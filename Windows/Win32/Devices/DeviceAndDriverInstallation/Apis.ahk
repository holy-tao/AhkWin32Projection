#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\..\Win32Handle.ahk
#Include .\HDEVINFO.ahk
#Include ..\..\System\Registry\HKEY.ahk
#Include ..\..\UI\Controls\HPROPSHEETPAGE.ahk

/**
 * @namespace Windows.Win32.Devices.DeviceAndDriverInstallation
 * @version v4.0.30319
 */
class DeviceAndDriverInstallation {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V1 => 37

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V2 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V3 => 51

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V4 => 52

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V5 => 53

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V6 => 54

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V7 => 55

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V8 => 57

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V9 => 58

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB => 58

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_FORCECONFIG => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_BOOTCONFIG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_DESIRED => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_NORMAL => 12288

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_LASTBESTCONFIG => 16383

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_SUBOPTIMAL => 20480

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_LASTSOFTCONFIG => 32767

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_RESTART => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_REBOOT => 36864

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_POWEROFF => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_HARDRECONFIG => 49152

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_HARDWIRED => 57344

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_IMPOSSIBLE => 61440

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_DISABLED => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LCPRI => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_TOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_BOTTOM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_LEFT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_RIGHT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_FRONT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_BACK => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_TOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_BOTTOM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_LEFT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_RIGHT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SHAPE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SHAPE_RECTANGLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SHAPE_OVAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_ORIENTATION_HORIZONTAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_ORIENTATION_VERTICAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_PLANAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_HINGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_PIVOT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_SWIVEL => 4

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_1394 => "{6bdd1fc1-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_1394DEBUG => "{66f250d6-7801-4a64-b139-eea80a450b24}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_61883 => "{7ebefbc0-3200-11d2-b4c2-00a0c9697d07}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_ADAPTER => "{4d36e964-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_APMSUPPORT => "{d45b1c18-c8fa-11d1-9f77-0000f805f530}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_AUDIOPROCESSINGOBJECT => "{5989fce8-9cd0-467d-8a6a-5419e31529d4}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_AVC => "{c06ff265-ae09-48f0-812c-16753d7cba83}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_BATTERY => "{72631e54-78a4-11d0-bcf7-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_BIOMETRIC => "{53d29ef7-377c-4d14-864b-eb3a85769359}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_BLUETOOTH => "{e0cbf06c-cd8b-4647-bb8a-263b43f0f974}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_CAMERA => "{ca3e7ab9-b4c3-4ae6-8251-579ef933890f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_CDROM => "{4d36e965-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_COMPUTEACCELERATOR => "{f01a9d53-3ff6-48d2-9f97-c8a7004be10c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_COMPUTER => "{4d36e966-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DECODER => "{6bdd1fc2-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DISKDRIVE => "{4d36e967-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DISPLAY => "{4d36e968-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DOT4 => "{48721b56-6795-11d2-b1a8-0080c72e74a2}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DOT4PRINT => "{49ce6ac8-6f86-11d2-b1e5-0080c72e74a2}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_EHSTORAGESILO => "{9da2b80f-f89f-4a49-a5c2-511b085b9e8a}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_ENUM1394 => "{c459df55-db08-11d1-b009-00a0c9081ff6}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_EXTENSION => "{e2f84ce7-8efa-411c-aa69-97454ca4cb57}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FDC => "{4d36e969-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FIRMWARE => "{f2e7dd72-6468-4e36-b6f1-6488f42c1b52}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FLOPPYDISK => "{4d36e980-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_GENERIC => "{ff494df1-c4ed-4fac-9b3f-3786f6e91e7e}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_GPS => "{6bdd1fc3-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_HDC => "{4d36e96a-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_HIDCLASS => "{745a17a0-74d3-11d0-b6fe-00a0c90f57da}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_HOLOGRAPHIC => "{d612553d-06b1-49ca-8938-e39ef80eb16f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_I3C => "{13cfe1b1-6b17-424c-ac3f-16ace8733898}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_IMAGE => "{6bdd1fc6-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_INFINIBAND => "{30ef7132-d858-4a0c-ac24-b9028a5cca3f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_INFRARED => "{6bdd1fc5-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_KEYBOARD => "{4d36e96b-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_LEGACYDRIVER => "{8ecc055d-047f-11d1-a537-0000f8753ed1}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MEDIA => "{4d36e96c-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MEDIUM_CHANGER => "{ce5939ae-ebde-11d0-b181-0000f8753ec4}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MEMORY => "{5099944a-f6b9-4057-a056-8c550228544c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MODEM => "{4d36e96d-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MONITOR => "{4d36e96e-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MOUSE => "{4d36e96f-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MTD => "{4d36e970-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MULTIFUNCTION => "{4d36e971-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MULTIPORTSERIAL => "{50906cb8-ba12-11d1-bf5d-0000f805f530}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NET => "{4d36e972-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETCLIENT => "{4d36e973-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETDRIVER => "{87ef9ad1-8f70-49ee-b215-ab1fcadcbe3c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETSERVICE => "{4d36e974-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETTRANS => "{4d36e975-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETUIO => "{78912bc1-cb8e-4b28-a329-f322ebadbe0f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NODRIVER => "{4d36e976-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PCMCIA => "{4d36e977-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PNPPRINTERS => "{4658ee7e-f050-11d1-b6bd-00c04fa372a7}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PORTS => "{4d36e978-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PRIMITIVE => "{242681d1-eed3-41d2-a1ef-1468fc843106}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PRINTER => "{4d36e979-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PRINTERUPGRADE => "{4d36e97a-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PRINTQUEUE => "{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PROCESSOR => "{50127dc3-0f36-415e-a6cc-4cb3be910b65}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SBP2 => "{d48179be-ec20-11d1-b6b8-00c04fa372a7}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SCMDISK => "{53966cb1-4d46-4166-bf23-c522403cd495}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SCMVOLUME => "{53ccb149-e543-4c84-b6e0-bce4f6b7e806}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SCSIADAPTER => "{4d36e97b-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SECURITYACCELERATOR => "{268c95a1-edfe-11d3-95c3-0010dc4050a5}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SENSOR => "{5175d334-c371-4806-b3ba-71fd53c9258d}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SIDESHOW => "{997b5d8d-c442-4f2e-baf3-9c8e671e9e21}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SMARTCARDREADER => "{50dd5230-ba8a-11d1-bf5d-0000f805f530}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SMRDISK => "{53487c23-680f-4585-acc3-1f10d6777e82}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SMRVOLUME => "{53b3cf03-8f5a-4788-91b6-d19ed9fcccbf}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SOFTWARECOMPONENT => "{5c4c3332-344d-483c-8739-259e934c9cc8}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SOUND => "{4d36e97c-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SYSTEM => "{4d36e97d-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_TAPEDRIVE => "{6d807884-7d21-11cf-801c-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_UNKNOWN => "{4d36e97e-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_UCM => "{e6f1aa1c-7f3b-4473-b2e8-c97d8ac71d53}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_USB => "{36fc9e60-c465-11cf-8056-444553540000}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_VOLUME => "{71a27cdd-812a-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_VOLUMESNAPSHOT => "{533c5b84-ec70-11d2-9505-00c04f79deaf}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_WCEUSBS => "{25dbce51-6c8f-4a72-8a6d-b54c2b4fc835}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_WPD => "{eec5ad98-8080-425f-922a-dabf3de3f69a}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_TOP => "{b369baf4-5568-4e82-a87e-a93eb16bca87}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_ACTIVITYMONITOR => "{b86dff51-a31e-4bac-b3cf-e8cfe75c9fc2}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_UNDELETE => "{fe8f1572-c67a-48c0-bbac-0b5c6d66cafb}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_ANTIVIRUS => "{b1d1a169-c54f-4379-81db-bee7d88d7454}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_REPLICATION => "{48d3ebc4-4cf8-48ff-b869-9c68ad42eb9f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_CONTINUOUSBACKUP => "{71aa14f8-6fad-4622-ad77-92bb9d7e6947}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_CONTENTSCREENER => "{3e3f0674-c83c-4558-bb26-9820e1eba5c5}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_QUOTAMANAGEMENT => "{8503c911-a6c7-4919-8f79-5028f5866b0c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_SYSTEMRECOVERY => "{2db15374-706e-4131-a0c7-d7c78eb0289a}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_CFSMETADATASERVER => "{cdcf0939-b75b-4630-bf76-80f7ba655884}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_HSM => "{d546500a-2aeb-45f6-9482-f4b1799c3177}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_COMPRESSION => "{f3586baf-b5aa-49b5-8d6c-0569284c639f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_ENCRYPTION => "{a0a701c0-a511-42ff-aa6c-06dc0395576f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_VIRTUALIZATION => "{f75a86c0-10d8-4c3a-b233-ed60e4cdfaac}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_PHYSICALQUOTAMANAGEMENT => "{6a0a8e78-bba6-4fc4-a709-1e33cd09d67e}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_OPENFILEBACKUP => "{f8ecafa6-66d1-41a5-899b-66585d7216b7}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_SECURITYENHANCER => "{d02bc3da-0c8e-4945-9bd5-f1883c226c8c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_COPYPROTECTION => "{89786ff1-9c12-402f-9c9e-17753c7f4375}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_BOTTOM => "{37765ea0-5958-4fc9-b04b-2fdfef97e59e}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_SYSTEM => "{5d1b9aaa-01e2-46af-849f-272b3f324c46}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_INFRASTRUCTURE => "{e55fa6f9-128c-4d04-abab-630c74b1453a}"

    /**
     * @type {Integer (UInt32)}
     */
    static LINE_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INF_STRING_LENGTH => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INF_SECTION_NAME_LENGTH => 255

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_TITLE_LEN => 60

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INSTRUCTION_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LABEL_LEN => 30

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SERVICE_NAME_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SUBTITLE_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SP_MAX_MACHINENAME_LENGTH => 263

    /**
     * @type {Integer (UInt32)}
     */
    static SP_ALTPLATFORM_FLAGS_VERSION_RANGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SP_ALTPLATFORM_FLAGS_SUITE_MASK => 2

    /**
     * @type {Integer (Int32)}
     */
    static DIRID_ABSOLUTE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_ABSOLUTE_16BIT => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_NULL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SRCPATH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_WINDOWS => 10

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SYSTEM => 11

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_DRIVERS => 12

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_IOSUBSYS => 12

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_DRIVER_STORE => 13

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_INF => 17

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_HELP => 18

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_FONTS => 20

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_VIEWERS => 21

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COLOR => 23

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_APPS => 24

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SHARED => 25

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_BOOT => 30

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SYSTEM16 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SPOOL => 51

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SPOOLDRIVERS => 52

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_USERPROFILE => 53

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_LOADER => 54

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PRINTPROCESSOR => 55

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_DEFAULT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_STARTMENU => 16406

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_PROGRAMS => 16407

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_STARTUP => 16408

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_DESKTOPDIRECTORY => 16409

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_FAVORITES => 16415

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_APPDATA => 16419

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PROGRAM_FILES => 16422

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SYSTEM_X86 => 16425

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PROGRAM_FILES_X86 => 16426

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PROGRAM_FILES_COMMON => 16427

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PROGRAM_FILES_COMMONX86 => 16428

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_TEMPLATES => 16429

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_DOCUMENTS => 16430

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_USER => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTQUEUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDQUEUE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTSUBQUEUE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDSUBQUEUE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTDELETE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDDELETE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_DELETEERROR => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTRENAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDRENAME => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_RENAMEERROR => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTCOPY => 11

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDCOPY => 12

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_COPYERROR => 13

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_NEEDMEDIA => 14

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_QUEUESCAN => 15

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_CABINETINFO => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_FILEINCABINET => 17

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_NEEDNEWCABINET => 18

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_FILEEXTRACTED => 19

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_FILEOPDELAYED => 20

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTBACKUP => 21

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_BACKUPERROR => 22

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDBACKUP => 23

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_QUEUESCAN_EX => 24

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTREGISTRATION => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDREGISTRATION => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_QUEUESCAN_SIGNERINFO => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_LANGMISMATCH => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_TARGETEXISTS => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_TARGETNEWER => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_RENAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_BACKUP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_ABORT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_DOIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_SKIP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_RETRY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_NEWPATH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_WARN_IF_SKIP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NOSKIP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NOVERSIONCHECK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_FORCE_FILE_IN_USE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NO_OVERWRITE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NO_VERSION_DIALOG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_OVERWRITE_OLDER_ONLY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_PROTECTED_WINDOWS_DRIVER_FILE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_REPLACEONLY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NODECOMP => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_REPLACE_BOOT_FILE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NOPRUNE => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_IN_USE_TRY_RENAME => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static DELFLG_IN_USE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DELFLG_IN_USE1 => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_SUCCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_LOADLIBRARY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_GETPROCADDR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_REGSVR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_DLLINSTALL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_TIMEOUT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_UNKNOWN => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static SPINT_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPINT_DEFAULT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPINT_REMOVED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPID_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPID_DEFAULT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPID_REMOVED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ENABLECLASS_QUERY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ENABLECLASS_SUCCESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ENABLECLASS_FAILURE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INSTALLWIZARD_DYNAPAGES => 20

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_DIDFACTDEFS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_HARDWAREALLREADYIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_NEEDSHUTDOWN => 512

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_EXPRESSINTRO => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_SKIPISDEVINSTALLED => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_NODETECTEDDEVS => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_INSTALLSPECIFIC => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_SKIPCLASSLIST => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_CI_PICKED_OEM => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_PCMCIAMODE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_PCMCIADEVICE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_USERCANCEL => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_KNOWNCLASS => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static DYNAWIZ_FLAG_PAGESADDED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static DYNAWIZ_FLAG_INSTALLDET_NEXT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DYNAWIZ_FLAG_INSTALLDET_PREV => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MIN_IDD_DYNAWIZ_RESOURCE_ID => 10000

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IDD_DYNAWIZ_RESOURCE_ID => 11000

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_FIRSTPAGE => 10000

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_SELECT_PREVPAGE => 10001

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_SELECT_NEXTPAGE => 10002

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_ANALYZE_PREVPAGE => 10003

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_ANALYZE_NEXTPAGE => 10004

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_SELECTDEV_PAGE => 10009

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_ANALYZEDEV_PAGE => 10010

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE => 10011

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_SELECTCLASS_PAGE => 10012

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE => 10006

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE => 10007

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_INSTALLDETECTED_NODEVS => 10008

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_HARDWAREID_RANK => 4095

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_HARDWAREID_MASK => 2147487743

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_UNTRUSTED_RANK => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_W9X_SUSPECT_RANK => 3221225472

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_COMPATID_RANK => 16383

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_UNTRUSTED_HARDWAREID_RANK => 36863

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_UNTRUSTED_COMPATID_RANK => 49151

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_W9X_SUSPECT_HARDWAREID_RANK => 53247

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_W9X_SUSPECT_COMPATID_RANK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static SPPSR_SELECT_DEVICE_RESOURCES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPPSR_ENUM_BASIC_DEVICE_PROPERTIES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPPSR_ENUM_ADV_DEVICE_PROPERTIES => 3

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_INF_SPEC_IS_HINF => 1

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_INF_NAME_IS_ABSOLUTE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_DEFAULT_SEARCH => 3

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_REVERSE_DEFAULT_SEARCH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_INF_PATH_LIST_SEARCH => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_TEMPORARY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_NOBROWSE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_SYSTEM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_USER => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_SYSIFADMIN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_SUBDIRS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_APPEND => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_NOSTRIPPLATFORM => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOBROWSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOSKIP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NODETAILS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOCOMPRESSED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_CHECKFIRST => 256

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOBEEP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOFOREGROUND => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_WARNIFSKIP => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOREMOVABLEMEDIAPROMPT => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_USEDISKNAMEASPROMPT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_OEMDISK => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_SUCCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_CANCEL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_SKIPFILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_BUFFERTOOSMALL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_OUTOFMEMORY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SETDIRID_NOT_FULL_PATH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_PATH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_TAGFILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_DESCRIPTION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_FLAGS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_TAGFILE2 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SRC_FLAGS_CABFILE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SP_FLAG_CABINETCONTINUATION => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SP_BACKUP_BACKUPPASS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SP_BACKUP_DEMANDPASS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SP_BACKUP_SPECIAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SP_BACKUP_BOOTFILE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_DELAYED_COPY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_BACKUP_AWARE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_ABORT_IF_UNSIGNED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_FILES_MODIFIED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_DO_SHUFFLEMOVE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_VALID => 15

    /**
     * @type {Integer (UInt32)}
     */
    static SPOST_MAX => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SUOI_FORCEDELETE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SUOI_INTERNAL1 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPDSL_IGNORE_DISK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPDSL_DISALLOW_NEGATIVE_ADJUST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILEQ_FILE_IN_USE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILEQ_REBOOT_RECOMMENDED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILEQ_REBOOT_IN_PROGRESS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_DELREG_BIT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_BINVALUETYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_NOCLOBBER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_DELVAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_APPEND => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_KEYONLY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_OVERWRITEONLY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_64BITKEY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_KEYONLY_COMMON => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_32BITKEY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_TYPE_SZ => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_TYPE_MULTI_SZ => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_TYPE_EXPAND_SZ => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_VALUE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_TYPE_SZ => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_TYPE_MULTI_SZ => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_TYPE_EXPAND_SZ => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_64BITKEY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_KEYONLY_COMMON => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_32BITKEY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_OPERATION_MASK => 254

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_BITREG_CLEARBITS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_BITREG_SETBITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_BITREG_64BITKEY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_BITREG_32BITKEY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_INI2REG_64BITKEY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_INI2REG_32BITKEY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_REGSVR_DLLREGISTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_REGSVR_DLLINSTALL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_PROFITEM_CURRENTUSER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_PROFITEM_DELETE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_PROFITEM_GROUP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_PROFITEM_CSIDL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_NOCLOBBER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_OVERWRITEONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_APPEND => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_OR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_AND => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELPROPERTY_MULTI_SZ_DELSTRING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_LOGCONFIG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_INIFILES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_REGISTRY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_INI2REG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_FILES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_BITREG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_REGSVR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_UNREGSVR => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_PROFILEITEMS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_COPYINF => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_PROPERTIES => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_ALL => 2047

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_SINGLESECTION => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_LOGCONFIG_IS_FORCED => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_LOGCONFIGS_ARE_OVERRIDES => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_REGISTERCALLBACKAWARE => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_DEVICEINSTALL => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILELOG_SYSTEMLOG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILELOG_FORCENEW => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILELOG_QUERYONLY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILELOG_OEMFILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevInformation => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevWarning => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevError => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevFatalError => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevMaximum => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DIOD_INHERIT_CLASSDRVS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIOD_CANCEL_REMOVE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DIODI_NO_ADD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPRDI_FIND_DUPS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPDIT_NODRIVER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DIBCI_NOINSTALLCLASS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIBCI_NODISPLAYCLASS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIOCR_INSTALLER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIOCR_INTERFACE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIREG_DEV => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIREG_DRV => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIREG_BOTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DICLASSPROP_INSTALLER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DICLASSPROP_INTERFACE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_UPPERFILTERS => 17

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_LOWERFILTERS => 18

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_SECURITY => 23

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_SECURITY_SDS => 24

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_DEVTYPE => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_EXCLUSIVE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_CHARACTERISTICS => 27

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_MAXIMUM_PROPERTY => 28

    /**
     * @type {Integer (UInt32)}
     */
    static DMI_MASK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DMI_BKCOLOR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DMI_USERECT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DIGCDP_FLAG_BASIC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIGCDP_FLAG_ADVANCED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIGCDP_FLAG_REMOTE_BASIC => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DIGCDP_FLAG_REMOTE_ADVANCED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCEFIRST => 159

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCE => 159

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCELAST => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCEOVERLAYFIRST => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCEOVERLAYLAST => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_CONFLICT => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_CLASSICON_OVERLAYFIRST => 500

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_CLASSICON_OVERLAYLAST => 502

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_PROBLEM_OVL => 500

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_DISABLED_OVL => 501

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_FORCED_OVL => 502

    /**
     * @type {Integer (UInt32)}
     */
    static SPWPT_SELECTDEVICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPWP_USE_DEVINFO_DATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_UNKNOWN => 4278190080

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_W9X_SUSPECT => 3221225472

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_UNSIGNED => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_AUTHENTICODE => 251658240

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_WHQL => 218103813

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_UNCLASSIFIED => 218103812

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_INBOX => 218103811

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_LOGO_STANDARD => 218103810

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_LOGO_PREMIUM => 218103809

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_MASK => 4278190080

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_SIGNED_MASK => 4026531840

    /**
     * @type {Integer (UInt32)}
     */
    static DICUSTOMDEVPROP_MERGE_MULTISZ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SCWMI_CLOBBER_SECURITY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DEVICE_ID_LEN => 200

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DEVNODE_ID_LEN => 200

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_GUID_STRING_LEN => 39

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_CLASS_NAME_LEN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_PROFILE_LEN => 80

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_CONFIG_VALUE => 9999

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INSTANCE_VALUE => 9999

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MEM_REGISTERS => 9

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IO_PORTS => 20

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IRQS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DMA_CHANNELS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static DWORD_MAX => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CONFIGMG_VERSION => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IO_ALIAS_10_BIT_DECODE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IO_ALIAS_12_BIT_DECODE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IO_ALIAS_16_BIT_DECODE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IO_ALIAS_POSITIVE_DECODE => 255

    /**
     * @type {Integer (UInt32)}
     */
    static IOA_Local => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CM_RESDES_WIDTH_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_RESDES_WIDTH_32 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_RESDES_WIDTH_64 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_RESDES_WIDTH_BITS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PCD_MAX_MEMORY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PCD_MAX_IO => 2

    /**
     * @type {Integer (UInt32)}
     */
    static mPMF_AUDIO_ENABLE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_HWPI_NOT_DOCKABLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_HWPI_UNDOCKED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_HWPI_DOCKED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_RANGE_ADDIFCONFLICT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_RANGE_DONOTADDIFCONFLICT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_RANGE_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOG_CONF_BITS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PRIORITY_EQUAL_FIRST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PRIORITY_EQUAL_LAST => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PRIORITY_BIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RegDisposition_OpenAlways => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RegDisposition_OpenExisting => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RegDisposition_Bits => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_ID_HARDWARE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_ID_COMPATIBLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_ID_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_NO_WAIT_INSTALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_PHANTOM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_GENERATE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_DO_NOT_INSTALL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_BITS => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_NO_WAIT_INSTALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_PHANTOM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_GENERATE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_DO_NOT_INSTALL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_BITS => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DELETE_CLASS_ONLY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DELETE_CLASS_SUBKEYS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DELETE_CLASS_INTERFACE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DELETE_CLASS_BITS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_NEW_PROFILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_CRASHED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_HWPROF_FIRST_BOOT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_RUN => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_BITS => 2147483655

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_POLITE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_ABSOLUTE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_HARDWARE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_UI_NOT_OK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_PERSIST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_BITS => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_ENUMERATOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_SERVICE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_EJECTRELATIONS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_REMOVALRELATIONS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_POWERRELATIONS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_BUSRELATIONS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_DONOTGENERATE => 268435520

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_BITS => 268435583

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_TRANSPORTRELATIONS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_PRESENT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_CLASS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_DEVICEDESC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_HARDWAREID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_COMPATIBLEIDS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UNUSED0 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_SERVICE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UNUSED1 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UNUSED2 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CLASS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CLASSGUID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_DRIVER => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CONFIGFLAGS => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_MFG => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_FRIENDLYNAME => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_LOCATION_INFORMATION => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CAPABILITIES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UI_NUMBER => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UPPERFILTERS => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_UPPERFILTERS => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_LOWERFILTERS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_LOWERFILTERS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_BUSTYPEGUID => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_LEGACYBUSTYPE => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_BUSNUMBER => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_ENUMERATOR_NAME => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_SECURITY => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_SECURITY => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_SECURITY_SDS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_SECURITY_SDS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_DEVTYPE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_DEVTYPE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_EXCLUSIVE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_EXCLUSIVE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CHARACTERISTICS => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_CHARACTERISTICS => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_ADDRESS => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UI_NUMBER_DESC_FORMAT => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_DEVICE_POWER_DATA => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_REMOVAL_POLICY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_REMOVAL_POLICY_HW_DEFAULT => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_REMOVAL_POLICY_OVERRIDE => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_INSTALL_STATE => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_LOCATION_PATHS => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_BASE_CONTAINERID => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_MIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_MIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_MAX => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_MAX => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CM_OPEN_CLASS_KEY_INSTALLER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_OPEN_CLASS_KEY_INTERFACE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_OPEN_CLASS_KEY_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_UI_OK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_UI_NOT_OK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_NO_RESTART => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_DISABLE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_BITS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_REMOVE_UI_OK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_REMOVE_UI_NOT_OK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTER_DEVICE_DRIVER_STATIC => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTER_DEVICE_DRIVER_DISABLEABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTER_DEVICE_DRIVER_REMOVABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTER_DEVICE_DRIVER_BITS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_HARDWARE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_SOFTWARE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_USER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_CONFIG => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_BITS => 769

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVNODE_PROBLEM_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVNODE_PROBLEM_OVERRIDE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVNODE_PROBLEM_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVINST_PROBLEM_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVINST_PROBLEM_OVERRIDE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVINST_PROBLEM_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_HW_PROF_FLAGS_UI_NOT_OK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_HW_PROF_FLAGS_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_READY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_READY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DOWNLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_WRITE_LOG_CONFS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_PROP_CHANGE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_RESET => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_RESET => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_CONFIG => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_CONFIG => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_CONFIG_CLASS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_CONFIG_CLASS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_CONFIG_EXTENSIONS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_CONFIG_EXTENSIONS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_CONFIG_RESET => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_CONFIG_RESET => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_BITS => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_ARBITRATOR_RAW => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_ARBITRATOR_TRANSLATED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_ARBITRATOR_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CUSTOMDEVPROP_MERGE_MULTISZ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CUSTOMDEVPROP_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_NAME_ATTRIBUTE_NAME_RETRIEVED_FROM_DEVICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_NAME_ATTRIBUTE_USER_ASSIGNED_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CLASS_PROPERTY_INSTALLER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CLASS_PROPERTY_INTERFACE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CLASS_PROPERTY_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_NOTIFY_FILTER_FLAG_ALL_INTERFACE_CLASSES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_NOTIFY_FILTER_FLAG_ALL_DEVICE_INSTANCES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_CAN_DO_UI => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_ON_BIG_STACK => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_SERVICES_AVAILABLE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_SHUTTING_DOWN => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_DETECTION_PENDING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_REBOOT_REQUIRED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_KEY_LEN => 100

    /**
     * @type {String}
     */
    static SZ_KEY_OPTIONDESC => "OptionDesc"

    /**
     * @type {String}
     */
    static SZ_KEY_LDIDOEM => "LdidOEM"

    /**
     * @type {String}
     */
    static SZ_KEY_SRCDISKFILES => "SourceDisksFiles"

    /**
     * @type {String}
     */
    static SZ_KEY_SRCDISKNAMES => "SourceDisksNames"

    /**
     * @type {String}
     */
    static SZ_KEY_STRINGS => "Strings"

    /**
     * @type {String}
     */
    static SZ_KEY_DESTDIRS => "DestinationDirs"

    /**
     * @type {String}
     */
    static SZ_KEY_LAYOUT_FILE => "LayoutFile"

    /**
     * @type {String}
     */
    static SZ_KEY_DEFDESTDIR => "DefaultDestDir"

    /**
     * @type {String}
     */
    static SZ_KEY_LFN_SECTION => "VarLDID.LFN"

    /**
     * @type {String}
     */
    static SZ_KEY_SFN_SECTION => "VarLDID.SFN"

    /**
     * @type {String}
     */
    static SZ_KEY_UPDATEINIS => "UpdateInis"

    /**
     * @type {String}
     */
    static SZ_KEY_UPDATEINIFIELDS => "UpdateIniFields"

    /**
     * @type {String}
     */
    static SZ_KEY_INI2REG => "Ini2Reg"

    /**
     * @type {String}
     */
    static SZ_KEY_COPYFILES => "CopyFiles"

    /**
     * @type {String}
     */
    static SZ_KEY_RENFILES => "RenFiles"

    /**
     * @type {String}
     */
    static SZ_KEY_DELFILES => "DelFiles"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDREG => "AddReg"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDREGNOCLOBBER => "AddRegNoClobber"

    /**
     * @type {String}
     */
    static SZ_KEY_DELREG => "DelReg"

    /**
     * @type {String}
     */
    static SZ_KEY_BITREG => "BitReg"

    /**
     * @type {String}
     */
    static SZ_KEY_COPYINF => "CopyINF"

    /**
     * @type {String}
     */
    static SZ_KEY_LOGCONFIG => "LogConfig"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDSERVICE => "AddService"

    /**
     * @type {String}
     */
    static SZ_KEY_DELSERVICE => "DelService"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDTRIGGER => "AddTrigger"

    /**
     * @type {String}
     */
    static SZ_KEY_FAILUREACTIONS => "FailureActions"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDINTERFACE => "AddInterface"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDIME => "AddIme"

    /**
     * @type {String}
     */
    static SZ_KEY_DELIME => "DelIme"

    /**
     * @type {String}
     */
    static SZ_KEY_REGSVR => "RegisterDlls"

    /**
     * @type {String}
     */
    static SZ_KEY_UNREGSVR => "UnregisterDlls"

    /**
     * @type {String}
     */
    static SZ_KEY_PROFILEITEMS => "ProfileItems"

    /**
     * @type {String}
     */
    static SZ_KEY_MODULES => "Modules"

    /**
     * @type {String}
     */
    static SZ_KEY_DEFAULTOPTION => "DefaultOption"

    /**
     * @type {String}
     */
    static SZ_KEY_LISTOPTIONS => "ListOptions"

    /**
     * @type {String}
     */
    static SZ_KEY_CLEANONLY => "CleanOnly"

    /**
     * @type {String}
     */
    static SZ_KEY_UPGRADEONLY => "UpgradeOnly"

    /**
     * @type {String}
     */
    static SZ_KEY_EXCLUDEID => "ExcludeId"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDPOWERSETTING => "AddPowerSetting"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDPROP => "AddProperty"

    /**
     * @type {String}
     */
    static SZ_KEY_DELPROP => "DelProperty"

    /**
     * @type {String}
     */
    static SZ_KEY_FEATURESCORE => "FeatureScore"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDEVENTPROVIDER => "AddEventProvider"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDCOMSERVER => "AddComServer"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDCOMCLASS => "AddComClass"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDCHANNEL => "AddChannel"

    /**
     * @type {String}
     */
    static SZ_KEY_IMPORTCHANNEL => "ImportChannel"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDAUTOLOGGER => "AddAutoLogger"

    /**
     * @type {String}
     */
    static SZ_KEY_UPDATEAUTOLOGGER => "UpdateAutoLogger"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDAUTOLOGGERPROVIDER => "AddAutoLoggerProvider"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDFILTER => "AddFilter"

    /**
     * @type {String}
     */
    static SZ_KEY_FILTERLEVEL => "FilterLevel"

    /**
     * @type {String}
     */
    static SZ_KEY_FILTERPOSITION => "FilterPosition"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDCOMPONENT => "AddComponent"

    /**
     * @type {String}
     */
    static SZ_KEY_PHASE1 => "Phase1"

    /**
     * @type {String}
     */
    static SZ_KEY_HARDWARE => "Hardware"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CONFIGPRIORITY => "ConfigPriority"

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_PRIORITYSTR_LEN => 16

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_HARDWIRED => "HARDWIRED"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_DESIRED => "DESIRED"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_NORMAL => "NORMAL"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_SUBOPTIMAL => "SUBOPTIMAL"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_DISABLED => "DISABLED"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_RESTART => "RESTART"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_REBOOT => "REBOOT"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_POWEROFF => "POWEROFF"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_HARDRECONFIG => "HARDRECONFIG"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_FORCECONFIG => "FORCECONFIG"

    /**
     * @type {String}
     */
    static INFSTR_CFGTYPE_BASIC => "BASIC"

    /**
     * @type {String}
     */
    static INFSTR_CFGTYPE_FORCED => "FORCED"

    /**
     * @type {String}
     */
    static INFSTR_CFGTYPE_OVERRIDE => "OVERRIDE"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MEMCONFIG => "MemConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MEMLARGECONFIG => "MemLargeConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_IOCONFIG => "IOConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_IRQCONFIG => "IRQConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DMACONFIG => "DMAConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PCCARDCONFIG => "PcCardConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MFCARDCONFIG => "MfCardConfig"

    /**
     * @type {String}
     */
    static INFSTR_SECT_CLASS_INSTALL => "ClassInstall"

    /**
     * @type {String}
     */
    static INFSTR_SECT_CLASS_INSTALL_32 => "ClassInstall32"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DEFAULT_INSTALL => "DefaultInstall"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DEFAULT_UNINSTALL => "DefaultUninstall"

    /**
     * @type {String}
     */
    static INFSTR_SECT_INTERFACE_INSTALL_32 => "InterfaceInstall32"

    /**
     * @type {String}
     */
    static INFSTR_SECT_VERSION => "Version"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PROVIDER => "Provider"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SIGNATURE => "Signature"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DRIVERSET => "DriverSet"

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INF_FLAG => 20

    /**
     * @type {String}
     */
    static INFSTR_KEY_HARDWARE_CLASS => "Class"

    /**
     * @type {String}
     */
    static INFSTR_KEY_HARDWARE_CLASSGUID => "ClassGUID"

    /**
     * @type {String}
     */
    static INFSTR_KEY_NOSETUPINF => "NoSetupInf"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FROMINET => "FromINet"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CATALOGFILE => "CatalogFile"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PNPLOCKDOWN => "PnpLockDown"

    /**
     * @type {String}
     */
    static INFSTR_KEY_EXTENSIONID => "ExtensionId"

    /**
     * @type {String}
     */
    static INFSTR_SECT_MFG => "Manufacturer"

    /**
     * @type {String}
     */
    static INFSTR_SECT_TARGETCOMPUTERS => "TargetComputers"

    /**
     * @type {String}
     */
    static INFSTR_SECT_EXTENSIONCONTRACTS => "ExtensionContracts"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CLASS => "Class"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CLASSGUID => "ClassGUID"

    /**
     * @type {String}
     */
    static INFSTR_RESTART => "Restart"

    /**
     * @type {String}
     */
    static INFSTR_REBOOT => "Reboot"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DISPLAYNAME => "DisplayName"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SERVICETYPE => "ServiceType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_STARTTYPE => "StartType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ERRORCONTROL => "ErrorControl"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SERVICEBINARY => "ServiceBinary"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOADORDERGROUP => "LoadOrderGroup"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DEPENDENCIES => "Dependencies"

    /**
     * @type {String}
     */
    static INFSTR_KEY_REQUIREDPRIVILEGES => "RequiredPrivileges"

    /**
     * @type {String}
     */
    static INFSTR_KEY_STARTNAME => "StartName"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SECURITY => "Security"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DESCRIPTION => "Description"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SERVICESIDTYPE => "ServiceSidType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DELAYEDAUTOSTART => "DelayedAutoStart"

    /**
     * @type {String}
     */
    static INFSTR_KEY_BOOTFLAGS => "BootFlags"

    /**
     * @type {String}
     */
    static INFSTR_KEY_TRIGGER_TYPE => "TriggerType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ACTION => "Action"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SUB_TYPE => "SubType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DATA_ITEM => "DataItem"

    /**
     * @type {String}
     */
    static INFSTR_KEY_RESET_PERIOD => "ResetPeriod"

    /**
     * @type {String}
     */
    static INFSTR_KEY_NON_CRASH_FAILURES => "NonCrashFailures"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FAILURE_ACTION => "Action"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PROVIDER_NAME => "ProviderName"

    /**
     * @type {String}
     */
    static INFSTR_KEY_RESOURCE_FILE => "ResourceFile"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MESSAGE_FILE => "MessageFile"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PARAMETER_FILE => "ParameterFile"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COM_SERVER_TYPE => "ServerType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COM_SERVER_BINARY => "ServerBinary"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COM_SERVER_BINARY_WOW64 => "ServerBinaryWow64"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COM_SERVER_ADD_COM_CLASS => "AddComClass"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COM_CLASS_THREADING_MODEL => "ThreadingModel"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COM_CLASS_DESCRIPTION => "Description"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COMPONENTIDS => "ComponentIds"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CHANNEL_ACCESS => "Access"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CHANNEL_ISOLATION => "Isolation"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CHANNEL_ENABLED => "Enabled"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CHANNEL_VALUE => "Value"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOGGING_MAXSIZE => "LoggingMaxSize"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOGGING_RETENTION => "LoggingRetention"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOGGING_AUTOBACKUP => "LoggingAutoBackup"

    /**
     * @type {String}
     */
    static INFSTR_KEY_START => "Start"

    /**
     * @type {String}
     */
    static INFSTR_KEY_BUFFER_SIZE => "BufferSize"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CLOCK_TYPE => "ClockType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DISABLE_REALTIME_PERSISTENCE => "DisableRealtimePersistence"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FILE_NAME => "FileName"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FILE_MAX => "FileMax"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FLUSH_TIMER => "FlushTimer"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOG_FILE_MODE => "LogFileMode"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MAX_FILE_SIZE => "MaxFileSize"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MAXIMUM_BUFFERS => "MaximumBuffers"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MINIMUM_BUFFERS => "MinimumBuffers"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ENABLED => "Enabled"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ENABLE_FLAGS => "EnableFlags"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ENABLE_LEVEL => "EnableLevel"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ENABLE_PROPERTY => "EnableProperty"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MATCH_ANY_KEYWORD => "MatchAnyKeyword"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MATCH_ALL_KEYWORD => "MatchAllKeyword"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DETMODULES => "Det.Modules"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DETCLASSINFO => "Det.ClassInfo"

    /**
     * @type {String}
     */
    static INFSTR_SECT_MANUALDEV => "Det.ManualDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_AVOIDCFGSYSDEV => "Det.AvoidCfgSysDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_REGCFGSYSDEV => "Det.RegCfgSysDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DEVINFS => "Det.DevINFs"

    /**
     * @type {String}
     */
    static INFSTR_SECT_AVOIDINIDEV => "Det.AvoidIniDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_AVOIDENVDEV => "Det.AvoidEnvDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_REGINIDEV => "Det.RegIniDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_REGENVDEV => "Det.RegEnvDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_HPOMNIBOOK => "Det.HPOmnibook"

    /**
     * @type {String}
     */
    static INFSTR_SECT_FORCEHWVERIFY => "Det.ForceHWVerify"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DETOPTIONS => "Det.Options"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADPNPBIOS => "BadPnpBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_GOODACPIBIOS => "GoodACPIBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADACPIBIOS => "BadACPIBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADROUTINGTABLEBIOS => "BadPCIIRQRoutingTableBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADPMCALLBIOS => "BadProtectedModeCallBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADRMCALLBIOS => "BadRealModeCallBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_MACHINEIDBIOS => "MachineIDBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADDISKBIOS => "BadDiskBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADDSBIOS => "BadDSBios"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DETPARAMS => "Params"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SKIPLIST => "SkipList"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DETECTLIST => "DetectList"

    /**
     * @type {String}
     */
    static INFSTR_KEY_EXCLUDERES => "ExcludeRes"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_LOGCONFIG => "LogConfig"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_DET => "Det"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_FACTDEF => "FactDef"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_POSSIBLEDUPS => "PosDup"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_NORESOURCEDUPS => "NoResDup"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_HW => "Hw"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_CTL => "CTL"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_SERVICES => "Services"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_SOFTWARE => "Software"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_INTERFACES => "Interfaces"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_COINSTALLERS => "CoInstallers"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_LOGCONFIGOVERRIDE => "LogConfigOverride"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_WMI => "WMI"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_EVENTS => "Events"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_COM => "COM"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_FILTERS => "Filters"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_COMPONENTS => "Components"

    /**
     * @type {String}
     */
    static INFSTR_CONTROLFLAGS_SECTION => "ControlFlags"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COPYFILESONLY => "CopyFilesOnly"

    /**
     * @type {String}
     */
    static INFSTR_KEY_EXCLUDEFROMSELECT => "ExcludeFromSelect"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ALWAYSEXCLUDEFROMSELECT => "AlwaysExcludeFromSelect"

    /**
     * @type {String}
     */
    static INFSTR_KEY_INTERACTIVEINSTALL => "InteractiveInstall"

    /**
     * @type {String}
     */
    static INFSTR_KEY_REQUESTADDITIONALSOFTWARE => "RequestAdditionalSoftware"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_WIN => "Win"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NT => "NT"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTX86 => "NTx86"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTMIPS => "NTMIPS"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTALPHA => "NTAlpha"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTPPC => "NTPPC"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTIA64 => "NTIA64"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTAXP64 => "NTAXP64"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTAMD64 => "NTAMD64"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTARM => "NTARM"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTARM64 => "NTARM64"

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INFSTR_STRKEY_LEN => 32

    /**
     * @type {String}
     */
    static INFSTR_STRKEY_DRVDESC => "DriverDesc"

    /**
     * @type {String}
     */
    static INFSTR_DRIVERSELECT_SECTION => "DriverSelect"

    /**
     * @type {String}
     */
    static INFSTR_DRIVERSELECT_FUNCTIONS => "DriverSelectFunctions"

    /**
     * @type {String}
     */
    static INFSTR_DRIVERVERSION_SECTION => "DriverVer"

    /**
     * @type {String}
     */
    static INFSTR_SOFTWAREVERSION_SECTION => "SoftwareVersion"

    /**
     * @type {String}
     */
    static INFSTR_SECT_CFGSYS => "ConfigSysDrivers"

    /**
     * @type {String}
     */
    static INFSTR_SECT_AUTOEXECBAT => "AutoexecBatDrivers"

    /**
     * @type {String}
     */
    static INFSTR_SECT_SYSINI => "SystemIniDrivers"

    /**
     * @type {String}
     */
    static INFSTR_SECT_SYSINIDRV => "SystemIniDriversLine"

    /**
     * @type {String}
     */
    static INFSTR_SECT_WININIRUN => "WinIniRunLine"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PATH => "Path"

    /**
     * @type {String}
     */
    static INFSTR_KEY_NAME => "Name"

    /**
     * @type {String}
     */
    static INFSTR_KEY_IO => "IO"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MEM => "Mem"

    /**
     * @type {String}
     */
    static INFSTR_KEY_IRQ => "IRQ"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DMA => "DMA"

    /**
     * @type {String}
     */
    static INFSTR_BUS_ISA => "BUS_ISA"

    /**
     * @type {String}
     */
    static INFSTR_BUS_EISA => "BUS_EISA"

    /**
     * @type {String}
     */
    static INFSTR_BUS_MCA => "BUS_MCA"

    /**
     * @type {String}
     */
    static INFSTR_BUS_ALL => "BUS_ALL"

    /**
     * @type {String}
     */
    static INFSTR_RISK_NONE => "RISK_NONE"

    /**
     * @type {String}
     */
    static INFSTR_RISK_VERYLOW => "RISK_VERYLOW"

    /**
     * @type {String}
     */
    static INFSTR_RISK_BIOSROMRD => "RISK_BIOSROMRD"

    /**
     * @type {String}
     */
    static INFSTR_RISK_QUERYDRV => "RISK_QUERYDRV"

    /**
     * @type {String}
     */
    static INFSTR_RISK_SWINT => "RISK_SWINT"

    /**
     * @type {String}
     */
    static INFSTR_RISK_LOW => "RISK_LOW"

    /**
     * @type {String}
     */
    static INFSTR_RISK_DELICATE => "RISK_DELICATE"

    /**
     * @type {String}
     */
    static INFSTR_RISK_MEMRD => "RISK_MEMRD"

    /**
     * @type {String}
     */
    static INFSTR_RISK_IORD => "RISK_IORD"

    /**
     * @type {String}
     */
    static INFSTR_RISK_MEMWR => "RISK_MEMWR"

    /**
     * @type {String}
     */
    static INFSTR_RISK_IOWR => "RISK_IOWR"

    /**
     * @type {String}
     */
    static INFSTR_RISK_UNRELIABLE => "RISK_UNRELIABLE"

    /**
     * @type {String}
     */
    static INFSTR_RISK_VERYHIGH => "RISK_VERYHIGH"

    /**
     * @type {String}
     */
    static INFSTR_CLASS_SAFEEXCL => "SAFE_EXCL"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DISPLAY_CLEANUP => "DisplayCleanup"

    /**
     * @type {String}
     */
    static GUID_HWPROFILE_QUERY_CHANGE => "{cb3a4001-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_HWPROFILE_CHANGE_CANCELLED => "{cb3a4002-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_HWPROFILE_CHANGE_COMPLETE => "{cb3a4003-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_DEVICE_INTERFACE_ARRIVAL => "{cb3a4004-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_DEVICE_INTERFACE_REMOVAL => "{cb3a4005-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_TARGET_DEVICE_QUERY_REMOVE => "{cb3a4006-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_TARGET_DEVICE_REMOVE_CANCELLED => "{cb3a4007-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_TARGET_DEVICE_REMOVE_COMPLETE => "{cb3a4008-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_PNP_CUSTOM_NOTIFICATION => "{aca73f8e-8d23-11d1-ac7d-0000f87571d0}"

    /**
     * @type {String}
     */
    static GUID_PNP_POWER_NOTIFICATION => "{c2cf0660-eb7a-11d1-bd7f-0000f87571d0}"

    /**
     * @type {String}
     */
    static GUID_PNP_POWER_SETTING_CHANGE => "{29c69b3e-c79a-43bf-bbde-a932fa1bea7e}"

    /**
     * @type {String}
     */
    static GUID_TARGET_DEVICE_TRANSPORT_RELATIONS_CHANGED => "{fcf528f6-a82f-47b1-ad3a-8050594cad28}"

    /**
     * @type {String}
     */
    static GUID_KERNEL_SOFT_RESTART_PREPARE => "{de373def-a85c-4f76-8cbf-f96bea8bd10f}"

    /**
     * @type {String}
     */
    static GUID_KERNEL_SOFT_RESTART_CANCEL => "{31d737e7-8c0b-468a-956e-9f433ec358fb}"

    /**
     * @type {String}
     */
    static GUID_RECOVERY_PCI_PREPARE_SHUTDOWN => "{90d889de-8704-44cf-8115-ed8528d2b2da}"

    /**
     * @type {String}
     */
    static GUID_RECOVERY_NVMED_PREPARE_SHUTDOWN => "{4b9770ea-bde7-400b-a9b9-4f684f54cc2a}"

    /**
     * @type {String}
     */
    static GUID_KERNEL_SOFT_RESTART_FINALIZE => "{20e91abd-350a-4d4f-8577-99c81507473a}"

    /**
     * @type {String}
     */
    static GUID_KERNEL_SOFT_RESTART_PRE_COMPLETE => "{af855082-530b-4a85-b5a6-120b63089451}"

    /**
     * @type {String}
     */
    static GUID_BUS_INTERFACE_STANDARD => "{496b8280-6f25-11d0-beaf-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_PCI_BUS_INTERFACE_STANDARD => "{496b8281-6f25-11d0-beaf-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_PCI_BUS_INTERFACE_STANDARD2 => "{de94e966-fdff-4c9c-9998-6747b150e74c}"

    /**
     * @type {String}
     */
    static GUID_ARBITER_INTERFACE_STANDARD => "{e644f185-8c0e-11d0-becf-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_TRANSLATOR_INTERFACE_STANDARD => "{6c154a92-aacf-11d0-8d2a-00a0c906b244}"

    /**
     * @type {String}
     */
    static GUID_ACPI_INTERFACE_STANDARD => "{b091a08a-ba97-11d0-bd14-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_INT_ROUTE_INTERFACE_STANDARD => "{70941bf4-0073-11d1-a09e-00c04fc340b1}"

    /**
     * @type {String}
     */
    static GUID_PCMCIA_BUS_INTERFACE_STANDARD => "{76173af0-c504-11d1-947f-00c04fb960ee}"

    /**
     * @type {String}
     */
    static GUID_ACPI_REGS_INTERFACE_STANDARD => "{06141966-7245-6369-462e-4e656c736f6e}"

    /**
     * @type {String}
     */
    static GUID_LEGACY_DEVICE_DETECTION_STANDARD => "{50feb0de-596a-11d2-a5b8-0000f81a4619}"

    /**
     * @type {String}
     */
    static GUID_PCI_DEVICE_PRESENT_INTERFACE => "{d1b82c26-bf49-45ef-b216-71cbd7889b57}"

    /**
     * @type {String}
     */
    static GUID_MF_ENUMERATION_INTERFACE => "{aeb895f0-5586-11d1-8d84-00a0c906b244}"

    /**
     * @type {String}
     */
    static GUID_REENUMERATE_SELF_INTERFACE_STANDARD => "{2aeb0243-6a6e-486b-82fc-d815f6b97006}"

    /**
     * @type {String}
     */
    static GUID_AGP_TARGET_BUS_INTERFACE_STANDARD => "{b15cfce8-06d1-4d37-9d4c-bedde0c2a6ff}"

    /**
     * @type {String}
     */
    static GUID_ACPI_CMOS_INTERFACE_STANDARD => "{3a8d0384-6505-40ca-bc39-56c15f8c5fed}"

    /**
     * @type {String}
     */
    static GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD => "{f14f609b-cbbd-4957-a674-bc00213f1c97}"

    /**
     * @type {String}
     */
    static GUID_ACPI_INTERFACE_STANDARD2 => "{e8695f63-1831-4870-a8cf-9c2f03f9dcb5}"

    /**
     * @type {String}
     */
    static GUID_PNP_LOCATION_INTERFACE => "{70211b0e-0afb-47db-afc1-410bf842497a}"

    /**
     * @type {String}
     */
    static GUID_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE => "{146cd41c-dae3-4437-8aff-2af3f038099b}"

    /**
     * @type {String}
     */
    static GUID_PCI_EXPRESS_ROOT_PORT_INTERFACE => "{83a7734a-84c7-4161-9a98-6000ed0c4a33}"

    /**
     * @type {String}
     */
    static GUID_MSIX_TABLE_CONFIG_INTERFACE => "{1a6a460b-194f-455d-b34b-b84c5b05712b}"

    /**
     * @type {String}
     */
    static GUID_D3COLD_SUPPORT_INTERFACE => "{b38290e5-3cd0-4f9d-9937-f5fe2b44d47a}"

    /**
     * @type {String}
     */
    static GUID_PROCESSOR_PCC_INTERFACE_STANDARD => "{37b17e9a-c21c-4296-972d-11c4b32b28f0}"

    /**
     * @type {String}
     */
    static GUID_PCI_VIRTUALIZATION_INTERFACE => "{64897b47-3a4a-4d75-bc74-89dd6c078293}"

    /**
     * @type {String}
     */
    static GUID_PCC_INTERFACE_STANDARD => "{3ee8ba63-0f59-4a24-8a45-35808bdd1249}"

    /**
     * @type {String}
     */
    static GUID_PCC_INTERFACE_INTERNAL => "{7cce62ce-c189-4814-a6a7-12112089e938}"

    /**
     * @type {String}
     */
    static GUID_THERMAL_COOLING_INTERFACE => "{ecbe47a8-c498-4bb9-bd70-e867e0940d22}"

    /**
     * @type {String}
     */
    static GUID_PCI_LINK_CONFIG_INTERFACE => "{67593984-7cc0-4760-8d01-cbffd2d080f7}"

    /**
     * @type {String}
     */
    static GUID_POWER_LIMIT_INTERFACE => "{3b96f4f2-ce49-44d1-91f8-652b8121e93a}"

    /**
     * @type {String}
     */
    static GUID_DMA_CACHE_COHERENCY_INTERFACE => "{b520f7fa-8a5a-4e40-a3f6-6be1e162d935}"

    /**
     * @type {String}
     */
    static GUID_DEVICE_RESET_INTERFACE_STANDARD => "{649fdf26-3bc0-4813-ad24-7e0c1eda3fa3}"

    /**
     * @type {String}
     */
    static GUID_IOMMU_BUS_INTERFACE => "{1efee0b2-d278-4ae4-bddc-1b34dd648043}"

    /**
     * @type {String}
     */
    static GUID_PCI_SECURITY_INTERFACE => "{6e7f1451-199e-4acc-ba2d-762b4edf4674}"

    /**
     * @type {String}
     */
    static GUID_SCM_BUS_INTERFACE => "{25944783-ce79-4232-815e-4a30014e8eb4}"

    /**
     * @type {String}
     */
    static GUID_SECURE_DRIVER_INTERFACE => "{370f67e1-4ff5-4a94-9a35-06c5d9cc30e2}"

    /**
     * @type {String}
     */
    static GUID_SDEV_IDENTIFIER_INTERFACE => "{49d67af8-916c-4ee8-9df1-889f17d21e91}"

    /**
     * @type {String}
     */
    static GUID_SCM_BUS_NVD_INTERFACE => "{8de064ff-b630-42e4-88ea-6f24c8641175}"

    /**
     * @type {String}
     */
    static GUID_SCM_BUS_LD_INTERFACE => "{9b89307d-d76b-4f48-b186-54041ae92e8d}"

    /**
     * @type {String}
     */
    static GUID_SCM_PHYSICAL_NVDIMM_INTERFACE => "{0079c21b-917e-405e-a9ce-0732b5bbcebd}"

    /**
     * @type {String}
     */
    static GUID_PNP_EXTENDED_ADDRESS_INTERFACE => "{b8e992ec-a797-4dc4-8846-84d041707446}"

    /**
     * @type {String}
     */
    static GUID_D3COLD_AUX_POWER_AND_TIMING_INTERFACE => "{0044d8aa-f664-4588-9ffc-2afeaf5950b9}"

    /**
     * @type {String}
     */
    static GUID_PCI_FPGA_CONTROL_INTERFACE => "{2df3f7a8-b9b3-4063-9215-b5d14a0b266e}"

    /**
     * @type {String}
     */
    static GUID_PCI_PTM_CONTROL_INTERFACE => "{348a5ebb-ba24-44b7-9916-285687735117}"

    /**
     * @type {String}
     */
    static GUID_BUS_RESOURCE_UPDATE_INTERFACE => "{27d0102d-bfb2-4164-81dd-dbb82f968b48}"

    /**
     * @type {String}
     */
    static GUID_NPEM_CONTROL_INTERFACE => "{4d95573d-b774-488a-b120-4f284a9eff51}"

    /**
     * @type {String}
     */
    static GUID_PCI_ATS_INTERFACE => "{010a7fe8-96f5-4943-bedf-95e651b93412}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_INTERNAL => "{1530ea73-086b-11d1-a09f-00c04fc340b1}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_PCMCIA => "{09343630-af9f-11d0-92e9-0000f81e1b30}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_PCI => "{c8ebdfb0-b510-11d0-80e5-00a0c92542e3}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_ISAPNP => "{e676f854-d87d-11d0-92b2-00a0c9055fc5}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_EISA => "{ddc35509-f3fc-11d0-a537-0000f8753ed1}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_MCA => "{1c75997a-dc33-11d0-92b2-00a0c9055fc5}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_SERENUM => "{77114a87-8944-11d1-bd90-00a0c906be2d}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_USB => "{9d7debbc-c85d-11d1-9eb4-006008c3a19a}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_LPTENUM => "{c4ca1000-2ddc-11d5-a17a-00c04f60524d}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_USBPRINT => "{441ee000-4342-11d5-a184-00c04f60524d}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_DOT4PRT => "{441ee001-4342-11d5-a184-00c04f60524d}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_1394 => "{f74e73eb-9ac5-45eb-be4d-772cc71ddfb3}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_HID => "{eeaf37d0-1963-47c4-aa48-72476db7cf49}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_AVC => "{c06ff265-ae09-48f0-812c-16753d7cba83}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_IRDA => "{7ae17dc1-c944-44d6-881f-4c2e61053bc1}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_SD => "{e700cc04-4036-4e89-9579-89ebf45f00cd}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_ACPI => "{d7b46895-001a-4942-891f-a7d46610a843}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_SW_DEVICE => "{06d10322-7de0-4cef-8e25-197d0e7442e2}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_SCM => "{375a5912-804c-45aa-bdc2-fdd25a1d9512}"

    /**
     * @type {String}
     */
    static GUID_POWER_DEVICE_ENABLE => "{827c0a6f-feb0-11d0-bd26-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_POWER_DEVICE_TIMEOUTS => "{a45da735-feb0-11d0-bd26-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_POWER_DEVICE_WAKE_ENABLE => "{a9546a82-feb0-11d0-bd26-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_WUDF_DEVICE_HOST_PROBLEM => "{c43d25bd-9346-40ee-a2d2-d70c15f8b75b}"

    /**
     * @type {String}
     */
    static GUID_PARTITION_UNIT_INTERFACE_STANDARD => "{52363f5b-d891-429b-8195-aec5fef6853c}"

    /**
     * @type {String}
     */
    static GUID_QUERY_CRASHDUMP_FUNCTIONS => "{9cc6b8ff-32e2-4834-b1de-b32ef8880a4b}"
;@endregion Constants

;@region Methods
    /**
     * The SetUpGetInfInformation function returns the SP_INF_INFORMATION structure for the specified INF file to a buffer.
     * @param {Pointer<Void>} InfSpec Handle or a file name for an INF file, depending on the value of <i>SearchControl</i>.
     * @param {Integer} SearchControl This parameter can be one of the following constants.
     * @param {Pointer} ReturnBuffer If not <b>NULL</b>, points to a buffer in which this function returns the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure. 
     * 
     * You can call the function one time to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. For more information, see the Remarks section of this topic.
     * @param {Integer} ReturnBufferSize Size of  <i>ReturnBuffer</i>, in bytes.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size, in bytes, for the buffer pointed to by <i>ReturnBuffer</i>. 
     * 
     * If <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the INF file cannot be located, the function returns <b>FALSE</b> and a subsequent call to 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_FILE_NOT_FOUND.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetinfinformationa
     * @since windows5.1.2600
     */
    static SetupGetInfInformationA(InfSpec, SearchControl, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfInformationA", "ptr", InfSpec, "uint", SearchControl, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetUpGetInfInformation function returns the SP_INF_INFORMATION structure for the specified INF file to a buffer.
     * @param {Pointer<Void>} InfSpec Handle or a file name for an INF file, depending on the value of <i>SearchControl</i>.
     * @param {Integer} SearchControl This parameter can be one of the following constants.
     * @param {Pointer} ReturnBuffer If not <b>NULL</b>, points to a buffer in which this function returns the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure. 
     * 
     * You can call the function one time to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. For more information, see the Remarks section of this topic.
     * @param {Integer} ReturnBufferSize Size of  <i>ReturnBuffer</i>, in bytes.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size, in bytes, for the buffer pointed to by <i>ReturnBuffer</i>. 
     * 
     * If <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the INF file cannot be located, the function returns <b>FALSE</b> and a subsequent call to 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_FILE_NOT_FOUND.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetinfinformationw
     * @since windows5.1.2600
     */
    static SetupGetInfInformationW(InfSpec, SearchControl, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfInformationW", "ptr", InfSpec, "uint", SearchControl, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfFileInformation function returns an INF filename from an SP_INF_INFORMATION structure to a buffer.
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF filename to retrieve. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {PSTR} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> is a pointer to a buffer in which this function returns the full INF filename. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, pointer to a variable that receives the required size for the <i>ReturnBuffer</i> buffer, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryinffileinformationa
     * @since windows5.1.2600
     */
    static SetupQueryInfFileInformationA(InfInformation, InfIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfFileInformationA", "ptr", InfInformation, "uint", InfIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfFileInformation function returns an INF filename from an SP_INF_INFORMATION structure to a buffer.
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF filename to retrieve. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {PWSTR} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> is a pointer to a buffer in which this function returns the full INF filename. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, pointer to a variable that receives the required size for the <i>ReturnBuffer</i> buffer, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryinffileinformationw
     * @since windows5.1.2600
     */
    static SetupQueryInfFileInformationW(InfInformation, InfIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfFileInformationW", "ptr", InfInformation, "uint", InfIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfOriginalFileInformation function returns the original name of an OEM INF file.
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF file name to retrieve. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Optional pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v1">SP_ALTPLATFORM_INFO_V1</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO_V2</a> structure used to pass information for an alternate platform to 
     * <b>SetupQueryInfOriginalFileInformation</b>.
     * @param {Pointer<SP_ORIGINAL_FILE_INFO_A>} OriginalFileInfo Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_original_file_info_a">SP_ORIGINAL_FILE_INFO</a> structure that receives the original INF file name and catalog file information returned by 
     * <b>SetupQueryInfOriginalFileInformation</b>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryinforiginalfileinformationa
     * @since windows5.1.2600
     */
    static SetupQueryInfOriginalFileInformationA(InfInformation, InfIndex, AlternatePlatformInfo, OriginalFileInfo) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfOriginalFileInformationA", "ptr", InfInformation, "uint", InfIndex, "ptr", AlternatePlatformInfo, "ptr", OriginalFileInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfOriginalFileInformation function returns the original name of an OEM INF file.
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF file name to retrieve. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Optional pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v1">SP_ALTPLATFORM_INFO_V1</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO_V2</a> structure used to pass information for an alternate platform to 
     * <b>SetupQueryInfOriginalFileInformation</b>.
     * @param {Pointer<SP_ORIGINAL_FILE_INFO_W>} OriginalFileInfo Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_original_file_info_a">SP_ORIGINAL_FILE_INFO</a> structure that receives the original INF file name and catalog file information returned by 
     * <b>SetupQueryInfOriginalFileInformation</b>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryinforiginalfileinformationw
     * @since windows5.1.2600
     */
    static SetupQueryInfOriginalFileInformationW(InfInformation, InfIndex, AlternatePlatformInfo, OriginalFileInfo) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfOriginalFileInformationW", "ptr", InfInformation, "uint", InfIndex, "ptr", AlternatePlatformInfo, "ptr", OriginalFileInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfVersionInformation function returns INF file version information from an SP_INF_INFORMATION structure to a buffer.
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure previously returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF file to retrieve version information from. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {PSTR} Key Optional pointer to a <b>null</b>-terminated string containing the key name whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all resource keys are copied to the supplied buffer. Each string is <b>null</b>-terminated, with an extra <b>null</b> at the end of the list.
     * @param {PSTR} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> points to a call-supplied character buffer in which this function returns the INF file style. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, pointer to a variable that receives the size required for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryinfversioninformationa
     * @since windows5.1.2600
     */
    static SetupQueryInfVersionInformationA(InfInformation, InfIndex, Key, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Key := Key is String ? StrPtr(Key) : Key
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfVersionInformationA", "ptr", InfInformation, "uint", InfIndex, "ptr", Key, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfVersionInformation function returns INF file version information from an SP_INF_INFORMATION structure to a buffer.
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure previously returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF file to retrieve version information from. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {PWSTR} Key Optional pointer to a <b>null</b>-terminated string containing the key name whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all resource keys are copied to the supplied buffer. Each string is <b>null</b>-terminated, with an extra <b>null</b> at the end of the list.
     * @param {PWSTR} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> points to a call-supplied character buffer in which this function returns the INF file style. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, pointer to a variable that receives the size required for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryinfversioninformationw
     * @since windows5.1.2600
     */
    static SetupQueryInfVersionInformationW(InfInformation, InfIndex, Key, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Key := Key is String ? StrPtr(Key) : Key
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfVersionInformationW", "ptr", InfInformation, "uint", InfIndex, "ptr", Key, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {PSTR} FileName 
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo 
     * @param {PSTR} LocaleName 
     * @param {PSTR} ReturnBuffer 
     * @param {Integer} ReturnBufferSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinfdriverstorelocationa
     * @since windows6.0.6000
     */
    static SetupGetInfDriverStoreLocationA(FileName, AlternatePlatformInfo, LocaleName, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        FileName := FileName is String ? StrPtr(FileName) : FileName
        LocaleName := LocaleName is String ? StrPtr(LocaleName) : LocaleName
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfDriverStoreLocationA", "ptr", FileName, "ptr", AlternatePlatformInfo, "ptr", LocaleName, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {PWSTR} FileName 
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo 
     * @param {PWSTR} LocaleName 
     * @param {PWSTR} ReturnBuffer 
     * @param {Integer} ReturnBufferSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinfdriverstorelocationw
     * @since windows6.0.6000
     */
    static SetupGetInfDriverStoreLocationW(FileName, AlternatePlatformInfo, LocaleName, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        FileName := FileName is String ? StrPtr(FileName) : FileName
        LocaleName := LocaleName is String ? StrPtr(LocaleName) : LocaleName
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfDriverStoreLocationW", "ptr", FileName, "ptr", AlternatePlatformInfo, "ptr", LocaleName, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfPublishedName function retrieves the fully qualified file name (directory path and file name) of an INF file in the system INF file directory that corresponds to a specified INF file in the driver store or a specified INF file in the system INF file directory.
     * @param {PSTR} DriverStoreLocation A pointer to a NULL-terminated string that contains the fully qualified file name (directory path and file name) of an INF file in the driver store. Alternatively, this parameter is a pointer to a NULL-terminated string that contains the name, and optionally the full directory path, of an INF file in the system INF file directory. For more information about how to specify the INF file, see the following <b>Remarks</b> section.
     * @param {PSTR} ReturnBuffer A pointer to the buffer in which <b>SetupGetInfPublishedName</b> returns a NULL-terminated string that contains the fully qualified file name of the specified INF file in the system INF directory. The maximum path size is MAX_PATH. This pointer can be set to <b>NULL</b>. For information about how to determine the required size of the return buffer, see the following <b>Remarks</b> section.
     * @param {Integer} ReturnBufferSize The size, in characters, of the buffer supplied by <i>ReturnBuffer</i>.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, of the <i>ReturnBuffer</i> buffer. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {BOOL} If <b>SetupGetInfPublishedName</b> succeeds, the function returns <b>TRUE</b>; otherwise, the function returns <b>FALSE</b>. To obtain extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the size, in characters, of the fully qualified file name of the requested INF file, including a null-terminator, is greater than <i>ReturnBufferSize</i>, the function will fail, and a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetinfpublishednamea
     * @since windows6.0.6000
     */
    static SetupGetInfPublishedNameA(DriverStoreLocation, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        DriverStoreLocation := DriverStoreLocation is String ? StrPtr(DriverStoreLocation) : DriverStoreLocation
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfPublishedNameA", "ptr", DriverStoreLocation, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfPublishedName function retrieves the fully qualified file name (directory path and file name) of an INF file in the system INF file directory that corresponds to a specified INF file in the driver store or a specified INF file in the system INF file directory.
     * @param {PWSTR} DriverStoreLocation A pointer to a NULL-terminated string that contains the fully qualified file name (directory path and file name) of an INF file in the driver store. Alternatively, this parameter is a pointer to a NULL-terminated string that contains the name, and optionally the full directory path, of an INF file in the system INF file directory. For more information about how to specify the INF file, see the following <b>Remarks</b> section.
     * @param {PWSTR} ReturnBuffer A pointer to the buffer in which <b>SetupGetInfPublishedName</b> returns a NULL-terminated string that contains the fully qualified file name of the specified INF file in the system INF directory. The maximum path size is MAX_PATH. This pointer can be set to <b>NULL</b>. For information about how to determine the required size of the return buffer, see the following <b>Remarks</b> section.
     * @param {Integer} ReturnBufferSize The size, in characters, of the buffer supplied by <i>ReturnBuffer</i>.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, of the <i>ReturnBuffer</i> buffer. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {BOOL} If <b>SetupGetInfPublishedName</b> succeeds, the function returns <b>TRUE</b>; otherwise, the function returns <b>FALSE</b>. To obtain extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the size, in characters, of the fully qualified file name of the requested INF file, including a null-terminator, is greater than <i>ReturnBufferSize</i>, the function will fail, and a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetinfpublishednamew
     * @since windows6.0.6000
     */
    static SetupGetInfPublishedNameW(DriverStoreLocation, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        DriverStoreLocation := DriverStoreLocation is String ? StrPtr(DriverStoreLocation) : DriverStoreLocation
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfPublishedNameW", "ptr", DriverStoreLocation, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfFileList function returns a list of INF files located in a caller-specified directory to a call-supplied buffer.
     * @param {PSTR} DirectoryPath Optional pointer to a <b>null</b>-terminated string containing the path of the directory in which to search. If this value is <b>NULL</b>, the %windir%\inf directory is used.
     * @param {Integer} InfStyle Type of INF file to search for. May be a combination of the following flags.
     * @param {PSTR} ReturnBuffer If not <b>NULL</b>, points to a buffer in which this function returns the list of all INF files of the desired styles that were found in the specified subdirectory. File names are <b>null</b>-terminated, with an extra <b>null</b> at the end of the list. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. The filenames do not include the path. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is not specified, <i>ReturnBufferSize</i> is ignored.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetinffilelista
     * @since windows5.1.2600
     */
    static SetupGetInfFileListA(DirectoryPath, InfStyle, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        DirectoryPath := DirectoryPath is String ? StrPtr(DirectoryPath) : DirectoryPath
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfFileListA", "ptr", DirectoryPath, "uint", InfStyle, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfFileList function returns a list of INF files located in a caller-specified directory to a call-supplied buffer.
     * @param {PWSTR} DirectoryPath Optional pointer to a <b>null</b>-terminated string containing the path of the directory in which to search. If this value is <b>NULL</b>, the %windir%\inf directory is used.
     * @param {Integer} InfStyle Type of INF file to search for. May be a combination of the following flags.
     * @param {PWSTR} ReturnBuffer If not <b>NULL</b>, points to a buffer in which this function returns the list of all INF files of the desired styles that were found in the specified subdirectory. File names are <b>null</b>-terminated, with an extra <b>null</b> at the end of the list. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. The filenames do not include the path. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is not specified, <i>ReturnBufferSize</i> is ignored.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetinffilelistw
     * @since windows5.1.2600
     */
    static SetupGetInfFileListW(DirectoryPath, InfStyle, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        DirectoryPath := DirectoryPath is String ? StrPtr(DirectoryPath) : DirectoryPath
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfFileListW", "ptr", DirectoryPath, "uint", InfStyle, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenInfFile function opens an INF file and returns a handle to it.
     * @param {PWSTR} FileName Pointer to a null-terminated string containing the name (and optional path) of the INF file to be opened. If the filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be a full path specification and no further processing is performed on it.
     * @param {PWSTR} InfClass Optional pointer to a null-terminated string containing the class of INF file desired. This string must match the Class value of the <b>Version</b> section (for example, Class=Net). If there is no entry in the Class value, but there is an entry for ClassGUID in the <b>Version</b> section, the corresponding class name for that GUID is retrieved and used for the comparison.
     * @param {Integer} InfStyle Style of INF file to open or search for. This parameter can be a combination of the following flags.
     * @param {Pointer<Integer>} ErrorLine Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred during loading of the INF file. This value is generally reliable only if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not return ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
     * @returns {Pointer<Void>} The function returns a handle to the opened INF file if it is successful. Otherwise, the return value is INVALID_HANDLE_VALUE. Extended error information can be retrieved by a call to 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupopeninffilew
     * @since windows5.1.2600
     */
    static SetupOpenInfFileW(FileName, InfClass, InfStyle, ErrorLine) {
        FileName := FileName is String ? StrPtr(FileName) : FileName
        InfClass := InfClass is String ? StrPtr(InfClass) : InfClass

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenInfFileW", "ptr", FileName, "ptr", InfClass, "uint", InfStyle, "uint*", ErrorLine, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenInfFile function opens an INF file and returns a handle to it.
     * @param {PSTR} FileName Pointer to a null-terminated string containing the name (and optional path) of the INF file to be opened. If the filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be a full path specification and no further processing is performed on it.
     * @param {PSTR} InfClass Optional pointer to a null-terminated string containing the class of INF file desired. This string must match the Class value of the <b>Version</b> section (for example, Class=Net). If there is no entry in the Class value, but there is an entry for ClassGUID in the <b>Version</b> section, the corresponding class name for that GUID is retrieved and used for the comparison.
     * @param {Integer} InfStyle Style of INF file to open or search for. This parameter can be a combination of the following flags.
     * @param {Pointer<Integer>} ErrorLine Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred during loading of the INF file. This value is generally reliable only if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not return ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
     * @returns {Pointer<Void>} The function returns a handle to the opened INF file if it is successful. Otherwise, the return value is INVALID_HANDLE_VALUE. Extended error information can be retrieved by a call to 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupopeninffilea
     * @since windows5.1.2600
     */
    static SetupOpenInfFileA(FileName, InfClass, InfStyle, ErrorLine) {
        FileName := FileName is String ? StrPtr(FileName) : FileName
        InfClass := InfClass is String ? StrPtr(InfClass) : InfClass

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenInfFileA", "ptr", FileName, "ptr", InfClass, "uint", InfStyle, "uint*", ErrorLine, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenMasterInf function opens the master INF file that contains file and layout information for files shipped with Windows.
     * @returns {Pointer<Void>} If 
     * <b>SetupOpenMasterInf</b> is successful, it returns a handle to the opened INF file that contains file/layout information for files shipped with Windows. Otherwise, the return value is INVALID_HANDLE_VALUE. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupopenmasterinf
     * @since windows5.1.2600
     */
    static SetupOpenMasterInf() {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenMasterInf", "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenAppendInfFile function appends the information in an INF file to an INF file previously opened by SetupOpenInfFile.
     * @param {PWSTR} FileName If not <b>NULL</b>, <i>FileName</i> points to a <b>null</b>-terminated string containing the name (and optionally the path) of the INF file to be opened. If the filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be a full path specification and no further processing is performed on it. If <i>FileName</i> is <b>NULL</b>, the INF filename is retrieved from the LayoutFile value of the <b>Version</b> section in the existing INF file. The same search logic is applied to the filename retrieved from the LayoutFile key.
     * @param {Pointer<Void>} InfHandle Existing INF handle to which this INF file will be appended.
     * @param {Pointer<Integer>} ErrorLine Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred during loading of the INF file. This value is generally reliable only if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not return ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>FileName</i> was not specified and there was no LayoutFile value in the <b>Version</b> section of the existing INF File, 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DATA.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupopenappendinffilew
     * @since windows5.1.2600
     */
    static SetupOpenAppendInfFileW(FileName, InfHandle, ErrorLine) {
        FileName := FileName is String ? StrPtr(FileName) : FileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenAppendInfFileW", "ptr", FileName, "ptr", InfHandle, "uint*", ErrorLine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenAppendInfFile function appends the information in an INF file to an INF file previously opened by SetupOpenInfFile.
     * @param {PSTR} FileName If not <b>NULL</b>, <i>FileName</i> points to a <b>null</b>-terminated string containing the name (and optionally the path) of the INF file to be opened. If the filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be a full path specification and no further processing is performed on it. If <i>FileName</i> is <b>NULL</b>, the INF filename is retrieved from the LayoutFile value of the <b>Version</b> section in the existing INF file. The same search logic is applied to the filename retrieved from the LayoutFile key.
     * @param {Pointer<Void>} InfHandle Existing INF handle to which this INF file will be appended.
     * @param {Pointer<Integer>} ErrorLine Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred during loading of the INF file. This value is generally reliable only if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not return ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>FileName</i> was not specified and there was no LayoutFile value in the <b>Version</b> section of the existing INF File, 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DATA.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupopenappendinffilea
     * @since windows5.1.2600
     */
    static SetupOpenAppendInfFileA(FileName, InfHandle, ErrorLine) {
        FileName := FileName is String ? StrPtr(FileName) : FileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenAppendInfFileA", "ptr", FileName, "ptr", InfHandle, "uint*", ErrorLine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCloseInfFile function closes the INF file opened by a call to SetupOpenInfFile. This function closes any INF files appended to it by calling SetupOpenAppendInfFile.
     * @param {Pointer<Void>} InfHandle Handle to the INF file to be closed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcloseinffile
     * @since windows5.1.2600
     */
    static SetupCloseInfFile(InfHandle) {
        DllCall("SETUPAPI.dll\SetupCloseInfFile", "ptr", InfHandle)
    }

    /**
     * The SetupFindFirstLine function locates a line in the specified section of an INF file. If the Key parameter is NULL, SetupFindFirstLine returns the first line of the section.
     * @param {Pointer<Void>} InfHandle Handle to the INF file to query.
     * @param {PSTR} Section Pointer to a <b>null</b>-terminated string specifying the section of the INF files to search in.
     * @param {PSTR} Key Optional pointer to a <b>null</b>-terminated string specifying the key to search for within the section. The <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be <b>NULL</b>. If <i>Key</i> is <b>NULL</b>, the first line in the section is returned.
     * @param {Pointer<INFCONTEXT>} Context Pointer to a structure that receives the context information used internally by the INF handle. Applications must not overwrite values in this structure.
     * @returns {BOOL} If the function could not find a line, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupfindfirstlinea
     * @since windows5.1.2600
     */
    static SetupFindFirstLineA(InfHandle, Section, Key, Context) {
        Section := Section is String ? StrPtr(Section) : Section
        Key := Key is String ? StrPtr(Key) : Key

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindFirstLineA", "ptr", InfHandle, "ptr", Section, "ptr", Key, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFindFirstLine function locates a line in the specified section of an INF file. If the Key parameter is NULL, SetupFindFirstLine returns the first line of the section.
     * @param {Pointer<Void>} InfHandle Handle to the INF file to query.
     * @param {PWSTR} Section Pointer to a <b>null</b>-terminated string specifying the section of the INF files to search in.
     * @param {PWSTR} Key Optional pointer to a <b>null</b>-terminated string specifying the key to search for within the section. The <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be <b>NULL</b>. If <i>Key</i> is <b>NULL</b>, the first line in the section is returned.
     * @param {Pointer<INFCONTEXT>} Context Pointer to a structure that receives the context information used internally by the INF handle. Applications must not overwrite values in this structure.
     * @returns {BOOL} If the function could not find a line, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupfindfirstlinew
     * @since windows5.1.2600
     */
    static SetupFindFirstLineW(InfHandle, Section, Key, Context) {
        Section := Section is String ? StrPtr(Section) : Section
        Key := Key is String ? StrPtr(Key) : Key

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindFirstLineW", "ptr", InfHandle, "ptr", Section, "ptr", Key, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFindNextLine returns the location of the next line in an INF file section relative to ContextIn.Line.
     * @param {Pointer<INFCONTEXT>} ContextIn Pointer to the INF file context retrieved by a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindfirstlinea">SetupFindFirstLine</a> function.
     * @param {Pointer<INFCONTEXT>} ContextOut Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point to <i>ContextIn</i> if the caller wishes.
     * @returns {BOOL} If this function finds the next line, the return value is a nonzero value. Otherwise, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupfindnextline
     * @since windows5.1.2600
     */
    static SetupFindNextLine(ContextIn, ContextOut) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindNextLine", "ptr", ContextIn, "ptr", ContextOut, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFindNextMatchLine function returns the location of the next line in an INF file relative to ContextIn.Line that matches a specified key.
     * @param {Pointer<INFCONTEXT>} ContextIn Pointer to an INF file context, as retrieved by a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindfirstlinea">SetupFindFirstLine</a> function.
     * @param {PSTR} Key If this optional parameter is specified, it supplies a key to match. This parameter should be a null-terminated string. This parameter can be Null. If <i>Key</i> is not specified, the 
     * <b>SetupFindNextMatchLine</b> function is equivalent to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindnextline">SetupFindNextLine</a> function.
     * @param {Pointer<INFCONTEXT>} ContextOut Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point to <i>ContextIn</i> if the caller wishes.
     * @returns {BOOL} The function returns a nonzero value if it finds a matching line. Otherwise, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupfindnextmatchlinea
     * @since windows5.1.2600
     */
    static SetupFindNextMatchLineA(ContextIn, Key, ContextOut) {
        Key := Key is String ? StrPtr(Key) : Key

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindNextMatchLineA", "ptr", ContextIn, "ptr", Key, "ptr", ContextOut, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFindNextMatchLine function returns the location of the next line in an INF file relative to ContextIn.Line that matches a specified key.
     * @param {Pointer<INFCONTEXT>} ContextIn Pointer to an INF file context, as retrieved by a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindfirstlinea">SetupFindFirstLine</a> function.
     * @param {PWSTR} Key If this optional parameter is specified, it supplies a key to match. This parameter should be a null-terminated string. This parameter can be Null. If <i>Key</i> is not specified, the 
     * <b>SetupFindNextMatchLine</b> function is equivalent to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindnextline">SetupFindNextLine</a> function.
     * @param {Pointer<INFCONTEXT>} ContextOut Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point to <i>ContextIn</i> if the caller wishes.
     * @returns {BOOL} The function returns a nonzero value if it finds a matching line. Otherwise, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupfindnextmatchlinew
     * @since windows5.1.2600
     */
    static SetupFindNextMatchLineW(ContextIn, Key, ContextOut) {
        Key := Key is String ? StrPtr(Key) : Key

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindNextMatchLineW", "ptr", ContextIn, "ptr", Key, "ptr", ContextOut, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineByIndex function locates a line by its index value in the specified section in the INF file.
     * @param {Pointer<Void>} InfHandle Handle to the INF file.
     * @param {PSTR} Section Pointer to a null-terminated string specifying the section of the INF file to search.
     * @param {Integer} Index Index of the line to be located. The total number of lines in a particular section can be found with a 
     *       call to <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetlinecounta">SetupGetLineCount</a>.
     * @param {Pointer<INFCONTEXT>} Context Pointer to a variable that receives the context information for the found line.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 
     *        zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetlinebyindexa
     * @since windows5.1.2600
     */
    static SetupGetLineByIndexA(InfHandle, Section, Index, Context) {
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineByIndexA", "ptr", InfHandle, "ptr", Section, "uint", Index, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineByIndex function locates a line by its index value in the specified section in the INF file.
     * @param {Pointer<Void>} InfHandle Handle to the INF file.
     * @param {PWSTR} Section Pointer to a null-terminated string specifying the section of the INF file to search.
     * @param {Integer} Index Index of the line to be located. The total number of lines in a particular section can be found with a 
     *       call to <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetlinecounta">SetupGetLineCount</a>.
     * @param {Pointer<INFCONTEXT>} Context Pointer to a variable that receives the context information for the found line.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 
     *        zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetlinebyindexw
     * @since windows5.1.2600
     */
    static SetupGetLineByIndexW(InfHandle, Section, Index, Context) {
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineByIndexW", "ptr", InfHandle, "ptr", Section, "uint", Index, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineCount function returns the number of lines in a specified section of an INF file.
     * @param {Pointer<Void>} InfHandle Handle to the INF file.
     * @param {PSTR} Section Pointer to a null-terminated string that specifies the section in which you want to count the lines.
     * @returns {Integer} If <i>InfHandle</i> references multiple INF files that have been appended  using 
     * <a href="/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, this function returns the sum of the lines in all of the INF files containing the specified section. A return value of 0 specifies an empty section. If the section does not exist, the function returns 1.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetlinecounta
     * @since windows5.1.2600
     */
    static SetupGetLineCountA(InfHandle, Section) {
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineCountA", "ptr", InfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineCount function returns the number of lines in a specified section of an INF file.
     * @param {Pointer<Void>} InfHandle Handle to the INF file.
     * @param {PWSTR} Section Pointer to a null-terminated string that specifies the section in which you want to count the lines.
     * @returns {Integer} If <i>InfHandle</i> references multiple INF files that have been appended  using 
     * <a href="/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, this function returns the sum of the lines in all of the INF files containing the specified section. A return value of 0 specifies an empty section. If the section does not exist, the function returns 1.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetlinecountw
     * @since windows5.1.2600
     */
    static SetupGetLineCountW(InfHandle, Section) {
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineCountW", "ptr", InfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineText function returns the contents of a line in an INF file in a compact form.
     * @param {Pointer<INFCONTEXT>} Context Context for a line in an INF file whose text is to be retrieved. This parameter can be <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
     * @param {Pointer<Void>} InfHandle Handle to the INF file to query. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
     * @param {PSTR} Section Pointer to a <b>null</b>-terminated string that specifies the section that  contains the key name of the line whose text is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
     * @param {PSTR} Key Pointer to a <b>null</b>-terminated string that contains the key name whose associated string is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
     * @param {PSTR} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> points to a buffer in which this function returns the contents of the line. The <b>null</b>-terminated string must not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the size required is larger than the value specified in the <i>ReturnBufferSize</i> parameter, the function fails and does not store data in the buffer.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetlinetexta
     * @since windows5.1.2600
     */
    static SetupGetLineTextA(Context, InfHandle, Section, Key, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Section := Section is String ? StrPtr(Section) : Section
        Key := Key is String ? StrPtr(Key) : Key
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineTextA", "ptr", Context, "ptr", InfHandle, "ptr", Section, "ptr", Key, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineText function returns the contents of a line in an INF file in a compact form.
     * @param {Pointer<INFCONTEXT>} Context Context for a line in an INF file whose text is to be retrieved. This parameter can be <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
     * @param {Pointer<Void>} InfHandle Handle to the INF file to query. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
     * @param {PWSTR} Section Pointer to a <b>null</b>-terminated string that specifies the section that  contains the key name of the line whose text is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
     * @param {PWSTR} Key Pointer to a <b>null</b>-terminated string that contains the key name whose associated string is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
     * @param {PWSTR} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> points to a buffer in which this function returns the contents of the line. The <b>null</b>-terminated string must not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the size required is larger than the value specified in the <i>ReturnBufferSize</i> parameter, the function fails and does not store data in the buffer.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetlinetextw
     * @since windows5.1.2600
     */
    static SetupGetLineTextW(Context, InfHandle, Section, Key, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Section := Section is String ? StrPtr(Section) : Section
        Key := Key is String ? StrPtr(Key) : Key
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineTextW", "ptr", Context, "ptr", InfHandle, "ptr", Section, "ptr", Key, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFieldCount function retrieves the number of fields in the specified line in an INF file.
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @returns {Integer} This function returns the number of fields on the line. If <i>Context</i> is invalid, 0 is returned. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetfieldcount
     * @since windows5.1.2600
     */
    static SetupGetFieldCount(Context) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFieldCount", "ptr", Context, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetStringField function retrieves a string from the specified field of a line in an INF file.
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the field within the specified line from which the string should be retrieved. Use a <i>FieldIndex</i> of 0 to retrieve a string key, if present.
     * @param {PSTR} ReturnBuffer Optional pointer to a  buffer that receives the <b>null</b>-terminated string. You should ensure the destination buffer is the same size or larger than the source buffer.  This parameter can be <b>NULL</b>. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size  for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. If <i>ReturnBuffer</i> is specified and the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and does not store the string in the buffer. In this case, a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.  For the Unicode version of this function, the required size is in characters. This includes the <b>null</b> terminator.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetstringfielda
     * @since windows5.1.2600
     */
    static SetupGetStringFieldA(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetStringFieldA", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetStringField function retrieves a string from the specified field of a line in an INF file.
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the field within the specified line from which the string should be retrieved. Use a <i>FieldIndex</i> of 0 to retrieve a string key, if present.
     * @param {PWSTR} ReturnBuffer Optional pointer to a  buffer that receives the <b>null</b>-terminated string. You should ensure the destination buffer is the same size or larger than the source buffer.  This parameter can be <b>NULL</b>. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size  for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. If <i>ReturnBuffer</i> is specified and the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and does not store the string in the buffer. In this case, a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.  For the Unicode version of this function, the required size is in characters. This includes the <b>null</b> terminator.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetstringfieldw
     * @since windows5.1.2600
     */
    static SetupGetStringFieldW(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetStringFieldW", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetIntField function retrieves an integer value from the specified field of a line in an INF file.
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the field within the specified line from which the integer should be retrieved. 
     * 
     * 
     * 
     * 
     * A <i>FieldIndex</i> of 0 can be used to retrieve an integer key (For example, consider the following INF line, 431 = 1, 2, 4. The value 431 would be put into the variable pointed at by <i>IntegerValue</i> if 
     * <b>SetupGetIntField</b> was called with a <i>FieldIndex</i> of 0).
     * @param {Pointer<Integer>} IntegerValue Pointer to a variable that receives the integer. If the field is not an integer, the function fails and a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DATA.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetintfield
     * @since windows5.1.2600
     */
    static SetupGetIntField(Context, FieldIndex, IntegerValue) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetIntField", "ptr", Context, "uint", FieldIndex, "int*", IntegerValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetMultiSzField function retrieves multiple strings stored in a line of an INF file, from the specified field to the end of the line.
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the starting field within the specified line from which the strings should be retrieved. The string list is built from each field starting at this point to the end of the line. A <i>FieldIndex</i> of zero is not valid with this function.
     * @param {PSTR} ReturnBuffer Optional pointer to a character buffer that receives the strings. Each string is <b>null</b>-terminated, with an extra <b>null</b> at the end of the string list. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the size required for the buffer pointed to by <i>ReturnBuffer</i>, in  characters. This includes the <b>null</b> terminator. If the size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetmultiszfielda
     * @since windows5.1.2600
     */
    static SetupGetMultiSzFieldA(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetMultiSzFieldA", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetMultiSzField function retrieves multiple strings stored in a line of an INF file, from the specified field to the end of the line.
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the starting field within the specified line from which the strings should be retrieved. The string list is built from each field starting at this point to the end of the line. A <i>FieldIndex</i> of zero is not valid with this function.
     * @param {PWSTR} ReturnBuffer Optional pointer to a character buffer that receives the strings. Each string is <b>null</b>-terminated, with an extra <b>null</b> at the end of the string list. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the size required for the buffer pointed to by <i>ReturnBuffer</i>, in  characters. This includes the <b>null</b> terminator. If the size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetmultiszfieldw
     * @since windows5.1.2600
     */
    static SetupGetMultiSzFieldW(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetMultiSzFieldW", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetBinaryField function retrieves binary data from a line in an INF file section, from the specified field to the end of the line.
     * @param {Pointer<INFCONTEXT>} Context INF context for the line.
     * @param {Integer} FieldIndex The 1-based index of the starting field within the specified line from which the binary data should be retrieved. The binary data is built from each field, starting at this point to the end of the line. Each field corresponds to 1 byte and is in hexadecimal notation. A <i>FieldIndex</i> of zero is not valid with this function.
     * @param {Pointer} ReturnBuffer Optional pointer to a buffer that receives the binary data. You should ensure the destination buffer is the same size or larger than the source buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size for the buffer pointed to <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b> terminator. If the size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DATA if a field that 
     * <b>SetupGetBinaryField</b> retrieves is not a valid hexadecimal number in the range 0-FF.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetbinaryfield
     * @since windows5.1.2600
     */
    static SetupGetBinaryField(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetBinaryField", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileCompressionInfo function examines a physical file to determine if it is compressed and gets its full path, size, and the size of the uncompressed target file.
     * @param {PSTR} SourceFileName File name of the file about which information is required. If the file is not found on the source media exactly as named, the file is searched for with up to two alternate "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, F:\mpis\cmd.ex_ is searched for and, if that is not found, a search is done for F:\x86\cmd.ex$. You should use a null-terminated string.
     * @param {Pointer<PSTR>} ActualSourceFileName Pointer to a variable that receives the full path of the file that it has been able to locate. The caller can free the pointer with a call to <b>LocalFree</b>. The path is valid only if the function returns NO_ERROR. Note that if the version of SetupAPI.dll is less than 5.0.2195, then the caller needs to use the exported function <b>MyFree</b> from SetupAPI to free the memory allocated by this function, rather then using <b>LocalFree</b>. See the Remarks section.
     * @param {Pointer<Integer>} SourceFileSize Pointer to a variable in which this function returns the size of the file in its current form which is the current size of the file named by <i>ActualSourceFileName</i>. The size is determined by examining the source file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR.
     * @param {Pointer<Integer>} TargetFileSize Pointer to a variable in which this function returns the size the file will occupy when it is uncompressed or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the function returns NO_ERROR.
     * @param {Pointer<Integer>} CompressionType Pointer to a variable in which this function returns a value indicating the type of compression used on <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR. The value can be one of the following flags.
     * @returns {Integer} The function returns a <a href="/windows/desktop/Debug/system-error-codes">system error code</a> that indicates the outcome of the file search. The error code can be one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetfilecompressioninfoa
     * @since windows5.1.2600
     */
    static SetupGetFileCompressionInfoA(SourceFileName, ActualSourceFileName, SourceFileSize, TargetFileSize, CompressionType) {
        SourceFileName := SourceFileName is String ? StrPtr(SourceFileName) : SourceFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileCompressionInfoA", "ptr", SourceFileName, "ptr", ActualSourceFileName, "uint*", SourceFileSize, "uint*", TargetFileSize, "uint*", CompressionType, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileCompressionInfo function examines a physical file to determine if it is compressed and gets its full path, size, and the size of the uncompressed target file.
     * @param {PWSTR} SourceFileName File name of the file about which information is required. If the file is not found on the source media exactly as named, the file is searched for with up to two alternate "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, F:\mpis\cmd.ex_ is searched for and, if that is not found, a search is done for F:\x86\cmd.ex$. You should use a null-terminated string.
     * @param {Pointer<PWSTR>} ActualSourceFileName Pointer to a variable that receives the full path of the file that it has been able to locate. The caller can free the pointer with a call to <b>LocalFree</b>. The path is valid only if the function returns NO_ERROR. Note that if the version of SetupAPI.dll is less than 5.0.2195, then the caller needs to use the exported function <b>MyFree</b> from SetupAPI to free the memory allocated by this function, rather then using <b>LocalFree</b>. See the Remarks section.
     * @param {Pointer<Integer>} SourceFileSize Pointer to a variable in which this function returns the size of the file in its current form which is the current size of the file named by <i>ActualSourceFileName</i>. The size is determined by examining the source file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR.
     * @param {Pointer<Integer>} TargetFileSize Pointer to a variable in which this function returns the size the file will occupy when it is uncompressed or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the function returns NO_ERROR.
     * @param {Pointer<Integer>} CompressionType Pointer to a variable in which this function returns a value indicating the type of compression used on <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR. The value can be one of the following flags.
     * @returns {Integer} The function returns a <a href="/windows/desktop/Debug/system-error-codes">system error code</a> that indicates the outcome of the file search. The error code can be one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetfilecompressioninfow
     * @since windows5.1.2600
     */
    static SetupGetFileCompressionInfoW(SourceFileName, ActualSourceFileName, SourceFileSize, TargetFileSize, CompressionType) {
        SourceFileName := SourceFileName is String ? StrPtr(SourceFileName) : SourceFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileCompressionInfoW", "ptr", SourceFileName, "ptr", ActualSourceFileName, "uint*", SourceFileSize, "uint*", TargetFileSize, "uint*", CompressionType, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileCompressionInfoEx function examines a potentially compressed file and gets the type of compression, the file's full path (including file name), the compressed size, and the size of the uncompressed target file.
     * @param {PSTR} SourceFileName File name of the potentially compressed file to be examined. If the file is not found on the source media exactly as named, Setup searches for up to two alternate names. For example; if Setup does not find F:\x86\cmd.exe, it searches for F:\mpis\cmd.ex_ and if that name is not found, it searches for F:\x86\cmd.ex$.
     * @param {PSTR} ActualSourceFileNameBuffer Pointer to a  buffer that receives the actual file name and path if this parameter is not <b>NULL</b>. This is valid only if the function returns NO_ERROR.
     * @param {Integer} ActualSourceFileNameBufferLen Size of the buffer specified by <i>ActualSourceFileNameBuffer</i>, in characters. You would typically use a buffer size of MAX_PATH. If <i>ActualSourceFileNameLen</i> is too small, the function fails with ERROR_INSUFFICIENT_BUFFER. <i>ActualSourceFileNameLen</i> must contain zero if <i>ActualSourceFileNameBuffer</i> is <b>NULL</b>.
     * @param {Pointer<Integer>} RequiredBufferLen Size of the file name and full path including the terminating <b>NULL</b>, if this parameter is not <b>NULL</b>. If <i>ActualSourceFileNameBuffer</i> is <b>NULL</b> and <i>ActualSourceFileNameLen</i> is zero, the function succeeds but fills in <i>RequiredBufferLen</i>. This parameter is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} SourceFileSize Pointer to a variable in which this function returns the size of the file in its current form, which is the current size of the file named by <i>ActualSourceFileNameBuffer</i>. The size is determined by examining the source file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} TargetFileSize Pointer to a variable in which this function returns the size that the file will occupy when it is uncompressed or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} CompressionType Pointer to a variable in which this function returns a value indicating the type of compression used on <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER. This parameter value can be one of the following flags.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b> (nonzero).
     * 
     * If the function fails, the return value is <b>FALSE</b> (zero). The function can also return one of the following  <a href="/windows/desktop/Debug/system-error-codes">system error codes</a>.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetfilecompressioninfoexa
     * @since windows5.1.2600
     */
    static SetupGetFileCompressionInfoExA(SourceFileName, ActualSourceFileNameBuffer, ActualSourceFileNameBufferLen, RequiredBufferLen, SourceFileSize, TargetFileSize, CompressionType) {
        SourceFileName := SourceFileName is String ? StrPtr(SourceFileName) : SourceFileName
        ActualSourceFileNameBuffer := ActualSourceFileNameBuffer is String ? StrPtr(ActualSourceFileNameBuffer) : ActualSourceFileNameBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileCompressionInfoExA", "ptr", SourceFileName, "ptr", ActualSourceFileNameBuffer, "uint", ActualSourceFileNameBufferLen, "uint*", RequiredBufferLen, "uint*", SourceFileSize, "uint*", TargetFileSize, "uint*", CompressionType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileCompressionInfoEx function examines a potentially compressed file and gets the type of compression, the file's full path (including file name), the compressed size, and the size of the uncompressed target file.
     * @param {PWSTR} SourceFileName File name of the potentially compressed file to be examined. If the file is not found on the source media exactly as named, Setup searches for up to two alternate names. For example; if Setup does not find F:\x86\cmd.exe, it searches for F:\mpis\cmd.ex_ and if that name is not found, it searches for F:\x86\cmd.ex$.
     * @param {PWSTR} ActualSourceFileNameBuffer Pointer to a  buffer that receives the actual file name and path if this parameter is not <b>NULL</b>. This is valid only if the function returns NO_ERROR.
     * @param {Integer} ActualSourceFileNameBufferLen Size of the buffer specified by <i>ActualSourceFileNameBuffer</i>, in characters. You would typically use a buffer size of MAX_PATH. If <i>ActualSourceFileNameLen</i> is too small, the function fails with ERROR_INSUFFICIENT_BUFFER. <i>ActualSourceFileNameLen</i> must contain zero if <i>ActualSourceFileNameBuffer</i> is <b>NULL</b>.
     * @param {Pointer<Integer>} RequiredBufferLen Size of the file name and full path including the terminating <b>NULL</b>, if this parameter is not <b>NULL</b>. If <i>ActualSourceFileNameBuffer</i> is <b>NULL</b> and <i>ActualSourceFileNameLen</i> is zero, the function succeeds but fills in <i>RequiredBufferLen</i>. This parameter is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} SourceFileSize Pointer to a variable in which this function returns the size of the file in its current form, which is the current size of the file named by <i>ActualSourceFileNameBuffer</i>. The size is determined by examining the source file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} TargetFileSize Pointer to a variable in which this function returns the size that the file will occupy when it is uncompressed or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} CompressionType Pointer to a variable in which this function returns a value indicating the type of compression used on <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER. This parameter value can be one of the following flags.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b> (nonzero).
     * 
     * If the function fails, the return value is <b>FALSE</b> (zero). The function can also return one of the following  <a href="/windows/desktop/Debug/system-error-codes">system error codes</a>.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetfilecompressioninfoexw
     * @since windows5.1.2600
     */
    static SetupGetFileCompressionInfoExW(SourceFileName, ActualSourceFileNameBuffer, ActualSourceFileNameBufferLen, RequiredBufferLen, SourceFileSize, TargetFileSize, CompressionType) {
        SourceFileName := SourceFileName is String ? StrPtr(SourceFileName) : SourceFileName
        ActualSourceFileNameBuffer := ActualSourceFileNameBuffer is String ? StrPtr(ActualSourceFileNameBuffer) : ActualSourceFileNameBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileCompressionInfoExW", "ptr", SourceFileName, "ptr", ActualSourceFileNameBuffer, "uint", ActualSourceFileNameBufferLen, "uint*", RequiredBufferLen, "uint*", SourceFileSize, "uint*", TargetFileSize, "uint*", CompressionType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDecompressOrCopyFile function copies a file, decompressing it if necessary.
     * @param {PSTR} SourceFileName File name of the file to be copied. You should use a <b>null</b>-terminated string. This parameter can be <b>NULL</b>. If <i>CompressionType</i> is not specified and the 
     * <b>SetupDecompressOrCopyFile</b> function does not find the file specified in <i>SourceFileName</i>, the function searches for the file with up to two alternate, "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, the function searches for F:\x86\cmd.ex_ and, if that is not found, F:\x86\cmd.ex$ is searched for. If <i>CompressionType</i> is specified, no additional processing is performed on the filename; the file must exist exactly as specified or the function fails.
     * @param {PSTR} TargetFileName Exact name of the target file that will be created by decompressing or copying the source file. You should use a <b>null</b>-terminated string.
     * @param {Pointer<Integer>} CompressionType Optional pointer to the compression type used on the source file. You can determine the compression type by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetfilecompressioninfoa">SetupGetFileCompressionInfo</a>. If this value is FILE_COMPRESSION_NONE, the file is copied (not decompressed) regardless of any compression in use on the source. If <i>CompressionType</i> is not specified, this routine determines the compression type automatically.
     * @returns {Integer} The 
     * <b>SetupDecompressOrCopyFile</b> function returns a <a href="/windows/desktop/Debug/system-error-codes">system error code</a> that indicates the outcome of the operation. 
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdecompressorcopyfilea
     * @since windows5.1.2600
     */
    static SetupDecompressOrCopyFileA(SourceFileName, TargetFileName, CompressionType) {
        SourceFileName := SourceFileName is String ? StrPtr(SourceFileName) : SourceFileName
        TargetFileName := TargetFileName is String ? StrPtr(TargetFileName) : TargetFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDecompressOrCopyFileA", "ptr", SourceFileName, "ptr", TargetFileName, "uint*", CompressionType, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDecompressOrCopyFile function copies a file, decompressing it if necessary.
     * @param {PWSTR} SourceFileName File name of the file to be copied. You should use a <b>null</b>-terminated string. This parameter can be <b>NULL</b>. If <i>CompressionType</i> is not specified and the 
     * <b>SetupDecompressOrCopyFile</b> function does not find the file specified in <i>SourceFileName</i>, the function searches for the file with up to two alternate, "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, the function searches for F:\x86\cmd.ex_ and, if that is not found, F:\x86\cmd.ex$ is searched for. If <i>CompressionType</i> is specified, no additional processing is performed on the filename; the file must exist exactly as specified or the function fails.
     * @param {PWSTR} TargetFileName Exact name of the target file that will be created by decompressing or copying the source file. You should use a <b>null</b>-terminated string.
     * @param {Pointer<Integer>} CompressionType Optional pointer to the compression type used on the source file. You can determine the compression type by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetfilecompressioninfoa">SetupGetFileCompressionInfo</a>. If this value is FILE_COMPRESSION_NONE, the file is copied (not decompressed) regardless of any compression in use on the source. If <i>CompressionType</i> is not specified, this routine determines the compression type automatically.
     * @returns {Integer} The 
     * <b>SetupDecompressOrCopyFile</b> function returns a <a href="/windows/desktop/Debug/system-error-codes">system error code</a> that indicates the outcome of the operation. 
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdecompressorcopyfilew
     * @since windows5.1.2600
     */
    static SetupDecompressOrCopyFileW(SourceFileName, TargetFileName, CompressionType) {
        SourceFileName := SourceFileName is String ? StrPtr(SourceFileName) : SourceFileName
        TargetFileName := TargetFileName is String ? StrPtr(TargetFileName) : TargetFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDecompressOrCopyFileW", "ptr", SourceFileName, "ptr", TargetFileName, "uint*", CompressionType, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceFileLocation function retrieves the location of a source file listed in an INF file.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to the context of a line in a <b>Copy Files</b> section for which the full source path is to be retrieved. If this parameter is <b>NULL</b>, <i>FileName</i> is searched for in the <b>SourceDisksFiles</b> section of the INF file specified by <i>InfHandle</i>.
     * @param {PSTR} FileName Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the full source location. This parameter can be <b>NULL</b>, but either <i>FileName</i> or <i>InfContext</i> must be specified.
     * @param {Pointer<Integer>} SourceId Pointer to a variable that receives the source identifier of the media where the file is located from the <b>SourceDisksNames</b> section of the INF file.
     * @param {PSTR} ReturnBuffer Optional pointer to a buffer to receive the relative source path. The source path does not include the filename itself, nor does it include a drive letter/network share name. The path does not start or end with a backslash (\), so the empty string specifies the root directory. You should use a <b>null</b>-terminated string buffer. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data.  Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If the required size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetsourcefilelocationa
     * @since windows5.1.2600
     */
    static SetupGetSourceFileLocationA(InfHandle, InfContext, FileName, SourceId, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        FileName := FileName is String ? StrPtr(FileName) : FileName
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceFileLocationA", "ptr", InfHandle, "ptr", InfContext, "ptr", FileName, "uint*", SourceId, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceFileLocation function retrieves the location of a source file listed in an INF file.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to the context of a line in a <b>Copy Files</b> section for which the full source path is to be retrieved. If this parameter is <b>NULL</b>, <i>FileName</i> is searched for in the <b>SourceDisksFiles</b> section of the INF file specified by <i>InfHandle</i>.
     * @param {PWSTR} FileName Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the full source location. This parameter can be <b>NULL</b>, but either <i>FileName</i> or <i>InfContext</i> must be specified.
     * @param {Pointer<Integer>} SourceId Pointer to a variable that receives the source identifier of the media where the file is located from the <b>SourceDisksNames</b> section of the INF file.
     * @param {PWSTR} ReturnBuffer Optional pointer to a buffer to receive the relative source path. The source path does not include the filename itself, nor does it include a drive letter/network share name. The path does not start or end with a backslash (\), so the empty string specifies the root directory. You should use a <b>null</b>-terminated string buffer. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data.  Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If the required size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetsourcefilelocationw
     * @since windows5.1.2600
     */
    static SetupGetSourceFileLocationW(InfHandle, InfContext, FileName, SourceId, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        FileName := FileName is String ? StrPtr(FileName) : FileName
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceFileLocationW", "ptr", InfHandle, "ptr", InfContext, "ptr", FileName, "uint*", SourceId, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceFileSize function reads the uncompressed size of a source file listed in an INF file.
     * @param {Pointer<Void>} InfHandle Handle to the loaded INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to a context for a line in a <b>Copy Files</b> section for which the size is to be retrieved. If <i>InfContext</i> is <b>NULL</b>, the <i>FileName</i> parameter is used.
     * @param {PSTR} FileName Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the size. If this parameter is <b>NULL</b> as well as <i>InfContext</i>, then the <i>Section</i> parameter is used.
     * @param {PSTR} Section Optional pointer to a <b>null</b>-terminated string containing the name of a <b>Copy Files</b> section. If this parameter is specified, the total size of all files listed in the section is computed.
     * @param {Pointer<Integer>} FileSize Pointer to a variable that receives the size, in bytes, of the specified file(s).
     * @param {Integer} RoundingFactor Optional value for rounding file sizes. All file sizes are rounded up to a multiple of this number before being added to the total size. Rounding is useful for more exact determinations of the space that a file will occupy on a given volume, because it allows the caller to have file sizes rounded up to a multiple of the cluster size. Rounding does not occur unless <i>RoundingFactor</i> is specified.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetsourcefilesizea
     * @since windows5.1.2600
     */
    static SetupGetSourceFileSizeA(InfHandle, InfContext, FileName, Section, FileSize, RoundingFactor) {
        FileName := FileName is String ? StrPtr(FileName) : FileName
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceFileSizeA", "ptr", InfHandle, "ptr", InfContext, "ptr", FileName, "ptr", Section, "uint*", FileSize, "uint", RoundingFactor, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceFileSize function reads the uncompressed size of a source file listed in an INF file.
     * @param {Pointer<Void>} InfHandle Handle to the loaded INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to a context for a line in a <b>Copy Files</b> section for which the size is to be retrieved. If <i>InfContext</i> is <b>NULL</b>, the <i>FileName</i> parameter is used.
     * @param {PWSTR} FileName Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the size. If this parameter is <b>NULL</b> as well as <i>InfContext</i>, then the <i>Section</i> parameter is used.
     * @param {PWSTR} Section Optional pointer to a <b>null</b>-terminated string containing the name of a <b>Copy Files</b> section. If this parameter is specified, the total size of all files listed in the section is computed.
     * @param {Pointer<Integer>} FileSize Pointer to a variable that receives the size, in bytes, of the specified file(s).
     * @param {Integer} RoundingFactor Optional value for rounding file sizes. All file sizes are rounded up to a multiple of this number before being added to the total size. Rounding is useful for more exact determinations of the space that a file will occupy on a given volume, because it allows the caller to have file sizes rounded up to a multiple of the cluster size. Rounding does not occur unless <i>RoundingFactor</i> is specified.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetsourcefilesizew
     * @since windows5.1.2600
     */
    static SetupGetSourceFileSizeW(InfHandle, InfContext, FileName, Section, FileSize, RoundingFactor) {
        FileName := FileName is String ? StrPtr(FileName) : FileName
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceFileSizeW", "ptr", InfHandle, "ptr", InfContext, "ptr", FileName, "ptr", Section, "uint*", FileSize, "uint", RoundingFactor, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetTargetPath function determines the target directory for a file list section.
     * @param {Pointer<Void>} InfHandle Handle to the load INF file that contains a <b>DestinationDirs</b> section.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to an INF context that specifies a line in a file list section whose destination directory is to be retrieved. If <i>InfContext</i> is <b>NULL</b>, then the <i>Section</i> parameter is used.
     * @param {PSTR} Section Optional parameter that specifies the name of a section of the INF file whose handle is <i>InfHandle</i>. 
     * <b>SetupGetTargetPath</b> retrieves the target directory for this section. The <i>Section</i> parameter is ignored if <i>InfContext</i> is specified. If neither <i>InfContext</i> nor <i>Section</i> is specified, the function retrieves the default target path from the INF file. You should use a <b>null</b>-terminated string.
     * @param {PSTR} ReturnBuffer Optional pointer to  buffer to receive the fully qualified  target path. The path is guaranteed not to end with \. You should use a <b>null</b>-terminated string. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a  variable that receives the required size for the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.  If the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgettargetpatha
     * @since windows5.1.2600
     */
    static SetupGetTargetPathA(InfHandle, InfContext, Section, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Section := Section is String ? StrPtr(Section) : Section
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetTargetPathA", "ptr", InfHandle, "ptr", InfContext, "ptr", Section, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetTargetPath function determines the target directory for a file list section.
     * @param {Pointer<Void>} InfHandle Handle to the load INF file that contains a <b>DestinationDirs</b> section.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to an INF context that specifies a line in a file list section whose destination directory is to be retrieved. If <i>InfContext</i> is <b>NULL</b>, then the <i>Section</i> parameter is used.
     * @param {PWSTR} Section Optional parameter that specifies the name of a section of the INF file whose handle is <i>InfHandle</i>. 
     * <b>SetupGetTargetPath</b> retrieves the target directory for this section. The <i>Section</i> parameter is ignored if <i>InfContext</i> is specified. If neither <i>InfContext</i> nor <i>Section</i> is specified, the function retrieves the default target path from the INF file. You should use a <b>null</b>-terminated string.
     * @param {PWSTR} ReturnBuffer Optional pointer to  buffer to receive the fully qualified  target path. The path is guaranteed not to end with \. You should use a <b>null</b>-terminated string. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a  variable that receives the required size for the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.  If the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgettargetpathw
     * @since windows5.1.2600
     */
    static SetupGetTargetPathW(InfHandle, InfContext, Section, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Section := Section is String ? StrPtr(Section) : Section
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetTargetPathW", "ptr", InfHandle, "ptr", InfContext, "ptr", Section, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetSourceList function allows the caller to set the list of installation sources for either the current user or the system (common to all users).
     * @param {Integer} Flags 
     * @param {Pointer<PSTR>} SourceList Pointer to an array of strings to use as the source list, as specified by the <i>Flags</i> parameter.
     * @param {Integer} SourceCount Number of elements in the array pointed to by <i>SourceList</i>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetsourcelista
     * @since windows5.1.2600
     */
    static SetupSetSourceListA(Flags, SourceList, SourceCount) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetSourceListA", "uint", Flags, "ptr", SourceList, "uint", SourceCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetSourceList function allows the caller to set the list of installation sources for either the current user or the system (common to all users).
     * @param {Integer} Flags 
     * @param {Pointer<PWSTR>} SourceList Pointer to an array of strings to use as the source list, as specified by the <i>Flags</i> parameter.
     * @param {Integer} SourceCount Number of elements in the array pointed to by <i>SourceList</i>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetsourcelistw
     * @since windows5.1.2600
     */
    static SetupSetSourceListW(Flags, SourceList, SourceCount) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetSourceListW", "uint", Flags, "ptr", SourceList, "uint", SourceCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCancelTemporarySourceList function cancels any temporary list and no-browse behavior and reestablishes standard list behavior.
     * @returns {BOOL} If a temporary list was in effect, the return value is a nonzero value. Otherwise, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcanceltemporarysourcelist
     * @since windows5.1.2600
     */
    static SetupCancelTemporarySourceList() {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCancelTemporarySourceList", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddToSourceList function appends a value to the list of installation sources for either the current user or the system. If the value already exists, it is removed first, so that duplicate entries are not created.
     * @param {Integer} Flags 
     * @param {PSTR} Source Pointer to the source to be added to the list. You should use a null-terminated string.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupaddtosourcelista
     * @since windows5.1.2600
     */
    static SetupAddToSourceListA(Flags, Source) {
        Source := Source is String ? StrPtr(Source) : Source

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddToSourceListA", "uint", Flags, "ptr", Source, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddToSourceList function appends a value to the list of installation sources for either the current user or the system. If the value already exists, it is removed first, so that duplicate entries are not created.
     * @param {Integer} Flags 
     * @param {PWSTR} Source Pointer to the source to be added to the list. You should use a null-terminated string.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupaddtosourcelistw
     * @since windows5.1.2600
     */
    static SetupAddToSourceListW(Flags, Source) {
        Source := Source is String ? StrPtr(Source) : Source

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddToSourceListW", "uint", Flags, "ptr", Source, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFromSourceList function removes a value from the list of installation sources for either the current user or the system. The system and user lists are merged at run time.
     * @param {Integer} Flags 
     * @param {PSTR} Source Pointer to a null-terminated string that specifies the source to remove from the list.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremovefromsourcelista
     * @since windows5.1.2600
     */
    static SetupRemoveFromSourceListA(Flags, Source) {
        Source := Source is String ? StrPtr(Source) : Source

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFromSourceListA", "uint", Flags, "ptr", Source, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFromSourceList function removes a value from the list of installation sources for either the current user or the system. The system and user lists are merged at run time.
     * @param {Integer} Flags 
     * @param {PWSTR} Source Pointer to a null-terminated string that specifies the source to remove from the list.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremovefromsourcelistw
     * @since windows5.1.2600
     */
    static SetupRemoveFromSourceListW(Flags, Source) {
        Source := Source is String ? StrPtr(Source) : Source

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFromSourceListW", "uint", Flags, "ptr", Source, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQuerySourceList function queries the current list of installation sources. The list is built from the system and user-specific lists, and potentially overridden by a temporary list (see SetupSetSourceList).
     * @param {Integer} Flags 
     * @param {Pointer<Pointer<PSTR>>} List Pointer to a variable in which this function returns a pointer to an array of sources. Use a null-terminated string. The caller must free this array with a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfreesourcelista">SetupFreeSourceList</a>.
     * @param {Pointer<Integer>} Count Pointer to a variable in which this function returns the number of sources in the list.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupquerysourcelista
     * @since windows5.1.2600
     */
    static SetupQuerySourceListA(Flags, List, Count) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQuerySourceListA", "uint", Flags, "ptr*", List, "uint*", Count, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQuerySourceList function queries the current list of installation sources. The list is built from the system and user-specific lists, and potentially overridden by a temporary list (see SetupSetSourceList).
     * @param {Integer} Flags 
     * @param {Pointer<Pointer<PWSTR>>} List Pointer to a variable in which this function returns a pointer to an array of sources. Use a null-terminated string. The caller must free this array with a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfreesourcelista">SetupFreeSourceList</a>.
     * @param {Pointer<Integer>} Count Pointer to a variable in which this function returns the number of sources in the list.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupquerysourcelistw
     * @since windows5.1.2600
     */
    static SetupQuerySourceListW(Flags, List, Count) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQuerySourceListW", "uint", Flags, "ptr*", List, "uint*", Count, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFreeSourceList function frees the system resources allocated to a source list.
     * @param {Pointer<Pointer<PSTR>>} List Pointer to an array of sources from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupquerysourcelista">SetupQuerySourceList</a>. The <b>null</b>-terminated string should not exceed the size of the destination buffer. When the function returns, this pointer is set to <b>NULL</b>.
     * @param {Integer} Count Number of sources in the list.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupfreesourcelista
     * @since windows5.1.2600
     */
    static SetupFreeSourceListA(List, Count) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFreeSourceListA", "ptr*", List, "uint", Count, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFreeSourceList function frees the system resources allocated to a source list.
     * @param {Pointer<Pointer<PWSTR>>} List Pointer to an array of sources from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupquerysourcelista">SetupQuerySourceList</a>. The <b>null</b>-terminated string should not exceed the size of the destination buffer. When the function returns, this pointer is set to <b>NULL</b>.
     * @param {Integer} Count Number of sources in the list.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupfreesourcelistw
     * @since windows5.1.2600
     */
    static SetupFreeSourceListW(List, Count) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFreeSourceListW", "ptr*", List, "uint", Count, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupPromptForDisk function displays a dialog box that prompts the user for a disk.
     * @param {HWND} hwndParent Handle to the parent window for this dialog box.
     * @param {PSTR} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the dialog title. If this parameter is <b>NULL</b>, the default of ""%s--Files Needed"" (localized) is used. The "%s" is replaced with the text retrieved from the parent window. If no text is retrieved from the parent window, the title is "Files Needed".
     * @param {PSTR} DiskName Optional pointer to a <b>null</b>-terminated string specifying the name of the disk to insert. If this parameter is <b>NULL</b>, the default "(Unknown)" (localized) is used.
     * @param {PSTR} PathToSource Optional pointer to a <b>null</b>-terminated string specifying the path part of the expected location of the file, for example, F:\x86. If not specified, the path where <b>SetupPromptForDisk</b> most recently  located a file is used. If that list is empty, a system default is used.
     * @param {PSTR} FileSought Pointer to a <b>null</b>-terminated string specifying the name of the file needed (filename part only). The filename is displayed if the user clicks on the <b>Browse</b> button. This routine looks for the file using its compressed form names; therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source media.
     * @param {PSTR} TagFile Optional pointer to a <b>null</b>-terminated string specifying a tag file (filename part only) that identifies the presence of a particular removable media volume. If the currently selected path would place the file on removable media and a tag file is specified, 
     * <b>SetupPromptForDisk</b> looks for the tag file at the root of the drive to determine whether to continue. 
     * 
     * 
     * 
     * 
     * For example, if <i>PathToSource</i> is A:\x86, the tagfile is disk1.tag, and the user types B:\x86 into the edit control of the prompt dialog box, the routine looks for B:\disk1.tag to determine whether to continue. If the tag file is not found, the function looks for the tagfile using <i>PathToSource</i>.
     * 
     * If a tag file is not specified, removable media works just like non-removable media and <i>FileSought</i> is looked for before continuing.
     * @param {Integer} DiskPromptStyle Specifies the behavior of the dialog box. This parameter can be a combination of the following flags.
     * @param {PSTR} PathBuffer Optional pointer to a buffer that, upon return, receives the path (no filename) of the location specified by the user through the dialog box.  You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size.  See the Remarks section.
     * @param {Integer} PathBufferSize Size of the buffer pointed to by <i>PathBuffer</i>, in characters. It should be at least MAX_PATH long. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} PathRequiredSize Optional pointer to a variable that receives the required size for <i>PathBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @returns {Integer} The function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuppromptfordiska
     * @since windows5.1.2600
     */
    static SetupPromptForDiskA(hwndParent, DialogTitle, DiskName, PathToSource, FileSought, TagFile, DiskPromptStyle, PathBuffer, PathBufferSize, PathRequiredSize) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        DiskName := DiskName is String ? StrPtr(DiskName) : DiskName
        PathToSource := PathToSource is String ? StrPtr(PathToSource) : PathToSource
        FileSought := FileSought is String ? StrPtr(FileSought) : FileSought
        TagFile := TagFile is String ? StrPtr(TagFile) : TagFile
        PathBuffer := PathBuffer is String ? StrPtr(PathBuffer) : PathBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupPromptForDiskA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", DiskName, "ptr", PathToSource, "ptr", FileSought, "ptr", TagFile, "uint", DiskPromptStyle, "ptr", PathBuffer, "uint", PathBufferSize, "uint*", PathRequiredSize, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupPromptForDisk function displays a dialog box that prompts the user for a disk.
     * @param {HWND} hwndParent Handle to the parent window for this dialog box.
     * @param {PWSTR} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the dialog title. If this parameter is <b>NULL</b>, the default of ""%s--Files Needed"" (localized) is used. The "%s" is replaced with the text retrieved from the parent window. If no text is retrieved from the parent window, the title is "Files Needed".
     * @param {PWSTR} DiskName Optional pointer to a <b>null</b>-terminated string specifying the name of the disk to insert. If this parameter is <b>NULL</b>, the default "(Unknown)" (localized) is used.
     * @param {PWSTR} PathToSource Optional pointer to a <b>null</b>-terminated string specifying the path part of the expected location of the file, for example, F:\x86. If not specified, the path where <b>SetupPromptForDisk</b> most recently  located a file is used. If that list is empty, a system default is used.
     * @param {PWSTR} FileSought Pointer to a <b>null</b>-terminated string specifying the name of the file needed (filename part only). The filename is displayed if the user clicks on the <b>Browse</b> button. This routine looks for the file using its compressed form names; therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source media.
     * @param {PWSTR} TagFile Optional pointer to a <b>null</b>-terminated string specifying a tag file (filename part only) that identifies the presence of a particular removable media volume. If the currently selected path would place the file on removable media and a tag file is specified, 
     * <b>SetupPromptForDisk</b> looks for the tag file at the root of the drive to determine whether to continue. 
     * 
     * 
     * 
     * 
     * For example, if <i>PathToSource</i> is A:\x86, the tagfile is disk1.tag, and the user types B:\x86 into the edit control of the prompt dialog box, the routine looks for B:\disk1.tag to determine whether to continue. If the tag file is not found, the function looks for the tagfile using <i>PathToSource</i>.
     * 
     * If a tag file is not specified, removable media works just like non-removable media and <i>FileSought</i> is looked for before continuing.
     * @param {Integer} DiskPromptStyle Specifies the behavior of the dialog box. This parameter can be a combination of the following flags.
     * @param {PWSTR} PathBuffer Optional pointer to a buffer that, upon return, receives the path (no filename) of the location specified by the user through the dialog box.  You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size.  See the Remarks section.
     * @param {Integer} PathBufferSize Size of the buffer pointed to by <i>PathBuffer</i>, in characters. It should be at least MAX_PATH long. This includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} PathRequiredSize Optional pointer to a variable that receives the required size for <i>PathBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @returns {Integer} The function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuppromptfordiskw
     * @since windows5.1.2600
     */
    static SetupPromptForDiskW(hwndParent, DialogTitle, DiskName, PathToSource, FileSought, TagFile, DiskPromptStyle, PathBuffer, PathBufferSize, PathRequiredSize) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        DiskName := DiskName is String ? StrPtr(DiskName) : DiskName
        PathToSource := PathToSource is String ? StrPtr(PathToSource) : PathToSource
        FileSought := FileSought is String ? StrPtr(FileSought) : FileSought
        TagFile := TagFile is String ? StrPtr(TagFile) : TagFile
        PathBuffer := PathBuffer is String ? StrPtr(PathBuffer) : PathBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupPromptForDiskW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", DiskName, "ptr", PathToSource, "ptr", FileSought, "ptr", TagFile, "uint", DiskPromptStyle, "ptr", PathBuffer, "uint", PathBufferSize, "uint*", PathRequiredSize, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCopyError function generates a dialog box to notify a user of a copy file error.
     * @param {HWND} hwndParent The handle to the parent window for this dialog box.
     * @param {PSTR} DialogTitle An optional pointer to a <b>null</b>-terminated string that specifies the dialog box title. 
     * 
     * This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Copy Error" (localized to the system language) is used.
     * @param {PSTR} DiskName An optional pointer to a <b>null</b>-terminated string that specifies the name of the disk to insert.  
     * 
     * This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default name "(Unknown)" (localized to the system language) is used.
     * @param {PSTR} PathToSource A pointer to the path component of the source file where an operation fails, for example, F:\x86. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {PSTR} SourceFile A pointer to a <b>null</b>-terminated string that specifies the filename part of the file where an operation fails. 
     * 
     * Use a <b>null</b>-terminated string. This filename is displayed if the user clicks on the <b>Details</b> or <b>Browse</b> buttons. The <b>SetupCopyError</b> function looks for the file that uses its compressed form names. Therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source media.
     * @param {PSTR} TargetPathFile An optional pointer to a <b>null</b>-terminated string that specifies the full path of the target file for rename and copy operations. 
     * 
     * Use a <b>null</b>-terminated string.  This parameter can be <b>NULL</b>. If TargetPathFile is not specified, "(Unknown)" (localized to the system language) is used.
     * @param {Integer} Win32ErrorCode If an error occurs, this member is the <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Code</a>. 
     * 
     * If an error does not occur, it is  NO_ERROR.
     * @param {Integer} Style The flags that control display formatting and behavior of a dialog box. 
     * 
     * This parameter can be one of the following flags.
     * @param {PSTR} PathBuffer An optional pointer to a variable in which this function returns the path (not including the filename) of the location that a user specifies in the dialog box. You should use a null-terminated string. 
     * 
     * The <b>null</b>-terminated string should not exceed the size of the destination buffer. To avoid insufficient buffer errors, <i>PathBuffer</i> should be at least MAX_PATH.
     * For more information, see the Remarks section of this topic.
     * @param {Integer} PathBufferSize The size of the buffer that  <i>PathBuffer</i> points to, in characters. 
     * 
     * The buffer size should be at least MAX_PATH characters, including the <b>null</b> terminator.
     * @param {Pointer<Integer>} PathRequiredSize An optional pointer to a variable in which this function returns the required buffer size, in characters, including the <b>null</b> terminator.
     * @returns {Integer} The function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcopyerrora
     * @since windows5.1.2600
     */
    static SetupCopyErrorA(hwndParent, DialogTitle, DiskName, PathToSource, SourceFile, TargetPathFile, Win32ErrorCode, Style, PathBuffer, PathBufferSize, PathRequiredSize) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        DiskName := DiskName is String ? StrPtr(DiskName) : DiskName
        PathToSource := PathToSource is String ? StrPtr(PathToSource) : PathToSource
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        TargetPathFile := TargetPathFile is String ? StrPtr(TargetPathFile) : TargetPathFile
        PathBuffer := PathBuffer is String ? StrPtr(PathBuffer) : PathBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCopyErrorA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", DiskName, "ptr", PathToSource, "ptr", SourceFile, "ptr", TargetPathFile, "uint", Win32ErrorCode, "uint", Style, "ptr", PathBuffer, "uint", PathBufferSize, "uint*", PathRequiredSize, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCopyError function generates a dialog box to notify a user of a copy file error.
     * @param {HWND} hwndParent The handle to the parent window for this dialog box.
     * @param {PWSTR} DialogTitle An optional pointer to a <b>null</b>-terminated string that specifies the dialog box title. 
     * 
     * This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Copy Error" (localized to the system language) is used.
     * @param {PWSTR} DiskName An optional pointer to a <b>null</b>-terminated string that specifies the name of the disk to insert.  
     * 
     * This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default name "(Unknown)" (localized to the system language) is used.
     * @param {PWSTR} PathToSource A pointer to the path component of the source file where an operation fails, for example, F:\x86. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {PWSTR} SourceFile A pointer to a <b>null</b>-terminated string that specifies the filename part of the file where an operation fails. 
     * 
     * Use a <b>null</b>-terminated string. This filename is displayed if the user clicks on the <b>Details</b> or <b>Browse</b> buttons. The <b>SetupCopyError</b> function looks for the file that uses its compressed form names. Therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source media.
     * @param {PWSTR} TargetPathFile An optional pointer to a <b>null</b>-terminated string that specifies the full path of the target file for rename and copy operations. 
     * 
     * Use a <b>null</b>-terminated string.  This parameter can be <b>NULL</b>. If TargetPathFile is not specified, "(Unknown)" (localized to the system language) is used.
     * @param {Integer} Win32ErrorCode If an error occurs, this member is the <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Code</a>. 
     * 
     * If an error does not occur, it is  NO_ERROR.
     * @param {Integer} Style The flags that control display formatting and behavior of a dialog box. 
     * 
     * This parameter can be one of the following flags.
     * @param {PWSTR} PathBuffer An optional pointer to a variable in which this function returns the path (not including the filename) of the location that a user specifies in the dialog box. You should use a null-terminated string. 
     * 
     * The <b>null</b>-terminated string should not exceed the size of the destination buffer. To avoid insufficient buffer errors, <i>PathBuffer</i> should be at least MAX_PATH.
     * For more information, see the Remarks section of this topic.
     * @param {Integer} PathBufferSize The size of the buffer that  <i>PathBuffer</i> points to, in characters. 
     * 
     * The buffer size should be at least MAX_PATH characters, including the <b>null</b> terminator.
     * @param {Pointer<Integer>} PathRequiredSize An optional pointer to a variable in which this function returns the required buffer size, in characters, including the <b>null</b> terminator.
     * @returns {Integer} The function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcopyerrorw
     * @since windows5.1.2600
     */
    static SetupCopyErrorW(hwndParent, DialogTitle, DiskName, PathToSource, SourceFile, TargetPathFile, Win32ErrorCode, Style, PathBuffer, PathBufferSize, PathRequiredSize) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        DiskName := DiskName is String ? StrPtr(DiskName) : DiskName
        PathToSource := PathToSource is String ? StrPtr(PathToSource) : PathToSource
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        TargetPathFile := TargetPathFile is String ? StrPtr(TargetPathFile) : TargetPathFile
        PathBuffer := PathBuffer is String ? StrPtr(PathBuffer) : PathBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCopyErrorW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", DiskName, "ptr", PathToSource, "ptr", SourceFile, "ptr", TargetPathFile, "uint", Win32ErrorCode, "uint", Style, "ptr", PathBuffer, "uint", PathBufferSize, "uint*", PathRequiredSize, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The RenameError function generates a dialog box that informs the user of a file renaming error.
     * @param {HWND} hwndParent Handle to the parent window for this dialog box.
     * @param {PSTR} DialogTitle Pointer to a <b>null</b>-terminated string that specifies the error dialog box title. This parameter may be <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Rename Error" (localized) is used.
     * @param {PSTR} SourceFile Pointer to a <b>null</b>-terminated string that specifies the full path of the source file on which the operation failed.
     * @param {PSTR} TargetFile Pointer to a <b>null</b>-terminated string that specifies the full path of the target file on which the operation failed.
     * @param {Integer} Win32ErrorCode The <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> encountered during the file operation.
     * @param {Integer} Style Specifies display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {Integer} This function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuprenameerrora
     * @since windows5.1.2600
     */
    static SetupRenameErrorA(hwndParent, DialogTitle, SourceFile, TargetFile, Win32ErrorCode, Style) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        TargetFile := TargetFile is String ? StrPtr(TargetFile) : TargetFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRenameErrorA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", SourceFile, "ptr", TargetFile, "uint", Win32ErrorCode, "uint", Style, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The RenameError function generates a dialog box that informs the user of a file renaming error.
     * @param {HWND} hwndParent Handle to the parent window for this dialog box.
     * @param {PWSTR} DialogTitle Pointer to a <b>null</b>-terminated string that specifies the error dialog box title. This parameter may be <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Rename Error" (localized) is used.
     * @param {PWSTR} SourceFile Pointer to a <b>null</b>-terminated string that specifies the full path of the source file on which the operation failed.
     * @param {PWSTR} TargetFile Pointer to a <b>null</b>-terminated string that specifies the full path of the target file on which the operation failed.
     * @param {Integer} Win32ErrorCode The <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> encountered during the file operation.
     * @param {Integer} Style Specifies display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {Integer} This function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuprenameerrorw
     * @since windows5.1.2600
     */
    static SetupRenameErrorW(hwndParent, DialogTitle, SourceFile, TargetFile, Win32ErrorCode, Style) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        TargetFile := TargetFile is String ? StrPtr(TargetFile) : TargetFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRenameErrorW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", SourceFile, "ptr", TargetFile, "uint", Win32ErrorCode, "uint", Style, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDeleteError function generates a dialog box that informs the user of a delete error.
     * @param {HWND} hwndParent Handle to the parent window for this dialog box.
     * @param {PSTR} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is <b>NULL</b>, the default title of "Delete Error" (localized) is used.
     * @param {PSTR} File Pointer to a <b>null</b>-terminated string specifying the full path of the file on which the delete operation failed.
     * @param {Integer} Win32ErrorCode The <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> encountered during the file operation.
     * @param {Integer} Style Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {Integer} This function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdeleteerrora
     * @since windows5.1.2600
     */
    static SetupDeleteErrorA(hwndParent, DialogTitle, File, Win32ErrorCode, Style) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        File := File is String ? StrPtr(File) : File

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDeleteErrorA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", File, "uint", Win32ErrorCode, "uint", Style, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDeleteError function generates a dialog box that informs the user of a delete error.
     * @param {HWND} hwndParent Handle to the parent window for this dialog box.
     * @param {PWSTR} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is <b>NULL</b>, the default title of "Delete Error" (localized) is used.
     * @param {PWSTR} File Pointer to a <b>null</b>-terminated string specifying the full path of the file on which the delete operation failed.
     * @param {Integer} Win32ErrorCode The <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> encountered during the file operation.
     * @param {Integer} Style Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {Integer} This function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdeleteerrorw
     * @since windows5.1.2600
     */
    static SetupDeleteErrorW(hwndParent, DialogTitle, File, Win32ErrorCode, Style) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        File := File is String ? StrPtr(File) : File

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDeleteErrorW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", File, "uint", Win32ErrorCode, "uint", Style, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupBackupError function generates a dialog box that informs the user of a backup error.
     * @param {HWND} hwndParent Handle to the parent window for this dialog box.
     * @param {PSTR} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is <b>NULL</b>, the default title of "Backup Error" (localized) is used.
     * @param {PSTR} SourceFile Pointer to a <b>null</b>-terminated string specifying the full path of the source file that is being backed up.
     * @param {PSTR} TargetFile Optional pointer to a <b>null</b>-terminated string specifying the full path of the backup name of the file. This parameter can be <b>NULL</b>.
     * @param {Integer} Win32ErrorCode If an error occurs, this member is the <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a>. If no error has occurred, it is  NO_ERROR.
     * @param {Integer} Style Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {Integer} This function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupbackuperrora
     * @since windows5.1.2600
     */
    static SetupBackupErrorA(hwndParent, DialogTitle, SourceFile, TargetFile, Win32ErrorCode, Style) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        TargetFile := TargetFile is String ? StrPtr(TargetFile) : TargetFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupBackupErrorA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", SourceFile, "ptr", TargetFile, "uint", Win32ErrorCode, "uint", Style, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupBackupError function generates a dialog box that informs the user of a backup error.
     * @param {HWND} hwndParent Handle to the parent window for this dialog box.
     * @param {PWSTR} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is <b>NULL</b>, the default title of "Backup Error" (localized) is used.
     * @param {PWSTR} SourceFile Pointer to a <b>null</b>-terminated string specifying the full path of the source file that is being backed up.
     * @param {PWSTR} TargetFile Optional pointer to a <b>null</b>-terminated string specifying the full path of the backup name of the file. This parameter can be <b>NULL</b>.
     * @param {Integer} Win32ErrorCode If an error occurs, this member is the <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a>. If no error has occurred, it is  NO_ERROR.
     * @param {Integer} Style Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {Integer} This function returns one of the following values.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupbackuperrorw
     * @since windows5.1.2600
     */
    static SetupBackupErrorW(hwndParent, DialogTitle, SourceFile, TargetFile, Win32ErrorCode, Style) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DialogTitle := DialogTitle is String ? StrPtr(DialogTitle) : DialogTitle
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        TargetFile := TargetFile is String ? StrPtr(TargetFile) : TargetFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupBackupErrorW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", SourceFile, "ptr", TargetFile, "uint", Win32ErrorCode, "uint", Style, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetDirectoryId function associates a directory identifier in an INF file with a specific directory.
     * @param {Pointer<Void>} InfHandle A handle for a loaded INF file.
     * @param {Integer} Id A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If <i>Id</i> is <b>NULL</b>, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is deleted.
     * @param {PSTR} Directory A pointer to  a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is unassociated. No error results if <i>Id</i> is not currently associated with a directory.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetdirectoryida
     * @since windows5.1.2600
     */
    static SetupSetDirectoryIdA(InfHandle, Id, Directory) {
        Directory := Directory is String ? StrPtr(Directory) : Directory

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetDirectoryIdA", "ptr", InfHandle, "uint", Id, "ptr", Directory, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetDirectoryId function associates a directory identifier in an INF file with a specific directory.
     * @param {Pointer<Void>} InfHandle A handle for a loaded INF file.
     * @param {Integer} Id A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If <i>Id</i> is <b>NULL</b>, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is deleted.
     * @param {PWSTR} Directory A pointer to  a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is unassociated. No error results if <i>Id</i> is not currently associated with a directory.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetdirectoryidw
     * @since windows5.1.2600
     */
    static SetupSetDirectoryIdW(InfHandle, Id, Directory) {
        Directory := Directory is String ? StrPtr(Directory) : Directory

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetDirectoryIdW", "ptr", InfHandle, "uint", Id, "ptr", Directory, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetDirectoryIdEx function associates a directory identifier in an INF file with a specific directory.
     * @param {Pointer<Void>} InfHandle A handle for a loaded INF file.
     * @param {Integer} Id A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If <i>Id</i> is zero, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is deleted.
     * @param {PSTR} Directory A pointer to  a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is unassociated. No error results if <i>Id</i> is not currently associated with a directory.
     * @param {Integer} Flags This parameter can be set to <b>SETDIRID_NOT_FULL_PATH</b> (1) to indicate that the <i>Directory</i> does not specify a full path.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetdirectoryidexa
     * @since windows5.1.2600
     */
    static SetupSetDirectoryIdExA(InfHandle, Id, Directory, Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        Directory := Directory is String ? StrPtr(Directory) : Directory

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetDirectoryIdExA", "ptr", InfHandle, "uint", Id, "ptr", Directory, "uint", Flags, "uint", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetDirectoryIdEx function associates a directory identifier in an INF file with a specific directory.
     * @param {Pointer<Void>} InfHandle A handle for a loaded INF file.
     * @param {Integer} Id A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If <i>Id</i> is zero, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is deleted.
     * @param {PWSTR} Directory A pointer to  a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is unassociated. No error results if <i>Id</i> is not currently associated with a directory.
     * @param {Integer} Flags This parameter can be set to <b>SETDIRID_NOT_FULL_PATH</b> (1) to indicate that the <i>Directory</i> does not specify a full path.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetdirectoryidexw
     * @since windows5.1.2600
     */
    static SetupSetDirectoryIdExW(InfHandle, Id, Directory, Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        Directory := Directory is String ? StrPtr(Directory) : Directory

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetDirectoryIdExW", "ptr", InfHandle, "uint", Id, "ptr", Directory, "uint", Flags, "uint", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceInfo function retrieves the path, tag file, or media description for a source listed in an INF file.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains a <b>SourceDisksNames</b> section. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b>), the platform-specific section will be used.
     * @param {Integer} SourceId Identifier for a source media. This value is used to search by key in the <b>SourceDisksNames</b> section.
     * @param {Integer} InfoDesired Indicates what information is desired. Only one value may be specified per function call, and they cannot be combined. The following types of information can be retrieved from a <b>SourceDisksNames</b> section.
     * @param {PSTR} ReturnBuffer Optional pointer to a buffer to receive the retrieved information.  Path returns are guaranteed not to end with \.  You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This  includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size for the buffer specified by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetsourceinfoa
     * @since windows5.1.2600
     */
    static SetupGetSourceInfoA(InfHandle, SourceId, InfoDesired, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceInfoA", "ptr", InfHandle, "uint", SourceId, "uint", InfoDesired, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceInfo function retrieves the path, tag file, or media description for a source listed in an INF file.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains a <b>SourceDisksNames</b> section. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b>), the platform-specific section will be used.
     * @param {Integer} SourceId Identifier for a source media. This value is used to search by key in the <b>SourceDisksNames</b> section.
     * @param {Integer} InfoDesired Indicates what information is desired. Only one value may be specified per function call, and they cannot be combined. The following types of information can be retrieved from a <b>SourceDisksNames</b> section.
     * @param {PWSTR} ReturnBuffer Optional pointer to a buffer to receive the retrieved information.  Path returns are guaranteed not to end with \.  You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This  includes the <b>null</b> terminator.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size for the buffer specified by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetsourceinfow
     * @since windows5.1.2600
     */
    static SetupGetSourceInfoW(InfHandle, SourceId, InfoDesired, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceInfoW", "ptr", InfHandle, "uint", SourceId, "uint", InfoDesired, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFile function installs a file as specified either by an INFCONTEXT returned by SetupFindXXXLine or explicitly by the file name and path.
     * @param {Pointer<Void>} InfHandle Optional pointer to the handle to an INF file that contains SourceDisksNames and SourceDisksFiles sections. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section will be used. If <i>InfContext</i> is null and <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to the context of a line in a Copy Files section in an INF file. The routine looks up this file  in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfHandle</i> is not specified, <i>SourceFile</i> must be.
     * @param {PSTR} SourceFile Optional pointer to the file name (no path) of the file to copy. The file is looked up in the SourceDisksFiles section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
     * @param {PSTR} SourcePathRoot Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
     * @param {PSTR} DestinationName Optional pointer to the file name only (no path) of the target file. This parameter can be null to indicate that the target file should have the same name as the source file. If <i>InfContext</i> is not specified, <i>DestinationName</i> supplies the full  path and file name for the target.
     * @param {Integer} CopyStyle 
     * @param {Pointer<PSP_FILE_CALLBACK_A>} CopyMsgHandler Optional pointer to a callback function to be notified of various conditions that may arise during the file copy operation.
     * @param {Pointer<Void>} Context Optional pointer to a caller-defined value that is passed as the first parameter of the callback function.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns NO_ERROR, the file copy operation was not completed. The file may not have been copied because the file copy operation was unnecessary or because the file callback function returned <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallfilea
     * @since windows5.1.2600
     */
    static SetupInstallFileA(InfHandle, InfContext, SourceFile, SourcePathRoot, DestinationName, CopyStyle, CopyMsgHandler, Context) {
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        SourcePathRoot := SourcePathRoot is String ? StrPtr(SourcePathRoot) : SourcePathRoot
        DestinationName := DestinationName is String ? StrPtr(DestinationName) : DestinationName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFileA", "ptr", InfHandle, "ptr", InfContext, "ptr", SourceFile, "ptr", SourcePathRoot, "ptr", DestinationName, "uint", CopyStyle, "ptr", CopyMsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFile function installs a file as specified either by an INFCONTEXT returned by SetupFindXXXLine or explicitly by the file name and path.
     * @param {Pointer<Void>} InfHandle Optional pointer to the handle to an INF file that contains SourceDisksNames and SourceDisksFiles sections. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section will be used. If <i>InfContext</i> is null and <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to the context of a line in a Copy Files section in an INF file. The routine looks up this file  in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfHandle</i> is not specified, <i>SourceFile</i> must be.
     * @param {PWSTR} SourceFile Optional pointer to the file name (no path) of the file to copy. The file is looked up in the SourceDisksFiles section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
     * @param {PWSTR} SourcePathRoot Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
     * @param {PWSTR} DestinationName Optional pointer to the file name only (no path) of the target file. This parameter can be null to indicate that the target file should have the same name as the source file. If <i>InfContext</i> is not specified, <i>DestinationName</i> supplies the full  path and file name for the target.
     * @param {Integer} CopyStyle 
     * @param {Pointer<PSP_FILE_CALLBACK_W>} CopyMsgHandler Optional pointer to a callback function to be notified of various conditions that may arise during the file copy operation.
     * @param {Pointer<Void>} Context Optional pointer to a caller-defined value that is passed as the first parameter of the callback function.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns NO_ERROR, the file copy operation was not completed. The file may not have been copied because the file copy operation was unnecessary or because the file callback function returned <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallfilew
     * @since windows5.1.2600
     */
    static SetupInstallFileW(InfHandle, InfContext, SourceFile, SourcePathRoot, DestinationName, CopyStyle, CopyMsgHandler, Context) {
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        SourcePathRoot := SourcePathRoot is String ? StrPtr(SourcePathRoot) : SourcePathRoot
        DestinationName := DestinationName is String ? StrPtr(DestinationName) : DestinationName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFileW", "ptr", InfHandle, "ptr", InfContext, "ptr", SourceFile, "ptr", SourcePathRoot, "ptr", DestinationName, "uint", CopyStyle, "ptr", CopyMsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFileEx function installs a file as specified either by an INFCONTEXT returned by SetupFindXXXLine or explicitly by the filename and path information.
     * @param {Pointer<Void>} InfHandle Optional pointer to the handle to an INF file that contains the SourceDisksNames and SourceDisksFiles sections. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section are used. If <i>InfContext</i> is not specified and <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to context for a line in a Copy Files section in an INF file. The routine looks this file up in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfContext</i> is not specified, <i>SourceFile</i> must be.
     * @param {PSTR} SourceFile Optional pointer to the filename (no path) of the file to copy. The file is looked up in the SourceDisksFiles section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. However, <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
     * @param {PSTR} SourcePathRoot Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
     * @param {PSTR} DestinationName Optional pointer  to  a new name for the copied file. If <i>InfContext</i> is specified, <i>DestinationName</i> supplies the filename only (no path) of the target file. This parameter can be <b>NULL</b> to indicate that the target file should have the same name as the source file. If <i>InfContext</i> is not specified, <i>DestinationName</i> supplies the full target path and filename for the target.
     * @param {Integer} CopyStyle Flags that control the behavior of the file copy operation.
     * @param {Pointer<PSP_FILE_CALLBACK_A>} CopyMsgHandler Optional pointer to a callback function to be notified of various conditions that may arise during the file copy.
     * @param {Pointer<Void>} Context Pointer to a caller-defined value that is passed as the first parameter of the callback function.
     * @param {Pointer<BOOL>} FileWasInUse Pointer to a variable in which this function returns a flag that indicates whether the file was in use. This parameter is required.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns NO_ERROR, the file copy operation was not completed. The file may not have been copied because the file copy operation was unnecessary or because the file callback function returned <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallfileexa
     * @since windows5.1.2600
     */
    static SetupInstallFileExA(InfHandle, InfContext, SourceFile, SourcePathRoot, DestinationName, CopyStyle, CopyMsgHandler, Context, FileWasInUse) {
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        SourcePathRoot := SourcePathRoot is String ? StrPtr(SourcePathRoot) : SourcePathRoot
        DestinationName := DestinationName is String ? StrPtr(DestinationName) : DestinationName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFileExA", "ptr", InfHandle, "ptr", InfContext, "ptr", SourceFile, "ptr", SourcePathRoot, "ptr", DestinationName, "uint", CopyStyle, "ptr", CopyMsgHandler, "ptr", Context, "ptr", FileWasInUse, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFileEx function installs a file as specified either by an INFCONTEXT returned by SetupFindXXXLine or explicitly by the filename and path information.
     * @param {Pointer<Void>} InfHandle Optional pointer to the handle to an INF file that contains the SourceDisksNames and SourceDisksFiles sections. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section are used. If <i>InfContext</i> is not specified and <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to context for a line in a Copy Files section in an INF file. The routine looks this file up in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfContext</i> is not specified, <i>SourceFile</i> must be.
     * @param {PWSTR} SourceFile Optional pointer to the filename (no path) of the file to copy. The file is looked up in the SourceDisksFiles section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. However, <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
     * @param {PWSTR} SourcePathRoot Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
     * @param {PWSTR} DestinationName Optional pointer  to  a new name for the copied file. If <i>InfContext</i> is specified, <i>DestinationName</i> supplies the filename only (no path) of the target file. This parameter can be <b>NULL</b> to indicate that the target file should have the same name as the source file. If <i>InfContext</i> is not specified, <i>DestinationName</i> supplies the full target path and filename for the target.
     * @param {Integer} CopyStyle Flags that control the behavior of the file copy operation.
     * @param {Pointer<PSP_FILE_CALLBACK_W>} CopyMsgHandler Optional pointer to a callback function to be notified of various conditions that may arise during the file copy.
     * @param {Pointer<Void>} Context Pointer to a caller-defined value that is passed as the first parameter of the callback function.
     * @param {Pointer<BOOL>} FileWasInUse Pointer to a variable in which this function returns a flag that indicates whether the file was in use. This parameter is required.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns NO_ERROR, the file copy operation was not completed. The file may not have been copied because the file copy operation was unnecessary or because the file callback function returned <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallfileexw
     * @since windows5.1.2600
     */
    static SetupInstallFileExW(InfHandle, InfContext, SourceFile, SourcePathRoot, DestinationName, CopyStyle, CopyMsgHandler, Context, FileWasInUse) {
        SourceFile := SourceFile is String ? StrPtr(SourceFile) : SourceFile
        SourcePathRoot := SourcePathRoot is String ? StrPtr(SourcePathRoot) : SourcePathRoot
        DestinationName := DestinationName is String ? StrPtr(DestinationName) : DestinationName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFileExW", "ptr", InfHandle, "ptr", InfContext, "ptr", SourceFile, "ptr", SourcePathRoot, "ptr", DestinationName, "uint", CopyStyle, "ptr", CopyMsgHandler, "ptr", Context, "ptr", FileWasInUse, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenFileQueue function creates a setup file queue.
     * @returns {Pointer<Void>} If the function succeeds, it returns a handle to a setup file queue. If there is not enough memory to create the queue, the function returns INVALID_HANDLE_VALUE. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupopenfilequeue
     * @since windows5.1.2600
     */
    static SetupOpenFileQueue() {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenFileQueue", "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCloseFileQueue function destroys a setup file queue.
     * @param {Pointer<Void>} QueueHandle Handle to an open setup file queue.
     * @returns {BOOL} This function does not return a value.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupclosefilequeue
     * @since windows5.1.2600
     */
    static SetupCloseFileQueue(QueueHandle) {
        result := DllCall("SETUPAPI.dll\SetupCloseFileQueue", "ptr", QueueHandle, "int")
        return result
    }

    /**
     * The SetupSetFileQueueAlternatePlatform function associates the file queue with a target platform that is different from the platform running the function. This is done to enable for non-native signature verification.
     * @param {Pointer<Void>} QueueHandle Handle to an open setup file queue.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Optional pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v1">SP_ALTPLATFORM_INFO</a> structure passing information about the alternate platform. On Windows 2000, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V1). On Windows Server2003 or WindowsXP, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V2).
     * @param {PSTR} AlternateDefaultCatalogFile Pointer to a <b>null</b>-terminated string that specifies a catalog that validates any INF files. This parameter may be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetfilequeuealternateplatforma
     * @since windows5.1.2600
     */
    static SetupSetFileQueueAlternatePlatformA(QueueHandle, AlternatePlatformInfo, AlternateDefaultCatalogFile) {
        AlternateDefaultCatalogFile := AlternateDefaultCatalogFile is String ? StrPtr(AlternateDefaultCatalogFile) : AlternateDefaultCatalogFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetFileQueueAlternatePlatformA", "ptr", QueueHandle, "ptr", AlternatePlatformInfo, "ptr", AlternateDefaultCatalogFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetFileQueueAlternatePlatform function associates the file queue with a target platform that is different from the platform running the function. This is done to enable for non-native signature verification.
     * @param {Pointer<Void>} QueueHandle Handle to an open setup file queue.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Optional pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v1">SP_ALTPLATFORM_INFO</a> structure passing information about the alternate platform. On Windows 2000, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V1). On Windows Server2003 or WindowsXP, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V2).
     * @param {PWSTR} AlternateDefaultCatalogFile Pointer to a <b>null</b>-terminated string that specifies a catalog that validates any INF files. This parameter may be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetfilequeuealternateplatformw
     * @since windows5.1.2600
     */
    static SetupSetFileQueueAlternatePlatformW(QueueHandle, AlternatePlatformInfo, AlternateDefaultCatalogFile) {
        AlternateDefaultCatalogFile := AlternateDefaultCatalogFile is String ? StrPtr(AlternateDefaultCatalogFile) : AlternateDefaultCatalogFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetFileQueueAlternatePlatformW", "ptr", QueueHandle, "ptr", AlternatePlatformInfo, "ptr", AlternateDefaultCatalogFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetPlatformPathOverride function is used to set a platform path override for a target machine when working with INFs from a different machine.
     * @param {PSTR} Override Pointer to a <b>null</b>-terminated string that contains the replacement platform information. For example, "alpha" or "x86". This parameter may be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NOT_ENOUGH_MEMORY, 
     * <b>SetupSetPlatformPathOverride</b> was unable to store the <i>Override</i> string.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetplatformpathoverridea
     * @since windows5.1.2600
     */
    static SetupSetPlatformPathOverrideA(Override) {
        Override := Override is String ? StrPtr(Override) : Override

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetPlatformPathOverrideA", "ptr", Override, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetPlatformPathOverride function is used to set a platform path override for a target machine when working with INFs from a different machine.
     * @param {PWSTR} Override Pointer to a <b>null</b>-terminated string that contains the replacement platform information. For example, "alpha" or "x86". This parameter may be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NOT_ENOUGH_MEMORY, 
     * <b>SetupSetPlatformPathOverride</b> was unable to store the <i>Override</i> string.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetplatformpathoverridew
     * @since windows5.1.2600
     */
    static SetupSetPlatformPathOverrideW(Override) {
        Override := Override is String ? StrPtr(Override) : Override

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetPlatformPathOverrideW", "ptr", Override, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopy function adds a single file copy operation to a setup file queue.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {PSTR} SourceRootPath Pointer to a <b>null</b>-terminated string that specifies the root of the source for this copy, such as A:\.
     * @param {PSTR} SourcePath Pointer to a <b>null</b>-terminated string that specifies the path relative to <i>SourceRootPath</i> where the file can be found. This parameter may be <b>NULL</b>.
     * @param {PSTR} SourceFilename Pointer to a <b>null</b>-terminated string that specifies the file name part of the file to be copied.
     * @param {PSTR} SourceDescription Pointer to a <b>null</b>-terminated string that specifies  a description of the source media to be used during disk prompts. This parameter can be <b>NULL</b>.
     * @param {PSTR} SourceTagfile Pointer to a <b>null</b>-terminated string that specifies  a tag file whose presence at <i>SourceRootPath</i> indicates the presence of the source media. This parameter may be <b>NULL</b>. If not specified, the file itself will be used as the tag file if required.
     * @param {PSTR} TargetDirectory Pointer to a <b>null</b>-terminated string that specifies the directory where the file is to be copied.
     * @param {PSTR} TargetFilename Pointer to a <b>null</b>-terminated string that specifies  the name of the target file. This parameter may be <b>NULL</b>. If not specified, the target file will have the same name as the source file.
     * @param {Integer} CopyStyle 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuecopya
     * @since windows5.1.2600
     */
    static SetupQueueCopyA(QueueHandle, SourceRootPath, SourcePath, SourceFilename, SourceDescription, SourceTagfile, TargetDirectory, TargetFilename, CopyStyle) {
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath
        SourcePath := SourcePath is String ? StrPtr(SourcePath) : SourcePath
        SourceFilename := SourceFilename is String ? StrPtr(SourceFilename) : SourceFilename
        SourceDescription := SourceDescription is String ? StrPtr(SourceDescription) : SourceDescription
        SourceTagfile := SourceTagfile is String ? StrPtr(SourceTagfile) : SourceTagfile
        TargetDirectory := TargetDirectory is String ? StrPtr(TargetDirectory) : TargetDirectory
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopyA", "ptr", QueueHandle, "ptr", SourceRootPath, "ptr", SourcePath, "ptr", SourceFilename, "ptr", SourceDescription, "ptr", SourceTagfile, "ptr", TargetDirectory, "ptr", TargetFilename, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopy function adds a single file copy operation to a setup file queue.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {PWSTR} SourceRootPath Pointer to a <b>null</b>-terminated string that specifies the root of the source for this copy, such as A:\.
     * @param {PWSTR} SourcePath Pointer to a <b>null</b>-terminated string that specifies the path relative to <i>SourceRootPath</i> where the file can be found. This parameter may be <b>NULL</b>.
     * @param {PWSTR} SourceFilename Pointer to a <b>null</b>-terminated string that specifies the file name part of the file to be copied.
     * @param {PWSTR} SourceDescription Pointer to a <b>null</b>-terminated string that specifies  a description of the source media to be used during disk prompts. This parameter can be <b>NULL</b>.
     * @param {PWSTR} SourceTagfile Pointer to a <b>null</b>-terminated string that specifies  a tag file whose presence at <i>SourceRootPath</i> indicates the presence of the source media. This parameter may be <b>NULL</b>. If not specified, the file itself will be used as the tag file if required.
     * @param {PWSTR} TargetDirectory Pointer to a <b>null</b>-terminated string that specifies the directory where the file is to be copied.
     * @param {PWSTR} TargetFilename Pointer to a <b>null</b>-terminated string that specifies  the name of the target file. This parameter may be <b>NULL</b>. If not specified, the target file will have the same name as the source file.
     * @param {Integer} CopyStyle 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuecopyw
     * @since windows5.1.2600
     */
    static SetupQueueCopyW(QueueHandle, SourceRootPath, SourcePath, SourceFilename, SourceDescription, SourceTagfile, TargetDirectory, TargetFilename, CopyStyle) {
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath
        SourcePath := SourcePath is String ? StrPtr(SourcePath) : SourcePath
        SourceFilename := SourceFilename is String ? StrPtr(SourceFilename) : SourceFilename
        SourceDescription := SourceDescription is String ? StrPtr(SourceDescription) : SourceDescription
        SourceTagfile := SourceTagfile is String ? StrPtr(SourceTagfile) : SourceTagfile
        TargetDirectory := TargetDirectory is String ? StrPtr(TargetDirectory) : TargetDirectory
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopyW", "ptr", QueueHandle, "ptr", SourceRootPath, "ptr", SourcePath, "ptr", SourceFilename, "ptr", SourceDescription, "ptr", SourceTagfile, "ptr", TargetDirectory, "ptr", TargetFilename, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopyIndirect function is an extended form of SetupQueueCopy passing additional parameters as a structure (SP_FILE_COPY_PARAMS). Other than this, the behavior is identical.
     * @param {Pointer<SP_FILE_COPY_PARAMS_A>} CopyParams Pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_file_copy_params_a">SP_FILE_COPY_PARAMS</a> structure that describes the file copy operation.
     * @returns {BOOL} If the function succeeds, the return value is an nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuecopyindirecta
     * @since windows5.1.2600
     */
    static SetupQueueCopyIndirectA(CopyParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopyIndirectA", "ptr", CopyParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopyIndirect function is an extended form of SetupQueueCopy passing additional parameters as a structure (SP_FILE_COPY_PARAMS). Other than this, the behavior is identical.
     * @param {Pointer<SP_FILE_COPY_PARAMS_W>} CopyParams Pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_file_copy_params_a">SP_FILE_COPY_PARAMS</a> structure that describes the file copy operation.
     * @returns {BOOL} If the function succeeds, the return value is an nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuecopyindirectw
     * @since windows5.1.2600
     */
    static SetupQueueCopyIndirectW(CopyParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopyIndirectW", "ptr", CopyParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDefaultCopy function adds a single file to a setup file queue for copying, using the default source media and destination as specified in an INF file.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {PSTR} SourceRootPath Pointer to a null-terminated string that specifies the root directory of the source for this copy such as A:\.
     * @param {PSTR} SourceFilename Pointer to a null-terminated string that specifies the file name of the file to be copied.
     * @param {PSTR} TargetFilename Pointer to a null-terminated string that specifies the file name of the target file.
     * @param {Integer} CopyStyle 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuedefaultcopya
     * @since windows5.1.2600
     */
    static SetupQueueDefaultCopyA(QueueHandle, InfHandle, SourceRootPath, SourceFilename, TargetFilename, CopyStyle) {
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath
        SourceFilename := SourceFilename is String ? StrPtr(SourceFilename) : SourceFilename
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDefaultCopyA", "ptr", QueueHandle, "ptr", InfHandle, "ptr", SourceRootPath, "ptr", SourceFilename, "ptr", TargetFilename, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDefaultCopy function adds a single file to a setup file queue for copying, using the default source media and destination as specified in an INF file.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {PWSTR} SourceRootPath Pointer to a null-terminated string that specifies the root directory of the source for this copy such as A:\.
     * @param {PWSTR} SourceFilename Pointer to a null-terminated string that specifies the file name of the file to be copied.
     * @param {PWSTR} TargetFilename Pointer to a null-terminated string that specifies the file name of the target file.
     * @param {Integer} CopyStyle 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuedefaultcopyw
     * @since windows5.1.2600
     */
    static SetupQueueDefaultCopyW(QueueHandle, InfHandle, SourceRootPath, SourceFilename, TargetFilename, CopyStyle) {
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath
        SourceFilename := SourceFilename is String ? StrPtr(SourceFilename) : SourceFilename
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDefaultCopyW", "ptr", QueueHandle, "ptr", InfHandle, "ptr", SourceRootPath, "ptr", SourceFilename, "ptr", TargetFilename, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopySection function places all the files in a section of an INF file in a setup queue for copying.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {PSTR} SourceRootPath Pointer to a null-terminated string that specifies the root of the source for this copy, such as A:\.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section names. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section will be used.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section to queue for copying. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section.
     * @param {PSTR} Section Pointer to a null-terminated string that specifies the name of the section to be queued for copy.
     * @param {Integer} CopyStyle 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuecopysectiona
     * @since windows5.1.2600
     */
    static SetupQueueCopySectionA(QueueHandle, SourceRootPath, InfHandle, ListInfHandle, Section, CopyStyle) {
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopySectionA", "ptr", QueueHandle, "ptr", SourceRootPath, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopySection function places all the files in a section of an INF file in a setup queue for copying.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {PWSTR} SourceRootPath Pointer to a null-terminated string that specifies the root of the source for this copy, such as A:\.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section names. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section will be used.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section to queue for copying. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section.
     * @param {PWSTR} Section Pointer to a null-terminated string that specifies the name of the section to be queued for copy.
     * @param {Integer} CopyStyle 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuecopysectionw
     * @since windows5.1.2600
     */
    static SetupQueueCopySectionW(QueueHandle, SourceRootPath, InfHandle, ListInfHandle, Section, CopyStyle) {
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopySectionW", "ptr", QueueHandle, "ptr", SourceRootPath, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDelete function places an individual file delete operation on a setup file queue.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {PSTR} PathPart1 Pointer to a <b>null</b>-terminated string that specifies the first part of the path of the file to be deleted. If <i>PathPart2</i> is <b>NULL</b>, <i>PathPart1</i> is the full path of the file to be deleted.
     * @param {PSTR} PathPart2 Pointer to a <b>null</b>-terminated string that specifies the second part of the path of the file to be deleted. This parameter may be <b>NULL</b>. This is appended to <i>PathPart1</i> to form the full path of the file to be deleted. The function checks for and collapses duplicated path separators when it combines <i>PathPart1</i> and <i>PathPart2</i>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuedeletea
     * @since windows5.1.2600
     */
    static SetupQueueDeleteA(QueueHandle, PathPart1, PathPart2) {
        PathPart1 := PathPart1 is String ? StrPtr(PathPart1) : PathPart1
        PathPart2 := PathPart2 is String ? StrPtr(PathPart2) : PathPart2

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDeleteA", "ptr", QueueHandle, "ptr", PathPart1, "ptr", PathPart2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDelete function places an individual file delete operation on a setup file queue.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {PWSTR} PathPart1 Pointer to a <b>null</b>-terminated string that specifies the first part of the path of the file to be deleted. If <i>PathPart2</i> is <b>NULL</b>, <i>PathPart1</i> is the full path of the file to be deleted.
     * @param {PWSTR} PathPart2 Pointer to a <b>null</b>-terminated string that specifies the second part of the path of the file to be deleted. This parameter may be <b>NULL</b>. This is appended to <i>PathPart1</i> to form the full path of the file to be deleted. The function checks for and collapses duplicated path separators when it combines <i>PathPart1</i> and <i>PathPart2</i>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuedeletew
     * @since windows5.1.2600
     */
    static SetupQueueDeleteW(QueueHandle, PathPart1, PathPart2) {
        PathPart1 := PathPart1 is String ? StrPtr(PathPart1) : PathPart1
        PathPart2 := PathPart2 is String ? StrPtr(PathPart2) : PathPart2

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDeleteW", "ptr", QueueHandle, "ptr", PathPart1, "ptr", PathPart2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDeleteSection function queues all the files in a section of an INF file for deletion. The section must be in the correct Delete Files format and the INF file must contain a DestinationDirs section.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section name.
     * @param {Pointer<Void>} ListInfHandle Optional  handle to an open INF file that contains the section to queue for deletion. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section name.
     * @param {PSTR} Section Pointer to a  null-terminated string that specifies the name of the section to be queued for deletion.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuedeletesectiona
     * @since windows5.1.2600
     */
    static SetupQueueDeleteSectionA(QueueHandle, InfHandle, ListInfHandle, Section) {
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDeleteSectionA", "ptr", QueueHandle, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDeleteSection function queues all the files in a section of an INF file for deletion. The section must be in the correct Delete Files format and the INF file must contain a DestinationDirs section.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section name.
     * @param {Pointer<Void>} ListInfHandle Optional  handle to an open INF file that contains the section to queue for deletion. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section name.
     * @param {PWSTR} Section Pointer to a  null-terminated string that specifies the name of the section to be queued for deletion.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuedeletesectionw
     * @since windows5.1.2600
     */
    static SetupQueueDeleteSectionW(QueueHandle, InfHandle, ListInfHandle, Section) {
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDeleteSectionW", "ptr", QueueHandle, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueRename function places an individual file rename operation on a setup file queue.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {PSTR} SourcePath Pointer to a null-terminated string that specifies the source path of the file to be renamed. If <i>SourceFileName</i> is not specified, <i>SourcePath</i> is assumed to be the full path.
     * @param {PSTR} SourceFilename Pointer to a null-terminated string that specifies the file name part of the file to be renamed. If not specified, <i>SourcePath</i> is the full path.
     * @param {PSTR} TargetPath Pointer to a null-terminated string that specifies the target directory. When this parameter is specified, the rename operation is actually a move operation. If <i>TargetPath</i> is not specified, the file is renamed but remains in its current location.
     * @param {PSTR} TargetFilename Pointer to a null-terminated string that specifies the new name for the source file.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuerenamea
     * @since windows5.1.2600
     */
    static SetupQueueRenameA(QueueHandle, SourcePath, SourceFilename, TargetPath, TargetFilename) {
        SourcePath := SourcePath is String ? StrPtr(SourcePath) : SourcePath
        SourceFilename := SourceFilename is String ? StrPtr(SourceFilename) : SourceFilename
        TargetPath := TargetPath is String ? StrPtr(TargetPath) : TargetPath
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueRenameA", "ptr", QueueHandle, "ptr", SourcePath, "ptr", SourceFilename, "ptr", TargetPath, "ptr", TargetFilename, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueRename function places an individual file rename operation on a setup file queue.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {PWSTR} SourcePath Pointer to a null-terminated string that specifies the source path of the file to be renamed. If <i>SourceFileName</i> is not specified, <i>SourcePath</i> is assumed to be the full path.
     * @param {PWSTR} SourceFilename Pointer to a null-terminated string that specifies the file name part of the file to be renamed. If not specified, <i>SourcePath</i> is the full path.
     * @param {PWSTR} TargetPath Pointer to a null-terminated string that specifies the target directory. When this parameter is specified, the rename operation is actually a move operation. If <i>TargetPath</i> is not specified, the file is renamed but remains in its current location.
     * @param {PWSTR} TargetFilename Pointer to a null-terminated string that specifies the new name for the source file.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuerenamew
     * @since windows5.1.2600
     */
    static SetupQueueRenameW(QueueHandle, SourcePath, SourceFilename, TargetPath, TargetFilename) {
        SourcePath := SourcePath is String ? StrPtr(SourcePath) : SourcePath
        SourceFilename := SourceFilename is String ? StrPtr(SourceFilename) : SourceFilename
        TargetPath := TargetPath is String ? StrPtr(TargetPath) : TargetPath
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueRenameW", "ptr", QueueHandle, "ptr", SourcePath, "ptr", SourceFilename, "ptr", TargetPath, "ptr", TargetFilename, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueRenameSection function queues a section in an INF file for renaming. The section must be in the correct rename list section format and the INF file must contain a DestinationDirs section.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section name.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an INF file that contains the section to queue for renaming. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section name.
     * @param {PSTR} Section Name of the section to be queued for renaming.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuerenamesectiona
     * @since windows5.1.2600
     */
    static SetupQueueRenameSectionA(QueueHandle, InfHandle, ListInfHandle, Section) {
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueRenameSectionA", "ptr", QueueHandle, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueRenameSection function queues a section in an INF file for renaming. The section must be in the correct rename list section format and the INF file must contain a DestinationDirs section.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section name.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an INF file that contains the section to queue for renaming. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section name.
     * @param {PWSTR} Section Name of the section to be queued for renaming.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueuerenamesectionw
     * @since windows5.1.2600
     */
    static SetupQueueRenameSectionW(QueueHandle, InfHandle, ListInfHandle, Section) {
        Section := Section is String ? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueRenameSectionW", "ptr", QueueHandle, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCommitFileQueue function performs file operations queued on a setup file queue.
     * @param {HWND} Owner Optional handle to a window to use as the parent of any progress dialog boxes.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PSP_FILE_CALLBACK_A>} MsgHandler Pointer to an optional callback routine to be notified of various significant events that are in the queue processing. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/default-queue-callback-routine">Default Queue Callback Routine</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> If the callback routine is <b>null</b>, 
     * <b>SetupCommitFileQueue</b> returns <b>TRUE</b> and the error is 0 or NO_ERROR.
     * @param {Pointer<Void>} Context Value that is passed to the callback function supplied by the <i>MsgHandler</i> parameter. If the default callback routine has been specified as <i>MsgHandler</i>, this context must be the context returned from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcommitfilequeuea
     * @since windows5.1.2600
     */
    static SetupCommitFileQueueA(Owner, QueueHandle, MsgHandler, Context) {
        Owner := Owner is Win32Handle ? NumGet(Owner, "ptr") : Owner

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCommitFileQueueA", "ptr", Owner, "ptr", QueueHandle, "ptr", MsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCommitFileQueue function performs file operations queued on a setup file queue.
     * @param {HWND} Owner Optional handle to a window to use as the parent of any progress dialog boxes.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PSP_FILE_CALLBACK_W>} MsgHandler Pointer to an optional callback routine to be notified of various significant events that are in the queue processing. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/default-queue-callback-routine">Default Queue Callback Routine</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> If the callback routine is <b>null</b>, 
     * <b>SetupCommitFileQueue</b> returns <b>TRUE</b> and the error is 0 or NO_ERROR.
     * @param {Pointer<Void>} Context Value that is passed to the callback function supplied by the <i>MsgHandler</i> parameter. If the default callback routine has been specified as <i>MsgHandler</i>, this context must be the context returned from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcommitfilequeuew
     * @since windows5.1.2600
     */
    static SetupCommitFileQueueW(Owner, QueueHandle, MsgHandler, Context) {
        Owner := Owner is Win32Handle ? NumGet(Owner, "ptr") : Owner

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCommitFileQueueW", "ptr", Owner, "ptr", QueueHandle, "ptr", MsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupScanFileQueue function scans a setup file queue, performing an operation on each node in its copy list. The operation is specified by a set of flags. This function can be called either before or after the queue has been committed.
     * @param {Pointer<Void>} FileQueue Handle to the setup file queue whose copy list is to be scanned or iterated.
     * @param {Integer} Flags Flags to combine to control the file queue scan operation. Note that either SPQ_SCAN_FILE_PRESENCE, SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX, or SPQ_SCAN_FILE_VALIDITY must be specified. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_FILE_PRESENCE"></a><a id="spq_scan_file_presence"></a><dl>
     * <dt><b>SPQ_SCAN_FILE_PRESENCE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target files in the copy queue  are already present on the target.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_FILE_VALIDITY"></a><a id="spq_scan_file_validity"></a><dl>
     * <dt><b>SPQ_SCAN_FILE_VALIDITY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target files in the copy queue  are already present on the target with valid signatures. Available  with Windows2000 and later versions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACK"></a><a id="spq_scan_use_callback"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Callback routine for each node of the queue. If the callback routine returns a nonzero value, the queue processing stops and 
     * <b>SetupScanFileQueue</b> returns zero. Issue a 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-queuescan">SPFILENOTIFY_QUEUESCAN</a> notification code and a pass a pointer to the target path as <i>Param1</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACKEX"></a><a id="spq_scan_use_callbackex"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACKEX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Callback routine for each node of the queue. If the callback routine returns a nonzero value, the queue processing stops and 
     * <b>SetupScanFileQueue</b> returns zero. Issue a SPFILENOTIFY_QUEUESCAN_EX notification and pass a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-filepaths_a">FILEPATHS</a> structure as <i>Param1</i>. SPQ_SCAN_USE_CALLBACKEX also checks that the file has a valid signature. Available starting with Windows2000. On WindowsXP only, you can turn off signature checking by combining this flag with SPQ_SCAN_FILE_PRESENCE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_INFORM_USER"></a><a id="spq_scan_inform_user"></a><dl>
     * <dt><b>SPQ_SCAN_INFORM_USER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Flag  specified when all  files in the queue pass the check for valid signatures. 
     * <b>SetupScanFileQueue</b> informs the user that the operation requires files that are already present on the target. This flag is ignored if SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY is not specified. This flag may not be used with SPQ_SCAN_PRUNE_COPY_QUEUE or SPQ_SCAN_PRUNE_DELREN.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_PRUNE_COPY_QUEUE"></a><a id="spq_scan_prune_copy_queue"></a><dl>
     * <dt><b>SPQ_SCAN_PRUNE_COPY_QUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Combined with SPQ_SCAN_FILE_PRESENCE, removes present entries from the copy queue. When combined with SPQ_SCAN_FILE_VALIDITY, removes signed entries from the copy queue. Available starting with Windows2000. On WindowsXP only, files that are also specified in the delete queue or rename queues are not pruned unless SPQ_SCAN_PRUNE_DELREN is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACK_SIGNERINFO"></a><a id="spq_scan_use_callback_signerinfo"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACK_SIGNERINFO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Available starting with WindowsXP. Issues SPFILENOTIFY_QUEUESCAN_SIGNERINFO notification and passes a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-filepaths_signerinfo_a">FILEPATHS_SIGNERINFO</a> structure as <i>Param1</i>. Checks each file for a valid signature and reports signature information through the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_PRUNE_DELREN"></a><a id="spq_scan_prune_delren"></a><dl>
     * <dt><b>SPQ_SCAN_PRUNE_DELREN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Combined with SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY, removes entries in the delete  or rename queue that are also in the copy queue. When combined with SPQ_SCAN_PRUNE_COPY_QUEUE, limits files that are removed from the copy queue to files that are not in  the delete  or  rename queues. Available starting with WindowsXP.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HWND} Window Optional handle to the window to own dialog boxes that are presented. This parameter is not used if the <i>Flags</i> parameter does not contain SPQ_SCAN_FILE_PRESENCE or if <i>Flags</i> does not contain SPQ_SCAN_INFORM_USER.
     * @param {Pointer<PSP_FILE_CALLBACK_A>} CallbackRoutine Optional pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> callback function to be called on each node of the copy queue. The notification code passed to the callback function is 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-queuescan">SPFILENOTIFY_QUEUESCAN</a>. This parameter is required if <i>Flags</i> includes SPQ_SCAN_USE_CALLBACK. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>You must supply the callback routine specified by <i>CallbackRoutine</i>. The default queue callback routine does not support 
     * <b>SetupScanFileQueue</b>.</div>
     * <div></div>
     * @param {Pointer<Void>} CallbackContext Optional pointer to a context that contains caller-defined data passed to the callback routine pointed to by <i>CallbackRoutine</i>.
     * @param {Pointer<Integer>} Result Pointer to a variable that receives the result of the scan operation.
     * @returns {BOOL} The function returns a nonzero value if all nodes in the queue were processed.
     * 
     * If the SPQ_SCAN_USE_CALLBACK flag was set, the value in <i>Result</i> is 0. The callback routine specified by <i>CallbackRoutine</i> is sent the notification SPFILENOTIFY_QUEUESCAN. <i>CallbackRoutine.Param1</i> specifies a pointer to an array that contains the target path information. The pointer has been cast to an unsigned integer and must be recast to a TCHAR array of MAX_PATH elements before a callback routine can access the information. <i>CallbackRoutine.Param2</i> is set to SPQ_DELAYED_COPY if the current queue node is in use and cannot be copied until the system is restarted. Otherwise, <i>CallbackRoutine.Param2</i> takes the value 0.
     * 
     * If SPQ_SCAN_USE_CALLBACK was not set, <i>Result</i> indicates whether the queue passed the presence or validity check as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue failed the check or it passed the check, but SPQ_SCAN_INFORM_USER was specified and the user wants new copies of the files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that copying is not required. The copy queue is empty and there are no elements on the delete or rename queues, so the caller can skip queue commit.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that copying is not required. The copy queue is empty, but there are elements on the delete or rename queues, so the caller cannot skip queue commit.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The function returns zero if an error occurred or the callback function returned nonzero. If <i>Result</i> is nonzero, it is the value returned by the callback function that stopped queue processing. If <i>Result</i> is zero, extended error information can be retrieved by a call to 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupscanfilequeuea
     * @since windows5.1.2600
     */
    static SetupScanFileQueueA(FileQueue, Flags, Window, CallbackRoutine, CallbackContext, Result) {
        Window := Window is Win32Handle ? NumGet(Window, "ptr") : Window

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupScanFileQueueA", "ptr", FileQueue, "uint", Flags, "ptr", Window, "ptr", CallbackRoutine, "ptr", CallbackContext, "uint*", Result, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupScanFileQueue function scans a setup file queue, performing an operation on each node in its copy list. The operation is specified by a set of flags. This function can be called either before or after the queue has been committed.
     * @param {Pointer<Void>} FileQueue Handle to the setup file queue whose copy list is to be scanned or iterated.
     * @param {Integer} Flags Flags to combine to control the file queue scan operation. Note that either SPQ_SCAN_FILE_PRESENCE, SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX, or SPQ_SCAN_FILE_VALIDITY must be specified. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_FILE_PRESENCE"></a><a id="spq_scan_file_presence"></a><dl>
     * <dt><b>SPQ_SCAN_FILE_PRESENCE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target files in the copy queue  are already present on the target.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_FILE_VALIDITY"></a><a id="spq_scan_file_validity"></a><dl>
     * <dt><b>SPQ_SCAN_FILE_VALIDITY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target files in the copy queue  are already present on the target with valid signatures. Available  with Windows2000 and later versions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACK"></a><a id="spq_scan_use_callback"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Callback routine for each node of the queue. If the callback routine returns a nonzero value, the queue processing stops and 
     * <b>SetupScanFileQueue</b> returns zero. Issue a 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-queuescan">SPFILENOTIFY_QUEUESCAN</a> notification code and a pass a pointer to the target path as <i>Param1</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACKEX"></a><a id="spq_scan_use_callbackex"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACKEX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Callback routine for each node of the queue. If the callback routine returns a nonzero value, the queue processing stops and 
     * <b>SetupScanFileQueue</b> returns zero. Issue a SPFILENOTIFY_QUEUESCAN_EX notification and pass a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-filepaths_a">FILEPATHS</a> structure as <i>Param1</i>. SPQ_SCAN_USE_CALLBACKEX also checks that the file has a valid signature. Available starting with Windows2000. On WindowsXP only, you can turn off signature checking by combining this flag with SPQ_SCAN_FILE_PRESENCE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_INFORM_USER"></a><a id="spq_scan_inform_user"></a><dl>
     * <dt><b>SPQ_SCAN_INFORM_USER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Flag  specified when all  files in the queue pass the check for valid signatures. 
     * <b>SetupScanFileQueue</b> informs the user that the operation requires files that are already present on the target. This flag is ignored if SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY is not specified. This flag may not be used with SPQ_SCAN_PRUNE_COPY_QUEUE or SPQ_SCAN_PRUNE_DELREN.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_PRUNE_COPY_QUEUE"></a><a id="spq_scan_prune_copy_queue"></a><dl>
     * <dt><b>SPQ_SCAN_PRUNE_COPY_QUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Combined with SPQ_SCAN_FILE_PRESENCE, removes present entries from the copy queue. When combined with SPQ_SCAN_FILE_VALIDITY, removes signed entries from the copy queue. Available starting with Windows2000. On WindowsXP only, files that are also specified in the delete queue or rename queues are not pruned unless SPQ_SCAN_PRUNE_DELREN is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACK_SIGNERINFO"></a><a id="spq_scan_use_callback_signerinfo"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACK_SIGNERINFO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Available starting with WindowsXP. Issues SPFILENOTIFY_QUEUESCAN_SIGNERINFO notification and passes a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-filepaths_signerinfo_a">FILEPATHS_SIGNERINFO</a> structure as <i>Param1</i>. Checks each file for a valid signature and reports signature information through the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_PRUNE_DELREN"></a><a id="spq_scan_prune_delren"></a><dl>
     * <dt><b>SPQ_SCAN_PRUNE_DELREN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Combined with SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY, removes entries in the delete  or rename queue that are also in the copy queue. When combined with SPQ_SCAN_PRUNE_COPY_QUEUE, limits files that are removed from the copy queue to files that are not in  the delete  or  rename queues. Available starting with WindowsXP.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HWND} Window Optional handle to the window to own dialog boxes that are presented. This parameter is not used if the <i>Flags</i> parameter does not contain SPQ_SCAN_FILE_PRESENCE or if <i>Flags</i> does not contain SPQ_SCAN_INFORM_USER.
     * @param {Pointer<PSP_FILE_CALLBACK_W>} CallbackRoutine Optional pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> callback function to be called on each node of the copy queue. The notification code passed to the callback function is 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-queuescan">SPFILENOTIFY_QUEUESCAN</a>. This parameter is required if <i>Flags</i> includes SPQ_SCAN_USE_CALLBACK. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>You must supply the callback routine specified by <i>CallbackRoutine</i>. The default queue callback routine does not support 
     * <b>SetupScanFileQueue</b>.</div>
     * <div></div>
     * @param {Pointer<Void>} CallbackContext Optional pointer to a context that contains caller-defined data passed to the callback routine pointed to by <i>CallbackRoutine</i>.
     * @param {Pointer<Integer>} Result Pointer to a variable that receives the result of the scan operation.
     * @returns {BOOL} The function returns a nonzero value if all nodes in the queue were processed.
     * 
     * If the SPQ_SCAN_USE_CALLBACK flag was set, the value in <i>Result</i> is 0. The callback routine specified by <i>CallbackRoutine</i> is sent the notification SPFILENOTIFY_QUEUESCAN. <i>CallbackRoutine.Param1</i> specifies a pointer to an array that contains the target path information. The pointer has been cast to an unsigned integer and must be recast to a TCHAR array of MAX_PATH elements before a callback routine can access the information. <i>CallbackRoutine.Param2</i> is set to SPQ_DELAYED_COPY if the current queue node is in use and cannot be copied until the system is restarted. Otherwise, <i>CallbackRoutine.Param2</i> takes the value 0.
     * 
     * If SPQ_SCAN_USE_CALLBACK was not set, <i>Result</i> indicates whether the queue passed the presence or validity check as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue failed the check or it passed the check, but SPQ_SCAN_INFORM_USER was specified and the user wants new copies of the files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that copying is not required. The copy queue is empty and there are no elements on the delete or rename queues, so the caller can skip queue commit.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that copying is not required. The copy queue is empty, but there are elements on the delete or rename queues, so the caller cannot skip queue commit.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The function returns zero if an error occurred or the callback function returned nonzero. If <i>Result</i> is nonzero, it is the value returned by the callback function that stopped queue processing. If <i>Result</i> is zero, extended error information can be retrieved by a call to 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupscanfilequeuew
     * @since windows5.1.2600
     */
    static SetupScanFileQueueW(FileQueue, Flags, Window, CallbackRoutine, CallbackContext, Result) {
        Window := Window is Win32Handle ? NumGet(Window, "ptr") : Window

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupScanFileQueueW", "ptr", FileQueue, "uint", Flags, "ptr", Window, "ptr", CallbackRoutine, "ptr", CallbackContext, "uint*", Result, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileQueueCount function gets the count from a setup file queue.
     * @param {Pointer<Void>} FileQueue Handle to an open setup file queue.
     * @param {Integer} SubQueueFileOp Flag that specifies which subqueue count to be returned. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl>
     * <dt><b>FILEOP_COPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the number of entries in the copy subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILEOP_RENAME"></a><a id="fileop_rename"></a><dl>
     * <dt><b>FILEOP_RENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the number of entries in the rename subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILEOP_DELETE"></a><a id="fileop_delete"></a><dl>
     * <dt><b>FILEOP_DELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the number of entries in the delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILEOP_BACKUP"></a><a id="fileop_backup"></a><dl>
     * <dt><b>FILEOP_BACKUP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the number of entries in the backup subqueue.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Integer>} NumOperations Count from the setup file queue.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetfilequeuecount
     * @since windows5.1.2600
     */
    static SetupGetFileQueueCount(FileQueue, SubQueueFileOp, NumOperations) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileQueueCount", "ptr", FileQueue, "uint", SubQueueFileOp, "uint*", NumOperations, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileQueueFlags function gets the flags from a setup file queue.
     * @param {Pointer<Void>} FileQueue Handle to an open setup file queue.
     * @param {Pointer<Integer>} Flags Pointer to location that contains the flag set with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupsetfilequeueflags">SetupSetFileQueueFlags</a> and returned by 
     * <b>SetupGetFileQueueFlags</b>. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_BACKUP_AWARE"></a><a id="spq_flag_backup_aware"></a><dl>
     * <dt><b>SPQ_FLAG_BACKUP_AWARE</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a> issues backup notifications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_ABORT_IF_UNSIGNED"></a><a id="spq_flag_abort_if_unsigned"></a><dl>
     * <dt><b>SPQ_FLAG_ABORT_IF_UNSIGNED</b></dt>
     * <dt>0X002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For internal use only.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetfilequeueflags
     * @since windows5.1.2600
     */
    static SetupGetFileQueueFlags(FileQueue, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileQueueFlags", "ptr", FileQueue, "uint*", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetFileQueueFlags function sets the flags on a setup file queue.
     * @param {Pointer<Void>} FileQueue Handle to an open setup file queue.
     * @param {Integer} FlagMask Mask of valid flags. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_VALID"></a><a id="spq_flag_valid"></a><dl>
     * <dt><b>SPQ_FLAG_VALID</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Mask for use with SPQ_FLAG_BACKUP_AWARE.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Flags Flags for use with 
     * <b>SetupSetFileQueueFlags</b> and returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetfilequeueflags">SetupGetFileQueueFlags</a>. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_BACKUP_AWARE"></a><a id="spq_flag_backup_aware"></a><dl>
     * <dt><b>SPQ_FLAG_BACKUP_AWARE</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a> issues backup notifications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_ABORT_IF_UNSIGNED"></a><a id="spq_flag_abort_if_unsigned"></a><dl>
     * <dt><b>SPQ_FLAG_ABORT_IF_UNSIGNED</b></dt>
     * <dt>0X002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For internal use only.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is (0) zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetfilequeueflags
     * @since windows5.1.2600
     */
    static SetupSetFileQueueFlags(FileQueue, FlagMask, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetFileQueueFlags", "ptr", FileQueue, "uint", FlagMask, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCopyOEMInf function copies a specified .inf file to the %windir%/Inf directory.
     * @param {PSTR} SourceInfFileName Full path to the source .inf file. You should use a null-terminated string. This path should not exceed <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
     * @param {PSTR} OEMSourceMediaLocation Source location information to be stored in the precompiled .inf (.pnf). This location information is specific to the source media type specified. You should use a null-terminated string. This path should not exceed <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
     * @param {Integer} OEMSourceMediaType 
     * @param {Integer} CopyStyle Specifies how the .inf file is copied into the .inf directory. The following flags can be combined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl>
     * <dt><b>SP_COPY_DELETESOURCE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete source file on successful copy.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a id="sp_copy_replaceonly"></a><dl>
     * <dt><b>SP_COPY_REPLACEONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Copy only if this file already exists in the Inf directory. This flag could be used to update the source location information for an existing .inf.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a id="sp_copy_nooverwrite"></a><dl>
     * <dt><b>SP_COPY_NOOVERWRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Copy only if the specified files do not currently exist in the Inf directory. If the .inf does currently exist, this API fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_FILE_EXISTS. In this case, the existing .inf file's filename is placed into the appropriate field in the destination .inf file's information output buffers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_OEMINF_CATALOG_ONLY"></a><a id="sp_copy_oeminf_catalog_only"></a><dl>
     * <dt><b>SP_COPY_OEMINF_CATALOG_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified .inf file's corresponding catalog files is copied to %windir%\Inf. If this flag is specified, the destination filename information is entered upon successful return if the specified .inf file already exists in the Inf directory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PSTR} DestinationInfFileName Pointer to a buffer to receive the .inf file name assigned to it at the time it was copied to the Inf directory. The buffer, if specified, should typically be <b>MAX_PATH</b> in length. If the SP_COPY_NOOVERWRITE flag is specified and the <b>SetupCopyOEMInf</b> function fails with a return code of ERROR_FILE_EXISTS, this buffer contains the name of the existing .inf file. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this buffer contains the destination .inf filename if the .inf file is already present in the Inf directory. Otherwise, this buffer is set to the empty string. This parameter can be <b>NULL</b>.
     * @param {Integer} DestinationInfFileNameSize Size of the <i>DestinationInfFileName</i> buffer, in characters, or zero if the buffer is not specified. If <i>DestinationInfFileName</i> is specified and this buffer size is less than the size required to return the destination .inf filename (including full path), this function fails. In this case <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} RequiredSize Pointer to a variable that receives the size (in characters) required to store the destination .inf file name including a terminating <b>NULL</b>. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this variable receives a string length only if the .inf file already exists in the Inf directory. Otherwise, this variable is set to zero. This parameter can be <b>NULL</b>.
     * @param {Pointer<PSTR>} DestinationInfFileNameComponent Pointer to a string that is set upon successful return (or ERROR_FILE_EXISTS) to point to the beginning of the filename component of the path stored in the <i>DestinationInfFileName</i> parameter. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, the <i>DestinationInfFileName</i> parameter may be an empty string. In this case, the character pointer is set to <b>NULL</b> upon successful return. This parameter can be <b>NULL</b>.
     * @returns {BOOL} This function returns WINSETUPAPI BOOL.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcopyoeminfa
     * @since windows5.1.2600
     */
    static SetupCopyOEMInfA(SourceInfFileName, OEMSourceMediaLocation, OEMSourceMediaType, CopyStyle, DestinationInfFileName, DestinationInfFileNameSize, RequiredSize, DestinationInfFileNameComponent) {
        SourceInfFileName := SourceInfFileName is String ? StrPtr(SourceInfFileName) : SourceInfFileName
        OEMSourceMediaLocation := OEMSourceMediaLocation is String ? StrPtr(OEMSourceMediaLocation) : OEMSourceMediaLocation
        DestinationInfFileName := DestinationInfFileName is String ? StrPtr(DestinationInfFileName) : DestinationInfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCopyOEMInfA", "ptr", SourceInfFileName, "ptr", OEMSourceMediaLocation, "uint", OEMSourceMediaType, "uint", CopyStyle, "ptr", DestinationInfFileName, "uint", DestinationInfFileNameSize, "uint*", RequiredSize, "ptr", DestinationInfFileNameComponent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCopyOEMInf function copies a specified .inf file to the %windir%/Inf directory.
     * @param {PWSTR} SourceInfFileName Full path to the source .inf file. You should use a null-terminated string. This path should not exceed <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
     * @param {PWSTR} OEMSourceMediaLocation Source location information to be stored in the precompiled .inf (.pnf). This location information is specific to the source media type specified. You should use a null-terminated string. This path should not exceed <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
     * @param {Integer} OEMSourceMediaType 
     * @param {Integer} CopyStyle Specifies how the .inf file is copied into the .inf directory. The following flags can be combined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl>
     * <dt><b>SP_COPY_DELETESOURCE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete source file on successful copy.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a id="sp_copy_replaceonly"></a><dl>
     * <dt><b>SP_COPY_REPLACEONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Copy only if this file already exists in the Inf directory. This flag could be used to update the source location information for an existing .inf.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a id="sp_copy_nooverwrite"></a><dl>
     * <dt><b>SP_COPY_NOOVERWRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Copy only if the specified files do not currently exist in the Inf directory. If the .inf does currently exist, this API fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_FILE_EXISTS. In this case, the existing .inf file's filename is placed into the appropriate field in the destination .inf file's information output buffers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_OEMINF_CATALOG_ONLY"></a><a id="sp_copy_oeminf_catalog_only"></a><dl>
     * <dt><b>SP_COPY_OEMINF_CATALOG_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified .inf file's corresponding catalog files is copied to %windir%\Inf. If this flag is specified, the destination filename information is entered upon successful return if the specified .inf file already exists in the Inf directory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} DestinationInfFileName Pointer to a buffer to receive the .inf file name assigned to it at the time it was copied to the Inf directory. The buffer, if specified, should typically be <b>MAX_PATH</b> in length. If the SP_COPY_NOOVERWRITE flag is specified and the <b>SetupCopyOEMInf</b> function fails with a return code of ERROR_FILE_EXISTS, this buffer contains the name of the existing .inf file. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this buffer contains the destination .inf filename if the .inf file is already present in the Inf directory. Otherwise, this buffer is set to the empty string. This parameter can be <b>NULL</b>.
     * @param {Integer} DestinationInfFileNameSize Size of the <i>DestinationInfFileName</i> buffer, in characters, or zero if the buffer is not specified. If <i>DestinationInfFileName</i> is specified and this buffer size is less than the size required to return the destination .inf filename (including full path), this function fails. In this case <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} RequiredSize Pointer to a variable that receives the size (in characters) required to store the destination .inf file name including a terminating <b>NULL</b>. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this variable receives a string length only if the .inf file already exists in the Inf directory. Otherwise, this variable is set to zero. This parameter can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} DestinationInfFileNameComponent Pointer to a string that is set upon successful return (or ERROR_FILE_EXISTS) to point to the beginning of the filename component of the path stored in the <i>DestinationInfFileName</i> parameter. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, the <i>DestinationInfFileName</i> parameter may be an empty string. In this case, the character pointer is set to <b>NULL</b> upon successful return. This parameter can be <b>NULL</b>.
     * @returns {BOOL} This function returns WINSETUPAPI BOOL.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcopyoeminfw
     * @since windows5.1.2600
     */
    static SetupCopyOEMInfW(SourceInfFileName, OEMSourceMediaLocation, OEMSourceMediaType, CopyStyle, DestinationInfFileName, DestinationInfFileNameSize, RequiredSize, DestinationInfFileNameComponent) {
        SourceInfFileName := SourceInfFileName is String ? StrPtr(SourceInfFileName) : SourceInfFileName
        OEMSourceMediaLocation := OEMSourceMediaLocation is String ? StrPtr(OEMSourceMediaLocation) : OEMSourceMediaLocation
        DestinationInfFileName := DestinationInfFileName is String ? StrPtr(DestinationInfFileName) : DestinationInfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCopyOEMInfW", "ptr", SourceInfFileName, "ptr", OEMSourceMediaLocation, "uint", OEMSourceMediaType, "uint", CopyStyle, "ptr", DestinationInfFileName, "uint", DestinationInfFileNameSize, "uint*", RequiredSize, "ptr", DestinationInfFileNameComponent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupUninstallOEMInf function uninstalls a specified .inf file and any associated .pnf file.
     * @param {PSTR} InfFileName File name, without path, of the .inf file in the Windows Inf directory that is to be uninstalled.
     * @param {Integer} Flags This parameter can be set as follows.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SUOI_FORCEDELETE"></a><a id="suoi_forcedelete"></a><dl>
     * <dt><b>SUOI_FORCEDELETE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>SetupUninstallOEMInf</b> function first checks whether there are any devices installed using the .inf file. A device does not need to be  present to be detected as using the .inf file.
     * 
     * If this flag is not set and the function finds a currently installed device that was installed using this .inf file, the .inf file is not removed.
     * 
     * If this flag is set, the .inf file is removed whether  the function finds a device that was installed with this .inf file.
     * 
     * <div class="alert"><b>Note</b>This flag only applies to x86, amd64, and ia64 architectures. It is ignored on all other architectures.</div>
     * <div></div>
     * <div class="alert"><b>Note</b>If the driver package has any files that are copied to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-destinationdirs-section">DestinationDir</a> that uses a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/using-dirids">dirid</a> of 13, then this force flag is ignored.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} This function returns WINSETUPAPI BOOL.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupuninstalloeminfa
     * @since windows5.1.2600
     */
    static SetupUninstallOEMInfA(InfFileName, Flags) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfFileName := InfFileName is String ? StrPtr(InfFileName) : InfFileName

        result := DllCall("SETUPAPI.dll\SetupUninstallOEMInfA", "ptr", InfFileName, "uint", Flags, "ptr", Reserved, "int")
        return result
    }

    /**
     * The SetupUninstallOEMInf function uninstalls a specified .inf file and any associated .pnf file.
     * @param {PWSTR} InfFileName File name, without path, of the .inf file in the Windows Inf directory that is to be uninstalled.
     * @param {Integer} Flags This parameter can be set as follows.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SUOI_FORCEDELETE"></a><a id="suoi_forcedelete"></a><dl>
     * <dt><b>SUOI_FORCEDELETE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>SetupUninstallOEMInf</b> function first checks whether there are any devices installed using the .inf file. A device does not need to be  present to be detected as using the .inf file.
     * 
     * If this flag is not set and the function finds a currently installed device that was installed using this .inf file, the .inf file is not removed.
     * 
     * If this flag is set, the .inf file is removed whether  the function finds a device that was installed with this .inf file.
     * 
     * <div class="alert"><b>Note</b>This flag only applies to x86, amd64, and ia64 architectures. It is ignored on all other architectures.</div>
     * <div></div>
     * <div class="alert"><b>Note</b>If the driver package has any files that are copied to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-destinationdirs-section">DestinationDir</a> that uses a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/using-dirids">dirid</a> of 13, then this force flag is ignored.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} This function returns WINSETUPAPI BOOL.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupuninstalloeminfw
     * @since windows5.1.2600
     */
    static SetupUninstallOEMInfW(InfFileName, Flags) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfFileName := InfFileName is String ? StrPtr(InfFileName) : InfFileName

        result := DllCall("SETUPAPI.dll\SetupUninstallOEMInfW", "ptr", InfFileName, "uint", Flags, "ptr", Reserved, "int")
        return result
    }

    /**
     * The SetupUninstallNewlyCopiedInfs function uninstalls INF files (.inf), precompiled INF files (.pnf), and catalog files (.cat) that are previously installed during the committal of the specified file queue.
     * @param {Pointer<Void>} FileQueue Handle to an open and committed file queue. This queue contains the newly installed INF, PNF, or CAT files that 
     * <b>SetupUninstallNewlyCopiedInfs</b> uninstalls.
     * @param {Integer} Flags Flags to use with 
     * <b>SetupUninstallNewlyCopiedInfs</b>. No flags are defined currently. This parameter must be 0 (zero).
     * @returns {BOOL} If the parameters passed in are valid, the return value is <b>TRUE</b> (nonzero), which does not necessarily mean that any INFs are uninstalled.
     * 
     * If some of the parameters passed in are invalid, the return value is <b>FALSE</b> (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupuninstallnewlycopiedinfs
     * @since windows5.1.2600
     */
    static SetupUninstallNewlyCopiedInfs(FileQueue, Flags) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupUninstallNewlyCopiedInfs", "ptr", FileQueue, "uint", Flags, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCreateDiskSpaceList function creates a disk-space list.
     * @param {Integer} Flags This parameter can be the following value.
     * @returns {Pointer<Void>} If the function succeeds, it returns a handle to the disk-space list.
     * 
     * If the function fails, it returns null. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcreatediskspacelista
     * @since windows5.1.2600
     */
    static SetupCreateDiskSpaceListA(Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCreateDiskSpaceListA", "ptr", Reserved1, "uint", Reserved2, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCreateDiskSpaceList function creates a disk-space list.
     * @param {Integer} Flags This parameter can be the following value.
     * @returns {Pointer<Void>} If the function succeeds, it returns a handle to the disk-space list.
     * 
     * If the function fails, it returns null. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcreatediskspacelistw
     * @since windows5.1.2600
     */
    static SetupCreateDiskSpaceListW(Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCreateDiskSpaceListW", "ptr", Reserved1, "uint", Reserved2, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDuplicateDiskSpaceList function duplicates a disk-space list as a new independent disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list to be duplicated.
     * @param {Integer} Flags Unused, must be  zero.
     * @returns {Pointer<Void>} If the function succeeds, it returns a handle to the new disk-space list.
     * 
     * If the function fails, it returns null. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupduplicatediskspacelista
     * @since windows5.1.2600
     */
    static SetupDuplicateDiskSpaceListA(DiskSpace, Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDuplicateDiskSpaceListA", "ptr", DiskSpace, "ptr", Reserved1, "uint", Reserved2, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDuplicateDiskSpaceList function duplicates a disk-space list as a new independent disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list to be duplicated.
     * @param {Integer} Flags Unused, must be  zero.
     * @returns {Pointer<Void>} If the function succeeds, it returns a handle to the new disk-space list.
     * 
     * If the function fails, it returns null. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupduplicatediskspacelistw
     * @since windows5.1.2600
     */
    static SetupDuplicateDiskSpaceListW(DiskSpace, Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDuplicateDiskSpaceListW", "ptr", DiskSpace, "ptr", Reserved1, "uint", Reserved2, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDestroyDiskSpaceList function destroys a disk-space list and releases the resources allocated to it.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list to be deconstructed.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdestroydiskspacelist
     * @since windows5.1.2600
     */
    static SetupDestroyDiskSpaceList(DiskSpace) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDestroyDiskSpaceList", "ptr", DiskSpace, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryDrivesInDiskSpaceList function fills a buffer with a list of the drives referenced by the file operations listed in the disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {PSTR} ReturnBuffer Optional pointer to a buffer that receives the drive specifications, such as "X:" or "\\server\share". You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be <b>NULL</b>.
     * If this parameter is not specified and no error occurs, the function returns a nonzero value and <i>RequiredSize</i> receives the buffer size required to hold the drive specifications.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. This parameter is ignored if <i>ReturnBuffer</i> is not specified.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the size of the buffer required to hold the <b>null</b>-terminated list of drives, in characters. This includes the <b>null</b> terminator.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns ERROR_INSUFFICIENT_BUFFER, <i>ReturnBuffer</i> was specified, but <i>ReturnBufferSize</i> indicated that the supplied buffer was too small.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupquerydrivesindiskspacelista
     * @since windows5.1.2600
     */
    static SetupQueryDrivesInDiskSpaceListA(DiskSpace, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryDrivesInDiskSpaceListA", "ptr", DiskSpace, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryDrivesInDiskSpaceList function fills a buffer with a list of the drives referenced by the file operations listed in the disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {PWSTR} ReturnBuffer Optional pointer to a buffer that receives the drive specifications, such as "X:" or "\\server\share". You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be <b>NULL</b>.
     * If this parameter is not specified and no error occurs, the function returns a nonzero value and <i>RequiredSize</i> receives the buffer size required to hold the drive specifications.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. This parameter is ignored if <i>ReturnBuffer</i> is not specified.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the size of the buffer required to hold the <b>null</b>-terminated list of drives, in characters. This includes the <b>null</b> terminator.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns ERROR_INSUFFICIENT_BUFFER, <i>ReturnBuffer</i> was specified, but <i>ReturnBufferSize</i> indicated that the supplied buffer was too small.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupquerydrivesindiskspacelistw
     * @since windows5.1.2600
     */
    static SetupQueryDrivesInDiskSpaceListW(DiskSpace, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String ? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryDrivesInDiskSpaceListW", "ptr", DiskSpace, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQuerySpaceRequiredOnDrive function examines a disk space list to determine the space that is required to perform all the file operations listed for a specific drive.
     * @param {Pointer<Void>} DiskSpace The handle to a disk space list.
     * @param {PSTR} DriveSpec A pointer to a null-terminated string that specifies the drive where space information is to be returned. 
     * 
     * This should be in the form "x:" or "\\server\share".
     * @param {Pointer<Integer>} SpaceRequired If the function succeeds, this parameter receives the amount of additional space that is required to process all the file operations listed in the disk space list for the drive that <i>DriveSpec</i> specifies. 
     * 
     * 
     * 
     * 
     * The 
     * <b>SetupQuerySpaceRequiredOnDrive</b> function calculates the additional space required on the target drive by checking for preexisting versions of the files on the target drive.
     * 
     * For example, if a file operation copies a 2000-byte file, FIRST.EXE, to the directory, C:\MYPROG\, the 
     * <b>SetupQuerySpaceRequiredOnDrive</b> function automatically checks for a preexisting version of that file in that directory. If a preexisting version of C:\MYPROG\FIRST.EXE has a file size of 500 bytes, the additional space required on the drive C for that operation is 1500 bytes.
     * 
     * The value received can be 0 (zero) or a negative number, if additional space is not required, or if space is freed on the target drive.
     * 
     * If FIRST.EXE in the preceding example is being deleted from the drive C, the amount of space required is 2000 bytes, or the space freed on drive C.
     * 
     * If the preexisting version has a file size of 5000 bytes, then the disk space required to replace it with the 2000-byte FIRST.EXE is 3000 bytes.
     * 
     * File sizes are rounded to disk cluster boundaries.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value and <i>SpaceRequired</i> receives the amount of space required by the file operations listed in the current disk space list.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DRIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is not on the disk-space list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>DiskSpace</i> handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>DriveSpec</i> string is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryspacerequiredondrivea
     * @since windows5.1.2600
     */
    static SetupQuerySpaceRequiredOnDriveA(DiskSpace, DriveSpec, SpaceRequired) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DriveSpec := DriveSpec is String ? StrPtr(DriveSpec) : DriveSpec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQuerySpaceRequiredOnDriveA", "ptr", DiskSpace, "ptr", DriveSpec, "int64*", SpaceRequired, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQuerySpaceRequiredOnDrive function examines a disk space list to determine the space that is required to perform all the file operations listed for a specific drive.
     * @param {Pointer<Void>} DiskSpace The handle to a disk space list.
     * @param {PWSTR} DriveSpec A pointer to a null-terminated string that specifies the drive where space information is to be returned. 
     * 
     * This should be in the form "x:" or "\\server\share".
     * @param {Pointer<Integer>} SpaceRequired If the function succeeds, this parameter receives the amount of additional space that is required to process all the file operations listed in the disk space list for the drive that <i>DriveSpec</i> specifies. 
     * 
     * 
     * 
     * 
     * The 
     * <b>SetupQuerySpaceRequiredOnDrive</b> function calculates the additional space required on the target drive by checking for preexisting versions of the files on the target drive.
     * 
     * For example, if a file operation copies a 2000-byte file, FIRST.EXE, to the directory, C:\MYPROG\, the 
     * <b>SetupQuerySpaceRequiredOnDrive</b> function automatically checks for a preexisting version of that file in that directory. If a preexisting version of C:\MYPROG\FIRST.EXE has a file size of 500 bytes, the additional space required on the drive C for that operation is 1500 bytes.
     * 
     * The value received can be 0 (zero) or a negative number, if additional space is not required, or if space is freed on the target drive.
     * 
     * If FIRST.EXE in the preceding example is being deleted from the drive C, the amount of space required is 2000 bytes, or the space freed on drive C.
     * 
     * If the preexisting version has a file size of 5000 bytes, then the disk space required to replace it with the 2000-byte FIRST.EXE is 3000 bytes.
     * 
     * File sizes are rounded to disk cluster boundaries.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value and <i>SpaceRequired</i> receives the amount of space required by the file operations listed in the current disk space list.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DRIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is not on the disk-space list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>DiskSpace</i> handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>DriveSpec</i> string is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryspacerequiredondrivew
     * @since windows5.1.2600
     */
    static SetupQuerySpaceRequiredOnDriveW(DiskSpace, DriveSpec, SpaceRequired) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DriveSpec := DriveSpec is String ? StrPtr(DriveSpec) : DriveSpec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQuerySpaceRequiredOnDriveW", "ptr", DiskSpace, "ptr", DriveSpec, "int64*", SpaceRequired, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAdjustDiskSpaceList function adjusts the amount of required space for a specified drive.
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {PSTR} DriveRoot Specifies a valid Win32 drive root. An entry is added to the disk-space list if the specified drive is not currently in the disk-space list.
     * @param {Integer} Amount Specifies the amount of space to add or remove. Use a negative number to remove space and use a positive number to add space.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupadjustdiskspacelista
     * @since windows5.1.2600
     */
    static SetupAdjustDiskSpaceListA(DiskSpace, DriveRoot, Amount) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DriveRoot := DriveRoot is String ? StrPtr(DriveRoot) : DriveRoot

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAdjustDiskSpaceListA", "ptr", DiskSpace, "ptr", DriveRoot, "int64", Amount, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAdjustDiskSpaceList function adjusts the amount of required space for a specified drive.
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {PWSTR} DriveRoot Specifies a valid Win32 drive root. An entry is added to the disk-space list if the specified drive is not currently in the disk-space list.
     * @param {Integer} Amount Specifies the amount of space to add or remove. Use a negative number to remove space and use a positive number to add space.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupadjustdiskspacelistw
     * @since windows5.1.2600
     */
    static SetupAdjustDiskSpaceListW(DiskSpace, DriveRoot, Amount) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DriveRoot := DriveRoot is String ? StrPtr(DriveRoot) : DriveRoot

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAdjustDiskSpaceListW", "ptr", DiskSpace, "ptr", DriveRoot, "int64", Amount, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddToDiskSpaceList function adds a single delete or copy operation to a disk-space list. To add all the file operations in a section of an INF file, use either SetupAddSectionToDiskSpaceList, or SetupAddInstallSectionToDiskSpaceList.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {PSTR} TargetFilespec File name of the file to be added to the disk-space list. You should use a null-terminated string that specifies  a fully qualified path. Otherwise, the path must be relative to the current directory.
     * @param {Integer} FileSize Uncompressed size of the file as it will exist in the target directory, in bytes. You can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetsourcefilesizea">SetupGetSourceFileSize</a> to retrieve this information from an INF file. This parameter is ignored for FILEOP_DELETE operations.
     * @param {Integer} Operation 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupaddtodiskspacelista
     * @since windows5.1.2600
     */
    static SetupAddToDiskSpaceListA(DiskSpace, TargetFilespec, FileSize, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        TargetFilespec := TargetFilespec is String ? StrPtr(TargetFilespec) : TargetFilespec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddToDiskSpaceListA", "ptr", DiskSpace, "ptr", TargetFilespec, "int64", FileSize, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddToDiskSpaceList function adds a single delete or copy operation to a disk-space list. To add all the file operations in a section of an INF file, use either SetupAddSectionToDiskSpaceList, or SetupAddInstallSectionToDiskSpaceList.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {PWSTR} TargetFilespec File name of the file to be added to the disk-space list. You should use a null-terminated string that specifies  a fully qualified path. Otherwise, the path must be relative to the current directory.
     * @param {Integer} FileSize Uncompressed size of the file as it will exist in the target directory, in bytes. You can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetsourcefilesizea">SetupGetSourceFileSize</a> to retrieve this information from an INF file. This parameter is ignored for FILEOP_DELETE operations.
     * @param {Integer} Operation 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupaddtodiskspacelistw
     * @since windows5.1.2600
     */
    static SetupAddToDiskSpaceListW(DiskSpace, TargetFilespec, FileSize, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        TargetFilespec := TargetFilespec is String ? StrPtr(TargetFilespec) : TargetFilespec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddToDiskSpaceListW", "ptr", DiskSpace, "ptr", TargetFilespec, "int64", FileSize, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddSectionToDiskSpaceList function adds to a disk-space list all the file delete or copy operations listed in a Copy Files or Delete Files section of an INF file.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not specified, this INF file must also contain the section named by <i>SectionName</i>.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section specified by <i>SectionName</i>. Otherwise, <i>InfHandle</i> is assumed to contain this section.
     * @param {PSTR} SectionName Name of the <b>Copy Files</b> or <b>Delete Files</b> section that contains the file operations to add to the disk-space list. Use a null-terminated string.
     * @param {Integer} Operation 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupaddsectiontodiskspacelista
     * @since windows5.1.2600
     */
    static SetupAddSectionToDiskSpaceListA(DiskSpace, InfHandle, ListInfHandle, SectionName, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddSectionToDiskSpaceListA", "ptr", DiskSpace, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", SectionName, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddSectionToDiskSpaceList function adds to a disk-space list all the file delete or copy operations listed in a Copy Files or Delete Files section of an INF file.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not specified, this INF file must also contain the section named by <i>SectionName</i>.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section specified by <i>SectionName</i>. Otherwise, <i>InfHandle</i> is assumed to contain this section.
     * @param {PWSTR} SectionName Name of the <b>Copy Files</b> or <b>Delete Files</b> section that contains the file operations to add to the disk-space list. Use a null-terminated string.
     * @param {Integer} Operation 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupaddsectiontodiskspacelistw
     * @since windows5.1.2600
     */
    static SetupAddSectionToDiskSpaceListW(DiskSpace, InfHandle, ListInfHandle, SectionName, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddSectionToDiskSpaceListW", "ptr", DiskSpace, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", SectionName, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddInstallSectionToDiskSpaceList function searches for CopyFile and DelFile lines in an Install section of an INF file. The function then adds the file operations specified in those sections to a disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>Install</b> section to be searched. If <i>ListInfHandle</i> is not specified, the INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} LayoutInfHandle This parameter, if specified, provides the handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
     * @param {PSTR} SectionName Name of the Install section to be added to the disk-space list. You should use a null-terminated string.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupaddinstallsectiontodiskspacelista
     * @since windows5.1.2600
     */
    static SetupAddInstallSectionToDiskSpaceListA(DiskSpace, InfHandle, LayoutInfHandle, SectionName) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddInstallSectionToDiskSpaceListA", "ptr", DiskSpace, "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", SectionName, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddInstallSectionToDiskSpaceList function searches for CopyFile and DelFile lines in an Install section of an INF file. The function then adds the file operations specified in those sections to a disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>Install</b> section to be searched. If <i>ListInfHandle</i> is not specified, the INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} LayoutInfHandle This parameter, if specified, provides the handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
     * @param {PWSTR} SectionName Name of the Install section to be added to the disk-space list. You should use a null-terminated string.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupaddinstallsectiontodiskspacelistw
     * @since windows5.1.2600
     */
    static SetupAddInstallSectionToDiskSpaceListW(DiskSpace, InfHandle, LayoutInfHandle, SectionName) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddInstallSectionToDiskSpaceListW", "ptr", DiskSpace, "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", SectionName, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFromDiskSpaceList function removes a file delete or copy operation from a disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {PSTR} TargetFilespec Pointer to a null-terminated string that specifies the file name of the file to remove from the disk-space list. This is typically a fully qualified  path. Otherwise, the path must be relative to the current directory.
     * @param {Integer} Operation 
     * @returns {BOOL} If the file was not in the list, the 
     * <b>SetupRemoveFromDiskSpaceList</b> function returns a nonzero value and 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME. If the file was in the list then upon success the routine returns a nonzero value and 
     * <b>GetLastError</b> returns NO_ERROR.
     * 
     * If the routine fails for some other reason, it returns zero and 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns extended error information.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremovefromdiskspacelista
     * @since windows5.1.2600
     */
    static SetupRemoveFromDiskSpaceListA(DiskSpace, TargetFilespec, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        TargetFilespec := TargetFilespec is String ? StrPtr(TargetFilespec) : TargetFilespec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFromDiskSpaceListA", "ptr", DiskSpace, "ptr", TargetFilespec, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFromDiskSpaceList function removes a file delete or copy operation from a disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {PWSTR} TargetFilespec Pointer to a null-terminated string that specifies the file name of the file to remove from the disk-space list. This is typically a fully qualified  path. Otherwise, the path must be relative to the current directory.
     * @param {Integer} Operation 
     * @returns {BOOL} If the file was not in the list, the 
     * <b>SetupRemoveFromDiskSpaceList</b> function returns a nonzero value and 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME. If the file was in the list then upon success the routine returns a nonzero value and 
     * <b>GetLastError</b> returns NO_ERROR.
     * 
     * If the routine fails for some other reason, it returns zero and 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns extended error information.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremovefromdiskspacelistw
     * @since windows5.1.2600
     */
    static SetupRemoveFromDiskSpaceListW(DiskSpace, TargetFilespec, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        TargetFilespec := TargetFilespec is String ? StrPtr(TargetFilespec) : TargetFilespec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFromDiskSpaceListW", "ptr", DiskSpace, "ptr", TargetFilespec, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveSectionFromDiskSpaceList function removes the file delete or copy operations listed in a Copy Files section of an INF file from a disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not specified, this INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section to remove from the disk-space list. Otherwise, <i>InfHandle</i> must contain the section specified by <i>SectionName</i>.
     * @param {PSTR} SectionName Pointer to a null-terminated string that specifies the name of the <b>Copy Files</b> or <b>Delete Files</b> section to remove from the disk-space list.
     * @param {Integer} Operation 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremovesectionfromdiskspacelista
     * @since windows5.1.2600
     */
    static SetupRemoveSectionFromDiskSpaceListA(DiskSpace, InfHandle, ListInfHandle, SectionName, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveSectionFromDiskSpaceListA", "ptr", DiskSpace, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", SectionName, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveSectionFromDiskSpaceList function removes the file delete or copy operations listed in a Copy Files section of an INF file from a disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not specified, this INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section to remove from the disk-space list. Otherwise, <i>InfHandle</i> must contain the section specified by <i>SectionName</i>.
     * @param {PWSTR} SectionName Pointer to a null-terminated string that specifies the name of the <b>Copy Files</b> or <b>Delete Files</b> section to remove from the disk-space list.
     * @param {Integer} Operation 
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremovesectionfromdiskspacelistw
     * @since windows5.1.2600
     */
    static SetupRemoveSectionFromDiskSpaceListW(DiskSpace, InfHandle, ListInfHandle, SectionName, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveSectionFromDiskSpaceListW", "ptr", DiskSpace, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", SectionName, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveInstallSectionFromDiskSpaceList function searches an Install section of an INF file for CopyFiles and DelFiles lines, and removes the file operations specified in those sections from a disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>Install</b> section. If <i>LayoutInfHandle</i> is not specified, the INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} LayoutInfHandle Optional handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise, that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
     * @param {PSTR} SectionName Pointer to a null-terminated string that specifies the name of the section to be added to the disk-space list.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremoveinstallsectionfromdiskspacelista
     * @since windows5.1.2600
     */
    static SetupRemoveInstallSectionFromDiskSpaceListA(DiskSpace, InfHandle, LayoutInfHandle, SectionName) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveInstallSectionFromDiskSpaceListA", "ptr", DiskSpace, "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", SectionName, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveInstallSectionFromDiskSpaceList function searches an Install section of an INF file for CopyFiles and DelFiles lines, and removes the file operations specified in those sections from a disk-space list.
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>Install</b> section. If <i>LayoutInfHandle</i> is not specified, the INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} LayoutInfHandle Optional handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise, that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
     * @param {PWSTR} SectionName Pointer to a null-terminated string that specifies the name of the section to be added to the disk-space list.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremoveinstallsectionfromdiskspacelistw
     * @since windows5.1.2600
     */
    static SetupRemoveInstallSectionFromDiskSpaceListW(DiskSpace, InfHandle, LayoutInfHandle, SectionName) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveInstallSectionFromDiskSpaceListW", "ptr", DiskSpace, "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", SectionName, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupIterateCabinet function iterates through all the files in a cabinet and sends a notification to a callback function for each file found.
     * @param {PSTR} CabinetFile Cabinet (.CAB) file to iterate through.
     * @param {Pointer<PSP_FILE_CALLBACK_A>} MsgHandler Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> routine that will process the notifications 
     * <b>SetupIterateCabinet</b> returns as it iterates through the files in the cabinet file. The callback routine may then return a value specifying whether to decompress, copy, or skip the file.
     * @param {Pointer<Void>} Context Context value that is passed into the routine specified in <i>MsgHandler</i>. This enables the callback routine to track values between notifications, without having to use global variables.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupiteratecabineta
     * @since windows5.1.2600
     */
    static SetupIterateCabinetA(CabinetFile, MsgHandler, Context) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        CabinetFile := CabinetFile is String ? StrPtr(CabinetFile) : CabinetFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupIterateCabinetA", "ptr", CabinetFile, "uint", Reserved, "ptr", MsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupIterateCabinet function iterates through all the files in a cabinet and sends a notification to a callback function for each file found.
     * @param {PWSTR} CabinetFile Cabinet (.CAB) file to iterate through.
     * @param {Pointer<PSP_FILE_CALLBACK_W>} MsgHandler Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> routine that will process the notifications 
     * <b>SetupIterateCabinet</b> returns as it iterates through the files in the cabinet file. The callback routine may then return a value specifying whether to decompress, copy, or skip the file.
     * @param {Pointer<Void>} Context Context value that is passed into the routine specified in <i>MsgHandler</i>. This enables the callback routine to track values between notifications, without having to use global variables.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupiteratecabinetw
     * @since windows5.1.2600
     */
    static SetupIterateCabinetW(CabinetFile, MsgHandler, Context) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        CabinetFile := CabinetFile is String ? StrPtr(CabinetFile) : CabinetFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupIterateCabinetW", "ptr", CabinetFile, "uint", Reserved, "ptr", MsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupPromptReboot function asks the user if he wants to reboot the system, optionally dependent on whether any files in a committed file queue were in use during a file operation.
     * @param {Pointer<Void>} FileQueue Optional pointer to a handle to the file queue upon which to base the decision about whether shutdown is necessary. If <i>FileQueue</i> is not specified, 
     * <b>SetupPromptReboot</b> assumes shutdown is necessary and asks the user what to do.
     * @param {HWND} Owner Handle for the parent window to own windows created by this function.
     * @param {BOOL} ScanOnly Indicates whether or not to prompt the user when 
     * <b>SetupPromptReboot</b> is called. 
     * 
     * 
     * 
     * 
     * If <b>TRUE</b>, the user is never asked about rebooting, and system shutdown is not initiated. In this case, <i>FileQueue</i> must be specified. If <b>FALSE</b>, the user is asked about rebooting, as previously described.
     * 
     * Use <i>ScanOnly</i> to determine if shutdown is necessary separately from actually initiating a shutdown.
     * @returns {Integer} The function returns a combination of the following flags or 1 if an error occurs.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuppromptreboot
     * @since windows5.1.2600
     */
    static SetupPromptReboot(FileQueue, Owner, ScanOnly) {
        Owner := Owner is Win32Handle ? NumGet(Owner, "ptr") : Owner

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupPromptReboot", "ptr", FileQueue, "ptr", Owner, "int", ScanOnly, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInitDefaultQueueCallback function initializes the context used by the default queue callback routine included with the Setup API.
     * @param {HWND} OwnerWindow Handle to the window to use as the parent of any dialog boxes generated by the default callback routine.
     * @returns {Pointer<Void>} Pointer to the context used by the default queue callback routine.
     * 
     * If the call to 
     * <b>SetupInitDefaultQueueCallback</b> fails, the function returns a PVOID value of null.
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinitdefaultqueuecallback
     * @since windows5.1.2600
     */
    static SetupInitDefaultQueueCallback(OwnerWindow) {
        OwnerWindow := OwnerWindow is Win32Handle ? NumGet(OwnerWindow, "ptr") : OwnerWindow

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInitDefaultQueueCallback", "ptr", OwnerWindow, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Initializes the context used by the default queue callback routine included with the Setup API in the same manner as SetupInitDefaultQueueCallback, except that an additional window is provided to the callback function to accept progress messages.
     * @param {HWND} OwnerWindow Handle to the window to use as the parent of any dialog boxes generated by the default callback routine.
     * @param {HWND} AlternateProgressWindow Handle to a window that receives the progress messages. To prevent progress messages from being displayed, you can specify this parameter to be INVALID_HANDLE_VALUE.
     * @param {Integer} ProgressMessage Message that is sent to <i>AlternateProgressWindow</i> when the copy queue is started, and each time a file is copied.
     * @returns {Pointer<Void>} <b>SetupInitDefaultQueueCallbackEx</b> returns a pointer to the context used by the default queue callback routine. This function can only fail if there is insufficient memory. If this function fails, it returns <b>NULL</b> and does not set the last-error code for the thread.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinitdefaultqueuecallbackex
     * @since windows5.1.2600
     */
    static SetupInitDefaultQueueCallbackEx(OwnerWindow, AlternateProgressWindow, ProgressMessage) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        OwnerWindow := OwnerWindow is Win32Handle ? NumGet(OwnerWindow, "ptr") : OwnerWindow
        AlternateProgressWindow := AlternateProgressWindow is Win32Handle ? NumGet(AlternateProgressWindow, "ptr") : AlternateProgressWindow

        result := DllCall("SETUPAPI.dll\SetupInitDefaultQueueCallbackEx", "ptr", OwnerWindow, "ptr", AlternateProgressWindow, "uint", ProgressMessage, "uint", Reserved1, "ptr", Reserved2, "ptr")
        return result
    }

    /**
     * The SetupTermDefaultQueueCallback function is called after a queue has finished committing. It frees resources allocated by previous calls to SetupInitDefaultQueueCallback or SetupInitDefaultQueueCallbackEx.
     * @param {Pointer<Void>} Context Pointer to the context used by the default callback routine.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuptermdefaultqueuecallback
     * @since windows5.1.2600
     */
    static SetupTermDefaultQueueCallback(Context) {
        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupTermDefaultQueueCallback", "ptr", Context)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupDefaultQueueCallback function is the default queue callback routine included with the Setup API. You can use it to process notifications sent by the SetupCommitFileQueue function.
     * @param {Pointer<Void>} Context Pointer to the context initialized by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a> functions.
     * @param {Integer} Notification Notification of a queue action. This parameter can be one of the  values shown in the following table. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTQUEUE"></a><a id="spfilenotify_startqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started queued file operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDQUEUE"></a><a id="spfilenotify_endqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished queued file operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTSUBQUEUE"></a><a id="spfilenotify_startsubqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTSUBQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a copy, rename, or delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDSUBQUEUE"></a><a id="spfilenotify_endsubqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDSUBQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a copy, rename, or delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTRENAME"></a><a id="spfilenotify_startrename"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTRENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a rename operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDRENAME"></a><a id="spfilenotify_endrename"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDRENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a rename operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_RENAMEERROR"></a><a id="spfilenotify_renameerror"></a><dl>
     * <dt><b>SPFILENOTIFY_RENAMEERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while renaming a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTDELETE"></a><a id="spfilenotify_startdelete"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTDELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a delete operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDDELETE"></a><a id="spfilenotify_enddelete"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDDELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a delete operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_DELETEERROR"></a><a id="spfilenotify_deleteerror"></a><dl>
     * <dt><b>SPFILENOTIFY_DELETEERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while deleting a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTCOPY"></a><a id="spfilenotify_startcopy"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTCOPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDCOPY"></a><a id="spfilenotify_endcopy"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDCOPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_COPYERROR"></a><a id="spfilenotify_copyerror"></a><dl>
     * <dt><b>SPFILENOTIFY_COPYERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while copying a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_NEEDMEDIA"></a><a id="spfilenotify_needmedia"></a><dl>
     * <dt><b>SPFILENOTIFY_NEEDMEDIA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * New media is required.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_LANGMISMATCH"></a><a id="spfilenotify_langmismatch"></a><dl>
     * <dt><b>SPFILENOTIFY_LANGMISMATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Existing target file is in a different language than the source.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_TARGETEXISTS"></a><a id="spfilenotify_targetexists"></a><dl>
     * <dt><b>SPFILENOTIFY_TARGETEXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target file exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_TARGETNEWER_"></a><a id="spfilenotify_targetnewer_"></a><dl>
     * <dt><b>SPFILENOTIFY_TARGETNEWER </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Existing target file is newer than source.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} Param1 Additional message information. The content of this parameter depends on the value of the <i>Notification</i> parameter.
     * @param {Pointer} Param2 Additional message information. The content of this parameter depends on the value of the <i>Notification</i> parameter.
     * @returns {Integer} Returns an unsigned integer to 
     * <a href="/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a> that can be the one of the values shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_ABORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Aborts the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_DOIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Performs the file operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_SKIP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_RETRY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retries the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_NEWPATH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets a new path for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdefaultqueuecallbacka
     * @since windows5.1.2600
     */
    static SetupDefaultQueueCallbackA(Context, Notification, Param1, Param2) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDefaultQueueCallbackA", "ptr", Context, "uint", Notification, "ptr", Param1, "ptr", Param2, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDefaultQueueCallback function is the default queue callback routine included with the Setup API. You can use it to process notifications sent by the SetupCommitFileQueue function.
     * @param {Pointer<Void>} Context Pointer to the context initialized by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a> functions.
     * @param {Integer} Notification Notification of a queue action. This parameter can be one of the  values shown in the following table. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTQUEUE"></a><a id="spfilenotify_startqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started queued file operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDQUEUE"></a><a id="spfilenotify_endqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished queued file operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTSUBQUEUE"></a><a id="spfilenotify_startsubqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTSUBQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a copy, rename, or delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDSUBQUEUE"></a><a id="spfilenotify_endsubqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDSUBQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a copy, rename, or delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTRENAME"></a><a id="spfilenotify_startrename"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTRENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a rename operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDRENAME"></a><a id="spfilenotify_endrename"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDRENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a rename operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_RENAMEERROR"></a><a id="spfilenotify_renameerror"></a><dl>
     * <dt><b>SPFILENOTIFY_RENAMEERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while renaming a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTDELETE"></a><a id="spfilenotify_startdelete"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTDELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a delete operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDDELETE"></a><a id="spfilenotify_enddelete"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDDELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a delete operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_DELETEERROR"></a><a id="spfilenotify_deleteerror"></a><dl>
     * <dt><b>SPFILENOTIFY_DELETEERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while deleting a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTCOPY"></a><a id="spfilenotify_startcopy"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTCOPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDCOPY"></a><a id="spfilenotify_endcopy"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDCOPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_COPYERROR"></a><a id="spfilenotify_copyerror"></a><dl>
     * <dt><b>SPFILENOTIFY_COPYERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while copying a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_NEEDMEDIA"></a><a id="spfilenotify_needmedia"></a><dl>
     * <dt><b>SPFILENOTIFY_NEEDMEDIA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * New media is required.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_LANGMISMATCH"></a><a id="spfilenotify_langmismatch"></a><dl>
     * <dt><b>SPFILENOTIFY_LANGMISMATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Existing target file is in a different language than the source.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_TARGETEXISTS"></a><a id="spfilenotify_targetexists"></a><dl>
     * <dt><b>SPFILENOTIFY_TARGETEXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target file exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_TARGETNEWER_"></a><a id="spfilenotify_targetnewer_"></a><dl>
     * <dt><b>SPFILENOTIFY_TARGETNEWER </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Existing target file is newer than source.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} Param1 Additional message information. The content of this parameter depends on the value of the <i>Notification</i> parameter.
     * @param {Pointer} Param2 Additional message information. The content of this parameter depends on the value of the <i>Notification</i> parameter.
     * @returns {Integer} Returns an unsigned integer to 
     * <a href="/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a> that can be the one of the values shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_ABORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Aborts the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_DOIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Performs the file operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_SKIP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_RETRY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retries the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILEOP_NEWPATH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets a new path for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdefaultqueuecallbackw
     * @since windows5.1.2600
     */
    static SetupDefaultQueueCallbackW(Context, Notification, Param1, Param2) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDefaultQueueCallbackW", "ptr", Context, "uint", Notification, "ptr", Param1, "ptr", Param2, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFromInfSection function carries out all the directives in an INF file Install section.
     * @param {HWND} Owner Optional pointer to the window handle to the window that owns any dialog boxes that are generated during 
     *       installation, such as for disk prompting or file copying. If <i>Owner</i> is not specified, 
     *       these dialog boxes become top-level windows.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the section to be processed.
     * @param {PSTR} SectionName Name of the <b>Install</b> section in the INF file to process.
     * @param {Integer} Flags 
     * @param {HKEY} RelativeKeyRoot Optional parameter that must be specified if <i>Flags</i> includes SPINST_REGISTRY or 
     *       SPINST_INI2REG. Handle to a registry key to be used as the root when the INF file specifies HKR as the key. 
     *       Note that this parameter is ignored if <b>SetupInstallFromInfSection</b> is called 
     *       with the optional <i>DeviceInfoSet</i> and <i>DeviceInfoData</i> set.
     * @param {PSTR} SourceRootPath Source root for file copies. An example would be A:\ or \\pegasus\win\install. If 
     *       <i>Flags</i> includes SPINST_FILES, and <i>SourceRootPath</i> is NULL, 
     *       the system provides a default root path.
     * @param {Integer} CopyFlags Optional parameter that must be specified if <i>Flags</i> includes SPINST_FILES. 
     *        Specifies flags to be passed to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupqueuecopysectiona">SetupQueueCopySection</a> function when files
     * @param {Pointer<PSP_FILE_CALLBACK_A>} MsgHandler Pointer to the callback routine. The callback routine must be in the format of 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a>. See 
     *        <a href="https://docs.microsoft.com/windows/desktop/SetupApi/notifications">Notifications</a> for more information.
     * 
     * This parameter is optional only if the <i>Flags</i> parameter does not include 
     *        SPINST_FILES, SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR, or SPINST_UNREGSVR.
     * 
     * <i>MsgHandler</i> must be set if <i>Flags</i> includes SPINST_FILES. In 
     *        this case, notification is sent to the callback routine when the file queue is committed with 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>.
     * 
     * <i>MsgHandler</i> must be set if <i>Flags</i> includes 
     *         SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR or SPINST_UNREGSVR. In this case a 
     *         <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-startregistration">SPFILENOTIFY_STARTREGISTRATION</a> 
     *         or 
     *         <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-endregistration">SPFILENOTIFY_ENDREGISTRATION</a> 
     *         is sent to the callback routine once each time a file is registered or unregistered using the 
     *         <b>RegisterDlls</b> INF directive on Windows2000.
     * @param {Pointer<Void>} Context Value to be passed to the callback function when the file queue built by this routine internally is 
     *       committed via 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>. The 
     *       <i>Context</i> parameter is optional only if the <i>Flags</i> parameter 
     *       does not include SPINST_FIlLES. This parameter must be specified if <i>Flags</i> includes 
     *       SPINST_FIlLES.
     * @param {HDEVINFO} DeviceInfoSet Optional pointer to a handle to a device information set. For more information about 
     *       the Device Installer setup functions, see the DDK 
     *       <i>Programmer's Guide</i>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData Optional pointer to a pointer to the <b>SP_DEVINFO_DATA</b> 
     *       structure that provides a context to a specific element in the set specified by 
     *       <i>DeviceInfoSet.</i> For more information about the Device Installer setup functions, see 
     *       the DDK <i>Programmer's Guide</i>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallfrominfsectiona
     * @since windows5.1.2600
     */
    static SetupInstallFromInfSectionA(Owner, InfHandle, SectionName, Flags, RelativeKeyRoot, SourceRootPath, CopyFlags, MsgHandler, Context, DeviceInfoSet, DeviceInfoData) {
        Owner := Owner is Win32Handle ? NumGet(Owner, "ptr") : Owner
        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName
        RelativeKeyRoot := RelativeKeyRoot is Win32Handle ? NumGet(RelativeKeyRoot, "ptr") : RelativeKeyRoot
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFromInfSectionA", "ptr", Owner, "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "ptr", RelativeKeyRoot, "ptr", SourceRootPath, "uint", CopyFlags, "ptr", MsgHandler, "ptr", Context, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFromInfSection function carries out all the directives in an INF file Install section.
     * @param {HWND} Owner Optional pointer to the window handle to the window that owns any dialog boxes that are generated during 
     *       installation, such as for disk prompting or file copying. If <i>Owner</i> is not specified, 
     *       these dialog boxes become top-level windows.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the section to be processed.
     * @param {PWSTR} SectionName Name of the <b>Install</b> section in the INF file to process.
     * @param {Integer} Flags 
     * @param {HKEY} RelativeKeyRoot Optional parameter that must be specified if <i>Flags</i> includes SPINST_REGISTRY or 
     *       SPINST_INI2REG. Handle to a registry key to be used as the root when the INF file specifies HKR as the key. 
     *       Note that this parameter is ignored if <b>SetupInstallFromInfSection</b> is called 
     *       with the optional <i>DeviceInfoSet</i> and <i>DeviceInfoData</i> set.
     * @param {PWSTR} SourceRootPath Source root for file copies. An example would be A:\ or \\pegasus\win\install. If 
     *       <i>Flags</i> includes SPINST_FILES, and <i>SourceRootPath</i> is NULL, 
     *       the system provides a default root path.
     * @param {Integer} CopyFlags Optional parameter that must be specified if <i>Flags</i> includes SPINST_FILES. 
     *        Specifies flags to be passed to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupqueuecopysectiona">SetupQueueCopySection</a> function when files
     * @param {Pointer<PSP_FILE_CALLBACK_W>} MsgHandler Pointer to the callback routine. The callback routine must be in the format of 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a>. See 
     *        <a href="https://docs.microsoft.com/windows/desktop/SetupApi/notifications">Notifications</a> for more information.
     * 
     * This parameter is optional only if the <i>Flags</i> parameter does not include 
     *        SPINST_FILES, SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR, or SPINST_UNREGSVR.
     * 
     * <i>MsgHandler</i> must be set if <i>Flags</i> includes SPINST_FILES. In 
     *        this case, notification is sent to the callback routine when the file queue is committed with 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>.
     * 
     * <i>MsgHandler</i> must be set if <i>Flags</i> includes 
     *         SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR or SPINST_UNREGSVR. In this case a 
     *         <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-startregistration">SPFILENOTIFY_STARTREGISTRATION</a> 
     *         or 
     *         <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-endregistration">SPFILENOTIFY_ENDREGISTRATION</a> 
     *         is sent to the callback routine once each time a file is registered or unregistered using the 
     *         <b>RegisterDlls</b> INF directive on Windows2000.
     * @param {Pointer<Void>} Context Value to be passed to the callback function when the file queue built by this routine internally is 
     *       committed via 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>. The 
     *       <i>Context</i> parameter is optional only if the <i>Flags</i> parameter 
     *       does not include SPINST_FIlLES. This parameter must be specified if <i>Flags</i> includes 
     *       SPINST_FIlLES.
     * @param {HDEVINFO} DeviceInfoSet Optional pointer to a handle to a device information set. For more information about 
     *       the Device Installer setup functions, see the DDK 
     *       <i>Programmer's Guide</i>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData Optional pointer to a pointer to the <b>SP_DEVINFO_DATA</b> 
     *       structure that provides a context to a specific element in the set specified by 
     *       <i>DeviceInfoSet.</i> For more information about the Device Installer setup functions, see 
     *       the DDK <i>Programmer's Guide</i>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallfrominfsectionw
     * @since windows5.1.2600
     */
    static SetupInstallFromInfSectionW(Owner, InfHandle, SectionName, Flags, RelativeKeyRoot, SourceRootPath, CopyFlags, MsgHandler, Context, DeviceInfoSet, DeviceInfoData) {
        Owner := Owner is Win32Handle ? NumGet(Owner, "ptr") : Owner
        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName
        RelativeKeyRoot := RelativeKeyRoot is Win32Handle ? NumGet(RelativeKeyRoot, "ptr") : RelativeKeyRoot
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFromInfSectionW", "ptr", Owner, "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "ptr", RelativeKeyRoot, "ptr", SourceRootPath, "uint", CopyFlags, "ptr", MsgHandler, "ptr", Context, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFilesFromInfSection function queues all the files for an installation that are specified in the Copy Files, Delete Files, and Rename Files sections that are listed by an Install section.
     * @param {Pointer<Void>} InfHandle The handle to an INF file that contains the section to be installed.
     * @param {Pointer<Void>} LayoutInfHandle An optional pointer to a handle to the INF file that contains the SourceDisksFiles and SourceDisksNames sections. 
     * 
     * If <i>LayoutInfHandle</i> is not specified, then the SourceDisksFiles and SourceDisksNames sections from <i>InfHandle</i> are used.
     * @param {Pointer<Void>} FileQueue The handle to the queue where installation operations are to be added.
     * @param {PSTR} SectionName The name of the Install section in  the <i>InfHandle</i> parameter that lists the Copy Files, Delete Files, and  Rename Files sections that contain the files to install. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {PSTR} SourceRootPath An optional pointer to a root path to the source files to copy, for example, A:\ or \\pegasus\win\install. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {Integer} CopyFlags An optional pointer to a set of flags that control the behavior of the file copy operation.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallfilesfrominfsectiona
     * @since windows5.1.2600
     */
    static SetupInstallFilesFromInfSectionA(InfHandle, LayoutInfHandle, FileQueue, SectionName, SourceRootPath, CopyFlags) {
        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFilesFromInfSectionA", "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", FileQueue, "ptr", SectionName, "ptr", SourceRootPath, "uint", CopyFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFilesFromInfSection function queues all the files for an installation that are specified in the Copy Files, Delete Files, and Rename Files sections that are listed by an Install section.
     * @param {Pointer<Void>} InfHandle The handle to an INF file that contains the section to be installed.
     * @param {Pointer<Void>} LayoutInfHandle An optional pointer to a handle to the INF file that contains the SourceDisksFiles and SourceDisksNames sections. 
     * 
     * If <i>LayoutInfHandle</i> is not specified, then the SourceDisksFiles and SourceDisksNames sections from <i>InfHandle</i> are used.
     * @param {Pointer<Void>} FileQueue The handle to the queue where installation operations are to be added.
     * @param {PWSTR} SectionName The name of the Install section in  the <i>InfHandle</i> parameter that lists the Copy Files, Delete Files, and  Rename Files sections that contain the files to install. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {PWSTR} SourceRootPath An optional pointer to a root path to the source files to copy, for example, A:\ or \\pegasus\win\install. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {Integer} CopyFlags An optional pointer to a set of flags that control the behavior of the file copy operation.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallfilesfrominfsectionw
     * @since windows5.1.2600
     */
    static SetupInstallFilesFromInfSectionW(InfHandle, LayoutInfHandle, FileQueue, SectionName, SourceRootPath, CopyFlags) {
        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName
        SourceRootPath := SourceRootPath is String ? StrPtr(SourceRootPath) : SourceRootPath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFilesFromInfSectionW", "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", FileQueue, "ptr", SectionName, "ptr", SourceRootPath, "uint", CopyFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallServicesFromInfSection function performs service installation and deletion operations that are specified in the Service Install sections listed in the Service section of an INF file.
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <b>Service</b> section.
     * @param {PSTR} SectionName The name of the <b>Service</b> section to process. You should use a null-terminated 
     *       string.
     * @param {Integer} Flags The controls for the installation of each service in the specified section.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl>
     * <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: move the service tag to the front of its group order list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
     * <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt>
     * <dt>0x004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: delete the event log entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a id="spsvcinst_noclobber_displayname"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt>
     * <dt>0x008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the display name if one already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt>
     * <dt>0x010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the start type value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt>
     * <dt>0x020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the error control value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
     * <dt>0x040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the load order group if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt>
     * <dt>0x080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the dependencies list if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt>
     * <dt>0x100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl>
     * <dt><b>SPSVCINST_STOPSERVICE</b></dt>
     * <dt>0x200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: Stop the associated service specified in the entry before deleting the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a id="spsvcinst_clobber_security"></a><dl>
     * <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt>
     * <dt>0x400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Security settings the service are overwritten if the service already exists in the 
     *          system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2003 and WindowsXP.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a id="spsvcinst_startservice"></a><dl>
     * <dt><b>SPSVCINST_STARTSERVICE</b></dt>
     * <dt>0x800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Start the service after the service is installed. This flag cannot be used to start a 
     *          service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise, 
     *          this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control 
     *          Manager (SCM.)
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008 and WindowsVista.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a id="spsvcinst_noclobber_requiredprivileges"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Do not overwrite the given service's required privileges if the service already exists 
     *          in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008R2 and Windows7.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero. The function calls 
     *        <b>SetLastError</b> with ERROR_SUCCESS_REBOOT_REQUIRED if a reboot of the system is 
     *        required.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallservicesfrominfsectiona
     * @since windows5.1.2600
     */
    static SetupInstallServicesFromInfSectionA(InfHandle, SectionName, Flags) {
        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallServicesFromInfSectionA", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallServicesFromInfSection function performs service installation and deletion operations that are specified in the Service Install sections listed in the Service section of an INF file.
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <b>Service</b> section.
     * @param {PWSTR} SectionName The name of the <b>Service</b> section to process. You should use a null-terminated 
     *       string.
     * @param {Integer} Flags The controls for the installation of each service in the specified section.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl>
     * <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: move the service tag to the front of its group order list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
     * <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt>
     * <dt>0x004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: delete the event log entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a id="spsvcinst_noclobber_displayname"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt>
     * <dt>0x008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the display name if one already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt>
     * <dt>0x010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the start type value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt>
     * <dt>0x020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the error control value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
     * <dt>0x040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the load order group if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt>
     * <dt>0x080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the dependencies list if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt>
     * <dt>0x100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl>
     * <dt><b>SPSVCINST_STOPSERVICE</b></dt>
     * <dt>0x200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: Stop the associated service specified in the entry before deleting the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a id="spsvcinst_clobber_security"></a><dl>
     * <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt>
     * <dt>0x400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Security settings the service are overwritten if the service already exists in the 
     *          system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2003 and WindowsXP.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a id="spsvcinst_startservice"></a><dl>
     * <dt><b>SPSVCINST_STARTSERVICE</b></dt>
     * <dt>0x800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Start the service after the service is installed. This flag cannot be used to start a 
     *          service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise, 
     *          this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control 
     *          Manager (SCM.)
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008 and WindowsVista.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a id="spsvcinst_noclobber_requiredprivileges"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Do not overwrite the given service's required privileges if the service already exists 
     *          in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008R2 and Windows7.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero. The function calls 
     *        <b>SetLastError</b> with ERROR_SUCCESS_REBOOT_REQUIRED if a reboot of the system is 
     *        required.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallservicesfrominfsectionw
     * @since windows5.1.2600
     */
    static SetupInstallServicesFromInfSectionW(InfHandle, SectionName, Flags) {
        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallServicesFromInfSectionW", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallServicesFromInfSectionEx function performs service installation and deletion operations that are specified in the Service Install sections listed in the Service section of an INF file.
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <b>Service</b> section.
     * @param {PSTR} SectionName The name of the <b>Service</b> section to process. You should use a null-terminated string.
     * @param {Integer} Flags The controls for the installation. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl>
     * <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Move the service tag to the front of its group order list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_ASSOCSERVICE"></a><a id="spsvcinst_assocservice"></a><dl>
     * <dt><b>SPSVCINST_ASSOCSERVICE</b></dt>
     * <dt>0x002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
     * <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt>
     * <dt>0x004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the event log entry for a specified service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a id="spsvcinst_noclobber_displayname"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt>
     * <dt>0x008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the display name if one already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt>
     * <dt>0x010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the start type value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt>
     * <dt>0x020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the error control value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
     * <dt>0x040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the load order group if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt>
     * <dt>0x080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the dependencies list if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt>
     * <dt>0x100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl>
     * <dt><b>SPSVCINST_STOPSERVICE</b></dt>
     * <dt>0x200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: Stop the associated service specified in the entry before deleting the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a id="spsvcinst_clobber_security"></a><dl>
     * <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt>
     * <dt>0x400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Security settings the service are overwritten if the service already exists in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2003 and WindowsXP.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a id="spsvcinst_startservice"></a><dl>
     * <dt><b>SPSVCINST_STARTSERVICE</b></dt>
     * <dt>0x800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Start the service after the service is installed. This flag cannot be used to start a service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise, this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control Manager (SCM.)
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008 and WindowsVista.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a id="spsvcinst_noclobber_requiredprivileges"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Do not overwrite the given service's required privileges if the service already exists in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008R2 and Windows7.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @param {HDEVINFO} DeviceInfoSet An optional pointer to a handle to a device information set. For more information, see the DDK <i>Programmer's Guide</i>. (This resource may not be available in some languages 
     * 
     * and countries.)
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData An optional pointer to  the <b>SP_DEVINFO_DATA</b> structure that provides a context to a specific element in the set that  <i>DeviceInfoSet</i> specifies. For more information, see the DDK <i>Programmer's Guide</i>. (This resource may not be available in some languages 
     * 
     * and countries.)
     * @returns {BOOL} If the function succeeds, the return value is nonzero.  The function calls <b>SetLastError</b> with ERROR_SUCCESS_REBOOT_REQUIRED  if a reboot of the system is required.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallservicesfrominfsectionexa
     * @since windows5.1.2600
     */
    static SetupInstallServicesFromInfSectionExA(InfHandle, SectionName, Flags, DeviceInfoSet, DeviceInfoData) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallServicesFromInfSectionExA", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallServicesFromInfSectionEx function performs service installation and deletion operations that are specified in the Service Install sections listed in the Service section of an INF file.
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <b>Service</b> section.
     * @param {PWSTR} SectionName The name of the <b>Service</b> section to process. You should use a null-terminated string.
     * @param {Integer} Flags The controls for the installation. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl>
     * <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Move the service tag to the front of its group order list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_ASSOCSERVICE"></a><a id="spsvcinst_assocservice"></a><dl>
     * <dt><b>SPSVCINST_ASSOCSERVICE</b></dt>
     * <dt>0x002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
     * <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt>
     * <dt>0x004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the event log entry for a specified service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a id="spsvcinst_noclobber_displayname"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt>
     * <dt>0x008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the display name if one already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt>
     * <dt>0x010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the start type value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt>
     * <dt>0x020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the error control value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
     * <dt>0x040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the load order group if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt>
     * <dt>0x080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the dependencies list if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt>
     * <dt>0x100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl>
     * <dt><b>SPSVCINST_STOPSERVICE</b></dt>
     * <dt>0x200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: Stop the associated service specified in the entry before deleting the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a id="spsvcinst_clobber_security"></a><dl>
     * <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt>
     * <dt>0x400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Security settings the service are overwritten if the service already exists in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2003 and WindowsXP.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a id="spsvcinst_startservice"></a><dl>
     * <dt><b>SPSVCINST_STARTSERVICE</b></dt>
     * <dt>0x800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Start the service after the service is installed. This flag cannot be used to start a service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise, this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control Manager (SCM.)
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008 and WindowsVista.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a id="spsvcinst_noclobber_requiredprivileges"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Do not overwrite the given service's required privileges if the service already exists in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008R2 and Windows7.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @param {HDEVINFO} DeviceInfoSet An optional pointer to a handle to a device information set. For more information, see the DDK <i>Programmer's Guide</i>. (This resource may not be available in some languages 
     * 
     * and countries.)
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData An optional pointer to  the <b>SP_DEVINFO_DATA</b> structure that provides a context to a specific element in the set that  <i>DeviceInfoSet</i> specifies. For more information, see the DDK <i>Programmer's Guide</i>. (This resource may not be available in some languages 
     * 
     * and countries.)
     * @returns {BOOL} If the function succeeds, the return value is nonzero.  The function calls <b>SetLastError</b> with ERROR_SUCCESS_REBOOT_REQUIRED  if a reboot of the system is required.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinstallservicesfrominfsectionexw
     * @since windows5.1.2600
     */
    static SetupInstallServicesFromInfSectionExW(InfHandle, SectionName, Flags, DeviceInfoSet, DeviceInfoData) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallServicesFromInfSectionExW", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * InstallHinfSection is an entry-point function exported by Setupapi.dll that you can use to execute a section of an .inf file. InstallHinfSection can be invoked by calling the Rundll32.exe utility as described in the Remarks section.
     * @remarks
     * 
     * Note that three exports exist: 
     * <b>InstallHinfSection</b> (for RunDll32), <b>InstallHinfSectionA</b>, and <b>InstallHinfSectionW</b>. 
     * 
     * To run an <b>Install</b> section of a specified .inf file, you can invoke 
     * <b>InstallHinfSection</b> with the Rundll32.exe by using the following syntax.
     * 
     * <b>RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection </b><i>&lt;section&gt;</i><i>&lt;mode&gt;</i><i>&lt;path&gt;</i>
     * 
     * This passes "<i>&lt;section&gt;</i><i>&lt;mode&gt;</i><i>&lt;path&gt;</i>" to <i>CmdLineBuffer</i>.
     * 
     * Alternatively, your program may call 
     * <b>InstallHinfSection</b>, <b>InstallHinfSectionA</b>, or <b>InstallHinfSectionW</b> directly, setting the <i>CmdLineBuffer</i> parameter to the following.
     * 
     * <pre class="syntax" xml:space="preserve"><c>"&lt;section&gt; &lt;mode&gt; &lt;path&gt;"</c></pre>
     * Where <i>path</i> is the full path to the .inf file, <i>mode</i> is the reboot mode parameter, and <i>section</i> is any <b>Install</b> section in the .inf file. The comma separator between SETUPAPI.DLL and 
     * <b>InstallHinfSection</b> on the command line is required. Note that there cannot be any white space on the command line between the comma and SETUPAPI.DLL or 
     * <b>InstallHinfSection</b>.
     * 
     * It is recommended that you specify the full path to the .inf file as <i>path</i>.
     * 
     * You may specify any <b>Install</b> section in the .inf file as <i>section</i>. No spaces are allowed.
     * 
     * You should use a combination of the following values for <i>mode</i>. You must include 128 to set the default path of the installation to the location of the INF, otherwise a system-provided INF is assumed. Add values to specify rebooting. Note that only the values 128 or 132 are recommended, other values may cause the computer to reboot unnecessarily or not reboot when it required.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>System provided INF.</td>
     * </tr>
     * <tr>
     * <td>128</td>
     * <td>Set the default path of the installation to the location of the INF. This is the typical setting.</td>
     * </tr>
     * <tr>
     * <td>+0</td>
     * <td>Never reboot the computer.</td>
     * </tr>
     * <tr>
     * <td>+1</td>
     * <td>Reboot the computer in all cases.</td>
     * </tr>
     * <tr>
     * <td>+2</td>
     * <td>Always ask the users if they want to reboot.</td>
     * </tr>
     * <tr>
     * <td>+3</td>
     * <td>Reboot the computer if necessary without asking user for permission.</td>
     * </tr>
     * <tr>
     * <td>+4</td>
     * <td>If a reboot of the computer is necessary, ask the user for permission before rebooting.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * <div></div>
     * 
     * 
     * For example, the following command line runs the DefaultInstall section of the Shell.inf file. If Setup determines a reboot is required, the user is will be prompted with a "Reboot the computer, Yes/No" dialog box.
     * 
     * <b>RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultInstall 132 C:\WINDOWS\INF\SHELL.INF</b>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines InstallHinfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * @param {HWND} Window The parent window handle. Typically <i>hwnd</i> is Null.
     * @param {HINSTANCE} ModuleHandle Reserved and should be Null.
     * @param {PSTR} CommandLine Pointer to buffer containing the command line. You should use a null-terminated string.
     * @param {Integer} ShowCommand Reserved and should be zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-installhinfsectiona
     * @since windows5.1.2600
     */
    static InstallHinfSectionA(Window, ModuleHandle, CommandLine, ShowCommand) {
        Window := Window is Win32Handle ? NumGet(Window, "ptr") : Window
        ModuleHandle := ModuleHandle is Win32Handle ? NumGet(ModuleHandle, "ptr") : ModuleHandle
        CommandLine := CommandLine is String ? StrPtr(CommandLine) : CommandLine

        DllCall("SETUPAPI.dll\InstallHinfSectionA", "ptr", Window, "ptr", ModuleHandle, "ptr", CommandLine, "int", ShowCommand)
    }

    /**
     * InstallHinfSection is an entry-point function exported by Setupapi.dll that you can use to execute a section of an .inf file. InstallHinfSection can be invoked by calling the Rundll32.exe utility as described in the Remarks section.
     * @remarks
     * 
     * Note that three exports exist: 
     * <b>InstallHinfSection</b> (for RunDll32), <b>InstallHinfSectionA</b>, and <b>InstallHinfSectionW</b>. 
     * 
     * To run an <b>Install</b> section of a specified .inf file, you can invoke 
     * <b>InstallHinfSection</b> with the Rundll32.exe by using the following syntax.
     * 
     * <b>RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection </b><i>&lt;section&gt;</i><i>&lt;mode&gt;</i><i>&lt;path&gt;</i>
     * 
     * This passes "<i>&lt;section&gt;</i><i>&lt;mode&gt;</i><i>&lt;path&gt;</i>" to <i>CmdLineBuffer</i>.
     * 
     * Alternatively, your program may call 
     * <b>InstallHinfSection</b>, <b>InstallHinfSectionA</b>, or <b>InstallHinfSectionW</b> directly, setting the <i>CmdLineBuffer</i> parameter to the following.
     * 
     * <pre class="syntax" xml:space="preserve"><c>"&lt;section&gt; &lt;mode&gt; &lt;path&gt;"</c></pre>
     * Where <i>path</i> is the full path to the .inf file, <i>mode</i> is the reboot mode parameter, and <i>section</i> is any <b>Install</b> section in the .inf file. The comma separator between SETUPAPI.DLL and 
     * <b>InstallHinfSection</b> on the command line is required. Note that there cannot be any white space on the command line between the comma and SETUPAPI.DLL or 
     * <b>InstallHinfSection</b>.
     * 
     * It is recommended that you specify the full path to the .inf file as <i>path</i>.
     * 
     * You may specify any <b>Install</b> section in the .inf file as <i>section</i>. No spaces are allowed.
     * 
     * You should use a combination of the following values for <i>mode</i>. You must include 128 to set the default path of the installation to the location of the INF, otherwise a system-provided INF is assumed. Add values to specify rebooting. Note that only the values 128 or 132 are recommended, other values may cause the computer to reboot unnecessarily or not reboot when it required.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>System provided INF.</td>
     * </tr>
     * <tr>
     * <td>128</td>
     * <td>Set the default path of the installation to the location of the INF. This is the typical setting.</td>
     * </tr>
     * <tr>
     * <td>+0</td>
     * <td>Never reboot the computer.</td>
     * </tr>
     * <tr>
     * <td>+1</td>
     * <td>Reboot the computer in all cases.</td>
     * </tr>
     * <tr>
     * <td>+2</td>
     * <td>Always ask the users if they want to reboot.</td>
     * </tr>
     * <tr>
     * <td>+3</td>
     * <td>Reboot the computer if necessary without asking user for permission.</td>
     * </tr>
     * <tr>
     * <td>+4</td>
     * <td>If a reboot of the computer is necessary, ask the user for permission before rebooting.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * <div></div>
     * 
     * 
     * For example, the following command line runs the DefaultInstall section of the Shell.inf file. If Setup determines a reboot is required, the user is will be prompted with a "Reboot the computer, Yes/No" dialog box.
     * 
     * <b>RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultInstall 132 C:\WINDOWS\INF\SHELL.INF</b>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines InstallHinfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * @param {HWND} Window The parent window handle. Typically <i>hwnd</i> is Null.
     * @param {HINSTANCE} ModuleHandle Reserved and should be Null.
     * @param {PWSTR} CommandLine Pointer to buffer containing the command line. You should use a null-terminated string.
     * @param {Integer} ShowCommand Reserved and should be zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-installhinfsectionw
     * @since windows5.1.2600
     */
    static InstallHinfSectionW(Window, ModuleHandle, CommandLine, ShowCommand) {
        Window := Window is Win32Handle ? NumGet(Window, "ptr") : Window
        ModuleHandle := ModuleHandle is Win32Handle ? NumGet(ModuleHandle, "ptr") : ModuleHandle
        CommandLine := CommandLine is String ? StrPtr(CommandLine) : CommandLine

        DllCall("SETUPAPI.dll\InstallHinfSectionW", "ptr", Window, "ptr", ModuleHandle, "ptr", CommandLine, "int", ShowCommand)
    }

    /**
     * The SetupInitializeFileLog function initializes a file to record installation operations and outcomes. This can be the system log, where the system tracks the files installed as part of Windows, or any other file.
     * @param {PSTR} LogFileName Optional pointer to the file name of the file to use as the log file. You should use a <b>null</b>-terminated string. The <i>LogFileName</i> parameter must be specified if <i>Flags</i> does not include SPFILELOG_SYSTEMLOG. The <i>LogFileName</i> parameter must not be specified if <i>Flags</i> includes SPFILELOG_SYSTEMLOG. This parameter can be <b>NULL</b>.
     * @param {Integer} Flags 
     * @returns {Pointer<Void>} The function returns the handle to the log file if it is successful. Otherwise, the return value is INVALID_HANDLE_VALUE and the logged error can be retrieved by a call to 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinitializefileloga
     * @since windows5.1.2600
     */
    static SetupInitializeFileLogA(LogFileName, Flags) {
        LogFileName := LogFileName is String ? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInitializeFileLogA", "ptr", LogFileName, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInitializeFileLog function initializes a file to record installation operations and outcomes. This can be the system log, where the system tracks the files installed as part of Windows, or any other file.
     * @param {PWSTR} LogFileName Optional pointer to the file name of the file to use as the log file. You should use a <b>null</b>-terminated string. The <i>LogFileName</i> parameter must be specified if <i>Flags</i> does not include SPFILELOG_SYSTEMLOG. The <i>LogFileName</i> parameter must not be specified if <i>Flags</i> includes SPFILELOG_SYSTEMLOG. This parameter can be <b>NULL</b>.
     * @param {Integer} Flags 
     * @returns {Pointer<Void>} The function returns the handle to the log file if it is successful. Otherwise, the return value is INVALID_HANDLE_VALUE and the logged error can be retrieved by a call to 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupinitializefilelogw
     * @since windows5.1.2600
     */
    static SetupInitializeFileLogW(LogFileName, Flags) {
        LogFileName := LogFileName is String ? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInitializeFileLogW", "ptr", LogFileName, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupTerminateFileLog function releases resources associated with a file log.
     * @param {Pointer<Void>} FileLogHandle Handle to the log file as returned by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupterminatefilelog
     * @since windows5.1.2600
     */
    static SetupTerminateFileLog(FileLogHandle) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupTerminateFileLog", "ptr", FileLogHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupLogFile function adds an entry to the log file.
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>. The caller must not have passed SPFILELOG_QUERYONLY when the log file was initialized.
     * @param {PSTR} LogSectionName Optional pointer to the name for a logical grouping of names within the log file. You should use a <b>null</b>-terminated string.  Required if SPFILELOG_SYSTEMLOG was not passed when the file log was initialized. Otherwise, this parameter can be <b>NULL</b>.
     * @param {PSTR} SourceFilename Name of the file as it exists on the source media from which it was installed. This name should be in whatever format is meaningful to the caller. You should use a <b>null</b>-terminated string.
     * @param {PSTR} TargetFilename Name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller. You should use a <b>null</b>-terminated string.
     * @param {Integer} Checksum Optional pointer to a  checksum value. Required for the system log.
     * @param {PSTR} DiskTagfile Optional pointer to the tagfile for the media from which the file was installed. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. Ignored for the system log if SPFILELOG_OEMFILE is not specified. Required for the system log if SPFILELOG_OEMFILE is specified. Otherwise, this parameter can be <b>NULL</b>.
     * @param {PSTR} DiskDescription Optional pointer to the human-readable description of the media from which the file was installed. You should use a <b>null</b>-terminated string.  Ignored for the system log if SPFILELOG_OEMFILE is not specified in the <i>Flags</i> parameter.  Required for the system log if SPFILELOG_OEMFILE is specified in the Flags parameter. Otherwise, this parameter can be <b>NULL</b>.
     * @param {PSTR} OtherInfo Optional pointer to additional information to be associated with the file. You should use a <b>null</b>-terminated string.  This parameter can be <b>NULL</b>.
     * @param {Integer} Flags This parameter can be SPFILELOG_OEMFILE, which is meaningful only for the system log and indicates that the file is not supplied by Microsoft. This parameter can be used to convert an existing file's entry, such as when an OEM overwrites a Microsoft-supplied system file.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuplogfilea
     * @since windows5.1.2600
     */
    static SetupLogFileA(FileLogHandle, LogSectionName, SourceFilename, TargetFilename, Checksum, DiskTagfile, DiskDescription, OtherInfo, Flags) {
        LogSectionName := LogSectionName is String ? StrPtr(LogSectionName) : LogSectionName
        SourceFilename := SourceFilename is String ? StrPtr(SourceFilename) : SourceFilename
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename
        DiskTagfile := DiskTagfile is String ? StrPtr(DiskTagfile) : DiskTagfile
        DiskDescription := DiskDescription is String ? StrPtr(DiskDescription) : DiskDescription
        OtherInfo := OtherInfo is String ? StrPtr(OtherInfo) : OtherInfo

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupLogFileA", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", SourceFilename, "ptr", TargetFilename, "uint", Checksum, "ptr", DiskTagfile, "ptr", DiskDescription, "ptr", OtherInfo, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupLogFile function adds an entry to the log file.
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>. The caller must not have passed SPFILELOG_QUERYONLY when the log file was initialized.
     * @param {PWSTR} LogSectionName Optional pointer to the name for a logical grouping of names within the log file. You should use a <b>null</b>-terminated string.  Required if SPFILELOG_SYSTEMLOG was not passed when the file log was initialized. Otherwise, this parameter can be <b>NULL</b>.
     * @param {PWSTR} SourceFilename Name of the file as it exists on the source media from which it was installed. This name should be in whatever format is meaningful to the caller. You should use a <b>null</b>-terminated string.
     * @param {PWSTR} TargetFilename Name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller. You should use a <b>null</b>-terminated string.
     * @param {Integer} Checksum Optional pointer to a  checksum value. Required for the system log.
     * @param {PWSTR} DiskTagfile Optional pointer to the tagfile for the media from which the file was installed. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. Ignored for the system log if SPFILELOG_OEMFILE is not specified. Required for the system log if SPFILELOG_OEMFILE is specified. Otherwise, this parameter can be <b>NULL</b>.
     * @param {PWSTR} DiskDescription Optional pointer to the human-readable description of the media from which the file was installed. You should use a <b>null</b>-terminated string.  Ignored for the system log if SPFILELOG_OEMFILE is not specified in the <i>Flags</i> parameter.  Required for the system log if SPFILELOG_OEMFILE is specified in the Flags parameter. Otherwise, this parameter can be <b>NULL</b>.
     * @param {PWSTR} OtherInfo Optional pointer to additional information to be associated with the file. You should use a <b>null</b>-terminated string.  This parameter can be <b>NULL</b>.
     * @param {Integer} Flags This parameter can be SPFILELOG_OEMFILE, which is meaningful only for the system log and indicates that the file is not supplied by Microsoft. This parameter can be used to convert an existing file's entry, such as when an OEM overwrites a Microsoft-supplied system file.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuplogfilew
     * @since windows5.1.2600
     */
    static SetupLogFileW(FileLogHandle, LogSectionName, SourceFilename, TargetFilename, Checksum, DiskTagfile, DiskDescription, OtherInfo, Flags) {
        LogSectionName := LogSectionName is String ? StrPtr(LogSectionName) : LogSectionName
        SourceFilename := SourceFilename is String ? StrPtr(SourceFilename) : SourceFilename
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename
        DiskTagfile := DiskTagfile is String ? StrPtr(DiskTagfile) : DiskTagfile
        DiskDescription := DiskDescription is String ? StrPtr(DiskDescription) : DiskDescription
        OtherInfo := OtherInfo is String ? StrPtr(OtherInfo) : OtherInfo

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupLogFileW", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", SourceFilename, "ptr", TargetFilename, "uint", Checksum, "ptr", DiskTagfile, "ptr", DiskDescription, "ptr", OtherInfo, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFileLogEntry function removes an entry or section from a file log.
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>. The caller must not have passed SPFILELOG_QUERYONLY when the log file was initialized.
     * @param {PSTR} LogSectionName Pointer to a <b>null</b>-terminated string that specifies the name for a logical grouping of names within the log file. Required for non-system logs. Otherwise, <i>LogSectionName</i> may be <b>NULL</b>.
     * @param {PSTR} TargetFilename Pointer to a <b>null</b>-terminated string that specifies the name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller. If <b>NULL</b>, the section specified by <i>LogSectionName</i> is removed. The main section cannot be removed.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremovefilelogentrya
     * @since windows5.1.2600
     */
    static SetupRemoveFileLogEntryA(FileLogHandle, LogSectionName, TargetFilename) {
        LogSectionName := LogSectionName is String ? StrPtr(LogSectionName) : LogSectionName
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFileLogEntryA", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", TargetFilename, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFileLogEntry function removes an entry or section from a file log.
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>. The caller must not have passed SPFILELOG_QUERYONLY when the log file was initialized.
     * @param {PWSTR} LogSectionName Pointer to a <b>null</b>-terminated string that specifies the name for a logical grouping of names within the log file. Required for non-system logs. Otherwise, <i>LogSectionName</i> may be <b>NULL</b>.
     * @param {PWSTR} TargetFilename Pointer to a <b>null</b>-terminated string that specifies the name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller. If <b>NULL</b>, the section specified by <i>LogSectionName</i> is removed. The main section cannot be removed.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupremovefilelogentryw
     * @since windows5.1.2600
     */
    static SetupRemoveFileLogEntryW(FileLogHandle, LogSectionName, TargetFilename) {
        LogSectionName := LogSectionName is String ? StrPtr(LogSectionName) : LogSectionName
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFileLogEntryW", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", TargetFilename, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryFileLog function returns information from a setup file log.
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>.
     * @param {PSTR} LogSectionName Optional pointer to the section name for the log file in a format that is meaningful to the caller. You should use a <b>null</b>-terminated string. Required for non-system logs. If no <i>LogSectionName</i> is specified for a system log, a default is supplied.
     * @param {PSTR} TargetFilename Name of the file for which log information is desired. You should use a <b>null</b>-terminated string.
     * @param {Integer} DesiredInfo Indicates what information should be returned to the <i>DataOut</i> buffer. This parameter can be one of the following enumerated values. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogSourceFile_name"></a><a id="setupfilelogsourcefile_name"></a><a id="SETUPFILELOGSOURCEFILE_NAME"></a><dl>
     * <dt><b>SetupFileLogSourceFile name</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Name of the source file as it exists on the source media
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogChecksum"></a><a id="setupfilelogchecksum"></a><a id="SETUPFILELOGCHECKSUM"></a><dl>
     * <dt><b>SetupFileLogChecksum</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A  checksum value used by the system log
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogDiskTagfile"></a><a id="setupfilelogdisktagfile"></a><a id="SETUPFILELOGDISKTAGFILE"></a><dl>
     * <dt><b>SetupFileLogDiskTagfile</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Name of the tag file of the media source containing the source file
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogDiskDescription"></a><a id="setupfilelogdiskdescription"></a><a id="SETUPFILELOGDISKDESCRIPTION"></a><dl>
     * <dt><b>SetupFileLogDiskDescription</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The human-readable description of the media where the source file resides
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogOtherInfo"></a><a id="setupfilelogotherinfo"></a><a id="SETUPFILELOGOTHERINFO"></a><dl>
     * <dt><b>SetupFileLogOtherInfo</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Additional information associated with the logged file
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the value of <i>DesiredInfo</i> is greater than <b>SetupFileLogOtherInfo</b> the function will fail, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_PARAMETER.
     * @param {PSTR} DataOut Optional pointer to a buffer in which this function returns the requested information for the file. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. Not all information is provided for every file. An error is not returned if an empty entry for the file exists in the log. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the <i>DataOut</i> buffer,  in characters. This includes the <b>null</b> terminator. If the buffer is too small and <i>DataOut</i> is specified, data is not stored in the buffer and the function returns zero. If <i>DataOut</i> is not specified, the <i>ReturnBufferSize</i> parameter is ignored.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size of <i>DataOut</i>, in characters. This number includes the <b>null</b> terminator.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryfileloga
     * @since windows5.1.2600
     */
    static SetupQueryFileLogA(FileLogHandle, LogSectionName, TargetFilename, DesiredInfo, DataOut, ReturnBufferSize, RequiredSize) {
        LogSectionName := LogSectionName is String ? StrPtr(LogSectionName) : LogSectionName
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename
        DataOut := DataOut is String ? StrPtr(DataOut) : DataOut

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryFileLogA", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", TargetFilename, "int", DesiredInfo, "ptr", DataOut, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryFileLog function returns information from a setup file log.
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>.
     * @param {PWSTR} LogSectionName Optional pointer to the section name for the log file in a format that is meaningful to the caller. You should use a <b>null</b>-terminated string. Required for non-system logs. If no <i>LogSectionName</i> is specified for a system log, a default is supplied.
     * @param {PWSTR} TargetFilename Name of the file for which log information is desired. You should use a <b>null</b>-terminated string.
     * @param {Integer} DesiredInfo Indicates what information should be returned to the <i>DataOut</i> buffer. This parameter can be one of the following enumerated values. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogSourceFile_name"></a><a id="setupfilelogsourcefile_name"></a><a id="SETUPFILELOGSOURCEFILE_NAME"></a><dl>
     * <dt><b>SetupFileLogSourceFile name</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Name of the source file as it exists on the source media
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogChecksum"></a><a id="setupfilelogchecksum"></a><a id="SETUPFILELOGCHECKSUM"></a><dl>
     * <dt><b>SetupFileLogChecksum</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A  checksum value used by the system log
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogDiskTagfile"></a><a id="setupfilelogdisktagfile"></a><a id="SETUPFILELOGDISKTAGFILE"></a><dl>
     * <dt><b>SetupFileLogDiskTagfile</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Name of the tag file of the media source containing the source file
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogDiskDescription"></a><a id="setupfilelogdiskdescription"></a><a id="SETUPFILELOGDISKDESCRIPTION"></a><dl>
     * <dt><b>SetupFileLogDiskDescription</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The human-readable description of the media where the source file resides
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogOtherInfo"></a><a id="setupfilelogotherinfo"></a><a id="SETUPFILELOGOTHERINFO"></a><dl>
     * <dt><b>SetupFileLogOtherInfo</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Additional information associated with the logged file
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the value of <i>DesiredInfo</i> is greater than <b>SetupFileLogOtherInfo</b> the function will fail, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_PARAMETER.
     * @param {PWSTR} DataOut Optional pointer to a buffer in which this function returns the requested information for the file. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. Not all information is provided for every file. An error is not returned if an empty entry for the file exists in the log. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the <i>DataOut</i> buffer,  in characters. This includes the <b>null</b> terminator. If the buffer is too small and <i>DataOut</i> is specified, data is not stored in the buffer and the function returns zero. If <i>DataOut</i> is not specified, the <i>ReturnBufferSize</i> parameter is ignored.
     * @param {Pointer<Integer>} RequiredSize Optional pointer to a variable that receives the required size of <i>DataOut</i>, in characters. This number includes the <b>null</b> terminator.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupqueryfilelogw
     * @since windows5.1.2600
     */
    static SetupQueryFileLogW(FileLogHandle, LogSectionName, TargetFilename, DesiredInfo, DataOut, ReturnBufferSize, RequiredSize) {
        LogSectionName := LogSectionName is String ? StrPtr(LogSectionName) : LogSectionName
        TargetFilename := TargetFilename is String ? StrPtr(TargetFilename) : TargetFilename
        DataOut := DataOut is String ? StrPtr(DataOut) : DataOut

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryFileLogW", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", TargetFilename, "int", DesiredInfo, "ptr", DataOut, "uint", ReturnBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenLog function opens the log files.
     * @param {BOOL} Erase Must be FALSE.
     * @returns {BOOL} <b>TRUE</b> if the log file can be opened. <b>FALSE</b> if an error occurs. To get the  error code, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupopenlog
     * @since windows5.1.2600
     */
    static SetupOpenLog(Erase) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenLog", "int", Erase, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupLogError function writes an error message to a log file.
     * @param {PSTR} MessageString Pointer to the string that should be saved to Setup's log. The message must end with a return-linefeed combination (\r\n). You should use a null-terminated string. The null-terminated string should not exceed the size of the destination buffer. The message is always saved to the action log, setupact.log. If <i>Severity</i> is <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>, Setup also saves the message to the error log, setuperr.log. Both logs are stored in the Windows directory.
     * @param {Integer} Severity Severity of the message, one of the following: <b>LogSevInformation</b>, <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuplogerrora
     * @since windows5.1.2600
     */
    static SetupLogErrorA(MessageString, Severity) {
        MessageString := MessageString is String ? StrPtr(MessageString) : MessageString

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupLogErrorA", "ptr", MessageString, "uint", Severity, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupLogError function writes an error message to a log file.
     * @param {PWSTR} MessageString Pointer to the string that should be saved to Setup's log. The message must end with a return-linefeed combination (\r\n). You should use a null-terminated string. The null-terminated string should not exceed the size of the destination buffer. The message is always saved to the action log, setupact.log. If <i>Severity</i> is <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>, Setup also saves the message to the error log, setuperr.log. Both logs are stored in the Windows directory.
     * @param {Integer} Severity Severity of the message, one of the following: <b>LogSevInformation</b>, <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setuplogerrorw
     * @since windows5.1.2600
     */
    static SetupLogErrorW(MessageString, Severity) {
        MessageString := MessageString is String ? StrPtr(MessageString) : MessageString

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupLogErrorW", "ptr", MessageString, "uint", Severity, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCloseLog function closes the log files.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupcloselog
     * @since windows5.1.2600
     */
    static SetupCloseLog() {
        DllCall("SETUPAPI.dll\SetupCloseLog")
    }

    /**
     * The SetupGetThreadLogToken function retrieves the log token for the thread from which this function was called.
     * @returns {Integer} <b>SetupGetThreadLogToken</b> returns the log token for the thread from which the function was called. If a log token is not set for the thread, <b>SetupGetThreadLogToken</b> returns the system-defined log token LOGTOKEN_UNSPECIFIED.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetthreadlogtoken
     * @since windows6.0.6000
     */
    static SetupGetThreadLogToken() {
        result := DllCall("SETUPAPI.dll\SetupGetThreadLogToken", "uint")
        return result
    }

    /**
     * The SetupSetThreadLogToken function sets the log context, as represented by a log token, for the thread from which this function was called.
     * @param {Integer} LogToken A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a> that is either a system-defined log token or was returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetthreadlogtoken
     * @since windows6.0.6000
     */
    static SetupSetThreadLogToken(LogToken) {
        DllCall("SETUPAPI.dll\SetupSetThreadLogToken", "uint", LogToken)
    }

    /**
     * The SetupWriteTextLog function writes a log entry in a SetupAPI text log.
     * @param {Integer} LogToken A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a> that is either a system-defined log token or was returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>.
     * @param {Integer} Category A DWORD-typed value that indicates the event category for the log entry. The event categories that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event categories, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/enabling-event-categories-for-a-text-log">Enabling Event Categories for a SetupAPI Text Log</a>.
     * @param {Integer} Flags A DWORD-typed value that is a bitwise OR of flag values, which specify the following:
     * 
     * <ul>
     * <li>
     * The event level for the log entry. The event levels that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event level flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-the-event-level-for-a-text-log">Setting the Event Level for a SetupAPI Text Log</a>. 
     * 
     * </li>
     * <li>
     * Whether to include a time stamp in the log entry. The time stamp flag value is TXTLOG_TIMESTAMP.
     * 
     * </li>
     * <li>
     * The change, if any, to the indentation depth of the section and the current log entry. For information about how to use the indentation flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-indented-log-entries">Writing Indented Log Entries</a>.
     * 
     * </li>
     * </ul>
     * @param {PSTR} MessageStr A pointer to a NULL-terminated constant string that contains a <b>printf</b>-compatible format string, which specifies the formatted message to include in the log entry. The comma-separated parameter list that follows <i>MessageStr</i> must match the format specifiers in the format string.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupwritetextlog
     * @since windows6.0.6000
     */
    static SetupWriteTextLog(LogToken, Category, Flags, MessageStr) {
        MessageStr := MessageStr is String ? StrPtr(MessageStr) : MessageStr

        DllCall("SETUPAPI.dll\SetupWriteTextLog", "uint", LogToken, "uint", Category, "uint", Flags, "ptr", MessageStr, "CDecl ")
    }

    /**
     * The SetupWriteTextLogError function writes information about a SetupAPI-specific error or a Win32 system error to a SetupAPI text log.
     * @param {Integer} LogToken A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a> that is either a system-defined log token or was returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>.
     * @param {Integer} Category A value of type DWORD that indicates the event category for the log entry. The event categories that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event categories, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/enabling-event-categories-for-a-text-log">Enabling Event Categories for a SetupAPI Text Log</a>.
     * @param {Integer} LogFlags A value of type DWORD that is a bitwise OR of flag values, which specify the following:
     * 
     * <ul>
     * <li>
     * The event level for the log entry. The event levels that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event level flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-the-event-level-for-a-text-log">Setting the Event Level for a Text Log</a>. 
     * 
     * </li>
     * <li>
     * Whether to include a time stamp in the log entry. The time stamp flag value is TXTLOG_TIMESTAMP.
     * 
     * </li>
     * <li>
     * The change, if any, to the indentation depth of the section and the current log entry. For information about how to use the indentation flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-indented-log-entries">Writing Indented Log Entries</a>.
     * 
     * </li>
     * </ul>
     * @param {Integer} Error A SetupAPI-specific error code or a Win32 error code. The SetupAPI-specific error codes are listed in <i>Setupapi.h</i>. The Win32 error codes are listed in <i>Winerror.h</i>.
     * @param {PSTR} MessageStr A pointer to a NULL-terminated constant string that contains a <b>printf</b>-compatible format string, which specifies the formatted message to include in the log entry.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupwritetextlogerror
     * @since windows6.0.6000
     */
    static SetupWriteTextLogError(LogToken, Category, LogFlags, Error, MessageStr) {
        MessageStr := MessageStr is String ? StrPtr(MessageStr) : MessageStr

        DllCall("SETUPAPI.dll\SetupWriteTextLogError", "uint", LogToken, "uint", Category, "uint", LogFlags, "uint", Error, "ptr", MessageStr, "CDecl ")
    }

    /**
     * The SetupWriteTextLogInfLine function writes a log entry in a SetupAPI text log that contains the text of a specified INF file line.
     * @param {Integer} LogToken A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a> that is either a system-defined log token or was returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>.
     * @param {Integer} Flags A value of type DWORD that is a bitwise OR of flag values, which specify the following:
     * 
     * <ul>
     * <li>
     * The event level for the log entry. The event levels that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event level flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-the-event-level-for-a-text-log">Setting the Event Level for a SetupAPI Text Log</a>. 
     * 
     * </li>
     * <li>
     * Whether to include a time stamp in the log entry. The time stamp flag value is TXTLOG_TIMESTAMP.
     * 
     * </li>
     * <li>
     * The change, if any, to the indentation depth of the section and the current log entry. For information about how to use the indentation flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-indented-log-entries">Writing Indented Log Entries</a>.
     * 
     * </li>
     * </ul>
     * @param {Pointer<Void>} InfHandle A handle to the INF file that includes the line of text to be written to the text log. A handle to an INF file is obtained by calling <b>SetupOpenInfFile</b>, which is documented in the Platform SDK.
     * @param {Pointer<INFCONTEXT>} Context A pointer to an INF file context that specifies the  line of text to be written to the text log. An INF file context for a line is obtained by calling the <b>SetupFind</b><i>Xxx</i><b>Line</b> functions. For information about INF files and an INF file context, see the information that is provided in the Platform SDK about using INF files, obtaining an INF file context, and the INFCONTEXT structure.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupwritetextloginfline
     * @since windows6.0.6000
     */
    static SetupWriteTextLogInfLine(LogToken, Flags, InfHandle, Context) {
        DllCall("SETUPAPI.dll\SetupWriteTextLogInfLine", "uint", LogToken, "uint", Flags, "ptr", InfHandle, "ptr", Context)
    }

    /**
     * 
     * @param {Pointer<Void>} QueueHandle 
     * @param {Pointer<SP_BACKUP_QUEUE_PARAMS_V2_A>} BackupParams 
     * @returns {BOOL} 
     */
    static SetupGetBackupInformationA(QueueHandle, BackupParams) {
        result := DllCall("SETUPAPI.dll\SetupGetBackupInformationA", "ptr", QueueHandle, "ptr", BackupParams, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} QueueHandle 
     * @param {Pointer<SP_BACKUP_QUEUE_PARAMS_V2_W>} BackupParams 
     * @returns {BOOL} 
     */
    static SetupGetBackupInformationW(QueueHandle, BackupParams) {
        result := DllCall("SETUPAPI.dll\SetupGetBackupInformationW", "ptr", QueueHandle, "ptr", BackupParams, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} QueueHandle 
     * @param {PSTR} BackupPath 
     * @param {Integer} RestoreFlags 
     * @returns {BOOL} 
     */
    static SetupPrepareQueueForRestoreA(QueueHandle, BackupPath, RestoreFlags) {
        BackupPath := BackupPath is String ? StrPtr(BackupPath) : BackupPath

        result := DllCall("SETUPAPI.dll\SetupPrepareQueueForRestoreA", "ptr", QueueHandle, "ptr", BackupPath, "uint", RestoreFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} QueueHandle 
     * @param {PWSTR} BackupPath 
     * @param {Integer} RestoreFlags 
     * @returns {BOOL} 
     */
    static SetupPrepareQueueForRestoreW(QueueHandle, BackupPath, RestoreFlags) {
        BackupPath := BackupPath is String ? StrPtr(BackupPath) : BackupPath

        result := DllCall("SETUPAPI.dll\SetupPrepareQueueForRestoreW", "ptr", QueueHandle, "ptr", BackupPath, "uint", RestoreFlags, "int")
        return result
    }

    /**
     * The SetupSetNonInteractiveMode function sets a non-interactive SetupAPI flag that determines whether SetupAPI can interact with a user in the caller's context.
     * @param {BOOL} NonInteractiveFlag The Boolean value of the non-interactive flag. If <i>NonInteractive</i> is set to <b>TRUE</b>, SetupAPI runs in a non-interactive user mode and if <i>NonInteractive</i> is set to <b>FALSE</b>, SetupAPI runs in an interactive user mode.
     * @returns {BOOL} <b>SetupSetNonInteractiveMode</b> returns the previous setting of the non-interactive flag.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupsetnoninteractivemode
     * @since windows5.1.2600
     */
    static SetupSetNonInteractiveMode(NonInteractiveFlag) {
        result := DllCall("SETUPAPI.dll\SetupSetNonInteractiveMode", "int", NonInteractiveFlag, "int")
        return result
    }

    /**
     * The SetupGetNonInteractiveMode function returns the value of a SetupAPI non-interactive flag that indicates whether the caller's process can interact with a user through user interface components, such as dialog boxes.
     * @returns {BOOL} <b>SetupGetNonInteractiveMode</b> returns <b>TRUE</b> if the caller's process cannot display interactive user interface elements, such as dialog boxes. Otherwise, the function returns <b>FALSE</b>, which indicates that the process can display interactive user interface elements.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupgetnoninteractivemode
     * @since windows5.1.2600
     */
    static SetupGetNonInteractiveMode() {
        result := DllCall("SETUPAPI.dll\SetupGetNonInteractiveMode", "int")
        return result
    }

    /**
     * The SetupDiCreateDeviceInfoList function creates an empty device information set and optionally associates the set with a device setup class and a top-level window.
     * @param {Pointer<Guid>} ClassGuid A pointer to the <b>GUID</b> of the device setup class to associate with the newly created device information set. If this parameter is specified, only devices of this class can be included in this device information set. If this parameter is set to <b>NULL</b>, the device information set is not associated with a specific device setup class.
     * @param {HWND} hwndParent A handle to the top-level window to use for any user interface that is related to non-device-specific actions (such as a select-device dialog box that uses the global class driver list). This handle is optional and can be <b>NULL</b>. If a specific top-level window is not required, set <i>hwndParent</i> to <b>NULL</b>.
     * @returns {HDEVINFO} The function returns a handle to an empty device information set if it is successful. Otherwise, it returns <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdicreatedeviceinfolist
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoList(ClassGuid, hwndParent) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoList", "ptr", ClassGuid, "ptr", hwndParent, "ptr")
        if(A_LastError)
            throw OSError()

        return HDEVINFO({Value: result}, True)
    }

    /**
     * The SetupDiCreateDeviceInfoList function creates an empty device information set on a remote or a local computer and optionally associates the set with a device setup class .
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the device setup class to associate with the newly created device information set. If this parameter is specified, only devices of this class can be included in this device information set. If this parameter is set to <b>NULL</b>, the device information set is not associated with a specific device setup class.
     * @param {HWND} hwndParent A handle to the top-level window to use for any user interface that is related to non-device-specific actions (such as a select-device dialog box that uses the global class driver list). This handle is optional and can be <b>NULL</b>. If a specific top-level window is not required, set <i>hwndParent</i> to <b>NULL</b>.
     * @param {PSTR} MachineName A pointer to a NULL-terminated string that contains the name of a computer on a network. If a name is specified, only devices on that computer can be created and opened in this device information set. If this parameter is set to <b>NULL</b>, the device information set is for devices on the local computer.
     * @returns {HDEVINFO} The function returns a handle to an empty device information set if it is successful. Otherwise, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdicreatedeviceinfolistexa
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoListExA(ClassGuid, hwndParent, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoListExA", "ptr", ClassGuid, "ptr", hwndParent, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return HDEVINFO({Value: result}, True)
    }

    /**
     * The SetupDiCreateDeviceInfoList function creates an empty device information set on a remote or a local computer and optionally associates the set with a device setup class .
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the device setup class to associate with the newly created device information set. If this parameter is specified, only devices of this class can be included in this device information set. If this parameter is set to <b>NULL</b>, the device information set is not associated with a specific device setup class.
     * @param {HWND} hwndParent A handle to the top-level window to use for any user interface that is related to non-device-specific actions (such as a select-device dialog box that uses the global class driver list). This handle is optional and can be <b>NULL</b>. If a specific top-level window is not required, set <i>hwndParent</i> to <b>NULL</b>.
     * @param {PWSTR} MachineName A pointer to a NULL-terminated string that contains the name of a computer on a network. If a name is specified, only devices on that computer can be created and opened in this device information set. If this parameter is set to <b>NULL</b>, the device information set is for devices on the local computer.
     * @returns {HDEVINFO} The function returns a handle to an empty device information set if it is successful. Otherwise, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdicreatedeviceinfolistexw
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoListExW(ClassGuid, hwndParent, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoListExW", "ptr", ClassGuid, "ptr", hwndParent, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return HDEVINFO({Value: result}, True)
    }

    /**
     * The SetupDiGetDeviceInfoListClass function retrieves the GUID for the device setup class associated with a device information set if the set has an associated class.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to query.
     * @param {Pointer<Guid>} ClassGuid A pointer to variable of type GUID that receives the GUID for the associated class.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetdeviceinfolistclass
     * @since windows5.0
     */
    static SetupDiGetDeviceInfoListClass(DeviceInfoSet, ClassGuid) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInfoListClass", "ptr", DeviceInfoSet, "ptr", ClassGuid, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_LIST_DETAIL_DATA_A>} DeviceInfoSetDetailData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila
     * @since windows5.0
     */
    static SetupDiGetDeviceInfoListDetailA(DeviceInfoSet, DeviceInfoSetDetailData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInfoListDetailA", "ptr", DeviceInfoSet, "ptr", DeviceInfoSetDetailData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_LIST_DETAIL_DATA_W>} DeviceInfoSetDetailData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetailw
     * @since windows5.0
     */
    static SetupDiGetDeviceInfoListDetailW(DeviceInfoSet, DeviceInfoSetDetailData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInfoListDetailW", "ptr", DeviceInfoSet, "ptr", DeviceInfoSetDetailData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {PSTR} DeviceName 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PSTR} DeviceDescription 
     * @param {HWND} hwndParent 
     * @param {Integer} CreationFlags 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinfoa
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoA(DeviceInfoSet, DeviceName, ClassGuid, DeviceDescription, hwndParent, CreationFlags, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        DeviceName := DeviceName is String ? StrPtr(DeviceName) : DeviceName
        DeviceDescription := DeviceDescription is String ? StrPtr(DeviceDescription) : DeviceDescription
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoA", "ptr", DeviceInfoSet, "ptr", DeviceName, "ptr", ClassGuid, "ptr", DeviceDescription, "ptr", hwndParent, "uint", CreationFlags, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {PWSTR} DeviceName 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PWSTR} DeviceDescription 
     * @param {HWND} hwndParent 
     * @param {Integer} CreationFlags 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinfow
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoW(DeviceInfoSet, DeviceName, ClassGuid, DeviceDescription, hwndParent, CreationFlags, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        DeviceName := DeviceName is String ? StrPtr(DeviceName) : DeviceName
        DeviceDescription := DeviceDescription is String ? StrPtr(DeviceDescription) : DeviceDescription
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoW", "ptr", DeviceInfoSet, "ptr", DeviceName, "ptr", ClassGuid, "ptr", DeviceDescription, "ptr", hwndParent, "uint", CreationFlags, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenDeviceInfo function adds a device information element for a device instance to a device information set, if one does not already exist in the device information set, and retrieves information that identifies the device information element for the device instance in the device information set.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to which <b>SetupDiOpenDeviceInfo</b> adds a device information element, if one does not already exist, for the device instance that is specified by <i>DeviceInstanceId</i>.
     * @param {PSTR} DeviceInstanceId A pointer to a NULL-terminated string that supplies the device instance identifier of a device (for example, "Root\*PNP0500\0000"). If <i>DeviceInstanceId</i> is <b>NULL</b> or references a zero-length string, <b>SetupDiOpenDeviceInfo</b> adds a device information element to the supplied device information set, if one does not already exist, for the root device in the device tree.
     * @param {HWND} hwndParent The handle to the top-level window to use for any user interface related to installing the device.
     * @param {Integer} OpenFlags A variable of DWORD type that controls how the device information element is opened. The value of this parameter can be one or more of the following:
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a caller-supplied <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that receives information about the device information element for the device instance that is specified by <i>DeviceInstanceId</i>. The caller must set <b>cbSize</b> to <b>sizeof(</b>SP_DEVINFO_DATA<b>)</b>. This parameter is optional and can be <b>NULL</b>.
     * @returns {BOOL} <b>SetupDiOpenDeviceInfo</b> returns <b>TRUE</b> if it is successful. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiopendeviceinfoa
     * @since windows5.0
     */
    static SetupDiOpenDeviceInfoA(DeviceInfoSet, DeviceInstanceId, hwndParent, OpenFlags, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        DeviceInstanceId := DeviceInstanceId is String ? StrPtr(DeviceInstanceId) : DeviceInstanceId
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInfoA", "ptr", DeviceInfoSet, "ptr", DeviceInstanceId, "ptr", hwndParent, "uint", OpenFlags, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenDeviceInfo function adds a device information element for a device instance to a device information set, if one does not already exist in the device information set, and retrieves information that identifies the device information element for the device instance in the device information set.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to which <b>SetupDiOpenDeviceInfo</b> adds a device information element, if one does not already exist, for the device instance that is specified by <i>DeviceInstanceId</i>.
     * @param {PWSTR} DeviceInstanceId A pointer to a NULL-terminated string that supplies the device instance identifier of a device (for example, "Root\*PNP0500\0000"). If <i>DeviceInstanceId</i> is <b>NULL</b> or references a zero-length string, <b>SetupDiOpenDeviceInfo</b> adds a device information element to the supplied device information set, if one does not already exist, for the root device in the device tree.
     * @param {HWND} hwndParent The handle to the top-level window to use for any user interface related to installing the device.
     * @param {Integer} OpenFlags A variable of DWORD type that controls how the device information element is opened. The value of this parameter can be one or more of the following:
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a caller-supplied <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that receives information about the device information element for the device instance that is specified by <i>DeviceInstanceId</i>. The caller must set <b>cbSize</b> to <b>sizeof(</b>SP_DEVINFO_DATA<b>)</b>. This parameter is optional and can be <b>NULL</b>.
     * @returns {BOOL} <b>SetupDiOpenDeviceInfo</b> returns <b>TRUE</b> if it is successful. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiopendeviceinfow
     * @since windows5.0
     */
    static SetupDiOpenDeviceInfoW(DeviceInfoSet, DeviceInstanceId, hwndParent, OpenFlags, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        DeviceInstanceId := DeviceInstanceId is String ? StrPtr(DeviceInstanceId) : DeviceInstanceId
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInfoW", "ptr", DeviceInfoSet, "ptr", DeviceInstanceId, "ptr", hwndParent, "uint", OpenFlags, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {PSTR} DeviceInstanceId 
     * @param {Integer} DeviceInstanceIdSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinstanceida
     * @since windows5.0
     */
    static SetupDiGetDeviceInstanceIdA(DeviceInfoSet, DeviceInfoData, DeviceInstanceId, DeviceInstanceIdSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        DeviceInstanceId := DeviceInstanceId is String ? StrPtr(DeviceInstanceId) : DeviceInstanceId

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInstanceIdA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstanceId, "uint", DeviceInstanceIdSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {PWSTR} DeviceInstanceId 
     * @param {Integer} DeviceInstanceIdSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinstanceidw
     * @since windows5.0
     */
    static SetupDiGetDeviceInstanceIdW(DeviceInfoSet, DeviceInfoData, DeviceInstanceId, DeviceInstanceIdSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        DeviceInstanceId := DeviceInstanceId is String ? StrPtr(DeviceInstanceId) : DeviceInstanceId

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInstanceIdW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstanceId, "uint", DeviceInstanceIdSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDeleteDeviceInfo function deletes a device information element from a device information set. This function does not delete the actual device.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element to delete.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device information element in <i>DeviceInfoSet </i>to delete.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdideletedeviceinfo
     * @since windows5.0
     */
    static SetupDiDeleteDeviceInfo(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDeleteDeviceInfo", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiEnumDeviceInfo function returns a SP_DEVINFO_DATA structure that specifies a device information element in a device information set.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to return an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents a device information element.
     * @param {Integer} MemberIndex A zero-based index of the device information element to retrieve.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure to receive information about an enumerated device information element. The caller must set <i>DeviceInfoData</i>.<b>cbSize</b> to <c>sizeof(SP_DEVINFO_DATA)</c>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdienumdeviceinfo
     * @since windows5.0
     */
    static SetupDiEnumDeviceInfo(DeviceInfoSet, MemberIndex, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiEnumDeviceInfo", "ptr", DeviceInfoSet, "uint", MemberIndex, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDestroyDeviceInfoList function deletes a device information set and frees all associated memory.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to delete.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdidestroydeviceinfolist
     * @since windows5.0
     */
    static SetupDiDestroyDeviceInfoList(DeviceInfoSet) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDestroyDeviceInfoList", "ptr", DeviceInfoSet, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiEnumDeviceInterfaces function enumerates the device interfaces that are contained in a device information set.
     * @param {HDEVINFO} DeviceInfoSet A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interfaces for which to return information. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiEnumDeviceInterfaces</b> constrains the enumeration to the interfaces that are supported by the specified device. If this parameter is <b>NULL</b>, repeated calls to <b>SetupDiEnumDeviceInterfaces</b> return information about the interfaces that are associated with all the device information elements in <i>DeviceInfoSet</i>. This pointer is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinfo">SetupDiEnumDeviceInfo</a>.
     * @param {Pointer<Guid>} InterfaceClassGuid A pointer to a GUID that specifies the device interface class for the requested interface.
     * @param {Integer} MemberIndex A zero-based index into the list of interfaces in the device information set. The caller should call this function first with <i>MemberIndex</i> set to zero to obtain the first interface. Then, repeatedly increment <i>MemberIndex</i> and retrieve an interface until this function fails and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_MORE_ITEMS.
     * 
     * If <i>DeviceInfoData</i> specifies a particular device, the <i>MemberIndex</i> is relative to only the interfaces exposed by that device.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to a caller-allocated buffer that contains, on successful return, a completed <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that identifies an interface that meets the search parameters. The caller must set <i>DeviceInterfaceData</i>.<b>cbSize</b> to <b>sizeof</b>(SP_DEVICE_INTERFACE_DATA) before calling this function.
     * @returns {BOOL} <b>SetupDiEnumDeviceInterfaces</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdienumdeviceinterfaces
     * @since windows5.0
     */
    static SetupDiEnumDeviceInterfaces(DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, MemberIndex, DeviceInterfaceData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiEnumDeviceInterfaces", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", InterfaceClassGuid, "uint", MemberIndex, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PSTR} ReferenceString 
     * @param {Integer} CreationFlags 
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea
     * @since windows5.0
     */
    static SetupDiCreateDeviceInterfaceA(DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, ReferenceString, CreationFlags, DeviceInterfaceData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        ReferenceString := ReferenceString is String ? StrPtr(ReferenceString) : ReferenceString

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInterfaceA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", InterfaceClassGuid, "ptr", ReferenceString, "uint", CreationFlags, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PWSTR} ReferenceString 
     * @param {Integer} CreationFlags 
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacew
     * @since windows5.0
     */
    static SetupDiCreateDeviceInterfaceW(DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, ReferenceString, CreationFlags, DeviceInterfaceData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        ReferenceString := ReferenceString is String ? StrPtr(ReferenceString) : ReferenceString

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInterfaceW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", InterfaceClassGuid, "ptr", ReferenceString, "uint", CreationFlags, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {PSTR} DevicePath 
     * @param {Integer} OpenFlags 
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendeviceinterfacea
     * @since windows5.0
     */
    static SetupDiOpenDeviceInterfaceA(DeviceInfoSet, DevicePath, OpenFlags, DeviceInterfaceData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        DevicePath := DevicePath is String ? StrPtr(DevicePath) : DevicePath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInterfaceA", "ptr", DeviceInfoSet, "ptr", DevicePath, "uint", OpenFlags, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {PWSTR} DevicePath 
     * @param {Integer} OpenFlags 
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendeviceinterfacew
     * @since windows5.0
     */
    static SetupDiOpenDeviceInterfaceW(DeviceInfoSet, DevicePath, OpenFlags, DeviceInterfaceData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        DevicePath := DevicePath is String ? StrPtr(DevicePath) : DevicePath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInterfaceW", "ptr", DeviceInfoSet, "ptr", DevicePath, "uint", OpenFlags, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfaceAlias function returns an alias of a specified device interface.
     * @param {HDEVINFO} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface for which to retrieve an alias. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i> for which to retrieve an alias. This pointer is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @param {Pointer<Guid>} AliasInterfaceClassGuid A pointer to a GUID that specifies the interface class of the alias to retrieve.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} AliasDeviceInterfaceData A pointer to a caller-allocated buffer that contains, on successful return, a completed <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that identifies the requested alias. The caller must set <i>AliasDeviceInterfaceData</i><b>.cbSize</b> to <b>sizeof</b>(SP_DEVICE_INTERFACE_DATA) before calling this function.
     * @returns {BOOL} <b>SetupDiGetDeviceInterfaceAlias</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Possible errors returned by <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> are listed in the following table.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid <i>DeviceInfoSet</i> or invalid <i>DeviceInterfaceData</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_DEVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no alias of class <i>AliasInterfaceClassGuid</i> for the specified device interface.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid <i>AliasDeviceInterfaceData</i> buffer. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetdeviceinterfacealias
     * @since windows5.0
     */
    static SetupDiGetDeviceInterfaceAlias(DeviceInfoSet, DeviceInterfaceData, AliasInterfaceClassGuid, AliasDeviceInterfaceData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfaceAlias", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", AliasInterfaceClassGuid, "ptr", AliasDeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDeleteDeviceInterfaceData function deletes a device interface from a device information set.
     * @param {HDEVINFO} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface to delete. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the interface in <i>DeviceInfoSet</i> to delete. This structure is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @returns {BOOL} <b>SetupDiDeleteDeviceInterfaceData</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, it returns <b>FALSE</b> and the error code for the failure can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdideletedeviceinterfacedata
     * @since windows5.0
     */
    static SetupDiDeleteDeviceInterfaceData(DeviceInfoSet, DeviceInterfaceData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDeleteDeviceInterfaceData", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRemoveDeviceInterface function removes a registered device interface from the system.
     * @param {HDEVINFO} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface to remove. This handle is typically returned by <b>SetupDiGetClassDevs</b>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i> to remove. This pointer is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * 
     * After the interface is removed, this function sets the SPINT_REMOVED flag in <i>DeviceInterfaceData</i><b>.Flags</b>. It also clears the SPINT_ACTIVE flag, but be aware that this flag should have already been cleared before this function was called.
     * @returns {BOOL} <b>SetupDiRemoveDeviceInterface</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, it returns <b>FALSE</b> and the error code for the failure can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiremovedeviceinterface
     * @since windows5.0
     */
    static SetupDiRemoveDeviceInterface(DeviceInfoSet, DeviceInterfaceData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiRemoveDeviceInterface", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData 
     * @param {Pointer} DeviceInterfaceDetailData 
     * @param {Integer} DeviceInterfaceDetailDataSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinterfacedetaila
     * @since windows5.0
     */
    static SetupDiGetDeviceInterfaceDetailA(DeviceInfoSet, DeviceInterfaceData, DeviceInterfaceDetailData, DeviceInterfaceDetailDataSize, RequiredSize, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfaceDetailA", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", DeviceInterfaceDetailData, "uint", DeviceInterfaceDetailDataSize, "uint*", RequiredSize, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfaceDetail function returns details about a device interface.
     * @param {HDEVINFO} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface for which to retrieve details. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the interface in <i>DeviceInfoSet</i> for which to retrieve details. A pointer of this type is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @param {Pointer} DeviceInterfaceDetailData A pointer to an <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_device_interface_detail_data_a">SP_DEVICE_INTERFACE_DETAIL_DATA</a> structure to receive information about the specified interface. This parameter is optional and can be <b>NULL</b>. This parameter must be <b>NULL</b> if <i>DeviceInterfaceDetailSize</i> is zero. If this parameter is specified, the caller must set <i>DeviceInterfaceDetailData</i><b>.cbSize</b> to <b>sizeof</b>(SP_DEVICE_INTERFACE_DETAIL_DATA) before calling this function. The <b>cbSize</b> member always contains the size of the fixed part of the data structure, not a size reflecting the variable-length string at the end.
     * @param {Integer} DeviceInterfaceDetailDataSize The size of the <i>DeviceInterfaceDetailData</i> buffer. The buffer must be at least (<b>offsetof</b>(SP_DEVICE_INTERFACE_DETAIL_DATA, <b>DevicePath</b>) + <b>sizeof</b>(TCHAR)) bytes, to contain the fixed part of the structure and a single <b>NULL</b> to terminate an empty MULTI_SZ string. 
     * 
     * This parameter must be zero if <i>DeviceInterfaceDetailData</i> is <b>NULL</b>.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable of type DWORD that receives the required size of the <i>DeviceInterfaceDetailData</i> buffer. This size includes the size of the fixed part of the structure plus the number of bytes required for the variable-length device path string. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a buffer that receives information about the device that supports the requested interface. The caller must set <i>DeviceInfoData</i><b>.cbSize</b> to <b>sizeof</b>(SP_DEVINFO_DATA). This parameter is optional and can be <b>NULL</b>.
     * @returns {BOOL} <b>SetupDiGetDeviceInterfaceDetail</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetdeviceinterfacedetailw
     * @since windows5.0
     */
    static SetupDiGetDeviceInterfaceDetailW(DeviceInfoSet, DeviceInterfaceData, DeviceInterfaceDetailData, DeviceInterfaceDetailDataSize, RequiredSize, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfaceDetailW", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", DeviceInterfaceDetailData, "uint", DeviceInterfaceDetailDataSize, "uint*", RequiredSize, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallDeviceInterfaces function is the default handler for the DIF_INSTALLINTERFACES installation request.
     * @param {HDEVINFO} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to install interfaces. The device information set must contain only elements for the local system.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @returns {BOOL} <b>SetupDiInstallDeviceInterfaces</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiinstalldeviceinterfaces
     * @since windows5.0
     */
    static SetupDiInstallDeviceInterfaces(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallDeviceInterfaces", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceInterfaceDefault function sets a device interface as the default interface for a device interface class.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface to set as the default for a device interface class.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i>.
     * @param {Integer} Flags Not used, must be zero.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdisetdeviceinterfacedefault
     * @since windows5.1.2600
     */
    static SetupDiSetDeviceInterfaceDefault(DeviceInfoSet, DeviceInterfaceData, Flags) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceInterfaceDefault", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Flags, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRegisterDeviceInfo function is the default handler for the DIF_REGISTERDEVICE request.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device to register. The device information set must not contain any remote elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoData.</i><b>DevInst</b> might be updated with a new handle value upon return.
     * @param {Integer} Flags A flag value that controls how the device is registered, which can be zero or the following value:
     * @param {Pointer<PSP_DETSIG_CMPPROC>} CompareProc A pointer to a comparison callback function to use in duplicate detection. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, the callback function is called for each device instance that is of the same class as the device instance that is being registered. The prototype of the callback function is as follows:
     * 
     * 
     * ```
     * typedef  DWORD (CALLBACK* PSP_DETSIG_CMPPROC) (
     *     IN HDEVINFO  DeviceInfoSet,
     *     IN PSP_DEVINFO_DATA  NewDeviceData,
     *     IN PSP_DEVINFO_DATA  ExistingDeviceData,
     *     IN PVOID  CompareContextOPTIONAL
     *     );
     * ```
     * 
     * 
     * The compare function must return ERROR_DUPLICATE_FOUND if it finds that the two devices are duplicates. Otherwise, it should return NO_ERROR. If some other error is encountered, the callback function should return the appropriate ERROR_* code to indicate the failure.
     * 
     * If <i>CompareProc</i> is not specified and duplication detection is requested, a default comparison behavior is used. The default is to compare the new device's detect signature with the detect signature of all other devices in the class. The detect signature is contained in the class-specific resource descriptor of the device's boot log configuration.
     * @param {Pointer<Void>} CompareContext A pointer to a caller-supplied context buffer that is passed into the callback function. This parameter is ignored if <i>CompareProc</i> is not specified.
     * @param {Pointer<SP_DEVINFO_DATA>} DupDeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure to receive information about a duplicate device instance, if any, discovered as a result of attempting to register this device. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, the caller must set <i>DupDeviceInfoData.</i><b>cbSize</b> to <b>sizeof</b>(SP_DEVINFO_DATA). This will be filled in if the function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_DUPLICATE_FOUND. This device information element is added as a member of the specified <i>DeviceInfoSet</i>, if not already a member. If <i>DupDeviceInfoData</i> is not specified, the duplicate is not added to the device information set.
     * 
     * If you call this function when handling a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-registerdevice">DIF_REGISTERDEVICE</a> request, the <i>DupDeviceInfoData</i> parameter must be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiregisterdeviceinfo
     * @since windows5.0
     */
    static SetupDiRegisterDeviceInfo(DeviceInfoSet, DeviceInfoData, Flags, CompareProc, CompareContext, DupDeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiRegisterDeviceInfo", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Flags, "ptr", CompareProc, "ptr", CompareContext, "ptr", DupDeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiBuildDriverInfoList function builds a list of drivers that is associated with a specific device or with the global class driver list for a device information set.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to contain the driver list, either globally for all device information elements or specifically for a single device information element. The device information set must not contain remote device information elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for the device information element in <i>DeviceInfoSet</i> that represents the device for which to build a driver list. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, the list is associated with the specified device. If this parameter is <b>NULL</b>, the list is associated with the global class driver list for <i>DeviceInfoSet</i>. 
     * 
     * If the class of this device is updated because of building a compatible driver list, <i>DeviceInfoData.</i><b>ClassGuid</b> is updated upon return.
     * @param {Integer} DriverType 
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdibuilddriverinfolist
     * @since windows5.0
     */
    static SetupDiBuildDriverInfoList(DeviceInfoSet, DeviceInfoData, DriverType) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiBuildDriverInfoList", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", DriverType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCancelDriverInfoSearch function cancels a driver list search that is currently in progress in a different thread.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which a driver list is being built.
     * @returns {BOOL} If a driver list search is underway for the specified device information set when this function is called, the search is terminated. <b>SetupDiCancelDriverInfoSearch</b> returns <b>TRUE</b> when the termination is confirmed. Otherwise, it returns <b>FALSE</b> and a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_HANDLE.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdicanceldriverinfosearch
     * @since windows5.0
     */
    static SetupDiCancelDriverInfoSearch(DeviceInfoSet) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCancelDriverInfoSearch", "ptr", DeviceInfoSet, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Integer} DriverType 
     * @param {Integer} MemberIndex 
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdienumdriverinfoa
     * @since windows5.0
     */
    static SetupDiEnumDriverInfoA(DeviceInfoSet, DeviceInfoData, DriverType, MemberIndex, DriverInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiEnumDriverInfoA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", DriverType, "uint", MemberIndex, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Integer} DriverType 
     * @param {Integer} MemberIndex 
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdienumdriverinfow
     * @since windows5.0
     */
    static SetupDiEnumDriverInfoW(DeviceInfoSet, DeviceInfoData, DriverType, MemberIndex, DriverInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiEnumDriverInfoW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", DriverType, "uint", MemberIndex, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetselecteddrivera
     * @since windows5.0
     */
    static SetupDiGetSelectedDriverA(DeviceInfoSet, DeviceInfoData, DriverInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetSelectedDriverA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetselecteddriverw
     * @since windows5.0
     */
    static SetupDiGetSelectedDriverW(DeviceInfoSet, DeviceInfoData, DriverInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetSelectedDriverW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetselecteddrivera
     * @since windows5.0
     */
    static SetupDiSetSelectedDriverA(DeviceInfoSet, DeviceInfoData, DriverInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetSelectedDriverA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetselecteddriverw
     * @since windows5.0
     */
    static SetupDiSetSelectedDriverW(DeviceInfoSet, DeviceInfoData, DriverInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetSelectedDriverW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData 
     * @param {Pointer} DriverInfoDetailData 
     * @param {Integer} DriverInfoDetailDataSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdriverinfodetaila
     * @since windows5.0
     */
    static SetupDiGetDriverInfoDetailA(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInfoDetailData, DriverInfoDetailDataSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDriverInfoDetailA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInfoDetailData, "uint", DriverInfoDetailDataSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData 
     * @param {Pointer} DriverInfoDetailData 
     * @param {Integer} DriverInfoDetailDataSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdriverinfodetailw
     * @since windows5.0
     */
    static SetupDiGetDriverInfoDetailW(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInfoDetailData, DriverInfoDetailDataSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDriverInfoDetailW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInfoDetailData, "uint", DriverInfoDetailDataSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDestroyDriverInfoList function deletes a driver list.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the driver list to delete.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be set to <b>NULL</b>. If this parameter is specified, <b>SetupDiDestroyDriverInfoList</b> deletes the driver list for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiDestroyDriverInfoList</b> deletes the global class driver list that is associated with <i>DeviceInfoSet</i>.
     * @param {Integer} DriverType 
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdidestroydriverinfolist
     * @since windows5.0
     */
    static SetupDiDestroyDriverInfoList(DeviceInfoSet, DeviceInfoData, DriverType) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDestroyDriverInfoList", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", DriverType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDevs function returns a handle to a device information set that contains requested device information elements for a local computer.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> or a <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a>. This pointer is optional and can be <b>NULL</b>. For more information about how to set <i>ClassGuid</i>, see the following <b>Remarks</b> section.
     * @param {PSTR} Enumerator A pointer to a NULL-terminated string that specifies:
     * 
     * <ul>
     * <li>
     * An identifier (ID) of a Plug and Play (PnP) <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>. This ID can either be the value's globally unique identifier (GUID) or symbolic name. For example, "PCI" can be used to specify the PCI PnP value. Other examples of symbolic names for PnP values include "USB," "PCMCIA," and "SCSI".
     * 
     * </li>
     * <li>
     * A PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. When specifying a PnP device instance ID, DIGCF_DEVICEINTERFACE must be set in the Flags parameter.
     * 
     * </li>
     * </ul>
     * This pointer is optional and can be <b>NULL</b>. If an <i>enumeration</i> value is not used to select devices, set <i>Enumerator</i> to <b>NULL</b>
     * 
     * For more information about how to set the <i>Enumerator</i> value, see the following <b>Remarks</b> section.
     * @param {HWND} hwndParent A handle to the top-level window to be used for a user interface that is associated with installing a device instance in the device information set. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} Flags A variable of type DWORD that specifies control options that filter the device information elements that are added to the device information set. This parameter can be a bitwise OR of zero or more of the following flags. For more information about combining these flags, see the following <b>Remarks</b> section.
     * @returns {HDEVINFO} If the operation succeeds, <b>SetupDiGetClassDevs</b> returns a handle to a <a href="/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains all installed devices that matched the supplied parameters. If the operation fails, the function returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassdevsa
     * @since windows5.0
     */
    static SetupDiGetClassDevsA(ClassGuid, Enumerator, hwndParent, Flags) {
        Enumerator := Enumerator is String ? StrPtr(Enumerator) : Enumerator
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevsA", "ptr", ClassGuid, "ptr", Enumerator, "ptr", hwndParent, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return HDEVINFO({Value: result}, True)
    }

    /**
     * The SetupDiGetClassDevs function returns a handle to a device information set that contains requested device information elements for a local computer.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> or a <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a>. This pointer is optional and can be <b>NULL</b>. For more information about how to set <i>ClassGuid</i>, see the following <b>Remarks</b> section.
     * @param {PWSTR} Enumerator A pointer to a NULL-terminated string that specifies:
     * 
     * <ul>
     * <li>
     * An identifier (ID) of a Plug and Play (PnP) <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>. This ID can either be the value's globally unique identifier (GUID) or symbolic name. For example, "PCI" can be used to specify the PCI PnP value. Other examples of symbolic names for PnP values include "USB," "PCMCIA," and "SCSI".
     * 
     * </li>
     * <li>
     * A PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. When specifying a PnP device instance ID, DIGCF_DEVICEINTERFACE must be set in the Flags parameter.
     * 
     * </li>
     * </ul>
     * This pointer is optional and can be <b>NULL</b>. If an <i>enumeration</i> value is not used to select devices, set <i>Enumerator</i> to <b>NULL</b>
     * 
     * For more information about how to set the <i>Enumerator</i> value, see the following <b>Remarks</b> section.
     * @param {HWND} hwndParent A handle to the top-level window to be used for a user interface that is associated with installing a device instance in the device information set. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} Flags A variable of type DWORD that specifies control options that filter the device information elements that are added to the device information set. This parameter can be a bitwise OR of zero or more of the following flags. For more information about combining these flags, see the following <b>Remarks</b> section.
     * @returns {HDEVINFO} If the operation succeeds, <b>SetupDiGetClassDevs</b> returns a handle to a <a href="/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains all installed devices that matched the supplied parameters. If the operation fails, the function returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassdevsw
     * @since windows5.0
     */
    static SetupDiGetClassDevsW(ClassGuid, Enumerator, hwndParent, Flags) {
        Enumerator := Enumerator is String ? StrPtr(Enumerator) : Enumerator
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevsW", "ptr", ClassGuid, "ptr", Enumerator, "ptr", hwndParent, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return HDEVINFO({Value: result}, True)
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PSTR} Enumerator 
     * @param {HWND} hwndParent 
     * @param {Integer} Flags 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {PSTR} MachineName 
     * @returns {HDEVINFO} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsexa
     * @since windows5.0
     */
    static SetupDiGetClassDevsExA(ClassGuid, Enumerator, hwndParent, Flags, DeviceInfoSet, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        Enumerator := Enumerator is String ? StrPtr(Enumerator) : Enumerator
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevsExA", "ptr", ClassGuid, "ptr", Enumerator, "ptr", hwndParent, "uint", Flags, "ptr", DeviceInfoSet, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return HDEVINFO({Value: result}, True)
    }

    /**
     * The SetupDiGetClassDevsEx function returns a handle to a device information set that contains requested device information elements for a local or a remote computer.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> or a <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a>. This pointer is optional and can be <b>NULL</b>. If a GUID value is not used to select devices, set <i>ClassGuid</i> to <b>NULL</b>. For more information about how to use <i>ClassGuid</i>, see the following <b>Remarks</b> section.
     * @param {PWSTR} Enumerator A pointer to a NULL-terminated string that specifies:
     * 
     * <ul>
     * <li>
     * An identifier (ID) of a Plug and Play (PnP) <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>. This ID can either be the enumerator's globally unique identifier (GUID) or symbolic name. For example, "PCI" can be used to specify the PCI PnP enumerator. Other examples of symbolic names for PnP enumerators include "USB", "PCMCIA", and "SCSI".
     * 
     * </li>
     * <li>
     *  A PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance IDs</a>. When specifying a PnP device instance ID, DIGCF_DEVICEINTERFACE must be set in the Flags parameter.
     * 
     * </li>
     * </ul>
     * This pointer is optional and can be <b>NULL</b>. If an <i>Enumerator</i> value is not used to select devices, set <i>Enumerator</i> to <b>NULL</b>
     * 
     * For more information about how to set the <i>Enumerator</i> value, see the following <b>Remarks</b> section.
     * @param {HWND} hwndParent A handle to the top-level window to be used for a user interface that is associated with installing a device instance in the device information set. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} Flags A variable of type DWORD that specifies control options that filter the device information elements that are added to the device information set. This parameter can be a bitwise OR of one or more of the following flags. For more information about combining these control options, see the following <b>Remarks</b> section.
     * @param {HDEVINFO} DeviceInfoSet The handle to an existing <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to which <b>SetupDiGetClassDevsEx</b> adds the requested device information elements. This parameter is optional and can be set to <b>NULL</b>. For more information about using this parameter, see the following <b>Remarks</b> section.
     * @param {PWSTR} MachineName A pointer to a constant string that contains the name of a remote computer on which the devices reside. A value of <b>NULL</b> for <i>MachineName</i> specifies that the device is installed on the local computer.
     * @returns {HDEVINFO} If the operation succeeds, <b>SetupDiGetClassDevsEx</b> returns a handle to a <a href="/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains all installed devices that matched the supplied parameters. If the operation fails, the function returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassdevsexw
     * @since windows5.0
     */
    static SetupDiGetClassDevsExW(ClassGuid, Enumerator, hwndParent, Flags, DeviceInfoSet, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        Enumerator := Enumerator is String ? StrPtr(Enumerator) : Enumerator
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevsExW", "ptr", ClassGuid, "ptr", Enumerator, "ptr", hwndParent, "uint", Flags, "ptr", DeviceInfoSet, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return HDEVINFO({Value: result}, True)
    }

    /**
     * The SetupDiGetINFClass function returns the class of a specified device INF file.
     * @param {PSTR} InfName A pointer to a NULL-terminated string that supplies the name of a device INF file. This name can include a path. However, if just the file name is specified, the file is searched for in each directory that is listed in the <b>DevicePath</b> entry under the <b>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion</b> subkey of the registry. The maximum length in characters, including a NULL terminator, of a NULL-terminated INF file name is MAX_PATH.
     * @param {Pointer<Guid>} ClassGuid A pointer to a variable of type GUID that receives the class GUID for the specified INF file. If the INF file does not specify a class name, the function returns a GUID_NULL structure. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiclassguidsfromnamea">SetupDiClassGuidsFromName</a> to determine whether one or more classes with this name are already installed.
     * @param {PSTR} ClassName A pointer to a buffer that receives a NULL-terminated string that contains the name of the class for the specified INF file. If the INF file does not specify a class name but does specify a GUID, this buffer receives the name that is retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiclassnamefromguida">SetupDiClassNameFromGuid</a>. However, if <b>SetupDiClassNameFromGuid</b> cannot retrieve a class name (for example, the class is not installed), it returns an empty string.
     * @param {Integer} ClassNameSize The size, in characters, of the buffer that is pointed to by the <i>ClassName</i> parameter. The maximum length of a NULL-terminated class name, in characters, is MAX_CLASS_NAME_LEN.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the number of characters that are required to store the class name, including a terminating <b>NULL</b>. This pointer is optional and can be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetinfclassa
     * @since windows5.0
     */
    static SetupDiGetINFClassA(InfName, ClassGuid, ClassName, ClassNameSize, RequiredSize) {
        InfName := InfName is String ? StrPtr(InfName) : InfName
        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetINFClassA", "ptr", InfName, "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetINFClass function returns the class of a specified device INF file.
     * @param {PWSTR} InfName A pointer to a NULL-terminated string that supplies the name of a device INF file. This name can include a path. However, if just the file name is specified, the file is searched for in each directory that is listed in the <b>DevicePath</b> entry under the <b>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion</b> subkey of the registry. The maximum length in characters, including a NULL terminator, of a NULL-terminated INF file name is MAX_PATH.
     * @param {Pointer<Guid>} ClassGuid A pointer to a variable of type GUID that receives the class GUID for the specified INF file. If the INF file does not specify a class name, the function returns a GUID_NULL structure. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiclassguidsfromnamea">SetupDiClassGuidsFromName</a> to determine whether one or more classes with this name are already installed.
     * @param {PWSTR} ClassName A pointer to a buffer that receives a NULL-terminated string that contains the name of the class for the specified INF file. If the INF file does not specify a class name but does specify a GUID, this buffer receives the name that is retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiclassnamefromguida">SetupDiClassNameFromGuid</a>. However, if <b>SetupDiClassNameFromGuid</b> cannot retrieve a class name (for example, the class is not installed), it returns an empty string.
     * @param {Integer} ClassNameSize The size, in characters, of the buffer that is pointed to by the <i>ClassName</i> parameter. The maximum length of a NULL-terminated class name, in characters, is MAX_CLASS_NAME_LEN.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the number of characters that are required to store the class name, including a terminating <b>NULL</b>. This pointer is optional and can be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetinfclassw
     * @since windows5.0
     */
    static SetupDiGetINFClassW(InfName, ClassGuid, ClassName, ClassNameSize, RequiredSize) {
        InfName := InfName is String ? StrPtr(InfName) : InfName
        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetINFClassW", "ptr", InfName, "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiBuildClassInfoList function returns a list of setup class GUIDs that identify the classes that are installed on a local computer.
     * @param {Integer} Flags 
     * @param {Pointer<Guid>} ClassGuidList A pointer to a GUID-typed array that receives a list of setup class GUIDs. This pointer is optional and can be <b>NULL</b>.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the array that is pointed to by the <i>ClassGuildList</i> parameter. If <i>ClassGuidList</i> is <b>NULL</b>, <i>ClassGuidSize</i> must be zero.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the number of GUIDs that are returned (if the number is less than or equal to the size, in GUIDs, of the array that is pointed to by the <i>ClassGuidList</i> parameter). 
     * 
     * If this number is greater than the size of the <i>ClassGuidList</i> array, it indicates how large the <i>ClassGuidList</i> array must be in order to contain all the class GUIDs.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdibuildclassinfolist
     * @since windows5.0
     */
    static SetupDiBuildClassInfoList(Flags, ClassGuidList, ClassGuidListSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiBuildClassInfoList", "uint", Flags, "ptr", ClassGuidList, "uint", ClassGuidListSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiBuildClassInfoListEx function returns a list of setup class GUIDs that includes every class installed on the local system or a remote system.
     * @param {Integer} Flags 
     * @param {Pointer<Guid>} ClassGuidList A pointer to a buffer that receives a list of setup class GUIDs.
     * @param {Integer} ClassGuidListSize Supplies the number of GUIDs in the <i>ClassGuildList</i> array.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable that receives the number of GUIDs returned. If this number is greater than the size of the <i>ClassGuidList</i>, the number indicates how large the <i>ClassGuidList</i> array must be in order to contain the list.
     * @param {PSTR} MachineName A pointer to a NULL-terminated string that contains the name of a remote computer from which to retrieve installed setup classes. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, this function builds a list of classes installed on the local computer.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdibuildclassinfolistexa
     * @since windows5.0
     */
    static SetupDiBuildClassInfoListExA(Flags, ClassGuidList, ClassGuidListSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiBuildClassInfoListExA", "uint", Flags, "ptr", ClassGuidList, "uint", ClassGuidListSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiBuildClassInfoListEx function returns a list of setup class GUIDs that includes every class installed on the local system or a remote system.
     * @param {Integer} Flags 
     * @param {Pointer<Guid>} ClassGuidList A pointer to a buffer that receives a list of setup class GUIDs.
     * @param {Integer} ClassGuidListSize Supplies the number of GUIDs in the <i>ClassGuildList</i> array.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable that receives the number of GUIDs returned. If this number is greater than the size of the <i>ClassGuidList</i>, the number indicates how large the <i>ClassGuidList</i> array must be in order to contain the list.
     * @param {PWSTR} MachineName A pointer to a NULL-terminated string that contains the name of a remote computer from which to retrieve installed setup classes. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, this function builds a list of classes installed on the local computer.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdibuildclassinfolistexw
     * @since windows5.0
     */
    static SetupDiBuildClassInfoListExW(Flags, ClassGuidList, ClassGuidListSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiBuildClassInfoListExW", "uint", Flags, "ptr", ClassGuidList, "uint", ClassGuidListSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDescription function retrieves the class description associated with the specified setup class GUID.
     * @param {Pointer<Guid>} ClassGuid The GUID of the setup class whose description is to be retrieved.
     * @param {PSTR} ClassDescription A pointer to a character buffer that receives the class description.
     * @param {Integer} ClassDescriptionSize The size, in characters, of the <i>ClassDescription</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to variable of type DWORD that receives the size, in characters, that is required to store the class description (including a NULL terminator). <i>RequiredSize</i> is always less than LINE_LEN. This parameter is optional and can be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassdescriptiona
     * @since windows5.0
     */
    static SetupDiGetClassDescriptionA(ClassGuid, ClassDescription, ClassDescriptionSize, RequiredSize) {
        ClassDescription := ClassDescription is String ? StrPtr(ClassDescription) : ClassDescription

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDescriptionA", "ptr", ClassGuid, "ptr", ClassDescription, "uint", ClassDescriptionSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDescription function retrieves the class description associated with the specified setup class GUID.
     * @param {Pointer<Guid>} ClassGuid The GUID of the setup class whose description is to be retrieved.
     * @param {PWSTR} ClassDescription A pointer to a character buffer that receives the class description.
     * @param {Integer} ClassDescriptionSize The size, in characters, of the <i>ClassDescription</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to variable of type DWORD that receives the size, in characters, that is required to store the class description (including a NULL terminator). <i>RequiredSize</i> is always less than LINE_LEN. This parameter is optional and can be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassdescriptionw
     * @since windows5.0
     */
    static SetupDiGetClassDescriptionW(ClassGuid, ClassDescription, ClassDescriptionSize, RequiredSize) {
        ClassDescription := ClassDescription is String ? StrPtr(ClassDescription) : ClassDescription

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDescriptionW", "ptr", ClassGuid, "ptr", ClassDescription, "uint", ClassDescriptionSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDescriptionEx function retrieves the description of a setup class installed on a local or remote computer.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for the setup class whose description is to be retrieved.
     * @param {PSTR} ClassDescription A pointer to a character buffer that receives the class description.
     * @param {Integer} ClassDescriptionSize The size, in characters, of the buffer that is pointed to by the <i>ClassDescription</i> parameter. The maximum length, in characters, of a NULL-terminated class description is LINE_LEN. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, that is required to store the requested NULL-terminated class description. This pointer is optional and can be <b>NULL</b>.
     * @param {PSTR} MachineName A pointer to a NULL-terminated string that supplies the name of a remote computer on which the setup class resides. This pointer is optional and can be <b>NULL</b>. If the class is installed on a local computer, set the pointer to <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassdescriptionexa
     * @since windows5.0
     */
    static SetupDiGetClassDescriptionExA(ClassGuid, ClassDescription, ClassDescriptionSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassDescription := ClassDescription is String ? StrPtr(ClassDescription) : ClassDescription
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDescriptionExA", "ptr", ClassGuid, "ptr", ClassDescription, "uint", ClassDescriptionSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDescriptionEx function retrieves the description of a setup class installed on a local or remote computer.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for the setup class whose description is to be retrieved.
     * @param {PWSTR} ClassDescription A pointer to a character buffer that receives the class description.
     * @param {Integer} ClassDescriptionSize The size, in characters, of the buffer that is pointed to by the <i>ClassDescription</i> parameter. The maximum length, in characters, of a NULL-terminated class description is LINE_LEN. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, that is required to store the requested NULL-terminated class description. This pointer is optional and can be <b>NULL</b>.
     * @param {PWSTR} MachineName A pointer to a NULL-terminated string that supplies the name of a remote computer on which the setup class resides. This pointer is optional and can be <b>NULL</b>. If the class is installed on a local computer, set the pointer to <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassdescriptionexw
     * @since windows5.0
     */
    static SetupDiGetClassDescriptionExW(ClassGuid, ClassDescription, ClassDescriptionSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassDescription := ClassDescription is String ? StrPtr(ClassDescription) : ClassDescription
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDescriptionExW", "ptr", ClassGuid, "ptr", ClassDescription, "uint", ClassDescriptionSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCallClassInstaller function calls the appropriate class installer, and any registered co-installers, with the specified installation request (DIF code).
     * @param {Integer} InstallFunction The device installation request (DIF request) to pass to the co-installers and class installer. DIF codes have the format <b>DIF_<i>XXX</i></b> and are defined in Setupapi.h. See <a href="https://docs.microsoft.com/previous-versions/ff541307(v=vs.85)">Device Installation Function Codes</a> for more information.
     * 
     * <div class="alert"><b>Note</b>For certain DIF requests, the caller must be a member of the Administrators group. For such DIF requests, this requirement is listed on the reference page for the associated default handler.</div>
     * <div></div>
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local computer. This set contains a device installation element which represents the device for which to perform the specified installation function.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in the <i>DeviceInfoSet</i> that represents the device for which to perform the specified installation function. This parameter is optional and can be set to <b>NULL</b>. If this parameter is specified, <b>SetupDiCallClassInstaller</b> performs the specified function on the <i>DeviceInfoData</i> element. If <i>DeviceInfoData</i> is <b>NULL</b>, <b>SetupDiCallClassInstaller</b> calls the installers for the setup class that is associated with <i>DeviceInfoSet</i>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * When GetLastError returns <b>ERROR_IN_WOW64</b>, this means that the calling application is a 32-bit application attempting to execute in a 64-bit environment, which is not allowed.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdicallclassinstaller
     * @since windows5.0
     */
    static SetupDiCallClassInstaller(InstallFunction, DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCallClassInstaller", "uint", InstallFunction, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSelectDevice function is the default handler for the DIF_SELECTDEVICE request.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to select a driver.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSelectDevice</b> selects the driver for the specified device and sets <i>DeviceInfoData.</i><b>ClassGuid</b> to the GUID of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for the selected driver. If this parameter is <b>NULL</b>, <b>SetupDiSelectDevice</b> sets the selected driver in the global class driver list for <i>DeviceInfoSet</i>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiselectdevice
     * @since windows5.0
     */
    static SetupDiSelectDevice(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSelectDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSelectBestCompatDrv function is the default handler for the DIF_SELECTBESTCOMPATDRV installation request.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to select the best compatible driver.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. <b>SetupDiSelectBestCompatDrv</b> selects the best driver for a device information element from the compatible driver list for the specified device.
     * @returns {BOOL} If the operation succeeds, <b>SetupDiSelectBestCompatDrv</b> returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiselectbestcompatdrv
     * @since windows5.0
     */
    static SetupDiSelectBestCompatDrv(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSelectBestCompatDrv", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallDevice function is the default handler for the DIF_INSTALLDEVICE installation request.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local system that contains a device information element that represents the device to install.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoData.</i><b>DevInst</b> might be updated with a new handle value upon return.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiinstalldevice
     * @since windows5.0
     */
    static SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallDriverFiles function is the default handler for the DIF_INSTALLDEVICEFILES installation request.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element that represents the device for which to install files. The device information set must not contain remote elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiinstalldriverfiles
     * @since windows5.0
     */
    static SetupDiInstallDriverFiles(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallDriverFiles", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRegisterCoDeviceInstallers function is the default handler for DIF_REGISTER_COINSTALLERS.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to register co-installers. The device information set must not contain any remote elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @returns {BOOL} <b>SetupDiRegisterCoDeviceInstallers</b> returns <b>TRUE</b> if the function succeeds. If the function returns <b>FALSE</b>, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiregistercodeviceinstallers
     * @since windows5.0
     */
    static SetupDiRegisterCoDeviceInstallers(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiRegisterCoDeviceInstallers", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRemoveDevice function is the default handler for the DIF_REMOVE installation request.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local system that contains a device information element that represents the device to remove.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoSet</i>.<b>DevInst</b> might be updated with a new handle value upon return. If this is a global removal or the last hardware profile-specific removal, all traces of the device instance are deleted from the registry and the handle will be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <b>GetLastError</b>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiremovedevice
     * @since windows5.0
     */
    static SetupDiRemoveDevice(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        result := DllCall("SETUPAPI.dll\SetupDiRemoveDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        return result
    }

    /**
     * The SetupDiUnremoveDevice function is the default handler for the DIF_UNREMOVE installation request.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local system that contains a device information element that represents a device to restore and to restart.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoData.</i><b>DevInst</b> might be updated with a new handle value on return.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiunremovedevice
     * @since windows5.0
     */
    static SetupDiUnremoveDevice(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiUnremoveDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRestartDevices function restarts a specified device or, if necessary, restarts all devices that are operated by the same function and filter drivers that operate the specified device.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-classes">device information set</a> that contains the device information element that represents the device to restart.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for the device information member that represents the device to restart. This parameter is also an output parameter because <b>SetupDiRestartDevices</b> updates the device installation parameters for this device information member and the status and problem code of the corresponding device instance. For more information about these updates, see the following <b>Remarks</b> section.
     * @returns {BOOL} If the operation succeeds, <b>SetupDiRestartDevices</b> returns <b>TRUE</b>; otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdirestartdevices
     */
    static SetupDiRestartDevices(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiRestartDevices", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiChangeState function is the default handler for the DIF_PROPERTYCHANGE installation request.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local computer. This set contains a device information element that represents the device whose state is to be changed.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoData.</i><b>DevInst</b> might be updated with a new handle value upon return.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdichangestate
     * @since windows5.0
     */
    static SetupDiChangeState(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiChangeState", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallClass function installs the ClassInstall32 section of the specified INF file.
     * @param {HWND} hwndParent The handle to the parent window for any user interface that is used to install this class. This parameter is optional and can be <b>NULL</b>.
     * @param {PSTR} InfFileName A pointer to a NULL-terminated string that contains the name of the INF file that contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-classinstall32-section">INF ClassInstall32 section</a>.
     * @param {Integer} Flags These flags control the installation process. Can be a combination of the following:
     * @param {Pointer<Void>} FileQueue If the DI_NOVCP flag is set, this parameter supplies a handle to a file queue where file operations should be queued but not committed.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiinstallclassa
     * @since windows5.0
     */
    static SetupDiInstallClassA(hwndParent, InfFileName, Flags, FileQueue) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        InfFileName := InfFileName is String ? StrPtr(InfFileName) : InfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallClassA", "ptr", hwndParent, "ptr", InfFileName, "uint", Flags, "ptr", FileQueue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallClass function installs the ClassInstall32 section of the specified INF file.
     * @param {HWND} hwndParent The handle to the parent window for any user interface that is used to install this class. This parameter is optional and can be <b>NULL</b>.
     * @param {PWSTR} InfFileName A pointer to a NULL-terminated string that contains the name of the INF file that contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-classinstall32-section">INF ClassInstall32 section</a>.
     * @param {Integer} Flags These flags control the installation process. Can be a combination of the following:
     * @param {Pointer<Void>} FileQueue If the DI_NOVCP flag is set, this parameter supplies a handle to a file queue where file operations should be queued but not committed.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiinstallclassw
     * @since windows5.0
     */
    static SetupDiInstallClassW(hwndParent, InfFileName, Flags, FileQueue) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        InfFileName := InfFileName is String ? StrPtr(InfFileName) : InfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallClassW", "ptr", hwndParent, "ptr", InfFileName, "uint", Flags, "ptr", FileQueue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HWND} hwndParent 
     * @param {PSTR} InfFileName 
     * @param {Integer} Flags 
     * @param {Pointer<Void>} FileQueue 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstallclassexa
     * @since windows5.0
     */
    static SetupDiInstallClassExA(hwndParent, InfFileName, Flags, FileQueue, InterfaceClassGuid) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        InfFileName := InfFileName is String ? StrPtr(InfFileName) : InfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallClassExA", "ptr", hwndParent, "ptr", InfFileName, "uint", Flags, "ptr", FileQueue, "ptr", InterfaceClassGuid, "ptr", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HWND} hwndParent 
     * @param {PWSTR} InfFileName 
     * @param {Integer} Flags 
     * @param {Pointer<Void>} FileQueue 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstallclassexw
     * @since windows5.0
     */
    static SetupDiInstallClassExW(hwndParent, InfFileName, Flags, FileQueue, InterfaceClassGuid) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        InfFileName := InfFileName is String ? StrPtr(InfFileName) : InfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallClassExW", "ptr", hwndParent, "ptr", InfFileName, "uint", Flags, "ptr", FileQueue, "ptr", InterfaceClassGuid, "ptr", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenClassRegKey function opens the setup class registry key or a specific class's subkey.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the setup class whose key is to be opened. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the root of the setup class tree (<b>HKLM\SYSTEM\CurrentControlSet\Control\Class</b>) is opened.
     * @param {Integer} samDesired The registry security access for the key to be opened. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @returns {HKEY} If the function is successful, it returns a handle to an opened registry key where information about this setup class can be stored/retrieved. 
     * 
     * If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiopenclassregkey
     * @since windows5.0
     */
    static SetupDiOpenClassRegKey(ClassGuid, samDesired) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenClassRegKey", "ptr", ClassGuid, "uint", samDesired, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Integer} samDesired 
     * @param {Integer} Flags 
     * @param {PSTR} MachineName 
     * @returns {HKEY} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopenclassregkeyexa
     * @since windows5.0
     */
    static SetupDiOpenClassRegKeyExA(ClassGuid, samDesired, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenClassRegKeyExA", "ptr", ClassGuid, "uint", samDesired, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Integer} samDesired 
     * @param {Integer} Flags 
     * @param {PWSTR} MachineName 
     * @returns {HKEY} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopenclassregkeyexw
     * @since windows5.0
     */
    static SetupDiOpenClassRegKeyExW(ClassGuid, samDesired, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenClassRegKeyExW", "ptr", ClassGuid, "uint", samDesired, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData 
     * @param {Integer} samDesired 
     * @param {Pointer<Void>} InfHandle 
     * @param {PSTR} InfSectionName 
     * @returns {HKEY} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinterfaceregkeya
     * @since windows5.0
     */
    static SetupDiCreateDeviceInterfaceRegKeyA(DeviceInfoSet, DeviceInterfaceData, samDesired, InfHandle, InfSectionName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        InfSectionName := InfSectionName is String ? StrPtr(InfSectionName) : InfSectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInterfaceRegKeyA", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Reserved, "uint", samDesired, "ptr", InfHandle, "ptr", InfSectionName, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData 
     * @param {Integer} samDesired 
     * @param {Pointer<Void>} InfHandle 
     * @param {PWSTR} InfSectionName 
     * @returns {HKEY} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinterfaceregkeyw
     * @since windows5.0
     */
    static SetupDiCreateDeviceInterfaceRegKeyW(DeviceInfoSet, DeviceInterfaceData, samDesired, InfHandle, InfSectionName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        InfSectionName := InfSectionName is String ? StrPtr(InfSectionName) : InfSectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInterfaceRegKeyW", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Reserved, "uint", samDesired, "ptr", InfHandle, "ptr", InfSectionName, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * The SetupDiOpenDeviceInterfaceRegKey function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface.
     * @param {HDEVINFO} DeviceInfoSet A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface for which to open a registry subkey.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface. This pointer can be returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea">SetupDiCreateDeviceInterface</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @param {Integer} samDesired The requested registry security access to the registry subkey. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @returns {HKEY} <b>SetupDiOpenDeviceInterfaceRegKey</b> returns a handle to the opened registry key. If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiopendeviceinterfaceregkey
     * @since windows5.0
     */
    static SetupDiOpenDeviceInterfaceRegKey(DeviceInfoSet, DeviceInterfaceData, samDesired) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInterfaceRegKey", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Reserved, "uint", samDesired, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * The SetupDiDeleteDeviceInterfaceRegKey function deletes the registry subkey that is used by applications and drivers to store interface-specific information.
     * @param {HDEVINFO} DeviceInfoSet A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface for which to delete interface-specific information in the registry. The device information set must not contain remote elements.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i>. This pointer is possibly returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea">SetupDiCreateDeviceInterface</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @returns {BOOL} <b>SetupDiDeleteDeviceInterfaceRegKey</b> returns <b>TRUE</b> if it is successful; otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdideletedeviceinterfaceregkey
     * @since windows5.0
     */
    static SetupDiDeleteDeviceInterfaceRegKey(DeviceInfoSet, DeviceInterfaceData) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDeleteDeviceInterfaceRegKey", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Integer} Scope 
     * @param {Integer} HwProfile 
     * @param {Integer} KeyType 
     * @param {Pointer<Void>} InfHandle 
     * @param {PSTR} InfSectionName 
     * @returns {HKEY} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedevregkeya
     * @since windows5.0
     */
    static SetupDiCreateDevRegKeyA(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, InfHandle, InfSectionName) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        InfSectionName := InfSectionName is String ? StrPtr(InfSectionName) : InfSectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDevRegKeyA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Scope, "uint", HwProfile, "uint", KeyType, "ptr", InfHandle, "ptr", InfSectionName, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Integer} Scope 
     * @param {Integer} HwProfile 
     * @param {Integer} KeyType 
     * @param {Pointer<Void>} InfHandle 
     * @param {PWSTR} InfSectionName 
     * @returns {HKEY} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedevregkeyw
     * @since windows5.0
     */
    static SetupDiCreateDevRegKeyW(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, InfHandle, InfSectionName) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        InfSectionName := InfSectionName is String ? StrPtr(InfSectionName) : InfSectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDevRegKeyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Scope, "uint", HwProfile, "uint", KeyType, "ptr", InfHandle, "ptr", InfSectionName, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * The SetupDiOpenDevRegKey function opens a registry key for device-specific configuration information.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to open a registry key.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} Scope 
     * @param {Integer} HwProfile A hardware profile value, which is set as follows:
     * 
     * <ul>
     * <li>
     * If <i>Scope</i> is set to DICS_FLAG_CONFIGSPECIFIC, <i>HwProfile</i> specifies the hardware profile of the key that is to be opened. 
     * 
     * </li>
     * <li>
     * If <i>HwProfile</i> is 0, the key for the current hardware profile is opened. 
     * 
     * </li>
     * <li>
     * If <i>Scope</i> is DICS_FLAG_GLOBAL, <i>HwProfile</i> is ignored.
     * 
     * </li>
     * </ul>
     * @param {Integer} KeyType 
     * @param {Integer} samDesired The registry security access that is required for the requested key. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @returns {HKEY} If the function is successful, it returns a handle to an opened registry key where private configuration data about this device instance can be stored/retrieved.
     * 
     * If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiopendevregkey
     * @since windows5.0
     */
    static SetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, samDesired) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDevRegKey", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Scope, "uint", HwProfile, "uint", KeyType, "uint", samDesired, "ptr")
        if(A_LastError)
            throw OSError()

        return HKEY({Value: result}, True)
    }

    /**
     * The SetupDiDeleteDevRegKey function deletes specified user-accessible registry keys that are associated with a device information element.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to delete registry keys. The device information set must not contain remote elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} Scope 
     * @param {Integer} HwProfile If <i>Scope</i> is set to DICS_FLAG_CONFIGSPECIFIC, the <i>HwProfile</i> parameter specifies the hardware profile for which to delete the registry key. If <i>HwProfile</i> is 0, the key for the current hardware profile is deleted. If <i>HwProfile</i> is 0xFFFFFFFF, the registry key for all hardware profiles is deleted.
     * @param {Integer} KeyType 
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdideletedevregkey
     * @since windows5.0
     */
    static SetupDiDeleteDevRegKey(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDeleteDevRegKey", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Scope, "uint", HwProfile, "uint", KeyType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileList function retrieves a list of all currently defined hardware profile IDs.
     * @param {Pointer<Integer>} HwProfileList A pointer to an array to receive the list of currently defined hardware profile IDs.
     * @param {Integer} HwProfileListSize The number of DWORDs in the <i>HwProfileList</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable of type DWORD that receives the number of hardware profiles currently defined. If the number is larger than <i>HwProfileListSize</i>, the list is truncated to fit the array size. The value returned in <i>RequiredSize</i> indicates the array size required to store the entire list of hardware profiles. In this case, the function fails and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<Integer>} CurrentlyActiveIndex A pointer to a variable of type DWORD that receives the index of the currently active hardware profile in the retrieved hardware profile list. This parameter is optional and can be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigethwprofilelist
     * @since windows5.0
     */
    static SetupDiGetHwProfileList(HwProfileList, HwProfileListSize, RequiredSize, CurrentlyActiveIndex) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileList", "uint*", HwProfileList, "uint", HwProfileListSize, "uint*", RequiredSize, "uint*", CurrentlyActiveIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileListEx function retrieves a list of all currently defined hardware profile IDs on a local or remote computer.
     * @param {Pointer<Integer>} HwProfileList A pointer to an array to receive the list of currently defined hardware profile IDs.
     * @param {Integer} HwProfileListSize The number of DWORDs in the <i>HwProfileList</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable of type DWORD that receives the number of hardware profiles that are currently defined. If the number is larger than <i>HwProfileListSize</i>, the list is truncated to fit the array size. The value returned in <i>RequiredSize</i> indicates the array size required to store the entire list of hardware profiles.
     * @param {Pointer<Integer>} CurrentlyActiveIndex A pointer to a variable that receives the index of the currently active hardware profile in the retrieved hardware profile list. This parameter is optional and can be <b>NULL</b>.
     * @param {PSTR} MachineName A pointer to a NULL-terminated string that contains the name of a remote system for which to retrieve the list of hardware profile IDs. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the list is retrieved for the local system.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the required size is larger than <i>HwProfileListSize</i>, <b>SetupDiGetHwProfileListEx</b> returns <b>FALSE</b> and a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigethwprofilelistexa
     * @since windows5.0
     */
    static SetupDiGetHwProfileListExA(HwProfileList, HwProfileListSize, RequiredSize, CurrentlyActiveIndex, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileListExA", "uint*", HwProfileList, "uint", HwProfileListSize, "uint*", RequiredSize, "uint*", CurrentlyActiveIndex, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileListEx function retrieves a list of all currently defined hardware profile IDs on a local or remote computer.
     * @param {Pointer<Integer>} HwProfileList A pointer to an array to receive the list of currently defined hardware profile IDs.
     * @param {Integer} HwProfileListSize The number of DWORDs in the <i>HwProfileList</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable of type DWORD that receives the number of hardware profiles that are currently defined. If the number is larger than <i>HwProfileListSize</i>, the list is truncated to fit the array size. The value returned in <i>RequiredSize</i> indicates the array size required to store the entire list of hardware profiles.
     * @param {Pointer<Integer>} CurrentlyActiveIndex A pointer to a variable that receives the index of the currently active hardware profile in the retrieved hardware profile list. This parameter is optional and can be <b>NULL</b>.
     * @param {PWSTR} MachineName A pointer to a NULL-terminated string that contains the name of a remote system for which to retrieve the list of hardware profile IDs. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the list is retrieved for the local system.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the required size is larger than <i>HwProfileListSize</i>, <b>SetupDiGetHwProfileListEx</b> returns <b>FALSE</b> and a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigethwprofilelistexw
     * @since windows5.0
     */
    static SetupDiGetHwProfileListExW(HwProfileList, HwProfileListSize, RequiredSize, CurrentlyActiveIndex, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileListExW", "uint*", HwProfileList, "uint", HwProfileListSize, "uint*", RequiredSize, "uint*", CurrentlyActiveIndex, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDevicePropertyKeys function retrieves an array of the device property keys that represent the device properties that are set for a device instance.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>. This device information set contains the device instance for which this function retrieves an array of device property keys. The property keys represent the device properties that are set for the device instance.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device instance for which to retrieve the requested array of device property keys.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray A pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device instance. The pointer is optional and can be <b>NULL</b>. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyKeyCount The size, in DEVPROPKEY-typed values, of the <i>PropertyKeyArray </i>buffer<i>. </i>If <i>PropertyKeyArray</i> is set to <b>NULL</b>, <i>PropertyKeyCount</i> must be set to zero.
     * @param {Pointer<Integer>} RequiredPropertyKeyCount A pointer to a DWORD-typed variable that receives the number of requested device property keys. The pointer is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {BOOL} <b>SetupDiGetDevicePropertyKeys</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device information element is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyKeyArray</i> is <b>NULL</b> and <i>PropertKeyCount</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device instance that is specified by <i>DevInfoData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyKeyArray</i> buffer is too small to hold all the requested property keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetdevicepropertykeys
     * @since windows6.0.6000
     */
    static SetupDiGetDevicePropertyKeys(DeviceInfoSet, DeviceInfoData, PropertyKeyArray, PropertyKeyCount, RequiredPropertyKeyCount, Flags) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDevicePropertyKeys", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertyKeyArray, "uint", PropertyKeyCount, "uint*", RequiredPropertyKeyCount, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceProperty function retrieves a device instance property.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device instance for which to retrieve a device instance property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device instance for which to retrieve a device instance property.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device instance property.
     * @param {Pointer<Integer>} PropertyType A pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device instance property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that receives the requested device instance property. <b>SetupDiGetDeviceProperty</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be <b>NULL</b>. If the pointer is set to <b>NULL</b> and <i>RequiredSize</i> is supplied, <b>SetupDiGetDeviceProperty</b> returns the size of the property, in bytes, in *<i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in bytes, of either the device instance property if the property is retrieved or the required buffer size if the buffer is not large enough. This pointer can be set to <b>NULL</b>.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {BOOL} <b>SetupDiGetDeviceProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device information element is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b> and <i>PropertBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device instance that is specified by <i>DevInfoData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyBuffer</i> buffer is too small to hold the requested property value, or an internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested device property does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetdevicepropertyw
     * @since windows6.0.6000
     */
    static SetupDiGetDevicePropertyW(DeviceInfoSet, DeviceInfoData, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, RequiredSize, Flags) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDevicePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceProperty function sets a device instance property.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>. This device information set contains a device information element that represents the device instance for which to set a device instance property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that identifies the device instance for which to set a device instance property.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the device instance property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device instance property. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that contains the device instance property value. If the property is being deleted or set to a <b>NULL</b> value, this pointer must be <b>NULL</b>, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer </i>is <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device information element is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid or the property is not writable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property-data-type identifier that is supplied by <i>PropertyType</i>, or the property value that is supplied by <i>PropertyBuffer,</i> is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device instance that is specified by <i>DevInfoData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal element was not found. One possibility is that the property to be deleted does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdisetdevicepropertyw
     * @since windows6.0.6000
     */
    static SetupDiSetDevicePropertyW(DeviceInfoSet, DeviceInfoData, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, Flags) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDevicePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfacePropertyKeys function retrieves an array of device property keys that represent the device properties that are set for a device interface.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>. This device information set contains a device interface for which to retrieve an array of the device property keys that represent the device properties that are set for a device interface.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that represents the device interface for which to retrieve the requested array of device property keys.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray A pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key for a device property that is set for the device interface. The pointer is optional and can be <b>NULL</b>. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyKeyCount The size, in DEVPROPKEY-typed elements, of the <i>PropertyKeyArray </i>buffer<i>. </i>If <i>PropertyKeyArray</i> is <b>NULL</b>, <i>PropertyKeyCount</i> must be set to zero.
     * @param {Pointer<Integer>} RequiredPropertyKeyCount A pointer to a DWORD-typed variable that receives the number of requested device property keys. The pointer is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter is not valid. One possibility is that the device interface that is specified by <i>DevInterfaceData</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyKeyArray</i> is <b>NULL</b>, and <i>PropertKeyCount</i> is not zero. .
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface that is specified by <i>DeviceInterfaceData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyKeyArray</i> buffer is not large enough to hold all the requested property keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetdeviceinterfacepropertykeys
     * @since windows6.0.6000
     */
    static SetupDiGetDeviceInterfacePropertyKeys(DeviceInfoSet, DeviceInterfaceData, PropertyKeyArray, PropertyKeyCount, RequiredPropertyKeyCount, Flags) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfacePropertyKeys", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", PropertyKeyArray, "uint", PropertyKeyCount, "uint*", RequiredPropertyKeyCount, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfaceProperty function retrieves a device property that is set for a device interface.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device interface for which to retrieve a device interface property.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that represents the device interface for which to retrieve a device interface property.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device interface property key of the device interface property to retrieve.
     * @param {Pointer<Integer>} PropertyType A pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device interface property. The property-data-type identifier is a bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that receives the requested device interface property. <b>SetupDiGetDeviceInterfaceProperty</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be <b>NULL</b>. If the pointer is set to <b>NULL</b> and <i>RequiredSize</i> is supplied, <b>SetupDiGetDeviceInterfaceProperty</b> returns the size of the property, in bytes, in *<i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in bytes, of either the device interface property if the property is retrieved or the required buffer size, if the buffer is not large enough. This pointer can be set to <b>NULL</b>.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {BOOL} <b>SetupDiGetDeviceInterfaceProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. Other error codes can be set by the device installer functions that are called by this API.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device interface that is specified by <i>DeviceInterfaceData</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface that is specified by <i>DeviceInterfaceData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyBuffer</i> buffer is not large enough to hold the property value, or an internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested device property does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetdeviceinterfacepropertyw
     * @since windows6.0.6000
     */
    static SetupDiGetDeviceInterfacePropertyW(DeviceInfoSet, DeviceInterfaceData, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, RequiredSize, Flags) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfacePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceInterfaceProperty function sets a device property of a device interface.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface for which to set a device interface property.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that represents the device interface for which to set a device interface property.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the device interface property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier of the device interface property to set. For more information about the property-data-type identifier, see the <b>Remarks</b> section later in this topic.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that contains the device interface property value. If either the property or the interface value is being deleted, this pointer must be set to <b>NULL</b>, and <i>PropertyBufferSize</i> must be set to zero. For more information about property value data, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. The property buffer size must be consistent with the property-data-type identifier that is supplied by <i>PropertyType</i>. If <i>PropertyBuffer </i>is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} Flags Must be set to zero.
     * @returns {BOOL} <b>SetupDiSetDeviceInterfaceProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, this function returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device interface specified by <i>DeviceInterfaceData</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified data value was not valid. This error could be logged if either the symbolic link name of the device interface is not valid or the property-data-type identifier is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface that is specified by <i>DeviceInterfaceData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal element was not found. One possibility is that a property to be deleted does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdisetdeviceinterfacepropertyw
     * @since windows6.0.6000
     */
    static SetupDiSetDeviceInterfacePropertyW(DeviceInfoSet, DeviceInterfaceData, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, Flags) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceInterfacePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassPropertyKeys function retrieves an array of the device property keys that represent the device properties that are set for a device setup class or a device interface class.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that represents a device setup class or a device interface class. <b>SetupDiGetClassPropertyKeys</b> retrieves an array of the device property keys that represent device properties that are set for the specified class. For information about specifying the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray A pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device class. The pointer is optional and can be <b>NULL</b>. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyKeyCount The size, in DEVPROPKEY-typed values, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to <b>NULL</b>, <i>PropertyKeyCount</i> must be set to zero.
     * @param {Pointer<Integer>} RequiredPropertyKeyCount A pointer to a DWORD-typed variable that receives the number of requested property keys. The parameter is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags 
     * @returns {BOOL} <b>SetupDiGetClassPropertyKeys</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the DICLASSPROP_INSTALLER flag is specified, this error code indicates that the device setup class that is specified by <i>ClassGuid</i> does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The reference string for the device interface that is specified by <i>ClassGuild</i> is not valid. This error can be returned if the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified data value is not valid. One possibility is that the <i>ClassGuid</i> value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified parameter is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyKeyArray</i> is <b>NULL</b>, and <i>PropertKeyCount</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the DICLASSPROP_INTERFACE flag is specified, this error code indicates that the device interface class that is specified by <i>ClassGuid</i> does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyKeyArray</i> buffer is not large enough to hold all the property keys, or an internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclasspropertykeys
     * @since windows6.0.6000
     */
    static SetupDiGetClassPropertyKeys(ClassGuid, PropertyKeyArray, PropertyKeyCount, RequiredPropertyKeyCount, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassPropertyKeys", "ptr", ClassGuid, "ptr", PropertyKeyArray, "uint", PropertyKeyCount, "uint*", RequiredPropertyKeyCount, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassPropertyKeysEx function retrieves an array of the device property keys that represent the device properties that are set for a device setup class or a device interface class on a local or a remote computer.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that represents a device setup class or a device interface class. <b>SetupDiGetClassPropertyKeysEx</b> retrieves an array of the device property keys that represent device properties that are set for the specified class. For information about specifying the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray A pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device setup class. The pointer is optional and can be <b>NULL</b>. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyKeyCount The size, in DEVPROPKEY-type values, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to <b>NULL</b>, <i>PropertyKeyCount</i> must be set to zero.
     * @param {Pointer<Integer>} RequiredPropertyKeyCount A pointer to a DWORD-typed variable that receives the number of requested property keys. The pointer is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags 
     * @param {PWSTR} MachineName A pointer to a NULL-terminated string that contains the UNC name, including the "\\" prefix, of a computer. The pointer can be <b>NULL</b>. If the pointer is <b>NULL</b>, <b>SetupDiGetClassPropertyKeysEx</b> retrieves the requested information from the local computer.
     * @returns {BOOL} <b>SetupDiGetClassPropertyKeysEx</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the DICLASSPROP_INSTALLER flag is specified, this error code indicates that the device setup class that is specified by <i>ClassGuid</i> does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The reference string for the device interface that is specified by <i>ClassGuild</i> is not valid. This error might be returned when the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified data value is not valid. One possibility is that the <i>ClassGuid</i> value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified parameter is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyKeyArray</i> is <b>NULL</b>, and <i>PropertKeyCount</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_MACHINENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name that is specified by <i>MachineName</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the DICLASSPROP_INTERFACE flag is specified, this error code indicates that the device interface class that is specified by <i>ClassGuid</i> does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyKeyArray</i> buffer is not large enough to hold all the property keys, or an internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclasspropertykeysexw
     * @since windows6.0.6000
     */
    static SetupDiGetClassPropertyKeysExW(ClassGuid, PropertyKeyArray, PropertyKeyCount, RequiredPropertyKeyCount, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassPropertyKeysExW", "ptr", ClassGuid, "ptr", PropertyKeyArray, "uint", PropertyKeyCount, "uint*", RequiredPropertyKeyCount, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassProperty function retrieves a device property that is set for a device setup class or a device interface class.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that identifies the device setup class or device interface class for which to retrieve a device property that is set for the device class. For information about specifying the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device class property.
     * @param {Pointer<Integer>} PropertyType A pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device class property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that receives the requested device class property. <b>SetupDiGetClassProperty</b> retrieves the requested property value only if the buffer is large enough to hold all the property value data. The pointer can be <b>NULL</b>. If the pointer is set to <b>NULL</b> and <i>RequiredSize</i> is supplied, <b>SetupDiGetClassProperty</b> returns the size of the device class property, in bytes, in *<i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives either the size, in bytes, of the device class property if the device class property is retrieved or the required buffer size if the buffer is not large enough. This pointer can be set to <b>NULL</b>.
     * @param {Integer} Flags 
     * @returns {BOOL} <b>SetupDiGetClassProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device setup class that is specified by <i>ClassGuid</i> is not valid. This error can occur only if the DICLASSPROP_INSTALLER flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified parameter is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface reference string is not valid. This error can be returned if the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface class that is specified by <i>ClassGuid</i> does not exist. This error can occur only if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested device property does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclasspropertyw
     * @since windows6.0.6000
     */
    static SetupDiGetClassPropertyW(ClassGuid, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, RequiredSize, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassPropertyW", "ptr", ClassGuid, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassPropertyEx function retrieves a class property for a device setup class or a device interface class on a local or remote computer.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that identifies the device setup class or device interface class for which to retrieve a device property for the device class. For information about specifying the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device class property.
     * @param {Pointer<Integer>} PropertyType A pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device class property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that receives the requested device class property. <b>SetupDiGetClassPropertyEx</b> retrieves the requested property value only if the buffer is large enough to hold all the property value data. The pointer can be <b>NULL</b>. If the pointer is set to <b>NULL</b> and <i>RequiredSize</i> is supplied, <b>SetupDiGetClassPropertyEx</b> returns the size of the device class property, in bytes, in *<i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-typed variable that receives either the size, in bytes, of the device class property if the property is retrieved or the required buffer size if the buffer is not large enough. This pointer can be set to <b>NULL</b>.
     * @param {Integer} Flags 
     * @param {PWSTR} MachineName A pointer to a NULL-terminated string that contains the UNC name, including the "\\" prefix, of a computer. The pointer can be set to <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, <b>SetupDiGetClassPropertyEx</b> retrieves the requested device class property from the local computer.
     * @returns {BOOL} <b>SetupDiGetClassPropertyEx</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device setup class that is specified by <i>ClassGuid</i> is not valid. This error can occur only if the DICLASSPROP_INSTALLER flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified parameter is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface reference string is not valid. This error can be returned if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_MACHINENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name that is specified by <i>MachineName</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface class that is specified by <i>ClassGuid</i> does not exist. This error can occur only if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested device property does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclasspropertyexw
     * @since windows6.0.6000
     */
    static SetupDiGetClassPropertyExW(ClassGuid, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, RequiredSize, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassPropertyExW", "ptr", ClassGuid, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassProperty function sets a class property for a device setup class or a device interface class.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that identifies the device setup class or device interface class for which to set a device property. For information about how to specify the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the device class property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device class property. For more information about the property-data-type identifier, see the <b>Remarks</b> section later in this topic.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that contains the property value of the device class. If either the property or the data is being deleted, this pointer must be set to <b>NULL</b>, and <i>PropertyBufferSize</i> must be set to zero. For more information about property data, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer </i>is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} Flags 
     * @returns {BOOL} <b>SetupDiSetClassProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is invalid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device setup class that is specified by <i>ClassGuid</i> is not valid. This error can occur only if the DICLASSPROP_INSTALLER flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface reference string is not valid. This error can occur only if the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid. This error could be logged if the <i>ClassGuid</i> value is not a valid GUID or the property value is not consistent with the property type specified by <i>PropertyType.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface class that is specified by <i>ClassGuid</i> does not exist. This error can occur only if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified item was not found. One possibility is that the property to be deleted does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdisetclasspropertyw
     * @since windows6.0.6000
     */
    static SetupDiSetClassPropertyW(ClassGuid, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassPropertyW", "ptr", ClassGuid, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassPropertyEx function sets a device property for a device setup class or a device interface class on a local or remote computer.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that identifies the device setup class or device interface class for which to set a device property. For information about how to specify the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the device class property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the class property. For more information about the property-data-type identifier, see the <b>Remarks</b> section later in this topic.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that contains the class property value. If either the property or the property value is being deleted, this pointer must be set to <b>NULL</b>, and <i>PropertyBufferSize</i> must be set to zero. For more information about property value requirements, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. The property buffer size must be consistent with the property-data-type identifier that is supplied by <i>PropertyType</i>. If <i>PropertyBuffer </i>is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} Flags 
     * @param {PWSTR} MachineName A pointer to a NULL-terminated Unicode string that contains the UNC name, including the "\\" prefix, of a computer. This pointer can be set to <b>NULL</b>. If the pointer is <b>NULL</b>, <b>SetupDiSetClassPropertyEx</b> sets the class property for a class that is installed on the local computer.
     * @returns {BOOL} <b>SetupDiSetClassPropertyEx</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is invalid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device setup class that is specified by <i>ClassGuid</i> is not valid. This error can occur only if the DICLASSPROP_INSTALLER flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface reference string is not valid. This error can occur only if the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid. This error could be logged if either the <i>ClassGuid</i> value is not a valid GUID or the property value does not match the property type specified by <i>PropertyType</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_MACHINENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name that is specified by <i>MachineName</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface class that is specified by <i>ClassGuid</i> does not exist. This error can occur only if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified item was not found. One possibility is that the property to be deleted does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdisetclasspropertyexw
     * @since windows6.0.6000
     */
    static SetupDiSetClassPropertyExW(ClassGuid, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassPropertyExW", "ptr", ClassGuid, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Integer} Property 
     * @param {Pointer<Integer>} PropertyRegDataType 
     * @param {Pointer} PropertyBuffer 
     * @param {Integer} PropertyBufferSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertya
     * @since windows5.0
     */
    static SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet, DeviceInfoData, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceRegistryPropertyA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Property, "uint*", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Integer} Property 
     * @param {Pointer<Integer>} PropertyRegDataType 
     * @param {Pointer} PropertyBuffer 
     * @param {Integer} PropertyBufferSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertyw
     * @since windows5.0
     */
    static SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, DeviceInfoData, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceRegistryPropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Property, "uint*", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Integer} Property 
     * @param {Pointer<Integer>} PropertyRegDataType 
     * @param {Pointer} PropertyBuffer 
     * @param {Integer} PropertyBufferSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @param {PSTR} MachineName 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassregistrypropertya
     * @since windows5.1.2600
     */
    static SetupDiGetClassRegistryPropertyA(ClassGuid, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassRegistryPropertyA", "ptr", ClassGuid, "uint", Property, "uint*", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Integer} Property 
     * @param {Pointer<Integer>} PropertyRegDataType 
     * @param {Pointer} PropertyBuffer 
     * @param {Integer} PropertyBufferSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @param {PWSTR} MachineName 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassregistrypropertyw
     * @since windows5.1.2600
     */
    static SetupDiGetClassRegistryPropertyW(ClassGuid, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassRegistryPropertyW", "ptr", ClassGuid, "uint", Property, "uint*", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Integer} Property 
     * @param {Pointer} PropertyBuffer 
     * @param {Integer} PropertyBufferSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceregistrypropertya
     * @since windows5.0
     */
    static SetupDiSetDeviceRegistryPropertyA(DeviceInfoSet, DeviceInfoData, Property, PropertyBuffer, PropertyBufferSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceRegistryPropertyA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Property, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Integer} Property 
     * @param {Pointer} PropertyBuffer 
     * @param {Integer} PropertyBufferSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceregistrypropertyw
     * @since windows5.0
     */
    static SetupDiSetDeviceRegistryPropertyW(DeviceInfoSet, DeviceInfoData, Property, PropertyBuffer, PropertyBufferSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceRegistryPropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Property, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Integer} Property 
     * @param {Pointer} PropertyBuffer 
     * @param {Integer} PropertyBufferSize 
     * @param {PSTR} MachineName 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclassregistrypropertya
     * @since windows5.1.2600
     */
    static SetupDiSetClassRegistryPropertyA(ClassGuid, Property, PropertyBuffer, PropertyBufferSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassRegistryPropertyA", "ptr", ClassGuid, "uint", Property, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Integer} Property 
     * @param {Pointer} PropertyBuffer 
     * @param {Integer} PropertyBufferSize 
     * @param {PWSTR} MachineName 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclassregistrypropertyw
     * @since windows5.1.2600
     */
    static SetupDiSetClassRegistryPropertyW(ClassGuid, Property, PropertyBuffer, PropertyBufferSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassRegistryPropertyW", "ptr", ClassGuid, "uint", Property, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DEVINSTALL_PARAMS_A>} DeviceInstallParams 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinstallparamsa
     * @since windows5.0
     */
    static SetupDiGetDeviceInstallParamsA(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInstallParams function retrieves device installation parameters for a device information set or a particular device information element.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device installation parameters to retrieve.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetDeviceInstallParams</b> retrieves the installation parameters for the specified device. If this parameter is <b>NULL</b>, the function retrieves the global device installation parameters that are associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DEVINSTALL_PARAMS_W>} DeviceInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure that receives the device install parameters. <i>DeviceInstallParams</i>.<b>cbSize</b> must be set to the size, in bytes, of the structure before calling this function.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetdeviceinstallparamsw
     * @since windows5.0
     */
    static SetupDiGetDeviceInstallParamsW(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer} ClassInstallParams 
     * @param {Integer} ClassInstallParamsSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassinstallparamsa
     * @since windows5.0
     */
    static SetupDiGetClassInstallParamsA(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", ClassInstallParams, "uint", ClassInstallParamsSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer} ClassInstallParams 
     * @param {Integer} ClassInstallParamsSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassinstallparamsw
     * @since windows5.0
     */
    static SetupDiGetClassInstallParamsW(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", ClassInstallParams, "uint", ClassInstallParamsSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DEVINSTALL_PARAMS_A>} DeviceInstallParams 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceinstallparamsa
     * @since windows5.0
     */
    static SetupDiSetDeviceInstallParamsA(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DEVINSTALL_PARAMS_W>} DeviceInstallParams 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceinstallparamsw
     * @since windows5.0
     */
    static SetupDiSetDeviceInstallParamsW(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer} ClassInstallParams 
     * @param {Integer} ClassInstallParamsSize 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclassinstallparamsa
     * @since windows5.0
     */
    static SetupDiSetClassInstallParamsA(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", ClassInstallParams, "uint", ClassInstallParamsSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassInstallParams function sets or clears class install parameters for a device information set or a particular device information element.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to set class install parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device for which to set class install parameters. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSetClassInstallParams</b> sets the class installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetClassInstallParams</b> sets the class install parameters that are associated with <i>DeviceInfoSet</i>.
     * @param {Pointer} ClassInstallParams A pointer to a buffer that contains the new class install parameters to use. The <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classinstall_header">SP_CLASSINSTALL_HEADER</a> structure at the beginning of this buffer must have its <b>cbSize</b> field set to <b>sizeof(</b>SP_CLASSINSTALL_HEADER<b>)</b> and the <b>InstallFunction</b> field must be set to the DI_FUNCTION code that reflects the type of parameters contained in the rest of the buffer. 
     * 
     * If <i>ClassInstallParams</i> is not specified, the current class install parameters, if any, are cleared for the specified device information set or element.
     * @param {Integer} ClassInstallParamsSize The size, in bytes, of the <i>ClassInstallParams</i> buffer. If the buffer is not supplied (that is, the class install parameters are being cleared), <i>ClassInstallParamsSize</i> must be 0<i>.</i>
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdisetclassinstallparamsw
     * @since windows5.0
     */
    static SetupDiSetClassInstallParamsW(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", ClassInstallParams, "uint", ClassInstallParamsSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData 
     * @param {Pointer<SP_DRVINSTALL_PARAMS>} DriverInstallParams 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdriverinstallparamsa
     * @since windows5.0
     */
    static SetupDiGetDriverInstallParamsA(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDriverInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData 
     * @param {Pointer<SP_DRVINSTALL_PARAMS>} DriverInstallParams 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdriverinstallparamsw
     * @since windows5.0
     */
    static SetupDiGetDriverInstallParamsW(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDriverInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData 
     * @param {Pointer<SP_DRVINSTALL_PARAMS>} DriverInstallParams 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdriverinstallparamsa
     * @since windows5.0
     */
    static SetupDiSetDriverInstallParamsA(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDriverInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData 
     * @param {Pointer<SP_DRVINSTALL_PARAMS>} DriverInstallParams 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdriverinstallparamsw
     * @since windows5.0
     */
    static SetupDiSetDriverInstallParamsW(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDriverInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiLoadClassIcon function loads both the large and mini-icon for the specified class.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the class for which the icon(s) should be loaded.
     * @param {Pointer<HICON>} LargeIcon A pointer to an icon handle that receives the handle value for the loaded large icon for the specified class. This pointer is optional and can be <b>NULL</b>. If the pointer is <b>NULL</b>, the large icon is not loaded.
     * @param {Pointer<Integer>} MiniIconIndex A pointer to an INT-typed variable that receives the index of the mini-icon for the specified class. The mini-icon is stored in the device installer's mini-icon cache. The pointer is optional and can be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiloadclassicon
     * @since windows5.0
     */
    static SetupDiLoadClassIcon(ClassGuid, LargeIcon, MiniIconIndex) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiLoadClassIcon", "ptr", ClassGuid, "ptr", LargeIcon, "int*", MiniIconIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiLoadDeviceIcon function retrieves an icon for a specified device.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element that represents the device for which to retrieve an icon.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} cxIcon The width, in pixels, of the icon to be retrieved. Use the system metric index SM_CXICON to specify a default-sized icon or use the system metric index SM_CXSMICON to specify a small icon. The system metric indexes are defined in <i>Winuser.h</i>, and their associated values can be retrieved by a call to the <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> function. (The <b>GetSystemMetrics</b> function is documented in the Microsoft Windows SDK.)
     * @param {Integer} cyIcon The height, in pixels, of the icon to be retrieved. Use SM_CXICON to specify a default-sized icon or use SM_CXSMICON to specify a small icon.
     * @param {Integer} Flags Not used. Must set to zero.
     * @param {Pointer<HICON>} hIcon A pointer to a handle to an icon that receives a handle to the icon that this function retrieves. After the application that calls this function is finished using the icon, the application must call <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> to delete the icon. (<b>DestroyIcon</b> is documented in the Microsoft Windows SDK.)
     * @returns {BOOL} <b>SetupDiLoadDeviceIcon</b> returns <b>TRUE</b> if the function succeeds in retrieving the icon for the specified device. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiloaddeviceicon
     * @since windows6.0.6000
     */
    static SetupDiLoadDeviceIcon(DeviceInfoSet, DeviceInfoData, cxIcon, cyIcon, Flags, hIcon) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiLoadDeviceIcon", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", cxIcon, "uint", cyIcon, "uint", Flags, "ptr", hIcon, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDrawMiniIcon function draws the specified mini-icon at the location requested.
     * @param {HDC} hdc The handle to the device context in which the mini-icon will be drawn.
     * @param {RECT} rc The rectangle in the specified device context handle to draw the mini-icon in.
     * @param {Integer} MiniIconIndex The index of the mini-icon, as retrieved from <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiloadclassicon">SetupDiLoadClassIcon</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassbitmapindex">SetupDiGetClassBitmapIndex</a>. The following predefined indexes for devices can be used:
     * 
     * <table>
     * <tr>
     * <th>        Class</th>
     * <th>Index</th>
     * </tr>
     * <tr>
     * <td>
     *         Computer/System
     * 
     * </td>
     * <td>
     * 0
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Display/Monitor
     * 
     * </td>
     * <td>
     * 2
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Network Adapter
     * 
     * </td>
     * <td>
     * 3
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Mouse
     * 
     * </td>
     * <td>
     * 5
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Keyboard
     * 
     * </td>
     * <td>
     * 6
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Sound
     * 
     * </td>
     * <td>
     * 8
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         FDC/HDC
     * 
     * </td>
     * <td>
     * 9
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Ports
     * 
     * </td>
     * <td>
     * 10
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Printer
     * 
     * </td>
     * <td>
     * 14
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Network Transport
     * 
     * </td>
     * <td>
     * 15
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Network Client
     * 
     * </td>
     * <td>
     * 16
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Network Service
     * 
     * </td>
     * <td>
     * 17
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Unknown
     * 
     * </td>
     * <td>
     * 18
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Flags These flags control the drawing operation. The LOWORD contains the actual flags defined as follows:
     * @returns {Integer} This function returns the offset from the left side of <i>rc</i> where the string should start. If the draw operation fails, the function returns zero.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdidrawminiicon
     * @since windows5.0
     */
    static SetupDiDrawMiniIcon(hdc, rc, MiniIconIndex, Flags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("SETUPAPI.dll\SetupDiDrawMiniIcon", "ptr", hdc, "ptr", rc, "int", MiniIconIndex, "uint", Flags, "int")
        return result
    }

    /**
     * The SetupDiGetClassBitmapIndex function retrieves the index of the mini-icon supplied for the specified class.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to retrieve the mini-icon. This pointer is optional and can be <b>NULL</b>.
     * @param {Pointer<Integer>} MiniIconIndex A pointer to a variable of type INT that receives the index of the mini-icon for the specified device setup class. If the <i>ClassGuid</i> parameter is <b>NULL</b> or if there is no mini-icon for the specified class, <b>SetupDiGetClassBitmapIndex</b> returns the index of the mini-icon for the Unknown device setup class.
     * @returns {BOOL} If there is a min-icon for the specified device setup class, <b>SetupDiGetClassBitmapIndex</b> returns <b>TRUE</b>. Otherwise, this function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the <i>ClassGuid</i> parameter is <b>NULL</b>, or if there is no mini-icon for the specified class, the function returns <b>FALSE</b> and <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_DEVICE_ICON.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassbitmapindex
     * @since windows5.0
     */
    static SetupDiGetClassBitmapIndex(ClassGuid, MiniIconIndex) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassBitmapIndex", "ptr", ClassGuid, "int*", MiniIconIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassImageList function builds an image list that contains bitmaps for every installed class and returns the list in a data structure.
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classimagelist_data">SP_CLASSIMAGELIST_DATA</a> structure to receive information regarding the class image list, including a handle to the image list. The <b>cbSize</b> field of this structure must be initialized with the size of the structure, in bytes, before calling this function or it will fail.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassimagelist
     * @since windows5.0
     */
    static SetupDiGetClassImageList(ClassImageListData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassImageList", "ptr", ClassImageListData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData 
     * @param {PSTR} MachineName 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassimagelistexa
     * @since windows5.0
     */
    static SetupDiGetClassImageListExA(ClassImageListData, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassImageListExA", "ptr", ClassImageListData, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData 
     * @param {PWSTR} MachineName 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassimagelistexw
     * @since windows5.0
     */
    static SetupDiGetClassImageListExW(ClassImageListData, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassImageListExW", "ptr", ClassImageListData, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassImageIndex function retrieves the index within the class image list of a specified class.
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classimagelist_data">SP_CLASSIMAGELIST_DATA</a> structure that describes a class image list that includes the image for the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> that is specified by the <i>ClassGuid</i> parameter.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the device setup class for which to retrieve the index of the class image in the specified class image list.
     * @param {Pointer<Integer>} ImageIndex A pointer to an INT-typed variable that receives the index of the specified class image in the class image list.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetclassimageindex
     * @since windows5.0
     */
    static SetupDiGetClassImageIndex(ClassImageListData, ClassGuid, ImageIndex) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassImageIndex", "ptr", ClassImageListData, "ptr", ClassGuid, "int*", ImageIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDestroyClassImageList function destroys a class image list that was built by a call to SetupDiGetClassImageList or SetupDiGetClassImageListEx.
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classimagelist_data">SP_CLASSIMAGELIST_DATA</a> structure that contains the class image list to destroy.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdidestroyclassimagelist
     * @since windows5.0
     */
    static SetupDiDestroyClassImageList(ClassImageListData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDestroyClassImageList", "ptr", ClassImageListData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<PROPSHEETHEADERA_V2>} PropertySheetHeader 
     * @param {Integer} PropertySheetHeaderPageListSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @param {Integer} PropertySheetType 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevpropertysheetsa
     * @since windows5.0
     */
    static SetupDiGetClassDevPropertySheetsA(DeviceInfoSet, DeviceInfoData, PropertySheetHeader, PropertySheetHeaderPageListSize, RequiredSize, PropertySheetType) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevPropertySheetsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertySheetHeader, "uint", PropertySheetHeaderPageListSize, "uint*", RequiredSize, "uint", PropertySheetType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<PROPSHEETHEADERW_V2>} PropertySheetHeader 
     * @param {Integer} PropertySheetHeaderPageListSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @param {Integer} PropertySheetType 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevpropertysheetsw
     * @since windows5.0
     */
    static SetupDiGetClassDevPropertySheetsW(DeviceInfoSet, DeviceInfoData, PropertySheetHeader, PropertySheetHeaderPageListSize, RequiredSize, PropertySheetType) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevPropertySheetsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertySheetHeader, "uint", PropertySheetHeaderPageListSize, "uint*", RequiredSize, "uint", PropertySheetType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiAskForOEMDisk function displays a dialog that asks the user for the path of an OEM installation disk.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local computer. This set contains a device information element that represents the device that is being installed.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiAskForOEMDisk</b> associates the driver with the device that is being installed. If this parameter is <b>NULL</b>, <b>SetupDiAskForOEMDisk</b> associates the driver with the global class driver list for <i>DeviceInfoSet</i>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful and the <b>DriverPath</b> field of the SP_DEVINSTALLPARAMS structure is updated to reflect the new path. If the user cancels the dialog, the function returns <b>FALSE</b> and a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_CANCELLED.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiaskforoemdisk
     * @since windows5.0
     */
    static SetupDiAskForOEMDisk(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiAskForOEMDisk", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSelectOEMDrv function selects a driver for a device information set or a particular device information element that uses an OEM path supplied by the user.
     * @param {HWND} hwndParent A window handle that will be the parent of any dialogs created during the processing of this function. This parameter can be used to override the <b>hwndParent</b> field in the installation parameters block of the specified device information set or element.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to select a driver.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSelectOEMDrv</b> associates the selected driver with the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSelectOEMDrv</b> associates the selected driver with the global class driver list for <i>DeviceInfoSet</i>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiselectoemdrv
     * @since windows5.0
     */
    static SetupDiSelectOEMDrv(hwndParent, DeviceInfoSet, DeviceInfoData) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSelectOEMDrv", "ptr", hwndParent, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassNameFromGuid function retrieves the class name associated with a class GUID.
     * @param {Pointer<Guid>} ClassGuid A pointer to the class GUID for the class name to retrieve.
     * @param {PSTR} ClassName A pointer to a buffer that receives the NULL-terminated string that contains the name of the class that is specified by the pointer in the <i>ClassGuid</i> parameter.
     * @param {Integer} ClassNameSize The size, in characters, of the buffer that is pointed to by the <i>ClassName</i> parameter. The maximum size, in characters, of a NULL-terminated class name is MAX_CLASS_NAME_LEN. For more information about the class name size, see the following <b>Remarks</b> section.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable that receives the number of characters that are required to store the requested NULL-terminated class name. This pointer is optional and can be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiclassnamefromguida
     * @since windows5.0
     */
    static SetupDiClassNameFromGuidA(ClassGuid, ClassName, ClassNameSize, RequiredSize) {
        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassNameFromGuidA", "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassNameFromGuid function retrieves the class name associated with a class GUID.
     * @param {Pointer<Guid>} ClassGuid A pointer to the class GUID for the class name to retrieve.
     * @param {PWSTR} ClassName A pointer to a buffer that receives the NULL-terminated string that contains the name of the class that is specified by the pointer in the <i>ClassGuid</i> parameter.
     * @param {Integer} ClassNameSize The size, in characters, of the buffer that is pointed to by the <i>ClassName</i> parameter. The maximum size, in characters, of a NULL-terminated class name is MAX_CLASS_NAME_LEN. For more information about the class name size, see the following <b>Remarks</b> section.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable that receives the number of characters that are required to store the requested NULL-terminated class name. This pointer is optional and can be <b>NULL</b>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiclassnamefromguidw
     * @since windows5.0
     */
    static SetupDiClassNameFromGuidW(ClassGuid, ClassName, ClassNameSize, RequiredSize) {
        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassNameFromGuidW", "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassNameFromGuidEx function retrieves the class name associated with a class GUID. The class can be installed on a local or remote computer.
     * @param {Pointer<Guid>} ClassGuid The class GUID of the class name to retrieve.
     * @param {PSTR} ClassName A pointer to a string buffer that receives the NULL-terminated name of the class for the specified GUID.
     * @param {Integer} ClassNameSize The size, in characters, of the <i>ClassName</i> buffer.
     * @param {Pointer<Integer>} RequiredSize The number of characters required to store the class name (including a terminating null). <i>RequiredSize</i> is always less than MAX_CLASS_NAME_LEN.
     * @param {PSTR} MachineName A pointer to a NULL-terminated string that contains the name of a remote system on which the class is installed. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the local system name is used.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiclassnamefromguidexa
     * @since windows5.0
     */
    static SetupDiClassNameFromGuidExA(ClassGuid, ClassName, ClassNameSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassNameFromGuidExA", "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassNameFromGuidEx function retrieves the class name associated with a class GUID. The class can be installed on a local or remote computer.
     * @param {Pointer<Guid>} ClassGuid The class GUID of the class name to retrieve.
     * @param {PWSTR} ClassName A pointer to a string buffer that receives the NULL-terminated name of the class for the specified GUID.
     * @param {Integer} ClassNameSize The size, in characters, of the <i>ClassName</i> buffer.
     * @param {Pointer<Integer>} RequiredSize The number of characters required to store the class name (including a terminating null). <i>RequiredSize</i> is always less than MAX_CLASS_NAME_LEN.
     * @param {PWSTR} MachineName A pointer to a NULL-terminated string that contains the name of a remote system on which the class is installed. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the local system name is used.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiclassnamefromguidexw
     * @since windows5.0
     */
    static SetupDiClassNameFromGuidExW(ClassGuid, ClassName, ClassNameSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassNameFromGuidExW", "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassGuidsFromName function retrieves the GUID(s) associated with the specified class name. This list is built based on the classes currently installed on the system.
     * @param {PSTR} ClassName The name of the class for which to retrieve the class GUID.
     * @param {Pointer<Guid>} ClassGuidList A pointer to an array to receive the list of GUIDs associated with the specified class name.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the <i>ClassGuidList</i> array.
     * @param {Pointer<Integer>} RequiredSize Supplies a pointer to a variable that receives the number of GUIDs associated with the class name. If this number is greater than the size of the <i>ClassGuidList</i> buffer, the number indicates how large the array must be in order to store all the GUIDs.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiclassguidsfromnamea
     * @since windows5.0
     */
    static SetupDiClassGuidsFromNameA(ClassName, ClassGuidList, ClassGuidListSize, RequiredSize) {
        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassGuidsFromNameA", "ptr", ClassName, "ptr", ClassGuidList, "uint", ClassGuidListSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassGuidsFromName function retrieves the GUID(s) associated with the specified class name. This list is built based on the classes currently installed on the system.
     * @param {PWSTR} ClassName The name of the class for which to retrieve the class GUID.
     * @param {Pointer<Guid>} ClassGuidList A pointer to an array to receive the list of GUIDs associated with the specified class name.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the <i>ClassGuidList</i> array.
     * @param {Pointer<Integer>} RequiredSize Supplies a pointer to a variable that receives the number of GUIDs associated with the class name. If this number is greater than the size of the <i>ClassGuidList</i> buffer, the number indicates how large the array must be in order to store all the GUIDs.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiclassguidsfromnamew
     * @since windows5.0
     */
    static SetupDiClassGuidsFromNameW(ClassName, ClassGuidList, ClassGuidListSize, RequiredSize) {
        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassGuidsFromNameW", "ptr", ClassName, "ptr", ClassGuidList, "uint", ClassGuidListSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassGuidsFromNameEx function retrieves the GUIDs associated with the specified class name. This resulting list contains the classes currently installed on a local or remote computer.
     * @param {PSTR} ClassName The name of the class for which to retrieve the class GUIDs.
     * @param {Pointer<Guid>} ClassGuidList A pointer to an array to receive the list of GUIDs associated with the specified class name.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the <i>ClassGuidList</i> array.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable that receives the number of GUIDs associated with the class name. If this number is greater than the size of the <i>ClassGuidList</i> buffer, the number indicates how large the array must be in order to store all the GUIDs.
     * @param {PSTR} MachineName A pointer to a NULL-terminated string that contains the name of a remote system from which to retrieve the GUIDs. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the local system name is used.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiclassguidsfromnameexa
     * @since windows5.0
     */
    static SetupDiClassGuidsFromNameExA(ClassName, ClassGuidList, ClassGuidListSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassGuidsFromNameExA", "ptr", ClassName, "ptr", ClassGuidList, "uint", ClassGuidListSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassGuidsFromNameEx function retrieves the GUIDs associated with the specified class name. This resulting list contains the classes currently installed on a local or remote computer.
     * @param {PWSTR} ClassName The name of the class for which to retrieve the class GUIDs.
     * @param {Pointer<Guid>} ClassGuidList A pointer to an array to receive the list of GUIDs associated with the specified class name.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the <i>ClassGuidList</i> array.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable that receives the number of GUIDs associated with the class name. If this number is greater than the size of the <i>ClassGuidList</i> buffer, the number indicates how large the array must be in order to store all the GUIDs.
     * @param {PWSTR} MachineName A pointer to a NULL-terminated string that contains the name of a remote system from which to retrieve the GUIDs. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the local system name is used.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdiclassguidsfromnameexw
     * @since windows5.0
     */
    static SetupDiClassGuidsFromNameExW(ClassName, ClassGuidList, ClassGuidListSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassName := ClassName is String ? StrPtr(ClassName) : ClassName
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassGuidsFromNameExW", "ptr", ClassName, "ptr", ClassGuidList, "uint", ClassGuidListSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileFriendlyName function retrieves the friendly name associated with a hardware profile ID.
     * @param {Integer} HwProfile The hardware profile ID associated with the friendly name to retrieve. If this parameter is 0, the friendly name for the current hardware profile is retrieved.
     * @param {PSTR} FriendlyName A pointer to a string buffer to receive the friendly name.
     * @param {Integer} FriendlyNameSize The size, in characters, of the <i>FriendlyName</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable of type DWORD that receives the number of characters required to retrieve the friendly name (including a NULL terminator).
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigethwprofilefriendlynamea
     * @since windows5.0
     */
    static SetupDiGetHwProfileFriendlyNameA(HwProfile, FriendlyName, FriendlyNameSize, RequiredSize) {
        FriendlyName := FriendlyName is String ? StrPtr(FriendlyName) : FriendlyName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileFriendlyNameA", "uint", HwProfile, "ptr", FriendlyName, "uint", FriendlyNameSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileFriendlyName function retrieves the friendly name associated with a hardware profile ID.
     * @param {Integer} HwProfile The hardware profile ID associated with the friendly name to retrieve. If this parameter is 0, the friendly name for the current hardware profile is retrieved.
     * @param {PWSTR} FriendlyName A pointer to a string buffer to receive the friendly name.
     * @param {Integer} FriendlyNameSize The size, in characters, of the <i>FriendlyName</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable of type DWORD that receives the number of characters required to retrieve the friendly name (including a NULL terminator).
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigethwprofilefriendlynamew
     * @since windows5.0
     */
    static SetupDiGetHwProfileFriendlyNameW(HwProfile, FriendlyName, FriendlyNameSize, RequiredSize) {
        FriendlyName := FriendlyName is String ? StrPtr(FriendlyName) : FriendlyName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileFriendlyNameW", "uint", HwProfile, "ptr", FriendlyName, "uint", FriendlyNameSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileFriendlyNameEx function retrieves the friendly name associated with a hardware profile ID on a local or remote computer.
     * @param {Integer} HwProfile Supplies the hardware profile ID associated with the friendly name to retrieve. If this parameter is 0, the friendly name for the current hardware profile is retrieved.
     * @param {PSTR} FriendlyName A pointer to a character buffer to receive the friendly name.
     * @param {Integer} FriendlyNameSize The size, in characters, of the <i>FriendlyName</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable to receive the number of characters required to store the friendly name (including a NULL terminator). This parameter is optional and can be <b>NULL</b>.
     * @param {PSTR} MachineName A pointer to NULL-terminated string that contains the name of a remote computer on which the hardware profile ID resides. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the hardware profile ID is on the local computer.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigethwprofilefriendlynameexa
     * @since windows5.0
     */
    static SetupDiGetHwProfileFriendlyNameExA(HwProfile, FriendlyName, FriendlyNameSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        FriendlyName := FriendlyName is String ? StrPtr(FriendlyName) : FriendlyName
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileFriendlyNameExA", "uint", HwProfile, "ptr", FriendlyName, "uint", FriendlyNameSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileFriendlyNameEx function retrieves the friendly name associated with a hardware profile ID on a local or remote computer.
     * @param {Integer} HwProfile Supplies the hardware profile ID associated with the friendly name to retrieve. If this parameter is 0, the friendly name for the current hardware profile is retrieved.
     * @param {PWSTR} FriendlyName A pointer to a character buffer to receive the friendly name.
     * @param {Integer} FriendlyNameSize The size, in characters, of the <i>FriendlyName</i> buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable to receive the number of characters required to store the friendly name (including a NULL terminator). This parameter is optional and can be <b>NULL</b>.
     * @param {PWSTR} MachineName A pointer to NULL-terminated string that contains the name of a remote computer on which the hardware profile ID resides. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the hardware profile ID is on the local computer.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigethwprofilefriendlynameexw
     * @since windows5.0
     */
    static SetupDiGetHwProfileFriendlyNameExW(HwProfile, FriendlyName, FriendlyNameSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        FriendlyName := FriendlyName is String ? StrPtr(FriendlyName) : FriendlyName
        MachineName := MachineName is String ? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileFriendlyNameExW", "uint", HwProfile, "ptr", FriendlyName, "uint", FriendlyNameSize, "uint*", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HDEVINFO} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_INSTALLWIZARD_DATA>} InstallWizardData 
     * @param {Integer} PageType 
     * @param {Integer} Flags 
     * @returns {HPROPSHEETPAGE} 
     */
    static SetupDiGetWizardPage(DeviceInfoSet, DeviceInfoData, InstallWizardData, PageType, Flags) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        result := DllCall("SETUPAPI.dll\SetupDiGetWizardPage", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", InstallWizardData, "uint", PageType, "uint", Flags, "ptr")
        return HPROPSHEETPAGE({Value: result}, True)
    }

    /**
     * The SetupDiGetSelectedDevice function retrieves the selected device information element in a device information set.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to retrieve the selected device information element.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that receives information about the selected device information element for <i>DeviceInfoSet</i>. The caller must set <i>DeviceInfoData.</i><b>cbSize</b> to <b>sizeof</b>(SP_DEVINFO_DATA). If a device is currently not selected, the function fails and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_DEVICE_SELECTED.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetselecteddevice
     * @since windows5.0
     */
    static SetupDiGetSelectedDevice(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetSelectedDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetSelectedDevice function sets a device information element as the selected member of a device information set. This function is typically used by an installation wizard.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element to set as the selected member of the device information set.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i> to set as the selected member of <i>DeviceInfoSet</i>.
     * @returns {BOOL} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdisetselecteddevice
     * @since windows5.0
     */
    static SetupDiSetSelectedDevice(DeviceInfoSet, DeviceInfoData) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetSelectedDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualModelsSection function retrieves the appropriate decorated INF Models section to use when installing a device from a device INF file.
     * @param {Pointer<INFCONTEXT>} Context A pointer to an INF file context that specifies a <i>manufacturer-identifier</i> entry in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-manufacturer-section">INF Manufacturer section</a> of an INF file. The <i>manufacturer-identifier</i> entry specifies an INF <i>Models</i> section name and optionally specifies <i>TargetOSVersion</i> decorations for the <i>Models</i> section name. For information about INF files and an INF file context, see the Platform SDK topics on <a href="https://docs.microsoft.com/windows/win32/setupapi/using-inf-files">using INF files</a> and the <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-infcontext">INFCONTEXT structure</a>.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo A pointer to an <a href="https://docs.microsoft.com/previous-versions/windows/hardware/previsioning-framework/ff552338(v=vs.85)">SP_ALTPLATFORM_INFO</a> structure that supplies information about a Windows version and processor architecture. The <b>cbSize</b> member of this structure must be set to <b>sizeof(</b>SP_ALTPLATFORM_INFO_V2<b>)</b>. This parameter is optional and can be set to <b>NULL</b>.
     * @param {PSTR} InfSectionWithExt A pointer to a buffer that receives a string that contains the decorated INF <i>Models</i> section name and a NULL terminator. If <i>AlternatePlatformInfo</i> is not supplied, the decorated INF <i>Models</i> section name applies to the current platform; otherwise the name applies to the specified alternative platform. This parameter is optional and can be set to <b>NULL</b>. If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the decorated <i>Models</i> section name and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the <i>DecoratedModelsSection </i>buffer. If <i>DecoratedModelsSection</i> is <b>NULL</b>, this parameter must be set to zero.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-type variable that receives the size, in characters, of the <i>DecoratedModelsSection</i> buffer that is required to retrieve the decorated <i>Models</i> section name and a terminating NULL character. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {BOOL} <b>SetupDiGetActualModelsSection</b> returns <b>TRUE</b> if the operation succeeds. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetactualmodelssectiona
     */
    static SetupDiGetActualModelsSectionA(Context, AlternatePlatformInfo, InfSectionWithExt, InfSectionWithExtSize, RequiredSize) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionWithExt := InfSectionWithExt is String ? StrPtr(InfSectionWithExt) : InfSectionWithExt

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualModelsSectionA", "ptr", Context, "ptr", AlternatePlatformInfo, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "uint*", RequiredSize, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualModelsSection function retrieves the appropriate decorated INF Models section to use when installing a device from a device INF file.
     * @param {Pointer<INFCONTEXT>} Context A pointer to an INF file context that specifies a <i>manufacturer-identifier</i> entry in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-manufacturer-section">INF Manufacturer section</a> of an INF file. The <i>manufacturer-identifier</i> entry specifies an INF <i>Models</i> section name and optionally specifies <i>TargetOSVersion</i> decorations for the <i>Models</i> section name. For information about INF files and an INF file context, see the Platform SDK topics on <a href="https://docs.microsoft.com/windows/win32/setupapi/using-inf-files">using INF files</a> and the <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-infcontext">INFCONTEXT structure</a>.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo A pointer to an <a href="https://docs.microsoft.com/previous-versions/windows/hardware/previsioning-framework/ff552338(v=vs.85)">SP_ALTPLATFORM_INFO</a> structure that supplies information about a Windows version and processor architecture. The <b>cbSize</b> member of this structure must be set to <b>sizeof(</b>SP_ALTPLATFORM_INFO_V2<b>)</b>. This parameter is optional and can be set to <b>NULL</b>.
     * @param {PWSTR} InfSectionWithExt A pointer to a buffer that receives a string that contains the decorated INF <i>Models</i> section name and a NULL terminator. If <i>AlternatePlatformInfo</i> is not supplied, the decorated INF <i>Models</i> section name applies to the current platform; otherwise the name applies to the specified alternative platform. This parameter is optional and can be set to <b>NULL</b>. If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the decorated <i>Models</i> section name and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the <i>DecoratedModelsSection </i>buffer. If <i>DecoratedModelsSection</i> is <b>NULL</b>, this parameter must be set to zero.
     * @param {Pointer<Integer>} RequiredSize A pointer to a DWORD-type variable that receives the size, in characters, of the <i>DecoratedModelsSection</i> buffer that is required to retrieve the decorated <i>Models</i> section name and a terminating NULL character. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {BOOL} <b>SetupDiGetActualModelsSection</b> returns <b>TRUE</b> if the operation succeeds. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetactualmodelssectionw
     */
    static SetupDiGetActualModelsSectionW(Context, AlternatePlatformInfo, InfSectionWithExt, InfSectionWithExtSize, RequiredSize) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionWithExt := InfSectionWithExt is String ? StrPtr(InfSectionWithExt) : InfSectionWithExt

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualModelsSectionW", "ptr", Context, "ptr", AlternatePlatformInfo, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "uint*", RequiredSize, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} InfHandle 
     * @param {PSTR} InfSectionName 
     * @param {PSTR} InfSectionWithExt 
     * @param {Integer} InfSectionWithExtSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @param {Pointer<PSTR>} Extension 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstalla
     * @since windows5.0
     */
    static SetupDiGetActualSectionToInstallA(InfHandle, InfSectionName, InfSectionWithExt, InfSectionWithExtSize, RequiredSize, Extension) {
        InfSectionName := InfSectionName is String ? StrPtr(InfSectionName) : InfSectionName
        InfSectionWithExt := InfSectionWithExt is String ? StrPtr(InfSectionWithExt) : InfSectionWithExt

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualSectionToInstallA", "ptr", InfHandle, "ptr", InfSectionName, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "uint*", RequiredSize, "ptr", Extension, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} InfHandle 
     * @param {PWSTR} InfSectionName 
     * @param {PWSTR} InfSectionWithExt 
     * @param {Integer} InfSectionWithExtSize 
     * @param {Pointer<Integer>} RequiredSize 
     * @param {Pointer<PWSTR>} Extension 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstallw
     * @since windows5.0
     */
    static SetupDiGetActualSectionToInstallW(InfHandle, InfSectionName, InfSectionWithExt, InfSectionWithExtSize, RequiredSize, Extension) {
        InfSectionName := InfSectionName is String ? StrPtr(InfSectionName) : InfSectionName
        InfSectionWithExt := InfSectionWithExt is String ? StrPtr(InfSectionWithExt) : InfSectionWithExt

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualSectionToInstallW", "ptr", InfHandle, "ptr", InfSectionName, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "uint*", RequiredSize, "ptr", Extension, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualSectionToInstallEx function retrieves the name of the INF DDInstall section that installs a device for a specified operating system and processor architecture.
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <i>DDInstall</i> section.
     * @param {PSTR} InfSectionName A pointer to the <i>DDInstall</i> section name (as specified in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-models-section">INF Models section</a>). The maximum length of the section name, in characters, is 254.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo A pointer, if non-<b>NULL</b>, to an <a href="https://docs.microsoft.com/previous-versions/windows/hardware/previsioning-framework/ff552338(v=vs.85)">SP_ALTPLATFORM_INFO</a> structure. This structure is used to specify an operating system and processor architecture that is different from that on the local computer. To return the <i>DDInstall </i>section name for the local computer, set this parameter to <b>NULL</b>. Otherwise, provide an SP_ALTPLATFORM structure and set its members as follows:
     * @param {PSTR} InfSectionWithExt A pointer to a character buffer to receive the <i>DDInstall</i> section name, its platform extension, and a NULL terminator. This is the decorated section name that should be used for installation.  If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the <i>DDInstall</i> section name, its platform extension, and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the buffer that is pointed to by the <i>InfSectionWithExt</i> parameter. The maximum length of a NULL-terminated INF section name, in characters, is MAX_INF_SECTION_NAME_LENGTH.
     * @param {Pointer<Integer>} RequiredSize A pointer to the variable that receives the size, in characters, that is required to return the <i>DDInstall</i> section name, the platform extension, and a terminating NULL character.
     * @param {Pointer<PSTR>} Extension A pointer to a variable that receives a pointer to the '.' character that marks the start of the extension in the <i>InfSectionWithExt</i> buffer. If the <i>InfSectionWithExt</i> buffer is not supplied or is too small, this parameter is not set. Set this parameter to <b>NULL</b> if a pointer to the extension is not required.
     * @returns {BOOL} If the function is successful, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetactualsectiontoinstallexa
     * @since windows5.1.2600
     */
    static SetupDiGetActualSectionToInstallExA(InfHandle, InfSectionName, AlternatePlatformInfo, InfSectionWithExt, InfSectionWithExtSize, RequiredSize, Extension) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionName := InfSectionName is String ? StrPtr(InfSectionName) : InfSectionName
        InfSectionWithExt := InfSectionWithExt is String ? StrPtr(InfSectionWithExt) : InfSectionWithExt

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualSectionToInstallExA", "ptr", InfHandle, "ptr", InfSectionName, "ptr", AlternatePlatformInfo, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "uint*", RequiredSize, "ptr", Extension, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualSectionToInstallEx function retrieves the name of the INF DDInstall section that installs a device for a specified operating system and processor architecture.
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <i>DDInstall</i> section.
     * @param {PWSTR} InfSectionName A pointer to the <i>DDInstall</i> section name (as specified in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-models-section">INF Models section</a>). The maximum length of the section name, in characters, is 254.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo A pointer, if non-<b>NULL</b>, to an <a href="https://docs.microsoft.com/previous-versions/windows/hardware/previsioning-framework/ff552338(v=vs.85)">SP_ALTPLATFORM_INFO</a> structure. This structure is used to specify an operating system and processor architecture that is different from that on the local computer. To return the <i>DDInstall </i>section name for the local computer, set this parameter to <b>NULL</b>. Otherwise, provide an SP_ALTPLATFORM structure and set its members as follows:
     * @param {PWSTR} InfSectionWithExt A pointer to a character buffer to receive the <i>DDInstall</i> section name, its platform extension, and a NULL terminator. This is the decorated section name that should be used for installation.  If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the <i>DDInstall</i> section name, its platform extension, and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the buffer that is pointed to by the <i>InfSectionWithExt</i> parameter. The maximum length of a NULL-terminated INF section name, in characters, is MAX_INF_SECTION_NAME_LENGTH.
     * @param {Pointer<Integer>} RequiredSize A pointer to the variable that receives the size, in characters, that is required to return the <i>DDInstall</i> section name, the platform extension, and a terminating NULL character.
     * @param {Pointer<PWSTR>} Extension A pointer to a variable that receives a pointer to the '.' character that marks the start of the extension in the <i>InfSectionWithExt</i> buffer. If the <i>InfSectionWithExt</i> buffer is not supplied or is too small, this parameter is not set. Set this parameter to <b>NULL</b> if a pointer to the extension is not required.
     * @returns {BOOL} If the function is successful, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. To get extended error information, call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetactualsectiontoinstallexw
     * @since windows5.1.2600
     */
    static SetupDiGetActualSectionToInstallExW(InfHandle, InfSectionName, AlternatePlatformInfo, InfSectionWithExt, InfSectionWithExtSize, RequiredSize, Extension) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionName := InfSectionName is String ? StrPtr(InfSectionName) : InfSectionName
        InfSectionWithExt := InfSectionWithExt is String ? StrPtr(InfSectionWithExt) : InfSectionWithExt

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualSectionToInstallExW", "ptr", InfHandle, "ptr", InfSectionName, "ptr", AlternatePlatformInfo, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "uint*", RequiredSize, "ptr", Extension, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupEnumInfSections function retrieves section names from an INF file.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that is to be queried.
     * @param {Integer} Index The zero-based index of the section name to retrieve. This index may not correspond to the order of sections as they appear in the INF file.
     * @param {PSTR} Buffer Pointer to a buffer that receives the section name. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the name. Using this technique, you can avoid errors caused by an insufficient buffer size. This parameter is optional. For more information, see the Remarks section.
     * @param {Integer} Size Size of the buffer pointed to by <i>ReturnBuffer</i> in characters. This number includes the terminating <b>NULL</b> character.
     * @param {Pointer<Integer>} SizeNeeded Pointer to a location that receives the required size of the buffer pointed to by <i>ReturnBuffer</i>. The size is specified as the number of characters required to store the section name, including the terminating <b>NULL</b> character.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NO_MORE_ITEMS</b> if the value of <b>EnumerationIndex</b> is greater than or equal to the number of sections names in the INF file.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupenuminfsectionsa
     * @since windows5.1.2600
     */
    static SetupEnumInfSectionsA(InfHandle, Index, Buffer, Size, SizeNeeded) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupEnumInfSectionsA", "ptr", InfHandle, "uint", Index, "ptr", Buffer, "uint", Size, "uint*", SizeNeeded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupEnumInfSections function retrieves section names from an INF file.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that is to be queried.
     * @param {Integer} Index The zero-based index of the section name to retrieve. This index may not correspond to the order of sections as they appear in the INF file.
     * @param {PWSTR} Buffer Pointer to a buffer that receives the section name. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the name. Using this technique, you can avoid errors caused by an insufficient buffer size. This parameter is optional. For more information, see the Remarks section.
     * @param {Integer} Size Size of the buffer pointed to by <i>ReturnBuffer</i> in characters. This number includes the terminating <b>NULL</b> character.
     * @param {Pointer<Integer>} SizeNeeded Pointer to a location that receives the required size of the buffer pointed to by <i>ReturnBuffer</i>. The size is specified as the number of characters required to store the section name, including the terminating <b>NULL</b> character.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NO_MORE_ITEMS</b> if the value of <b>EnumerationIndex</b> is greater than or equal to the number of sections names in the INF file.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupenuminfsectionsw
     * @since windows5.1.2600
     */
    static SetupEnumInfSectionsW(InfHandle, Index, Buffer, Size, SizeNeeded) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupEnumInfSectionsW", "ptr", InfHandle, "uint", Index, "ptr", Buffer, "uint", Size, "uint*", SizeNeeded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupVerifyInfFile function verifies the digital signature of the specified INF file by using its corresponding catalog. The verification can be performed against an alternate platform.
     * @param {PSTR} InfName The name of the INF file to be verified. This name may include a path.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AltPlatformInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO_V2</a> structure that contains information about the alternate platform to use when validating the INF file. This parameter can be Null.
     * @param {Pointer<SP_INF_SIGNER_INFO_V2_A>} InfSignerInfo A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_signer_info_v1_a">SP_INF_SIGNER_INFO</a> structure that receives information about the INF digital signature, that is, if it is signed.
     * @returns {BOOL} This function returns WINSETUPAPI BOOL.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupverifyinffilea
     * @since windows5.1.2600
     */
    static SetupVerifyInfFileA(InfName, AltPlatformInfo, InfSignerInfo) {
        InfName := InfName is String ? StrPtr(InfName) : InfName

        result := DllCall("SETUPAPI.dll\SetupVerifyInfFileA", "ptr", InfName, "ptr", AltPlatformInfo, "ptr", InfSignerInfo, "int")
        return result
    }

    /**
     * The SetupVerifyInfFile function verifies the digital signature of the specified INF file by using its corresponding catalog. The verification can be performed against an alternate platform.
     * @param {PWSTR} InfName The name of the INF file to be verified. This name may include a path.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AltPlatformInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO_V2</a> structure that contains information about the alternate platform to use when validating the INF file. This parameter can be Null.
     * @param {Pointer<SP_INF_SIGNER_INFO_V2_W>} InfSignerInfo A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_signer_info_v1_a">SP_INF_SIGNER_INFO</a> structure that receives information about the INF digital signature, that is, if it is signed.
     * @returns {BOOL} This function returns WINSETUPAPI BOOL.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupverifyinffilew
     * @since windows5.1.2600
     */
    static SetupVerifyInfFileW(InfName, AltPlatformInfo, InfSignerInfo) {
        InfName := InfName is String ? StrPtr(InfName) : InfName

        result := DllCall("SETUPAPI.dll\SetupVerifyInfFileW", "ptr", InfName, "ptr", AltPlatformInfo, "ptr", InfSignerInfo, "int")
        return result
    }

    /**
     * The SetupDiGetCustomDeviceProperty function retrieves a specified custom device property from the registry.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to retrieve a custom device property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {PSTR} CustomPropertyName A registry value name representing a custom property.
     * @param {Integer} Flags A flag value that indicates how the requested information should be returned. The flag can be zero or one of the following:
     * @param {Pointer<Integer>} PropertyRegDataType A pointer to a variable of type DWORD that receives the data type of the retrieved property. The data type is specified as one of the REG_-prefixed constants that represents registry data types. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that receives requested property information.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i>buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable of type DWORD that receives the buffer size, in bytes, that is required to receive the requested information. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetCustomDeviceProperty</b> returns the required size, regardless of whether the <i>PropertyBuffer</i> buffer is large enough to receive the requested information.
     * @returns {BOOL} If the operation succeeds, <b>SetupDiGetCustomDeviceProperty</b> returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the <i>PropertyBuffer </i>buffer is not large enough to receive the requested information, <b>SetupDiGetCustomDeviceProperty</b> returns <b>FALSE</b> and a subsequent call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetcustomdevicepropertya
     * @since windows5.1.2600
     */
    static SetupDiGetCustomDevicePropertyA(DeviceInfoSet, DeviceInfoData, CustomPropertyName, Flags, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        CustomPropertyName := CustomPropertyName is String ? StrPtr(CustomPropertyName) : CustomPropertyName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetCustomDevicePropertyA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", CustomPropertyName, "uint", Flags, "uint*", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetCustomDeviceProperty function retrieves a specified custom device property from the registry.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to retrieve a custom device property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {PWSTR} CustomPropertyName A registry value name representing a custom property.
     * @param {Integer} Flags A flag value that indicates how the requested information should be returned. The flag can be zero or one of the following:
     * @param {Pointer<Integer>} PropertyRegDataType A pointer to a variable of type DWORD that receives the data type of the retrieved property. The data type is specified as one of the REG_-prefixed constants that represents registry data types. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that receives requested property information.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i>buffer.
     * @param {Pointer<Integer>} RequiredSize A pointer to a variable of type DWORD that receives the buffer size, in bytes, that is required to receive the requested information. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetCustomDeviceProperty</b> returns the required size, regardless of whether the <i>PropertyBuffer</i> buffer is large enough to receive the requested information.
     * @returns {BOOL} If the operation succeeds, <b>SetupDiGetCustomDeviceProperty</b> returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the <i>PropertyBuffer </i>buffer is not large enough to receive the requested information, <b>SetupDiGetCustomDeviceProperty</b> returns <b>FALSE</b> and a subsequent call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupdigetcustomdevicepropertyw
     * @since windows5.1.2600
     */
    static SetupDiGetCustomDevicePropertyW(DeviceInfoSet, DeviceInfoData, CustomPropertyName, Flags, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        CustomPropertyName := CustomPropertyName is String ? StrPtr(CustomPropertyName) : CustomPropertyName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetCustomDevicePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", CustomPropertyName, "uint", Flags, "uint*", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint*", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupConfigureWmiFromInfSection function configures the security of the WMI data that is exposed by an INF file when passed to the [DDInstall.WMI] section.
     * @param {Pointer<Void>} InfHandle A handle to an open INF file.
     * @param {PSTR} SectionName Name of the section in the INF file that contains WMI security information. This should be in the form of[DDinstall.WMI].
     * @param {Integer} Flags This parameter can be set as follows.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCWMI_CLOBBER_SECURITY"></a><a id="scwmi_clobber_security"></a><dl>
     * <dt><b>SCWMI_CLOBBER_SECURITY</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If and only if this flag is set does the security information passed to this function override any security information set elsewhere in the INF file. If this flag does not exist and no security information exists in the INF file, the security is set. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} This function returns WINSETUPAPI BOOL.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupconfigurewmifrominfsectiona
     * @since windowsserver2003
     */
    static SetupConfigureWmiFromInfSectionA(InfHandle, SectionName, Flags) {
        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        result := DllCall("SETUPAPI.dll\SetupConfigureWmiFromInfSectionA", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "int")
        return result
    }

    /**
     * The SetupConfigureWmiFromInfSection function configures the security of the WMI data that is exposed by an INF file when passed to the [DDInstall.WMI] section.
     * @param {Pointer<Void>} InfHandle A handle to an open INF file.
     * @param {PWSTR} SectionName Name of the section in the INF file that contains WMI security information. This should be in the form of[DDinstall.WMI].
     * @param {Integer} Flags This parameter can be set as follows.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCWMI_CLOBBER_SECURITY"></a><a id="scwmi_clobber_security"></a><dl>
     * <dt><b>SCWMI_CLOBBER_SECURITY</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If and only if this flag is set does the security information passed to this function override any security information set elsewhere in the INF file. If this flag does not exist and no security information exists in the INF file, the security is set. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} This function returns WINSETUPAPI BOOL.
     * @see https://docs.microsoft.com/windows/win32/api//setupapi/nf-setupapi-setupconfigurewmifrominfsectionw
     * @since windowsserver2003
     */
    static SetupConfigureWmiFromInfSectionW(InfHandle, SectionName, Flags) {
        SectionName := SectionName is String ? StrPtr(SectionName) : SectionName

        result := DllCall("SETUPAPI.dll\SetupConfigureWmiFromInfSectionW", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "int")
        return result
    }

    /**
     * The CM_Add_Empty_Log_Conf function creates an empty logical configuration, for a specified configuration type and a specified device instance, on the local machine.
     * @param {Pointer<Pointer>} plcLogConf Address of a location to receive the handle to an empty logical configuration.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} Priority Caller-supplied configuration priority value. This must be one of the constant values listed in the following table. The constants are listed in order of priority, from highest to lowest. (For multiple configurations with the same <i>ulFlags</i> value, the system will attempt to use the one with the highest priority first.)
     * 
     * <table>
     * <tr>
     * <th>Priority Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_FORCECONFIG
     * 
     * </td>
     * <td>
     * Result of a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">forced configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_BOOTCONFIG
     * 
     * </td>
     * <td>
     * Result of a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">boot configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_DESIRED
     * 
     * </td>
     * <td>
     * Preferred configuration (better performance).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_NORMAL
     * 
     * </td>
     * <td>
     * Workable configuration (acceptable performance).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_LASTBESTCONFIG
     * 
     * </td>
     * <td>
     * <i>For internal use only.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_SUBOPTIMAL
     * 
     * </td>
     * <td>
     * Not a desirable configuration, but it will work.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_LASTSOFTCONFIG
     * 
     * </td>
     * <td>
     * <i>For internal use only.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_RESTART
     * 
     * </td>
     * <td>
     * The system must be restarted
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_REBOOT
     * 
     * </td>
     * <td>
     * The system must be restarted (same as LCPRI_RESTART).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_POWEROFF
     * 
     * </td>
     * <td>
     * The system must be shut down and powered off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_HARDRECONFIG
     * 
     * </td>
     * <td>
     * A jumper must be changed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_HARDWIRED
     * 
     * </td>
     * <td>
     * The configuration cannot be changed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_IMPOSSIBLE
     * 
     * </td>
     * <td>
     * The configuration cannot exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_DISABLED
     * 
     * </td>
     * <td>
     * Disabled configuration.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} ulFlags Caller-supplied flags that specify the type of the logical configuration. One of the following flags must be specified.
     * 
     * <table>
     * <tr>
     * <th>Configuration Type Flags</th>
     * <th>Definitions</th>
     * </tr>
     * <tr>
     * <td>
     * BASIC_LOG_CONF
     * 
     * </td>
     * <td>
     * Resource descriptors added to this configuration will describe a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">basic configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * FILTERED_LOG_CONF
     * 
     * </td>
     * <td>
     * <i>Do not use.</i> (Only the PnP manager can create a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">filtered configuration</a>.)
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * ALLOC_LOG_CONF
     * 
     * </td>
     * <td>
     * <i>Do not use.</i> (Only the PnP manager can create an <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">allocated configuration</a>.)
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * BOOT_LOG_CONF
     * 
     * </td>
     * <td>
     * Resource descriptors added to this configuration will describe a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">boot configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * FORCED_LOG_CONF
     * 
     * </td>
     * <td>
     * Resource descriptors added to this configuration will describe a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">forced configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * OVERRIDE_LOG_CONF
     * 
     * </td>
     * <td>
     * Resource descriptors added to this configuration will describe an <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">override configuration</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * One of the following bit flags can be ORed with the configuration type flag.
     * 
     * <table>
     * <tr>
     * <th>Priority Comparison Flags</th>
     * <th>Definitions</th>
     * </tr>
     * <tr>
     * <td>
     * PRIORITY_EQUAL_FIRST
     * 
     * </td>
     * <td>
     * If multiple configurations of the same type (<i>ulFlags</i>) have the same priority (<i>Priority</i>), this configuration is placed at the head of the list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * PRIORITY_EQUAL_LAST
     * 
     * </td>
     * <td>
     * (Default) If multiple configurations of the same type (<i>ulFlags</i>) have the same priority (<i>Priority</i>), this configuration is placed at the tail of the list.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Add_Empty_Log_Conf</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf
     * @since windows5.0
     */
    static CM_Add_Empty_Log_Conf(plcLogConf, dnDevInst, Priority, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Add_Empty_Log_Conf", "ptr*", plcLogConf, "uint", dnDevInst, "int", Priority, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_Empty_Log_Conf_Ex function creates an empty logical configuration, for a specified configuration type and a specified device instance, on either the local or a remote machine.
     * @param {Pointer<Pointer>} plcLogConf Pointer to a location to receive the handle to an empty logical configuration.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} Priority Caller-supplied configuration priority value. For a list of values, see the <i>Priority</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>.
     * @param {Integer} ulFlags Caller-supplied flags that specify the type of the logical configuration. For a list of flags, see the description <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Add_Empty_Log_Conf_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex
     * @since windows5.0
     */
    static CM_Add_Empty_Log_Conf_Ex(plcLogConf, dnDevInst, Priority, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Add_Empty_Log_Conf_Ex", "ptr*", plcLogConf, "uint", dnDevInst, "int", Priority, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Add_ID function appends a specified device ID (if not already present) to a device instance's hardware ID list or compatible ID list.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {PSTR} pszID Caller-supplied pointer to a NULL-terminated device ID string.
     * @param {Integer} ulFlags Caller-supplied flag constant that specifies the list onto which the supplied device ID should be appended. The following flag constants are valid.
     * 
     * <table>
     * <tr>
     * <th>Flag Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_COMPATIBLE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's compatible ID list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_HARDWARE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's hardware ID list.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_add_ida
     */
    static CM_Add_IDA(dnDevInst, pszID, ulFlags) {
        pszID := pszID is String ? StrPtr(pszID) : pszID

        result := DllCall("CFGMGR32.dll\CM_Add_IDA", "uint", dnDevInst, "ptr", pszID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_ID function appends a specified device ID (if not already present) to a device instance'shardware ID list or compatible ID list.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {PWSTR} pszID Caller-supplied pointer to a NULL-terminated device ID string.
     * @param {Integer} ulFlags Caller-supplied flag constant that specifies the list onto which the supplied device ID should be appended. The following flag constants are valid.
     * 
     * <table>
     * <tr>
     * <th>Flag Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_COMPATIBLE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's compatible ID list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_HARDWARE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's hardware ID list.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_add_idw
     * @since windows5.0
     */
    static CM_Add_IDW(dnDevInst, pszID, ulFlags) {
        pszID := pszID is String ? StrPtr(pszID) : pszID

        result := DllCall("CFGMGR32.dll\CM_Add_IDW", "uint", dnDevInst, "ptr", pszID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_ID_Ex function appends a device ID (if not already present) to a device instance's hardware ID list or compatible ID list, on either the local or a remote machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {PSTR} pszID Caller-supplied pointer to a NULL-terminated device ID string.
     * @param {Integer} ulFlags Caller-supplied flag constant that specifies the list onto which the supplied device ID should be appended. The following flag constants are valid.
     * 
     * <table>
     * <tr>
     * <th>Flag Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_COMPATIBLE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's compatible ID list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_HARDWARE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's hardware ID list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_add_id_exa
     */
    static CM_Add_ID_ExA(dnDevInst, pszID, ulFlags, hMachine) {
        pszID := pszID is String ? StrPtr(pszID) : pszID

        result := DllCall("CFGMGR32.dll\CM_Add_ID_ExA", "uint", dnDevInst, "ptr", pszID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Add_ID_Ex function appends a device ID (if not already present) to a device instance's hardware ID list or compatible ID list, on either the local or a remote machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by 
     * 
     * <i>hMachine</i>
     * 
     * .
     * @param {PWSTR} pszID Caller-supplied pointer to a NULL-terminated device ID string.
     * @param {Integer} ulFlags Caller-supplied flag constant that specifies the list onto which the supplied device ID should be appended. The following flag constants are valid.
     * 
     * <table>
     * <tr>
     * <th>Flag Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_COMPATIBLE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's compatible ID list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_HARDWARE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's hardware ID list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_add_id_exw
     * @since windows5.0
     */
    static CM_Add_ID_ExW(dnDevInst, pszID, ulFlags, hMachine) {
        pszID := pszID is String ? StrPtr(pszID) : pszID

        result := DllCall("CFGMGR32.dll\CM_Add_ID_ExW", "uint", dnDevInst, "ptr", pszID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ullStartValue 
     * @param {Integer} ullEndValue 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_range
     */
    static CM_Add_Range(ullStartValue, ullEndValue, rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Add_Range", "uint", ullStartValue, "uint", ullEndValue, "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_Res_Des function adds a resource descriptor to a logical configuration.
     * @param {Pointer<Pointer>} prdResDes Pointer to a location to receive a handle to the new resource descriptor.
     * @param {Pointer} lcLogConf Caller-supplied handle to the logical configuration to which the resource descriptor should be added. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Integer} ResourceID Caller-supplied resource type identifier, which identifies the type of structure supplied by <i>ResourceData</i>. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer} ResourceData Caller-supplied pointer to one of the resource structures listed in the following table.
     * 
     * <table>
     * <tr>
     * <th><i>ResourceID </i>Parameter</th>
     * <th>Resource Structure</th>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_BusNumber</b>
     * 
     * </td>
     * <td>
     * 
     * [BUSNUMBER_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-busnumber_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_ClassSpecific</b>
     * 
     * </td>
     * <td>
     * 
     * [CS_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-cs_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_DevicePrivate</b>
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devprivate-resource">DEVPRIVATE_RESOURCE</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_DMA</b>
     * 
     * </td>
     * <td>
     * 
     * [DMA_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-dma_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_IO</b>
     * 
     * </td>
     * <td>
     * 
     * [IO_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-io_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_IRQ</b>
     * 
     * </td>
     * <td>
     * 
     * [IRQ_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-irq_resource_32)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_Mem</b>
     * 
     * </td>
     * <td>
     * 
     * [MEM_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-mem_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_MfCardConfig</b>
     * 
     * </td>
     * <td>
     * 
     * [MFCARD_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-mfcard_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_PcCardConfig</b>
     * 
     * </td>
     * <td>
     * 
     * [PCCARD_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-pccard_resource)
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8,  <b>CM_Add_Res_Des</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_add_res_des
     * @since windows5.0
     */
    static CM_Add_Res_Des(prdResDes, lcLogConf, ResourceID, ResourceData, ResourceLen, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Add_Res_Des", "ptr*", prdResDes, "ptr", lcLogConf, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_Res_Des_Ex function adds a resource descriptor to a logical configuration. The logical configuration can be on either the local or a remote machine.
     * @param {Pointer<Pointer>} prdResDes Pointer to a location to receive a handle to the new resource descriptor.
     * @param {Pointer} lcLogConf Caller-supplied handle to the logical configuration to which the resource descriptor should be added. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Integer} ResourceID Caller-supplied resource type identifier, which identifies the type of structure supplied by <i>ResourceData</i>. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer} ResourceData Caller-supplied pointer to one of the resource structures listed in the following table.
     * 
     * <table>
     * <tr>
     * <th><i>ResourceID </i>Parameter</th>
     * <th>Resource Structure</th>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_BusNumber</b>
     * 
     * </td>
     * <td>
     * 
     * [BUSNUMBER_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-busnumber_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_ClassSpecific</b>
     * 
     * </td>
     * <td>
     * 
     * [CS_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-cs_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_DevicePrivate</b>
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devprivate-resource">DEVPRIVATE_RESOURCE</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_DMA</b>
     * 
     * </td>
     * <td>
     * 
     * [DMA_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-dma_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_IO</b>
     * 
     * </td>
     * <td>
     * 
     * [IO_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-io_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_IRQ</b>
     * 
     * </td>
     * <td>
     * 
     * [IRQ_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-irq_resource_32)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_Mem</b>
     * 
     * </td>
     * <td>
     * 
     * [MEM_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-mem_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_MfCardConfig</b>
     * 
     * </td>
     * <td>
     * 
     * [MFCARD_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-mfcard_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_PcCardConfig</b>
     * 
     * </td>
     * <td>
     * 
     * [PCCARD_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-pccard_resource)
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>, or <b>NULL</b>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Add_Res_Des_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex
     * @since windows5.0
     */
    static CM_Add_Res_Des_Ex(prdResDes, lcLogConf, ResourceID, ResourceData, ResourceLen, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Add_Res_Des_Ex", "ptr*", prdResDes, "ptr", lcLogConf, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Connect_Machine function creates a connection to a remote machine.
     * @param {PSTR} UNCServerName Caller-supplied pointer to a text string representing the UNC name, including the <b>\\</b> prefix, of the system for which a connection will be made. If the pointer is <b>NULL</b>, the local system is used.
     * @param {Pointer<Pointer>} phMachine Address of a location to receive a machine handle.
     * 
     * <div class="alert"><b>Note</b> Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_connect_machinea
     */
    static CM_Connect_MachineA(UNCServerName, phMachine) {
        UNCServerName := UNCServerName is String ? StrPtr(UNCServerName) : UNCServerName

        result := DllCall("CFGMGR32.dll\CM_Connect_MachineA", "ptr", UNCServerName, "ptr*", phMachine, "uint")
        return result
    }

    /**
     * The CM_Connect_Machine function creates a connection to a remote machine.
     * @param {PWSTR} UNCServerName Caller-supplied pointer to a text string representing the UNC name, including the <b>\\</b> prefix, of the system for which a connection will be made. If the pointer is <b>NULL</b>, the local system is used.
     * @param {Pointer<Pointer>} phMachine Address of a location to receive a machine handle.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_connect_machinew
     * @since windows5.0
     */
    static CM_Connect_MachineW(UNCServerName, phMachine) {
        UNCServerName := UNCServerName is String ? StrPtr(UNCServerName) : UNCServerName

        result := DllCall("CFGMGR32.dll\CM_Connect_MachineW", "ptr", UNCServerName, "ptr*", phMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pdnDevInst 
     * @param {PSTR} pDeviceID 
     * @param {Integer} dnParent 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_devnodea
     */
    static CM_Create_DevNodeA(pdnDevInst, pDeviceID, dnParent, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Create_DevNodeA", "uint*", pdnDevInst, "ptr", pDeviceID, "uint", dnParent, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pdnDevInst 
     * @param {PWSTR} pDeviceID 
     * @param {Integer} dnParent 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_devnodew
     */
    static CM_Create_DevNodeW(pdnDevInst, pDeviceID, dnParent, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Create_DevNodeW", "uint*", pdnDevInst, "ptr", pDeviceID, "uint", dnParent, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pdnDevInst 
     * @param {PSTR} pDeviceID 
     * @param {Integer} dnParent 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_devnode_exa
     */
    static CM_Create_DevNode_ExA(pdnDevInst, pDeviceID, dnParent, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Create_DevNode_ExA", "uint*", pdnDevInst, "ptr", pDeviceID, "uint", dnParent, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pdnDevInst 
     * @param {PWSTR} pDeviceID 
     * @param {Integer} dnParent 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_devnode_exw
     */
    static CM_Create_DevNode_ExW(pdnDevInst, pDeviceID, dnParent, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Create_DevNode_ExW", "uint*", pdnDevInst, "ptr", pDeviceID, "uint", dnParent, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer>} prlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_range_list
     */
    static CM_Create_Range_List(prlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Create_Range_List", "ptr*", prlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Delete_Class_Key function removes the specified installed device class from the system.
     * @param {Pointer<Guid>} ClassGuid Pointer to the GUID of the device class to remove.
     * @param {Integer} ulFlags Delete class key flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_delete_class_key
     * @since windows5.0
     */
    static CM_Delete_Class_Key(ClassGuid, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Delete_Class_Key", "ptr", ClassGuid, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_class_key_ex
     */
    static CM_Delete_Class_Key_Ex(ClassGuid, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Delete_Class_Key_Ex", "ptr", ClassGuid, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Delete_DevNode_Key function deletes the specified user-accessible registry keys that are associated with a device.
     * @param {Integer} dnDevNode Device instance handle that is bound to the local machine.
     * @param {Integer} ulHardwareProfile The hardware profile to delete if <i>ulFlags</i> includes CM_REGISTRY_CONFIG. If this value is zero, the key for the current hardware profile is deleted. If this value is 0xFFFFFFFF, the registry keys for all hardware profiles are deleted.
     * @param {Integer} ulFlags Delete device node key flags. Indicates the scope and type of registry storage key to delete.  Can be a combination of the following flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_delete_devnode_key
     * @since windows5.0
     */
    static CM_Delete_DevNode_Key(dnDevNode, ulHardwareProfile, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Delete_DevNode_Key", "uint", dnDevNode, "uint", ulHardwareProfile, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevNode 
     * @param {Integer} ulHardwareProfile 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_devnode_key_ex
     */
    static CM_Delete_DevNode_Key_Ex(dnDevNode, ulHardwareProfile, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Delete_DevNode_Key_Ex", "uint", dnDevNode, "uint", ulHardwareProfile, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ullStartValue 
     * @param {Integer} ullEndValue 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_range
     */
    static CM_Delete_Range(ullStartValue, ullEndValue, rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Delete_Range", "uint", ullStartValue, "uint", ullEndValue, "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Pointer} ResourceData 
     * @param {Integer} ResourceLen 
     * @param {Pointer<BOOL>} pbConflictDetected 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_detect_resource_conflict
     */
    static CM_Detect_Resource_Conflict(dnDevInst, ResourceID, ResourceData, ResourceLen, pbConflictDetected, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Detect_Resource_Conflict", "uint", dnDevInst, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "ptr", pbConflictDetected, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Pointer} ResourceData 
     * @param {Integer} ResourceLen 
     * @param {Pointer<BOOL>} pbConflictDetected 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_detect_resource_conflict_ex
     */
    static CM_Detect_Resource_Conflict_Ex(dnDevInst, ResourceID, ResourceData, ResourceLen, pbConflictDetected, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Detect_Resource_Conflict_Ex", "uint", dnDevInst, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "ptr", pbConflictDetected, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Disable_DevNode function disables a device.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Disable flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_disable_devnode
     * @since windows5.0
     */
    static CM_Disable_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Disable_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_disable_devnode_ex
     */
    static CM_Disable_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Disable_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Disconnect_Machine function removes a connection to a remote machine.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_disconnect_machine
     * @since windows5.0
     */
    static CM_Disconnect_Machine(hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Disconnect_Machine", "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlhOld 
     * @param {Pointer} rlhNew 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_dup_range_list
     */
    static CM_Dup_Range_List(rlhOld, rlhNew, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Dup_Range_List", "ptr", rlhOld, "ptr", rlhNew, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Enable_DevNode function enables a device.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_enable_devnode
     * @since windows5.0
     */
    static CM_Enable_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Enable_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enable_devnode_ex
     */
    static CM_Enable_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Enable_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Classes function, when called repeatedly, enumerates the local machine's installed device classes by supplying each class's GUID.
     * @param {Integer} ulClassIndex Caller-supplied index into the machine's list of device classes. For more information, see the <b>Remarks</b> section.
     * @param {Pointer<Guid>} ClassGuid Caller-supplied address of a GUID structure (described in the Microsoft Windows SDK) to receive a device class's GUID.
     * @param {Integer} ulFlags Beginning with Windows8, callers can specify the following flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_enumerate_classes
     * @since windows5.0
     */
    static CM_Enumerate_Classes(ulClassIndex, ClassGuid, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Enumerate_Classes", "uint", ulClassIndex, "ptr", ClassGuid, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Classes_Ex function, when called repeatedly, enumerates a local or a remote machine's installed device classes, by supplying each class's GUID.
     * @param {Integer} ulClassIndex Caller-supplied index into the machine's list of device classes. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<Guid>} ClassGuid Caller-supplied address of a GUID structure (described in the Microsoft Windows SDK) to receive a device class's GUID.
     * @param {Integer} ulFlags Beginning with Windows8, callers can specify the following flags:
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_enumerate_classes_ex
     * @since windows5.0
     */
    static CM_Enumerate_Classes_Ex(ulClassIndex, ClassGuid, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Enumerate_Classes_Ex", "uint", ulClassIndex, "ptr", ClassGuid, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Enumerators function enumerates the local machine's device enumerators by supplying each enumerator's name.
     * @param {Integer} ulEnumIndex Caller-supplied index into the machine's list of device enumerators. For more information, see the following <b>Remarks</b> section.
     * @param {PSTR} Buffer Address of a buffer to receive an enumerator name. This buffer should be MAX_DEVICE_ID_LEN-sized (or, set <i>Buffer</i> to zero and obtain the actual name length in the location referenced by <i>puLength</i>).
     * @param {Pointer<Integer>} pulLength Caller-supplied address of a location to hold the buffer size. The caller supplies the length of the buffer pointed to by <i>Buffer</i>. The function replaces this value with the actual size of the enumerator's name string. If the caller-supplied buffer length is too small, the function supplies the required buffer size and returns CR_BUFFER_SMALL.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_enumerate_enumeratorsa
     */
    static CM_Enumerate_EnumeratorsA(ulEnumIndex, Buffer, pulLength, ulFlags) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Enumerate_EnumeratorsA", "uint", ulEnumIndex, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Enumerators function enumerates the local machine's device enumerators by supplying each enumerator's name.
     * @param {Integer} ulEnumIndex Caller-supplied index into the machine's list of device enumerators. For more information, see the following <b>Remarks</b> section.
     * @param {PWSTR} Buffer Address of a buffer to receive an enumerator name. This buffer should be MAX_DEVICE_ID_LEN-sized (or, set <i>Buffer</i> to zero and obtain the actual name length in the location referenced by <i>puLength</i>).
     * @param {Pointer<Integer>} pulLength Caller-supplied address of a location to hold the buffer size. The caller supplies the length of the buffer pointed to by <i>Buffer</i>. The function replaces this value with the actual size of the enumerator's name string. If the caller-supplied buffer length is too small, the function supplies the required buffer size and returns CR_BUFFER_SMALL.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_enumerate_enumeratorsw
     * @since windows5.0
     */
    static CM_Enumerate_EnumeratorsW(ulEnumIndex, Buffer, pulLength, ulFlags) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Enumerate_EnumeratorsW", "uint", ulEnumIndex, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Enumerators_Ex function enumerates a local or a remote machine's device enumerators, by supplying each enumerator's name.
     * @param {Integer} ulEnumIndex Caller-supplied index into the machine's list of device enumerators. For more information, see the following <b>Remarks</b> section.
     * @param {PSTR} Buffer Address of a buffer to receive an enumerator name. This buffer should be MAX_DEVICE_ID_LEN-sized (or, set <i>Buffer</i> to zero and obtain the actual name length in the location referenced by <b>puLength</b>).
     * @param {Pointer<Integer>} pulLength Caller-supplied address of a location to hold the buffer size. The caller supplies the length of the buffer pointed to by <i>Buffer</i>. The function replaces this value with the actual size of the enumerator's name string. If the caller-supplied buffer length is too small, the function supplies the required buffer size and returns CR_BUFFER_SMALL.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_enumerate_enumerators_exa
     */
    static CM_Enumerate_Enumerators_ExA(ulEnumIndex, Buffer, pulLength, ulFlags, hMachine) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Enumerate_Enumerators_ExA", "uint", ulEnumIndex, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Enumerators_Ex function enumerates a local or a remote machine's device enumerators, by supplying each enumerator's name.
     * @param {Integer} ulEnumIndex Caller-supplied index into the machine's list of device enumerators. For more information, see the following <b>Remarks</b> section.
     * @param {PWSTR} Buffer Address of a buffer to receive an enumerator name. This buffer should be MAX_DEVICE_ID_LEN-sized (or, set <i>Buffer</i> to zero and obtain the actual name length in the location referenced by <b>puLength</b>).
     * @param {Pointer<Integer>} pulLength Caller-supplied address of a location to hold the buffer size. The caller supplies the length of the buffer pointed to by <i>Buffer</i>. The function replaces this value with the actual size of the enumerator's name string. If the caller-supplied buffer length is too small, the function supplies the required buffer size and returns CR_BUFFER_SMALL.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_enumerate_enumerators_exw
     * @since windows5.0
     */
    static CM_Enumerate_Enumerators_ExW(ulEnumIndex, Buffer, pulLength, ulFlags, hMachine) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Enumerate_Enumerators_ExW", "uint", ulEnumIndex, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pullStart 
     * @param {Integer} ullStart 
     * @param {Integer} ulLength 
     * @param {Integer} ullAlignment 
     * @param {Integer} ullEnd 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_find_range
     */
    static CM_Find_Range(pullStart, ullStart, ulLength, ullAlignment, ullEnd, rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Find_Range", "uint*", pullStart, "uint", ullStart, "uint", ulLength, "uint", ullAlignment, "uint", ullEnd, "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlh 
     * @param {Pointer<Integer>} pullStart 
     * @param {Pointer<Integer>} pullEnd 
     * @param {Pointer<Pointer>} preElement 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_first_range
     */
    static CM_First_Range(rlh, pullStart, pullEnd, preElement, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_First_Range", "ptr", rlh, "uint*", pullStart, "uint*", pullEnd, "ptr*", preElement, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Free_Log_Conf function removes a logical configuration and all associated resource descriptors from the local machine.
     * @param {Pointer} lcLogConfToBeFreed Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Free_Log_Conf</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_free_log_conf
     * @since windows5.0
     */
    static CM_Free_Log_Conf(lcLogConfToBeFreed, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Free_Log_Conf", "ptr", lcLogConfToBeFreed, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Free_Log_Conf_Ex function removes a logical configuration and all associated resource descriptors from either a local or a remote machine.
     * @param {Pointer} lcLogConfToBeFreed Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Free_Log_Conf_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_free_log_conf_ex
     * @since windows5.0
     */
    static CM_Free_Log_Conf_Ex(lcLogConfToBeFreed, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Free_Log_Conf_Ex", "ptr", lcLogConfToBeFreed, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Free_Log_Conf_Handle function invalidates a logical configuration handle and frees its associated memory allocation.
     * @param {Pointer} lcLogConf Caller-supplied logical configuration handle. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_free_log_conf_handle
     * @since windows5.0
     */
    static CM_Free_Log_Conf_Handle(lcLogConf) {
        result := DllCall("CFGMGR32.dll\CM_Free_Log_Conf_Handle", "ptr", lcLogConf, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_range_list
     */
    static CM_Free_Range_List(rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Free_Range_List", "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Free_Res_Des function removes a resource descriptor from a logical configuration on the local machine.
     * @param {Pointer<Pointer>} prdResDes Caller-supplied location to receive a handle to the configuration's previous resource descriptor. This parameter can be <b>NULL</b>. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer} rdResDes Caller-supplied handle to the resource descriptor to be removed. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Free_Res_Des</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_free_res_des
     * @since windows5.0
     */
    static CM_Free_Res_Des(prdResDes, rdResDes, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Free_Res_Des", "ptr*", prdResDes, "ptr", rdResDes, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Free_Res_Des_Ex function removes a resource descriptor from a logical configuration on either a local or a remote machine.
     * @param {Pointer<Pointer>} prdResDes Caller-supplied location to receive a handle to the configuration's previous resource descriptor. This parameter can be <b>NULL</b>. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer} rdResDes Caller-supplied handle to the resource descriptor to be removed. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Free_Res_Des_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_free_res_des_ex
     * @since windows5.0
     */
    static CM_Free_Res_Des_Ex(prdResDes, rdResDes, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Free_Res_Des_Ex", "ptr*", prdResDes, "ptr", rdResDes, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Free_Res_Des_Handle function invalidates a resource description handle and frees its associated memory allocation.
     * @param {Pointer} rdResDes Caller-supplied resource descriptor handle to be freed. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_free_res_des_handle
     * @since windows5.0
     */
    static CM_Free_Res_Des_Handle(rdResDes) {
        result := DllCall("CFGMGR32.dll\CM_Free_Res_Des_Handle", "ptr", rdResDes, "uint")
        return result
    }

    /**
     * The CM_Get_Child function is used to retrieve a device instance handle to the first child node of a specified device node (devnode) in the local machine's device tree.
     * @param {Pointer<Integer>} pdnDevInst Caller-supplied pointer to the device instance handle to the child node that this function retrieves. The retrieved handle is bound to the local machine. See the <b>Remarks</b> section.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_child
     * @since windows5.0
     */
    static CM_Get_Child(pdnDevInst, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Child", "uint*", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Child_Ex function is used to retrieve a device instance handle to the first child node of a specified device node (devnode) in a local or a remote machine's device tree.
     * @param {Pointer<Integer>} pdnDevInst Caller-supplied pointer to the device instance handle to the child node that this function retrieves. The retrieved handle is bound to the machine handle supplied by <i>hMachine</i>. See the <b>Remarks</b> section.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_child_ex
     * @since windows5.0
     */
    static CM_Get_Child_Ex(pdnDevInst, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Child_Ex", "uint*", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PSTR} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_namea
     */
    static CM_Get_Class_NameA(ClassGuid, Buffer, pulLength, ulFlags) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Class_NameA", "ptr", ClassGuid, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PWSTR} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_namew
     */
    static CM_Get_Class_NameW(ClassGuid, Buffer, pulLength, ulFlags) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Class_NameW", "ptr", ClassGuid, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PSTR} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_name_exa
     */
    static CM_Get_Class_Name_ExA(ClassGuid, Buffer, pulLength, ulFlags, hMachine) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Name_ExA", "ptr", ClassGuid, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PWSTR} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_name_exw
     */
    static CM_Get_Class_Name_ExW(ClassGuid, Buffer, pulLength, ulFlags, hMachine) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Name_ExW", "ptr", ClassGuid, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PSTR} pszKeyName 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_key_namea
     */
    static CM_Get_Class_Key_NameA(ClassGuid, pszKeyName, pulLength, ulFlags) {
        pszKeyName := pszKeyName is String ? StrPtr(pszKeyName) : pszKeyName

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Key_NameA", "ptr", ClassGuid, "ptr", pszKeyName, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PWSTR} pszKeyName 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_key_namew
     */
    static CM_Get_Class_Key_NameW(ClassGuid, pszKeyName, pulLength, ulFlags) {
        pszKeyName := pszKeyName is String ? StrPtr(pszKeyName) : pszKeyName

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Key_NameW", "ptr", ClassGuid, "ptr", pszKeyName, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PSTR} pszKeyName 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_key_name_exa
     */
    static CM_Get_Class_Key_Name_ExA(ClassGuid, pszKeyName, pulLength, ulFlags, hMachine) {
        pszKeyName := pszKeyName is String ? StrPtr(pszKeyName) : pszKeyName

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Key_Name_ExA", "ptr", ClassGuid, "ptr", pszKeyName, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PWSTR} pszKeyName 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_key_name_exw
     */
    static CM_Get_Class_Key_Name_ExW(ClassGuid, pszKeyName, pulLength, ulFlags, hMachine) {
        pszKeyName := pszKeyName is String ? StrPtr(pszKeyName) : pszKeyName

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Key_Name_ExW", "ptr", ClassGuid, "ptr", pszKeyName, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Depth function is used to obtain the depth of a specified device node (devnode) within the local machine's device tree.
     * @param {Pointer<Integer>} pulDepth Caller-supplied address of a location to receive a depth value, where zero represents the device tree's root node, one represents the root node's children, and so on.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_depth
     * @since windows5.0
     */
    static CM_Get_Depth(pulDepth, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Depth", "uint*", pulDepth, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Depth_Ex function is used to obtain the depth of a specified device node (devnode) within a local or a remote machine's device tree.
     * @param {Pointer<Integer>} pulDepth Caller-supplied address of a location to receive a depth value, where zero represents the device tree's root node, one represents the root node's children, and so on.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_depth_ex
     * @since windows5.0
     */
    static CM_Get_Depth_Ex(pulDepth, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Depth_Ex", "uint*", pulDepth, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID function retrieves the device instance ID for a specified device instance on the local machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {PSTR} Buffer Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size">CM_Get_Device_ID_Size</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_ida
     */
    static CM_Get_Device_IDA(dnDevInst, Buffer, BufferLen, ulFlags) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_IDA", "uint", dnDevInst, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID function retrieves the device instance ID for a specified device instance on the local machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {PWSTR} Buffer Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size">CM_Get_Device_ID_Size</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_idw
     * @since windows5.0
     */
    static CM_Get_Device_IDW(dnDevInst, Buffer, BufferLen, ulFlags) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_IDW", "uint", dnDevInst, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_Ex function retrieves the device instance ID for a specified device instance on a local or a remote machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {PSTR} Buffer Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size_ex">CM_Get_Device_ID_Size_Ex</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_exa
     */
    static CM_Get_Device_ID_ExA(dnDevInst, Buffer, BufferLen, ulFlags, hMachine) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_ExA", "uint", dnDevInst, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_Ex function retrieves the device instance ID for a specified device instance on a local or a remote machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {PWSTR} Buffer Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size_ex">CM_Get_Device_ID_Size_Ex</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_exw
     * @since windows5.0
     */
    static CM_Get_Device_ID_ExW(dnDevInst, Buffer, BufferLen, ulFlags, hMachine) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_ExW", "uint", dnDevInst, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List function retrieves a list of device instance IDs for the local computer's device instances.
     * @param {PSTR} pszFilter Caller-supplied pointer to a character string that is either set to a subset of the computer's device instance identifiers (IDs), or to <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {PSTR} Buffer Address of a buffer to receive a set of NULL-terminated device instance identifier strings. The end of the set is terminated by an extra <b>NULL</b>. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_sizea">CM_Get_Device_ID_List_Size</a>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags One of the following caller-supplied bit flags that specifies search filters:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista
     * @since windows5.0
     */
    static CM_Get_Device_ID_ListA(pszFilter, Buffer, BufferLen, ulFlags) {
        pszFilter := pszFilter is String ? StrPtr(pszFilter) : pszFilter
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_ListA", "ptr", pszFilter, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List function retrieves a list of device instance IDs for the local computer's device instances.
     * @param {PWSTR} pszFilter Caller-supplied pointer to a character string that is either set to a subset of the computer's device instance identifiers (IDs), or to <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {PWSTR} Buffer Address of a buffer to receive a set of NULL-terminated device instance identifier strings. The end of the set is terminated by an extra <b>NULL</b>. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_sizea">CM_Get_Device_ID_List_Size</a>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags One of the following caller-supplied bit flags that specifies search filters:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_listw
     * @since windows5.0
     */
    static CM_Get_Device_ID_ListW(pszFilter, Buffer, BufferLen, ulFlags) {
        pszFilter := pszFilter is String ? StrPtr(pszFilter) : pszFilter
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_ListW", "ptr", pszFilter, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Ex function retrieves a list of device instance IDs for the device instances on a local or a remote machine.
     * @param {PSTR} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {PSTR} Buffer Address of a buffer to receive a set of NULL-terminated device instance identifier strings. The end of the set is terminated by an extra <b>NULL</b>. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_size_exa">CM_Get_Device_ID_List_Size_Ex</a>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exa
     */
    static CM_Get_Device_ID_List_ExA(pszFilter, Buffer, BufferLen, ulFlags, hMachine) {
        pszFilter := pszFilter is String ? StrPtr(pszFilter) : pszFilter
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_ExA", "ptr", pszFilter, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Ex function retrieves a list of device instance IDs for the device instances on a local or a remote machine.
     * @param {PWSTR} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {PWSTR} Buffer Address of a buffer to receive a set of NULL-terminated device instance identifier strings. The end of the set is terminated by an extra <b>NULL</b>. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_size_exw">CM_Get_Device_ID_List_Size_Ex</a>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exw
     * @since windows5.0
     */
    static CM_Get_Device_ID_List_ExW(pszFilter, Buffer, BufferLen, ulFlags, hMachine) {
        pszFilter := pszFilter is String ? StrPtr(pszFilter) : pszFilter
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_ExW", "ptr", pszFilter, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Size function retrieves the buffer size required to hold a list of device instance IDs for the local machine's device instances.
     * @param {Pointer<Integer>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {PSTR} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies the buffer size required to hold all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_sizea
     * @since windows5.0
     */
    static CM_Get_Device_ID_List_SizeA(pulLen, pszFilter, ulFlags) {
        pszFilter := pszFilter is String ? StrPtr(pszFilter) : pszFilter

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_SizeA", "uint*", pulLen, "ptr", pszFilter, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Size function retrieves the buffer size required to hold a list of device instance IDs for the local machine's device instances.
     * @param {Pointer<Integer>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {PWSTR} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies the buffer size required to hold all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_sizew
     * @since windows5.0
     */
    static CM_Get_Device_ID_List_SizeW(pulLen, pszFilter, ulFlags) {
        pszFilter := pszFilter is String ? StrPtr(pszFilter) : pszFilter

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_SizeW", "uint*", pulLen, "ptr", pszFilter, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Size_Ex function retrieves the buffer size required to hold a list of device instance IDs for a local or a remote machine's device instances.
     * @param {Pointer<Integer>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {PSTR} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies the buffer size required to hold all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exa">CM_Get_Device_ID_List_Ex</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_size_exa
     */
    static CM_Get_Device_ID_List_Size_ExA(pulLen, pszFilter, ulFlags, hMachine) {
        pszFilter := pszFilter is String ? StrPtr(pszFilter) : pszFilter

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_Size_ExA", "uint*", pulLen, "ptr", pszFilter, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Size_Ex function retrieves the buffer size required to hold a list of device instance IDs for a local or a remote machine's device instances.
     * @param {Pointer<Integer>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {PWSTR} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies the buffer size required to hold all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exw">CM_Get_Device_ID_List_Ex</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_size_exw
     * @since windows5.0
     */
    static CM_Get_Device_ID_List_Size_ExW(pulLen, pszFilter, ulFlags, hMachine) {
        pszFilter := pszFilter is String ? StrPtr(pszFilter) : pszFilter

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_Size_ExW", "uint*", pulLen, "ptr", pszFilter, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_Size function retrieves the buffer size required to hold a device instance ID for a device instance on the local machine.
     * @param {Pointer<Integer>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_size
     * @since windows5.0
     */
    static CM_Get_Device_ID_Size(pulLen, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_Size", "uint*", pulLen, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_Size_Ex function retrieves the buffer size required to hold a device instance ID for a device instance on a local or a remote machine.
     * @param {Pointer<Integer>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_id_size_ex
     * @since windows5.0
     */
    static CM_Get_Device_ID_Size_Ex(pulLen, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_Size_Ex", "uint*", pulLen, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Property function retrieves a device instance property.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device instance property.
     * @param {Pointer<Integer>} PropertyType Pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device instance property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that receives the requested device instance property. <b>CM_Get_DevNode_Property</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<Integer>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_DevNode_Property</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_devnode_propertyw
     * @since windows6.0.6000
     */
    static CM_Get_DevNode_PropertyW(dnDevInst, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_PropertyW", "uint", dnDevInst, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint*", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Property_ExW function retrieves a device instance property.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device instance property.
     * @param {Pointer<Integer>} PropertyType Pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device instance property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that receives the requested device instance property. <b>CM_Get_DevNode_Property_ExW</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<Integer>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_DevNode_Property_ExW</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_devnode_property_exw
     * @since windows10.0.10240
     */
    static CM_Get_DevNode_Property_ExW(dnDevInst, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Property_ExW", "uint", dnDevInst, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint*", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Property_Keys function retrieves an array of the device property keys that represent the device properties that are set for a device instance.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device instance. The pointer is optional and can be NULL.
     * @param {Pointer<Integer>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero. As output, If <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_DevNode_Property_Keys</b> returns the count of the keys in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_devnode_property_keys
     * @since windows6.0.6000
     */
    static CM_Get_DevNode_Property_Keys(dnDevInst, PropertyKeyArray, PropertyKeyCount, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Property_Keys", "uint", dnDevInst, "ptr", PropertyKeyArray, "uint*", PropertyKeyCount, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Property_Keys_Ex function retrieves an array of the device property keys that represent the device properties that are set for a device instance.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device instance. The pointer is optional and can be NULL.
     * @param {Pointer<Integer>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero. As output, If <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_DevNode_Property_Keys_Ex</b> returns the count of the keys in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_devnode_property_keys_ex
     * @since windows10.0.10240
     */
    static CM_Get_DevNode_Property_Keys_Ex(dnDevInst, PropertyKeyArray, PropertyKeyCount, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Property_Keys_Ex", "uint", dnDevInst, "ptr", PropertyKeyArray, "uint*", PropertyKeyCount, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Registry_Property function retrieves a specified device property from the registry.
     * @param {Integer} dnDevInst A caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProperty A CM_DRP_-prefixed constant value that identifies the device property to be obtained from the registry. These constants are defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Integer>} pulRegDataType Optional, can be <b>NULL</b>. A pointer to a location that receives the registry data type, specified as a REG_-prefixed constant defined in <i>Winnt.h</i>.
     * @param {Pointer} Buffer Optional, can be <b>NULL</b>. A pointer to a caller-supplied buffer that receives the requested device property. If this value is <b>NULL</b>, the function supplies only the length of the requested data in the address pointed to by <i>pulLength</i>.
     * @param {Pointer<Integer>} pulLength A pointer to a ULONG variable into which the function stores the length, in bytes, of the requested device property.
     * 
     * If the <i>Buffer</i> parameter is set to <b>NULL</b>, the ULONG variable must be set to zero.
     * 
     * If the <i>Buffer</i> parameter is not set to <b>NULL</b>, the ULONG variable must be set to the length, in bytes, of the caller-supplied buffer.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_devnode_registry_propertya
     */
    static CM_Get_DevNode_Registry_PropertyA(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Registry_PropertyA", "uint", dnDevInst, "uint", ulProperty, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Registry_Property function retrieves a specified device property from the registry.
     * @param {Integer} dnDevInst A caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProperty A CM_DRP_-prefixed constant value that identifies the device property to be obtained from the registry. These constants are defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Integer>} pulRegDataType Optional, can be <b>NULL</b>. A pointer to a location that receives the registry data type, specified as a REG_-prefixed constant defined in <i>Winnt.h</i>.
     * @param {Pointer} Buffer Optional, can be <b>NULL</b>. A pointer to a caller-supplied buffer that receives the requested device property. If this value is <b>NULL</b>, the function supplies only the length of the requested data in the address pointed to by <i>pulLength</i>.
     * @param {Pointer<Integer>} pulLength A pointer to a ULONG variable into which the function stores the length, in bytes, of the requested device property.
     * 
     * If the <i>Buffer</i> parameter is set to <b>NULL</b>, the ULONG variable must be set to zero.
     * 
     * If the <i>Buffer</i> parameter is not set to <b>NULL</b>, the ULONG variable must be set to the length, in bytes, of the caller-supplied buffer.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_devnode_registry_propertyw
     * @since windows5.0
     */
    static CM_Get_DevNode_Registry_PropertyW(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Registry_PropertyW", "uint", dnDevInst, "uint", ulProperty, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulProperty 
     * @param {Pointer<Integer>} pulRegDataType 
     * @param {Pointer} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_registry_property_exa
     */
    static CM_Get_DevNode_Registry_Property_ExA(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Registry_Property_ExA", "uint", dnDevInst, "uint", ulProperty, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulProperty 
     * @param {Pointer<Integer>} pulRegDataType 
     * @param {Pointer} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_registry_property_exw
     */
    static CM_Get_DevNode_Registry_Property_ExW(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Registry_Property_ExW", "uint", dnDevInst, "uint", ulProperty, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {PSTR} pszCustomPropertyName 
     * @param {Pointer<Integer>} pulRegDataType 
     * @param {Pointer} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_custom_propertya
     */
    static CM_Get_DevNode_Custom_PropertyA(dnDevInst, pszCustomPropertyName, pulRegDataType, Buffer, pulLength, ulFlags) {
        pszCustomPropertyName := pszCustomPropertyName is String ? StrPtr(pszCustomPropertyName) : pszCustomPropertyName

        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Custom_PropertyA", "uint", dnDevInst, "ptr", pszCustomPropertyName, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {PWSTR} pszCustomPropertyName 
     * @param {Pointer<Integer>} pulRegDataType 
     * @param {Pointer} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_custom_propertyw
     */
    static CM_Get_DevNode_Custom_PropertyW(dnDevInst, pszCustomPropertyName, pulRegDataType, Buffer, pulLength, ulFlags) {
        pszCustomPropertyName := pszCustomPropertyName is String ? StrPtr(pszCustomPropertyName) : pszCustomPropertyName

        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Custom_PropertyW", "uint", dnDevInst, "ptr", pszCustomPropertyName, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {PSTR} pszCustomPropertyName 
     * @param {Pointer<Integer>} pulRegDataType 
     * @param {Pointer} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_custom_property_exa
     */
    static CM_Get_DevNode_Custom_Property_ExA(dnDevInst, pszCustomPropertyName, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        pszCustomPropertyName := pszCustomPropertyName is String ? StrPtr(pszCustomPropertyName) : pszCustomPropertyName

        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Custom_Property_ExA", "uint", dnDevInst, "ptr", pszCustomPropertyName, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {PWSTR} pszCustomPropertyName 
     * @param {Pointer<Integer>} pulRegDataType 
     * @param {Pointer} Buffer 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_custom_property_exw
     */
    static CM_Get_DevNode_Custom_Property_ExW(dnDevInst, pszCustomPropertyName, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        pszCustomPropertyName := pszCustomPropertyName is String ? StrPtr(pszCustomPropertyName) : pszCustomPropertyName

        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Custom_Property_ExW", "uint", dnDevInst, "ptr", pszCustomPropertyName, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Status function obtains the status of a device instance from its device node (devnode) in the local machine's device tree.
     * @param {Pointer<Integer>} pulStatus Address of a location to receive status bit flags. The function can set any combination of the <b>DN_-</b>prefixed bit flags defined in <i>Cfg.h</i>.
     * @param {Pointer<Integer>} pulProblemNumber Address of a location to receive one of the <b>CM_PROB_</b>-prefixed problem values defined in <i>Cfg.h</i>. Used only if DN_HAS_PROBLEM is set in <i>pulStatus</i>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_devnode_status
     * @since windows5.0
     */
    static CM_Get_DevNode_Status(pulStatus, pulProblemNumber, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Status", "uint*", pulStatus, "uint*", pulProblemNumber, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Status_Ex function obtains the status of a device instance from its device node (devnode) on a local or a remote machine's device tree.
     * @param {Pointer<Integer>} pulStatus Address of a location to receive status bit flags. The function can set any combination of the DN_-prefixed bit flags defined in <i>Cfg.h</i>.
     * @param {Pointer<Integer>} pulProblemNumber Address of a location to receive one of the CM_PROB_-prefixed problem values defined in <i>Cfg.h</i>. Used only if DN_HAS_PROBLEM is set in <i>pulStatus</i>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_devnode_status_ex
     * @since windows5.0
     */
    static CM_Get_DevNode_Status_Ex(pulStatus, pulProblemNumber, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Status_Ex", "uint*", pulStatus, "uint*", pulProblemNumber, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_First_Log_Conf function obtains the first logical configuration, of a specified configuration type, associated with a specified device instance on the local machine.
     * @param {Pointer<Pointer>} plcLogConf Address of a location to receive the handle to a logical configuration, or <b>NULL</b>. See the following <b>Remarks</b> section.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Caller-supplied flag value indicating the type of logical configuration being requested. One of the flags in the following table must be specified.
     * 
     * <table>
     * <tr>
     * <th>Configuration Type Flags</th>
     * <th>Definitions</th>
     * </tr>
     * <tr>
     * <td>
     * BASIC_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">basic configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * FILTERED_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">filtered configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * ALLOC_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">allocated configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * BOOT_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">boot configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * FORCED_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">forced configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * OVERRIDE_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">override configuration</a> information.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_First_Log_Conf</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf
     * @since windows5.0
     */
    static CM_Get_First_Log_Conf(plcLogConf, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_First_Log_Conf", "ptr*", plcLogConf, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_First_Log_Conf_Ex function obtains the first logical configuration associated with a specified device instance on a local or a remote machine.
     * @param {Pointer<Pointer>} plcLogConf Address of a location to receive the handle to a logical configuration, or <b>NULL</b>. See the <b>Remarks</b> section.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Caller-supplied flag value indicating the type of logical configuration being requested. For a list of flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_First_Log_Conf_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex
     * @since windows5.0
     */
    static CM_Get_First_Log_Conf_Ex(plcLogConf, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_First_Log_Conf_Ex", "ptr*", plcLogConf, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pulState 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_global_state
     */
    static CM_Get_Global_State(pulState, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Global_State", "uint*", pulState, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pulState 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_global_state_ex
     */
    static CM_Get_Global_State_Ex(pulState, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Global_State_Ex", "uint*", pulState, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulIndex 
     * @param {Pointer<HWPROFILEINFO_A>} pHWProfileInfo 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hardware_profile_infoa
     */
    static CM_Get_Hardware_Profile_InfoA(ulIndex, pHWProfileInfo, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Hardware_Profile_InfoA", "uint", ulIndex, "ptr", pHWProfileInfo, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulIndex 
     * @param {Pointer<HWPROFILEINFO_A>} pHWProfileInfo 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hardware_profile_info_exa
     */
    static CM_Get_Hardware_Profile_Info_ExA(ulIndex, pHWProfileInfo, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Hardware_Profile_Info_ExA", "uint", ulIndex, "ptr", pHWProfileInfo, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulIndex 
     * @param {Pointer<HWPROFILEINFO_W>} pHWProfileInfo 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hardware_profile_infow
     */
    static CM_Get_Hardware_Profile_InfoW(ulIndex, pHWProfileInfo, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Hardware_Profile_InfoW", "uint", ulIndex, "ptr", pHWProfileInfo, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulIndex 
     * @param {Pointer<HWPROFILEINFO_W>} pHWProfileInfo 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hardware_profile_info_exw
     */
    static CM_Get_Hardware_Profile_Info_ExW(ulIndex, pHWProfileInfo, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Hardware_Profile_Info_ExW", "uint", ulIndex, "ptr", pHWProfileInfo, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_HW_Prof_Flags function retrieves the hardware profile-specific configuration flags for a device instance on a local machine.
     * @param {PSTR} pDeviceID Pointer to a NULL-terminated string that contains the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> of the device for which to retrieve hardware profile-specific configuration flags.
     * @param {Integer} ulHardwareProfile A variable of ULONG type that specifies the identifier of the hardware profile for which to retrieve configuration flags. If this parameter is zero, this function retrieves the configuration flags for the current hardware profile.
     * @param {Pointer<Integer>} pulValue Pointer to a caller-supplied variable of ULONG type that receives zero or a bitwise OR of the following configuration flags that are defined in <i>Regstr.h</i>:
     * @param {Integer} ulFlags Reserved for internal use. Must be set to zero.
     * @returns {Integer} If the operation succeeds, <b>CM_Get_HW_Prof_Flags</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flagsa
     * @since windows5.0
     */
    static CM_Get_HW_Prof_FlagsA(pDeviceID, ulHardwareProfile, pulValue, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_HW_Prof_FlagsA", "ptr", pDeviceID, "uint", ulHardwareProfile, "uint*", pulValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_HW_Prof_Flags function retrieves the hardware profile-specific configuration flags for a device instance on a local machine.
     * @param {PWSTR} pDeviceID Pointer to a NULL-terminated string that contains the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> of the device for which to retrieve hardware profile-specific configuration flags.
     * @param {Integer} ulHardwareProfile A variable of ULONG type that specifies the identifier of the hardware profile for which to retrieve configuration flags. If this parameter is zero, this function retrieves the configuration flags for the current hardware profile.
     * @param {Pointer<Integer>} pulValue Pointer to a caller-supplied variable of ULONG type that receives zero or a bitwise OR of the following configuration flags that are defined in <i>Regstr.h</i>:
     * @param {Integer} ulFlags Reserved for internal use. Must be set to zero.
     * @returns {Integer} If the operation succeeds, <b>CM_Get_HW_Prof_Flags</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flagsw
     * @since windows5.0
     */
    static CM_Get_HW_Prof_FlagsW(pDeviceID, ulHardwareProfile, pulValue, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_HW_Prof_FlagsW", "ptr", pDeviceID, "uint", ulHardwareProfile, "uint*", pulValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_HW_Prof_Flags_Ex function retrieves the hardware profile-specific configuration flags for a device instance on a remote machine or a local machine.
     * @param {PSTR} pDeviceID Pointer to a NULL-terminated string that contains the device instance ID of the device for which to retrieve hardware profile-specific configuration flags.
     * @param {Integer} ulHardwareProfile A variable of ULONG type that specifies the identifier of the hardware profile for which to retrieve configuration flags. If this parameter is zero, this function retrieves the configuration flags for the current hardware profile.
     * @param {Pointer<Integer>} pulValue Pointer to a caller-supplied variable of ULONG type that receives zero or a bitwise OR of the following configuration flags that are defined in <i>Regstr.h</i>:
     * @param {Integer} ulFlags Reserved for internal use. Must be set to zero.
     * @param {Pointer} hMachine A machine handle that is returned by call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a> or <b>NULL</b>. If this parameter is set to <b>NULL</b>, <b>CM_Get_HW_Prof_Flags_Ex</b> retrieves the configuration flags on the local machine.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, <b>CM_Get_HW_Prof_Flags</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flags_exa
     * @since windows5.0
     */
    static CM_Get_HW_Prof_Flags_ExA(pDeviceID, ulHardwareProfile, pulValue, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_HW_Prof_Flags_ExA", "ptr", pDeviceID, "uint", ulHardwareProfile, "uint*", pulValue, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_HW_Prof_Flags_Ex function retrieves the hardware profile-specific configuration flags for a device instance on a remote machine or a local machine.
     * @param {PWSTR} pDeviceID Pointer to a NULL-terminated string that contains the device instance ID of the device for which to retrieve hardware profile-specific configuration flags.
     * @param {Integer} ulHardwareProfile A variable of ULONG type that specifies the identifier of the hardware profile for which to retrieve configuration flags. If this parameter is zero, this function retrieves the configuration flags for the current hardware profile.
     * @param {Pointer<Integer>} pulValue Pointer to a caller-supplied variable of ULONG type that receives zero or a bitwise OR of the following configuration flags that are defined in <i>Regstr.h</i>:
     * @param {Integer} ulFlags Reserved for internal use. Must be set to zero.
     * @param {Pointer} hMachine A machine handle that is returned by call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a> or <b>NULL</b>. If this parameter is set to <b>NULL</b>, <b>CM_Get_HW_Prof_Flags_Ex</b> retrieves the configuration flags on the local machine.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, <b>CM_Get_HW_Prof_Flags</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flags_exw
     * @since windows5.0
     */
    static CM_Get_HW_Prof_Flags_ExW(pDeviceID, ulHardwareProfile, pulValue, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_HW_Prof_Flags_ExW", "ptr", pDeviceID, "uint", ulHardwareProfile, "uint*", pulValue, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Alias function returns the alias of the specified device interface instance, if the alias exists.
     * @param {PSTR} pszDeviceInterface Pointer to the name of the device interface instance for which to retrieve an alias. The caller typically received this string from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_lista">CM_Get_Device_Interface_List</a>, or in a PnP notification structure.
     * @param {Pointer<Guid>} AliasInterfaceGuid Pointer to a GUID specifying the interface class of the alias to retrieve.
     * @param {PSTR} pszAliasDeviceInterface Specifies a pointer to a buffer, that upon successful return, points to a string containing the name of the alias. The caller must free this string when it is no longer needed.
     * 
     * A buffer is required.  Otherwise, the call will fail.
     * @param {Pointer<Integer>} pulLength Supplies the count of characters in <i>pszAliasDeviceInterface</i> and receives the number of characters required to hold the alias device interface.
     * 
     * On input, this parameter must be greater than 0.
     * @param {Integer} ulFlags Reserved. Do not use.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Possibly indicates that there is no alias of the specified interface class.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is not enough memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_BUFFER_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer passed is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_aliasa
     */
    static CM_Get_Device_Interface_AliasA(pszDeviceInterface, AliasInterfaceGuid, pszAliasDeviceInterface, pulLength, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface
        pszAliasDeviceInterface := pszAliasDeviceInterface is String ? StrPtr(pszAliasDeviceInterface) : pszAliasDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_AliasA", "ptr", pszDeviceInterface, "ptr", AliasInterfaceGuid, "ptr", pszAliasDeviceInterface, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Alias function returns the alias of the specified device interface instance, if the alias exists.
     * @param {PWSTR} pszDeviceInterface Pointer to the name of the device interface instance for which to retrieve an alias. The caller typically received this string from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_lista">CM_Get_Device_Interface_List</a>, or in a PnP notification structure.
     * @param {Pointer<Guid>} AliasInterfaceGuid Pointer to a GUID specifying the interface class of the alias to retrieve.
     * @param {PWSTR} pszAliasDeviceInterface Specifies a pointer to a buffer, that upon successful return, points to a string containing the name of the alias. The caller must free this string when it is no longer needed.
     * 
     * A buffer is required.  Otherwise, the call will fail.
     * @param {Pointer<Integer>} pulLength Supplies the count of characters in <i>pszAliasDeviceInterface</i>          and receives the number of characters required to hold the alias device interface.
     * 
     * On input, this parameter must be greater than 0.
     * @param {Integer} ulFlags Reserved. Do not use.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Possibly indicates that there is no alias of the specified interface class.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is not enough memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_BUFFER_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer passed is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_aliasw
     * @since windows5.0
     */
    static CM_Get_Device_Interface_AliasW(pszDeviceInterface, AliasInterfaceGuid, pszAliasDeviceInterface, pulLength, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface
        pszAliasDeviceInterface := pszAliasDeviceInterface is String ? StrPtr(pszAliasDeviceInterface) : pszAliasDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_AliasW", "ptr", pszDeviceInterface, "ptr", AliasInterfaceGuid, "ptr", pszAliasDeviceInterface, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {PSTR} pszDeviceInterface 
     * @param {Pointer<Guid>} AliasInterfaceGuid 
     * @param {PSTR} pszAliasDeviceInterface 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_alias_exa
     */
    static CM_Get_Device_Interface_Alias_ExA(pszDeviceInterface, AliasInterfaceGuid, pszAliasDeviceInterface, pulLength, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface
        pszAliasDeviceInterface := pszAliasDeviceInterface is String ? StrPtr(pszAliasDeviceInterface) : pszAliasDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Alias_ExA", "ptr", pszDeviceInterface, "ptr", AliasInterfaceGuid, "ptr", pszAliasDeviceInterface, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszDeviceInterface 
     * @param {Pointer<Guid>} AliasInterfaceGuid 
     * @param {PWSTR} pszAliasDeviceInterface 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_alias_exw
     */
    static CM_Get_Device_Interface_Alias_ExW(pszDeviceInterface, AliasInterfaceGuid, pszAliasDeviceInterface, pulLength, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface
        pszAliasDeviceInterface := pszAliasDeviceInterface is String ? StrPtr(pszAliasDeviceInterface) : pszAliasDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Alias_ExW", "ptr", pszDeviceInterface, "ptr", AliasInterfaceGuid, "ptr", pszAliasDeviceInterface, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_List function retrieves a list of device interface instances that belong to a specified device interface class.
     * @param {Pointer<Guid>} InterfaceClassGuid Supplies a GUID that identifies a device interface class.
     * @param {PSTR} pDeviceID Caller-supplied pointer to a NULL-terminated string that represents a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the function retrieves device interfaces that are supported by the device for the specified class. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves all interfaces that belong to the specified class.
     * @param {PSTR} Buffer Caller-supplied pointer to a buffer that receives multiple, NULL-terminated Unicode strings, each representing the symbolic link name of an interface instance.
     * @param {Integer} BufferLen Caller-supplied value that specifies the length, in characters, of the buffer pointed to by <i>Buffer</i>. Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea">CM_Get_Device_Interface_List_Size</a> to determine the required buffer size.
     * @param {Integer} ulFlags Contains one of the following caller-supplied flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the error codes with the CR_ prefix as defined in <i>Cfgmgr32.h</i>.
     * 
     * The following table includes some of the more common error codes that this function might return.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_BUFFER_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Buffer</i> buffer is too small to hold the requested list of device interfaces.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_lista
     * @since windows5.0
     */
    static CM_Get_Device_Interface_ListA(InterfaceClassGuid, pDeviceID, Buffer, BufferLen, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_ListA", "ptr", InterfaceClassGuid, "ptr", pDeviceID, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_List function retrieves a list of device interface instances that belong to a specified device interface class.
     * @param {Pointer<Guid>} InterfaceClassGuid Supplies a GUID that identifies a device interface class.
     * @param {PWSTR} pDeviceID Caller-supplied pointer to a NULL-terminated string that represents a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the function retrieves device interfaces that are supported by the device for the specified class. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves all interfaces that belong to the specified class.
     * @param {PWSTR} Buffer Caller-supplied pointer to a buffer that receives multiple, NULL-terminated Unicode strings, each representing the symbolic link name of an interface instance.
     * @param {Integer} BufferLen Caller-supplied value that specifies the length, in characters, of the buffer pointed to by <i>Buffer</i>. Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea">CM_Get_Device_Interface_List_Size</a> to determine the required buffer size.
     * @param {Integer} ulFlags Contains one of the following caller-supplied flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the error codes with the CR_ prefix as defined in <i>Cfgmgr32.h</i>.
     * 
     * The following table includes some of the more common error codes that this function might return.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_BUFFER_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Buffer</i> buffer is too small to hold the requested list of device interfaces.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_listw
     * @since windows5.0
     */
    static CM_Get_Device_Interface_ListW(InterfaceClassGuid, pDeviceID, Buffer, BufferLen, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_ListW", "ptr", InterfaceClassGuid, "ptr", pDeviceID, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PSTR} pDeviceID 
     * @param {PSTR} Buffer 
     * @param {Integer} BufferLen 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_exa
     */
    static CM_Get_Device_Interface_List_ExA(InterfaceClassGuid, pDeviceID, Buffer, BufferLen, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_ExA", "ptr", InterfaceClassGuid, "ptr", pDeviceID, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PWSTR} pDeviceID 
     * @param {PWSTR} Buffer 
     * @param {Integer} BufferLen 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_exw
     */
    static CM_Get_Device_Interface_List_ExW(InterfaceClassGuid, pDeviceID, Buffer, BufferLen, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_ExW", "ptr", InterfaceClassGuid, "ptr", pDeviceID, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_List_Size function retrieves the buffer size that must be passed to the CM_Get_Device_Interface_List function.
     * @param {Pointer<Integer>} pulLen Caller-supplied pointer to a location that receives the required length, in characters, of a buffer to 
     *            hold the multiple Unicode strings that will be returned by 
     *            <b>CM_Get_Device_Interface_List</b>.
     * @param {Pointer<Guid>} InterfaceClassGuid Supplies a GUID that identifies a 
     *            <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a>.
     * @param {PSTR} pDeviceID Caller-supplied pointer to a NULL-terminated string that represents a 
     *            <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the 
     *            function retrieves the length of symbolic link names for the device interfaces that are supported by the 
     *            device, for the specified class. If this value is <b>NULL</b>, or if it points to a 
     *            zero-length string, the function retrieves the length of symbolic link names for all interfaces that belong 
     *            to the specified class.
     * @param {Integer} ulFlags Contains one of the following caller-supplied flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES"></a><a id="cm_get_device_interface_list_all_devices"></a><dl>
     * <dt><b>CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function provides the size of a list that contains device interfaces associated with all devices 
     *              that match the specified <b>GUID</b> and device instance ID, if any.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CM_GET_DEVICE_INTERFACE_LIST_PRESENT"></a><a id="cm_get_device_interface_list_present"></a><dl>
     * <dt><b>CM_GET_DEVICE_INTERFACE_LIST_PRESENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function provides the size of a list containing device interfaces associated with devices that 
     *              are currently active, and which match the specified GUID and device instance ID, if any.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns <b>CR_SUCCESS</b>. Otherwise, it 
     *            returns one of the error codes with the <b>CR_</b> prefix as defined in 
     *            Cfgmgr32.h.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea
     * @since windows5.0
     */
    static CM_Get_Device_Interface_List_SizeA(pulLen, InterfaceClassGuid, pDeviceID, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_SizeA", "uint*", pulLen, "ptr", InterfaceClassGuid, "ptr", pDeviceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_List_Size function retrieves the buffer size that must be passed to the CM_Get_Device_Interface_List function.
     * @param {Pointer<Integer>} pulLen Caller-supplied pointer to a location that receives the required length, in characters, of a buffer to 
     *            hold the multiple Unicode strings that will be returned by 
     *            <b>CM_Get_Device_Interface_List</b>.
     * @param {Pointer<Guid>} InterfaceClassGuid Supplies a GUID that identifies a 
     *            <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a>.
     * @param {PWSTR} pDeviceID Caller-supplied pointer to a NULL-terminated string that represents a 
     *            <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the 
     *            function retrieves the length of symbolic link names for the device interfaces that are supported by the 
     *            device, for the specified class. If this value is <b>NULL</b>, or if it points to a 
     *            zero-length string, the function retrieves the length of symbolic link names for all interfaces that belong 
     *            to the specified class.
     * @param {Integer} ulFlags Contains one of the following caller-supplied flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES"></a><a id="cm_get_device_interface_list_all_devices"></a><dl>
     * <dt><b>CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function provides the size of a list that contains device interfaces associated with all devices 
     *              that match the specified <b>GUID</b> and device instance ID, if any.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CM_GET_DEVICE_INTERFACE_LIST_PRESENT"></a><a id="cm_get_device_interface_list_present"></a><dl>
     * <dt><b>CM_GET_DEVICE_INTERFACE_LIST_PRESENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function provides the size of a list containing device interfaces associated with devices that 
     *              are currently active, and which match the specified GUID and device instance ID, if any.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns <b>CR_SUCCESS</b>. Otherwise, it 
     *            returns one of the error codes with the <b>CR_</b> prefix as defined in 
     *            Cfgmgr32.h.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizew
     * @since windows5.0
     */
    static CM_Get_Device_Interface_List_SizeW(pulLen, InterfaceClassGuid, pDeviceID, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_SizeW", "uint*", pulLen, "ptr", InterfaceClassGuid, "ptr", pDeviceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pulLen 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PSTR} pDeviceID 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_size_exa
     */
    static CM_Get_Device_Interface_List_Size_ExA(pulLen, InterfaceClassGuid, pDeviceID, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_Size_ExA", "uint*", pulLen, "ptr", InterfaceClassGuid, "ptr", pDeviceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pulLen 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PWSTR} pDeviceID 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_size_exw
     */
    static CM_Get_Device_Interface_List_Size_ExW(pulLen, InterfaceClassGuid, pDeviceID, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_Size_ExW", "uint*", pulLen, "ptr", InterfaceClassGuid, "ptr", pDeviceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Property function retrieves a device property that is set for a device interface.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance to retrieve the property from.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device interface property key of the device interface property to retrieve.
     * @param {Pointer<Integer>} PropertyType Pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device interface property. The property-data-type identifier is a bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that receives the requested device interface property. <b>CM_Get_Device_Interface_Property</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<Integer>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Device_Interface_Property</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_propertyw
     * @since windows6.0.6000
     */
    static CM_Get_Device_Interface_PropertyW(pszDeviceInterface, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_PropertyW", "ptr", pszDeviceInterface, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint*", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Property_ExW function retrieves a device property that is set for a device interface.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance to retrieve the property from.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device interface property key of the device interface property to retrieve.
     * @param {Pointer<Integer>} PropertyType Pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device interface property. The property-data-type identifier is a bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer A pointer to a buffer that receives the requested device interface property. <b>CM_Get_Device_Interface_Property_ExW</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<Integer>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Device_Interface_Property_ExW</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_property_exw
     * @since windows10.0.10240
     */
    static CM_Get_Device_Interface_Property_ExW(pszDeviceInterface, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Property_ExW", "ptr", pszDeviceInterface, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint*", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Property_Keys function retrieves an array of device property keys that represent the device properties that are set for a device interface.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance to retrieve the property keys from.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device interface. The pointer is optional and can be NULL
     * @param {Pointer<Integer>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero.  As output, if <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_Device_Interface_Property_Keys</b> returns the count of the keys, in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_property_keysw
     * @since windows6.0.6000
     */
    static CM_Get_Device_Interface_Property_KeysW(pszDeviceInterface, PropertyKeyArray, PropertyKeyCount, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Property_KeysW", "ptr", pszDeviceInterface, "ptr", PropertyKeyArray, "uint*", PropertyKeyCount, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Property_Keys_ExW function retrieves an array of device property keys that represent the device properties that are set for a device interface.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance to retrieve the property keys from.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device interface. The pointer is optional and can be NULL
     * @param {Pointer<Integer>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero.  As output, if <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_Device_Interface_Property_Keys_ExW</b> returns the count of the keys, in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_device_interface_property_keys_exw
     * @since windows10.0.10240
     */
    static CM_Get_Device_Interface_Property_Keys_ExW(pszDeviceInterface, PropertyKeyArray, PropertyKeyCount, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Property_Keys_ExW", "ptr", pszDeviceInterface, "ptr", PropertyKeyArray, "uint*", PropertyKeyCount, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Log_Conf_Priority function obtains the configuration priority of a specified logical configuration on the local machine.
     * @param {Pointer} lcLogConf Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Pointer<Integer>} pPriority Caller-supplied address of a location to receive a configuration priority value. For a list of priority values, see the description of <i>Priority</i> for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Log_Conf_Priority</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_log_conf_priority
     * @since windows5.0
     */
    static CM_Get_Log_Conf_Priority(lcLogConf, pPriority, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Log_Conf_Priority", "ptr", lcLogConf, "uint*", pPriority, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Log_Conf_Priority_Ex function obtains the configuration priority of a specified logical configuration on a local or a remote machine.
     * @param {Pointer} lcLogConf Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Pointer<Integer>} pPriority Caller-supplied address of a location to receive a configuration priority value. For a list of priority values, see the description of <i>Priority</i> for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Log_Conf_Priority_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_log_conf_priority_ex
     * @since windows5.0
     */
    static CM_Get_Log_Conf_Priority_Ex(lcLogConf, pPriority, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Log_Conf_Priority_Ex", "ptr", lcLogConf, "uint*", pPriority, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Next_Log_Conf function obtains the next logical configuration associated with a specific device instance on the local machine.
     * @param {Pointer<Pointer>} plcLogConf Address of a location to receive the handle to a logical configuration, or <b>NULL</b>. (See the following <b>Remarks</b> section.
     * @param {Pointer} lcLogConf Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * <b>CM_Get_Next_Log_Conf</b>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Next_Log_Conf</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf
     * @since windows5.0
     */
    static CM_Get_Next_Log_Conf(plcLogConf, lcLogConf) {
        static ulFlags := 0 ;Reserved parameters must always be NULL

        result := DllCall("CFGMGR32.dll\CM_Get_Next_Log_Conf", "ptr*", plcLogConf, "ptr", lcLogConf, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Next_Log_Conf_Ex function obtains the next logical configuration associated with a specific device instance on a local or a remote machine.
     * @param {Pointer<Pointer>} plcLogConf Address of a location to receive the handle to a logical configuration, or <b>NULL</b>. (See the following <b>Remarks</b> section.
     * @param {Pointer} lcLogConf Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * <b>CM_Get_Next_Log_Conf_Ex</b>
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Next_Log_Conf_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex
     * @since windows5.0
     */
    static CM_Get_Next_Log_Conf_Ex(plcLogConf, lcLogConf, hMachine) {
        static ulFlags := 0 ;Reserved parameters must always be NULL

        result := DllCall("CFGMGR32.dll\CM_Get_Next_Log_Conf_Ex", "ptr*", plcLogConf, "ptr", lcLogConf, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Parent function obtains a device instance handle to the parent node of a specified device node (devnode) in the local machine's device tree.
     * @param {Pointer<Integer>} pdnDevInst Caller-supplied pointer to the device instance handle to the parent node that this function retrieves. The retrieved handle is bound to the local machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_parent
     * @since windows5.0
     */
    static CM_Get_Parent(pdnDevInst, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Parent", "uint*", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Parent_Ex function obtains a device instance handle to the parent node of a specified device node (devnode) in a local or a remote machine's device tree.
     * @param {Pointer<Integer>} pdnDevInst Caller-supplied pointer to the device instance handle to the parent node that this function retrieves. The retrieved handle is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_parent_ex
     * @since windows5.0
     */
    static CM_Get_Parent_Ex(pdnDevInst, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Parent_Ex", "uint*", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Res_Des_Data function retrieves the information stored in a resource descriptor on the local machine.
     * @param {Pointer} rdResDes Caller-supplied handle to a resource descriptor, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>.
     * @param {Pointer} Buffer Address of a buffer to receive the contents of a resource descriptor. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_size">CM_Get_Res_Des_Data_Size</a>.
     * @param {Integer} BufferLen Caller-supplied length of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Res_Des_Data</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_res_des_data
     * @since windows5.0
     */
    static CM_Get_Res_Des_Data(rdResDes, Buffer, BufferLen, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Res_Des_Data", "ptr", rdResDes, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Res_Des_Data_Ex function retrieves the information stored in a resource descriptor on a local or a remote machine.
     * @param {Pointer} rdResDes Caller-supplied handle to a resource descriptor, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>.
     * @param {Pointer} Buffer Address of a buffer to receive the contents of a resource descriptor. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_size_ex">CM_Get_Res_Des_Data_Size_Ex</a>.
     * @param {Integer} BufferLen Caller-supplied length of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Res_Des_Data_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_ex
     * @since windows5.0
     */
    static CM_Get_Res_Des_Data_Ex(rdResDes, Buffer, BufferLen, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Res_Des_Data_Ex", "ptr", rdResDes, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Res_Des_Data_Size function obtains the buffer size required to hold the information contained in a specified resource descriptor on the local machine.
     * @param {Pointer<Integer>} pulSize Caller-supplied address of a location to receive the required buffer size.
     * @param {Pointer} rdResDes Caller-supplied handle to a resource descriptor, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Res_Des_Data_Size</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_size
     * @since windows5.0
     */
    static CM_Get_Res_Des_Data_Size(pulSize, rdResDes, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Res_Des_Data_Size", "uint*", pulSize, "ptr", rdResDes, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Res_Des_Data_Size_Ex function obtains the buffer size required to hold the information contained in a specified resource descriptor on a local or a remote machine.
     * @param {Pointer<Integer>} pulSize Caller-supplied address of a location to receive the required buffer size.
     * @param {Pointer} rdResDes Caller-supplied handle to a resource descriptor, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Res_Des_Data_Size_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_size_ex
     * @since windows5.0
     */
    static CM_Get_Res_Des_Data_Size_Ex(pulSize, rdResDes, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Res_Des_Data_Size_Ex", "uint*", pulSize, "ptr", rdResDes, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Sibling function obtains a device instance handle to the next sibling node of a specified device node (devnode) in the local machine's device tree.
     * @param {Pointer<Integer>} pdnDevInst Caller-supplied pointer to the device instance handle to the sibling node that this function retrieves. The retrieved handle is bound to the local machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_sibling
     * @since windows5.0
     */
    static CM_Get_Sibling(pdnDevInst, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Sibling", "uint*", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Sibling_Ex function obtains a device instance handle to the next sibling node of a specified device node, in a local or a remote machine's device tree.
     * @param {Pointer<Integer>} pdnDevInst Caller-supplied pointer to the device instance handle to the sibling node that this function retrieves. The retrieved handle is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_sibling_ex
     * @since windows5.0
     */
    static CM_Get_Sibling_Ex(pdnDevInst, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Sibling_Ex", "uint*", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Version function returns version 4.0 of the Plug and Play (PnP) Configuration Manager DLL (Cfgmgr32.dll) for a local machine.
     * @returns {Integer} If the function succeeds, it returns the major revision number in the high-order byte, and the minor revision number in the low-order byte. Version 4.0 is returned as 0x0400. By default, version 4.0 is supported by Microsoft Windows 2000 and later versions of Windows. If an internal error occurs, the function returns 0x0000. Call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to obtain the error code for the failure.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_version
     * @since windows5.0
     */
    static CM_Get_Version() {
        A_LastError := 0

        result := DllCall("CFGMGR32.dll\CM_Get_Version", "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CM_Get_Version_Ex function returns version 4.0 of the Plug and Play (PnP) Configuration Manager DLL (Cfgmgr32.dll) for a local or a remote machine.
     * @param {Pointer} hMachine Supplies a machine handle that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the function succeeds, it returns the major revision number in the high-order byte and the minor revision number in the low-order byte. Version 4.0 is returned as 0x0400. By default, version 4.0 is supported  by Microsoft Windows 2000 and later versions of Windows. If an internal error occurs, the function returns 0x0000. Call <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to obtain the error code for the failure.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_version_ex
     * @since windows5.0
     */
    static CM_Get_Version_Ex(hMachine) {
        A_LastError := 0

        result := DllCall("CFGMGR32.dll\CM_Get_Version_Ex", "ptr", hMachine, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CM_Is_Version_Available function indicates whether a specified version of the Plug and Play (PnP) Configuration Manager DLL (Cfgmgr32.dll) is supported by a local machine.
     * @param {Integer} wVersion Identifies a version of the configuration manager. The supported version of the configuration manager corresponds directly to the operating system version. The major version is specified by the high-order byte and the minor version is specified by the low-order byte. 
     * 
     * For example, 0x0400 specifies version 4.0, which is supported by default by Microsoft Windows 2000 and later versions of Windows. 0x0501 specifies version 5.1, which is supported by Windows XP and later versions of Windows.
     * @returns {BOOL} The function returns <b>TRUE</b> if the local machine supports the specified version of the configuration manager. Otherwise, the function returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_is_version_available
     * @since windows5.1.2600
     */
    static CM_Is_Version_Available(wVersion) {
        result := DllCall("CFGMGR32.dll\CM_Is_Version_Available", "ushort", wVersion, "int")
        return result
    }

    /**
     * The CM_Is_Version_Available_Ex function indicates whether a specified version of the Plug and Play (PNP) Configuration Manager DLL (Cfgmgr32.dll) is supported by a local or a remote machine.
     * @param {Integer} wVersion Identifies a version of the configuration manager. The supported version of the configuration manager corresponds directly to the operating system version. The major version is specified by the high-order byte and the minor version is specified by the low-order byte. For example, 0x0400 specifies version 4.0, which is supported by default by Microsoft Windows NT 4.0 and later versions of Windows. Version 0x0501 specifies version 5.1, which is supported by Windows XP and later versions of Windows.
     * @param {Pointer} hMachine Supplies a machine handle that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {BOOL} The function returns <b>TRUE</b> if the function can connect to the specified machine and if the machine supports the specified version. Otherwise, the function returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_is_version_available_ex
     * @since windows5.1.2600
     */
    static CM_Is_Version_Available_Ex(wVersion, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Is_Version_Available_Ex", "ushort", wVersion, "ptr", hMachine, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} rlhOld1 
     * @param {Pointer} rlhOld2 
     * @param {Pointer} rlhNew 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_intersect_range_list
     */
    static CM_Intersect_Range_List(rlhOld1, rlhOld2, rlhNew, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Intersect_Range_List", "ptr", rlhOld1, "ptr", rlhOld2, "ptr", rlhNew, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlhOld 
     * @param {Pointer} rlhNew 
     * @param {Integer} ullMaxValue 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_invert_range_list
     */
    static CM_Invert_Range_List(rlhOld, rlhNew, ullMaxValue, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Invert_Range_List", "ptr", rlhOld, "ptr", rlhNew, "uint", ullMaxValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Locate_DevNode function obtains a device instance handle to the device node that is associated with a specified device instance ID on the local machine.
     * @param {Pointer<Integer>} pdnDevInst A pointer to a device instance handle that <b>CM_Locate_DevNode</b> retrieves. The retrieved handle is bound to the local machine.
     * @param {PSTR} pDeviceID A pointer to a NULL-terminated string representing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves a device instance handle to the device at the root of the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/device-tree">device tree</a>.
     * @param {Integer} ulFlags A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:
     * @returns {Integer} If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_locate_devnodea
     * @since windows5.0
     */
    static CM_Locate_DevNodeA(pdnDevInst, pDeviceID, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Locate_DevNodeA", "uint*", pdnDevInst, "ptr", pDeviceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Locate_DevNode function obtains a device instance handle to the device node that is associated with a specified device instance ID on the local machine.
     * @param {Pointer<Integer>} pdnDevInst A pointer to a device instance handle that <b>CM_Locate_DevNode</b> retrieves. The retrieved handle is bound to the local machine.
     * @param {PWSTR} pDeviceID A pointer to a NULL-terminated string representing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves a device instance handle to the device at the root of the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/device-tree">device tree</a>.
     * @param {Integer} ulFlags A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:
     * @returns {Integer} If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_locate_devnodew
     * @since windows5.0
     */
    static CM_Locate_DevNodeW(pdnDevInst, pDeviceID, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Locate_DevNodeW", "uint*", pdnDevInst, "ptr", pDeviceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Locate_DevNode_Ex function obtains a device instance handle to the device node that is associated with a specified device instance ID, on a local machine or a remote machine.
     * @param {Pointer<Integer>} pdnDevInst 
     * @param {PSTR} pDeviceID 
     * @param {Integer} ulFlags A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:
     * @param {Pointer} hMachine A machine handle obtained from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea">CM_Connect_Machine</a>, or a machine handle to which a device information set is bound. The machine handle for a device information set is obtained from the <b>RemoteMachineHandle</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure for the device information set. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila">SetupDiGetDeviceInfoListDetail</a> to obtain an SP_DEVINFO_LIST_DETAIL_DATA structure.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_locate_devnode_exa
     */
    static CM_Locate_DevNode_ExA(pdnDevInst, pDeviceID, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Locate_DevNode_ExA", "uint*", pdnDevInst, "ptr", pDeviceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Locate_DevNode_Ex function obtains a device instance handle to the device node that is associated with a specified device instance ID, on a local machine or a remote machine.
     * @param {Pointer<Integer>} pdnDevInst A pointer to the device instance handle that this function retrieves. The retrieved handle is bound to the machine handle specified by <i>hMachine</i>.
     * @param {PWSTR} pDeviceID A pointer to a NULL-terminated string representing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If this value is <b>NULL</b>, or if it points to a zero-length string, the function supplies a device instance handle to the device at the root of the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/device-tree">device tree</a>.
     * @param {Integer} ulFlags A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:
     * @param {Pointer} hMachine A machine handle obtained from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>, or a machine handle to which a device information set is bound. The machine handle for a device information set is obtained from the <b>RemoteMachineHandle</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure for the device information set. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila">SetupDiGetDeviceInfoListDetail</a> to obtain an SP_DEVINFO_LIST_DETAIL_DATA structure.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_locate_devnode_exw
     * @since windows5.0
     */
    static CM_Locate_DevNode_ExW(pdnDevInst, pDeviceID, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Locate_DevNode_ExW", "uint*", pdnDevInst, "ptr", pDeviceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlhOld1 
     * @param {Pointer} rlhOld2 
     * @param {Pointer} rlhNew 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_merge_range_list
     */
    static CM_Merge_Range_List(rlhOld1, rlhOld2, rlhNew, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Merge_Range_List", "ptr", rlhOld1, "ptr", rlhOld2, "ptr", rlhNew, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Modify_Res_Des function modifies a specified resource descriptor on the local machine.
     * @param {Pointer<Pointer>} prdResDes Pointer to a location to receive a handle to the modified resource descriptor.
     * @param {Pointer} rdResDes Caller-supplied handle to the resource descriptor to be modified. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * <b>CM_Modify_Res_Des</b>
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>
     * @param {Integer} ResourceID Caller-supplied resource type identifier. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer} ResourceData Caller-supplied pointer to a resource descriptor, which can be one of the structures listed under the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a> function's description of <i>ResourceData</i>.
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Modify_Res_Des</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_modify_res_des
     * @since windows5.0
     */
    static CM_Modify_Res_Des(prdResDes, rdResDes, ResourceID, ResourceData, ResourceLen, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Modify_Res_Des", "ptr*", prdResDes, "ptr", rdResDes, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Modify_Res_Des_Ex function modifies a specified resource descriptor on a local or a remote machine.
     * @param {Pointer<Pointer>} prdResDes Pointer to a location to receive a handle to the modified resource descriptor.
     * @param {Pointer} rdResDes Caller-supplied handle to the resource descriptor to be modified. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>
     * 
     * 
     * <b>CM_Modify_Res_Des_Ex</b>
     * @param {Integer} ResourceID Caller-supplied resource type identifier. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer} ResourceData Caller-supplied pointer to a resource descriptor, which can be one of the structures listed under the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a> function's description of <i>ResourceData</i>.
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Modify_Res_Des_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex
     * @since windows5.0
     */
    static CM_Modify_Res_Des_Ex(prdResDes, rdResDes, ResourceID, ResourceData, ResourceLen, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Modify_Res_Des_Ex", "ptr*", prdResDes, "ptr", rdResDes, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnFromDevInst 
     * @param {Integer} dnToDevInst 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_move_devnode
     */
    static CM_Move_DevNode(dnFromDevInst, dnToDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Move_DevNode", "uint", dnFromDevInst, "uint", dnToDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnFromDevInst 
     * @param {Integer} dnToDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_move_devnode_ex
     */
    static CM_Move_DevNode_Ex(dnFromDevInst, dnToDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Move_DevNode_Ex", "uint", dnFromDevInst, "uint", dnToDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer>} preElement 
     * @param {Pointer<Integer>} pullStart 
     * @param {Pointer<Integer>} pullEnd 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_next_range
     */
    static CM_Next_Range(preElement, pullStart, pullEnd, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Next_Range", "ptr*", preElement, "uint*", pullStart, "uint*", pullEnd, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Next_Res_Des function obtains a handle to the next resource descriptor, of a specified resource type, for a logical configuration on the local machine.
     * @param {Pointer<Pointer>} prdResDes Pointer to a location to receive a resource descriptor handle.
     * @param {Pointer} rdResDes Caller-supplied handle to either a resource descriptor or a logical configuration. For more information, see the following <b>Remarks</b> section.
     * @param {Integer} ForResource Caller-supplied resource type identifier, indicating the type of resource descriptor being requested. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Integer>} pResourceID Pointer to a location to receive a resource type identifier, if <i>ForResource</i> specifies <b>ResType_All</b>. For any other <i>ForResource</i> value, callers should set this to <b>NULL</b>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Next_Res_Des</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_next_res_des
     * @since windows5.0
     */
    static CM_Get_Next_Res_Des(prdResDes, rdResDes, ForResource, pResourceID, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Next_Res_Des", "ptr*", prdResDes, "ptr", rdResDes, "uint", ForResource, "uint*", pResourceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Next_Res_Des_Ex function obtains a handle to the next resource descriptor, of a specified resource type, for a logical configuration on a local or a remote machine.
     * @param {Pointer<Pointer>} prdResDes Pointer to a location to receive a resource descriptor handle.
     * @param {Pointer} rdResDes Caller-supplied handle to either a resource descriptor or a logical configuration. For more information, see the following <b>Remarks</b> section.
     * @param {Integer} ForResource Caller-supplied resource type identifier, indicating the type of resource descriptor being requested. This must be one of the ResType_-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Integer>} pResourceID Pointer to a location to receive a resource type identifier, if <i>ForResource</i> specifies <b>ResType_All</b>. For any other <i>ForResource</i> value, callers should set this to <b>NULL</b>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Next_Res_Des_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex
     * @since windows5.0
     */
    static CM_Get_Next_Res_Des_Ex(prdResDes, rdResDes, ForResource, pResourceID, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Next_Res_Des_Ex", "ptr*", prdResDes, "ptr", rdResDes, "uint", ForResource, "uint*", pResourceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Open_Class_Key function opens the device setup class registry key, the device interface class registry key, or a specific subkey of a class.
     * @param {Pointer<Guid>} ClassGuid Pointer to the GUID of the class whose registry key is to be opened. This parameter is optional and can be NULL. If this parameter is NULL, the root of the class tree is opened.
     * @param {PSTR} pszClassName Reserved. Must be set to NULL.
     * @param {Integer} samDesired The registry security access for the key to be opened.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkClass Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Open class key flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_open_class_keya
     */
    static CM_Open_Class_KeyA(ClassGuid, pszClassName, samDesired, Disposition, phkClass, ulFlags) {
        pszClassName := pszClassName is String ? StrPtr(pszClassName) : pszClassName

        result := DllCall("CFGMGR32.dll\CM_Open_Class_KeyA", "ptr", ClassGuid, "ptr", pszClassName, "uint", samDesired, "uint", Disposition, "ptr", phkClass, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Open_Class_Key function opens the device setup class registry key, the device interface class registry key, or a specific subkey of a class.
     * @param {Pointer<Guid>} ClassGuid Pointer to the GUID of the class whose registry key is to be opened. This parameter is optional and can be NULL. If this parameter is NULL, the root of the class tree is opened.
     * @param {PWSTR} pszClassName Reserved. Must be set to NULL.
     * @param {Integer} samDesired The registry security access for the key to be opened.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkClass Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Open class key flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_open_class_keyw
     * @since windows5.0
     */
    static CM_Open_Class_KeyW(ClassGuid, pszClassName, samDesired, Disposition, phkClass, ulFlags) {
        pszClassName := pszClassName is String ? StrPtr(pszClassName) : pszClassName

        result := DllCall("CFGMGR32.dll\CM_Open_Class_KeyW", "ptr", ClassGuid, "ptr", pszClassName, "uint", samDesired, "uint", Disposition, "ptr", phkClass, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PSTR} pszClassName 
     * @param {Integer} samDesired 
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkClass 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_class_key_exa
     */
    static CM_Open_Class_Key_ExA(ClassGuid, pszClassName, samDesired, Disposition, phkClass, ulFlags, hMachine) {
        pszClassName := pszClassName is String ? StrPtr(pszClassName) : pszClassName

        result := DllCall("CFGMGR32.dll\CM_Open_Class_Key_ExA", "ptr", ClassGuid, "ptr", pszClassName, "uint", samDesired, "uint", Disposition, "ptr", phkClass, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {PWSTR} pszClassName 
     * @param {Integer} samDesired 
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkClass 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_class_key_exw
     */
    static CM_Open_Class_Key_ExW(ClassGuid, pszClassName, samDesired, Disposition, phkClass, ulFlags, hMachine) {
        pszClassName := pszClassName is String ? StrPtr(pszClassName) : pszClassName

        result := DllCall("CFGMGR32.dll\CM_Open_Class_Key_ExW", "ptr", ClassGuid, "ptr", pszClassName, "uint", samDesired, "uint", Disposition, "ptr", phkClass, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Open_DevNode_Key function opens a registry key for device-specific configuration information.
     * @param {Integer} dnDevNode Caller-supplied device instance handle that is bound to the local machine
     * @param {Integer} samDesired The registry security access that is required for the requested key.
     * @param {Integer} ulHardwareProfile The hardware profile to open if <i>ulFlags</i> includes CM_REGISTRY_CONFIG. If this value is zero, the key for the current hardware profile is opened.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDevice Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Open device node key flags. Indicates the scope and type of registry storage key to open.  Can be a combination of the following flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_open_devnode_key
     * @since windows5.0
     */
    static CM_Open_DevNode_Key(dnDevNode, samDesired, ulHardwareProfile, Disposition, phkDevice, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Open_DevNode_Key", "uint", dnDevNode, "uint", samDesired, "uint", ulHardwareProfile, "uint", Disposition, "ptr", phkDevice, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevNode 
     * @param {Integer} samDesired 
     * @param {Integer} ulHardwareProfile 
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDevice 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_devnode_key_ex
     */
    static CM_Open_DevNode_Key_Ex(dnDevNode, samDesired, ulHardwareProfile, Disposition, phkDevice, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Open_DevNode_Key_Ex", "uint", dnDevNode, "uint", samDesired, "uint", ulHardwareProfile, "uint", Disposition, "ptr", phkDevice, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Open_Device_Interface_Key function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface.
     * @param {PSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance to open the registry subkey for.
     * @param {Integer} samDesired The requested registry security access to the registry subkey.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDeviceInterface Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_open_device_interface_keya
     * @since windows6.0.6000
     */
    static CM_Open_Device_Interface_KeyA(pszDeviceInterface, samDesired, Disposition, phkDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Open_Device_Interface_KeyA", "ptr", pszDeviceInterface, "uint", samDesired, "uint", Disposition, "ptr", phkDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Open_Device_Interface_Key function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance to open the registry subkey for.
     * @param {Integer} samDesired The requested registry security access to the registry subkey.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDeviceInterface Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_open_device_interface_keyw
     * @since windows6.0.6000
     */
    static CM_Open_Device_Interface_KeyW(pszDeviceInterface, samDesired, Disposition, phkDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Open_Device_Interface_KeyW", "ptr", pszDeviceInterface, "uint", samDesired, "uint", Disposition, "ptr", phkDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Open_Device_Interface_Key_ExA function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface.
     * @param {PSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance to open the registry subkey for.
     * @param {Integer} samDesired The requested registry security access to the registry subkey.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDeviceInterface Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_open_device_interface_key_exa
     * @since windows10.0.10240
     */
    static CM_Open_Device_Interface_Key_ExA(pszDeviceInterface, samDesired, Disposition, phkDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Open_Device_Interface_Key_ExA", "ptr", pszDeviceInterface, "uint", samDesired, "uint", Disposition, "ptr", phkDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Open_Device_Interface_Key_ExW function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance to open the registry subkey for.
     * @param {Integer} samDesired The requested registry security access to the registry subkey.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDeviceInterface Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_open_device_interface_key_exw
     * @since windows10.0.10240
     */
    static CM_Open_Device_Interface_Key_ExW(pszDeviceInterface, samDesired, Disposition, phkDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Open_Device_Interface_Key_ExW", "ptr", pszDeviceInterface, "uint", samDesired, "uint", Disposition, "ptr", phkDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Delete_Device_Interface_Key function deletes the registry subkey that is used by applications and drivers to store interface-specific information.
     * @param {PSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance of the registry subkey to delete.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_delete_device_interface_keya
     */
    static CM_Delete_Device_Interface_KeyA(pszDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Delete_Device_Interface_KeyA", "ptr", pszDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Delete_Device_Interface_Key function deletes the registry subkey that is used by applications and drivers to store interface-specific information.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance of the registry subkey to delete.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_delete_device_interface_keyw
     * @since windows6.0.6000
     */
    static CM_Delete_Device_Interface_KeyW(pszDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Delete_Device_Interface_KeyW", "ptr", pszDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Delete_Device_Interface_Key_ExA function deletes the registry subkey that is used by applications and drivers to store interface-specific information.
     * @param {PSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance of the registry subkey to delete.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_delete_device_interface_key_exa
     * @since windows10.0.10240
     */
    static CM_Delete_Device_Interface_Key_ExA(pszDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Delete_Device_Interface_Key_ExA", "ptr", pszDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Delete_Device_Interface_Key_ExW function deletes the registry subkey that is used by applications and drivers to store interface-specific information.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance of the registry subkey to delete.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_delete_device_interface_key_exw
     * @since windows10.0.10240
     */
    static CM_Delete_Device_Interface_Key_ExW(pszDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Delete_Device_Interface_Key_ExW", "ptr", pszDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} pData 
     * @param {Integer} DataLen 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_arbitrator_free_data
     */
    static CM_Query_Arbitrator_Free_Data(pData, DataLen, dnDevInst, ResourceID, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Query_Arbitrator_Free_Data", "ptr", pData, "uint", DataLen, "uint", dnDevInst, "uint", ResourceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} pData 
     * @param {Integer} DataLen 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_arbitrator_free_data_ex
     */
    static CM_Query_Arbitrator_Free_Data_Ex(pData, DataLen, dnDevInst, ResourceID, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Query_Arbitrator_Free_Data_Ex", "ptr", pData, "uint", DataLen, "uint", dnDevInst, "uint", ResourceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pulSize 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_arbitrator_free_size
     */
    static CM_Query_Arbitrator_Free_Size(pulSize, dnDevInst, ResourceID, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Query_Arbitrator_Free_Size", "uint*", pulSize, "uint", dnDevInst, "uint", ResourceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pulSize 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_arbitrator_free_size_ex
     */
    static CM_Query_Arbitrator_Free_Size_Ex(pulSize, dnDevInst, ResourceID, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Query_Arbitrator_Free_Size_Ex", "uint*", pulSize, "uint", dnDevInst, "uint", ResourceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnAncestor 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_remove_subtree
     */
    static CM_Query_Remove_SubTree(dnAncestor, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Query_Remove_SubTree", "uint", dnAncestor, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnAncestor 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_remove_subtree_ex
     */
    static CM_Query_Remove_SubTree_Ex(dnAncestor, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Query_Remove_SubTree_Ex", "uint", dnAncestor, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Query_And_Remove_SubTree function checks whether a device instance and its children can be removed and, if so, it removes them.
     * @param {Integer} dnAncestor Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the local machine.
     * @param {Pointer<Integer>} pVetoType (<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.
     * @param {PSTR} pszVetoName (<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the other CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtreea
     */
    static CM_Query_And_Remove_SubTreeA(dnAncestor, pVetoType, pszVetoName, ulNameLength, ulFlags) {
        pszVetoName := pszVetoName is String ? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Query_And_Remove_SubTreeA", "uint", dnAncestor, "int*", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Query_And_Remove_SubTree function checks whether a device instance and its children can be removed and, if so, it removes them.
     * @param {Integer} dnAncestor Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the local machine.
     * @param {Pointer<Integer>} pVetoType (<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.
     * @param {PWSTR} pszVetoName (<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the other CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtreew
     * @since windows5.0
     */
    static CM_Query_And_Remove_SubTreeW(dnAncestor, pVetoType, pszVetoName, ulNameLength, ulFlags) {
        pszVetoName := pszVetoName is String ? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Query_And_Remove_SubTreeW", "uint", dnAncestor, "int*", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Query_And_Remove_SubTree_Ex function checks whether a device instance and its children can be removed and, if so, it removes them.
     * @param {Integer} dnAncestor Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<Integer>} pVetoType (<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.
     * @param {PSTR} pszVetoName (<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtree_exa
     */
    static CM_Query_And_Remove_SubTree_ExA(dnAncestor, pVetoType, pszVetoName, ulNameLength, ulFlags, hMachine) {
        pszVetoName := pszVetoName is String ? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Query_And_Remove_SubTree_ExA", "uint", dnAncestor, "int*", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Query_And_Remove_SubTree_Ex function checks whether a device instance and its children can be removed and, if so, it removes them.
     * @param {Integer} dnAncestor Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<Integer>} pVetoType (<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.
     * @param {PWSTR} pszVetoName (<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtree_exw
     * @since windows5.0
     */
    static CM_Query_And_Remove_SubTree_ExW(dnAncestor, pVetoType, pszVetoName, ulNameLength, ulFlags, hMachine) {
        pszVetoName := pszVetoName is String ? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Query_And_Remove_SubTree_ExW", "uint", dnAncestor, "int*", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Request_Device_Eject function prepares a local device instance for safe removal, if the device is removable. If the device can be physically ejected, it will be.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Pointer<Integer>} pVetoType (<i>Optional</i>.) If not <b>NULL</b>, this points to a location that, if the removal request fails, receives a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value indicating the reason for the failure.
     * @param {PSTR} pszVetoName (<i>Optional</i>.) If not <b>NULL</b>, this is a caller-supplied pointer to a string buffer that receives a text string. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags Not used.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_request_device_ejecta
     */
    static CM_Request_Device_EjectA(dnDevInst, pVetoType, pszVetoName, ulNameLength, ulFlags) {
        pszVetoName := pszVetoName is String ? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Request_Device_EjectA", "uint", dnDevInst, "int*", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Request_Device_Eject_Ex function prepares a local or a remote device instance for safe removal, if the device is removable. If the device can be physically ejected, it will be.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<Integer>} pVetoType (<i>Optional</i>.) If not <b>NULL</b>, this points to a location that, if the removal request fails, receives a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value indicating the reason for the failure.
     * @param {PSTR} pszVetoName (<i>Optional</i>.) If not <b>NULL</b>, this is a caller-supplied pointer to a string buffer that receives a text string. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags Not used.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_request_device_eject_exa
     */
    static CM_Request_Device_Eject_ExA(dnDevInst, pVetoType, pszVetoName, ulNameLength, ulFlags, hMachine) {
        pszVetoName := pszVetoName is String ? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Request_Device_Eject_ExA", "uint", dnDevInst, "int*", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Request_Device_Eject function prepares a local device instance for safe removal, if the device is removable. If the device can be physically ejected, it will be.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Pointer<Integer>} pVetoType (<i>Optional</i>.) If not <b>NULL</b>, this points to a location that, if the removal request fails, receives a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value indicating the reason for the failure.
     * @param {PWSTR} pszVetoName (<i>Optional</i>.) If not <b>NULL</b>, this is a caller-supplied pointer to a string buffer that receives a text string. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags Not used.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_request_device_ejectw
     * @since windows5.0
     */
    static CM_Request_Device_EjectW(dnDevInst, pVetoType, pszVetoName, ulNameLength, ulFlags) {
        pszVetoName := pszVetoName is String ? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Request_Device_EjectW", "uint", dnDevInst, "int*", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Request_Device_Eject_Ex function prepares a local or a remote device instance for safe removal, if the device is removable. If the device can be physically ejected, it will be.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<Integer>} pVetoType (<i>Optional</i>.) If not <b>NULL</b>, this points to a location that, if the removal request fails, receives a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value indicating the reason for the failure.
     * @param {PWSTR} pszVetoName (<i>Optional</i>.) If not <b>NULL</b>, this is a caller-supplied pointer to a string buffer that receives a text string. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags Not used.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_request_device_eject_exw
     * @since windows5.0
     */
    static CM_Request_Device_Eject_ExW(dnDevInst, pVetoType, pszVetoName, ulNameLength, ulFlags, hMachine) {
        pszVetoName := pszVetoName is String ? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Request_Device_Eject_ExW", "uint", dnDevInst, "int*", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Reenumerate_DevNode function enumerates the devices identified by a specified device node and all of its children.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Caller-supplied flags that specify how reenumeration should occur. This parameter can be set to a combination of the following flags, as noted:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_reenumerate_devnode
     * @since windows5.0
     */
    static CM_Reenumerate_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Reenumerate_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Reenumerate_DevNode_Ex function enumerates the devices identified by a specified device node and all of its children.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Caller-supplied flags that specify how reenumeration should occur. This parameter can be set to a combination of the following flags, as noted:
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_reenumerate_devnode_ex
     * @since windows5.0
     */
    static CM_Reenumerate_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Reenumerate_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PSTR} pszReference 
     * @param {PSTR} pszDeviceInterface 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_interfacea
     */
    static CM_Register_Device_InterfaceA(dnDevInst, InterfaceClassGuid, pszReference, pszDeviceInterface, pulLength, ulFlags) {
        pszReference := pszReference is String ? StrPtr(pszReference) : pszReference
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Register_Device_InterfaceA", "uint", dnDevInst, "ptr", InterfaceClassGuid, "ptr", pszReference, "ptr", pszDeviceInterface, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PWSTR} pszReference 
     * @param {PWSTR} pszDeviceInterface 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_interfacew
     */
    static CM_Register_Device_InterfaceW(dnDevInst, InterfaceClassGuid, pszReference, pszDeviceInterface, pulLength, ulFlags) {
        pszReference := pszReference is String ? StrPtr(pszReference) : pszReference
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Register_Device_InterfaceW", "uint", dnDevInst, "ptr", InterfaceClassGuid, "ptr", pszReference, "ptr", pszDeviceInterface, "uint*", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PSTR} pszReference 
     * @param {PSTR} pszDeviceInterface 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_interface_exa
     */
    static CM_Register_Device_Interface_ExA(dnDevInst, InterfaceClassGuid, pszReference, pszDeviceInterface, pulLength, ulFlags, hMachine) {
        pszReference := pszReference is String ? StrPtr(pszReference) : pszReference
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Register_Device_Interface_ExA", "uint", dnDevInst, "ptr", InterfaceClassGuid, "ptr", pszReference, "ptr", pszDeviceInterface, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {PWSTR} pszReference 
     * @param {PWSTR} pszDeviceInterface 
     * @param {Pointer<Integer>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_interface_exw
     */
    static CM_Register_Device_Interface_ExW(dnDevInst, InterfaceClassGuid, pszReference, pszDeviceInterface, pulLength, ulFlags, hMachine) {
        pszReference := pszReference is String ? StrPtr(pszReference) : pszReference
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Register_Device_Interface_ExW", "uint", dnDevInst, "ptr", InterfaceClassGuid, "ptr", pszReference, "ptr", pszDeviceInterface, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Problem_Ex function sets a problem code for a device that is installed in a local or a remote machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulProblem Supplies a problem code, which is zero or one of the CM_PROB_Xxx flags that are described in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-manager-error-messages">Device Manager Error Messages</a>. A value of zero indicates that a problem code is not set for the device.
     * @param {Integer} ulFlags Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_devnode_problem_ex
     * @since windows5.0
     */
    static CM_Set_DevNode_Problem_Ex(dnDevInst, ulProblem, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Problem_Ex", "uint", dnDevInst, "uint", ulProblem, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Problem function sets a problem code for a device that is installed in a local machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProblem Supplies a problem code, which is zero or one of the CM_PROB_Xxx flags that are described in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-manager-error-messages">Device Manager Error Messages</a>. A value of zero indicates that a problem is not set for the device.
     * @param {Integer} ulFlags Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_devnode_problem
     * @since windows5.0
     */
    static CM_Set_DevNode_Problem(dnDevInst, ulProblem, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Problem", "uint", dnDevInst, "uint", ulProblem, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {PSTR} pszDeviceInterface 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_device_interfacea
     */
    static CM_Unregister_Device_InterfaceA(pszDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Unregister_Device_InterfaceA", "ptr", pszDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszDeviceInterface 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_device_interfacew
     */
    static CM_Unregister_Device_InterfaceW(pszDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Unregister_Device_InterfaceW", "ptr", pszDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {PSTR} pszDeviceInterface 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_device_interface_exa
     */
    static CM_Unregister_Device_Interface_ExA(pszDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Unregister_Device_Interface_ExA", "ptr", pszDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszDeviceInterface 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_device_interface_exw
     */
    static CM_Unregister_Device_Interface_ExW(pszDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Unregister_Device_Interface_ExW", "ptr", pszDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_driver
     */
    static CM_Register_Device_Driver(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Register_Device_Driver", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_driver_ex
     */
    static CM_Register_Device_Driver_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Register_Device_Driver_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnAncestor 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_remove_subtree
     */
    static CM_Remove_SubTree(dnAncestor, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Remove_SubTree", "uint", dnAncestor, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnAncestor 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_remove_subtree_ex
     */
    static CM_Remove_SubTree_Ex(dnAncestor, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Remove_SubTree_Ex", "uint", dnAncestor, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Property function sets a device instance property.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device instance property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device instance property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that contains the property value of the device instance property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_devnode_propertyw
     * @since windows6.0.6000
     */
    static CM_Set_DevNode_PropertyW(dnDevInst, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_PropertyW", "uint", dnDevInst, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Property_ExW function sets a device instance property.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device instance property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device instance property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that contains the property value of the device instance property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_devnode_property_exw
     * @since windows10.0.10240
     */
    static CM_Set_DevNode_Property_ExW(dnDevInst, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Property_ExW", "uint", dnDevInst, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Registry_Property function sets a specified device property in the registry.
     * @param {Integer} dnDevInst A caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProperty A CM_DRP_-prefixed constant value that identifies the device property to be set in the registry. These constants are defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer} Buffer A pointer to a caller-supplied buffer that supplies the requested device property, formatted appropriately for the property's data type.
     * @param {Integer} ulLength The length, in bytes, of the supplied device property.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_devnode_registry_propertya
     */
    static CM_Set_DevNode_Registry_PropertyA(dnDevInst, ulProperty, Buffer, ulLength, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Registry_PropertyA", "uint", dnDevInst, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Registry_Property function sets a specified device property in the registry.
     * @param {Integer} dnDevInst A caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProperty A CM_DRP_-prefixed constant value that identifies the device property to be set in the registry. These constants are defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer} Buffer A pointer to a caller-supplied buffer that supplies the requested device property, formatted appropriately for the property's data type.
     * @param {Integer} ulLength The length, in bytes, of the supplied device property.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_devnode_registry_propertyw
     * @since windows5.0
     */
    static CM_Set_DevNode_Registry_PropertyW(dnDevInst, ulProperty, Buffer, ulLength, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Registry_PropertyW", "uint", dnDevInst, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulProperty 
     * @param {Pointer} Buffer 
     * @param {Integer} ulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_registry_property_exa
     */
    static CM_Set_DevNode_Registry_Property_ExA(dnDevInst, ulProperty, Buffer, ulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Registry_Property_ExA", "uint", dnDevInst, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulProperty 
     * @param {Pointer} Buffer 
     * @param {Integer} ulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_registry_property_exw
     */
    static CM_Set_DevNode_Registry_Property_ExW(dnDevInst, ulProperty, Buffer, ulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Registry_Property_ExW", "uint", dnDevInst, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_Device_Interface_Property function sets a device property of a device interface.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance for which to set a property for.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device interface property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device interface property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that contains the property value of the device interface property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_device_interface_propertyw
     * @since windows6.0.6000
     */
    static CM_Set_Device_Interface_PropertyW(pszDeviceInterface, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Set_Device_Interface_PropertyW", "ptr", pszDeviceInterface, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Set_Device_Interface_Property_ExW function sets a device property of a device interface.
     * @param {PWSTR} pszDeviceInterface Pointer to a string that identifies the device interface instance for which to set a property for.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device interface property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device interface property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that contains the property value of the device interface property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_device_interface_property_exw
     * @since windows10.0.10240
     */
    static CM_Set_Device_Interface_Property_ExW(pszDeviceInterface, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String ? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Set_Device_Interface_Property_ExW", "ptr", pszDeviceInterface, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Is_Dock_Station_Present function identifies whether a docking station is present in a local machine.
     * @param {Pointer<BOOL>} pbPresent Pointer to a Boolean value that indicates whether a docking station is present in a local machine. The function sets *<i>pbPresen</i>t to <b>TRUE</b> if a docking station is present. Otherwise, the function sets *<i>pbPresen</i>t to <b>FALSE</b>.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present
     * @since windows5.0
     */
    static CM_Is_Dock_Station_Present(pbPresent) {
        result := DllCall("CFGMGR32.dll\CM_Is_Dock_Station_Present", "ptr", pbPresent, "uint")
        return result
    }

    /**
     * The CM_Is_Dock_Station_Present_Ex function identifies whether a docking station is present in a local or a remote machine.
     * @param {Pointer<BOOL>} pbPresent Pointer to a Boolean value that indicates whether a docking station is present in a local machine. The function sets *pbPresent to <b>TRUE</b> if a docking station is present. The function sets *<i>pbPresent</i> to <b>FALSE</b> if the function cannot connect to the specified machine or a docking station is not present.
     * @param {Pointer} hMachine Supplies a machine handle that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present_ex
     * @since windows5.0
     */
    static CM_Is_Dock_Station_Present_Ex(pbPresent, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Is_Dock_Station_Present_Ex", "ptr", pbPresent, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Request_Eject_PC function requests that a portable PC, which is inserted in a local docking station, be ejected.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_request_eject_pc
     * @since windows5.0
     */
    static CM_Request_Eject_PC() {
        result := DllCall("CFGMGR32.dll\CM_Request_Eject_PC", "uint")
        return result
    }

    /**
     * The CM_Request_Eject_PC_Ex function requests that a portable PC, which is inserted in a local or a remote docking station, be ejected.
     * @param {Pointer} hMachine Supplies a machine handle that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_request_eject_pc_ex
     * @since windows5.0
     */
    static CM_Request_Eject_PC_Ex(hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Request_Eject_PC_Ex", "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {PSTR} pDeviceID 
     * @param {Integer} ulConfig 
     * @param {Integer} ulValue 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_flagsa
     */
    static CM_Set_HW_Prof_FlagsA(pDeviceID, ulConfig, ulValue, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_FlagsA", "ptr", pDeviceID, "uint", ulConfig, "uint", ulValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} pDeviceID 
     * @param {Integer} ulConfig 
     * @param {Integer} ulValue 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_flagsw
     */
    static CM_Set_HW_Prof_FlagsW(pDeviceID, ulConfig, ulValue, ulFlags) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_FlagsW", "ptr", pDeviceID, "uint", ulConfig, "uint", ulValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {PSTR} pDeviceID 
     * @param {Integer} ulConfig 
     * @param {Integer} ulValue 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_flags_exa
     */
    static CM_Set_HW_Prof_Flags_ExA(pDeviceID, ulConfig, ulValue, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_Flags_ExA", "ptr", pDeviceID, "uint", ulConfig, "uint", ulValue, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} pDeviceID 
     * @param {Integer} ulConfig 
     * @param {Integer} ulValue 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_flags_exw
     */
    static CM_Set_HW_Prof_Flags_ExW(pDeviceID, ulConfig, ulValue, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String ? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_Flags_ExW", "ptr", pDeviceID, "uint", ulConfig, "uint", ulValue, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Setup_DevNode function restarts a device instance that is not running because there is a problem with the device configuration.
     * @param {Integer} dnDevInst A device instance handle that is bound to the local system.
     * @param {Integer} ulFlags One of the following flag values:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise it returns one of the error codes with "CR_" prefix that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_setup_devnode
     * @since windows5.0
     */
    static CM_Setup_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Setup_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_setup_devnode_ex
     */
    static CM_Setup_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Setup_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ullStartValue 
     * @param {Integer} ullEndValue 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_test_range_available
     */
    static CM_Test_Range_Available(ullStartValue, ullEndValue, rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Test_Range_Available", "uint", ullStartValue, "uint", ullEndValue, "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Uninstall_DevNode function removes all persistent state associated with a device instance.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_uninstall_devnode
     * @since windows5.0
     */
    static CM_Uninstall_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Uninstall_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_uninstall_devnode_ex
     */
    static CM_Uninstall_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Uninstall_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_run_detection
     */
    static CM_Run_Detection(ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Run_Detection", "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_run_detection_ex
     */
    static CM_Run_Detection_Ex(ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Run_Detection_Ex", "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulHardwareProfile 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof
     */
    static CM_Set_HW_Prof(ulHardwareProfile, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof", "uint", ulHardwareProfile, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulHardwareProfile 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_ex
     */
    static CM_Set_HW_Prof_Ex(ulHardwareProfile, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_Ex", "uint", ulHardwareProfile, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Query_Resource_Conflict_List function identifies device instances having resource requirements that conflict with a specified device instance's resource description.
     * @param {Pointer<Pointer>} pclConflictList Caller-supplied address of a location to receive a handle to a conflict list.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ResourceID Caller-supplied resource type identifier. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer} ResourceData Caller-supplied pointer to a resource descriptor, which can be one of the structures listed under the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a> function's description of <i>ResourceData</i>.
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Query_Resource_Conflict_List</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list
     * @since windows5.0
     */
    static CM_Query_Resource_Conflict_List(pclConflictList, dnDevInst, ResourceID, ResourceData, ResourceLen, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Query_Resource_Conflict_List", "ptr*", pclConflictList, "uint", dnDevInst, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Free_Resource_Conflict_Handle function invalidates a handle to a resource conflict list, and frees the handle's associated memory allocation.
     * @param {Pointer} clConflictList Caller-supplied handle to be freed. This conflict list handle must have been previously obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_free_resource_conflict_handle
     * @since windows5.0
     */
    static CM_Free_Resource_Conflict_Handle(clConflictList) {
        result := DllCall("CFGMGR32.dll\CM_Free_Resource_Conflict_Handle", "ptr", clConflictList, "uint")
        return result
    }

    /**
     * The CM_Get_Resource_Conflict_Count function obtains the number of conflicts contained in a specified resource conflict list.
     * @param {Pointer} clConflictList Caller-supplied handle to a conflict list, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @param {Pointer<Integer>} pulCount Caller-supplied address of a location to receive the conflict count.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count
     * @since windows5.0
     */
    static CM_Get_Resource_Conflict_Count(clConflictList, pulCount) {
        result := DllCall("CFGMGR32.dll\CM_Get_Resource_Conflict_Count", "ptr", clConflictList, "uint*", pulCount, "uint")
        return result
    }

    /**
     * The CM_Get_Resource_Conflict_Details function obtains the details about one of the resource conflicts in a conflict list.
     * @param {Pointer} clConflictList Caller-supplied handle to a conflict list, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @param {Integer} ulIndex Caller-supplied value used as an index into the conflict list. This value can be from zero to one less than the number returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count">CM_Get_Resource_Conflict_Count</a>.
     * @param {Pointer<CONFLICT_DETAILS_A>} pConflictDetails Caller-supplied address of a <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ns-cfgmgr32-conflict_details_a">CONFLICT_DETAILS</a> structure to receive conflict details. The caller must supply values for the structure's <i>CD_ulSize</i> and <i>CD_ulMask</i> structures.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_detailsa
     */
    static CM_Get_Resource_Conflict_DetailsA(clConflictList, ulIndex, pConflictDetails) {
        result := DllCall("CFGMGR32.dll\CM_Get_Resource_Conflict_DetailsA", "ptr", clConflictList, "uint", ulIndex, "ptr", pConflictDetails, "uint")
        return result
    }

    /**
     * The CM_Get_Resource_Conflict_Details function obtains the details about one of the resource conflicts in a conflict list.
     * @param {Pointer} clConflictList Caller-supplied handle to a conflict list, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @param {Integer} ulIndex Caller-supplied value used as an index into the conflict list. This value can be from zero to one less than the number returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count">CM_Get_Resource_Conflict_Count</a>.
     * @param {Pointer<CONFLICT_DETAILS_W>} pConflictDetails Caller-supplied address of a <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ns-cfgmgr32-conflict_details_a">CONFLICT_DETAILS</a> structure to receive conflict details. The caller must supply values for the structure's <i>CD_ulSize</i> and <i>CD_ulMask</i> structures.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_detailsw
     * @since windows5.0
     */
    static CM_Get_Resource_Conflict_DetailsW(clConflictList, ulIndex, pConflictDetails) {
        result := DllCall("CFGMGR32.dll\CM_Get_Resource_Conflict_DetailsW", "ptr", clConflictList, "uint", ulIndex, "ptr", pConflictDetails, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Property function retrieves a device property that is set for a device interface class or device setup class.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to retrieve a device property that is set for the device class. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device class property.
     * @param {Pointer<Integer>} PropertyType Pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device class property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that receives the requested device class property. <b>CM_Get_Class_Property</b> retrieves the requested property value only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<Integer>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If the <i>PropertyBuffer</i> parameter is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Class_Property</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Class property flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_class_propertyw
     * @since windows6.0.6000
     */
    static CM_Get_Class_PropertyW(ClassGUID, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_PropertyW", "ptr", ClassGUID, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint*", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Property_ExW function retrieves a device property that is set for a device interface class or device setup class.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to retrieve a device property that is set for the device class. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device class property.
     * @param {Pointer<Integer>} PropertyType Pointer to a <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device class property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base data type is modified, a property-data-type modifier.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that receives the requested device class property. <b>CM_Get_Class_Property_ExW</b> retrieves the requested property value only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<Integer>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If the <i>PropertyBuffer</i> parameter is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Class_Property_ExW</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Class property flags:
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_class_property_exw
     * @since windows10.0.10240
     */
    static CM_Get_Class_Property_ExW(ClassGUID, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Property_ExW", "ptr", ClassGUID, "ptr", PropertyKey, "uint*", PropertyType, "ptr", PropertyBuffer, "uint*", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Property_Keys function retrieves an array of the device property keys that represent the device properties that are set for a device interface class or device setup class.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to retrieve the property keys for. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device class. The pointer is optional and can be NULL.
     * @param {Pointer<Integer>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero. As output, if <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_Class_Property_Keys</b> returns the count of the keys, in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Class property key flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_class_property_keys
     * @since windows6.0.6000
     */
    static CM_Get_Class_Property_Keys(ClassGUID, PropertyKeyArray, PropertyKeyCount, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Property_Keys", "ptr", ClassGUID, "ptr", PropertyKeyArray, "uint*", PropertyKeyCount, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Property_Keys_Ex function retrieves an array of the device property keys that represent the device properties that are set for a device interface class or device setup class.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to retrieve the property keys for. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device class. The pointer is optional and can be NULL.
     * @param {Pointer<Integer>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero. As output, if <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_Class_Property_Keys_Ex</b> returns the count of the keys, in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Class property key flags:
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_class_property_keys_ex
     * @since windows10.0.10240
     */
    static CM_Get_Class_Property_Keys_Ex(ClassGUID, PropertyKeyArray, PropertyKeyCount, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Property_Keys_Ex", "ptr", ClassGUID, "ptr", PropertyKeyArray, "uint*", PropertyKeyCount, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_Class_Property function sets a class property for a device setup class or a device interface class.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to set a device property. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device class property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device class property. To delete a property, set this to DEVPROP_TYPE_EMPTY.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that contains the property value of the device class property. If either the property or the data is to be deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Class property flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_class_propertyw
     * @since windows6.0.6000
     */
    static CM_Set_Class_PropertyW(ClassGUID, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_Class_PropertyW", "ptr", ClassGUID, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Set_Class_Property_ExW function sets a class property for a device setup class or a device interface class.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://msdn.microsoft.com/C989D2D3-E8DE-4D64-86EE-3D3B3906390D">device interface class</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to set a device property. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device class property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/previous-versions/ff543546(v=vs.85)">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device class property. To delete a property, set this to <b>DEVPROP_TYPE_EMPTY</b>.
     * @param {Pointer} PropertyBuffer Pointer to a buffer that contains the property value of the device class property. If either the property or the data is to be deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Class property flags:
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_class_property_exw
     * @since windows10.0.10240
     */
    static CM_Set_Class_Property_ExW(ClassGUID, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_Class_Property_ExW", "ptr", ClassGUID, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Registry_Property function retrieves a device setup class property.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that represents the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to retrieve a property.
     * @param {Integer} ulProperty A value of type ULONG that identifies the property to be retrieved. This value must be one of the following CM_CRP_<i>Xxx</i> values that are defined in <i>Cfgmgr32.h</i>:
     * @param {Pointer<Integer>} pulRegDataType A pointer to a variable of type ULONG that receives the REG_<i>Xxx</i> constant that represents the data type of the requested property. The REG_<i>Xxx</i> constants are defined in <i>Winnt.h</i> and are described in the <b>Type</b> member of the <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_key_value_basic_information">KEY_VALUE_BASIC_INFORMATION</a> structure. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer} Buffer A pointer to a buffer that receives the requested property data. For more information about this parameter and the buffer-size parameter <i>pulLength</i>, see the following <b>Remarks</b> section.
     * @param {Pointer<Integer>} pulLength A pointer to variable of type ULONG whose value, on input, is the size, in bytes, of the buffer that is supplied by <i>Buffer</i>. On return, <b>CM_Get_Class_Registry_Property </b>sets this variable to the size, in bytes, of the requested property.
     * @param {Integer} ulFlags Reserved for internal use only. Must be set to zero.
     * @param {Pointer} hMachine A handle to a remote machine from which to retrieve the specified device class property. This parameter is optional, and, if it is set to <b>NULL</b>, the property is retrieved from the local machine.
     * @returns {Integer} If the operation succeeds, <b>CM_Get_Class_Registry_Property </b>returns CR_SUCCESS. Otherwise, the function returns one of the other CR_<i>Xxx</i> status codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_class_registry_propertya
     */
    static CM_Get_Class_Registry_PropertyA(ClassGuid, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Registry_PropertyA", "ptr", ClassGuid, "uint", ulProperty, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Registry_Property function retrieves a device setup class property.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that represents the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">device setup class</a> for which to retrieve a property.
     * @param {Integer} ulProperty A value of type ULONG that identifies the property to be retrieved. This value must be one of the following CM_CRP_<i>Xxx</i> values that are defined in <i>Cfgmgr32.h</i>:
     * @param {Pointer<Integer>} pulRegDataType A pointer to a variable of type ULONG that receives the REG_<i>Xxx</i> constant that represents the data type of the requested property. The REG_<i>Xxx</i> constants are defined in <i>Winnt.h</i> and are described in the <b>Type</b> member of the <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_key_value_basic_information">KEY_VALUE_BASIC_INFORMATION</a> structure. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer} Buffer A pointer to a buffer that receives the requested property data. For more information about this parameter and the buffer-size parameter <i>pulLength</i>, see the following <b>Remarks</b> section.
     * @param {Pointer<Integer>} pulLength A pointer to variable of type ULONG whose value, on input, is the size, in bytes, of the buffer that is supplied by <i>Buffer</i>. On return, <b>CM_Get_Class_Registry_Property </b>sets this variable to the size, in bytes, of the requested property.
     * @param {Integer} ulFlags Reserved for internal use only. Must be set to zero.
     * @param {Pointer} hMachine A handle to a remote machine from which to retrieve the specified device class property. This parameter is optional, and, if it is set to <b>NULL</b>, the property is retrieved from the local machine.
     * @returns {Integer} If the operation succeeds, <b>CM_Get_Class_Registry_Property </b>returns CR_SUCCESS. Otherwise, the function returns one of the other CR_<i>Xxx</i> status codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_get_class_registry_propertyw
     * @since windows5.0
     */
    static CM_Get_Class_Registry_PropertyW(ClassGuid, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Registry_PropertyW", "ptr", ClassGuid, "uint", ulProperty, "uint*", pulRegDataType, "ptr", Buffer, "uint*", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_Class_Registry_Property function sets or deletes a property of a device setup class.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that represents the device setup class for which to set a property.
     * @param {Integer} ulProperty A value of type ULONG that identifies the property to set. This value must be one of the CM_CRP_<i>Xxx</i> values that are described for the <i>ulProperty</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_class_registry_propertya">CM_Get_Class_Registry_Property</a> function.
     * @param {Pointer} Buffer A pointer to a buffer that contains the property data. This parameter is optional and can be set to <b>NULL</b>. For more information about setting this parameter and the corresponding <i>ulLength</i> parameter, see the following <b>Remarks</b> section.
     * @param {Integer} ulLength A value of type ULONG that specifies the size, in bytes, of the property data.
     * @param {Integer} ulFlags Reserved for internal use only. Must be set to zero.
     * @param {Pointer} hMachine A handle to a remote machine on which to set the specified <a href="https://docs.microsoft.com/windows-hardware/drivers/install/accessing-device-setup-class-properties">device setup class property</a>. This parameter is optional. If set to <b>NULL</b>, the property is set on the local machine.
     * @returns {Integer} If the operation succeeds, <b>CM_Set_Class_Registry_Property </b>returns CR_SUCCESS. Otherwise, the function returns one of the other CR_<i>Xxx</i> status codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_class_registry_propertya
     */
    static CM_Set_Class_Registry_PropertyA(ClassGuid, ulProperty, Buffer, ulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_Class_Registry_PropertyA", "ptr", ClassGuid, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_Class_Registry_Property function sets or deletes a property of a device setup class.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that represents the device setup class for which to set a property.
     * @param {Integer} ulProperty A value of type ULONG that identifies the property to set. This value must be one of the CM_CRP_<i>Xxx</i> values that are described for the <i>ulProperty</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_class_registry_propertyw">CM_Get_Class_Registry_Property</a> function.
     * @param {Pointer} Buffer A pointer to a buffer that contains the property data. This parameter is optional and can be set to <b>NULL</b>. For more information about setting this parameter and the corresponding <i>ulLength</i> parameter, see the following <b>Remarks</b> section.
     * @param {Integer} ulLength A value of type ULONG that specifies the size, in bytes, of the property data.
     * @param {Integer} ulFlags Reserved for internal use only. Must be set to zero.
     * @param {Pointer} hMachine A handle to a remote machine on which to set the specified <a href="https://docs.microsoft.com/windows-hardware/drivers/install/accessing-device-setup-class-properties">device setup class property</a>. This parameter is optional. If set to <b>NULL</b>, the property is set on the local machine.
     * @returns {Integer} If the operation succeeds, <b>CM_Set_Class_Registry_Property </b>returns CR_SUCCESS. Otherwise, the function returns one of the other CR_<i>Xxx</i> status codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_set_class_registry_propertyw
     * @since windows5.0
     */
    static CM_Set_Class_Registry_PropertyW(ClassGuid, ulProperty, Buffer, ulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_Class_Registry_PropertyW", "ptr", ClassGuid, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dwTimeout 
     * @returns {Integer} 
     */
    static CMP_WaitNoPendingInstallEvents(dwTimeout) {
        result := DllCall("CFGMGR32.dll\CMP_WaitNoPendingInstallEvents", "uint", dwTimeout, "uint")
        return result
    }

    /**
     * Use RegisterDeviceNotification instead of CM_Register_Notification if your code targets Windows7 or earlier versions of Windows. Kernel mode callers should use IoRegisterPlugPlayNotification instead.
     * @param {Pointer<CM_NOTIFY_FILTER>} pFilter Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ns-cfgmgr32-cm_notify_filter">CM_NOTIFY_FILTER</a> structure.
     * @param {Pointer<Void>} pContext Pointer to a caller-allocated buffer containing the context to be passed to the callback routine in <i>pCallback</i>.
     * @param {Pointer<PCM_NOTIFY_CALLBACK>} pCallback Pointer to the routine to be called when the specified PnP event occurs. See the <b>Remarks</b> section for the callback function's prototype.
     * 
     * The callback routines <i>Action</i> parameter will be a value from the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ne-cfgmgr32-cm_notify_action">CM_NOTIFY_ACTION</a> enumeration.
     * 
     * Upon receiving a notification, how the callback examines the notification will depend on the <b>FilterType</b> member of the callback routine's <i>EventData</i> parameter:
     * @param {Pointer<HCMNOTIFICATION>} pNotifyContext Pointer to receive the HCMNOTIFICATION handle that corresponds to the registration call.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_register_notification
     * @since windows8.0
     */
    static CM_Register_Notification(pFilter, pContext, pCallback, pNotifyContext) {
        result := DllCall("CFGMGR32.dll\CM_Register_Notification", "ptr", pFilter, "ptr", pContext, "ptr", pCallback, "ptr", pNotifyContext, "uint")
        return result
    }

    /**
     * Use UnregisterDeviceNotification instead of CM_Unregister_Notification if your code targets Windows7 or earlier versions of Windows.
     * @param {HCMNOTIFICATION} NotifyContext The HCMNOTIFICATION handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_register_notification">CM_Register_Notification</a> function.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_unregister_notification
     * @since windows8.0
     */
    static CM_Unregister_Notification(NotifyContext) {
        NotifyContext := NotifyContext is Win32Handle ? NumGet(NotifyContext, "ptr") : NotifyContext

        result := DllCall("CFGMGR32.dll\CM_Unregister_Notification", "ptr", NotifyContext, "uint")
        return result
    }

    /**
     * Converts a specified CONFIGRET code to its equivalent system error code.
     * @param {Integer} CmReturnCode The <b>CONFIGRET</b> code to be converted. <b>CONFIGRET</b> 
     *       error codes are defined in CfgMgr32.h.
     * @param {Integer} DefaultErr A default system error code to be returned when no system error code is mapped to the specified 
     *       <b>CONFIGRET</b> code.
     * @returns {Integer} The system error code that corresponds to the <b>CONFIGRET</b> code. System error codes 
     *        are defined in Winerror.h.
     * 
     * When there is no mapping from the specified <b>CONFIGRET</b> code to a system error 
     *        code, <b>CM_MapCrToWin32Err</b> returns the value 
     *        specified in the <i>DefaultErr</i> parameter.
     * @see https://docs.microsoft.com/windows/win32/api//cfgmgr32/nf-cfgmgr32-cm_mapcrtowin32err
     * @since windows6.1
     */
    static CM_MapCrToWin32Err(CmReturnCode, DefaultErr) {
        result := DllCall("CFGMGR32.dll\CM_MapCrToWin32Err", "uint", CmReturnCode, "uint", DefaultErr, "uint")
        return result
    }

    /**
     * Given an INF file and a hardware ID, the UpdateDriverForPlugAndPlayDevices function installs updated drivers for devices that match the hardware ID.
     * @param {HWND} hwndParent A handle to the top-level window to use for any UI related to installing devices.
     * @param {PSTR} HardwareId A pointer to a NULL-terminated string that supplies the hardware identifier to match existing devices on the computer. The maximum length of a NULL-terminated hardware identifier is MAX_DEVICE_ID_LEN. For more information about hardware identifiers, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * @param {PSTR} FullInfPath A pointer to a NULL-terminated string that supplies the full path file name of an INF file. The files should be on the distribution media or in a vendor-created directory, not in a system location such as <i>%SystemRoot%\inf</i>. <b>UpdateDriverForPlugAndPlayDevices</b> copies driver files to the appropriate system locations if the installation is successful.
     * @param {Integer} InstallFlags A caller-supplied value created by using OR to combine zero or more of the following bit flags:
     * @param {Pointer<BOOL>} bRebootRequired A pointer to a BOOL-typed variable that indicates whether a restart is required and who should prompt for it. This pointer is optional and can be <b>NULL</b>. 
     * 
     * If the pointer is <b>NULL</b>, <b>UpdateDriverForPlugAndPlayDevices</b> prompts for a restart after installing drivers, if necessary. If the pointer is supplied, the function returns a BOOLEAN value that is <b>TRUE</b> if the system should be restarted. It is then the caller's responsibility to prompt for a restart. 
     * 
     * For more information, see the following <b>Remarks</b> section.
     * @returns {BOOL} The function returns <b>TRUE</b> if a device was upgraded to the specified driver.
     * 
     * Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <b>GetLastError</b>. Possible error values returned by <b>GetLastError</b> are included in the following table.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path that was specified for <i>FullInfPath</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application attempting to execute in a 64-bit environment, which is not allowed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>InstallFlags</i> is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>HardwareId</i> does not match any device on the system. That is, the device is not plugged in.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function found a match for the <i>HardwareId</i> value, but the specified driver was not a better match than the current driver and the caller did not specify the INSTALLFLAG_FORCE flag. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-updatedriverforplugandplaydevicesa
     * @since windows5.0
     */
    static UpdateDriverForPlugAndPlayDevicesA(hwndParent, HardwareId, FullInfPath, InstallFlags, bRebootRequired) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        HardwareId := HardwareId is String ? StrPtr(HardwareId) : HardwareId
        FullInfPath := FullInfPath is String ? StrPtr(FullInfPath) : FullInfPath

        A_LastError := 0

        result := DllCall("newdev.dll\UpdateDriverForPlugAndPlayDevicesA", "ptr", hwndParent, "ptr", HardwareId, "ptr", FullInfPath, "uint", InstallFlags, "ptr", bRebootRequired, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Given an INF file and a hardware ID, the UpdateDriverForPlugAndPlayDevices function installs updated drivers for devices that match the hardware ID.
     * @param {HWND} hwndParent A handle to the top-level window to use for any UI related to installing devices.
     * @param {PWSTR} HardwareId A pointer to a NULL-terminated string that supplies the hardware identifier to match existing devices on the computer. The maximum length of a NULL-terminated hardware identifier is MAX_DEVICE_ID_LEN. For more information about hardware identifiers, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * @param {PWSTR} FullInfPath A pointer to a NULL-terminated string that supplies the full path file name of an INF file. The files should be on the distribution media or in a vendor-created directory, not in a system location such as <i>%SystemRoot%\inf</i>. <b>UpdateDriverForPlugAndPlayDevices</b> copies driver files to the appropriate system locations if the installation is successful.
     * @param {Integer} InstallFlags A caller-supplied value created by using OR to combine zero or more of the following bit flags:
     * @param {Pointer<BOOL>} bRebootRequired A pointer to a BOOL-typed variable that indicates whether a restart is required and who should prompt for it. This pointer is optional and can be <b>NULL</b>. 
     * 
     * If the pointer is <b>NULL</b>, <b>UpdateDriverForPlugAndPlayDevices</b> prompts for a restart after installing drivers, if necessary. If the pointer is supplied, the function returns a BOOLEAN value that is <b>TRUE</b> if the system should be restarted. It is then the caller's responsibility to prompt for a restart. 
     * 
     * For more information, see the following <b>Remarks</b> section.
     * @returns {BOOL} The function returns <b>TRUE</b> if a device was upgraded to the specified driver.
     * 
     * Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <b>GetLastError</b>. Possible error values returned by <b>GetLastError</b> are included in the following table.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path that was specified for <i>FullInfPath</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application attempting to execute in a 64-bit environment, which is not allowed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>InstallFlags</i> is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>HardwareId</i> does not match any device on the system. That is, the device is not plugged in.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function found a match for the <i>HardwareId</i> value, but the specified driver was not a better match than the current driver and the caller did not specify the INSTALLFLAG_FORCE flag. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-updatedriverforplugandplaydevicesw
     * @since windows5.0
     */
    static UpdateDriverForPlugAndPlayDevicesW(hwndParent, HardwareId, FullInfPath, InstallFlags, bRebootRequired) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        HardwareId := HardwareId is String ? StrPtr(HardwareId) : HardwareId
        FullInfPath := FullInfPath is String ? StrPtr(FullInfPath) : FullInfPath

        A_LastError := 0

        result := DllCall("newdev.dll\UpdateDriverForPlugAndPlayDevicesW", "ptr", hwndParent, "ptr", HardwareId, "ptr", FullInfPath, "uint", InstallFlags, "ptr", bRebootRequired, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiInstallDevice function installs a specified driver that is preinstalled in the driver store on a specified device that is present in the system.
     * @param {HWND} hwndParent A handle to the top-level window that <b>DiInstallDevice</b> uses to display any user interface component that is associated with installing the device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {HDEVINFO} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the specified device.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the specified device in the specified device information set.
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData An pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver to install on the specified device. This parameter is optional and can be set to <b>NULL</b>. If this parameter is <b>NULL</b>, <b>DiInstallDevice</b> searches the drivers preinstalled in the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a> for the driver that is the best match to the specified device, and, if one is found, installs the driver on the specified device.
     * @param {Integer} Flags A value of type <b>DWORD</b> that specifies zero or the following flag:
     * @param {Pointer<BOOL>} NeedReboot A pointer to a value of type <b>BOOL</b> that <b>DiInstallDevice</b> sets to indicate whether a system restart is required to complete the installation. This parameter is optional and can be set to <b>NULL</b>. If this parameter is supplied and a system restart is required to complete the installation, <b>DiInstallDevice</b> sets the value to <b>TRUE</b>. In this case, the caller is responsible for restarting the system. If this parameter is supplied and a system restart is not required, <b>DiInstallDevice</b> sets this parameter to <b>FALSE</b>. If this parameter is <b>NULL</b> and a system restart is required to complete the installation, <b>DiInstallDevice</b> displays a system restart dialog box.
     * @returns {BOOL} <b>DiInstallDevice</b> returns <b>TRUE</b> if the function successfully installed the specified driver on the specified device. Otherwise, <b>DiInstallDevice</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, WindowsVista and Windows Server2008 require that a calling process have Administrator privileges to install a driver on a device.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value that is specified for <i>Flags</i> is not zero or a bitwise OR of the valid flags.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-diinstalldevice
     * @since windows6.0.6000
     */
    static DiInstallDevice(hwndParent, DeviceInfoSet, DeviceInfoData, DriverInfoData, Flags, NeedReboot) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("newdev.dll\DiInstallDevice", "ptr", hwndParent, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiInstallDriver function preinstalls a driver in the driver store and then installs the driver on devices present in the system that the driver supports.
     * @param {HWND} hwndParent A handle to the top-level window that <b>DiInstallDriver</b> uses to display any user interface component that is associated with installing the device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {PWSTR} InfPath A pointer to a NULL-terminated string that supplies the fully qualified path of the INF file for the <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a>.
     * @param {Integer} Flags A value of type DWORD that specifies zero or DIIRFLAG_FORCE_INF. Typically, this flag should be set to zero. 
     * 
     * If this flag is zero, <b>DiInstallDriver</b> only installs the specified driver on a device if the driver is a better match for a device than the driver that is currently installed on a device. However, if this flag is set to DIIRFLAG_FORCE_INF, <b>DiInstallDriver</b> installs the specified driver on a matching device whether the driver is a better match for the device than the driver that is currently installed on the device. 
     * 
     * <div class="alert"><b>Caution</b>Forcing the installation of the driver can result in replacing a more compatible or newer driver with a less compatible or older driver. </div>
     * <div></div>
     * For information about how Windows selects a driver for a device, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>.
     * @param {Pointer<BOOL>} NeedReboot A pointer to a value of type BOOL that <b>DiInstallDriver</b> sets to indicate whether a system is restart is required to complete the installation. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the installation, <b>DiInstallDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the installation, <b>DiInstallDriver</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the installation, <b>DiInstallDriver</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {BOOL} <b>DiInstallDriver</b> returns <b>TRUE</b> if the function successfully preinstalled the specified <a href="/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="/windows-hardware/drivers/install/driver-store">driver store</a>. <b>DiInstallDriver</b> also returns <b>TRUE</b> if the function successfully installed the driver on one or more devices in the system. If the driver package is not successfully installed in the driver store, <b>DiInstallDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to preinstall a <a href="/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="/windows-hardware/drivers/install/driver-store">driver store</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path of the specified INF file does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or DIIRFLAG_FORCE_INF.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-diinstalldriverw
     * @since windows6.0.6000
     */
    static DiInstallDriverW(hwndParent, InfPath, Flags, NeedReboot) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        InfPath := InfPath is String ? StrPtr(InfPath) : InfPath

        A_LastError := 0

        result := DllCall("newdev.dll\DiInstallDriverW", "ptr", hwndParent, "ptr", InfPath, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiInstallDriver function preinstalls a driver in the driver store and then installs the driver on devices present in the system that the driver supports.
     * @param {HWND} hwndParent A handle to the top-level window that <b>DiInstallDriver</b> uses to display any user interface component that is associated with installing the device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {PSTR} InfPath A pointer to a NULL-terminated string that supplies the fully qualified path of the INF file for the <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a>.
     * @param {Integer} Flags A value of type DWORD that specifies zero or DIIRFLAG_FORCE_INF. Typically, this flag should be set to zero. 
     * 
     * If this flag is zero, <b>DiInstallDriver</b> only installs the specified driver on a device if the driver is a better match for a device than the driver that is currently installed on a device. However, if this flag is set to DIIRFLAG_FORCE_INF, <b>DiInstallDriver</b> installs the specified driver on a matching device whether the driver is a better match for the device than the driver that is currently installed on the device. 
     * 
     * <div class="alert"><b>Caution</b>Forcing the installation of the driver can result in replacing a more compatible or newer driver with a less compatible or older driver. </div>
     * <div></div>
     * For information about how Windows selects a driver for a device, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>.
     * @param {Pointer<BOOL>} NeedReboot A pointer to a value of type BOOL that <b>DiInstallDriver</b> sets to indicate whether a system is restart is required to complete the installation. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the installation, <b>DiInstallDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the installation, <b>DiInstallDriver</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the installation, <b>DiInstallDriver</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {BOOL} <b>DiInstallDriver</b> returns <b>TRUE</b> if the function successfully preinstalled the specified <a href="/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="/windows-hardware/drivers/install/driver-store">driver store</a>. <b>DiInstallDriver</b> also returns <b>TRUE</b> if the function successfully installed the driver on one or more devices in the system. If the driver package is not successfully installed in the driver store, <b>DiInstallDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to preinstall a <a href="/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="/windows-hardware/drivers/install/driver-store">driver store</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path of the specified INF file does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or DIIRFLAG_FORCE_INF.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-diinstalldrivera
     * @since windows6.0.6000
     */
    static DiInstallDriverA(hwndParent, InfPath, Flags, NeedReboot) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        InfPath := InfPath is String ? StrPtr(InfPath) : InfPath

        A_LastError := 0

        result := DllCall("newdev.dll\DiInstallDriverA", "ptr", hwndParent, "ptr", InfPath, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiUninstallDevice function uninstalls a device and removes its device node (devnode) from the system.
     * @param {HWND} hwndParent A handle to the top-level window that is used to display any user interface component that is associated with the uninstallation request for the device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element. This element represents the device to be uninstalled through this call.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the specified device in the specified device information set for which the uninstallation request is performed.
     * @param {Integer} Flags A value of type DWORD that specifies device uninstallation flags. Starting with Windows 7, this parameter must be set to zero.
     * @param {Pointer<BOOL>} NeedReboot A pointer to a value of type BOOL that <b>DiUninstallDevice</b> sets to indicate whether a system restart is required to complete the device uninstallation request. This parameter is optional and can be set to <b>NULL</b>.
     * 
     * If the parameter is given and a system restart is required, <b>DiUninstallDevice</b> sets the value to <b>TRUE</b>. In this case, the application must prompt the user to restart the system. If this parameter is supplied and a system restart is not required, <b>DiUninstallDevice</b> sets the value to <b>FALSE</b>. 
     * 
     * If this parameter is <b>NULL</b> and a system restart is required to complete the device uninstallation, <b>DiUninstallDevice</b> displays a system restart dialog box.
     * 
     * For more information about this parameter, see the <b>Remarks</b> section.
     * @returns {BOOL} <b>DiUninstallDevice</b> returns <b>TRUE</b> if the function successfully uninstalled the top-level device node that represents the device.  Otherwise, <b>DiUninstallDevice</b> returns <b>FALSE</b>, and the logged error can be retrieved by making a call to <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list shows some of the more common error values that <b>GetLastError</b> might return for this API:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to uninstall devices.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value that is specified for the <i>Flags</i> parameter is not equal to zero.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>The return value does not indicate that the removal of all child devnodes has succeeded or failed. Starting with Windows Vista, information about the status of the removal of child devnodes  is available in the <i>Setupapi.dev.log</i> file. For more information about this file, see <a href="/windows-hardware/drivers/install/setupapi-text-logs">SetupAPI Text Logs</a>.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-diuninstalldevice
     * @since windows6.1
     */
    static DiUninstallDevice(hwndParent, DeviceInfoSet, DeviceInfoData, Flags, NeedReboot) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("newdev.dll\DiUninstallDevice", "ptr", hwndParent, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HWND} hwndParent 
     * @param {PWSTR} InfPath 
     * @param {Integer} Flags 
     * @param {Pointer<BOOL>} NeedReboot 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-diuninstalldriverw
     * @since windows10.0.10240
     */
    static DiUninstallDriverW(hwndParent, InfPath, Flags, NeedReboot) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        InfPath := InfPath is String ? StrPtr(InfPath) : InfPath

        A_LastError := 0

        result := DllCall("newdev.dll\DiUninstallDriverW", "ptr", hwndParent, "ptr", InfPath, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiUninstallDriver function removes a driver package from any devices it is installed on by installing those devices with another matching driver package, if available, or the null driver if no other matching driver package is available. Then the specified driver package is removed from the driver store.
     * @param {HWND} hwndParent A handle to the top-level window that <b>DiUninstallDriver</b> should use to display any user interface component that is associated with uninstalling the driver. This parameter is optional and can be set to <b>NULL</b>.
     * @param {PSTR} InfPath A pointer to a NULL-terminated string that supplies the fully qualified path of the INF file for the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-packages">driver package</a>.
     * @param {Integer} Flags A value of type DWORD that specifies zero or one or more of the following flags: DIURFLAG_NO_REMOVE_INF. Typically, this flag should be set to zero. 
     * 
     * If this flag is zero, <b>DiUninstallDriver</b> removes the driver package from any devices it is installed on by installing those devices with another matching driver package, if available, or the null driver if no other matching driver package is available. However, if this flag is set to DIURFLAG_NO_REMOVE_INF, <b>DiUninstallDriver</b> removes the driver package from any devices it is installed on, but does not remove the driver package from the Driver Store.
     * 
     * <div class="alert"><b>Caution:</b>Forcing the uninstallation of the driver package can result in replacing a more compatible or newer driver package with a less compatible or older driver. </div>
     * <div></div>
     * 
     * For information about how Windows selects a driver package for a device, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>.
     * @param {Pointer<BOOL>} NeedReboot A pointer to a value of type BOOL that <b>DiUninstallDriver</b> sets to indicate whether a system restart is required to complete the uninstallation. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the uninstallation, <b>DiUninstallDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the uninstallation, <b>DiUninstallDriver</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the uninstallation, <b>DiUninstallDriver</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {BOOL} <b>DiUninstallDriver</b> returns <b>TRUE</b> if the function successfully removes the <a href="/windows-hardware/drivers/install/driver-packages">driver package</a> from any devices it is installed on and is successfully removed from the driver store of the system. If the driver package is not successfully uninstalled from the driver store, <b>DiUninstallDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to uninstall a <a href="/windows-hardware/drivers/install/driver-packages">driver package</a> from the <a href="/windows-hardware/drivers/install/driver-store">driver store</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path of the specified INF file does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or DIURFLAG_NO_REMOVE_INF.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-diuninstalldrivera
     */
    static DiUninstallDriverA(hwndParent, InfPath, Flags, NeedReboot) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        InfPath := InfPath is String ? StrPtr(InfPath) : InfPath

        A_LastError := 0

        result := DllCall("newdev.dll\DiUninstallDriverA", "ptr", hwndParent, "ptr", InfPath, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiShowUpdateDevice function displays the Hardware Update wizard for a specified device.
     * @param {HWND} hwndParent A handle to the top-level window that <b>DiShowUpdateDevice</b> uses to display any user interface components that are associated with updating the specified device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to show the Hardware Update wizard.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device for which to show the Hardware Update wizard.
     * @param {Integer} Flags This parameter must be set to zero.
     * @param {Pointer<BOOL>} NeedReboot A pointer to a value of type BOOL that <b>DiShowUpdateDevice</b> sets to indicate whether a system restart is required to complete the driver update. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the driver update, <b>DiShowUpdateDevice</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the installation, <b>DiShowUpdateDevice</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the driver update, <b>DiShowUpdateDevice</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {BOOL} <b>DiShowUpdateDevice</b> returns <b>TRUE</b> if the Hardware Update wizard successfully updated the driver for the specified device. Otherwise, <b>DiShowUpdateDevice</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some of the more common error values that <a href="/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the calling process have Administrator privileges to update a <a href="/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user canceled the Hardware Update wizard.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-dishowupdatedevice
     * @since windows6.0.6000
     */
    static DiShowUpdateDevice(hwndParent, DeviceInfoSet, DeviceInfoData, Flags, NeedReboot) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet

        A_LastError := 0

        result := DllCall("newdev.dll\DiShowUpdateDevice", "ptr", hwndParent, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiRollbackDriver function rolls back the driver that is installed on a specified device.
     * @param {HDEVINFO} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which driver rollback is performed.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the specific device in the specified device information set for which driver rollback is performed.
     * @param {HWND} hwndParent A handle to the top-level window that <b>DiRollbackDriver</b> uses to display any user interface component that is associated with a driver rollback for the specified device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags A value of type DWORD that can be set to zero or ROLLBACK_FLAG_NO_UI. 
     * 
     * Typically, this flag should be set to zero, in which case <b>DiRollbackDriver</b> does not suppress the default user interface components that are associated with a driver rollback. However, if this flag is set to ROLLBACK_FLAG_NO_UI, <b>DiRollbackDriver</b> suppresses the display of user interface components that are associated with a driver rollback.
     * @param {Pointer<BOOL>} NeedReboot A pointer to a value of type BOOL that <b>DiRollbackDriver</b> sets to indicate whether a system restart is required to complete the rollback. This parameter is optional and can be <b>NULL</b>. 
     * 
     * If the parameter is supplied and a system restart is required to complete the rollback, <b>DiRollbackDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the installation, <b>DiRollbackDriver</b> sets the value to <b>FALSE</b>. 
     * 
     * If the parameter is <b>NULL</b> and a system restart is required to complete the rollback, <b>DiRollbackDriver</b> displays a system restart dialog box. 
     * 
     * For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {BOOL} <b>DiRollbackDriver</b> returns <b>TRUE</b> if the function successfully rolled back the driver for the device; otherwise, <b>DiRollbackDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to roll back a <a href="/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or ROLLBACK_FLAG_NO_UI.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A backup driver is not set for the device.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//newdev/nf-newdev-dirollbackdriver
     * @since windows6.0.6000
     */
    static DiRollbackDriver(DeviceInfoSet, DeviceInfoData, hwndParent, Flags, NeedReboot) {
        DeviceInfoSet := DeviceInfoSet is Win32Handle ? NumGet(DeviceInfoSet, "ptr") : DeviceInfoSet
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        A_LastError := 0

        result := DllCall("newdev.dll\DiRollbackDriver", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", hwndParent, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HWND} hwndParent 
     * @param {PWSTR} FilePath 
     * @param {Integer} Flags 
     * @param {Pointer<BOOL>} NeedReboot 
     * @returns {BOOL} 
     */
    static DiShowUpdateDriver(hwndParent, FilePath, Flags, NeedReboot) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent
        FilePath := FilePath is String ? StrPtr(FilePath) : FilePath

        result := DllCall("newdev.dll\DiShowUpdateDriver", "ptr", hwndParent, "ptr", FilePath, "uint", Flags, "ptr", NeedReboot, "int")
        return result
    }

;@endregion Methods
}
