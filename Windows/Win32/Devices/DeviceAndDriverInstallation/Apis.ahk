#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.Devices.DeviceAndDriverInstallation
 * @version v4.0.30319
 */
class DeviceAndDriverInstallation {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V1 => 37

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V2 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V3 => 51

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V4 => 52

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V5 => 53

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V6 => 54

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V7 => 55

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V8 => 57

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB_V9 => 58

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_CM_PROB => 58

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_FORCECONFIG => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_BOOTCONFIG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_DESIRED => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_NORMAL => 12288

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_LASTBESTCONFIG => 16383

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_SUBOPTIMAL => 20480

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_LASTSOFTCONFIG => 32767

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_RESTART => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_REBOOT => 36864

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_POWEROFF => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_HARDRECONFIG => 49152

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_HARDWIRED => 57344

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_IMPOSSIBLE => 61440

    /**
     * @type {Integer (UInt32)}
     */
    static LCPRI_DISABLED => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LCPRI => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_TOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_BOTTOM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_LEFT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_RIGHT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_FRONT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SIDE_BACK => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_TOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_BOTTOM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_LEFT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_EDGE_RIGHT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SHAPE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SHAPE_RECTANGLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_SHAPE_OVAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_ORIENTATION_HORIZONTAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_ORIENTATION_VERTICAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_PLANAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_HINGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_PIVOT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DEVICE_PANEL_JOINT_TYPE_SWIVEL => 4

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_1394 => "{6bdd1fc1-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_1394DEBUG => "{66f250d6-7801-4a64-b139-eea80a450b24}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_61883 => "{7ebefbc0-3200-11d2-b4c2-00a0c9697d07}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_ADAPTER => "{4d36e964-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_APMSUPPORT => "{d45b1c18-c8fa-11d1-9f77-0000f805f530}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_AVC => "{c06ff265-ae09-48f0-812c-16753d7cba83}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_BATTERY => "{72631e54-78a4-11d0-bcf7-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_BIOMETRIC => "{53d29ef7-377c-4d14-864b-eb3a85769359}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_BLUETOOTH => "{e0cbf06c-cd8b-4647-bb8a-263b43f0f974}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_CAMERA => "{ca3e7ab9-b4c3-4ae6-8251-579ef933890f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_CDROM => "{4d36e965-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_COMPUTEACCELERATOR => "{f01a9d53-3ff6-48d2-9f97-c8a7004be10c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_COMPUTER => "{4d36e966-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DECODER => "{6bdd1fc2-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DISKDRIVE => "{4d36e967-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DISPLAY => "{4d36e968-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DOT4 => "{48721b56-6795-11d2-b1a8-0080c72e74a2}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_DOT4PRINT => "{49ce6ac8-6f86-11d2-b1e5-0080c72e74a2}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_EHSTORAGESILO => "{9da2b80f-f89f-4a49-a5c2-511b085b9e8a}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_ENUM1394 => "{c459df55-db08-11d1-b009-00a0c9081ff6}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_EXTENSION => "{e2f84ce7-8efa-411c-aa69-97454ca4cb57}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FDC => "{4d36e969-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FIRMWARE => "{f2e7dd72-6468-4e36-b6f1-6488f42c1b52}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FLOPPYDISK => "{4d36e980-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_GENERIC => "{ff494df1-c4ed-4fac-9b3f-3786f6e91e7e}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_GPS => "{6bdd1fc3-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_HDC => "{4d36e96a-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_HIDCLASS => "{745a17a0-74d3-11d0-b6fe-00a0c90f57da}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_HOLOGRAPHIC => "{d612553d-06b1-49ca-8938-e39ef80eb16f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_IMAGE => "{6bdd1fc6-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_INFINIBAND => "{30ef7132-d858-4a0c-ac24-b9028a5cca3f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_INFRARED => "{6bdd1fc5-810f-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_KEYBOARD => "{4d36e96b-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_LEGACYDRIVER => "{8ecc055d-047f-11d1-a537-0000f8753ed1}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MEDIA => "{4d36e96c-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MEDIUM_CHANGER => "{ce5939ae-ebde-11d0-b181-0000f8753ec4}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MEMORY => "{5099944a-f6b9-4057-a056-8c550228544c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MODEM => "{4d36e96d-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MONITOR => "{4d36e96e-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MOUSE => "{4d36e96f-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MTD => "{4d36e970-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MULTIFUNCTION => "{4d36e971-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_MULTIPORTSERIAL => "{50906cb8-ba12-11d1-bf5d-0000f805f530}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NET => "{4d36e972-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETCLIENT => "{4d36e973-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETDRIVER => "{87ef9ad1-8f70-49ee-b215-ab1fcadcbe3c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETSERVICE => "{4d36e974-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETTRANS => "{4d36e975-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NETUIO => "{78912bc1-cb8e-4b28-a329-f322ebadbe0f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_NODRIVER => "{4d36e976-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PCMCIA => "{4d36e977-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PNPPRINTERS => "{4658ee7e-f050-11d1-b6bd-00c04fa372a7}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PORTS => "{4d36e978-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PRIMITIVE => "{242681d1-eed3-41d2-a1ef-1468fc843106}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PRINTER => "{4d36e979-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PRINTERUPGRADE => "{4d36e97a-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PRINTQUEUE => "{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_PROCESSOR => "{50127dc3-0f36-415e-a6cc-4cb3be910b65}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SBP2 => "{d48179be-ec20-11d1-b6b8-00c04fa372a7}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SCMDISK => "{53966cb1-4d46-4166-bf23-c522403cd495}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SCMVOLUME => "{53ccb149-e543-4c84-b6e0-bce4f6b7e806}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SCSIADAPTER => "{4d36e97b-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SECURITYACCELERATOR => "{268c95a1-edfe-11d3-95c3-0010dc4050a5}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SENSOR => "{5175d334-c371-4806-b3ba-71fd53c9258d}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SIDESHOW => "{997b5d8d-c442-4f2e-baf3-9c8e671e9e21}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SMARTCARDREADER => "{50dd5230-ba8a-11d1-bf5d-0000f805f530}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SMRDISK => "{53487c23-680f-4585-acc3-1f10d6777e82}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SMRVOLUME => "{53b3cf03-8f5a-4788-91b6-d19ed9fcccbf}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SOFTWARECOMPONENT => "{5c4c3332-344d-483c-8739-259e934c9cc8}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SOUND => "{4d36e97c-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_SYSTEM => "{4d36e97d-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_TAPEDRIVE => "{6d807884-7d21-11cf-801c-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_UNKNOWN => "{4d36e97e-e325-11ce-bfc1-08002be10318}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_UCM => "{e6f1aa1c-7f3b-4473-b2e8-c97d8ac71d53}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_USB => "{36fc9e60-c465-11cf-8056-444553540000}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_VOLUME => "{71a27cdd-812a-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_VOLUMESNAPSHOT => "{533c5b84-ec70-11d2-9505-00c04f79deaf}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_WCEUSBS => "{25dbce51-6c8f-4a72-8a6d-b54c2b4fc835}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_WPD => "{eec5ad98-8080-425f-922a-dabf3de3f69a}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_TOP => "{b369baf4-5568-4e82-a87e-a93eb16bca87}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_ACTIVITYMONITOR => "{b86dff51-a31e-4bac-b3cf-e8cfe75c9fc2}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_UNDELETE => "{fe8f1572-c67a-48c0-bbac-0b5c6d66cafb}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_ANTIVIRUS => "{b1d1a169-c54f-4379-81db-bee7d88d7454}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_REPLICATION => "{48d3ebc4-4cf8-48ff-b869-9c68ad42eb9f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_CONTINUOUSBACKUP => "{71aa14f8-6fad-4622-ad77-92bb9d7e6947}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_CONTENTSCREENER => "{3e3f0674-c83c-4558-bb26-9820e1eba5c5}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_QUOTAMANAGEMENT => "{8503c911-a6c7-4919-8f79-5028f5866b0c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_SYSTEMRECOVERY => "{2db15374-706e-4131-a0c7-d7c78eb0289a}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_CFSMETADATASERVER => "{cdcf0939-b75b-4630-bf76-80f7ba655884}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_HSM => "{d546500a-2aeb-45f6-9482-f4b1799c3177}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_COMPRESSION => "{f3586baf-b5aa-49b5-8d6c-0569284c639f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_ENCRYPTION => "{a0a701c0-a511-42ff-aa6c-06dc0395576f}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_VIRTUALIZATION => "{f75a86c0-10d8-4c3a-b233-ed60e4cdfaac}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_PHYSICALQUOTAMANAGEMENT => "{6a0a8e78-bba6-4fc4-a709-1e33cd09d67e}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_OPENFILEBACKUP => "{f8ecafa6-66d1-41a5-899b-66585d7216b7}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_SECURITYENHANCER => "{d02bc3da-0c8e-4945-9bd5-f1883c226c8c}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_COPYPROTECTION => "{89786ff1-9c12-402f-9c9e-17753c7f4375}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_BOTTOM => "{37765ea0-5958-4fc9-b04b-2fdfef97e59e}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_SYSTEM => "{5d1b9aaa-01e2-46af-849f-272b3f324c46}"

    /**
     * @type {String}
     */
    static GUID_DEVCLASS_FSFILTER_INFRASTRUCTURE => "{e55fa6f9-128c-4d04-abab-630c74b1453a}"

    /**
     * @type {Integer (UInt32)}
     */
    static LINE_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INF_STRING_LENGTH => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INF_SECTION_NAME_LENGTH => 255

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_TITLE_LEN => 60

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INSTRUCTION_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LABEL_LEN => 30

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SERVICE_NAME_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SUBTITLE_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SP_MAX_MACHINENAME_LENGTH => 263

    /**
     * @type {Integer (UInt32)}
     */
    static SP_ALTPLATFORM_FLAGS_VERSION_RANGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SP_ALTPLATFORM_FLAGS_SUITE_MASK => 2

    /**
     * @type {Integer (Int32)}
     */
    static DIRID_ABSOLUTE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_ABSOLUTE_16BIT => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_NULL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SRCPATH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_WINDOWS => 10

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SYSTEM => 11

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_DRIVERS => 12

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_IOSUBSYS => 12

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_DRIVER_STORE => 13

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_INF => 17

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_HELP => 18

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_FONTS => 20

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_VIEWERS => 21

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COLOR => 23

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_APPS => 24

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SHARED => 25

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_BOOT => 30

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SYSTEM16 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SPOOL => 51

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SPOOLDRIVERS => 52

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_USERPROFILE => 53

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_LOADER => 54

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PRINTPROCESSOR => 55

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_DEFAULT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_STARTMENU => 16406

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_PROGRAMS => 16407

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_STARTUP => 16408

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_DESKTOPDIRECTORY => 16409

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_FAVORITES => 16415

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_APPDATA => 16419

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PROGRAM_FILES => 16422

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_SYSTEM_X86 => 16425

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PROGRAM_FILES_X86 => 16426

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PROGRAM_FILES_COMMON => 16427

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_PROGRAM_FILES_COMMONX86 => 16428

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_TEMPLATES => 16429

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_COMMON_DOCUMENTS => 16430

    /**
     * @type {Integer (UInt32)}
     */
    static DIRID_USER => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTQUEUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDQUEUE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTSUBQUEUE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDSUBQUEUE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTDELETE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDDELETE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_DELETEERROR => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTRENAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDRENAME => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_RENAMEERROR => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTCOPY => 11

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDCOPY => 12

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_COPYERROR => 13

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_NEEDMEDIA => 14

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_QUEUESCAN => 15

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_CABINETINFO => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_FILEINCABINET => 17

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_NEEDNEWCABINET => 18

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_FILEEXTRACTED => 19

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_FILEOPDELAYED => 20

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTBACKUP => 21

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_BACKUPERROR => 22

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDBACKUP => 23

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_QUEUESCAN_EX => 24

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_STARTREGISTRATION => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_ENDREGISTRATION => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_QUEUESCAN_SIGNERINFO => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_LANGMISMATCH => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_TARGETEXISTS => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILENOTIFY_TARGETNEWER => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_RENAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_BACKUP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_ABORT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_DOIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_SKIP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_RETRY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FILEOP_NEWPATH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_WARN_IF_SKIP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NOSKIP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NOVERSIONCHECK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_FORCE_FILE_IN_USE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NO_OVERWRITE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NO_VERSION_DIALOG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_OVERWRITE_OLDER_ONLY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_PROTECTED_WINDOWS_DRIVER_FILE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_REPLACEONLY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NODECOMP => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_REPLACE_BOOT_FILE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_NOPRUNE => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFLG_IN_USE_TRY_RENAME => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static DELFLG_IN_USE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DELFLG_IN_USE1 => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_SUCCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_LOADLIBRARY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_GETPROCADDR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_REGSVR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_DLLINSTALL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_TIMEOUT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SPREG_UNKNOWN => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static SPINT_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPINT_DEFAULT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPINT_REMOVED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPID_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPID_DEFAULT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPID_REMOVED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ENABLECLASS_QUERY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ENABLECLASS_SUCCESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ENABLECLASS_FAILURE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INSTALLWIZARD_DYNAPAGES => 20

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_DIDFACTDEFS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_HARDWAREALLREADYIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_NEEDSHUTDOWN => 512

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_EXPRESSINTRO => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_SKIPISDEVINSTALLED => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_NODETECTEDDEVS => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_INSTALLSPECIFIC => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_SKIPCLASSLIST => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_CI_PICKED_OEM => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_PCMCIAMODE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_PCMCIADEVICE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_USERCANCEL => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static NDW_INSTALLFLAG_KNOWNCLASS => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static DYNAWIZ_FLAG_PAGESADDED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static DYNAWIZ_FLAG_INSTALLDET_NEXT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DYNAWIZ_FLAG_INSTALLDET_PREV => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MIN_IDD_DYNAWIZ_RESOURCE_ID => 10000

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IDD_DYNAWIZ_RESOURCE_ID => 11000

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_FIRSTPAGE => 10000

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_SELECT_PREVPAGE => 10001

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_SELECT_NEXTPAGE => 10002

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_ANALYZE_PREVPAGE => 10003

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_ANALYZE_NEXTPAGE => 10004

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_SELECTDEV_PAGE => 10009

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_ANALYZEDEV_PAGE => 10010

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE => 10011

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_SELECTCLASS_PAGE => 10012

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE => 10006

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE => 10007

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_DYNAWIZ_INSTALLDETECTED_NODEVS => 10008

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_HARDWAREID_RANK => 4095

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_HARDWAREID_MASK => 2147487743

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_UNTRUSTED_RANK => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_W9X_SUSPECT_RANK => 3221225472

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_COMPATID_RANK => 16383

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_UNTRUSTED_HARDWAREID_RANK => 36863

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_UNTRUSTED_COMPATID_RANK => 49151

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_W9X_SUSPECT_HARDWAREID_RANK => 53247

    /**
     * @type {Integer (UInt32)}
     */
    static DRIVER_W9X_SUSPECT_COMPATID_RANK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static SPPSR_SELECT_DEVICE_RESOURCES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPPSR_ENUM_BASIC_DEVICE_PROPERTIES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPPSR_ENUM_ADV_DEVICE_PROPERTIES => 3

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_INF_SPEC_IS_HINF => 1

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_INF_NAME_IS_ABSOLUTE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_DEFAULT_SEARCH => 3

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_REVERSE_DEFAULT_SEARCH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static INFINFO_INF_PATH_LIST_SEARCH => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_TEMPORARY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_NOBROWSE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_SYSTEM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_USER => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_SYSIFADMIN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_SUBDIRS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_APPEND => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SRCLIST_NOSTRIPPLATFORM => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOBROWSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOSKIP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NODETAILS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOCOMPRESSED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_CHECKFIRST => 256

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOBEEP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOFOREGROUND => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_WARNIFSKIP => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_NOREMOVABLEMEDIAPROMPT => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_USEDISKNAMEASPROMPT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static IDF_OEMDISK => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_SUCCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_CANCEL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_SKIPFILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_BUFFERTOOSMALL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DPROMPT_OUTOFMEMORY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SETDIRID_NOT_FULL_PATH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_PATH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_TAGFILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_DESCRIPTION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_FLAGS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SRCINFO_TAGFILE2 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SRC_FLAGS_CABFILE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SP_FLAG_CABINETCONTINUATION => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SP_BACKUP_BACKUPPASS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SP_BACKUP_DEMANDPASS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SP_BACKUP_SPECIAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SP_BACKUP_BOOTFILE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_DELAYED_COPY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_BACKUP_AWARE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_ABORT_IF_UNSIGNED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_FILES_MODIFIED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_DO_SHUFFLEMOVE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPQ_FLAG_VALID => 15

    /**
     * @type {Integer (UInt32)}
     */
    static SPOST_MAX => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SUOI_FORCEDELETE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SUOI_INTERNAL1 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPDSL_IGNORE_DISK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPDSL_DISALLOW_NEGATIVE_ADJUST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILEQ_FILE_IN_USE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILEQ_REBOOT_RECOMMENDED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILEQ_REBOOT_IN_PROGRESS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_DELREG_BIT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_BINVALUETYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_NOCLOBBER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_DELVAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_APPEND => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_KEYONLY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_OVERWRITEONLY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_64BITKEY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_KEYONLY_COMMON => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_32BITKEY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_TYPE_SZ => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_TYPE_MULTI_SZ => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDREG_TYPE_EXPAND_SZ => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_VALUE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_TYPE_SZ => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_TYPE_MULTI_SZ => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_TYPE_EXPAND_SZ => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_64BITKEY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_KEYONLY_COMMON => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_32BITKEY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELREG_OPERATION_MASK => 254

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_BITREG_CLEARBITS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_BITREG_SETBITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_BITREG_64BITKEY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_BITREG_32BITKEY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_INI2REG_64BITKEY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_INI2REG_32BITKEY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_REGSVR_DLLREGISTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_REGSVR_DLLINSTALL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_PROFITEM_CURRENTUSER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_PROFITEM_DELETE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_PROFITEM_GROUP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_PROFITEM_CSIDL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_NOCLOBBER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_OVERWRITEONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_APPEND => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_OR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_ADDPROPERTY_AND => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FLG_DELPROPERTY_MULTI_SZ_DELSTRING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_LOGCONFIG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_INIFILES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_REGISTRY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_INI2REG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_FILES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_BITREG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_REGSVR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_UNREGSVR => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_PROFILEITEMS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_COPYINF => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_PROPERTIES => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_ALL => 2047

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_SINGLESECTION => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_LOGCONFIG_IS_FORCED => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_LOGCONFIGS_ARE_OVERRIDES => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_REGISTERCALLBACKAWARE => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static SPINST_DEVICEINSTALL => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILELOG_SYSTEMLOG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILELOG_FORCENEW => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILELOG_QUERYONLY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPFILELOG_OEMFILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevInformation => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevWarning => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevError => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevFatalError => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LogSevMaximum => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DIOD_INHERIT_CLASSDRVS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIOD_CANCEL_REMOVE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DIODI_NO_ADD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPRDI_FIND_DUPS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPDIT_NODRIVER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DIBCI_NOINSTALLCLASS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIBCI_NODISPLAYCLASS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIOCR_INSTALLER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIOCR_INTERFACE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIREG_DEV => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIREG_DRV => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIREG_BOTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DICLASSPROP_INSTALLER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DICLASSPROP_INTERFACE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_UPPERFILTERS => 17

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_LOWERFILTERS => 18

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_SECURITY => 23

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_SECURITY_SDS => 24

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_DEVTYPE => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_EXCLUSIVE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_CHARACTERISTICS => 27

    /**
     * @type {Integer (UInt32)}
     */
    static SPCRP_MAXIMUM_PROPERTY => 28

    /**
     * @type {Integer (UInt32)}
     */
    static DMI_MASK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DMI_BKCOLOR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DMI_USERECT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DIGCDP_FLAG_BASIC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DIGCDP_FLAG_ADVANCED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DIGCDP_FLAG_REMOTE_BASIC => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DIGCDP_FLAG_REMOTE_ADVANCED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCEFIRST => 159

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCE => 159

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCELAST => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCEOVERLAYFIRST => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_RESOURCEOVERLAYLAST => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_CONFLICT => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_CLASSICON_OVERLAYFIRST => 500

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_CLASSICON_OVERLAYLAST => 502

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_PROBLEM_OVL => 500

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_DISABLED_OVL => 501

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_FORCED_OVL => 502

    /**
     * @type {Integer (UInt32)}
     */
    static SPWPT_SELECTDEVICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPWP_USE_DEVINFO_DATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_UNKNOWN => 4278190080

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_W9X_SUSPECT => 3221225472

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_UNSIGNED => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_AUTHENTICODE => 251658240

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_WHQL => 218103813

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_UNCLASSIFIED => 218103812

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_INBOX => 218103811

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_LOGO_STANDARD => 218103810

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_LOGO_PREMIUM => 218103809

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_MASK => 4278190080

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNERSCORE_SIGNED_MASK => 4026531840

    /**
     * @type {Integer (UInt32)}
     */
    static DICUSTOMDEVPROP_MERGE_MULTISZ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SCWMI_CLOBBER_SECURITY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DEVICE_ID_LEN => 200

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DEVNODE_ID_LEN => 200

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_GUID_STRING_LEN => 39

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_CLASS_NAME_LEN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_PROFILE_LEN => 80

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_CONFIG_VALUE => 9999

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INSTANCE_VALUE => 9999

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MEM_REGISTERS => 9

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IO_PORTS => 20

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IRQS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DMA_CHANNELS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static DWORD_MAX => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CONFIGMG_VERSION => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IO_ALIAS_10_BIT_DECODE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IO_ALIAS_12_BIT_DECODE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IO_ALIAS_16_BIT_DECODE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IO_ALIAS_POSITIVE_DECODE => 255

    /**
     * @type {Integer (UInt32)}
     */
    static IOA_Local => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CM_RESDES_WIDTH_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_RESDES_WIDTH_32 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_RESDES_WIDTH_64 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_RESDES_WIDTH_BITS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PCD_MAX_MEMORY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PCD_MAX_IO => 2

    /**
     * @type {Integer (UInt32)}
     */
    static mPMF_AUDIO_ENABLE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_HWPI_NOT_DOCKABLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_HWPI_UNDOCKED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_HWPI_DOCKED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_RANGE_ADDIFCONFLICT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_RANGE_DONOTADDIFCONFLICT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_RANGE_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOG_CONF_BITS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PRIORITY_EQUAL_FIRST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PRIORITY_EQUAL_LAST => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PRIORITY_BIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RegDisposition_OpenAlways => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RegDisposition_OpenExisting => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RegDisposition_Bits => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_ID_HARDWARE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_ID_COMPATIBLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_ADD_ID_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_NO_WAIT_INSTALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_PHANTOM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_GENERATE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_DO_NOT_INSTALL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVNODE_BITS => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_NO_WAIT_INSTALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_PHANTOM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_GENERATE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_DO_NOT_INSTALL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CREATE_DEVINST_BITS => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DELETE_CLASS_ONLY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DELETE_CLASS_SUBKEYS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DELETE_CLASS_INTERFACE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DELETE_CLASS_BITS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_NEW_PROFILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_CRASHED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_HWPROF_FIRST_BOOT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_RUN => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DETECT_BITS => 2147483655

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_POLITE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_ABSOLUTE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_HARDWARE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_UI_NOT_OK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_PERSIST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DISABLE_BITS => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_ENUMERATOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_SERVICE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_EJECTRELATIONS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_REMOVALRELATIONS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_POWERRELATIONS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_BUSRELATIONS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_DONOTGENERATE => 268435520

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_BITS => 268435583

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_TRANSPORTRELATIONS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_PRESENT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GETIDLIST_FILTER_CLASS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_DEVICEDESC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_HARDWAREID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_COMPATIBLEIDS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UNUSED0 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_SERVICE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UNUSED1 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UNUSED2 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CLASS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CLASSGUID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_DRIVER => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CONFIGFLAGS => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_MFG => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_FRIENDLYNAME => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_LOCATION_INFORMATION => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CAPABILITIES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UI_NUMBER => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UPPERFILTERS => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_UPPERFILTERS => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_LOWERFILTERS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_LOWERFILTERS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_BUSTYPEGUID => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_LEGACYBUSTYPE => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_BUSNUMBER => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_ENUMERATOR_NAME => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_SECURITY => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_SECURITY => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_SECURITY_SDS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_SECURITY_SDS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_DEVTYPE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_DEVTYPE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_EXCLUSIVE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_EXCLUSIVE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_CHARACTERISTICS => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_CHARACTERISTICS => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_ADDRESS => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_UI_NUMBER_DESC_FORMAT => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_DEVICE_POWER_DATA => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_REMOVAL_POLICY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_REMOVAL_POLICY_HW_DEFAULT => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_REMOVAL_POLICY_OVERRIDE => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_INSTALL_STATE => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_LOCATION_PATHS => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_BASE_CONTAINERID => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_MIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_MIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_DRP_MAX => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CRP_MAX => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CM_OPEN_CLASS_KEY_INSTALLER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_OPEN_CLASS_KEY_INTERFACE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_OPEN_CLASS_KEY_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_UI_OK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_UI_NOT_OK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_NO_RESTART => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_DISABLE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REMOVE_BITS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_REMOVE_UI_OK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_REMOVE_UI_NOT_OK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTER_DEVICE_DRIVER_STATIC => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTER_DEVICE_DRIVER_DISABLEABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTER_DEVICE_DRIVER_REMOVABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTER_DEVICE_DRIVER_BITS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_HARDWARE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_SOFTWARE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_USER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_CONFIG => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CM_REGISTRY_BITS => 769

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVNODE_PROBLEM_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVNODE_PROBLEM_OVERRIDE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVNODE_PROBLEM_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVINST_PROBLEM_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVINST_PROBLEM_OVERRIDE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_DEVINST_PROBLEM_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_HW_PROF_FLAGS_UI_NOT_OK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SET_HW_PROF_FLAGS_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_READY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_READY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DOWNLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_WRITE_LOG_CONFS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_PROP_CHANGE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_RESET => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_RESET => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_CONFIG => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_CONFIG => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_CONFIG_CLASS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_CONFIG_CLASS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_CONFIG_EXTENSIONS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_CONFIG_EXTENSIONS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVNODE_CONFIG_RESET => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_DEVINST_CONFIG_RESET => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_SETUP_BITS => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_ARBITRATOR_RAW => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_ARBITRATOR_TRANSLATED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_QUERY_ARBITRATOR_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CUSTOMDEVPROP_MERGE_MULTISZ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CUSTOMDEVPROP_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_NAME_ATTRIBUTE_NAME_RETRIEVED_FROM_DEVICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_NAME_ATTRIBUTE_USER_ASSIGNED_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CLASS_PROPERTY_INSTALLER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CLASS_PROPERTY_INTERFACE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_CLASS_PROPERTY_BITS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_NOTIFY_FILTER_FLAG_ALL_INTERFACE_CLASSES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_NOTIFY_FILTER_FLAG_ALL_DEVICE_INSTANCES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_CAN_DO_UI => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_ON_BIG_STACK => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_SERVICES_AVAILABLE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_SHUTTING_DOWN => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_DETECTION_PENDING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CM_GLOBAL_STATE_REBOOT_REQUIRED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_KEY_LEN => 100

    /**
     * @type {String}
     */
    static SZ_KEY_OPTIONDESC => "OptionDesc"

    /**
     * @type {String}
     */
    static SZ_KEY_LDIDOEM => "LdidOEM"

    /**
     * @type {String}
     */
    static SZ_KEY_SRCDISKFILES => "SourceDisksFiles"

    /**
     * @type {String}
     */
    static SZ_KEY_SRCDISKNAMES => "SourceDisksNames"

    /**
     * @type {String}
     */
    static SZ_KEY_STRINGS => "Strings"

    /**
     * @type {String}
     */
    static SZ_KEY_DESTDIRS => "DestinationDirs"

    /**
     * @type {String}
     */
    static SZ_KEY_LAYOUT_FILE => "LayoutFile"

    /**
     * @type {String}
     */
    static SZ_KEY_DEFDESTDIR => "DefaultDestDir"

    /**
     * @type {String}
     */
    static SZ_KEY_LFN_SECTION => "VarLDID.LFN"

    /**
     * @type {String}
     */
    static SZ_KEY_SFN_SECTION => "VarLDID.SFN"

    /**
     * @type {String}
     */
    static SZ_KEY_UPDATEINIS => "UpdateInis"

    /**
     * @type {String}
     */
    static SZ_KEY_UPDATEINIFIELDS => "UpdateIniFields"

    /**
     * @type {String}
     */
    static SZ_KEY_INI2REG => "Ini2Reg"

    /**
     * @type {String}
     */
    static SZ_KEY_COPYFILES => "CopyFiles"

    /**
     * @type {String}
     */
    static SZ_KEY_RENFILES => "RenFiles"

    /**
     * @type {String}
     */
    static SZ_KEY_DELFILES => "DelFiles"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDREG => "AddReg"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDREGNOCLOBBER => "AddRegNoClobber"

    /**
     * @type {String}
     */
    static SZ_KEY_DELREG => "DelReg"

    /**
     * @type {String}
     */
    static SZ_KEY_BITREG => "BitReg"

    /**
     * @type {String}
     */
    static SZ_KEY_COPYINF => "CopyINF"

    /**
     * @type {String}
     */
    static SZ_KEY_LOGCONFIG => "LogConfig"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDSERVICE => "AddService"

    /**
     * @type {String}
     */
    static SZ_KEY_DELSERVICE => "DelService"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDTRIGGER => "AddTrigger"

    /**
     * @type {String}
     */
    static SZ_KEY_FAILUREACTIONS => "FailureActions"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDINTERFACE => "AddInterface"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDIME => "AddIme"

    /**
     * @type {String}
     */
    static SZ_KEY_DELIME => "DelIme"

    /**
     * @type {String}
     */
    static SZ_KEY_REGSVR => "RegisterDlls"

    /**
     * @type {String}
     */
    static SZ_KEY_UNREGSVR => "UnregisterDlls"

    /**
     * @type {String}
     */
    static SZ_KEY_PROFILEITEMS => "ProfileItems"

    /**
     * @type {String}
     */
    static SZ_KEY_MODULES => "Modules"

    /**
     * @type {String}
     */
    static SZ_KEY_DEFAULTOPTION => "DefaultOption"

    /**
     * @type {String}
     */
    static SZ_KEY_LISTOPTIONS => "ListOptions"

    /**
     * @type {String}
     */
    static SZ_KEY_CLEANONLY => "CleanOnly"

    /**
     * @type {String}
     */
    static SZ_KEY_UPGRADEONLY => "UpgradeOnly"

    /**
     * @type {String}
     */
    static SZ_KEY_EXCLUDEID => "ExcludeId"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDPOWERSETTING => "AddPowerSetting"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDPROP => "AddProperty"

    /**
     * @type {String}
     */
    static SZ_KEY_DELPROP => "DelProperty"

    /**
     * @type {String}
     */
    static SZ_KEY_FEATURESCORE => "FeatureScore"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDEVENTPROVIDER => "AddEventProvider"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDCHANNEL => "AddChannel"

    /**
     * @type {String}
     */
    static SZ_KEY_IMPORTCHANNEL => "ImportChannel"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDAUTOLOGGER => "AddAutoLogger"

    /**
     * @type {String}
     */
    static SZ_KEY_UPDATEAUTOLOGGER => "UpdateAutoLogger"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDAUTOLOGGERPROVIDER => "AddAutoLoggerProvider"

    /**
     * @type {String}
     */
    static SZ_KEY_ADDFILTER => "AddFilter"

    /**
     * @type {String}
     */
    static SZ_KEY_FILTERLEVEL => "FilterLevel"

    /**
     * @type {String}
     */
    static SZ_KEY_FILTERPOSITION => "FilterPosition"

    /**
     * @type {String}
     */
    static SZ_KEY_PHASE1 => "Phase1"

    /**
     * @type {String}
     */
    static SZ_KEY_HARDWARE => "Hardware"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CONFIGPRIORITY => "ConfigPriority"

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_PRIORITYSTR_LEN => 16

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_HARDWIRED => "HARDWIRED"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_DESIRED => "DESIRED"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_NORMAL => "NORMAL"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_SUBOPTIMAL => "SUBOPTIMAL"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_DISABLED => "DISABLED"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_RESTART => "RESTART"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_REBOOT => "REBOOT"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_POWEROFF => "POWEROFF"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_HARDRECONFIG => "HARDRECONFIG"

    /**
     * @type {String}
     */
    static INFSTR_CFGPRI_FORCECONFIG => "FORCECONFIG"

    /**
     * @type {String}
     */
    static INFSTR_CFGTYPE_BASIC => "BASIC"

    /**
     * @type {String}
     */
    static INFSTR_CFGTYPE_FORCED => "FORCED"

    /**
     * @type {String}
     */
    static INFSTR_CFGTYPE_OVERRIDE => "OVERRIDE"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MEMCONFIG => "MemConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MEMLARGECONFIG => "MemLargeConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_IOCONFIG => "IOConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_IRQCONFIG => "IRQConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DMACONFIG => "DMAConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PCCARDCONFIG => "PcCardConfig"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MFCARDCONFIG => "MfCardConfig"

    /**
     * @type {String}
     */
    static INFSTR_SECT_CLASS_INSTALL => "ClassInstall"

    /**
     * @type {String}
     */
    static INFSTR_SECT_CLASS_INSTALL_32 => "ClassInstall32"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DEFAULT_INSTALL => "DefaultInstall"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DEFAULT_UNINSTALL => "DefaultUninstall"

    /**
     * @type {String}
     */
    static INFSTR_SECT_INTERFACE_INSTALL_32 => "InterfaceInstall32"

    /**
     * @type {String}
     */
    static INFSTR_SECT_VERSION => "Version"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PROVIDER => "Provider"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SIGNATURE => "Signature"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DRIVERSET => "DriverSet"

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INF_FLAG => 20

    /**
     * @type {String}
     */
    static INFSTR_KEY_HARDWARE_CLASS => "Class"

    /**
     * @type {String}
     */
    static INFSTR_KEY_HARDWARE_CLASSGUID => "ClassGUID"

    /**
     * @type {String}
     */
    static INFSTR_KEY_NOSETUPINF => "NoSetupInf"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FROMINET => "FromINet"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CATALOGFILE => "CatalogFile"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PNPLOCKDOWN => "PnpLockDown"

    /**
     * @type {String}
     */
    static INFSTR_KEY_EXTENSIONID => "ExtensionId"

    /**
     * @type {String}
     */
    static INFSTR_SECT_MFG => "Manufacturer"

    /**
     * @type {String}
     */
    static INFSTR_SECT_TARGETCOMPUTERS => "TargetComputers"

    /**
     * @type {String}
     */
    static INFSTR_SECT_EXTENSIONCONTRACTS => "ExtensionContracts"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CLASS => "Class"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CLASSGUID => "ClassGUID"

    /**
     * @type {String}
     */
    static INFSTR_RESTART => "Restart"

    /**
     * @type {String}
     */
    static INFSTR_REBOOT => "Reboot"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DISPLAYNAME => "DisplayName"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SERVICETYPE => "ServiceType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_STARTTYPE => "StartType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ERRORCONTROL => "ErrorControl"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SERVICEBINARY => "ServiceBinary"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOADORDERGROUP => "LoadOrderGroup"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DEPENDENCIES => "Dependencies"

    /**
     * @type {String}
     */
    static INFSTR_KEY_REQUIREDPRIVILEGES => "RequiredPrivileges"

    /**
     * @type {String}
     */
    static INFSTR_KEY_STARTNAME => "StartName"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SECURITY => "Security"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DESCRIPTION => "Description"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SERVICESIDTYPE => "ServiceSidType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DELAYEDAUTOSTART => "DelayedAutoStart"

    /**
     * @type {String}
     */
    static INFSTR_KEY_TRIGGER_TYPE => "TriggerType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ACTION => "Action"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SUB_TYPE => "SubType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DATA_ITEM => "DataItem"

    /**
     * @type {String}
     */
    static INFSTR_KEY_RESET_PERIOD => "ResetPeriod"

    /**
     * @type {String}
     */
    static INFSTR_KEY_NON_CRASH_FAILURES => "NonCrashFailures"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FAILURE_ACTION => "Action"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PROVIDER_NAME => "ProviderName"

    /**
     * @type {String}
     */
    static INFSTR_KEY_RESOURCE_FILE => "ResourceFile"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MESSAGE_FILE => "MessageFile"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PARAMETER_FILE => "ParameterFile"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CHANNEL_ACCESS => "Access"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CHANNEL_ISOLATION => "Isolation"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CHANNEL_ENABLED => "Enabled"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CHANNEL_VALUE => "Value"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOGGING_MAXSIZE => "LoggingMaxSize"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOGGING_RETENTION => "LoggingRetention"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOGGING_AUTOBACKUP => "LoggingAutoBackup"

    /**
     * @type {String}
     */
    static INFSTR_KEY_START => "Start"

    /**
     * @type {String}
     */
    static INFSTR_KEY_BUFFER_SIZE => "BufferSize"

    /**
     * @type {String}
     */
    static INFSTR_KEY_CLOCK_TYPE => "ClockType"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DISABLE_REALTIME_PERSISTENCE => "DisableRealtimePersistence"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FILE_NAME => "FileName"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FILE_MAX => "FileMax"

    /**
     * @type {String}
     */
    static INFSTR_KEY_FLUSH_TIMER => "FlushTimer"

    /**
     * @type {String}
     */
    static INFSTR_KEY_LOG_FILE_MODE => "LogFileMode"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MAX_FILE_SIZE => "MaxFileSize"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MAXIMUM_BUFFERS => "MaximumBuffers"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MINIMUM_BUFFERS => "MinimumBuffers"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ENABLED => "Enabled"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ENABLE_FLAGS => "EnableFlags"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ENABLE_LEVEL => "EnableLevel"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ENABLE_PROPERTY => "EnableProperty"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MATCH_ANY_KEYWORD => "MatchAnyKeyword"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MATCH_ALL_KEYWORD => "MatchAllKeyword"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DETMODULES => "Det.Modules"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DETCLASSINFO => "Det.ClassInfo"

    /**
     * @type {String}
     */
    static INFSTR_SECT_MANUALDEV => "Det.ManualDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_AVOIDCFGSYSDEV => "Det.AvoidCfgSysDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_REGCFGSYSDEV => "Det.RegCfgSysDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DEVINFS => "Det.DevINFs"

    /**
     * @type {String}
     */
    static INFSTR_SECT_AVOIDINIDEV => "Det.AvoidIniDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_AVOIDENVDEV => "Det.AvoidEnvDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_REGINIDEV => "Det.RegIniDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_REGENVDEV => "Det.RegEnvDev"

    /**
     * @type {String}
     */
    static INFSTR_SECT_HPOMNIBOOK => "Det.HPOmnibook"

    /**
     * @type {String}
     */
    static INFSTR_SECT_FORCEHWVERIFY => "Det.ForceHWVerify"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DETOPTIONS => "Det.Options"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADPNPBIOS => "BadPnpBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_GOODACPIBIOS => "GoodACPIBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADACPIBIOS => "BadACPIBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADROUTINGTABLEBIOS => "BadPCIIRQRoutingTableBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADPMCALLBIOS => "BadProtectedModeCallBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADRMCALLBIOS => "BadRealModeCallBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_MACHINEIDBIOS => "MachineIDBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADDISKBIOS => "BadDiskBios"

    /**
     * @type {String}
     */
    static INFSTR_SECT_BADDSBIOS => "BadDSBios"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DETPARAMS => "Params"

    /**
     * @type {String}
     */
    static INFSTR_KEY_SKIPLIST => "SkipList"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DETECTLIST => "DetectList"

    /**
     * @type {String}
     */
    static INFSTR_KEY_EXCLUDERES => "ExcludeRes"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_LOGCONFIG => "LogConfig"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_DET => "Det"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_FACTDEF => "FactDef"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_POSSIBLEDUPS => "PosDup"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_NORESOURCEDUPS => "NoResDup"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_HW => "Hw"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_CTL => "CTL"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_SERVICES => "Services"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_SOFTWARE => "Software"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_INTERFACES => "Interfaces"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_COINSTALLERS => "CoInstallers"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_LOGCONFIGOVERRIDE => "LogConfigOverride"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_WMI => "WMI"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_EVENTS => "Events"

    /**
     * @type {String}
     */
    static INFSTR_SUBKEY_FILTERS => "Filters"

    /**
     * @type {String}
     */
    static INFSTR_CONTROLFLAGS_SECTION => "ControlFlags"

    /**
     * @type {String}
     */
    static INFSTR_KEY_COPYFILESONLY => "CopyFilesOnly"

    /**
     * @type {String}
     */
    static INFSTR_KEY_EXCLUDEFROMSELECT => "ExcludeFromSelect"

    /**
     * @type {String}
     */
    static INFSTR_KEY_ALWAYSEXCLUDEFROMSELECT => "AlwaysExcludeFromSelect"

    /**
     * @type {String}
     */
    static INFSTR_KEY_INTERACTIVEINSTALL => "InteractiveInstall"

    /**
     * @type {String}
     */
    static INFSTR_KEY_REQUESTADDITIONALSOFTWARE => "RequestAdditionalSoftware"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_WIN => "Win"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NT => "NT"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTX86 => "NTx86"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTMIPS => "NTMIPS"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTALPHA => "NTAlpha"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTPPC => "NTPPC"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTIA64 => "NTIA64"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTAXP64 => "NTAXP64"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTAMD64 => "NTAMD64"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTARM => "NTARM"

    /**
     * @type {String}
     */
    static INFSTR_PLATFORM_NTARM64 => "NTARM64"

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_INFSTR_STRKEY_LEN => 32

    /**
     * @type {String}
     */
    static INFSTR_STRKEY_DRVDESC => "DriverDesc"

    /**
     * @type {String}
     */
    static INFSTR_DRIVERSELECT_SECTION => "DriverSelect"

    /**
     * @type {String}
     */
    static INFSTR_DRIVERSELECT_FUNCTIONS => "DriverSelectFunctions"

    /**
     * @type {String}
     */
    static INFSTR_DRIVERVERSION_SECTION => "DriverVer"

    /**
     * @type {String}
     */
    static INFSTR_SOFTWAREVERSION_SECTION => "SoftwareVersion"

    /**
     * @type {String}
     */
    static INFSTR_SECT_CFGSYS => "ConfigSysDrivers"

    /**
     * @type {String}
     */
    static INFSTR_SECT_AUTOEXECBAT => "AutoexecBatDrivers"

    /**
     * @type {String}
     */
    static INFSTR_SECT_SYSINI => "SystemIniDrivers"

    /**
     * @type {String}
     */
    static INFSTR_SECT_SYSINIDRV => "SystemIniDriversLine"

    /**
     * @type {String}
     */
    static INFSTR_SECT_WININIRUN => "WinIniRunLine"

    /**
     * @type {String}
     */
    static INFSTR_KEY_PATH => "Path"

    /**
     * @type {String}
     */
    static INFSTR_KEY_NAME => "Name"

    /**
     * @type {String}
     */
    static INFSTR_KEY_IO => "IO"

    /**
     * @type {String}
     */
    static INFSTR_KEY_MEM => "Mem"

    /**
     * @type {String}
     */
    static INFSTR_KEY_IRQ => "IRQ"

    /**
     * @type {String}
     */
    static INFSTR_KEY_DMA => "DMA"

    /**
     * @type {String}
     */
    static INFSTR_BUS_ISA => "BUS_ISA"

    /**
     * @type {String}
     */
    static INFSTR_BUS_EISA => "BUS_EISA"

    /**
     * @type {String}
     */
    static INFSTR_BUS_MCA => "BUS_MCA"

    /**
     * @type {String}
     */
    static INFSTR_BUS_ALL => "BUS_ALL"

    /**
     * @type {String}
     */
    static INFSTR_RISK_NONE => "RISK_NONE"

    /**
     * @type {String}
     */
    static INFSTR_RISK_VERYLOW => "RISK_VERYLOW"

    /**
     * @type {String}
     */
    static INFSTR_RISK_BIOSROMRD => "RISK_BIOSROMRD"

    /**
     * @type {String}
     */
    static INFSTR_RISK_QUERYDRV => "RISK_QUERYDRV"

    /**
     * @type {String}
     */
    static INFSTR_RISK_SWINT => "RISK_SWINT"

    /**
     * @type {String}
     */
    static INFSTR_RISK_LOW => "RISK_LOW"

    /**
     * @type {String}
     */
    static INFSTR_RISK_DELICATE => "RISK_DELICATE"

    /**
     * @type {String}
     */
    static INFSTR_RISK_MEMRD => "RISK_MEMRD"

    /**
     * @type {String}
     */
    static INFSTR_RISK_IORD => "RISK_IORD"

    /**
     * @type {String}
     */
    static INFSTR_RISK_MEMWR => "RISK_MEMWR"

    /**
     * @type {String}
     */
    static INFSTR_RISK_IOWR => "RISK_IOWR"

    /**
     * @type {String}
     */
    static INFSTR_RISK_UNRELIABLE => "RISK_UNRELIABLE"

    /**
     * @type {String}
     */
    static INFSTR_RISK_VERYHIGH => "RISK_VERYHIGH"

    /**
     * @type {String}
     */
    static INFSTR_CLASS_SAFEEXCL => "SAFE_EXCL"

    /**
     * @type {String}
     */
    static INFSTR_SECT_DISPLAY_CLEANUP => "DisplayCleanup"

    /**
     * @type {String}
     */
    static GUID_HWPROFILE_QUERY_CHANGE => "{cb3a4001-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_HWPROFILE_CHANGE_CANCELLED => "{cb3a4002-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_HWPROFILE_CHANGE_COMPLETE => "{cb3a4003-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_DEVICE_INTERFACE_ARRIVAL => "{cb3a4004-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_DEVICE_INTERFACE_REMOVAL => "{cb3a4005-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_TARGET_DEVICE_QUERY_REMOVE => "{cb3a4006-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_TARGET_DEVICE_REMOVE_CANCELLED => "{cb3a4007-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_TARGET_DEVICE_REMOVE_COMPLETE => "{cb3a4008-46f0-11d0-b08f-00609713053f}"

    /**
     * @type {String}
     */
    static GUID_PNP_CUSTOM_NOTIFICATION => "{aca73f8e-8d23-11d1-ac7d-0000f87571d0}"

    /**
     * @type {String}
     */
    static GUID_PNP_POWER_NOTIFICATION => "{c2cf0660-eb7a-11d1-bd7f-0000f87571d0}"

    /**
     * @type {String}
     */
    static GUID_PNP_POWER_SETTING_CHANGE => "{29c69b3e-c79a-43bf-bbde-a932fa1bea7e}"

    /**
     * @type {String}
     */
    static GUID_TARGET_DEVICE_TRANSPORT_RELATIONS_CHANGED => "{fcf528f6-a82f-47b1-ad3a-8050594cad28}"

    /**
     * @type {String}
     */
    static GUID_KERNEL_SOFT_RESTART_PREPARE => "{de373def-a85c-4f76-8cbf-f96bea8bd10f}"

    /**
     * @type {String}
     */
    static GUID_KERNEL_SOFT_RESTART_CANCEL => "{31d737e7-8c0b-468a-956e-9f433ec358fb}"

    /**
     * @type {String}
     */
    static GUID_RECOVERY_PCI_PREPARE_SHUTDOWN => "{90d889de-8704-44cf-8115-ed8528d2b2da}"

    /**
     * @type {String}
     */
    static GUID_RECOVERY_NVMED_PREPARE_SHUTDOWN => "{4b9770ea-bde7-400b-a9b9-4f684f54cc2a}"

    /**
     * @type {String}
     */
    static GUID_KERNEL_SOFT_RESTART_FINALIZE => "{20e91abd-350a-4d4f-8577-99c81507473a}"

    /**
     * @type {String}
     */
    static GUID_BUS_INTERFACE_STANDARD => "{496b8280-6f25-11d0-beaf-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_PCI_BUS_INTERFACE_STANDARD => "{496b8281-6f25-11d0-beaf-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_PCI_BUS_INTERFACE_STANDARD2 => "{de94e966-fdff-4c9c-9998-6747b150e74c}"

    /**
     * @type {String}
     */
    static GUID_ARBITER_INTERFACE_STANDARD => "{e644f185-8c0e-11d0-becf-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_TRANSLATOR_INTERFACE_STANDARD => "{6c154a92-aacf-11d0-8d2a-00a0c906b244}"

    /**
     * @type {String}
     */
    static GUID_ACPI_INTERFACE_STANDARD => "{b091a08a-ba97-11d0-bd14-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_INT_ROUTE_INTERFACE_STANDARD => "{70941bf4-0073-11d1-a09e-00c04fc340b1}"

    /**
     * @type {String}
     */
    static GUID_PCMCIA_BUS_INTERFACE_STANDARD => "{76173af0-c504-11d1-947f-00c04fb960ee}"

    /**
     * @type {String}
     */
    static GUID_ACPI_REGS_INTERFACE_STANDARD => "{06141966-7245-6369-462e-4e656c736f6e}"

    /**
     * @type {String}
     */
    static GUID_LEGACY_DEVICE_DETECTION_STANDARD => "{50feb0de-596a-11d2-a5b8-0000f81a4619}"

    /**
     * @type {String}
     */
    static GUID_PCI_DEVICE_PRESENT_INTERFACE => "{d1b82c26-bf49-45ef-b216-71cbd7889b57}"

    /**
     * @type {String}
     */
    static GUID_MF_ENUMERATION_INTERFACE => "{aeb895f0-5586-11d1-8d84-00a0c906b244}"

    /**
     * @type {String}
     */
    static GUID_REENUMERATE_SELF_INTERFACE_STANDARD => "{2aeb0243-6a6e-486b-82fc-d815f6b97006}"

    /**
     * @type {String}
     */
    static GUID_AGP_TARGET_BUS_INTERFACE_STANDARD => "{b15cfce8-06d1-4d37-9d4c-bedde0c2a6ff}"

    /**
     * @type {String}
     */
    static GUID_ACPI_CMOS_INTERFACE_STANDARD => "{3a8d0384-6505-40ca-bc39-56c15f8c5fed}"

    /**
     * @type {String}
     */
    static GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD => "{f14f609b-cbbd-4957-a674-bc00213f1c97}"

    /**
     * @type {String}
     */
    static GUID_ACPI_INTERFACE_STANDARD2 => "{e8695f63-1831-4870-a8cf-9c2f03f9dcb5}"

    /**
     * @type {String}
     */
    static GUID_PNP_LOCATION_INTERFACE => "{70211b0e-0afb-47db-afc1-410bf842497a}"

    /**
     * @type {String}
     */
    static GUID_PCI_EXPRESS_LINK_QUIESCENT_INTERFACE => "{146cd41c-dae3-4437-8aff-2af3f038099b}"

    /**
     * @type {String}
     */
    static GUID_PCI_EXPRESS_ROOT_PORT_INTERFACE => "{83a7734a-84c7-4161-9a98-6000ed0c4a33}"

    /**
     * @type {String}
     */
    static GUID_MSIX_TABLE_CONFIG_INTERFACE => "{1a6a460b-194f-455d-b34b-b84c5b05712b}"

    /**
     * @type {String}
     */
    static GUID_D3COLD_SUPPORT_INTERFACE => "{b38290e5-3cd0-4f9d-9937-f5fe2b44d47a}"

    /**
     * @type {String}
     */
    static GUID_PROCESSOR_PCC_INTERFACE_STANDARD => "{37b17e9a-c21c-4296-972d-11c4b32b28f0}"

    /**
     * @type {String}
     */
    static GUID_PCI_VIRTUALIZATION_INTERFACE => "{64897b47-3a4a-4d75-bc74-89dd6c078293}"

    /**
     * @type {String}
     */
    static GUID_PCC_INTERFACE_STANDARD => "{3ee8ba63-0f59-4a24-8a45-35808bdd1249}"

    /**
     * @type {String}
     */
    static GUID_PCC_INTERFACE_INTERNAL => "{7cce62ce-c189-4814-a6a7-12112089e938}"

    /**
     * @type {String}
     */
    static GUID_THERMAL_COOLING_INTERFACE => "{ecbe47a8-c498-4bb9-bd70-e867e0940d22}"

    /**
     * @type {String}
     */
    static GUID_DMA_CACHE_COHERENCY_INTERFACE => "{b520f7fa-8a5a-4e40-a3f6-6be1e162d935}"

    /**
     * @type {String}
     */
    static GUID_DEVICE_RESET_INTERFACE_STANDARD => "{649fdf26-3bc0-4813-ad24-7e0c1eda3fa3}"

    /**
     * @type {String}
     */
    static GUID_IOMMU_BUS_INTERFACE => "{1efee0b2-d278-4ae4-bddc-1b34dd648043}"

    /**
     * @type {String}
     */
    static GUID_PCI_SECURITY_INTERFACE => "{6e7f1451-199e-4acc-ba2d-762b4edf4674}"

    /**
     * @type {String}
     */
    static GUID_SCM_BUS_INTERFACE => "{25944783-ce79-4232-815e-4a30014e8eb4}"

    /**
     * @type {String}
     */
    static GUID_SECURE_DRIVER_INTERFACE => "{370f67e1-4ff5-4a94-9a35-06c5d9cc30e2}"

    /**
     * @type {String}
     */
    static GUID_SDEV_IDENTIFIER_INTERFACE => "{49d67af8-916c-4ee8-9df1-889f17d21e91}"

    /**
     * @type {String}
     */
    static GUID_SCM_BUS_NVD_INTERFACE => "{8de064ff-b630-42e4-88ea-6f24c8641175}"

    /**
     * @type {String}
     */
    static GUID_SCM_BUS_LD_INTERFACE => "{9b89307d-d76b-4f48-b186-54041ae92e8d}"

    /**
     * @type {String}
     */
    static GUID_SCM_PHYSICAL_NVDIMM_INTERFACE => "{0079c21b-917e-405e-a9ce-0732b5bbcebd}"

    /**
     * @type {String}
     */
    static GUID_PNP_EXTENDED_ADDRESS_INTERFACE => "{b8e992ec-a797-4dc4-8846-84d041707446}"

    /**
     * @type {String}
     */
    static GUID_D3COLD_AUX_POWER_AND_TIMING_INTERFACE => "{0044d8aa-f664-4588-9ffc-2afeaf5950b9}"

    /**
     * @type {String}
     */
    static GUID_PCI_FPGA_CONTROL_INTERFACE => "{2df3f7a8-b9b3-4063-9215-b5d14a0b266e}"

    /**
     * @type {String}
     */
    static GUID_PCI_PTM_CONTROL_INTERFACE => "{348a5ebb-ba24-44b7-9916-285687735117}"

    /**
     * @type {String}
     */
    static GUID_BUS_RESOURCE_UPDATE_INTERFACE => "{27d0102d-bfb2-4164-81dd-dbb82f968b48}"

    /**
     * @type {String}
     */
    static GUID_NPEM_CONTROL_INTERFACE => "{4d95573d-b774-488a-b120-4f284a9eff51}"

    /**
     * @type {String}
     */
    static GUID_PCI_ATS_INTERFACE => "{010a7fe8-96f5-4943-bedf-95e651b93412}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_INTERNAL => "{1530ea73-086b-11d1-a09f-00c04fc340b1}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_PCMCIA => "{09343630-af9f-11d0-92e9-0000f81e1b30}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_PCI => "{c8ebdfb0-b510-11d0-80e5-00a0c92542e3}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_ISAPNP => "{e676f854-d87d-11d0-92b2-00a0c9055fc5}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_EISA => "{ddc35509-f3fc-11d0-a537-0000f8753ed1}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_MCA => "{1c75997a-dc33-11d0-92b2-00a0c9055fc5}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_SERENUM => "{77114a87-8944-11d1-bd90-00a0c906be2d}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_USB => "{9d7debbc-c85d-11d1-9eb4-006008c3a19a}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_LPTENUM => "{c4ca1000-2ddc-11d5-a17a-00c04f60524d}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_USBPRINT => "{441ee000-4342-11d5-a184-00c04f60524d}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_DOT4PRT => "{441ee001-4342-11d5-a184-00c04f60524d}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_1394 => "{f74e73eb-9ac5-45eb-be4d-772cc71ddfb3}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_HID => "{eeaf37d0-1963-47c4-aa48-72476db7cf49}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_AVC => "{c06ff265-ae09-48f0-812c-16753d7cba83}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_IRDA => "{7ae17dc1-c944-44d6-881f-4c2e61053bc1}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_SD => "{e700cc04-4036-4e89-9579-89ebf45f00cd}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_ACPI => "{d7b46895-001a-4942-891f-a7d46610a843}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_SW_DEVICE => "{06d10322-7de0-4cef-8e25-197d0e7442e2}"

    /**
     * @type {String}
     */
    static GUID_BUS_TYPE_SCM => "{375a5912-804c-45aa-bdc2-fdd25a1d9512}"

    /**
     * @type {String}
     */
    static GUID_POWER_DEVICE_ENABLE => "{827c0a6f-feb0-11d0-bd26-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_POWER_DEVICE_TIMEOUTS => "{a45da735-feb0-11d0-bd26-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_POWER_DEVICE_WAKE_ENABLE => "{a9546a82-feb0-11d0-bd26-00aa00b7b32a}"

    /**
     * @type {String}
     */
    static GUID_WUDF_DEVICE_HOST_PROBLEM => "{c43d25bd-9346-40ee-a2d2-d70c15f8b75b}"

    /**
     * @type {String}
     */
    static GUID_PARTITION_UNIT_INTERFACE_STANDARD => "{52363f5b-d891-429b-8195-aec5fef6853c}"

    /**
     * @type {String}
     */
    static GUID_QUERY_CRASHDUMP_FUNCTIONS => "{9cc6b8ff-32e2-4834-b1de-b32ef8880a4b}"
;@endregion Constants

;@region Methods
    /**
     * The SetUpGetInfInformation function returns the SP_INF_INFORMATION structure for the specified INF file to a buffer. (ANSI)
     * @remarks
     * If this function is called with a ReturnBuffer of <b>NULL</b> and a ReturnBufferSize of 0 (zero), the function puts the buffer size needed to hold the specified data into the variable pointed to by RequiredSize. If the function succeeds, the return value is a nonzero value. Otherwise, the return value is 0 (zero), and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetInfInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfSpec Handle or a file name for an INF file, depending on the value of <i>SearchControl</i>.
     * @param {Integer} SearchControl This parameter can be one of the following constants.
     * @param {Pointer<SP_INF_INFORMATION>} ReturnBuffer If not <b>NULL</b>, points to a buffer in which this function returns the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure. 
     * 
     * You can call the function one time to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. For more information, see the Remarks section of this topic.
     * @param {Integer} ReturnBufferSize Size of  <i>ReturnBuffer</i>, in bytes.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size, in bytes, for the buffer pointed to by <i>ReturnBuffer</i>. 
     * 
     * If <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the INF file cannot be located, the function returns <b>FALSE</b> and a subsequent call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_FILE_NOT_FOUND.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinfinformationa
     * @since windows5.1.2600
     */
    static SetupGetInfInformationA(InfSpec, SearchControl, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfInformationA", "ptr", InfSpec, "uint", SearchControl, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetUpGetInfInformation function returns the SP_INF_INFORMATION structure for the specified INF file to a buffer. (Unicode)
     * @remarks
     * If this function is called with a ReturnBuffer of <b>NULL</b> and a ReturnBufferSize of 0 (zero), the function puts the buffer size needed to hold the specified data into the variable pointed to by RequiredSize. If the function succeeds, the return value is a nonzero value. Otherwise, the return value is 0 (zero), and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetInfInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfSpec Handle or a file name for an INF file, depending on the value of <i>SearchControl</i>.
     * @param {Integer} SearchControl This parameter can be one of the following constants.
     * @param {Pointer<SP_INF_INFORMATION>} ReturnBuffer If not <b>NULL</b>, points to a buffer in which this function returns the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure. 
     * 
     * You can call the function one time to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. For more information, see the Remarks section of this topic.
     * @param {Integer} ReturnBufferSize Size of  <i>ReturnBuffer</i>, in bytes.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size, in bytes, for the buffer pointed to by <i>ReturnBuffer</i>. 
     * 
     * If <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the INF file cannot be located, the function returns <b>FALSE</b> and a subsequent call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_FILE_NOT_FOUND.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinfinformationw
     * @since windows5.1.2600
     */
    static SetupGetInfInformationW(InfSpec, SearchControl, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfInformationW", "ptr", InfSpec, "uint", SearchControl, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfFileInformation function returns an INF filename from an SP_INF_INFORMATION structure to a buffer. (ANSI)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryInfFileInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF filename to retrieve. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {Pointer<PSTR>} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> is a pointer to a buffer in which this function returns the full INF filename. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, pointer to a variable that receives the required size for the <i>ReturnBuffer</i> buffer, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryinffileinformationa
     * @since windows5.1.2600
     */
    static SetupQueryInfFileInformationA(InfInformation, InfIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfFileInformationA", "ptr", InfInformation, "uint", InfIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfFileInformation function returns an INF filename from an SP_INF_INFORMATION structure to a buffer. (Unicode)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryInfFileInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF filename to retrieve. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {Pointer<PWSTR>} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> is a pointer to a buffer in which this function returns the full INF filename. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, pointer to a variable that receives the required size for the <i>ReturnBuffer</i> buffer, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryinffileinformationw
     * @since windows5.1.2600
     */
    static SetupQueryInfFileInformationW(InfInformation, InfIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfFileInformationW", "ptr", InfInformation, "uint", InfIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfOriginalFileInformation function returns the original name of an OEM INF file. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryInfOriginalFileInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF file name to retrieve. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Optional pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v1">SP_ALTPLATFORM_INFO_V1</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO_V2</a> structure used to pass information for an alternate platform to 
     * <b>SetupQueryInfOriginalFileInformation</b>.
     * @param {Pointer<SP_ORIGINAL_FILE_INFO_A>} OriginalFileInfo Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_original_file_info_a">SP_ORIGINAL_FILE_INFO</a> structure that receives the original INF file name and catalog file information returned by 
     * <b>SetupQueryInfOriginalFileInformation</b>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryinforiginalfileinformationa
     * @since windows5.1.2600
     */
    static SetupQueryInfOriginalFileInformationA(InfInformation, InfIndex, AlternatePlatformInfo, OriginalFileInfo) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfOriginalFileInformationA", "ptr", InfInformation, "uint", InfIndex, "ptr", AlternatePlatformInfo, "ptr", OriginalFileInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfOriginalFileInformation function returns the original name of an OEM INF file. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryInfOriginalFileInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF file name to retrieve. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Optional pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v1">SP_ALTPLATFORM_INFO_V1</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO_V2</a> structure used to pass information for an alternate platform to 
     * <b>SetupQueryInfOriginalFileInformation</b>.
     * @param {Pointer<SP_ORIGINAL_FILE_INFO_W>} OriginalFileInfo Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_original_file_info_a">SP_ORIGINAL_FILE_INFO</a> structure that receives the original INF file name and catalog file information returned by 
     * <b>SetupQueryInfOriginalFileInformation</b>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryinforiginalfileinformationw
     * @since windows5.1.2600
     */
    static SetupQueryInfOriginalFileInformationW(InfInformation, InfIndex, AlternatePlatformInfo, OriginalFileInfo) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfOriginalFileInformationW", "ptr", InfInformation, "uint", InfIndex, "ptr", AlternatePlatformInfo, "ptr", OriginalFileInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfVersionInformation function returns INF file version information from an SP_INF_INFORMATION structure to a buffer. (ANSI)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If 
     * <b>SetupQueryInfVersionInformation</b> is called on a legacy INF file , then version information is generated from the legacy INF file in the following manner:
     * 
     * <ol>
     * <li>The OptionType key in the <b>Identification</b> section of the legacy file  is returned as the Class key value.</li>
     * <li>The FileType key in the <b>Signature</b> section of the legacy INF file becomes the Signature key value.</li>
     * <li>If the value of the FileType key of the legacy INF file is MICROSOFT_FILE, then the Provider key value is set to "Microsoft".</li>
     * </ol>
     * The following table summarizes how the information is translated before it is passed into the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure.
     * 
     * <table>
     * <tr>
     * <th>Legacy file information</th>
     * <th> Windows INF information</th>
     * </tr>
     * <tr>
     * <td>
     * 
     * ``` syntax
     * [Identification]
     * OptionType = Mouse
     * ```
     * 
     * </td>
     * <td>
     * 
     * ``` syntax
     * [Version]
     * Class=Mouse
     * ```
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * 
     * ``` syntax
     * [Signature]
     * FileType = MICROSOFT_FILE
     * ```
     * 
     * </td>
     * <td>
     * 
     * ``` syntax
     * Signature=MICROSOFT_FILE
     * ```
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>(if the FileType is MICROSOFT_FILE)</td>
     * <td>
     * 
     * ``` syntax
     * Provider="Microsoft"
     * ```
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryInfVersionInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure previously returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF file to retrieve version information from. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {Pointer<PSTR>} Key Optional pointer to a <b>null</b>-terminated string containing the key name whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all resource keys are copied to the supplied buffer. Each string is <b>null</b>-terminated, with an extra <b>null</b> at the end of the list.
     * @param {Pointer<PSTR>} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> points to a call-supplied character buffer in which this function returns the INF file style. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, pointer to a variable that receives the size required for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryinfversioninformationa
     * @since windows5.1.2600
     */
    static SetupQueryInfVersionInformationA(InfInformation, InfIndex, Key, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Key := Key is String? StrPtr(Key) : Key
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfVersionInformationA", "ptr", InfInformation, "uint", InfIndex, "ptr", Key, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryInfVersionInformation function returns INF file version information from an SP_INF_INFORMATION structure to a buffer. (Unicode)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If 
     * <b>SetupQueryInfVersionInformation</b> is called on a legacy INF file , then version information is generated from the legacy INF file in the following manner:
     * 
     * <ol>
     * <li>The OptionType key in the <b>Identification</b> section of the legacy file  is returned as the Class key value.</li>
     * <li>The FileType key in the <b>Signature</b> section of the legacy INF file becomes the Signature key value.</li>
     * <li>If the value of the FileType key of the legacy INF file is MICROSOFT_FILE, then the Provider key value is set to "Microsoft".</li>
     * </ol>
     * The following table summarizes how the information is translated before it is passed into the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure.
     * 
     * <table>
     * <tr>
     * <th>Legacy file information</th>
     * <th> Windows INF information</th>
     * </tr>
     * <tr>
     * <td>
     * 
     * ``` syntax
     * [Identification]
     * OptionType = Mouse
     * ```
     * 
     * </td>
     * <td>
     * 
     * ``` syntax
     * [Version]
     * Class=Mouse
     * ```
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * 
     * ``` syntax
     * [Signature]
     * FileType = MICROSOFT_FILE
     * ```
     * 
     * </td>
     * <td>
     * 
     * ``` syntax
     * Signature=MICROSOFT_FILE
     * ```
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>(if the FileType is MICROSOFT_FILE)</td>
     * <td>
     * 
     * ``` syntax
     * Provider="Microsoft"
     * ```
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryInfVersionInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_INF_INFORMATION>} InfInformation Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_information">SP_INF_INFORMATION</a> structure previously returned from a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * @param {Integer} InfIndex Index of the constituent INF file to retrieve version information from. This index can be in the range [0, <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including, <i>InfInformation.InfCount</i> are valid.
     * @param {Pointer<PWSTR>} Key Optional pointer to a <b>null</b>-terminated string containing the key name whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all resource keys are copied to the supplied buffer. Each string is <b>null</b>-terminated, with an extra <b>null</b> at the end of the list.
     * @param {Pointer<PWSTR>} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> points to a call-supplied character buffer in which this function returns the INF file style. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, pointer to a variable that receives the size required for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryinfversioninformationw
     * @since windows5.1.2600
     */
    static SetupQueryInfVersionInformationW(InfInformation, InfIndex, Key, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Key := Key is String? StrPtr(Key) : Key
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryInfVersionInformationW", "ptr", InfInformation, "uint", InfIndex, "ptr", Key, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfDriverStoreLocation function retrieves the fully qualified file name (directory path and file name) of an INF file in the driver store that corresponds to a specified INF file in the system INF file directory or a specified INF file in the driver store. (ANSI)
     * @remarks
     * To determine the size of the return buffer that is required to contain the fully qualified file name of the specified INF file in the driver store, call <b>SetupGetInfDriverStoreLocation</b> and set <i>ReturnBuffer</i> to <b>NULL</b>, <i>ReturnBufferSize</i> to zero, and supply <i>RequiredSize</i>. <b>SetupGetInfDriverStoreLocation</b> will return the required buffer size in <i>RequiredSize</i>.
     * 
     * When device installation preinstalls a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/difx-guidelines">driver package</a> in the driver store, it creates two copies of the driver package INF file. Device installation installs one copy in the system INF directory and assigns that copy of the INF file a unique <i>published file name</i> of the form <i>OEMnnn.inf</i>. Device installation installs a second copy of the INF file in the driver store and assigns that copy the original INF file name.
     * 
     * <b>SetupGetInfDriverStoreLocation</b> returns the fully qualified file name of the INF file in the driver store that matches the INF file, if any, that is supplied by <i>FileName</i>. <i>Filename</i> must specify the file name, and optionally the directory path, of an INF file in the system INF directory. Alternatively, <i>Filename</i> must specify the fully qualified file name of an INF file in the driver store. 
     * 
     * For example, assume that the INF file for a driver package is <i>Myinf.inf</i>, and that for this driver package, device installation installs the INF file <i>OEM1.inf</i> in the system INF directory C:<i>\Windows\inf.</i> Further assume that device installation installs the corresponding INF file copy C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf</i> in the driver store. In this case, the function returns C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf</i> if <i>FileName</i> supplies one of the following strings: <i>OEM1.inf</i>, C:<i>\Windows\inf\OEM1.inf</i>, or C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf.</i>
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/">Class installers</a> and <a href="https://docs.microsoft.com/windows-hardware/drivers/">co-installers</a> can use <b>SetupGetInfDriverStoreLocation</b> to access files in a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/difx-guidelines">driver package</a> that is preinstalled in the driver store. To determine the path of the driver package in the driver store, the installer does the following:
     * 
     * <ol>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdriverinfodetaila">SetupDiGetDriverInfoDetail</a> to retrieve a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_detail_data_a">SP_DRVINFO_DETAIL_DATA</a> structure for a driver. The <b>InfFileName</b> member of this structure contains the fully qualified file name of the driver INF file in the system INF directory.
     * 
     * </li>
     * <li>
     * Call <b>SetupGetInfDriverStoreLocation</b> and supply the fully qualified file name of the driver INF file that was retrieved by calling <b>SetupDiGetDriverInfoDetail</b>. <b>SetupGetInfDriverStoreLocation</b> will return the fully qualified file name of the driver INF file in the driver store. The directory path part of the fully qualified file name of the INF file is the path of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/difx-guidelines">driver package</a> files. 
     * 
     * </li>
     * </ol>
     * <div class="alert"><b>Note</b><b>SetupGetInfDriverStoreLocation</b> does not process the contents of the INF file that is specified in <i>FileName</i>. You cannot use this function to perform a content-specific search for an INF file in the driver store.</div>
     * <div></div>
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfpublishednamea">SetupGetInfPublishedName</a> function to retrieve the fully qualified file name of an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-inf-files">INF file</a> in the system INF file directory that corresponds to a specified INF file in the system INF file directory or a specified file in the driver store.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetInfDriverStoreLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} FileName A pointer to a NULL-terminated string that contains the name, and optionally the full directory path, of an INF file in the system INF file directory. Alternatively, this parameter is a pointer to a NULL-terminated string that contains the fully qualified file name (directory path and file name) of an INF file in the driver store. 
     * 
     * For more information about how to specify the INF file, see the following <b>Remarks</b> section.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Reserved for system use.
     * @param {Pointer<PSTR>} LocaleName Reserved for system use.
     * @param {Pointer<PSTR>} ReturnBuffer A pointer to a buffer in which the function returns a NULL-terminated string that contains the fully qualified file name of the specified INF file. This parameter can be set to <b>NULL</b>. The maximum supported path size is MAX_PATH. For information about how to determine the required size of the buffer, see the following <b>Remarks</b> section.
     * @param {Integer} ReturnBufferSize The size, in characters, of the buffer supplied by <i>ReturnBuffer</i>.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, of the <i>ReturnBuffer</i> buffer. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {Integer} If <b>SetupGetInfDriverStoreLocation</b> succeeds, the function returns <b>TRUE</b>; otherwise, the function returns <b>FALSE</b>. To obtain extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If the size, in characters, of the fully qualified file name of the requested INF file, including a null-terminator, is greater than <i>ReturnBufferSize</i>, the function will fail, and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinfdriverstorelocationa
     * @since windows6.0.6000
     */
    static SetupGetInfDriverStoreLocationA(FileName, AlternatePlatformInfo, LocaleName, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        FileName := FileName is String? StrPtr(FileName) : FileName
        LocaleName := LocaleName is String? StrPtr(LocaleName) : LocaleName
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfDriverStoreLocationA", "ptr", FileName, "ptr", AlternatePlatformInfo, "ptr", LocaleName, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfDriverStoreLocation function retrieves the fully qualified file name (directory path and file name) of an INF file in the driver store that corresponds to a specified INF file in the system INF file directory or a specified INF file in the driver store. (Unicode)
     * @remarks
     * To determine the size of the return buffer that is required to contain the fully qualified file name of the specified INF file in the driver store, call <b>SetupGetInfDriverStoreLocation</b> and set <i>ReturnBuffer</i> to <b>NULL</b>, <i>ReturnBufferSize</i> to zero, and supply <i>RequiredSize</i>. <b>SetupGetInfDriverStoreLocation</b> will return the required buffer size in <i>RequiredSize</i>.
     * 
     * When device installation preinstalls a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/difx-guidelines">driver package</a> in the driver store, it creates two copies of the driver package INF file. Device installation installs one copy in the system INF directory and assigns that copy of the INF file a unique <i>published file name</i> of the form <i>OEMnnn.inf</i>. Device installation installs a second copy of the INF file in the driver store and assigns that copy the original INF file name.
     * 
     * <b>SetupGetInfDriverStoreLocation</b> returns the fully qualified file name of the INF file in the driver store that matches the INF file, if any, that is supplied by <i>FileName</i>. <i>Filename</i> must specify the file name, and optionally the directory path, of an INF file in the system INF directory. Alternatively, <i>Filename</i> must specify the fully qualified file name of an INF file in the driver store. 
     * 
     * For example, assume that the INF file for a driver package is <i>Myinf.inf</i>, and that for this driver package, device installation installs the INF file <i>OEM1.inf</i> in the system INF directory C:<i>\Windows\inf.</i> Further assume that device installation installs the corresponding INF file copy C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf</i> in the driver store. In this case, the function returns C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf</i> if <i>FileName</i> supplies one of the following strings: <i>OEM1.inf</i>, C:<i>\Windows\inf\OEM1.inf</i>, or C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf.</i>
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/">Class installers</a> and <a href="https://docs.microsoft.com/windows-hardware/drivers/">co-installers</a> can use <b>SetupGetInfDriverStoreLocation</b> to access files in a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/difx-guidelines">driver package</a> that is preinstalled in the driver store. To determine the path of the driver package in the driver store, the installer does the following:
     * 
     * <ol>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdriverinfodetaila">SetupDiGetDriverInfoDetail</a> to retrieve a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_detail_data_a">SP_DRVINFO_DETAIL_DATA</a> structure for a driver. The <b>InfFileName</b> member of this structure contains the fully qualified file name of the driver INF file in the system INF directory.
     * 
     * </li>
     * <li>
     * Call <b>SetupGetInfDriverStoreLocation</b> and supply the fully qualified file name of the driver INF file that was retrieved by calling <b>SetupDiGetDriverInfoDetail</b>. <b>SetupGetInfDriverStoreLocation</b> will return the fully qualified file name of the driver INF file in the driver store. The directory path part of the fully qualified file name of the INF file is the path of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/difx-guidelines">driver package</a> files. 
     * 
     * </li>
     * </ol>
     * <div class="alert"><b>Note</b><b>SetupGetInfDriverStoreLocation</b> does not process the contents of the INF file that is specified in <i>FileName</i>. You cannot use this function to perform a content-specific search for an INF file in the driver store.</div>
     * <div></div>
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfpublishednamea">SetupGetInfPublishedName</a> function to retrieve the fully qualified file name of an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-inf-files">INF file</a> in the system INF file directory that corresponds to a specified INF file in the system INF file directory or a specified file in the driver store.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetInfDriverStoreLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} FileName A pointer to a NULL-terminated string that contains the name, and optionally the full directory path, of an INF file in the system INF file directory. Alternatively, this parameter is a pointer to a NULL-terminated string that contains the fully qualified file name (directory path and file name) of an INF file in the driver store. 
     * 
     * For more information about how to specify the INF file, see the following <b>Remarks</b> section.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Reserved for system use.
     * @param {Pointer<PWSTR>} LocaleName Reserved for system use.
     * @param {Pointer<PWSTR>} ReturnBuffer A pointer to a buffer in which the function returns a NULL-terminated string that contains the fully qualified file name of the specified INF file. This parameter can be set to <b>NULL</b>. The maximum supported path size is MAX_PATH. For information about how to determine the required size of the buffer, see the following <b>Remarks</b> section.
     * @param {Integer} ReturnBufferSize The size, in characters, of the buffer supplied by <i>ReturnBuffer</i>.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, of the <i>ReturnBuffer</i> buffer. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {Integer} If <b>SetupGetInfDriverStoreLocation</b> succeeds, the function returns <b>TRUE</b>; otherwise, the function returns <b>FALSE</b>. To obtain extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If the size, in characters, of the fully qualified file name of the requested INF file, including a null-terminator, is greater than <i>ReturnBufferSize</i>, the function will fail, and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinfdriverstorelocationw
     * @since windows6.0.6000
     */
    static SetupGetInfDriverStoreLocationW(FileName, AlternatePlatformInfo, LocaleName, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        FileName := FileName is String? StrPtr(FileName) : FileName
        LocaleName := LocaleName is String? StrPtr(LocaleName) : LocaleName
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfDriverStoreLocationW", "ptr", FileName, "ptr", AlternatePlatformInfo, "ptr", LocaleName, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfPublishedName function retrieves the fully qualified file name (directory path and file name) of an INF file in the system INF file directory that corresponds to a specified INF file in the driver store or a specified INF file in the system INF file directory. (ANSI)
     * @remarks
     * To determine the size of the return buffer that is required to contain the fully qualified file name of the specified INF file in the system INF directory, call <b>SetupGetInfPublishedName</b> and set <i>ReturnBuffer</i> to <b>NULL</b>, <i>ReturnBufferSize</i> to zero, and supply <i>RequiredSize</i>. <b>SetupGetInfPublishedName</b> will return the required buffer size in <i>RequiredSize</i>.
     * 
     * When device installation preinstalls a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/difx-guidelines">driver package</a> in the driver store, it creates two copies of the driver package INF file. Device installation adds one copy to the system INF directory and assigns that copy of the INF file a unique <i>published file name</i> of the form <i>OEMnnn.inf</i>. Device installation adds a second copy of the INF file to the driver store and assigns that copy the original INF file name.
     * 
     * <b>SetupGetInfPublishedName</b> returns the fully qualified file name of the INF file in the system INF file directory that matches the INF file, if any, that is supplied by <i>DriverStoreLocation</i>. <i>DriverStoreLocation </i> must specify the fully qualified file name of an INF file in the driver store or must specify the file name, and optionally the directory path, of an INF file in the system INF directory. For example, assume that the INF file for a driver package is <i>myinf.inf</i>, and that for this driver package, device installation installs the INF file <i>OEM1.inf</i> in the system INF directory C:<i>\Windows\inf</i>. Further assume that device installation installs the corresponding INF file copy C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf</i> in the driver store. In this case, the function returns C:<i>\Windows\inf\OEM1.inf</i> if <i>DriverStoreLocation</i> supplies one of the following strings: C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf, OEM1.inf</i>, or C:<i>\Windows\inf\OEM1.inf.</i>
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfdriverstorelocationa">SetupGetInfDriverStoreLocation</a> function to retrieve the fully qualified file name of an INF file in the driver store that corresponds to a specified INF file in the system INF file directory or a specified file in the driver store.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetInfPublishedName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} DriverStoreLocation A pointer to a NULL-terminated string that contains the fully qualified file name (directory path and file name) of an INF file in the driver store. Alternatively, this parameter is a pointer to a NULL-terminated string that contains the name, and optionally the full directory path, of an INF file in the system INF file directory. For more information about how to specify the INF file, see the following <b>Remarks</b> section.
     * @param {Pointer<PSTR>} ReturnBuffer A pointer to the buffer in which <b>SetupGetInfPublishedName</b> returns a NULL-terminated string that contains the fully qualified file name of the specified INF file in the system INF directory. The maximum path size is MAX_PATH. This pointer can be set to <b>NULL</b>. For information about how to determine the required size of the return buffer, see the following <b>Remarks</b> section.
     * @param {Integer} ReturnBufferSize The size, in characters, of the buffer supplied by <i>ReturnBuffer</i>.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, of the <i>ReturnBuffer</i> buffer. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {Integer} If <b>SetupGetInfPublishedName</b> succeeds, the function returns <b>TRUE</b>; otherwise, the function returns <b>FALSE</b>. To obtain extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the size, in characters, of the fully qualified file name of the requested INF file, including a null-terminator, is greater than <i>ReturnBufferSize</i>, the function will fail, and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinfpublishednamea
     * @since windows6.0.6000
     */
    static SetupGetInfPublishedNameA(DriverStoreLocation, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        DriverStoreLocation := DriverStoreLocation is String? StrPtr(DriverStoreLocation) : DriverStoreLocation
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfPublishedNameA", "ptr", DriverStoreLocation, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfPublishedName function retrieves the fully qualified file name (directory path and file name) of an INF file in the system INF file directory that corresponds to a specified INF file in the driver store or a specified INF file in the system INF file directory. (Unicode)
     * @remarks
     * To determine the size of the return buffer that is required to contain the fully qualified file name of the specified INF file in the system INF directory, call <b>SetupGetInfPublishedName</b> and set <i>ReturnBuffer</i> to <b>NULL</b>, <i>ReturnBufferSize</i> to zero, and supply <i>RequiredSize</i>. <b>SetupGetInfPublishedName</b> will return the required buffer size in <i>RequiredSize</i>.
     * 
     * When device installation preinstalls a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/difx-guidelines">driver package</a> in the driver store, it creates two copies of the driver package INF file. Device installation adds one copy to the system INF directory and assigns that copy of the INF file a unique <i>published file name</i> of the form <i>OEMnnn.inf</i>. Device installation adds a second copy of the INF file to the driver store and assigns that copy the original INF file name.
     * 
     * <b>SetupGetInfPublishedName</b> returns the fully qualified file name of the INF file in the system INF file directory that matches the INF file, if any, that is supplied by <i>DriverStoreLocation</i>. <i>DriverStoreLocation </i> must specify the fully qualified file name of an INF file in the driver store or must specify the file name, and optionally the directory path, of an INF file in the system INF directory. For example, assume that the INF file for a driver package is <i>myinf.inf</i>, and that for this driver package, device installation installs the INF file <i>OEM1.inf</i> in the system INF directory C:<i>\Windows\inf</i>. Further assume that device installation installs the corresponding INF file copy C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf</i> in the driver store. In this case, the function returns C:<i>\Windows\inf\OEM1.inf</i> if <i>DriverStoreLocation</i> supplies one of the following strings: C:<i>\windows\system32\driverstore\filerepository\myinf_12345678\myinf.inf, OEM1.inf</i>, or C:<i>\Windows\inf\OEM1.inf.</i>
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfdriverstorelocationa">SetupGetInfDriverStoreLocation</a> function to retrieve the fully qualified file name of an INF file in the driver store that corresponds to a specified INF file in the system INF file directory or a specified file in the driver store.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetInfPublishedName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} DriverStoreLocation A pointer to a NULL-terminated string that contains the fully qualified file name (directory path and file name) of an INF file in the driver store. Alternatively, this parameter is a pointer to a NULL-terminated string that contains the name, and optionally the full directory path, of an INF file in the system INF file directory. For more information about how to specify the INF file, see the following <b>Remarks</b> section.
     * @param {Pointer<PWSTR>} ReturnBuffer A pointer to the buffer in which <b>SetupGetInfPublishedName</b> returns a NULL-terminated string that contains the fully qualified file name of the specified INF file in the system INF directory. The maximum path size is MAX_PATH. This pointer can be set to <b>NULL</b>. For information about how to determine the required size of the return buffer, see the following <b>Remarks</b> section.
     * @param {Integer} ReturnBufferSize The size, in characters, of the buffer supplied by <i>ReturnBuffer</i>.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, of the <i>ReturnBuffer</i> buffer. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {Integer} If <b>SetupGetInfPublishedName</b> succeeds, the function returns <b>TRUE</b>; otherwise, the function returns <b>FALSE</b>. To obtain extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the size, in characters, of the fully qualified file name of the requested INF file, including a null-terminator, is greater than <i>ReturnBufferSize</i>, the function will fail, and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinfpublishednamew
     * @since windows6.0.6000
     */
    static SetupGetInfPublishedNameW(DriverStoreLocation, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        DriverStoreLocation := DriverStoreLocation is String? StrPtr(DriverStoreLocation) : DriverStoreLocation
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfPublishedNameW", "ptr", DriverStoreLocation, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfFileList function returns a list of INF files located in a caller-specified directory to a call-supplied buffer. (ANSI)
     * @remarks
     * If this function is called with a ReturnBuffer of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * If multiple INF file styles are returned by this function, the style of a particular INF file can be determined by calling the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetInfFileList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} DirectoryPath Optional pointer to a <b>null</b>-terminated string containing the path of the directory in which to search. If this value is <b>NULL</b>, the %windir%\inf directory is used.
     * @param {Integer} InfStyle Type of INF file to search for. May be a combination of the following flags.
     * @param {Pointer<PSTR>} ReturnBuffer If not <b>NULL</b>, points to a buffer in which this function returns the list of all INF files of the desired styles that were found in the specified subdirectory. File names are <b>null</b>-terminated, with an extra <b>null</b> at the end of the list. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. The filenames do not include the path. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is not specified, <i>ReturnBufferSize</i> is ignored.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinffilelista
     * @since windows5.1.2600
     */
    static SetupGetInfFileListA(DirectoryPath, InfStyle, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        DirectoryPath := DirectoryPath is String? StrPtr(DirectoryPath) : DirectoryPath
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfFileListA", "ptr", DirectoryPath, "uint", InfStyle, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetInfFileList function returns a list of INF files located in a caller-specified directory to a call-supplied buffer. (Unicode)
     * @remarks
     * If this function is called with a ReturnBuffer of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * If multiple INF file styles are returned by this function, the style of a particular INF file can be determined by calling the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetInfFileList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} DirectoryPath Optional pointer to a <b>null</b>-terminated string containing the path of the directory in which to search. If this value is <b>NULL</b>, the %windir%\inf directory is used.
     * @param {Integer} InfStyle Type of INF file to search for. May be a combination of the following flags.
     * @param {Pointer<PWSTR>} ReturnBuffer If not <b>NULL</b>, points to a buffer in which this function returns the list of all INF files of the desired styles that were found in the specified subdirectory. File names are <b>null</b>-terminated, with an extra <b>null</b> at the end of the list. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. The filenames do not include the path. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is not specified, <i>ReturnBufferSize</i> is ignored.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetinffilelistw
     * @since windows5.1.2600
     */
    static SetupGetInfFileListW(DirectoryPath, InfStyle, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        DirectoryPath := DirectoryPath is String? StrPtr(DirectoryPath) : DirectoryPath
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetInfFileListW", "ptr", DirectoryPath, "uint", InfStyle, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenInfFile function opens an INF file and returns a handle to it. (Unicode)
     * @remarks
     * If the load fails because the INF file type does not match <i>InfClass</i>, the function returns INVALID_HANDLE_VALUE and a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_CLASS_MISMATCH.
     * 
     * If multiple INF file styles are specified, the style of the INF file opened can be determined by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * 
     * Because there may be more than one class GUID with the same class name, callers interested in INF files of a particular class (that is, a particular class GUID) should retrieve the ClassGUID value from the INF file by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupqueryinfversioninformationa">SetupQueryInfVersionInformation</a>.
     * 
     * For legacy INF files, the <i>InfClass</i> string must match the type specified in the OptionType value of the <b>Identification</b> section in the INF file (for example, OptionType=NetAdapter).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupOpenInfFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} FileName Pointer to a null-terminated string containing the name (and optional path) of the INF file to be opened. If the filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be a full path specification and no further processing is performed on it.
     * @param {Pointer<PWSTR>} InfClass Optional pointer to a null-terminated string containing the class of INF file desired. This string must match the Class value of the <b>Version</b> section (for example, Class=Net). If there is no entry in the Class value, but there is an entry for ClassGUID in the <b>Version</b> section, the corresponding class name for that GUID is retrieved and used for the comparison.
     * @param {Integer} InfStyle Style of INF file to open or search for. This parameter can be a combination of the following flags.
     * @param {Pointer<UInt32>} ErrorLine Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred during loading of the INF file. This value is generally reliable only if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not return ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupopeninffilew
     * @since windows5.1.2600
     */
    static SetupOpenInfFileW(FileName, InfClass, InfStyle, ErrorLine) {
        FileName := FileName is String? StrPtr(FileName) : FileName
        InfClass := InfClass is String? StrPtr(InfClass) : InfClass

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupOpenInfFileW", "ptr", FileName, "ptr", InfClass, "uint", InfStyle, "ptr", ErrorLine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupOpenInfFile function opens an INF file and returns a handle to it. (ANSI)
     * @remarks
     * If the load fails because the INF file type does not match <i>InfClass</i>, the function returns INVALID_HANDLE_VALUE and a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_CLASS_MISMATCH.
     * 
     * If multiple INF file styles are specified, the style of the INF file opened can be determined by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetinfinformationa">SetupGetInfInformation</a> function.
     * 
     * Because there may be more than one class GUID with the same class name, callers interested in INF files of a particular class (that is, a particular class GUID) should retrieve the ClassGUID value from the INF file by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupqueryinfversioninformationa">SetupQueryInfVersionInformation</a>.
     * 
     * For legacy INF files, the <i>InfClass</i> string must match the type specified in the OptionType value of the <b>Identification</b> section in the INF file (for example, OptionType=NetAdapter).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupOpenInfFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} FileName Pointer to a null-terminated string containing the name (and optional path) of the INF file to be opened. If the filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be a full path specification and no further processing is performed on it.
     * @param {Pointer<PSTR>} InfClass Optional pointer to a null-terminated string containing the class of INF file desired. This string must match the Class value of the <b>Version</b> section (for example, Class=Net). If there is no entry in the Class value, but there is an entry for ClassGUID in the <b>Version</b> section, the corresponding class name for that GUID is retrieved and used for the comparison.
     * @param {Integer} InfStyle Style of INF file to open or search for. This parameter can be a combination of the following flags.
     * @param {Pointer<UInt32>} ErrorLine Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred during loading of the INF file. This value is generally reliable only if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not return ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupopeninffilea
     * @since windows5.1.2600
     */
    static SetupOpenInfFileA(FileName, InfClass, InfStyle, ErrorLine) {
        FileName := FileName is String? StrPtr(FileName) : FileName
        InfClass := InfClass is String? StrPtr(InfClass) : InfClass

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupOpenInfFileA", "ptr", FileName, "ptr", InfClass, "uint", InfStyle, "ptr", ErrorLine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupOpenMasterInf function opens the master INF file that contains file and layout information for files shipped with Windows.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupopenmasterinf
     * @since windows5.1.2600
     */
    static SetupOpenMasterInf() {
        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupOpenMasterInf")
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupOpenAppendInfFile function appends the information in an INF file to an INF file previously opened by SetupOpenInfFile. (Unicode)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. In this case, the function returns <b>FALSE</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_PARAMETER. The main purpose of this function is to combine an INF file with the source file location information contained in the file specified in the LayoutFile entry of the <b>Version</b> section (typically, LAYOUT.INF).
     * 
     * The ERROR_WRONG_INF_STYLE may also be returned by <b>SetupOpenAppendInfFile</b> if the INF file uses an older format.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupOpenAppendInfFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} FileName If not <b>NULL</b>, <i>FileName</i> points to a <b>null</b>-terminated string containing the name (and optionally the path) of the INF file to be opened. If the filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be a full path specification and no further processing is performed on it. If <i>FileName</i> is <b>NULL</b>, the INF filename is retrieved from the LayoutFile value of the <b>Version</b> section in the existing INF file. The same search logic is applied to the filename retrieved from the LayoutFile key.
     * @param {Pointer<Void>} InfHandle Existing INF handle to which this INF file will be appended.
     * @param {Pointer<UInt32>} ErrorLine Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred during loading of the INF file. This value is generally reliable only if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not return ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>FileName</i> was not specified and there was no LayoutFile value in the <b>Version</b> section of the existing INF File, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DATA.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupopenappendinffilew
     * @since windows5.1.2600
     */
    static SetupOpenAppendInfFileW(FileName, InfHandle, ErrorLine) {
        FileName := FileName is String? StrPtr(FileName) : FileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenAppendInfFileW", "ptr", FileName, "ptr", InfHandle, "ptr", ErrorLine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenAppendInfFile function appends the information in an INF file to an INF file previously opened by SetupOpenInfFile. (ANSI)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. In this case, the function returns <b>FALSE</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_PARAMETER. The main purpose of this function is to combine an INF file with the source file location information contained in the file specified in the LayoutFile entry of the <b>Version</b> section (typically, LAYOUT.INF).
     * 
     * The ERROR_WRONG_INF_STYLE may also be returned by <b>SetupOpenAppendInfFile</b> if the INF file uses an older format.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupOpenAppendInfFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} FileName If not <b>NULL</b>, <i>FileName</i> points to a <b>null</b>-terminated string containing the name (and optionally the path) of the INF file to be opened. If the filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be a full path specification and no further processing is performed on it. If <i>FileName</i> is <b>NULL</b>, the INF filename is retrieved from the LayoutFile value of the <b>Version</b> section in the existing INF file. The same search logic is applied to the filename retrieved from the LayoutFile key.
     * @param {Pointer<Void>} InfHandle Existing INF handle to which this INF file will be appended.
     * @param {Pointer<UInt32>} ErrorLine Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred during loading of the INF file. This value is generally reliable only if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not return ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>FileName</i> was not specified and there was no LayoutFile value in the <b>Version</b> section of the existing INF File, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DATA.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupopenappendinffilea
     * @since windows5.1.2600
     */
    static SetupOpenAppendInfFileA(FileName, InfHandle, ErrorLine) {
        FileName := FileName is String? StrPtr(FileName) : FileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenAppendInfFileA", "ptr", FileName, "ptr", InfHandle, "ptr", ErrorLine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCloseInfFile function closes the INF file opened by a call to SetupOpenInfFile. This function closes any INF files appended to it by calling SetupOpenAppendInfFile.
     * @param {Pointer<Void>} InfHandle Handle to the INF file to be closed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcloseinffile
     * @since windows5.1.2600
     */
    static SetupCloseInfFile(InfHandle) {
        DllCall("SETUPAPI.dll\SetupCloseInfFile", "ptr", InfHandle)
    }

    /**
     * The SetupFindFirstLine function locates a line in the specified section of an INF file. If the Key parameter is NULL, SetupFindFirstLine returns the first line of the section. (ANSI)
     * @remarks
     * If the <i>InfHandle</i> parameter references multiple INF files that have been appended together using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, the 
     * <b>SetupFindFirstLine</b> function searches across the specified section in all of the files referenced by the specified HINF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupFindFirstLine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file to query.
     * @param {Pointer<PSTR>} Section Pointer to a <b>null</b>-terminated string specifying the section of the INF files to search in.
     * @param {Pointer<PSTR>} Key Optional pointer to a <b>null</b>-terminated string specifying the key to search for within the section. The <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be <b>NULL</b>. If <i>Key</i> is <b>NULL</b>, the first line in the section is returned.
     * @param {Pointer<INFCONTEXT>} Context Pointer to a structure that receives the context information used internally by the INF handle. Applications must not overwrite values in this structure.
     * @returns {Integer} If the function could not find a line, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupfindfirstlinea
     * @since windows5.1.2600
     */
    static SetupFindFirstLineA(InfHandle, Section, Key, Context) {
        Section := Section is String? StrPtr(Section) : Section
        Key := Key is String? StrPtr(Key) : Key

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindFirstLineA", "ptr", InfHandle, "ptr", Section, "ptr", Key, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFindFirstLine function locates a line in the specified section of an INF file. If the Key parameter is NULL, SetupFindFirstLine returns the first line of the section. (Unicode)
     * @remarks
     * If the <i>InfHandle</i> parameter references multiple INF files that have been appended together using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, the 
     * <b>SetupFindFirstLine</b> function searches across the specified section in all of the files referenced by the specified HINF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupFindFirstLine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file to query.
     * @param {Pointer<PWSTR>} Section Pointer to a <b>null</b>-terminated string specifying the section of the INF files to search in.
     * @param {Pointer<PWSTR>} Key Optional pointer to a <b>null</b>-terminated string specifying the key to search for within the section. The <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be <b>NULL</b>. If <i>Key</i> is <b>NULL</b>, the first line in the section is returned.
     * @param {Pointer<INFCONTEXT>} Context Pointer to a structure that receives the context information used internally by the INF handle. Applications must not overwrite values in this structure.
     * @returns {Integer} If the function could not find a line, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupfindfirstlinew
     * @since windows5.1.2600
     */
    static SetupFindFirstLineW(InfHandle, Section, Key, Context) {
        Section := Section is String? StrPtr(Section) : Section
        Key := Key is String? StrPtr(Key) : Key

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindFirstLineW", "ptr", InfHandle, "ptr", Section, "ptr", Key, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFindNextLine returns the location of the next line in an INF file section relative to ContextIn.Line.
     * @remarks
     * If <i>ContextIn.Line</i> references multiple INF files that have been appended together using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, this function searches across the specified section in all files referenced by the HINF to locate the next line.
     * @param {Pointer<INFCONTEXT>} ContextIn Pointer to the INF file context retrieved by a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindfirstlinea">SetupFindFirstLine</a> function.
     * @param {Pointer<INFCONTEXT>} ContextOut Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point to <i>ContextIn</i> if the caller wishes.
     * @returns {Integer} If this function finds the next line, the return value is a nonzero value. Otherwise, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupfindnextline
     * @since windows5.1.2600
     */
    static SetupFindNextLine(ContextIn, ContextOut) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindNextLine", "ptr", ContextIn, "ptr", ContextOut, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFindNextMatchLine function returns the location of the next line in an INF file relative to ContextIn.Line that matches a specified key. (ANSI)
     * @remarks
     * If <i>ContextIn.Inf</i> references multiple INF files that have been appended together using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, the 
     * <b>SetupFindNextMatchLine</b> function searches across the specified section in all files referenced by the HINF to locate the next matching line.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupFindNextMatchLine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} ContextIn Pointer to an INF file context, as retrieved by a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindfirstlinea">SetupFindFirstLine</a> function.
     * @param {Pointer<PSTR>} Key If this optional parameter is specified, it supplies a key to match. This parameter should be a null-terminated string. This parameter can be Null. If <i>Key</i> is not specified, the 
     * <b>SetupFindNextMatchLine</b> function is equivalent to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindnextline">SetupFindNextLine</a> function.
     * @param {Pointer<INFCONTEXT>} ContextOut Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point to <i>ContextIn</i> if the caller wishes.
     * @returns {Integer} The function returns a nonzero value if it finds a matching line. Otherwise, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupfindnextmatchlinea
     * @since windows5.1.2600
     */
    static SetupFindNextMatchLineA(ContextIn, Key, ContextOut) {
        Key := Key is String? StrPtr(Key) : Key

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindNextMatchLineA", "ptr", ContextIn, "ptr", Key, "ptr", ContextOut, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFindNextMatchLine function returns the location of the next line in an INF file relative to ContextIn.Line that matches a specified key. (Unicode)
     * @remarks
     * If <i>ContextIn.Inf</i> references multiple INF files that have been appended together using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, the 
     * <b>SetupFindNextMatchLine</b> function searches across the specified section in all files referenced by the HINF to locate the next matching line.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupFindNextMatchLine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} ContextIn Pointer to an INF file context, as retrieved by a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindfirstlinea">SetupFindFirstLine</a> function.
     * @param {Pointer<PWSTR>} Key If this optional parameter is specified, it supplies a key to match. This parameter should be a null-terminated string. This parameter can be Null. If <i>Key</i> is not specified, the 
     * <b>SetupFindNextMatchLine</b> function is equivalent to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfindnextline">SetupFindNextLine</a> function.
     * @param {Pointer<INFCONTEXT>} ContextOut Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point to <i>ContextIn</i> if the caller wishes.
     * @returns {Integer} The function returns a nonzero value if it finds a matching line. Otherwise, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupfindnextmatchlinew
     * @since windows5.1.2600
     */
    static SetupFindNextMatchLineW(ContextIn, Key, ContextOut) {
        Key := Key is String? StrPtr(Key) : Key

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFindNextMatchLineW", "ptr", ContextIn, "ptr", Key, "ptr", ContextOut, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineByIndex function locates a line by its index value in the specified section in the INF file. (ANSI)
     * @remarks
     * If <i>InfHandle</i> references multiple INF files that have been appended together using 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, this function 
     *     searches across the specified section in all files referenced by the HINF to locate the indexed line.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetLineByIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file.
     * @param {Pointer<PSTR>} Section Pointer to a null-terminated string specifying the section of the INF file to search.
     * @param {Integer} Index Index of the line to be located. The total number of lines in a particular section can be found with a 
     *       call to <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetlinecounta">SetupGetLineCount</a>.
     * @param {Pointer<INFCONTEXT>} Context Pointer to a variable that receives the context information for the found line.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 
     *        zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetlinebyindexa
     * @since windows5.1.2600
     */
    static SetupGetLineByIndexA(InfHandle, Section, Index, Context) {
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineByIndexA", "ptr", InfHandle, "ptr", Section, "uint", Index, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineByIndex function locates a line by its index value in the specified section in the INF file. (Unicode)
     * @remarks
     * If <i>InfHandle</i> references multiple INF files that have been appended together using 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, this function 
     *     searches across the specified section in all files referenced by the HINF to locate the indexed line.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetLineByIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file.
     * @param {Pointer<PWSTR>} Section Pointer to a null-terminated string specifying the section of the INF file to search.
     * @param {Integer} Index Index of the line to be located. The total number of lines in a particular section can be found with a 
     *       call to <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetlinecounta">SetupGetLineCount</a>.
     * @param {Pointer<INFCONTEXT>} Context Pointer to a variable that receives the context information for the found line.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 
     *        zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetlinebyindexw
     * @since windows5.1.2600
     */
    static SetupGetLineByIndexW(InfHandle, Section, Index, Context) {
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineByIndexW", "ptr", InfHandle, "ptr", Section, "uint", Index, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineCount function returns the number of lines in a specified section of an INF file. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetLineCount as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file.
     * @param {Pointer<PSTR>} Section Pointer to a null-terminated string that specifies the section in which you want to count the lines.
     * @returns {Integer} If <i>InfHandle</i> references multiple INF files that have been appended  using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, this function returns the sum of the lines in all of the INF files containing the specified section. A return value of 0 specifies an empty section. If the section does not exist, the function returns 1.
     * 
     * To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetlinecounta
     * @since windows5.1.2600
     */
    static SetupGetLineCountA(InfHandle, Section) {
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineCountA", "ptr", InfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineCount function returns the number of lines in a specified section of an INF file. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetLineCount as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file.
     * @param {Pointer<PWSTR>} Section Pointer to a null-terminated string that specifies the section in which you want to count the lines.
     * @returns {Integer} If <i>InfHandle</i> references multiple INF files that have been appended  using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenappendinffilea">SetupOpenAppendInfFile</a>, this function returns the sum of the lines in all of the INF files containing the specified section. A return value of 0 specifies an empty section. If the section does not exist, the function returns 1.
     * 
     * To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetlinecountw
     * @since windows5.1.2600
     */
    static SetupGetLineCountW(InfHandle, Section) {
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineCountW", "ptr", InfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineText function returns the contents of a line in an INF file in a compact form. (ANSI)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size required to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * This function returns the contents of a line in a compact format. All extraneous white space is removed and multi-line values are converted into a single contiguous string. For example, this line:
     * 
     * 
     * ``` syntax
     * HKLM, , PointerClass0, 1 \
     * ; This is a comment
     * 01, 02, 03
     * ```
     * 
     * would be returned as:
     * 
     * 
     * ``` syntax
     * HKLM,,PointerClass0,1,01,02,03
     * ```
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetLineText as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} Context Context for a line in an INF file whose text is to be retrieved. This parameter can be <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
     * @param {Pointer<Void>} InfHandle Handle to the INF file to query. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
     * @param {Pointer<PSTR>} Section Pointer to a <b>null</b>-terminated string that specifies the section that  contains the key name of the line whose text is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
     * @param {Pointer<PSTR>} Key Pointer to a <b>null</b>-terminated string that contains the key name whose associated string is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
     * @param {Pointer<PSTR>} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> points to a buffer in which this function returns the contents of the line. The <b>null</b>-terminated string must not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the size required is larger than the value specified in the <i>ReturnBufferSize</i> parameter, the function fails and does not store data in the buffer.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetlinetexta
     * @since windows5.1.2600
     */
    static SetupGetLineTextA(Context, InfHandle, Section, Key, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Section := Section is String? StrPtr(Section) : Section
        Key := Key is String? StrPtr(Key) : Key
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineTextA", "ptr", Context, "ptr", InfHandle, "ptr", Section, "ptr", Key, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetLineText function returns the contents of a line in an INF file in a compact form. (Unicode)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size required to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * This function returns the contents of a line in a compact format. All extraneous white space is removed and multi-line values are converted into a single contiguous string. For example, this line:
     * 
     * 
     * ``` syntax
     * HKLM, , PointerClass0, 1 \
     * ; This is a comment
     * 01, 02, 03
     * ```
     * 
     * would be returned as:
     * 
     * 
     * ``` syntax
     * HKLM,,PointerClass0,1,01,02,03
     * ```
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetLineText as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} Context Context for a line in an INF file whose text is to be retrieved. This parameter can be <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
     * @param {Pointer<Void>} InfHandle Handle to the INF file to query. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
     * @param {Pointer<PWSTR>} Section Pointer to a <b>null</b>-terminated string that specifies the section that  contains the key name of the line whose text is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
     * @param {Pointer<PWSTR>} Key Pointer to a <b>null</b>-terminated string that contains the key name whose associated string is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
     * @param {Pointer<PWSTR>} ReturnBuffer If not <b>NULL</b>, <i>ReturnBuffer</i> points to a buffer in which this function returns the contents of the line. The <b>null</b>-terminated string must not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the size required is larger than the value specified in the <i>ReturnBufferSize</i> parameter, the function fails and does not store data in the buffer.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetlinetextw
     * @since windows5.1.2600
     */
    static SetupGetLineTextW(Context, InfHandle, Section, Key, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Section := Section is String? StrPtr(Section) : Section
        Key := Key is String? StrPtr(Key) : Key
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetLineTextW", "ptr", Context, "ptr", InfHandle, "ptr", Section, "ptr", Key, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFieldCount function retrieves the number of fields in the specified line in an INF file.
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @returns {Integer} This function returns the number of fields on the line. If <i>Context</i> is invalid, 0 is returned. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetfieldcount
     * @since windows5.1.2600
     */
    static SetupGetFieldCount(Context) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFieldCount", "ptr", Context, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetStringField function retrieves a string from the specified field of a line in an INF file. (ANSI)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size.
     * 
     * 
     * 
     * Note that the maximum length of any single string specified in an INF Strings section is 512 characters, including the terminating <b>NULL</b>. If the string length is greater than 512 it will be truncated and no error will be returned. The maximum length of any concatenated string created from one or more %strkey% tokens is 4096 characters.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetStringField as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the field within the specified line from which the string should be retrieved. Use a <i>FieldIndex</i> of 0 to retrieve a string key, if present.
     * @param {Pointer<PSTR>} ReturnBuffer Optional pointer to a  buffer that receives the <b>null</b>-terminated string. You should ensure the destination buffer is the same size or larger than the source buffer.  This parameter can be <b>NULL</b>. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size  for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. If <i>ReturnBuffer</i> is specified and the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and does not store the string in the buffer. In this case, a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.  For the Unicode version of this function, the required size is in characters. This includes the <b>null</b> terminator.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetstringfielda
     * @since windows5.1.2600
     */
    static SetupGetStringFieldA(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetStringFieldA", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetStringField function retrieves a string from the specified field of a line in an INF file. (Unicode)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size.
     * 
     * 
     * 
     * Note that the maximum length of any single string specified in an INF Strings section is 512 characters, including the terminating <b>NULL</b>. If the string length is greater than 512 it will be truncated and no error will be returned. The maximum length of any concatenated string created from one or more %strkey% tokens is 4096 characters.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetStringField as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the field within the specified line from which the string should be retrieved. Use a <i>FieldIndex</i> of 0 to retrieve a string key, if present.
     * @param {Pointer<PWSTR>} ReturnBuffer Optional pointer to a  buffer that receives the <b>null</b>-terminated string. You should ensure the destination buffer is the same size or larger than the source buffer.  This parameter can be <b>NULL</b>. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size  for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. If <i>ReturnBuffer</i> is specified and the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and does not store the string in the buffer. In this case, a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.  For the Unicode version of this function, the required size is in characters. This includes the <b>null</b> terminator.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetstringfieldw
     * @since windows5.1.2600
     */
    static SetupGetStringFieldW(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetStringFieldW", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetIntField function retrieves an integer value from the specified field of a line in an INF file.
     * @remarks
     * The integer field may start with a positive (+) or negative (-) sign. It will be interpreted as a decimal number, unless  prefixed in the file with 0x or 0X, in which case it is hexadecimal.
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the field within the specified line from which the integer should be retrieved. 
     * 
     * 
     * 
     * 
     * A <i>FieldIndex</i> of 0 can be used to retrieve an integer key (For example, consider the following INF line, 431 = 1, 2, 4. The value 431 would be put into the variable pointed at by <i>IntegerValue</i> if 
     * <b>SetupGetIntField</b> was called with a <i>FieldIndex</i> of 0).
     * @param {Pointer<Int32>} IntegerValue Pointer to a variable that receives the integer. If the field is not an integer, the function fails and a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DATA.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetintfield
     * @since windows5.1.2600
     */
    static SetupGetIntField(Context, FieldIndex, IntegerValue) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetIntField", "ptr", Context, "uint", FieldIndex, "ptr", IntegerValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetMultiSzField function retrieves multiple strings stored in a line of an INF file, from the specified field to the end of the line. (ANSI)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * <b>SetupGetMultiSzField</b> should not be used to iterate through string values on an INF line. Instead you should use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetstringfielda">SetupGetStringField</a>. <b>SetupGetMultiSzField</b> returns a value in the format of REG_MULTI_SZ. This is an array of <b>null</b>-terminated strings terminated by an extra <b>null</b> character. This format does not allow zero-length strings. If the list of strings contains any zero-length strings, <b>SetupGetMultiSzField</b> will return prematurely when it encounters the first blank string value. 
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetMultiSzField as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the starting field within the specified line from which the strings should be retrieved. The string list is built from each field starting at this point to the end of the line. A <i>FieldIndex</i> of zero is not valid with this function.
     * @param {Pointer<PSTR>} ReturnBuffer Optional pointer to a character buffer that receives the strings. Each string is <b>null</b>-terminated, with an extra <b>null</b> at the end of the string list. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the size required for the buffer pointed to by <i>ReturnBuffer</i>, in  characters. This includes the <b>null</b> terminator. If the size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetmultiszfielda
     * @since windows5.1.2600
     */
    static SetupGetMultiSzFieldA(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetMultiSzFieldA", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetMultiSzField function retrieves multiple strings stored in a line of an INF file, from the specified field to the end of the line. (Unicode)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * <b>SetupGetMultiSzField</b> should not be used to iterate through string values on an INF line. Instead you should use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetstringfielda">SetupGetStringField</a>. <b>SetupGetMultiSzField</b> returns a value in the format of REG_MULTI_SZ. This is an array of <b>null</b>-terminated strings terminated by an extra <b>null</b> character. This format does not allow zero-length strings. If the list of strings contains any zero-length strings, <b>SetupGetMultiSzField</b> will return prematurely when it encounters the first blank string value. 
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetMultiSzField as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} Context Pointer to the context for a line in an INF file.
     * @param {Integer} FieldIndex The 1-based index of the starting field within the specified line from which the strings should be retrieved. The string list is built from each field starting at this point to the end of the line. A <i>FieldIndex</i> of zero is not valid with this function.
     * @param {Pointer<PWSTR>} ReturnBuffer Optional pointer to a character buffer that receives the strings. Each string is <b>null</b>-terminated, with an extra <b>null</b> at the end of the string list. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the size required for the buffer pointed to by <i>ReturnBuffer</i>, in  characters. This includes the <b>null</b> terminator. If the size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetmultiszfieldw
     * @since windows5.1.2600
     */
    static SetupGetMultiSzFieldW(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetMultiSzFieldW", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetBinaryField function retrieves binary data from a line in an INF file section, from the specified field to the end of the line.
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * To better understand how this function works, consider the following line from an INF file.
     * 
     * 
     * ``` syntax
     * X=34,FF,00,13
     * ```
     * 
     * If 
     * <b>SetupGetBinaryField</b> was called on the preceding line, the binary values 34, FF, 00, and 13 would be put into the buffer specified by <i>ReturnBuffer</i>.
     * 
     * For the Unicode version of this function, the buffer sizes <i>ReturnBufferSize</i> and <i>RequiredSize</i> are specified in number of characters. This number includes the <b>null</b> terminator. For the ANSI version of this function, the sizes are specified in number of bytes.
     * 
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Thus, you can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size.
     * @param {Pointer<INFCONTEXT>} Context INF context for the line.
     * @param {Integer} FieldIndex The 1-based index of the starting field within the specified line from which the binary data should be retrieved. The binary data is built from each field, starting at this point to the end of the line. Each field corresponds to 1 byte and is in hexadecimal notation. A <i>FieldIndex</i> of zero is not valid with this function.
     * @param {Pointer<Byte>} ReturnBuffer Optional pointer to a buffer that receives the binary data. You should ensure the destination buffer is the same size or larger than the source buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size for the buffer pointed to <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b> terminator. If the size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DATA if a field that 
     * <b>SetupGetBinaryField</b> retrieves is not a valid hexadecimal number in the range 0-FF.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetbinaryfield
     * @since windows5.1.2600
     */
    static SetupGetBinaryField(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetBinaryField", "ptr", Context, "uint", FieldIndex, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileCompressionInfo function examines a physical file to determine if it is compressed and gets its full path, size, and the size of the uncompressed target file. (ANSI)
     * @remarks
     * Do not use 
     * <b>SetupGetFileCompressionInfo</b>, instead always use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetfilecompressioninfoexa">SetupGetFileCompressionInfoEx</a>.
     * 
     * Because 
     * <b>SetupGetFileCompressionInfo</b> determines the compression by referencing the physical file, your setup application should ensure that the file is present before calling 
     * <b>SetupGetFileCompressionInfo</b>.
     * 
     * Note that if the version of SetupAPI.dll is less than 5.0.2195, then the caller needs to use the exported function <b>MyFree</b> from SetupAPI to free the memory allocated by this function, rather then using <b>LocalFree</b>. If the call to <b>LocalFree</b>  causes an Access Violation, you should solve the problem by using <b>MyFree</b>. 
     * 
     * The following is an example of how to obtain the <b>MyFree</b> function from the SetupAPI.dll: 
     * 
     * 
     * 
     * ``` syntax
     * typedef VOID (WINAPI* MYFREEFUNC)(LPVOID lpBuff);
     *    MYFREEFUNC MyFree;
     * 
     *    HMODULE hDll=NULL;
     *    hDll = GetModuleHandle("SETUPAPI.DLL");
     *    MyFree = (MYFREEFUNC)GetProcAddress(hDll, "MyFree");
     *    ...
     *    other code here to prepare file queue
     *    ...
     *    PTSTR lpActualSourceFileName;
     *    SetupGetFileCompressionInfo(...,&amp;lpActualSourceFileName,...,...,...);
     *    ...
     *    MyFree(lpActualSourceFileName); 
     * ```
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetFileCompressionInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} SourceFileName File name of the file about which information is required. If the file is not found on the source media exactly as named, the file is searched for with up to two alternate "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, F:\mpis\cmd.ex_ is searched for and, if that is not found, a search is done for F:\x86\cmd.ex$. You should use a null-terminated string.
     * @param {Pointer<PSTR>} ActualSourceFileName Pointer to a variable that receives the full path of the file that it has been able to locate. The caller can free the pointer with a call to <b>LocalFree</b>. The path is valid only if the function returns NO_ERROR. Note that if the version of SetupAPI.dll is less than 5.0.2195, then the caller needs to use the exported function <b>MyFree</b> from SetupAPI to free the memory allocated by this function, rather then using <b>LocalFree</b>. See the Remarks section.
     * @param {Pointer<UInt32>} SourceFileSize Pointer to a variable in which this function returns the size of the file in its current form which is the current size of the file named by <i>ActualSourceFileName</i>. The size is determined by examining the source file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR.
     * @param {Pointer<UInt32>} TargetFileSize Pointer to a variable in which this function returns the size the file will occupy when it is uncompressed or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the function returns NO_ERROR.
     * @param {Pointer<UInt32>} CompressionType Pointer to a variable in which this function returns a value indicating the type of compression used on <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR. The value can be one of the following flags.
     * @returns {Integer} The function returns a <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> that indicates the outcome of the file search. The error code can be one of the following values.
     * 
     * To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetfilecompressioninfoa
     * @since windows5.1.2600
     */
    static SetupGetFileCompressionInfoA(SourceFileName, ActualSourceFileName, SourceFileSize, TargetFileSize, CompressionType) {
        SourceFileName := SourceFileName is String? StrPtr(SourceFileName) : SourceFileName
        ActualSourceFileName := ActualSourceFileName is String? StrPtr(ActualSourceFileName) : ActualSourceFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileCompressionInfoA", "ptr", SourceFileName, "ptr", ActualSourceFileName, "ptr", SourceFileSize, "ptr", TargetFileSize, "ptr", CompressionType, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileCompressionInfo function examines a physical file to determine if it is compressed and gets its full path, size, and the size of the uncompressed target file. (Unicode)
     * @remarks
     * Do not use 
     * <b>SetupGetFileCompressionInfo</b>, instead always use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetfilecompressioninfoexa">SetupGetFileCompressionInfoEx</a>.
     * 
     * Because 
     * <b>SetupGetFileCompressionInfo</b> determines the compression by referencing the physical file, your setup application should ensure that the file is present before calling 
     * <b>SetupGetFileCompressionInfo</b>.
     * 
     * Note that if the version of SetupAPI.dll is less than 5.0.2195, then the caller needs to use the exported function <b>MyFree</b> from SetupAPI to free the memory allocated by this function, rather then using <b>LocalFree</b>. If the call to <b>LocalFree</b>  causes an Access Violation, you should solve the problem by using <b>MyFree</b>. 
     * 
     * The following is an example of how to obtain the <b>MyFree</b> function from the SetupAPI.dll: 
     * 
     * 
     * 
     * ``` syntax
     * typedef VOID (WINAPI* MYFREEFUNC)(LPVOID lpBuff);
     *    MYFREEFUNC MyFree;
     * 
     *    HMODULE hDll=NULL;
     *    hDll = GetModuleHandle("SETUPAPI.DLL");
     *    MyFree = (MYFREEFUNC)GetProcAddress(hDll, "MyFree");
     *    ...
     *    other code here to prepare file queue
     *    ...
     *    PTSTR lpActualSourceFileName;
     *    SetupGetFileCompressionInfo(...,&amp;lpActualSourceFileName,...,...,...);
     *    ...
     *    MyFree(lpActualSourceFileName); 
     * ```
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetFileCompressionInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} SourceFileName File name of the file about which information is required. If the file is not found on the source media exactly as named, the file is searched for with up to two alternate "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, F:\mpis\cmd.ex_ is searched for and, if that is not found, a search is done for F:\x86\cmd.ex$. You should use a null-terminated string.
     * @param {Pointer<PWSTR>} ActualSourceFileName Pointer to a variable that receives the full path of the file that it has been able to locate. The caller can free the pointer with a call to <b>LocalFree</b>. The path is valid only if the function returns NO_ERROR. Note that if the version of SetupAPI.dll is less than 5.0.2195, then the caller needs to use the exported function <b>MyFree</b> from SetupAPI to free the memory allocated by this function, rather then using <b>LocalFree</b>. See the Remarks section.
     * @param {Pointer<UInt32>} SourceFileSize Pointer to a variable in which this function returns the size of the file in its current form which is the current size of the file named by <i>ActualSourceFileName</i>. The size is determined by examining the source file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR.
     * @param {Pointer<UInt32>} TargetFileSize Pointer to a variable in which this function returns the size the file will occupy when it is uncompressed or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the function returns NO_ERROR.
     * @param {Pointer<UInt32>} CompressionType Pointer to a variable in which this function returns a value indicating the type of compression used on <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR. The value can be one of the following flags.
     * @returns {Integer} The function returns a <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> that indicates the outcome of the file search. The error code can be one of the following values.
     * 
     * To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetfilecompressioninfow
     * @since windows5.1.2600
     */
    static SetupGetFileCompressionInfoW(SourceFileName, ActualSourceFileName, SourceFileSize, TargetFileSize, CompressionType) {
        SourceFileName := SourceFileName is String? StrPtr(SourceFileName) : SourceFileName
        ActualSourceFileName := ActualSourceFileName is String? StrPtr(ActualSourceFileName) : ActualSourceFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileCompressionInfoW", "ptr", SourceFileName, "ptr", ActualSourceFileName, "ptr", SourceFileSize, "ptr", TargetFileSize, "ptr", CompressionType, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileCompressionInfoEx function examines a potentially compressed file and gets the type of compression, the file's full path (including file name), the compressed size, and the size of the uncompressed target file. (ANSI)
     * @remarks
     * Because 
     * <b>SetupGetFileCompressionInfoEx</b> determines the compression by examining the physical file, your setup application should ensure that the file is present before calling 
     * <b>SetupGetFileCompressionInfoEx</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetFileCompressionInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} SourceFileName File name of the potentially compressed file to be examined. If the file is not found on the source media exactly as named, Setup searches for up to two alternate names. For example; if Setup does not find F:\x86\cmd.exe, it searches for F:\mpis\cmd.ex_ and if that name is not found, it searches for F:\x86\cmd.ex$.
     * @param {Pointer<PSTR>} ActualSourceFileNameBuffer Pointer to a  buffer that receives the actual file name and path if this parameter is not <b>NULL</b>. This is valid only if the function returns NO_ERROR.
     * @param {Integer} ActualSourceFileNameBufferLen Size of the buffer specified by <i>ActualSourceFileNameBuffer</i>, in characters. You would typically use a buffer size of MAX_PATH. If <i>ActualSourceFileNameLen</i> is too small, the function fails with ERROR_INSUFFICIENT_BUFFER. <i>ActualSourceFileNameLen</i> must contain zero if <i>ActualSourceFileNameBuffer</i> is <b>NULL</b>.
     * @param {Pointer<UInt32>} RequiredBufferLen Size of the file name and full path including the terminating <b>NULL</b>, if this parameter is not <b>NULL</b>. If <i>ActualSourceFileNameBuffer</i> is <b>NULL</b> and <i>ActualSourceFileNameLen</i> is zero, the function succeeds but fills in <i>RequiredBufferLen</i>. This parameter is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} SourceFileSize Pointer to a variable in which this function returns the size of the file in its current form, which is the current size of the file named by <i>ActualSourceFileNameBuffer</i>. The size is determined by examining the source file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} TargetFileSize Pointer to a variable in which this function returns the size that the file will occupy when it is uncompressed or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} CompressionType Pointer to a variable in which this function returns a value indicating the type of compression used on <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER. This parameter value can be one of the following flags.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b> (nonzero).
     * 
     * If the function fails, the return value is <b>FALSE</b> (zero). The function can also return one of the following  <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error codes</a>.
     * 
     * To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetfilecompressioninfoexa
     * @since windows5.1.2600
     */
    static SetupGetFileCompressionInfoExA(SourceFileName, ActualSourceFileNameBuffer, ActualSourceFileNameBufferLen, RequiredBufferLen, SourceFileSize, TargetFileSize, CompressionType) {
        SourceFileName := SourceFileName is String? StrPtr(SourceFileName) : SourceFileName
        ActualSourceFileNameBuffer := ActualSourceFileNameBuffer is String? StrPtr(ActualSourceFileNameBuffer) : ActualSourceFileNameBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileCompressionInfoExA", "ptr", SourceFileName, "ptr", ActualSourceFileNameBuffer, "uint", ActualSourceFileNameBufferLen, "ptr", RequiredBufferLen, "ptr", SourceFileSize, "ptr", TargetFileSize, "ptr", CompressionType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileCompressionInfoEx function examines a potentially compressed file and gets the type of compression, the file's full path (including file name), the compressed size, and the size of the uncompressed target file. (Unicode)
     * @remarks
     * Because 
     * <b>SetupGetFileCompressionInfoEx</b> determines the compression by examining the physical file, your setup application should ensure that the file is present before calling 
     * <b>SetupGetFileCompressionInfoEx</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetFileCompressionInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} SourceFileName File name of the potentially compressed file to be examined. If the file is not found on the source media exactly as named, Setup searches for up to two alternate names. For example; if Setup does not find F:\x86\cmd.exe, it searches for F:\mpis\cmd.ex_ and if that name is not found, it searches for F:\x86\cmd.ex$.
     * @param {Pointer<PWSTR>} ActualSourceFileNameBuffer Pointer to a  buffer that receives the actual file name and path if this parameter is not <b>NULL</b>. This is valid only if the function returns NO_ERROR.
     * @param {Integer} ActualSourceFileNameBufferLen Size of the buffer specified by <i>ActualSourceFileNameBuffer</i>, in characters. You would typically use a buffer size of MAX_PATH. If <i>ActualSourceFileNameLen</i> is too small, the function fails with ERROR_INSUFFICIENT_BUFFER. <i>ActualSourceFileNameLen</i> must contain zero if <i>ActualSourceFileNameBuffer</i> is <b>NULL</b>.
     * @param {Pointer<UInt32>} RequiredBufferLen Size of the file name and full path including the terminating <b>NULL</b>, if this parameter is not <b>NULL</b>. If <i>ActualSourceFileNameBuffer</i> is <b>NULL</b> and <i>ActualSourceFileNameLen</i> is zero, the function succeeds but fills in <i>RequiredBufferLen</i>. This parameter is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} SourceFileSize Pointer to a variable in which this function returns the size of the file in its current form, which is the current size of the file named by <i>ActualSourceFileNameBuffer</i>. The size is determined by examining the source file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} TargetFileSize Pointer to a variable in which this function returns the size that the file will occupy when it is uncompressed or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} CompressionType Pointer to a variable in which this function returns a value indicating the type of compression used on <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER. This parameter value can be one of the following flags.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b> (nonzero).
     * 
     * If the function fails, the return value is <b>FALSE</b> (zero). The function can also return one of the following  <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error codes</a>.
     * 
     * To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetfilecompressioninfoexw
     * @since windows5.1.2600
     */
    static SetupGetFileCompressionInfoExW(SourceFileName, ActualSourceFileNameBuffer, ActualSourceFileNameBufferLen, RequiredBufferLen, SourceFileSize, TargetFileSize, CompressionType) {
        SourceFileName := SourceFileName is String? StrPtr(SourceFileName) : SourceFileName
        ActualSourceFileNameBuffer := ActualSourceFileNameBuffer is String? StrPtr(ActualSourceFileNameBuffer) : ActualSourceFileNameBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileCompressionInfoExW", "ptr", SourceFileName, "ptr", ActualSourceFileNameBuffer, "uint", ActualSourceFileNameBufferLen, "ptr", RequiredBufferLen, "ptr", SourceFileSize, "ptr", TargetFileSize, "ptr", CompressionType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDecompressOrCopyFile function copies a file, decompressing it if necessary. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDecompressOrCopyFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} SourceFileName File name of the file to be copied. You should use a <b>null</b>-terminated string. This parameter can be <b>NULL</b>. If <i>CompressionType</i> is not specified and the 
     * <b>SetupDecompressOrCopyFile</b> function does not find the file specified in <i>SourceFileName</i>, the function searches for the file with up to two alternate, "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, the function searches for F:\x86\cmd.ex_ and, if that is not found, F:\x86\cmd.ex$ is searched for. If <i>CompressionType</i> is specified, no additional processing is performed on the filename; the file must exist exactly as specified or the function fails.
     * @param {Pointer<PSTR>} TargetFileName Exact name of the target file that will be created by decompressing or copying the source file. You should use a <b>null</b>-terminated string.
     * @param {Pointer<UInt32>} CompressionType Optional pointer to the compression type used on the source file. You can determine the compression type by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetfilecompressioninfoa">SetupGetFileCompressionInfo</a>. If this value is FILE_COMPRESSION_NONE, the file is copied (not decompressed) regardless of any compression in use on the source. If <i>CompressionType</i> is not specified, this routine determines the compression type automatically.
     * @returns {Integer} The 
     * <b>SetupDecompressOrCopyFile</b> function returns a <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> that indicates the outcome of the operation. 
     * 
     * To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdecompressorcopyfilea
     * @since windows5.1.2600
     */
    static SetupDecompressOrCopyFileA(SourceFileName, TargetFileName, CompressionType) {
        SourceFileName := SourceFileName is String? StrPtr(SourceFileName) : SourceFileName
        TargetFileName := TargetFileName is String? StrPtr(TargetFileName) : TargetFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDecompressOrCopyFileA", "ptr", SourceFileName, "ptr", TargetFileName, "ptr", CompressionType, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDecompressOrCopyFile function copies a file, decompressing it if necessary. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDecompressOrCopyFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} SourceFileName File name of the file to be copied. You should use a <b>null</b>-terminated string. This parameter can be <b>NULL</b>. If <i>CompressionType</i> is not specified and the 
     * <b>SetupDecompressOrCopyFile</b> function does not find the file specified in <i>SourceFileName</i>, the function searches for the file with up to two alternate, "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, the function searches for F:\x86\cmd.ex_ and, if that is not found, F:\x86\cmd.ex$ is searched for. If <i>CompressionType</i> is specified, no additional processing is performed on the filename; the file must exist exactly as specified or the function fails.
     * @param {Pointer<PWSTR>} TargetFileName Exact name of the target file that will be created by decompressing or copying the source file. You should use a <b>null</b>-terminated string.
     * @param {Pointer<UInt32>} CompressionType Optional pointer to the compression type used on the source file. You can determine the compression type by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetfilecompressioninfoa">SetupGetFileCompressionInfo</a>. If this value is FILE_COMPRESSION_NONE, the file is copied (not decompressed) regardless of any compression in use on the source. If <i>CompressionType</i> is not specified, this routine determines the compression type automatically.
     * @returns {Integer} The 
     * <b>SetupDecompressOrCopyFile</b> function returns a <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> that indicates the outcome of the operation. 
     * 
     * To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdecompressorcopyfilew
     * @since windows5.1.2600
     */
    static SetupDecompressOrCopyFileW(SourceFileName, TargetFileName, CompressionType) {
        SourceFileName := SourceFileName is String? StrPtr(SourceFileName) : SourceFileName
        TargetFileName := TargetFileName is String? StrPtr(TargetFileName) : TargetFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDecompressOrCopyFileW", "ptr", SourceFileName, "ptr", TargetFileName, "ptr", CompressionType, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceFileLocation function retrieves the location of a source file listed in an INF file. (ANSI)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetSourceFileLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to the context of a line in a <b>Copy Files</b> section for which the full source path is to be retrieved. If this parameter is <b>NULL</b>, <i>FileName</i> is searched for in the <b>SourceDisksFiles</b> section of the INF file specified by <i>InfHandle</i>.
     * @param {Pointer<PSTR>} FileName Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the full source location. This parameter can be <b>NULL</b>, but either <i>FileName</i> or <i>InfContext</i> must be specified.
     * @param {Pointer<UInt32>} SourceId Pointer to a variable that receives the source identifier of the media where the file is located from the <b>SourceDisksNames</b> section of the INF file.
     * @param {Pointer<PSTR>} ReturnBuffer Optional pointer to a buffer to receive the relative source path. The source path does not include the filename itself, nor does it include a drive letter/network share name. The path does not start or end with a backslash (\), so the empty string specifies the root directory. You should use a <b>null</b>-terminated string buffer. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data.  Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If the required size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetsourcefilelocationa
     * @since windows5.1.2600
     */
    static SetupGetSourceFileLocationA(InfHandle, InfContext, FileName, SourceId, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        FileName := FileName is String? StrPtr(FileName) : FileName
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceFileLocationA", "ptr", InfHandle, "ptr", InfContext, "ptr", FileName, "ptr", SourceId, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceFileLocation function retrieves the location of a source file listed in an INF file. (Unicode)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetSourceFileLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to the context of a line in a <b>Copy Files</b> section for which the full source path is to be retrieved. If this parameter is <b>NULL</b>, <i>FileName</i> is searched for in the <b>SourceDisksFiles</b> section of the INF file specified by <i>InfHandle</i>.
     * @param {Pointer<PWSTR>} FileName Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the full source location. This parameter can be <b>NULL</b>, but either <i>FileName</i> or <i>InfContext</i> must be specified.
     * @param {Pointer<UInt32>} SourceId Pointer to a variable that receives the source identifier of the media where the file is located from the <b>SourceDisksNames</b> section of the INF file.
     * @param {Pointer<PWSTR>} ReturnBuffer Optional pointer to a buffer to receive the relative source path. The source path does not include the filename itself, nor does it include a drive letter/network share name. The path does not start or end with a backslash (\), so the empty string specifies the root directory. You should use a <b>null</b>-terminated string buffer. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data.  Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size for the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If the required size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetsourcefilelocationw
     * @since windows5.1.2600
     */
    static SetupGetSourceFileLocationW(InfHandle, InfContext, FileName, SourceId, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        FileName := FileName is String? StrPtr(FileName) : FileName
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceFileLocationW", "ptr", InfHandle, "ptr", InfContext, "ptr", FileName, "ptr", SourceId, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceFileSize function reads the uncompressed size of a source file listed in an INF file. (ANSI)
     * @remarks
     * One and only one of the optional parameters, <i>InfContext</i>, <i>FileName</i>, and <i>Section</i>, must be specified.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetSourceFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the loaded INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to a context for a line in a <b>Copy Files</b> section for which the size is to be retrieved. If <i>InfContext</i> is <b>NULL</b>, the <i>FileName</i> parameter is used.
     * @param {Pointer<PSTR>} FileName Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the size. If this parameter is <b>NULL</b> as well as <i>InfContext</i>, then the <i>Section</i> parameter is used.
     * @param {Pointer<PSTR>} Section Optional pointer to a <b>null</b>-terminated string containing the name of a <b>Copy Files</b> section. If this parameter is specified, the total size of all files listed in the section is computed.
     * @param {Pointer<UInt32>} FileSize Pointer to a variable that receives the size, in bytes, of the specified file(s).
     * @param {Integer} RoundingFactor Optional value for rounding file sizes. All file sizes are rounded up to a multiple of this number before being added to the total size. Rounding is useful for more exact determinations of the space that a file will occupy on a given volume, because it allows the caller to have file sizes rounded up to a multiple of the cluster size. Rounding does not occur unless <i>RoundingFactor</i> is specified.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetsourcefilesizea
     * @since windows5.1.2600
     */
    static SetupGetSourceFileSizeA(InfHandle, InfContext, FileName, Section, FileSize, RoundingFactor) {
        FileName := FileName is String? StrPtr(FileName) : FileName
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceFileSizeA", "ptr", InfHandle, "ptr", InfContext, "ptr", FileName, "ptr", Section, "ptr", FileSize, "uint", RoundingFactor, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceFileSize function reads the uncompressed size of a source file listed in an INF file. (Unicode)
     * @remarks
     * One and only one of the optional parameters, <i>InfContext</i>, <i>FileName</i>, and <i>Section</i>, must be specified.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetSourceFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the loaded INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to a context for a line in a <b>Copy Files</b> section for which the size is to be retrieved. If <i>InfContext</i> is <b>NULL</b>, the <i>FileName</i> parameter is used.
     * @param {Pointer<PWSTR>} FileName Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the size. If this parameter is <b>NULL</b> as well as <i>InfContext</i>, then the <i>Section</i> parameter is used.
     * @param {Pointer<PWSTR>} Section Optional pointer to a <b>null</b>-terminated string containing the name of a <b>Copy Files</b> section. If this parameter is specified, the total size of all files listed in the section is computed.
     * @param {Pointer<UInt32>} FileSize Pointer to a variable that receives the size, in bytes, of the specified file(s).
     * @param {Integer} RoundingFactor Optional value for rounding file sizes. All file sizes are rounded up to a multiple of this number before being added to the total size. Rounding is useful for more exact determinations of the space that a file will occupy on a given volume, because it allows the caller to have file sizes rounded up to a multiple of the cluster size. Rounding does not occur unless <i>RoundingFactor</i> is specified.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetsourcefilesizew
     * @since windows5.1.2600
     */
    static SetupGetSourceFileSizeW(InfHandle, InfContext, FileName, Section, FileSize, RoundingFactor) {
        FileName := FileName is String? StrPtr(FileName) : FileName
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceFileSizeW", "ptr", InfHandle, "ptr", InfContext, "ptr", FileName, "ptr", Section, "ptr", FileSize, "uint", RoundingFactor, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetTargetPath function determines the target directory for a file list section. (ANSI)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetTargetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the load INF file that contains a <b>DestinationDirs</b> section.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to an INF context that specifies a line in a file list section whose destination directory is to be retrieved. If <i>InfContext</i> is <b>NULL</b>, then the <i>Section</i> parameter is used.
     * @param {Pointer<PSTR>} Section Optional parameter that specifies the name of a section of the INF file whose handle is <i>InfHandle</i>. 
     * <b>SetupGetTargetPath</b> retrieves the target directory for this section. The <i>Section</i> parameter is ignored if <i>InfContext</i> is specified. If neither <i>InfContext</i> nor <i>Section</i> is specified, the function retrieves the default target path from the INF file. You should use a <b>null</b>-terminated string.
     * @param {Pointer<PSTR>} ReturnBuffer Optional pointer to  buffer to receive the fully qualified  target path. The path is guaranteed not to end with \. You should use a <b>null</b>-terminated string. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a  variable that receives the required size for the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.  If the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgettargetpatha
     * @since windows5.1.2600
     */
    static SetupGetTargetPathA(InfHandle, InfContext, Section, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Section := Section is String? StrPtr(Section) : Section
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetTargetPathA", "ptr", InfHandle, "ptr", InfContext, "ptr", Section, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetTargetPath function determines the target directory for a file list section. (Unicode)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetTargetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the load INF file that contains a <b>DestinationDirs</b> section.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to an INF context that specifies a line in a file list section whose destination directory is to be retrieved. If <i>InfContext</i> is <b>NULL</b>, then the <i>Section</i> parameter is used.
     * @param {Pointer<PWSTR>} Section Optional parameter that specifies the name of a section of the INF file whose handle is <i>InfHandle</i>. 
     * <b>SetupGetTargetPath</b> retrieves the target directory for this section. The <i>Section</i> parameter is ignored if <i>InfContext</i> is specified. If neither <i>InfContext</i> nor <i>Section</i> is specified, the function retrieves the default target path from the INF file. You should use a <b>null</b>-terminated string.
     * @param {Pointer<PWSTR>} ReturnBuffer Optional pointer to  buffer to receive the fully qualified  target path. The path is guaranteed not to end with \. You should use a <b>null</b>-terminated string. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a  variable that receives the required size for the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.  If the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgettargetpathw
     * @since windows5.1.2600
     */
    static SetupGetTargetPathW(InfHandle, InfContext, Section, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        Section := Section is String? StrPtr(Section) : Section
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetTargetPathW", "ptr", InfHandle, "ptr", InfContext, "ptr", Section, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetSourceList function allows the caller to set the list of installation sources for either the current user or the system (common to all users). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetSourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<PSTR>} SourceList Pointer to an array of strings to use as the source list, as specified by the <i>Flags</i> parameter.
     * @param {Integer} SourceCount Number of elements in the array pointed to by <i>SourceList</i>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetsourcelista
     * @since windows5.1.2600
     */
    static SetupSetSourceListA(Flags, SourceList, SourceCount) {
        SourceList := SourceList is String? StrPtr(SourceList) : SourceList

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetSourceListA", "uint", Flags, "ptr", SourceList, "uint", SourceCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetSourceList function allows the caller to set the list of installation sources for either the current user or the system (common to all users). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetSourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<PWSTR>} SourceList Pointer to an array of strings to use as the source list, as specified by the <i>Flags</i> parameter.
     * @param {Integer} SourceCount Number of elements in the array pointed to by <i>SourceList</i>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetsourcelistw
     * @since windows5.1.2600
     */
    static SetupSetSourceListW(Flags, SourceList, SourceCount) {
        SourceList := SourceList is String? StrPtr(SourceList) : SourceList

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetSourceListW", "uint", Flags, "ptr", SourceList, "uint", SourceCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCancelTemporarySourceList function cancels any temporary list and no-browse behavior and reestablishes standard list behavior.
     * @returns {Integer} If a temporary list was in effect, the return value is a nonzero value. Otherwise, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcanceltemporarysourcelist
     * @since windows5.1.2600
     */
    static SetupCancelTemporarySourceList() {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCancelTemporarySourceList", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddToSourceList function appends a value to the list of installation sources for either the current user or the system. If the value already exists, it is removed first, so that duplicate entries are not created. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupAddToSourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<PSTR>} Source Pointer to the source to be added to the list. You should use a null-terminated string.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupaddtosourcelista
     * @since windows5.1.2600
     */
    static SetupAddToSourceListA(Flags, Source) {
        Source := Source is String? StrPtr(Source) : Source

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddToSourceListA", "uint", Flags, "ptr", Source, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddToSourceList function appends a value to the list of installation sources for either the current user or the system. If the value already exists, it is removed first, so that duplicate entries are not created. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupAddToSourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<PWSTR>} Source Pointer to the source to be added to the list. You should use a null-terminated string.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupaddtosourcelistw
     * @since windows5.1.2600
     */
    static SetupAddToSourceListW(Flags, Source) {
        Source := Source is String? StrPtr(Source) : Source

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddToSourceListW", "uint", Flags, "ptr", Source, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFromSourceList function removes a value from the list of installation sources for either the current user or the system. The system and user lists are merged at run time. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveFromSourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<PSTR>} Source Pointer to a null-terminated string that specifies the source to remove from the list.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremovefromsourcelista
     * @since windows5.1.2600
     */
    static SetupRemoveFromSourceListA(Flags, Source) {
        Source := Source is String? StrPtr(Source) : Source

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFromSourceListA", "uint", Flags, "ptr", Source, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFromSourceList function removes a value from the list of installation sources for either the current user or the system. The system and user lists are merged at run time. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveFromSourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<PWSTR>} Source Pointer to a null-terminated string that specifies the source to remove from the list.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremovefromsourcelistw
     * @since windows5.1.2600
     */
    static SetupRemoveFromSourceListW(Flags, Source) {
        Source := Source is String? StrPtr(Source) : Source

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFromSourceListW", "uint", Flags, "ptr", Source, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQuerySourceList function queries the current list of installation sources. The list is built from the system and user-specific lists, and potentially overridden by a temporary list (see SetupSetSourceList). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupQuerySourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<PSTR>} List Pointer to a variable in which this function returns a pointer to an array of sources. Use a null-terminated string. The caller must free this array with a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfreesourcelista">SetupFreeSourceList</a>.
     * @param {Pointer<UInt32>} Count Pointer to a variable in which this function returns the number of sources in the list.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupquerysourcelista
     * @since windows5.1.2600
     */
    static SetupQuerySourceListA(Flags, List, Count) {
        List := List is String? StrPtr(List) : List

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQuerySourceListA", "uint", Flags, "ptr", List, "ptr", Count, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQuerySourceList function queries the current list of installation sources. The list is built from the system and user-specific lists, and potentially overridden by a temporary list (see SetupSetSourceList). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupQuerySourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<PWSTR>} List Pointer to a variable in which this function returns a pointer to an array of sources. Use a null-terminated string. The caller must free this array with a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupfreesourcelista">SetupFreeSourceList</a>.
     * @param {Pointer<UInt32>} Count Pointer to a variable in which this function returns the number of sources in the list.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupquerysourcelistw
     * @since windows5.1.2600
     */
    static SetupQuerySourceListW(Flags, List, Count) {
        List := List is String? StrPtr(List) : List

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQuerySourceListW", "uint", Flags, "ptr", List, "ptr", Count, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFreeSourceList function frees the system resources allocated to a source list. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupFreeSourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} List Pointer to an array of sources from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupquerysourcelista">SetupQuerySourceList</a>. The <b>null</b>-terminated string should not exceed the size of the destination buffer. When the function returns, this pointer is set to <b>NULL</b>.
     * @param {Integer} Count Number of sources in the list.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupfreesourcelista
     * @since windows5.1.2600
     */
    static SetupFreeSourceListA(List, Count) {
        List := List is String? StrPtr(List) : List

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFreeSourceListA", "ptr", List, "uint", Count, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupFreeSourceList function frees the system resources allocated to a source list. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupFreeSourceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} List Pointer to an array of sources from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupquerysourcelista">SetupQuerySourceList</a>. The <b>null</b>-terminated string should not exceed the size of the destination buffer. When the function returns, this pointer is set to <b>NULL</b>.
     * @param {Integer} Count Number of sources in the list.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupfreesourcelistw
     * @since windows5.1.2600
     */
    static SetupFreeSourceListW(List, Count) {
        List := List is String? StrPtr(List) : List

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupFreeSourceListW", "ptr", List, "uint", Count, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupPromptForDisk function displays a dialog box that prompts the user for a disk. (ANSI)
     * @remarks
     * If this function is called with a <i>PathBuffer</i> of <b>NULL</b> and a <i>PathBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>PathRequiredSize</i>. If the function succeeds in this, the return value is NO_ERROR. Otherwise, the return value is one of the values described in the Return Values section.
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupPromptForDisk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent Handle to the parent window for this dialog box.
     * @param {Pointer<PSTR>} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the dialog title. If this parameter is <b>NULL</b>, the default of ""%s--Files Needed"" (localized) is used. The "%s" is replaced with the text retrieved from the parent window. If no text is retrieved from the parent window, the title is "Files Needed".
     * @param {Pointer<PSTR>} DiskName Optional pointer to a <b>null</b>-terminated string specifying the name of the disk to insert. If this parameter is <b>NULL</b>, the default "(Unknown)" (localized) is used.
     * @param {Pointer<PSTR>} PathToSource Optional pointer to a <b>null</b>-terminated string specifying the path part of the expected location of the file, for example, F:\x86. If not specified, the path where <b>SetupPromptForDisk</b> most recently  located a file is used. If that list is empty, a system default is used.
     * @param {Pointer<PSTR>} FileSought Pointer to a <b>null</b>-terminated string specifying the name of the file needed (filename part only). The filename is displayed if the user clicks on the <b>Browse</b> button. This routine looks for the file using its compressed form names; therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source media.
     * @param {Pointer<PSTR>} TagFile Optional pointer to a <b>null</b>-terminated string specifying a tag file (filename part only) that identifies the presence of a particular removable media volume. If the currently selected path would place the file on removable media and a tag file is specified, 
     * <b>SetupPromptForDisk</b> looks for the tag file at the root of the drive to determine whether to continue. 
     * 
     * 
     * 
     * 
     * For example, if <i>PathToSource</i> is A:\x86, the tagfile is disk1.tag, and the user types B:\x86 into the edit control of the prompt dialog box, the routine looks for B:\disk1.tag to determine whether to continue. If the tag file is not found, the function looks for the tagfile using <i>PathToSource</i>.
     * 
     * If a tag file is not specified, removable media works just like non-removable media and <i>FileSought</i> is looked for before continuing.
     * @param {Integer} DiskPromptStyle Specifies the behavior of the dialog box. This parameter can be a combination of the following flags.
     * @param {Pointer<PSTR>} PathBuffer Optional pointer to a buffer that, upon return, receives the path (no filename) of the location specified by the user through the dialog box.  You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size.  See the Remarks section.
     * @param {Integer} PathBufferSize Size of the buffer pointed to by <i>PathBuffer</i>, in characters. It should be at least MAX_PATH long. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} PathRequiredSize Optional pointer to a variable that receives the required size for <i>PathBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuppromptfordiska
     * @since windows5.1.2600
     */
    static SetupPromptForDiskA(hwndParent, DialogTitle, DiskName, PathToSource, FileSought, TagFile, DiskPromptStyle, PathBuffer, PathBufferSize, PathRequiredSize) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        DiskName := DiskName is String? StrPtr(DiskName) : DiskName
        PathToSource := PathToSource is String? StrPtr(PathToSource) : PathToSource
        FileSought := FileSought is String? StrPtr(FileSought) : FileSought
        TagFile := TagFile is String? StrPtr(TagFile) : TagFile
        PathBuffer := PathBuffer is String? StrPtr(PathBuffer) : PathBuffer

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupPromptForDiskA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", DiskName, "ptr", PathToSource, "ptr", FileSought, "ptr", TagFile, "uint", DiskPromptStyle, "ptr", PathBuffer, "uint", PathBufferSize, "ptr", PathRequiredSize)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupPromptForDisk function displays a dialog box that prompts the user for a disk. (Unicode)
     * @remarks
     * If this function is called with a <i>PathBuffer</i> of <b>NULL</b> and a <i>PathBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>PathRequiredSize</i>. If the function succeeds in this, the return value is NO_ERROR. Otherwise, the return value is one of the values described in the Return Values section.
     * 
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupPromptForDisk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent Handle to the parent window for this dialog box.
     * @param {Pointer<PWSTR>} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the dialog title. If this parameter is <b>NULL</b>, the default of ""%s--Files Needed"" (localized) is used. The "%s" is replaced with the text retrieved from the parent window. If no text is retrieved from the parent window, the title is "Files Needed".
     * @param {Pointer<PWSTR>} DiskName Optional pointer to a <b>null</b>-terminated string specifying the name of the disk to insert. If this parameter is <b>NULL</b>, the default "(Unknown)" (localized) is used.
     * @param {Pointer<PWSTR>} PathToSource Optional pointer to a <b>null</b>-terminated string specifying the path part of the expected location of the file, for example, F:\x86. If not specified, the path where <b>SetupPromptForDisk</b> most recently  located a file is used. If that list is empty, a system default is used.
     * @param {Pointer<PWSTR>} FileSought Pointer to a <b>null</b>-terminated string specifying the name of the file needed (filename part only). The filename is displayed if the user clicks on the <b>Browse</b> button. This routine looks for the file using its compressed form names; therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source media.
     * @param {Pointer<PWSTR>} TagFile Optional pointer to a <b>null</b>-terminated string specifying a tag file (filename part only) that identifies the presence of a particular removable media volume. If the currently selected path would place the file on removable media and a tag file is specified, 
     * <b>SetupPromptForDisk</b> looks for the tag file at the root of the drive to determine whether to continue. 
     * 
     * 
     * 
     * 
     * For example, if <i>PathToSource</i> is A:\x86, the tagfile is disk1.tag, and the user types B:\x86 into the edit control of the prompt dialog box, the routine looks for B:\disk1.tag to determine whether to continue. If the tag file is not found, the function looks for the tagfile using <i>PathToSource</i>.
     * 
     * If a tag file is not specified, removable media works just like non-removable media and <i>FileSought</i> is looked for before continuing.
     * @param {Integer} DiskPromptStyle Specifies the behavior of the dialog box. This parameter can be a combination of the following flags.
     * @param {Pointer<PWSTR>} PathBuffer Optional pointer to a buffer that, upon return, receives the path (no filename) of the location specified by the user through the dialog box.  You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size.  See the Remarks section.
     * @param {Integer} PathBufferSize Size of the buffer pointed to by <i>PathBuffer</i>, in characters. It should be at least MAX_PATH long. This includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} PathRequiredSize Optional pointer to a variable that receives the required size for <i>PathBuffer</i>, in characters. This includes the <b>null</b> terminator.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuppromptfordiskw
     * @since windows5.1.2600
     */
    static SetupPromptForDiskW(hwndParent, DialogTitle, DiskName, PathToSource, FileSought, TagFile, DiskPromptStyle, PathBuffer, PathBufferSize, PathRequiredSize) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        DiskName := DiskName is String? StrPtr(DiskName) : DiskName
        PathToSource := PathToSource is String? StrPtr(PathToSource) : PathToSource
        FileSought := FileSought is String? StrPtr(FileSought) : FileSought
        TagFile := TagFile is String? StrPtr(TagFile) : TagFile
        PathBuffer := PathBuffer is String? StrPtr(PathBuffer) : PathBuffer

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupPromptForDiskW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", DiskName, "ptr", PathToSource, "ptr", FileSought, "ptr", TagFile, "uint", DiskPromptStyle, "ptr", PathBuffer, "uint", PathBufferSize, "ptr", PathRequiredSize)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupCopyError function generates a dialog box to notify a user of a copy file error. (ANSI)
     * @remarks
     * If this function is called with a <i>PathBuffer</i> of <b>NULL</b> and a <i>PathBufferSize</i> of 0 (zero), the function puts the buffer size that is needed to hold the specified data into the variable pointed to by <i>PathRequiredSize</i>. 
     * 
     * If the function succeeds, the return value is NO_ERROR. Otherwise, the return value is one of the specified values.
     * 
     * To avoid insufficient buffer errors, <i>ReturnBuffer</i> should be at least MAX_PATH.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupCopyError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent The handle to the parent window for this dialog box.
     * @param {Pointer<PSTR>} DialogTitle An optional pointer to a <b>null</b>-terminated string that specifies the dialog box title. 
     * 
     * This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Copy Error" (localized to the system language) is used.
     * @param {Pointer<PSTR>} DiskName An optional pointer to a <b>null</b>-terminated string that specifies the name of the disk to insert.  
     * 
     * This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default name "(Unknown)" (localized to the system language) is used.
     * @param {Pointer<PSTR>} PathToSource A pointer to the path component of the source file where an operation fails, for example, F:\x86. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {Pointer<PSTR>} SourceFile A pointer to a <b>null</b>-terminated string that specifies the filename part of the file where an operation fails. 
     * 
     * Use a <b>null</b>-terminated string. This filename is displayed if the user clicks on the <b>Details</b> or <b>Browse</b> buttons. The <b>SetupCopyError</b> function looks for the file that uses its compressed form names. Therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source media.
     * @param {Pointer<PSTR>} TargetPathFile An optional pointer to a <b>null</b>-terminated string that specifies the full path of the target file for rename and copy operations. 
     * 
     * Use a <b>null</b>-terminated string.  This parameter can be <b>NULL</b>. If TargetPathFile is not specified, "(Unknown)" (localized to the system language) is used.
     * @param {Integer} Win32ErrorCode If an error occurs, this member is the <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Code</a>. 
     * 
     * If an error does not occur, it is  NO_ERROR.
     * @param {Integer} Style The flags that control display formatting and behavior of a dialog box. 
     * 
     * This parameter can be one of the following flags.
     * @param {Pointer<PSTR>} PathBuffer An optional pointer to a variable in which this function returns the path (not including the filename) of the location that a user specifies in the dialog box. You should use a null-terminated string. 
     * 
     * The <b>null</b>-terminated string should not exceed the size of the destination buffer. To avoid insufficient buffer errors, <i>PathBuffer</i> should be at least MAX_PATH.
     * For more information, see the Remarks section of this topic.
     * @param {Integer} PathBufferSize The size of the buffer that  <i>PathBuffer</i> points to, in characters. 
     * 
     * The buffer size should be at least MAX_PATH characters, including the <b>null</b> terminator.
     * @param {Pointer<UInt32>} PathRequiredSize An optional pointer to a variable in which this function returns the required buffer size, in characters, including the <b>null</b> terminator.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcopyerrora
     * @since windows5.1.2600
     */
    static SetupCopyErrorA(hwndParent, DialogTitle, DiskName, PathToSource, SourceFile, TargetPathFile, Win32ErrorCode, Style, PathBuffer, PathBufferSize, PathRequiredSize) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        DiskName := DiskName is String? StrPtr(DiskName) : DiskName
        PathToSource := PathToSource is String? StrPtr(PathToSource) : PathToSource
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        TargetPathFile := TargetPathFile is String? StrPtr(TargetPathFile) : TargetPathFile
        PathBuffer := PathBuffer is String? StrPtr(PathBuffer) : PathBuffer

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupCopyErrorA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", DiskName, "ptr", PathToSource, "ptr", SourceFile, "ptr", TargetPathFile, "uint", Win32ErrorCode, "uint", Style, "ptr", PathBuffer, "uint", PathBufferSize, "ptr", PathRequiredSize)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupCopyError function generates a dialog box to notify a user of a copy file error. (Unicode)
     * @remarks
     * If this function is called with a <i>PathBuffer</i> of <b>NULL</b> and a <i>PathBufferSize</i> of 0 (zero), the function puts the buffer size that is needed to hold the specified data into the variable pointed to by <i>PathRequiredSize</i>. 
     * 
     * If the function succeeds, the return value is NO_ERROR. Otherwise, the return value is one of the specified values.
     * 
     * To avoid insufficient buffer errors, <i>ReturnBuffer</i> should be at least MAX_PATH.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupCopyError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent The handle to the parent window for this dialog box.
     * @param {Pointer<PWSTR>} DialogTitle An optional pointer to a <b>null</b>-terminated string that specifies the dialog box title. 
     * 
     * This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Copy Error" (localized to the system language) is used.
     * @param {Pointer<PWSTR>} DiskName An optional pointer to a <b>null</b>-terminated string that specifies the name of the disk to insert.  
     * 
     * This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default name "(Unknown)" (localized to the system language) is used.
     * @param {Pointer<PWSTR>} PathToSource A pointer to the path component of the source file where an operation fails, for example, F:\x86. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {Pointer<PWSTR>} SourceFile A pointer to a <b>null</b>-terminated string that specifies the filename part of the file where an operation fails. 
     * 
     * Use a <b>null</b>-terminated string. This filename is displayed if the user clicks on the <b>Details</b> or <b>Browse</b> buttons. The <b>SetupCopyError</b> function looks for the file that uses its compressed form names. Therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source media.
     * @param {Pointer<PWSTR>} TargetPathFile An optional pointer to a <b>null</b>-terminated string that specifies the full path of the target file for rename and copy operations. 
     * 
     * Use a <b>null</b>-terminated string.  This parameter can be <b>NULL</b>. If TargetPathFile is not specified, "(Unknown)" (localized to the system language) is used.
     * @param {Integer} Win32ErrorCode If an error occurs, this member is the <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Code</a>. 
     * 
     * If an error does not occur, it is  NO_ERROR.
     * @param {Integer} Style The flags that control display formatting and behavior of a dialog box. 
     * 
     * This parameter can be one of the following flags.
     * @param {Pointer<PWSTR>} PathBuffer An optional pointer to a variable in which this function returns the path (not including the filename) of the location that a user specifies in the dialog box. You should use a null-terminated string. 
     * 
     * The <b>null</b>-terminated string should not exceed the size of the destination buffer. To avoid insufficient buffer errors, <i>PathBuffer</i> should be at least MAX_PATH.
     * For more information, see the Remarks section of this topic.
     * @param {Integer} PathBufferSize The size of the buffer that  <i>PathBuffer</i> points to, in characters. 
     * 
     * The buffer size should be at least MAX_PATH characters, including the <b>null</b> terminator.
     * @param {Pointer<UInt32>} PathRequiredSize An optional pointer to a variable in which this function returns the required buffer size, in characters, including the <b>null</b> terminator.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcopyerrorw
     * @since windows5.1.2600
     */
    static SetupCopyErrorW(hwndParent, DialogTitle, DiskName, PathToSource, SourceFile, TargetPathFile, Win32ErrorCode, Style, PathBuffer, PathBufferSize, PathRequiredSize) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        DiskName := DiskName is String? StrPtr(DiskName) : DiskName
        PathToSource := PathToSource is String? StrPtr(PathToSource) : PathToSource
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        TargetPathFile := TargetPathFile is String? StrPtr(TargetPathFile) : TargetPathFile
        PathBuffer := PathBuffer is String? StrPtr(PathBuffer) : PathBuffer

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupCopyErrorW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", DiskName, "ptr", PathToSource, "ptr", SourceFile, "ptr", TargetPathFile, "uint", Win32ErrorCode, "uint", Style, "ptr", PathBuffer, "uint", PathBufferSize, "ptr", PathRequiredSize)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The RenameError function generates a dialog box that informs the user of a file renaming error. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupRenameError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent Handle to the parent window for this dialog box.
     * @param {Pointer<PSTR>} DialogTitle Pointer to a <b>null</b>-terminated string that specifies the error dialog box title. This parameter may be <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Rename Error" (localized) is used.
     * @param {Pointer<PSTR>} SourceFile Pointer to a <b>null</b>-terminated string that specifies the full path of the source file on which the operation failed.
     * @param {Pointer<PSTR>} TargetFile Pointer to a <b>null</b>-terminated string that specifies the full path of the target file on which the operation failed.
     * @param {Integer} Win32ErrorCode The <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> encountered during the file operation.
     * @param {Integer} Style Specifies display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuprenameerrora
     * @since windows5.1.2600
     */
    static SetupRenameErrorA(hwndParent, DialogTitle, SourceFile, TargetFile, Win32ErrorCode, Style) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        TargetFile := TargetFile is String? StrPtr(TargetFile) : TargetFile

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupRenameErrorA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", SourceFile, "ptr", TargetFile, "uint", Win32ErrorCode, "uint", Style)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The RenameError function generates a dialog box that informs the user of a file renaming error. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupRenameError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent Handle to the parent window for this dialog box.
     * @param {Pointer<PWSTR>} DialogTitle Pointer to a <b>null</b>-terminated string that specifies the error dialog box title. This parameter may be <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Rename Error" (localized) is used.
     * @param {Pointer<PWSTR>} SourceFile Pointer to a <b>null</b>-terminated string that specifies the full path of the source file on which the operation failed.
     * @param {Pointer<PWSTR>} TargetFile Pointer to a <b>null</b>-terminated string that specifies the full path of the target file on which the operation failed.
     * @param {Integer} Win32ErrorCode The <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> encountered during the file operation.
     * @param {Integer} Style Specifies display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuprenameerrorw
     * @since windows5.1.2600
     */
    static SetupRenameErrorW(hwndParent, DialogTitle, SourceFile, TargetFile, Win32ErrorCode, Style) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        TargetFile := TargetFile is String? StrPtr(TargetFile) : TargetFile

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupRenameErrorW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", SourceFile, "ptr", TargetFile, "uint", Win32ErrorCode, "uint", Style)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupDeleteError function generates a dialog box that informs the user of a delete error. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDeleteError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent Handle to the parent window for this dialog box.
     * @param {Pointer<PSTR>} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is <b>NULL</b>, the default title of "Delete Error" (localized) is used.
     * @param {Pointer<PSTR>} File Pointer to a <b>null</b>-terminated string specifying the full path of the file on which the delete operation failed.
     * @param {Integer} Win32ErrorCode The <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> encountered during the file operation.
     * @param {Integer} Style Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdeleteerrora
     * @since windows5.1.2600
     */
    static SetupDeleteErrorA(hwndParent, DialogTitle, File, Win32ErrorCode, Style) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        File := File is String? StrPtr(File) : File

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupDeleteErrorA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", File, "uint", Win32ErrorCode, "uint", Style)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupDeleteError function generates a dialog box that informs the user of a delete error. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDeleteError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent Handle to the parent window for this dialog box.
     * @param {Pointer<PWSTR>} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is <b>NULL</b>, the default title of "Delete Error" (localized) is used.
     * @param {Pointer<PWSTR>} File Pointer to a <b>null</b>-terminated string specifying the full path of the file on which the delete operation failed.
     * @param {Integer} Win32ErrorCode The <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a> encountered during the file operation.
     * @param {Integer} Style Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdeleteerrorw
     * @since windows5.1.2600
     */
    static SetupDeleteErrorW(hwndParent, DialogTitle, File, Win32ErrorCode, Style) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        File := File is String? StrPtr(File) : File

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupDeleteErrorW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", File, "uint", Win32ErrorCode, "uint", Style)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupBackupError function generates a dialog box that informs the user of a backup error. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupBackupError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent Handle to the parent window for this dialog box.
     * @param {Pointer<PSTR>} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is <b>NULL</b>, the default title of "Backup Error" (localized) is used.
     * @param {Pointer<PSTR>} SourceFile Pointer to a <b>null</b>-terminated string specifying the full path of the source file that is being backed up.
     * @param {Pointer<PSTR>} TargetFile Optional pointer to a <b>null</b>-terminated string specifying the full path of the backup name of the file. This parameter can be <b>NULL</b>.
     * @param {Integer} Win32ErrorCode If an error occurs, this member is the <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a>. If no error has occurred, it is  NO_ERROR.
     * @param {Integer} Style Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupbackuperrora
     * @since windows5.1.2600
     */
    static SetupBackupErrorA(hwndParent, DialogTitle, SourceFile, TargetFile, Win32ErrorCode, Style) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        TargetFile := TargetFile is String? StrPtr(TargetFile) : TargetFile

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupBackupErrorA", "ptr", hwndParent, "ptr", DialogTitle, "ptr", SourceFile, "ptr", TargetFile, "uint", Win32ErrorCode, "uint", Style)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupBackupError function generates a dialog box that informs the user of a backup error. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupBackupError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent Handle to the parent window for this dialog box.
     * @param {Pointer<PWSTR>} DialogTitle Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is <b>NULL</b>, the default title of "Backup Error" (localized) is used.
     * @param {Pointer<PWSTR>} SourceFile Pointer to a <b>null</b>-terminated string specifying the full path of the source file that is being backed up.
     * @param {Pointer<PWSTR>} TargetFile Optional pointer to a <b>null</b>-terminated string specifying the full path of the backup name of the file. This parameter can be <b>NULL</b>.
     * @param {Integer} Win32ErrorCode If an error occurs, this member is the <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a>. If no error has occurred, it is  NO_ERROR.
     * @param {Integer} Style Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following flags.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupbackuperrorw
     * @since windows5.1.2600
     */
    static SetupBackupErrorW(hwndParent, DialogTitle, SourceFile, TargetFile, Win32ErrorCode, Style) {
        DialogTitle := DialogTitle is String? StrPtr(DialogTitle) : DialogTitle
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        TargetFile := TargetFile is String? StrPtr(TargetFile) : TargetFile

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupBackupErrorW", "ptr", hwndParent, "ptr", DialogTitle, "ptr", SourceFile, "ptr", TargetFile, "uint", Win32ErrorCode, "uint", Style)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupSetDirectoryId function associates a directory identifier in an INF file with a specific directory. (ANSI)
     * @remarks
     * <b>SetupSetDirectoryId</b> can be used prior to queuing file copy operations to specify a target location that is only known at runtime.
     * 
     * After setting the directory identifier, this function traverses all appended INF files, and if any of them have unresolved string substitutions, the function attempts to re-apply string substitution to them based on the new DIRID mapping. Because of this, some INF values may change after calling 
     * <b>SetupSetDirectoryId</b>.
     * 
     * DIRID_ABSOLUTE_16BIT is not a valid value for <i>Id</i>, which ensures compatibility with 16-bit setup.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetDirectoryId as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle for a loaded INF file.
     * @param {Integer} Id A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If <i>Id</i> is <b>NULL</b>, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is deleted.
     * @param {Pointer<PSTR>} Directory A pointer to  a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is unassociated. No error results if <i>Id</i> is not currently associated with a directory.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetdirectoryida
     * @since windows5.1.2600
     */
    static SetupSetDirectoryIdA(InfHandle, Id, Directory) {
        Directory := Directory is String? StrPtr(Directory) : Directory

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetDirectoryIdA", "ptr", InfHandle, "uint", Id, "ptr", Directory, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetDirectoryId function associates a directory identifier in an INF file with a specific directory. (Unicode)
     * @remarks
     * <b>SetupSetDirectoryId</b> can be used prior to queuing file copy operations to specify a target location that is only known at runtime.
     * 
     * After setting the directory identifier, this function traverses all appended INF files, and if any of them have unresolved string substitutions, the function attempts to re-apply string substitution to them based on the new DIRID mapping. Because of this, some INF values may change after calling 
     * <b>SetupSetDirectoryId</b>.
     * 
     * DIRID_ABSOLUTE_16BIT is not a valid value for <i>Id</i>, which ensures compatibility with 16-bit setup.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetDirectoryId as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle for a loaded INF file.
     * @param {Integer} Id A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If <i>Id</i> is <b>NULL</b>, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is deleted.
     * @param {Pointer<PWSTR>} Directory A pointer to  a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is unassociated. No error results if <i>Id</i> is not currently associated with a directory.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetdirectoryidw
     * @since windows5.1.2600
     */
    static SetupSetDirectoryIdW(InfHandle, Id, Directory) {
        Directory := Directory is String? StrPtr(Directory) : Directory

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetDirectoryIdW", "ptr", InfHandle, "uint", Id, "ptr", Directory, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetDirectoryIdEx function associates a directory identifier in an INF file with a specific directory. (ANSI)
     * @remarks
     * <b>SetupSetDirectoryIdEx</b> can be used prior to queuing file copy operations to specify a target location that is only known at runtime.
     * 
     * After setting the directory identifier, this function traverses all appended INF files, and if any of them have unresolved string substitutions, the function attempts to re-apply string substitution to them based on the new DIRID mapping. Because of this, some INF values may change after calling 
     * <b>SetupSetDirectoryIdEx</b>.
     * 
     * DIRID_ABSOLUTE_16BIT is not a valid value for <i>Id</i>, which ensures compatibility with 16-bit setup.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetDirectoryIdEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle for a loaded INF file.
     * @param {Integer} Id A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If <i>Id</i> is zero, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is deleted.
     * @param {Pointer<PSTR>} Directory A pointer to  a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is unassociated. No error results if <i>Id</i> is not currently associated with a directory.
     * @param {Integer} Flags This parameter can be set to <b>SETDIRID_NOT_FULL_PATH</b> (1) to indicate that the <i>Directory</i> does not specify a full path.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetdirectoryidexa
     * @since windows5.1.2600
     */
    static SetupSetDirectoryIdExA(InfHandle, Id, Directory, Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        Directory := Directory is String? StrPtr(Directory) : Directory

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetDirectoryIdExA", "ptr", InfHandle, "uint", Id, "ptr", Directory, "uint", Flags, "uint", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetDirectoryIdEx function associates a directory identifier in an INF file with a specific directory. (Unicode)
     * @remarks
     * <b>SetupSetDirectoryIdEx</b> can be used prior to queuing file copy operations to specify a target location that is only known at runtime.
     * 
     * After setting the directory identifier, this function traverses all appended INF files, and if any of them have unresolved string substitutions, the function attempts to re-apply string substitution to them based on the new DIRID mapping. Because of this, some INF values may change after calling 
     * <b>SetupSetDirectoryIdEx</b>.
     * 
     * DIRID_ABSOLUTE_16BIT is not a valid value for <i>Id</i>, which ensures compatibility with 16-bit setup.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetDirectoryIdEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle for a loaded INF file.
     * @param {Integer} Id A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If <i>Id</i> is zero, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is deleted.
     * @param {Pointer<PWSTR>} Directory A pointer to  a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is unassociated. No error results if <i>Id</i> is not currently associated with a directory.
     * @param {Integer} Flags This parameter can be set to <b>SETDIRID_NOT_FULL_PATH</b> (1) to indicate that the <i>Directory</i> does not specify a full path.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetdirectoryidexw
     * @since windows5.1.2600
     */
    static SetupSetDirectoryIdExW(InfHandle, Id, Directory, Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        Directory := Directory is String? StrPtr(Directory) : Directory

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetDirectoryIdExW", "ptr", InfHandle, "uint", Id, "ptr", Directory, "uint", Flags, "uint", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceInfo function retrieves the path, tag file, or media description for a source listed in an INF file. (ANSI)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetSourceInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains a <b>SourceDisksNames</b> section. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b>), the platform-specific section will be used.
     * @param {Integer} SourceId Identifier for a source media. This value is used to search by key in the <b>SourceDisksNames</b> section.
     * @param {Integer} InfoDesired Indicates what information is desired. Only one value may be specified per function call, and they cannot be combined. The following types of information can be retrieved from a <b>SourceDisksNames</b> section.
     * @param {Pointer<PSTR>} ReturnBuffer Optional pointer to a buffer to receive the retrieved information.  Path returns are guaranteed not to end with \.  You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This  includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size for the buffer specified by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetsourceinfoa
     * @since windows5.1.2600
     */
    static SetupGetSourceInfoA(InfHandle, SourceId, InfoDesired, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceInfoA", "ptr", InfHandle, "uint", SourceId, "uint", InfoDesired, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetSourceInfo function retrieves the path, tag file, or media description for a source listed in an INF file. (Unicode)
     * @remarks
     * If this function is called with a <i>ReturnBuffer</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupGetSourceInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains a <b>SourceDisksNames</b> section. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b>), the platform-specific section will be used.
     * @param {Integer} SourceId Identifier for a source media. This value is used to search by key in the <b>SourceDisksNames</b> section.
     * @param {Integer} InfoDesired Indicates what information is desired. Only one value may be specified per function call, and they cannot be combined. The following types of information can be retrieved from a <b>SourceDisksNames</b> section.
     * @param {Pointer<PWSTR>} ReturnBuffer Optional pointer to a buffer to receive the retrieved information.  Path returns are guaranteed not to end with \.  You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This  includes the <b>null</b> terminator.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size for the buffer specified by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetsourceinfow
     * @since windows5.1.2600
     */
    static SetupGetSourceInfoW(InfHandle, SourceId, InfoDesired, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetSourceInfoW", "ptr", InfHandle, "uint", SourceId, "uint", InfoDesired, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFile function installs a file as specified either by an INFCONTEXT returned by SetupFindXXXLine or explicitly by the file name and path. (ANSI)
     * @remarks
     * If a UNC directory is specified as the target directory of a file installation, you must ensure it exists before you call 
     * <b>SetupInstallFile</b>. The setup functions do not check for the existence of nor create UNC directories. If the target UNC directory does not exist, the file installation will fail.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Optional pointer to the handle to an INF file that contains SourceDisksNames and SourceDisksFiles sections. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section will be used. If <i>InfContext</i> is null and <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to the context of a line in a Copy Files section in an INF file. The routine looks up this file  in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfHandle</i> is not specified, <i>SourceFile</i> must be.
     * @param {Pointer<PSTR>} SourceFile Optional pointer to the file name (no path) of the file to copy. The file is looked up in the SourceDisksFiles section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
     * @param {Pointer<PSTR>} SourcePathRoot Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
     * @param {Pointer<PSTR>} DestinationName Optional pointer to the file name only (no path) of the target file. This parameter can be null to indicate that the target file should have the same name as the source file. If <i>InfContext</i> is not specified, <i>DestinationName</i> supplies the full  path and file name for the target.
     * @param {Integer} CopyStyle 
     * @param {Pointer<PSP_FILE_CALLBACK_A>} CopyMsgHandler Optional pointer to a callback function to be notified of various conditions that may arise during the file copy operation.
     * @param {Pointer<Void>} Context Optional pointer to a caller-defined value that is passed as the first parameter of the callback function.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns NO_ERROR, the file copy operation was not completed. The file may not have been copied because the file copy operation was unnecessary or because the file callback function returned <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallfilea
     * @since windows5.1.2600
     */
    static SetupInstallFileA(InfHandle, InfContext, SourceFile, SourcePathRoot, DestinationName, CopyStyle, CopyMsgHandler, Context) {
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        SourcePathRoot := SourcePathRoot is String? StrPtr(SourcePathRoot) : SourcePathRoot
        DestinationName := DestinationName is String? StrPtr(DestinationName) : DestinationName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFileA", "ptr", InfHandle, "ptr", InfContext, "ptr", SourceFile, "ptr", SourcePathRoot, "ptr", DestinationName, "uint", CopyStyle, "ptr", CopyMsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFile function installs a file as specified either by an INFCONTEXT returned by SetupFindXXXLine or explicitly by the file name and path. (Unicode)
     * @remarks
     * If a UNC directory is specified as the target directory of a file installation, you must ensure it exists before you call 
     * <b>SetupInstallFile</b>. The setup functions do not check for the existence of nor create UNC directories. If the target UNC directory does not exist, the file installation will fail.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Optional pointer to the handle to an INF file that contains SourceDisksNames and SourceDisksFiles sections. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section will be used. If <i>InfContext</i> is null and <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to the context of a line in a Copy Files section in an INF file. The routine looks up this file  in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfHandle</i> is not specified, <i>SourceFile</i> must be.
     * @param {Pointer<PWSTR>} SourceFile Optional pointer to the file name (no path) of the file to copy. The file is looked up in the SourceDisksFiles section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
     * @param {Pointer<PWSTR>} SourcePathRoot Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
     * @param {Pointer<PWSTR>} DestinationName Optional pointer to the file name only (no path) of the target file. This parameter can be null to indicate that the target file should have the same name as the source file. If <i>InfContext</i> is not specified, <i>DestinationName</i> supplies the full  path and file name for the target.
     * @param {Integer} CopyStyle 
     * @param {Pointer<PSP_FILE_CALLBACK_W>} CopyMsgHandler Optional pointer to a callback function to be notified of various conditions that may arise during the file copy operation.
     * @param {Pointer<Void>} Context Optional pointer to a caller-defined value that is passed as the first parameter of the callback function.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns NO_ERROR, the file copy operation was not completed. The file may not have been copied because the file copy operation was unnecessary or because the file callback function returned <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallfilew
     * @since windows5.1.2600
     */
    static SetupInstallFileW(InfHandle, InfContext, SourceFile, SourcePathRoot, DestinationName, CopyStyle, CopyMsgHandler, Context) {
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        SourcePathRoot := SourcePathRoot is String? StrPtr(SourcePathRoot) : SourcePathRoot
        DestinationName := DestinationName is String? StrPtr(DestinationName) : DestinationName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFileW", "ptr", InfHandle, "ptr", InfContext, "ptr", SourceFile, "ptr", SourcePathRoot, "ptr", DestinationName, "uint", CopyStyle, "ptr", CopyMsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFileEx function installs a file as specified either by an INFCONTEXT returned by SetupFindXXXLine or explicitly by the filename and path information. (ANSI)
     * @remarks
     * This API is typically used when installing new versions of system files that are likely to be in use. It updates a <b>BOOL</b> value that indicates whether the file was in use. If the file was in use, then the file copy operation is postponed until the system is rebooted.
     * 
     * If a UNC directory is specified as the target directory of a file installation, you must ensure it exists before you call 
     * <b>SetupInstallFileEx</b>. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file installation fails.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Optional pointer to the handle to an INF file that contains the SourceDisksNames and SourceDisksFiles sections. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section are used. If <i>InfContext</i> is not specified and <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to context for a line in a Copy Files section in an INF file. The routine looks this file up in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfContext</i> is not specified, <i>SourceFile</i> must be.
     * @param {Pointer<PSTR>} SourceFile Optional pointer to the filename (no path) of the file to copy. The file is looked up in the SourceDisksFiles section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. However, <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
     * @param {Pointer<PSTR>} SourcePathRoot Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
     * @param {Pointer<PSTR>} DestinationName Optional pointer  to  a new name for the copied file. If <i>InfContext</i> is specified, <i>DestinationName</i> supplies the filename only (no path) of the target file. This parameter can be <b>NULL</b> to indicate that the target file should have the same name as the source file. If <i>InfContext</i> is not specified, <i>DestinationName</i> supplies the full target path and filename for the target.
     * @param {Integer} CopyStyle Flags that control the behavior of the file copy operation.
     * @param {Pointer<PSP_FILE_CALLBACK_A>} CopyMsgHandler Optional pointer to a callback function to be notified of various conditions that may arise during the file copy.
     * @param {Pointer<Void>} Context Pointer to a caller-defined value that is passed as the first parameter of the callback function.
     * @param {Pointer<Int32>} FileWasInUse Pointer to a variable in which this function returns a flag that indicates whether the file was in use. This parameter is required.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns NO_ERROR, the file copy operation was not completed. The file may not have been copied because the file copy operation was unnecessary or because the file callback function returned <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallfileexa
     * @since windows5.1.2600
     */
    static SetupInstallFileExA(InfHandle, InfContext, SourceFile, SourcePathRoot, DestinationName, CopyStyle, CopyMsgHandler, Context, FileWasInUse) {
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        SourcePathRoot := SourcePathRoot is String? StrPtr(SourcePathRoot) : SourcePathRoot
        DestinationName := DestinationName is String? StrPtr(DestinationName) : DestinationName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFileExA", "ptr", InfHandle, "ptr", InfContext, "ptr", SourceFile, "ptr", SourcePathRoot, "ptr", DestinationName, "uint", CopyStyle, "ptr", CopyMsgHandler, "ptr", Context, "ptr", FileWasInUse, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFileEx function installs a file as specified either by an INFCONTEXT returned by SetupFindXXXLine or explicitly by the filename and path information. (Unicode)
     * @remarks
     * This API is typically used when installing new versions of system files that are likely to be in use. It updates a <b>BOOL</b> value that indicates whether the file was in use. If the file was in use, then the file copy operation is postponed until the system is rebooted.
     * 
     * If a UNC directory is specified as the target directory of a file installation, you must ensure it exists before you call 
     * <b>SetupInstallFileEx</b>. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file installation fails.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Optional pointer to the handle to an INF file that contains the SourceDisksNames and SourceDisksFiles sections. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section are used. If <i>InfContext</i> is not specified and <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
     * @param {Pointer<INFCONTEXT>} InfContext Optional pointer to context for a line in a Copy Files section in an INF file. The routine looks this file up in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfContext</i> is not specified, <i>SourceFile</i> must be.
     * @param {Pointer<PWSTR>} SourceFile Optional pointer to the filename (no path) of the file to copy. The file is looked up in the SourceDisksFiles section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. However, <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
     * @param {Pointer<PWSTR>} SourcePathRoot Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
     * @param {Pointer<PWSTR>} DestinationName Optional pointer  to  a new name for the copied file. If <i>InfContext</i> is specified, <i>DestinationName</i> supplies the filename only (no path) of the target file. This parameter can be <b>NULL</b> to indicate that the target file should have the same name as the source file. If <i>InfContext</i> is not specified, <i>DestinationName</i> supplies the full target path and filename for the target.
     * @param {Integer} CopyStyle Flags that control the behavior of the file copy operation.
     * @param {Pointer<PSP_FILE_CALLBACK_W>} CopyMsgHandler Optional pointer to a callback function to be notified of various conditions that may arise during the file copy.
     * @param {Pointer<Void>} Context Pointer to a caller-defined value that is passed as the first parameter of the callback function.
     * @param {Pointer<Int32>} FileWasInUse Pointer to a variable in which this function returns a flag that indicates whether the file was in use. This parameter is required.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns NO_ERROR, the file copy operation was not completed. The file may not have been copied because the file copy operation was unnecessary or because the file callback function returned <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallfileexw
     * @since windows5.1.2600
     */
    static SetupInstallFileExW(InfHandle, InfContext, SourceFile, SourcePathRoot, DestinationName, CopyStyle, CopyMsgHandler, Context, FileWasInUse) {
        SourceFile := SourceFile is String? StrPtr(SourceFile) : SourceFile
        SourcePathRoot := SourcePathRoot is String? StrPtr(SourcePathRoot) : SourcePathRoot
        DestinationName := DestinationName is String? StrPtr(DestinationName) : DestinationName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFileExW", "ptr", InfHandle, "ptr", InfContext, "ptr", SourceFile, "ptr", SourcePathRoot, "ptr", DestinationName, "uint", CopyStyle, "ptr", CopyMsgHandler, "ptr", Context, "ptr", FileWasInUse, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenFileQueue function creates a setup file queue.
     * @remarks
     * After the file queue has been committed and is no longer needed, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupclosefilequeue">SetupCloseFileQueue</a> should be called to release the resources allocated during 
     * <b>SetupOpenFileQueue</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupopenfilequeue
     * @since windows5.1.2600
     */
    static SetupOpenFileQueue() {
        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupOpenFileQueue")
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupCloseFileQueue function destroys a setup file queue.
     * @remarks
     * The 
     * <b>SetupCloseFileQueue</b> function does not flush the queue; pending operations are not performed. To commit a file queue before closing it call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>.
     * @param {Pointer<Void>} QueueHandle Handle to an open setup file queue.
     * @returns {Integer} This function does not return a value.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupclosefilequeue
     * @since windows5.1.2600
     */
    static SetupCloseFileQueue(QueueHandle) {
        result := DllCall("SETUPAPI.dll\SetupCloseFileQueue", "ptr", QueueHandle, "int")
        return result
    }

    /**
     * The SetupSetFileQueueAlternatePlatform function associates the file queue with a target platform that is different from the platform running the function. This is done to enable for non-native signature verification. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetFileQueueAlternatePlatform as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to an open setup file queue.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Optional pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v1">SP_ALTPLATFORM_INFO</a> structure passing information about the alternate platform. On Windows 2000, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V1). On Windows Server2003 or WindowsXP, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V2).
     * @param {Pointer<PSTR>} AlternateDefaultCatalogFile Pointer to a <b>null</b>-terminated string that specifies a catalog that validates any INF files. This parameter may be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetfilequeuealternateplatforma
     * @since windows5.1.2600
     */
    static SetupSetFileQueueAlternatePlatformA(QueueHandle, AlternatePlatformInfo, AlternateDefaultCatalogFile) {
        AlternateDefaultCatalogFile := AlternateDefaultCatalogFile is String? StrPtr(AlternateDefaultCatalogFile) : AlternateDefaultCatalogFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetFileQueueAlternatePlatformA", "ptr", QueueHandle, "ptr", AlternatePlatformInfo, "ptr", AlternateDefaultCatalogFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetFileQueueAlternatePlatform function associates the file queue with a target platform that is different from the platform running the function. This is done to enable for non-native signature verification. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetFileQueueAlternatePlatform as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to an open setup file queue.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo Optional pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v1">SP_ALTPLATFORM_INFO</a> structure passing information about the alternate platform. On Windows 2000, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V1). On Windows Server2003 or WindowsXP, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V2).
     * @param {Pointer<PWSTR>} AlternateDefaultCatalogFile Pointer to a <b>null</b>-terminated string that specifies a catalog that validates any INF files. This parameter may be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetfilequeuealternateplatformw
     * @since windows5.1.2600
     */
    static SetupSetFileQueueAlternatePlatformW(QueueHandle, AlternatePlatformInfo, AlternateDefaultCatalogFile) {
        AlternateDefaultCatalogFile := AlternateDefaultCatalogFile is String? StrPtr(AlternateDefaultCatalogFile) : AlternateDefaultCatalogFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetFileQueueAlternatePlatformW", "ptr", QueueHandle, "ptr", AlternatePlatformInfo, "ptr", AlternateDefaultCatalogFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetPlatformPathOverride function is used to set a platform path override for a target machine when working with INFs from a different machine. (ANSI)
     * @remarks
     * <b>SetPlatformPathOverride</b> is used to change the source path when queuing files. If a platform path override has been set by a call to <b>SetPlatformPathOverride</b>, any setup function that queues file copy operations will examine the final component of the source path and if the final component matches the name of the user's platform, replace it with the override string set by <b>SetPlatformPathOverride</b>.
     * 
     * For example, consider a MIPS-platform machine where the platform has been set to Alpha by a call to <b>SetPlatformPathOverride</b>. After the platform path override has been set, a file copy operation is queued with a source path of \\pop\top\baz\mips\x.exe, the path will be changed to \\pop\top\baz\alpha\x.exe.
     * 
     * The paths of file copy operations queued before the path override is set are not changed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetPlatformPathOverride as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} Override Pointer to a <b>null</b>-terminated string that contains the replacement platform information. For example, "alpha" or "x86". This parameter may be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NOT_ENOUGH_MEMORY, 
     * <b>SetupSetPlatformPathOverride</b> was unable to store the <i>Override</i> string.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetplatformpathoverridea
     * @since windows5.1.2600
     */
    static SetupSetPlatformPathOverrideA(Override) {
        Override := Override is String? StrPtr(Override) : Override

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetPlatformPathOverrideA", "ptr", Override, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetPlatformPathOverride function is used to set a platform path override for a target machine when working with INFs from a different machine. (Unicode)
     * @remarks
     * <b>SetPlatformPathOverride</b> is used to change the source path when queuing files. If a platform path override has been set by a call to <b>SetPlatformPathOverride</b>, any setup function that queues file copy operations will examine the final component of the source path and if the final component matches the name of the user's platform, replace it with the override string set by <b>SetPlatformPathOverride</b>.
     * 
     * For example, consider a MIPS-platform machine where the platform has been set to Alpha by a call to <b>SetPlatformPathOverride</b>. After the platform path override has been set, a file copy operation is queued with a source path of \\pop\top\baz\mips\x.exe, the path will be changed to \\pop\top\baz\alpha\x.exe.
     * 
     * The paths of file copy operations queued before the path override is set are not changed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupSetPlatformPathOverride as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} Override Pointer to a <b>null</b>-terminated string that contains the replacement platform information. For example, "alpha" or "x86". This parameter may be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NOT_ENOUGH_MEMORY, 
     * <b>SetupSetPlatformPathOverride</b> was unable to store the <i>Override</i> string.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetplatformpathoverridew
     * @since windows5.1.2600
     */
    static SetupSetPlatformPathOverrideW(Override) {
        Override := Override is String? StrPtr(Override) : Override

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetPlatformPathOverrideW", "ptr", Override, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopy function adds a single file copy operation to a setup file queue. (ANSI)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists before the queue is committed. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file copy will fail.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueCopy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PSTR>} SourceRootPath Pointer to a <b>null</b>-terminated string that specifies the root of the source for this copy, such as A:\.
     * @param {Pointer<PSTR>} SourcePath Pointer to a <b>null</b>-terminated string that specifies the path relative to <i>SourceRootPath</i> where the file can be found. This parameter may be <b>NULL</b>.
     * @param {Pointer<PSTR>} SourceFilename Pointer to a <b>null</b>-terminated string that specifies the file name part of the file to be copied.
     * @param {Pointer<PSTR>} SourceDescription Pointer to a <b>null</b>-terminated string that specifies  a description of the source media to be used during disk prompts. This parameter can be <b>NULL</b>.
     * @param {Pointer<PSTR>} SourceTagfile Pointer to a <b>null</b>-terminated string that specifies  a tag file whose presence at <i>SourceRootPath</i> indicates the presence of the source media. This parameter may be <b>NULL</b>. If not specified, the file itself will be used as the tag file if required.
     * @param {Pointer<PSTR>} TargetDirectory Pointer to a <b>null</b>-terminated string that specifies the directory where the file is to be copied.
     * @param {Pointer<PSTR>} TargetFilename Pointer to a <b>null</b>-terminated string that specifies  the name of the target file. This parameter may be <b>NULL</b>. If not specified, the target file will have the same name as the source file.
     * @param {Integer} CopyStyle 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuecopya
     * @since windows5.1.2600
     */
    static SetupQueueCopyA(QueueHandle, SourceRootPath, SourcePath, SourceFilename, SourceDescription, SourceTagfile, TargetDirectory, TargetFilename, CopyStyle) {
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath
        SourcePath := SourcePath is String? StrPtr(SourcePath) : SourcePath
        SourceFilename := SourceFilename is String? StrPtr(SourceFilename) : SourceFilename
        SourceDescription := SourceDescription is String? StrPtr(SourceDescription) : SourceDescription
        SourceTagfile := SourceTagfile is String? StrPtr(SourceTagfile) : SourceTagfile
        TargetDirectory := TargetDirectory is String? StrPtr(TargetDirectory) : TargetDirectory
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopyA", "ptr", QueueHandle, "ptr", SourceRootPath, "ptr", SourcePath, "ptr", SourceFilename, "ptr", SourceDescription, "ptr", SourceTagfile, "ptr", TargetDirectory, "ptr", TargetFilename, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopy function adds a single file copy operation to a setup file queue. (Unicode)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists before the queue is committed. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file copy will fail.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueCopy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PWSTR>} SourceRootPath Pointer to a <b>null</b>-terminated string that specifies the root of the source for this copy, such as A:\.
     * @param {Pointer<PWSTR>} SourcePath Pointer to a <b>null</b>-terminated string that specifies the path relative to <i>SourceRootPath</i> where the file can be found. This parameter may be <b>NULL</b>.
     * @param {Pointer<PWSTR>} SourceFilename Pointer to a <b>null</b>-terminated string that specifies the file name part of the file to be copied.
     * @param {Pointer<PWSTR>} SourceDescription Pointer to a <b>null</b>-terminated string that specifies  a description of the source media to be used during disk prompts. This parameter can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} SourceTagfile Pointer to a <b>null</b>-terminated string that specifies  a tag file whose presence at <i>SourceRootPath</i> indicates the presence of the source media. This parameter may be <b>NULL</b>. If not specified, the file itself will be used as the tag file if required.
     * @param {Pointer<PWSTR>} TargetDirectory Pointer to a <b>null</b>-terminated string that specifies the directory where the file is to be copied.
     * @param {Pointer<PWSTR>} TargetFilename Pointer to a <b>null</b>-terminated string that specifies  the name of the target file. This parameter may be <b>NULL</b>. If not specified, the target file will have the same name as the source file.
     * @param {Integer} CopyStyle 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuecopyw
     * @since windows5.1.2600
     */
    static SetupQueueCopyW(QueueHandle, SourceRootPath, SourcePath, SourceFilename, SourceDescription, SourceTagfile, TargetDirectory, TargetFilename, CopyStyle) {
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath
        SourcePath := SourcePath is String? StrPtr(SourcePath) : SourcePath
        SourceFilename := SourceFilename is String? StrPtr(SourceFilename) : SourceFilename
        SourceDescription := SourceDescription is String? StrPtr(SourceDescription) : SourceDescription
        SourceTagfile := SourceTagfile is String? StrPtr(SourceTagfile) : SourceTagfile
        TargetDirectory := TargetDirectory is String? StrPtr(TargetDirectory) : TargetDirectory
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopyW", "ptr", QueueHandle, "ptr", SourceRootPath, "ptr", SourcePath, "ptr", SourceFilename, "ptr", SourceDescription, "ptr", SourceTagfile, "ptr", TargetDirectory, "ptr", TargetFilename, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopyIndirect function is an extended form of SetupQueueCopy passing additional parameters as a structure (SP_FILE_COPY_PARAMS). Other than this, the behavior is identical. (ANSI)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists before the queue is committed. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file copy will fail.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueCopyIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_FILE_COPY_PARAMS_A>} CopyParams Pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_file_copy_params_a">SP_FILE_COPY_PARAMS</a> structure that describes the file copy operation.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuecopyindirecta
     * @since windows5.1.2600
     */
    static SetupQueueCopyIndirectA(CopyParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopyIndirectA", "ptr", CopyParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopyIndirect function is an extended form of SetupQueueCopy passing additional parameters as a structure (SP_FILE_COPY_PARAMS). Other than this, the behavior is identical. (Unicode)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists before the queue is committed. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file copy will fail.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueCopyIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_FILE_COPY_PARAMS_W>} CopyParams Pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_file_copy_params_a">SP_FILE_COPY_PARAMS</a> structure that describes the file copy operation.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuecopyindirectw
     * @since windows5.1.2600
     */
    static SetupQueueCopyIndirectW(CopyParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopyIndirectW", "ptr", CopyParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDefaultCopy function adds a single file to a setup file queue for copying, using the default source media and destination as specified in an INF file. (ANSI)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists before the queue is committed. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file copy will fail.
     * 
     * The default destination used by this function is specified by the <b>DefaultDestDir</b> key in the <b>DestinationDirs</b> section of an INF file.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueDefaultCopy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<PSTR>} SourceRootPath Pointer to a null-terminated string that specifies the root directory of the source for this copy such as A:\.
     * @param {Pointer<PSTR>} SourceFilename Pointer to a null-terminated string that specifies the file name of the file to be copied.
     * @param {Pointer<PSTR>} TargetFilename Pointer to a null-terminated string that specifies the file name of the target file.
     * @param {Integer} CopyStyle 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuedefaultcopya
     * @since windows5.1.2600
     */
    static SetupQueueDefaultCopyA(QueueHandle, InfHandle, SourceRootPath, SourceFilename, TargetFilename, CopyStyle) {
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath
        SourceFilename := SourceFilename is String? StrPtr(SourceFilename) : SourceFilename
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDefaultCopyA", "ptr", QueueHandle, "ptr", InfHandle, "ptr", SourceRootPath, "ptr", SourceFilename, "ptr", TargetFilename, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDefaultCopy function adds a single file to a setup file queue for copying, using the default source media and destination as specified in an INF file. (Unicode)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists before the queue is committed. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file copy will fail.
     * 
     * The default destination used by this function is specified by the <b>DefaultDestDir</b> key in the <b>DestinationDirs</b> section of an INF file.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueDefaultCopy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
     * @param {Pointer<PWSTR>} SourceRootPath Pointer to a null-terminated string that specifies the root directory of the source for this copy such as A:\.
     * @param {Pointer<PWSTR>} SourceFilename Pointer to a null-terminated string that specifies the file name of the file to be copied.
     * @param {Pointer<PWSTR>} TargetFilename Pointer to a null-terminated string that specifies the file name of the target file.
     * @param {Integer} CopyStyle 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuedefaultcopyw
     * @since windows5.1.2600
     */
    static SetupQueueDefaultCopyW(QueueHandle, InfHandle, SourceRootPath, SourceFilename, TargetFilename, CopyStyle) {
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath
        SourceFilename := SourceFilename is String? StrPtr(SourceFilename) : SourceFilename
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDefaultCopyW", "ptr", QueueHandle, "ptr", InfHandle, "ptr", SourceRootPath, "ptr", SourceFilename, "ptr", TargetFilename, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopySection function places all the files in a section of an INF file in a setup queue for copying. (ANSI)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists before the queue is committed. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file copy will fail.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueCopySection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PSTR>} SourceRootPath Pointer to a null-terminated string that specifies the root of the source for this copy, such as A:\.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section names. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section will be used.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section to queue for copying. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section.
     * @param {Pointer<PSTR>} Section Pointer to a null-terminated string that specifies the name of the section to be queued for copy.
     * @param {Integer} CopyStyle 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuecopysectiona
     * @since windows5.1.2600
     */
    static SetupQueueCopySectionA(QueueHandle, SourceRootPath, InfHandle, ListInfHandle, Section, CopyStyle) {
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopySectionA", "ptr", QueueHandle, "ptr", SourceRootPath, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueCopySection function places all the files in a section of an INF file in a setup queue for copying. (Unicode)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists before the queue is committed. The setup functions do not check for the existence of and do not create UNC directories. If the target UNC directory does not exist, the file copy will fail.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueCopySection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PWSTR>} SourceRootPath Pointer to a null-terminated string that specifies the root of the source for this copy, such as A:\.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section names. If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific section will be used.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section to queue for copying. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section.
     * @param {Pointer<PWSTR>} Section Pointer to a null-terminated string that specifies the name of the section to be queued for copy.
     * @param {Integer} CopyStyle 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuecopysectionw
     * @since windows5.1.2600
     */
    static SetupQueueCopySectionW(QueueHandle, SourceRootPath, InfHandle, ListInfHandle, Section, CopyStyle) {
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueCopySectionW", "ptr", QueueHandle, "ptr", SourceRootPath, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "uint", CopyStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDelete function places an individual file delete operation on a setup file queue. (ANSI)
     * @remarks
     * Because delete operations are assumed to take place on fixed media, the user will not be prompted when the queue is committed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueDelete as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PSTR>} PathPart1 Pointer to a <b>null</b>-terminated string that specifies the first part of the path of the file to be deleted. If <i>PathPart2</i> is <b>NULL</b>, <i>PathPart1</i> is the full path of the file to be deleted.
     * @param {Pointer<PSTR>} PathPart2 Pointer to a <b>null</b>-terminated string that specifies the second part of the path of the file to be deleted. This parameter may be <b>NULL</b>. This is appended to <i>PathPart1</i> to form the full path of the file to be deleted. The function checks for and collapses duplicated path separators when it combines <i>PathPart1</i> and <i>PathPart2</i>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuedeletea
     * @since windows5.1.2600
     */
    static SetupQueueDeleteA(QueueHandle, PathPart1, PathPart2) {
        PathPart1 := PathPart1 is String? StrPtr(PathPart1) : PathPart1
        PathPart2 := PathPart2 is String? StrPtr(PathPart2) : PathPart2

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDeleteA", "ptr", QueueHandle, "ptr", PathPart1, "ptr", PathPart2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDelete function places an individual file delete operation on a setup file queue. (Unicode)
     * @remarks
     * Because delete operations are assumed to take place on fixed media, the user will not be prompted when the queue is committed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueDelete as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PWSTR>} PathPart1 Pointer to a <b>null</b>-terminated string that specifies the first part of the path of the file to be deleted. If <i>PathPart2</i> is <b>NULL</b>, <i>PathPart1</i> is the full path of the file to be deleted.
     * @param {Pointer<PWSTR>} PathPart2 Pointer to a <b>null</b>-terminated string that specifies the second part of the path of the file to be deleted. This parameter may be <b>NULL</b>. This is appended to <i>PathPart1</i> to form the full path of the file to be deleted. The function checks for and collapses duplicated path separators when it combines <i>PathPart1</i> and <i>PathPart2</i>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuedeletew
     * @since windows5.1.2600
     */
    static SetupQueueDeleteW(QueueHandle, PathPart1, PathPart2) {
        PathPart1 := PathPart1 is String? StrPtr(PathPart1) : PathPart1
        PathPart2 := PathPart2 is String? StrPtr(PathPart2) : PathPart2

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDeleteW", "ptr", QueueHandle, "ptr", PathPart1, "ptr", PathPart2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDeleteSection function queues all the files in a section of an INF file for deletion. The section must be in the correct Delete Files format and the INF file must contain a DestinationDirs section. (ANSI)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueDeleteSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section name.
     * @param {Pointer<Void>} ListInfHandle Optional  handle to an open INF file that contains the section to queue for deletion. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section name.
     * @param {Pointer<PSTR>} Section Pointer to a  null-terminated string that specifies the name of the section to be queued for deletion.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuedeletesectiona
     * @since windows5.1.2600
     */
    static SetupQueueDeleteSectionA(QueueHandle, InfHandle, ListInfHandle, Section) {
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDeleteSectionA", "ptr", QueueHandle, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueDeleteSection function queues all the files in a section of an INF file for deletion. The section must be in the correct Delete Files format and the INF file must contain a DestinationDirs section. (Unicode)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueDeleteSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section name.
     * @param {Pointer<Void>} ListInfHandle Optional  handle to an open INF file that contains the section to queue for deletion. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section name.
     * @param {Pointer<PWSTR>} Section Pointer to a  null-terminated string that specifies the name of the section to be queued for deletion.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuedeletesectionw
     * @since windows5.1.2600
     */
    static SetupQueueDeleteSectionW(QueueHandle, InfHandle, ListInfHandle, Section) {
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueDeleteSectionW", "ptr", QueueHandle, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueRename function places an individual file rename operation on a setup file queue. (ANSI)
     * @remarks
     * Because rename operations are assumed to take place on fixed media, the user will not be prompted when the queue is committed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueRename as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PSTR>} SourcePath Pointer to a null-terminated string that specifies the source path of the file to be renamed. If <i>SourceFileName</i> is not specified, <i>SourcePath</i> is assumed to be the full path.
     * @param {Pointer<PSTR>} SourceFilename Pointer to a null-terminated string that specifies the file name part of the file to be renamed. If not specified, <i>SourcePath</i> is the full path.
     * @param {Pointer<PSTR>} TargetPath Pointer to a null-terminated string that specifies the target directory. When this parameter is specified, the rename operation is actually a move operation. If <i>TargetPath</i> is not specified, the file is renamed but remains in its current location.
     * @param {Pointer<PSTR>} TargetFilename Pointer to a null-terminated string that specifies the new name for the source file.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuerenamea
     * @since windows5.1.2600
     */
    static SetupQueueRenameA(QueueHandle, SourcePath, SourceFilename, TargetPath, TargetFilename) {
        SourcePath := SourcePath is String? StrPtr(SourcePath) : SourcePath
        SourceFilename := SourceFilename is String? StrPtr(SourceFilename) : SourceFilename
        TargetPath := TargetPath is String? StrPtr(TargetPath) : TargetPath
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueRenameA", "ptr", QueueHandle, "ptr", SourcePath, "ptr", SourceFilename, "ptr", TargetPath, "ptr", TargetFilename, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueRename function places an individual file rename operation on a setup file queue. (Unicode)
     * @remarks
     * Because rename operations are assumed to take place on fixed media, the user will not be prompted when the queue is committed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueRename as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PWSTR>} SourcePath Pointer to a null-terminated string that specifies the source path of the file to be renamed. If <i>SourceFileName</i> is not specified, <i>SourcePath</i> is assumed to be the full path.
     * @param {Pointer<PWSTR>} SourceFilename Pointer to a null-terminated string that specifies the file name part of the file to be renamed. If not specified, <i>SourcePath</i> is the full path.
     * @param {Pointer<PWSTR>} TargetPath Pointer to a null-terminated string that specifies the target directory. When this parameter is specified, the rename operation is actually a move operation. If <i>TargetPath</i> is not specified, the file is renamed but remains in its current location.
     * @param {Pointer<PWSTR>} TargetFilename Pointer to a null-terminated string that specifies the new name for the source file.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuerenamew
     * @since windows5.1.2600
     */
    static SetupQueueRenameW(QueueHandle, SourcePath, SourceFilename, TargetPath, TargetFilename) {
        SourcePath := SourcePath is String? StrPtr(SourcePath) : SourcePath
        SourceFilename := SourceFilename is String? StrPtr(SourceFilename) : SourceFilename
        TargetPath := TargetPath is String? StrPtr(TargetPath) : TargetPath
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueRenameW", "ptr", QueueHandle, "ptr", SourcePath, "ptr", SourceFilename, "ptr", TargetPath, "ptr", TargetFilename, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueRenameSection function queues a section in an INF file for renaming. The section must be in the correct rename list section format and the INF file must contain a DestinationDirs section. (ANSI)
     * @remarks
     * You cannot queue file moves with 
     * <b>SetupQueueRenameSection</b> because the form of a rename list section limits section renaming to within the same directory.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueRenameSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section name.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an INF file that contains the section to queue for renaming. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section name.
     * @param {Pointer<PSTR>} Section Name of the section to be queued for renaming.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuerenamesectiona
     * @since windows5.1.2600
     */
    static SetupQueueRenameSectionA(QueueHandle, InfHandle, ListInfHandle, Section) {
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueRenameSectionA", "ptr", QueueHandle, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueueRenameSection function queues a section in an INF file for renaming. The section must be in the correct rename list section format and the INF file must contain a DestinationDirs section. (Unicode)
     * @remarks
     * You cannot queue file moves with 
     * <b>SetupQueueRenameSection</b> because the form of a rename list section limits section renaming to within the same directory.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueueRenameSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section name.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an INF file that contains the section to queue for renaming. If <i>ListInfHandle</i> is not specified, <i>InfHandle</i> is assumed to contain the section name.
     * @param {Pointer<PWSTR>} Section Name of the section to be queued for renaming.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueuerenamesectionw
     * @since windows5.1.2600
     */
    static SetupQueueRenameSectionW(QueueHandle, InfHandle, ListInfHandle, Section) {
        Section := Section is String? StrPtr(Section) : Section

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueueRenameSectionW", "ptr", QueueHandle, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", Section, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCommitFileQueue function performs file operations queued on a setup file queue. (ANSI)
     * @remarks
     * The callback routine specified in <i>MsgHandler</i> should be compatible with the parameters that 
     * <b>SetupCommitFileQueue</b> passed to it during a queue commit.
     * 
     * If Unicode is defined in your callback application, and you specify <i>MsgHandler</i> as the default queue callback routine, the callback routine will expect Unicode parameters. Otherwise, the default queue callback routine will expect ANSI parameters.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupCommitFileQueue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} Owner Optional handle to a window to use as the parent of any progress dialog boxes.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PSP_FILE_CALLBACK_A>} MsgHandler Pointer to an optional callback routine to be notified of various significant events that are in the queue processing. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/default-queue-callback-routine">Default Queue Callback Routine</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> If the callback routine is <b>null</b>, 
     * <b>SetupCommitFileQueue</b> returns <b>TRUE</b> and the error is 0 or NO_ERROR.
     * @param {Pointer<Void>} Context Value that is passed to the callback function supplied by the <i>MsgHandler</i> parameter. If the default callback routine has been specified as <i>MsgHandler</i>, this context must be the context returned from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcommitfilequeuea
     * @since windows5.1.2600
     */
    static SetupCommitFileQueueA(Owner, QueueHandle, MsgHandler, Context) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCommitFileQueueA", "ptr", Owner, "ptr", QueueHandle, "ptr", MsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCommitFileQueue function performs file operations queued on a setup file queue. (Unicode)
     * @remarks
     * The callback routine specified in <i>MsgHandler</i> should be compatible with the parameters that 
     * <b>SetupCommitFileQueue</b> passed to it during a queue commit.
     * 
     * If Unicode is defined in your callback application, and you specify <i>MsgHandler</i> as the default queue callback routine, the callback routine will expect Unicode parameters. Otherwise, the default queue callback routine will expect ANSI parameters.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupCommitFileQueue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} Owner Optional handle to a window to use as the parent of any progress dialog boxes.
     * @param {Pointer<Void>} QueueHandle Handle to a setup file queue, as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupopenfilequeue">SetupOpenFileQueue</a>.
     * @param {Pointer<PSP_FILE_CALLBACK_W>} MsgHandler Pointer to an optional callback routine to be notified of various significant events that are in the queue processing. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/default-queue-callback-routine">Default Queue Callback Routine</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> If the callback routine is <b>null</b>, 
     * <b>SetupCommitFileQueue</b> returns <b>TRUE</b> and the error is 0 or NO_ERROR.
     * @param {Pointer<Void>} Context Value that is passed to the callback function supplied by the <i>MsgHandler</i> parameter. If the default callback routine has been specified as <i>MsgHandler</i>, this context must be the context returned from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcommitfilequeuew
     * @since windows5.1.2600
     */
    static SetupCommitFileQueueW(Owner, QueueHandle, MsgHandler, Context) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCommitFileQueueW", "ptr", Owner, "ptr", QueueHandle, "ptr", MsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupScanFileQueue function scans a setup file queue, performing an operation on each node in its copy list. The operation is specified by a set of flags. This function can be called either before or after the queue has been committed. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupScanFileQueue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} FileQueue Handle to the setup file queue whose copy list is to be scanned or iterated.
     * @param {Integer} Flags Flags to combine to control the file queue scan operation. Note that either SPQ_SCAN_FILE_PRESENCE, SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX, or SPQ_SCAN_FILE_VALIDITY must be specified. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_FILE_PRESENCE"></a><a id="spq_scan_file_presence"></a><dl>
     * <dt><b>SPQ_SCAN_FILE_PRESENCE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target files in the copy queue  are already present on the target.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_FILE_VALIDITY"></a><a id="spq_scan_file_validity"></a><dl>
     * <dt><b>SPQ_SCAN_FILE_VALIDITY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target files in the copy queue  are already present on the target with valid signatures. Available  with Windows2000 and later versions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACK"></a><a id="spq_scan_use_callback"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Callback routine for each node of the queue. If the callback routine returns a nonzero value, the queue processing stops and 
     * <b>SetupScanFileQueue</b> returns zero. Issue a 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-queuescan">SPFILENOTIFY_QUEUESCAN</a> notification code and a pass a pointer to the target path as <i>Param1</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACKEX"></a><a id="spq_scan_use_callbackex"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACKEX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Callback routine for each node of the queue. If the callback routine returns a nonzero value, the queue processing stops and 
     * <b>SetupScanFileQueue</b> returns zero. Issue a SPFILENOTIFY_QUEUESCAN_EX notification and pass a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-filepaths_a">FILEPATHS</a> structure as <i>Param1</i>. SPQ_SCAN_USE_CALLBACKEX also checks that the file has a valid signature. Available starting with Windows2000. On WindowsXP only, you can turn off signature checking by combining this flag with SPQ_SCAN_FILE_PRESENCE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_INFORM_USER"></a><a id="spq_scan_inform_user"></a><dl>
     * <dt><b>SPQ_SCAN_INFORM_USER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Flag  specified when all  files in the queue pass the check for valid signatures. 
     * <b>SetupScanFileQueue</b> informs the user that the operation requires files that are already present on the target. This flag is ignored if SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY is not specified. This flag may not be used with SPQ_SCAN_PRUNE_COPY_QUEUE or SPQ_SCAN_PRUNE_DELREN.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_PRUNE_COPY_QUEUE"></a><a id="spq_scan_prune_copy_queue"></a><dl>
     * <dt><b>SPQ_SCAN_PRUNE_COPY_QUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Combined with SPQ_SCAN_FILE_PRESENCE, removes present entries from the copy queue. When combined with SPQ_SCAN_FILE_VALIDITY, removes signed entries from the copy queue. Available starting with Windows2000. On WindowsXP only, files that are also specified in the delete queue or rename queues are not pruned unless SPQ_SCAN_PRUNE_DELREN is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACK_SIGNERINFO"></a><a id="spq_scan_use_callback_signerinfo"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACK_SIGNERINFO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Available starting with WindowsXP. Issues SPFILENOTIFY_QUEUESCAN_SIGNERINFO notification and passes a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-filepaths_signerinfo_a">FILEPATHS_SIGNERINFO</a> structure as <i>Param1</i>. Checks each file for a valid signature and reports signature information through the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_PRUNE_DELREN"></a><a id="spq_scan_prune_delren"></a><dl>
     * <dt><b>SPQ_SCAN_PRUNE_DELREN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Combined with SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY, removes entries in the delete  or rename queue that are also in the copy queue. When combined with SPQ_SCAN_PRUNE_COPY_QUEUE, limits files that are removed from the copy queue to files that are not in  the delete  or  rename queues. Available starting with WindowsXP.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<HWND>} Window Optional handle to the window to own dialog boxes that are presented. This parameter is not used if the <i>Flags</i> parameter does not contain SPQ_SCAN_FILE_PRESENCE or if <i>Flags</i> does not contain SPQ_SCAN_INFORM_USER.
     * @param {Pointer<PSP_FILE_CALLBACK_A>} CallbackRoutine Optional pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> callback function to be called on each node of the copy queue. The notification code passed to the callback function is 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-queuescan">SPFILENOTIFY_QUEUESCAN</a>. This parameter is required if <i>Flags</i> includes SPQ_SCAN_USE_CALLBACK. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>You must supply the callback routine specified by <i>CallbackRoutine</i>. The default queue callback routine does not support 
     * <b>SetupScanFileQueue</b>.</div>
     * <div></div>
     * @param {Pointer<Void>} CallbackContext Optional pointer to a context that contains caller-defined data passed to the callback routine pointed to by <i>CallbackRoutine</i>.
     * @param {Pointer<UInt32>} Result Pointer to a variable that receives the result of the scan operation.
     * @returns {Integer} The function returns a nonzero value if all nodes in the queue were processed.
     * 
     * If the SPQ_SCAN_USE_CALLBACK flag was set, the value in <i>Result</i> is 0. The callback routine specified by <i>CallbackRoutine</i> is sent the notification SPFILENOTIFY_QUEUESCAN. <i>CallbackRoutine.Param1</i> specifies a pointer to an array that contains the target path information. The pointer has been cast to an unsigned integer and must be recast to a TCHAR array of MAX_PATH elements before a callback routine can access the information. <i>CallbackRoutine.Param2</i> is set to SPQ_DELAYED_COPY if the current queue node is in use and cannot be copied until the system is restarted. Otherwise, <i>CallbackRoutine.Param2</i> takes the value 0.
     * 
     * If SPQ_SCAN_USE_CALLBACK was not set, <i>Result</i> indicates whether the queue passed the presence or validity check as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue failed the check or it passed the check, but SPQ_SCAN_INFORM_USER was specified and the user wants new copies of the files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that copying is not required. The copy queue is empty and there are no elements on the delete or rename queues, so the caller can skip queue commit.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that copying is not required. The copy queue is empty, but there are elements on the delete or rename queues, so the caller cannot skip queue commit.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The function returns zero if an error occurred or the callback function returned nonzero. If <i>Result</i> is nonzero, it is the value returned by the callback function that stopped queue processing. If <i>Result</i> is zero, extended error information can be retrieved by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupscanfilequeuea
     * @since windows5.1.2600
     */
    static SetupScanFileQueueA(FileQueue, Flags, Window, CallbackRoutine, CallbackContext, Result) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupScanFileQueueA", "ptr", FileQueue, "uint", Flags, "ptr", Window, "ptr", CallbackRoutine, "ptr", CallbackContext, "ptr", Result, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupScanFileQueue function scans a setup file queue, performing an operation on each node in its copy list. The operation is specified by a set of flags. This function can be called either before or after the queue has been committed. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupScanFileQueue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} FileQueue Handle to the setup file queue whose copy list is to be scanned or iterated.
     * @param {Integer} Flags Flags to combine to control the file queue scan operation. Note that either SPQ_SCAN_FILE_PRESENCE, SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX, or SPQ_SCAN_FILE_VALIDITY must be specified. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_FILE_PRESENCE"></a><a id="spq_scan_file_presence"></a><dl>
     * <dt><b>SPQ_SCAN_FILE_PRESENCE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target files in the copy queue  are already present on the target.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_FILE_VALIDITY"></a><a id="spq_scan_file_validity"></a><dl>
     * <dt><b>SPQ_SCAN_FILE_VALIDITY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target files in the copy queue  are already present on the target with valid signatures. Available  with Windows2000 and later versions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACK"></a><a id="spq_scan_use_callback"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Callback routine for each node of the queue. If the callback routine returns a nonzero value, the queue processing stops and 
     * <b>SetupScanFileQueue</b> returns zero. Issue a 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-queuescan">SPFILENOTIFY_QUEUESCAN</a> notification code and a pass a pointer to the target path as <i>Param1</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACKEX"></a><a id="spq_scan_use_callbackex"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACKEX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Callback routine for each node of the queue. If the callback routine returns a nonzero value, the queue processing stops and 
     * <b>SetupScanFileQueue</b> returns zero. Issue a SPFILENOTIFY_QUEUESCAN_EX notification and pass a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-filepaths_a">FILEPATHS</a> structure as <i>Param1</i>. SPQ_SCAN_USE_CALLBACKEX also checks that the file has a valid signature. Available starting with Windows2000. On WindowsXP only, you can turn off signature checking by combining this flag with SPQ_SCAN_FILE_PRESENCE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_INFORM_USER"></a><a id="spq_scan_inform_user"></a><dl>
     * <dt><b>SPQ_SCAN_INFORM_USER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Flag  specified when all  files in the queue pass the check for valid signatures. 
     * <b>SetupScanFileQueue</b> informs the user that the operation requires files that are already present on the target. This flag is ignored if SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY is not specified. This flag may not be used with SPQ_SCAN_PRUNE_COPY_QUEUE or SPQ_SCAN_PRUNE_DELREN.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_PRUNE_COPY_QUEUE"></a><a id="spq_scan_prune_copy_queue"></a><dl>
     * <dt><b>SPQ_SCAN_PRUNE_COPY_QUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Combined with SPQ_SCAN_FILE_PRESENCE, removes present entries from the copy queue. When combined with SPQ_SCAN_FILE_VALIDITY, removes signed entries from the copy queue. Available starting with Windows2000. On WindowsXP only, files that are also specified in the delete queue or rename queues are not pruned unless SPQ_SCAN_PRUNE_DELREN is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_USE_CALLBACK_SIGNERINFO"></a><a id="spq_scan_use_callback_signerinfo"></a><dl>
     * <dt><b>SPQ_SCAN_USE_CALLBACK_SIGNERINFO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Available starting with WindowsXP. Issues SPFILENOTIFY_QUEUESCAN_SIGNERINFO notification and passes a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-filepaths_signerinfo_a">FILEPATHS_SIGNERINFO</a> structure as <i>Param1</i>. Checks each file for a valid signature and reports signature information through the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_SCAN_PRUNE_DELREN"></a><a id="spq_scan_prune_delren"></a><dl>
     * <dt><b>SPQ_SCAN_PRUNE_DELREN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Combined with SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY, removes entries in the delete  or rename queue that are also in the copy queue. When combined with SPQ_SCAN_PRUNE_COPY_QUEUE, limits files that are removed from the copy queue to files that are not in  the delete  or  rename queues. Available starting with WindowsXP.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<HWND>} Window Optional handle to the window to own dialog boxes that are presented. This parameter is not used if the <i>Flags</i> parameter does not contain SPQ_SCAN_FILE_PRESENCE or if <i>Flags</i> does not contain SPQ_SCAN_INFORM_USER.
     * @param {Pointer<PSP_FILE_CALLBACK_W>} CallbackRoutine Optional pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> callback function to be called on each node of the copy queue. The notification code passed to the callback function is 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-queuescan">SPFILENOTIFY_QUEUESCAN</a>. This parameter is required if <i>Flags</i> includes SPQ_SCAN_USE_CALLBACK. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>You must supply the callback routine specified by <i>CallbackRoutine</i>. The default queue callback routine does not support 
     * <b>SetupScanFileQueue</b>.</div>
     * <div></div>
     * @param {Pointer<Void>} CallbackContext Optional pointer to a context that contains caller-defined data passed to the callback routine pointed to by <i>CallbackRoutine</i>.
     * @param {Pointer<UInt32>} Result Pointer to a variable that receives the result of the scan operation.
     * @returns {Integer} The function returns a nonzero value if all nodes in the queue were processed.
     * 
     * If the SPQ_SCAN_USE_CALLBACK flag was set, the value in <i>Result</i> is 0. The callback routine specified by <i>CallbackRoutine</i> is sent the notification SPFILENOTIFY_QUEUESCAN. <i>CallbackRoutine.Param1</i> specifies a pointer to an array that contains the target path information. The pointer has been cast to an unsigned integer and must be recast to a TCHAR array of MAX_PATH elements before a callback routine can access the information. <i>CallbackRoutine.Param2</i> is set to SPQ_DELAYED_COPY if the current queue node is in use and cannot be copied until the system is restarted. Otherwise, <i>CallbackRoutine.Param2</i> takes the value 0.
     * 
     * If SPQ_SCAN_USE_CALLBACK was not set, <i>Result</i> indicates whether the queue passed the presence or validity check as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue failed the check or it passed the check, but SPQ_SCAN_INFORM_USER was specified and the user wants new copies of the files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that copying is not required. The copy queue is empty and there are no elements on the delete or rename queues, so the caller can skip queue commit.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that copying is not required. The copy queue is empty, but there are elements on the delete or rename queues, so the caller cannot skip queue commit.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The function returns zero if an error occurred or the callback function returned nonzero. If <i>Result</i> is nonzero, it is the value returned by the callback function that stopped queue processing. If <i>Result</i> is zero, extended error information can be retrieved by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupscanfilequeuew
     * @since windows5.1.2600
     */
    static SetupScanFileQueueW(FileQueue, Flags, Window, CallbackRoutine, CallbackContext, Result) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupScanFileQueueW", "ptr", FileQueue, "uint", Flags, "ptr", Window, "ptr", CallbackRoutine, "ptr", CallbackContext, "ptr", Result, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileQueueCount function gets the count from a setup file queue.
     * @param {Pointer<Void>} FileQueue Handle to an open setup file queue.
     * @param {Integer} SubQueueFileOp Flag that specifies which subqueue count to be returned. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl>
     * <dt><b>FILEOP_COPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the number of entries in the copy subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILEOP_RENAME"></a><a id="fileop_rename"></a><dl>
     * <dt><b>FILEOP_RENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the number of entries in the rename subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILEOP_DELETE"></a><a id="fileop_delete"></a><dl>
     * <dt><b>FILEOP_DELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the number of entries in the delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILEOP_BACKUP"></a><a id="fileop_backup"></a><dl>
     * <dt><b>FILEOP_BACKUP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the number of entries in the backup subqueue.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} NumOperations Count from the setup file queue.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetfilequeuecount
     * @since windows5.1.2600
     */
    static SetupGetFileQueueCount(FileQueue, SubQueueFileOp, NumOperations) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileQueueCount", "ptr", FileQueue, "uint", SubQueueFileOp, "ptr", NumOperations, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupGetFileQueueFlags function gets the flags from a setup file queue.
     * @param {Pointer<Void>} FileQueue Handle to an open setup file queue.
     * @param {Pointer<UInt32>} Flags Pointer to location that contains the flag set with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupsetfilequeueflags">SetupSetFileQueueFlags</a> and returned by 
     * <b>SetupGetFileQueueFlags</b>. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_BACKUP_AWARE"></a><a id="spq_flag_backup_aware"></a><dl>
     * <dt><b>SPQ_FLAG_BACKUP_AWARE</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a> issues backup notifications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_ABORT_IF_UNSIGNED"></a><a id="spq_flag_abort_if_unsigned"></a><dl>
     * <dt><b>SPQ_FLAG_ABORT_IF_UNSIGNED</b></dt>
     * <dt>0X002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For internal use only.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetfilequeueflags
     * @since windows5.1.2600
     */
    static SetupGetFileQueueFlags(FileQueue, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupGetFileQueueFlags", "ptr", FileQueue, "ptr", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupSetFileQueueFlags function sets the flags on a setup file queue.
     * @param {Pointer<Void>} FileQueue Handle to an open setup file queue.
     * @param {Integer} FlagMask Mask of valid flags. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_VALID"></a><a id="spq_flag_valid"></a><dl>
     * <dt><b>SPQ_FLAG_VALID</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Mask for use with SPQ_FLAG_BACKUP_AWARE.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Flags Flags for use with 
     * <b>SetupSetFileQueueFlags</b> and returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetfilequeueflags">SetupGetFileQueueFlags</a>. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_BACKUP_AWARE"></a><a id="spq_flag_backup_aware"></a><dl>
     * <dt><b>SPQ_FLAG_BACKUP_AWARE</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a> issues backup notifications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPQ_FLAG_ABORT_IF_UNSIGNED"></a><a id="spq_flag_abort_if_unsigned"></a><dl>
     * <dt><b>SPQ_FLAG_ABORT_IF_UNSIGNED</b></dt>
     * <dt>0X002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For internal use only.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is (0) zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetfilequeueflags
     * @since windows5.1.2600
     */
    static SetupSetFileQueueFlags(FileQueue, FlagMask, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupSetFileQueueFlags", "ptr", FileQueue, "uint", FlagMask, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCopyOEMInf function copies a specified .inf file to the %windir%/Inf directory. (ANSI)
     * @remarks
     * The 
     * <b>SetupCopyOEMInf</b> function copies a specified .inf file into the %windir%\Inf directory. 
     * <b>SetupCopyOEMInf</b> does not recopy the file if it finds that a binary image of the specified .inf file already exists in the Inf directory with the same name or a name of the form OEM*.inf. When 
     * <b>SetupCopyOEMInf</b> copies a file, it renames the copied file to OEM*.inf. Name provided is unique and cannot be predicted.
     * 
     * <b>SetupCopyOEMInf</b> uses the following procedure to determine if the .inf file already exists in the Inf directory:
     * 
     * All .inf files with names of the form OEM*.inf are enumerated and any files that have the same file size as the specified .inf file are binary compared.
     * 
     * The Inf directory is searched for the source filename of the .inf file. If an .inf file of the same name exists and is the same size as that of the specified .inf file, the two files are binary compared to determine if they are identical.
     * 
     * If the specified .inf file already exists a further check is performed to determine if the specified .inf file contains a CatalogFile= entry in its [Version] section. If it does, the .inf file's %windir%\Inf primary filename with a ".cat" extension is used to determine if the catalog is already installed. If there is a catalog installed, but it is not the same as the catalog associated with the source .inf, this is not considered to be a match and enumerations continue. It is possible to have multiple identical .inf files with unique catalogs contained in %windir%\Inf directory. If an existing match is not found, the .inf and .cat files are installed under a new and unique name.
     * 
     * OEM .inf files that do not specify a CatalogFile= entry are considered invalid with respect to digital signature verification.
     * 
     * In cases where the .inf file must be copied to the %windir%\Inf directory, any digital signature verification failures are reported.
     * 
     * If the .inf and .cat files already exist, these existing filenames are used and the file replacement behavior is based on the specified CopyStyle flags. Replacement behavior refers only to the source media information stored in the .pnf. Existing .inf, .pnf, and .cat files are not modified.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupCopyOEMInf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} SourceInfFileName Full path to the source .inf file. You should use a null-terminated string. This path should not exceed <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
     * @param {Pointer<PSTR>} OEMSourceMediaLocation Source location information to be stored in the precompiled .inf (.pnf). This location information is specific to the source media type specified. You should use a null-terminated string. This path should not exceed <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
     * @param {Integer} OEMSourceMediaType 
     * @param {Integer} CopyStyle Specifies how the .inf file is copied into the .inf directory. The following flags can be combined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl>
     * <dt><b>SP_COPY_DELETESOURCE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete source file on successful copy.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a id="sp_copy_replaceonly"></a><dl>
     * <dt><b>SP_COPY_REPLACEONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Copy only if this file already exists in the Inf directory. This flag could be used to update the source location information for an existing .inf.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a id="sp_copy_nooverwrite"></a><dl>
     * <dt><b>SP_COPY_NOOVERWRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Copy only if the specified files do not currently exist in the Inf directory. If the .inf does currently exist, this API fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_FILE_EXISTS. In this case, the existing .inf file's filename is placed into the appropriate field in the destination .inf file's information output buffers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_OEMINF_CATALOG_ONLY"></a><a id="sp_copy_oeminf_catalog_only"></a><dl>
     * <dt><b>SP_COPY_OEMINF_CATALOG_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified .inf file's corresponding catalog files is copied to %windir%\Inf. If this flag is specified, the destination filename information is entered upon successful return if the specified .inf file already exists in the Inf directory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PSTR>} DestinationInfFileName Pointer to a buffer to receive the .inf file name assigned to it at the time it was copied to the Inf directory. The buffer, if specified, should typically be <b>MAX_PATH</b> in length. If the SP_COPY_NOOVERWRITE flag is specified and the <b>SetupCopyOEMInf</b> function fails with a return code of ERROR_FILE_EXISTS, this buffer contains the name of the existing .inf file. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this buffer contains the destination .inf filename if the .inf file is already present in the Inf directory. Otherwise, this buffer is set to the empty string. This parameter can be <b>NULL</b>.
     * @param {Integer} DestinationInfFileNameSize Size of the <i>DestinationInfFileName</i> buffer, in characters, or zero if the buffer is not specified. If <i>DestinationInfFileName</i> is specified and this buffer size is less than the size required to return the destination .inf filename (including full path), this function fails. In this case <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} RequiredSize Pointer to a variable that receives the size (in characters) required to store the destination .inf file name including a terminating <b>NULL</b>. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this variable receives a string length only if the .inf file already exists in the Inf directory. Otherwise, this variable is set to zero. This parameter can be <b>NULL</b>.
     * @param {Pointer<PSTR>} DestinationInfFileNameComponent Pointer to a string that is set upon successful return (or ERROR_FILE_EXISTS) to point to the beginning of the filename component of the path stored in the <i>DestinationInfFileName</i> parameter. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, the <i>DestinationInfFileName</i> parameter may be an empty string. In this case, the character pointer is set to <b>NULL</b> upon successful return. This parameter can be <b>NULL</b>.
     * @returns {Integer} This function returns WINSETUPAPI BOOL.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcopyoeminfa
     * @since windows5.1.2600
     */
    static SetupCopyOEMInfA(SourceInfFileName, OEMSourceMediaLocation, OEMSourceMediaType, CopyStyle, DestinationInfFileName, DestinationInfFileNameSize, RequiredSize, DestinationInfFileNameComponent) {
        SourceInfFileName := SourceInfFileName is String? StrPtr(SourceInfFileName) : SourceInfFileName
        OEMSourceMediaLocation := OEMSourceMediaLocation is String? StrPtr(OEMSourceMediaLocation) : OEMSourceMediaLocation
        DestinationInfFileName := DestinationInfFileName is String? StrPtr(DestinationInfFileName) : DestinationInfFileName
        DestinationInfFileNameComponent := DestinationInfFileNameComponent is String? StrPtr(DestinationInfFileNameComponent) : DestinationInfFileNameComponent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCopyOEMInfA", "ptr", SourceInfFileName, "ptr", OEMSourceMediaLocation, "uint", OEMSourceMediaType, "uint", CopyStyle, "ptr", DestinationInfFileName, "uint", DestinationInfFileNameSize, "ptr", RequiredSize, "ptr", DestinationInfFileNameComponent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCopyOEMInf function copies a specified .inf file to the %windir%/Inf directory. (Unicode)
     * @remarks
     * The 
     * <b>SetupCopyOEMInf</b> function copies a specified .inf file into the %windir%\Inf directory. 
     * <b>SetupCopyOEMInf</b> does not recopy the file if it finds that a binary image of the specified .inf file already exists in the Inf directory with the same name or a name of the form OEM*.inf. When 
     * <b>SetupCopyOEMInf</b> copies a file, it renames the copied file to OEM*.inf. Name provided is unique and cannot be predicted.
     * 
     * <b>SetupCopyOEMInf</b> uses the following procedure to determine if the .inf file already exists in the Inf directory:
     * 
     * All .inf files with names of the form OEM*.inf are enumerated and any files that have the same file size as the specified .inf file are binary compared.
     * 
     * The Inf directory is searched for the source filename of the .inf file. If an .inf file of the same name exists and is the same size as that of the specified .inf file, the two files are binary compared to determine if they are identical.
     * 
     * If the specified .inf file already exists a further check is performed to determine if the specified .inf file contains a CatalogFile= entry in its [Version] section. If it does, the .inf file's %windir%\Inf primary filename with a ".cat" extension is used to determine if the catalog is already installed. If there is a catalog installed, but it is not the same as the catalog associated with the source .inf, this is not considered to be a match and enumerations continue. It is possible to have multiple identical .inf files with unique catalogs contained in %windir%\Inf directory. If an existing match is not found, the .inf and .cat files are installed under a new and unique name.
     * 
     * OEM .inf files that do not specify a CatalogFile= entry are considered invalid with respect to digital signature verification.
     * 
     * In cases where the .inf file must be copied to the %windir%\Inf directory, any digital signature verification failures are reported.
     * 
     * If the .inf and .cat files already exist, these existing filenames are used and the file replacement behavior is based on the specified CopyStyle flags. Replacement behavior refers only to the source media information stored in the .pnf. Existing .inf, .pnf, and .cat files are not modified.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupCopyOEMInf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} SourceInfFileName Full path to the source .inf file. You should use a null-terminated string. This path should not exceed <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
     * @param {Pointer<PWSTR>} OEMSourceMediaLocation Source location information to be stored in the precompiled .inf (.pnf). This location information is specific to the source media type specified. You should use a null-terminated string. This path should not exceed <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
     * @param {Integer} OEMSourceMediaType 
     * @param {Integer} CopyStyle Specifies how the .inf file is copied into the .inf directory. The following flags can be combined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl>
     * <dt><b>SP_COPY_DELETESOURCE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete source file on successful copy.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a id="sp_copy_replaceonly"></a><dl>
     * <dt><b>SP_COPY_REPLACEONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Copy only if this file already exists in the Inf directory. This flag could be used to update the source location information for an existing .inf.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a id="sp_copy_nooverwrite"></a><dl>
     * <dt><b>SP_COPY_NOOVERWRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Copy only if the specified files do not currently exist in the Inf directory. If the .inf does currently exist, this API fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_FILE_EXISTS. In this case, the existing .inf file's filename is placed into the appropriate field in the destination .inf file's information output buffers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SP_COPY_OEMINF_CATALOG_ONLY"></a><a id="sp_copy_oeminf_catalog_only"></a><dl>
     * <dt><b>SP_COPY_OEMINF_CATALOG_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified .inf file's corresponding catalog files is copied to %windir%\Inf. If this flag is specified, the destination filename information is entered upon successful return if the specified .inf file already exists in the Inf directory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} DestinationInfFileName Pointer to a buffer to receive the .inf file name assigned to it at the time it was copied to the Inf directory. The buffer, if specified, should typically be <b>MAX_PATH</b> in length. If the SP_COPY_NOOVERWRITE flag is specified and the <b>SetupCopyOEMInf</b> function fails with a return code of ERROR_FILE_EXISTS, this buffer contains the name of the existing .inf file. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this buffer contains the destination .inf filename if the .inf file is already present in the Inf directory. Otherwise, this buffer is set to the empty string. This parameter can be <b>NULL</b>.
     * @param {Integer} DestinationInfFileNameSize Size of the <i>DestinationInfFileName</i> buffer, in characters, or zero if the buffer is not specified. If <i>DestinationInfFileName</i> is specified and this buffer size is less than the size required to return the destination .inf filename (including full path), this function fails. In this case <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} RequiredSize Pointer to a variable that receives the size (in characters) required to store the destination .inf file name including a terminating <b>NULL</b>. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this variable receives a string length only if the .inf file already exists in the Inf directory. Otherwise, this variable is set to zero. This parameter can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} DestinationInfFileNameComponent Pointer to a string that is set upon successful return (or ERROR_FILE_EXISTS) to point to the beginning of the filename component of the path stored in the <i>DestinationInfFileName</i> parameter. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, the <i>DestinationInfFileName</i> parameter may be an empty string. In this case, the character pointer is set to <b>NULL</b> upon successful return. This parameter can be <b>NULL</b>.
     * @returns {Integer} This function returns WINSETUPAPI BOOL.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcopyoeminfw
     * @since windows5.1.2600
     */
    static SetupCopyOEMInfW(SourceInfFileName, OEMSourceMediaLocation, OEMSourceMediaType, CopyStyle, DestinationInfFileName, DestinationInfFileNameSize, RequiredSize, DestinationInfFileNameComponent) {
        SourceInfFileName := SourceInfFileName is String? StrPtr(SourceInfFileName) : SourceInfFileName
        OEMSourceMediaLocation := OEMSourceMediaLocation is String? StrPtr(OEMSourceMediaLocation) : OEMSourceMediaLocation
        DestinationInfFileName := DestinationInfFileName is String? StrPtr(DestinationInfFileName) : DestinationInfFileName
        DestinationInfFileNameComponent := DestinationInfFileNameComponent is String? StrPtr(DestinationInfFileNameComponent) : DestinationInfFileNameComponent

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupCopyOEMInfW", "ptr", SourceInfFileName, "ptr", OEMSourceMediaLocation, "uint", OEMSourceMediaType, "uint", CopyStyle, "ptr", DestinationInfFileName, "uint", DestinationInfFileNameSize, "ptr", RequiredSize, "ptr", DestinationInfFileNameComponent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupUninstallOEMInf function uninstalls a specified .inf file and any associated .pnf file. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupUninstallOEMInf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} InfFileName File name, without path, of the .inf file in the Windows Inf directory that is to be uninstalled.
     * @param {Integer} Flags This parameter can be set as follows.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SUOI_FORCEDELETE"></a><a id="suoi_forcedelete"></a><dl>
     * <dt><b>SUOI_FORCEDELETE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>SetupUninstallOEMInf</b> function first checks whether there are any devices installed using the .inf file. A device does not need to be  present to be detected as using the .inf file.
     * 
     * If this flag is not set and the function finds a currently installed device that was installed using this .inf file, the .inf file is not removed.
     * 
     * If this flag is set, the .inf file is removed whether  the function finds a device that was installed with this .inf file.
     * 
     * <div class="alert"><b>Note</b>This flag only applies to x86, amd64, and ia64 architectures. It is ignored on all other architectures.</div>
     * <div></div>
     * <div class="alert"><b>Note</b>If the driver package has any files that are copied to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-destinationdirs-section">DestinationDir</a> that uses a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/using-dirids">DirId</a> of 13, then this force flag is ignored.</div>
     * <div></div>
     * <div class="alert"><b>Note</b>It is recommended to use <a href="https://docs.microsoft.com/windows/win32/api/newdev/nf-newdev-diuninstalldrivera">DiUninstallDriver</a> to remove a driver package instead of using this flag.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} This function returns WINSETUPAPI BOOL.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupuninstalloeminfa
     * @since windows5.1.2600
     */
    static SetupUninstallOEMInfA(InfFileName, Flags) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfFileName := InfFileName is String? StrPtr(InfFileName) : InfFileName

        result := DllCall("SETUPAPI.dll\SetupUninstallOEMInfA", "ptr", InfFileName, "uint", Flags, "ptr", Reserved, "int")
        return result
    }

    /**
     * The SetupUninstallOEMInf function uninstalls a specified .inf file and any associated .pnf file. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupUninstallOEMInf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} InfFileName File name, without path, of the .inf file in the Windows Inf directory that is to be uninstalled.
     * @param {Integer} Flags This parameter can be set as follows.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SUOI_FORCEDELETE"></a><a id="suoi_forcedelete"></a><dl>
     * <dt><b>SUOI_FORCEDELETE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>SetupUninstallOEMInf</b> function first checks whether there are any devices installed using the .inf file. A device does not need to be  present to be detected as using the .inf file.
     * 
     * If this flag is not set and the function finds a currently installed device that was installed using this .inf file, the .inf file is not removed.
     * 
     * If this flag is set, the .inf file is removed whether  the function finds a device that was installed with this .inf file.
     * 
     * <div class="alert"><b>Note</b>This flag only applies to x86, amd64, and ia64 architectures. It is ignored on all other architectures.</div>
     * <div></div>
     * <div class="alert"><b>Note</b>If the driver package has any files that are copied to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-destinationdirs-section">DestinationDir</a> that uses a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/using-dirids">DirId</a> of 13, then this force flag is ignored.</div>
     * <div></div>
     * <div class="alert"><b>Note</b>It is recommended to use <a href="https://docs.microsoft.com/windows/win32/api/newdev/nf-newdev-diuninstalldriverw">DiUninstallDriver</a> to remove a driver package instead of using this flag.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} This function returns WINSETUPAPI BOOL.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupuninstalloeminfw
     * @since windows5.1.2600
     */
    static SetupUninstallOEMInfW(InfFileName, Flags) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfFileName := InfFileName is String? StrPtr(InfFileName) : InfFileName

        result := DllCall("SETUPAPI.dll\SetupUninstallOEMInfW", "ptr", InfFileName, "uint", Flags, "ptr", Reserved, "int")
        return result
    }

    /**
     * The SetupUninstallNewlyCopiedInfs function uninstalls INF files (.inf), precompiled INF files (.pnf), and catalog files (.cat) that are previously installed during the committal of the specified file queue.
     * @param {Pointer<Void>} FileQueue Handle to an open and committed file queue. This queue contains the newly installed INF, PNF, or CAT files that 
     * <b>SetupUninstallNewlyCopiedInfs</b> uninstalls.
     * @param {Integer} Flags Flags to use with 
     * <b>SetupUninstallNewlyCopiedInfs</b>. No flags are defined currently. This parameter must be 0 (zero).
     * @returns {Integer} If the parameters passed in are valid, the return value is <b>TRUE</b> (nonzero), which does not necessarily mean that any INFs are uninstalled.
     * 
     * If some of the parameters passed in are invalid, the return value is <b>FALSE</b> (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupuninstallnewlycopiedinfs
     * @since windows5.1.2600
     */
    static SetupUninstallNewlyCopiedInfs(FileQueue, Flags) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupUninstallNewlyCopiedInfs", "ptr", FileQueue, "uint", Flags, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCreateDiskSpaceList function creates a disk-space list. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupCreateDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags This parameter can be the following value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcreatediskspacelista
     * @since windows5.1.2600
     */
    static SetupCreateDiskSpaceListA(Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupCreateDiskSpaceListA", "ptr", Reserved1, "uint", Reserved2, "uint", Flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupCreateDiskSpaceList function creates a disk-space list. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupCreateDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags This parameter can be the following value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcreatediskspacelistw
     * @since windows5.1.2600
     */
    static SetupCreateDiskSpaceListW(Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupCreateDiskSpaceListW", "ptr", Reserved1, "uint", Reserved2, "uint", Flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupDuplicateDiskSpaceList function duplicates a disk-space list as a new independent disk-space list. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDuplicateDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list to be duplicated.
     * @param {Integer} Flags Unused, must be  zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupduplicatediskspacelista
     * @since windows5.1.2600
     */
    static SetupDuplicateDiskSpaceListA(DiskSpace, Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupDuplicateDiskSpaceListA", "ptr", DiskSpace, "ptr", Reserved1, "uint", Reserved2, "uint", Flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupDuplicateDiskSpaceList function duplicates a disk-space list as a new independent disk-space list. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDuplicateDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list to be duplicated.
     * @param {Integer} Flags Unused, must be  zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupduplicatediskspacelistw
     * @since windows5.1.2600
     */
    static SetupDuplicateDiskSpaceListW(DiskSpace, Flags) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupDuplicateDiskSpaceListW", "ptr", DiskSpace, "ptr", Reserved1, "uint", Reserved2, "uint", Flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupDestroyDiskSpaceList function destroys a disk-space list and releases the resources allocated to it.
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list to be deconstructed.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdestroydiskspacelist
     * @since windows5.1.2600
     */
    static SetupDestroyDiskSpaceList(DiskSpace) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDestroyDiskSpaceList", "ptr", DiskSpace, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryDrivesInDiskSpaceList function fills a buffer with a list of the drives referenced by the file operations listed in the disk-space list. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryDrivesInDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<PSTR>} ReturnBuffer Optional pointer to a buffer that receives the drive specifications, such as "X:" or "\\server\share". You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be <b>NULL</b>.
     * If this parameter is not specified and no error occurs, the function returns a nonzero value and <i>RequiredSize</i> receives the buffer size required to hold the drive specifications.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. This parameter is ignored if <i>ReturnBuffer</i> is not specified.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the size of the buffer required to hold the <b>null</b>-terminated list of drives, in characters. This includes the <b>null</b> terminator.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns ERROR_INSUFFICIENT_BUFFER, <i>ReturnBuffer</i> was specified, but <i>ReturnBufferSize</i> indicated that the supplied buffer was too small.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupquerydrivesindiskspacelista
     * @since windows5.1.2600
     */
    static SetupQueryDrivesInDiskSpaceListA(DiskSpace, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryDrivesInDiskSpaceListA", "ptr", DiskSpace, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryDrivesInDiskSpaceList function fills a buffer with a list of the drives referenced by the file operations listed in the disk-space list. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryDrivesInDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<PWSTR>} ReturnBuffer Optional pointer to a buffer that receives the drive specifications, such as "X:" or "\\server\share". You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be <b>NULL</b>.
     * If this parameter is not specified and no error occurs, the function returns a nonzero value and <i>RequiredSize</i> receives the buffer size required to hold the drive specifications.
     * @param {Integer} ReturnBufferSize Size of the buffer pointed by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. This parameter is ignored if <i>ReturnBuffer</i> is not specified.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the size of the buffer required to hold the <b>null</b>-terminated list of drives, in characters. This includes the <b>null</b> terminator.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns ERROR_INSUFFICIENT_BUFFER, <i>ReturnBuffer</i> was specified, but <i>ReturnBufferSize</i> indicated that the supplied buffer was too small.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupquerydrivesindiskspacelistw
     * @since windows5.1.2600
     */
    static SetupQueryDrivesInDiskSpaceListW(DiskSpace, ReturnBuffer, ReturnBufferSize, RequiredSize) {
        ReturnBuffer := ReturnBuffer is String? StrPtr(ReturnBuffer) : ReturnBuffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryDrivesInDiskSpaceListW", "ptr", DiskSpace, "ptr", ReturnBuffer, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQuerySpaceRequiredOnDrive function examines a disk space list to determine the space that is required to perform all the file operations listed for a specific drive. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupQuerySpaceRequiredOnDrive as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace The handle to a disk space list.
     * @param {Pointer<PSTR>} DriveSpec A pointer to a null-terminated string that specifies the drive where space information is to be returned. 
     * 
     * This should be in the form "x:" or "\\server\share".
     * @param {Pointer<Int64>} SpaceRequired If the function succeeds, this parameter receives the amount of additional space that is required to process all the file operations listed in the disk space list for the drive that <i>DriveSpec</i> specifies. 
     * 
     * 
     * 
     * 
     * The 
     * <b>SetupQuerySpaceRequiredOnDrive</b> function calculates the additional space required on the target drive by checking for preexisting versions of the files on the target drive.
     * 
     * For example, if a file operation copies a 2000-byte file, FIRST.EXE, to the directory, C:\MYPROG\, the 
     * <b>SetupQuerySpaceRequiredOnDrive</b> function automatically checks for a preexisting version of that file in that directory. If a preexisting version of C:\MYPROG\FIRST.EXE has a file size of 500 bytes, the additional space required on the drive C for that operation is 1500 bytes.
     * 
     * The value received can be 0 (zero) or a negative number, if additional space is not required, or if space is freed on the target drive.
     * 
     * If FIRST.EXE in the preceding example is being deleted from the drive C, the amount of space required is 2000 bytes, or the space freed on drive C.
     * 
     * If the preexisting version has a file size of 5000 bytes, then the disk space required to replace it with the 2000-byte FIRST.EXE is 3000 bytes.
     * 
     * File sizes are rounded to disk cluster boundaries.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value and <i>SpaceRequired</i> receives the amount of space required by the file operations listed in the current disk space list.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DRIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is not on the disk-space list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>DiskSpace</i> handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>DriveSpec</i> string is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryspacerequiredondrivea
     * @since windows5.1.2600
     */
    static SetupQuerySpaceRequiredOnDriveA(DiskSpace, DriveSpec, SpaceRequired) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DriveSpec := DriveSpec is String? StrPtr(DriveSpec) : DriveSpec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQuerySpaceRequiredOnDriveA", "ptr", DiskSpace, "ptr", DriveSpec, "ptr", SpaceRequired, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQuerySpaceRequiredOnDrive function examines a disk space list to determine the space that is required to perform all the file operations listed for a specific drive. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupQuerySpaceRequiredOnDrive as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace The handle to a disk space list.
     * @param {Pointer<PWSTR>} DriveSpec A pointer to a null-terminated string that specifies the drive where space information is to be returned. 
     * 
     * This should be in the form "x:" or "\\server\share".
     * @param {Pointer<Int64>} SpaceRequired If the function succeeds, this parameter receives the amount of additional space that is required to process all the file operations listed in the disk space list for the drive that <i>DriveSpec</i> specifies. 
     * 
     * 
     * 
     * 
     * The 
     * <b>SetupQuerySpaceRequiredOnDrive</b> function calculates the additional space required on the target drive by checking for preexisting versions of the files on the target drive.
     * 
     * For example, if a file operation copies a 2000-byte file, FIRST.EXE, to the directory, C:\MYPROG\, the 
     * <b>SetupQuerySpaceRequiredOnDrive</b> function automatically checks for a preexisting version of that file in that directory. If a preexisting version of C:\MYPROG\FIRST.EXE has a file size of 500 bytes, the additional space required on the drive C for that operation is 1500 bytes.
     * 
     * The value received can be 0 (zero) or a negative number, if additional space is not required, or if space is freed on the target drive.
     * 
     * If FIRST.EXE in the preceding example is being deleted from the drive C, the amount of space required is 2000 bytes, or the space freed on drive C.
     * 
     * If the preexisting version has a file size of 5000 bytes, then the disk space required to replace it with the 2000-byte FIRST.EXE is 3000 bytes.
     * 
     * File sizes are rounded to disk cluster boundaries.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value and <i>SpaceRequired</i> receives the amount of space required by the file operations listed in the current disk space list.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DRIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is not on the disk-space list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>DiskSpace</i> handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>DriveSpec</i> string is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryspacerequiredondrivew
     * @since windows5.1.2600
     */
    static SetupQuerySpaceRequiredOnDriveW(DiskSpace, DriveSpec, SpaceRequired) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DriveSpec := DriveSpec is String? StrPtr(DriveSpec) : DriveSpec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQuerySpaceRequiredOnDriveW", "ptr", DiskSpace, "ptr", DriveSpec, "ptr", SpaceRequired, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAdjustDiskSpaceList function adjusts the amount of required space for a specified drive. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupAdjustDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<PSTR>} DriveRoot Specifies a valid Win32 drive root. An entry is added to the disk-space list if the specified drive is not currently in the disk-space list.
     * @param {Integer} Amount Specifies the amount of space to add or remove. Use a negative number to remove space and use a positive number to add space.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupadjustdiskspacelista
     * @since windows5.1.2600
     */
    static SetupAdjustDiskSpaceListA(DiskSpace, DriveRoot, Amount) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DriveRoot := DriveRoot is String? StrPtr(DriveRoot) : DriveRoot

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAdjustDiskSpaceListA", "ptr", DiskSpace, "ptr", DriveRoot, "int64", Amount, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAdjustDiskSpaceList function adjusts the amount of required space for a specified drive. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupAdjustDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<PWSTR>} DriveRoot Specifies a valid Win32 drive root. An entry is added to the disk-space list if the specified drive is not currently in the disk-space list.
     * @param {Integer} Amount Specifies the amount of space to add or remove. Use a negative number to remove space and use a positive number to add space.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupadjustdiskspacelistw
     * @since windows5.1.2600
     */
    static SetupAdjustDiskSpaceListW(DiskSpace, DriveRoot, Amount) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DriveRoot := DriveRoot is String? StrPtr(DriveRoot) : DriveRoot

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAdjustDiskSpaceListW", "ptr", DiskSpace, "ptr", DriveRoot, "int64", Amount, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddToDiskSpaceList function adds a single delete or copy operation to a disk-space list. To add all the file operations in a section of an INF file, use either SetupAddSectionToDiskSpaceList, or SetupAddInstallSectionToDiskSpaceList. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupAddToDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<PSTR>} TargetFilespec File name of the file to be added to the disk-space list. You should use a null-terminated string that specifies  a fully qualified path. Otherwise, the path must be relative to the current directory.
     * @param {Integer} FileSize Uncompressed size of the file as it will exist in the target directory, in bytes. You can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetsourcefilesizea">SetupGetSourceFileSize</a> to retrieve this information from an INF file. This parameter is ignored for FILEOP_DELETE operations.
     * @param {Integer} Operation 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupaddtodiskspacelista
     * @since windows5.1.2600
     */
    static SetupAddToDiskSpaceListA(DiskSpace, TargetFilespec, FileSize, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        TargetFilespec := TargetFilespec is String? StrPtr(TargetFilespec) : TargetFilespec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddToDiskSpaceListA", "ptr", DiskSpace, "ptr", TargetFilespec, "int64", FileSize, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddToDiskSpaceList function adds a single delete or copy operation to a disk-space list. To add all the file operations in a section of an INF file, use either SetupAddSectionToDiskSpaceList, or SetupAddInstallSectionToDiskSpaceList. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupAddToDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<PWSTR>} TargetFilespec File name of the file to be added to the disk-space list. You should use a null-terminated string that specifies  a fully qualified path. Otherwise, the path must be relative to the current directory.
     * @param {Integer} FileSize Uncompressed size of the file as it will exist in the target directory, in bytes. You can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetsourcefilesizea">SetupGetSourceFileSize</a> to retrieve this information from an INF file. This parameter is ignored for FILEOP_DELETE operations.
     * @param {Integer} Operation 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupaddtodiskspacelistw
     * @since windows5.1.2600
     */
    static SetupAddToDiskSpaceListW(DiskSpace, TargetFilespec, FileSize, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        TargetFilespec := TargetFilespec is String? StrPtr(TargetFilespec) : TargetFilespec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddToDiskSpaceListW", "ptr", DiskSpace, "ptr", TargetFilespec, "int64", FileSize, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddSectionToDiskSpaceList function adds to a disk-space list all the file delete or copy operations listed in a Copy Files or Delete Files section of an INF file. (ANSI)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupAddSectionToDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not specified, this INF file must also contain the section named by <i>SectionName</i>.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section specified by <i>SectionName</i>. Otherwise, <i>InfHandle</i> is assumed to contain this section.
     * @param {Pointer<PSTR>} SectionName Name of the <b>Copy Files</b> or <b>Delete Files</b> section that contains the file operations to add to the disk-space list. Use a null-terminated string.
     * @param {Integer} Operation 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupaddsectiontodiskspacelista
     * @since windows5.1.2600
     */
    static SetupAddSectionToDiskSpaceListA(DiskSpace, InfHandle, ListInfHandle, SectionName, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddSectionToDiskSpaceListA", "ptr", DiskSpace, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", SectionName, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddSectionToDiskSpaceList function adds to a disk-space list all the file delete or copy operations listed in a Copy Files or Delete Files section of an INF file. (Unicode)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupAddSectionToDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not specified, this INF file must also contain the section named by <i>SectionName</i>.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section specified by <i>SectionName</i>. Otherwise, <i>InfHandle</i> is assumed to contain this section.
     * @param {Pointer<PWSTR>} SectionName Name of the <b>Copy Files</b> or <b>Delete Files</b> section that contains the file operations to add to the disk-space list. Use a null-terminated string.
     * @param {Integer} Operation 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupaddsectiontodiskspacelistw
     * @since windows5.1.2600
     */
    static SetupAddSectionToDiskSpaceListW(DiskSpace, InfHandle, ListInfHandle, SectionName, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddSectionToDiskSpaceListW", "ptr", DiskSpace, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", SectionName, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddInstallSectionToDiskSpaceList function searches for CopyFile and DelFile lines in an Install section of an INF file. The function then adds the file operations specified in those sections to a disk-space list. (ANSI)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupAddInstallSectionToDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>Install</b> section to be searched. If <i>ListInfHandle</i> is not specified, the INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} LayoutInfHandle This parameter, if specified, provides the handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
     * @param {Pointer<PSTR>} SectionName Name of the Install section to be added to the disk-space list. You should use a null-terminated string.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupaddinstallsectiontodiskspacelista
     * @since windows5.1.2600
     */
    static SetupAddInstallSectionToDiskSpaceListA(DiskSpace, InfHandle, LayoutInfHandle, SectionName) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddInstallSectionToDiskSpaceListA", "ptr", DiskSpace, "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", SectionName, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupAddInstallSectionToDiskSpaceList function searches for CopyFile and DelFile lines in an Install section of an INF file. The function then adds the file operations specified in those sections to a disk-space list. (Unicode)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupAddInstallSectionToDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>Install</b> section to be searched. If <i>ListInfHandle</i> is not specified, the INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} LayoutInfHandle This parameter, if specified, provides the handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
     * @param {Pointer<PWSTR>} SectionName Name of the Install section to be added to the disk-space list. You should use a null-terminated string.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupaddinstallsectiontodiskspacelistw
     * @since windows5.1.2600
     */
    static SetupAddInstallSectionToDiskSpaceListW(DiskSpace, InfHandle, LayoutInfHandle, SectionName) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupAddInstallSectionToDiskSpaceListW", "ptr", DiskSpace, "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", SectionName, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFromDiskSpaceList function removes a file delete or copy operation from a disk-space list. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveFromDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<PSTR>} TargetFilespec Pointer to a null-terminated string that specifies the file name of the file to remove from the disk-space list. This is typically a fully qualified  path. Otherwise, the path must be relative to the current directory.
     * @param {Integer} Operation 
     * @returns {Integer} If the file was not in the list, the 
     * <b>SetupRemoveFromDiskSpaceList</b> function returns a nonzero value and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME. If the file was in the list then upon success the routine returns a nonzero value and 
     * <b>GetLastError</b> returns NO_ERROR.
     * 
     * If the routine fails for some other reason, it returns zero and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremovefromdiskspacelista
     * @since windows5.1.2600
     */
    static SetupRemoveFromDiskSpaceListA(DiskSpace, TargetFilespec, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        TargetFilespec := TargetFilespec is String? StrPtr(TargetFilespec) : TargetFilespec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFromDiskSpaceListA", "ptr", DiskSpace, "ptr", TargetFilespec, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFromDiskSpaceList function removes a file delete or copy operation from a disk-space list. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveFromDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<PWSTR>} TargetFilespec Pointer to a null-terminated string that specifies the file name of the file to remove from the disk-space list. This is typically a fully qualified  path. Otherwise, the path must be relative to the current directory.
     * @param {Integer} Operation 
     * @returns {Integer} If the file was not in the list, the 
     * <b>SetupRemoveFromDiskSpaceList</b> function returns a nonzero value and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME. If the file was in the list then upon success the routine returns a nonzero value and 
     * <b>GetLastError</b> returns NO_ERROR.
     * 
     * If the routine fails for some other reason, it returns zero and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremovefromdiskspacelistw
     * @since windows5.1.2600
     */
    static SetupRemoveFromDiskSpaceListW(DiskSpace, TargetFilespec, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        TargetFilespec := TargetFilespec is String? StrPtr(TargetFilespec) : TargetFilespec

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFromDiskSpaceListW", "ptr", DiskSpace, "ptr", TargetFilespec, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveSectionFromDiskSpaceList function removes the file delete or copy operations listed in a Copy Files section of an INF file from a disk-space list. (ANSI)
     * @remarks
     * The file operations removed by the 
     * <b>SetupRemoveSectionFromDiskSpaceList</b> function are typically those that have been added to the list by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupaddsectiontodiskspacelista">SetupAddSectionToDiskSpaceList</a> function, though this is not a requirement. The 
     * <b>SetupRemoveSectionFromDiskSpaceList</b> function ignores files in the INF section that are not listed in the disk-space list.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveSectionFromDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not specified, this INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section to remove from the disk-space list. Otherwise, <i>InfHandle</i> must contain the section specified by <i>SectionName</i>.
     * @param {Pointer<PSTR>} SectionName Pointer to a null-terminated string that specifies the name of the <b>Copy Files</b> or <b>Delete Files</b> section to remove from the disk-space list.
     * @param {Integer} Operation 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremovesectionfromdiskspacelista
     * @since windows5.1.2600
     */
    static SetupRemoveSectionFromDiskSpaceListA(DiskSpace, InfHandle, ListInfHandle, SectionName, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveSectionFromDiskSpaceListA", "ptr", DiskSpace, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", SectionName, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveSectionFromDiskSpaceList function removes the file delete or copy operations listed in a Copy Files section of an INF file from a disk-space list. (Unicode)
     * @remarks
     * The file operations removed by the 
     * <b>SetupRemoveSectionFromDiskSpaceList</b> function are typically those that have been added to the list by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupaddsectiontodiskspacelista">SetupAddSectionToDiskSpaceList</a> function, though this is not a requirement. The 
     * <b>SetupRemoveSectionFromDiskSpaceList</b> function ignores files in the INF section that are not listed in the disk-space list.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveSectionFromDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to the disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not specified, this INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} ListInfHandle Optional handle to an open INF file that contains the section to remove from the disk-space list. Otherwise, <i>InfHandle</i> must contain the section specified by <i>SectionName</i>.
     * @param {Pointer<PWSTR>} SectionName Pointer to a null-terminated string that specifies the name of the <b>Copy Files</b> or <b>Delete Files</b> section to remove from the disk-space list.
     * @param {Integer} Operation 
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremovesectionfromdiskspacelistw
     * @since windows5.1.2600
     */
    static SetupRemoveSectionFromDiskSpaceListW(DiskSpace, InfHandle, ListInfHandle, SectionName, Operation) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveSectionFromDiskSpaceListW", "ptr", DiskSpace, "ptr", InfHandle, "ptr", ListInfHandle, "ptr", SectionName, "uint", Operation, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveInstallSectionFromDiskSpaceList function searches an Install section of an INF file for CopyFiles and DelFiles lines, and removes the file operations specified in those sections from a disk-space list. (ANSI)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveInstallSectionFromDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>Install</b> section. If <i>LayoutInfHandle</i> is not specified, the INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} LayoutInfHandle Optional handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise, that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
     * @param {Pointer<PSTR>} SectionName Pointer to a null-terminated string that specifies the name of the section to be added to the disk-space list.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremoveinstallsectionfromdiskspacelista
     * @since windows5.1.2600
     */
    static SetupRemoveInstallSectionFromDiskSpaceListA(DiskSpace, InfHandle, LayoutInfHandle, SectionName) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveInstallSectionFromDiskSpaceListA", "ptr", DiskSpace, "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", SectionName, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveInstallSectionFromDiskSpaceList function searches an Install section of an INF file for CopyFiles and DelFiles lines, and removes the file operations specified in those sections from a disk-space list. (Unicode)
     * @remarks
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveInstallSectionFromDiskSpaceList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} DiskSpace Handle to a disk-space list.
     * @param {Pointer<Void>} InfHandle Handle to an open INF file that contains the <b>Install</b> section. If <i>LayoutInfHandle</i> is not specified, the INF file must also contain the section specified by <i>SectionName</i>.
     * @param {Pointer<Void>} LayoutInfHandle Optional handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise, that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
     * @param {Pointer<PWSTR>} SectionName Pointer to a null-terminated string that specifies the name of the section to be added to the disk-space list.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremoveinstallsectionfromdiskspacelistw
     * @since windows5.1.2600
     */
    static SetupRemoveInstallSectionFromDiskSpaceListW(DiskSpace, InfHandle, LayoutInfHandle, SectionName) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveInstallSectionFromDiskSpaceListW", "ptr", DiskSpace, "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", SectionName, "ptr", Reserved1, "uint", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupIterateCabinet function iterates through all the files in a cabinet and sends a notification to a callback function for each file found. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupIterateCabinet as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} CabinetFile Cabinet (.CAB) file to iterate through.
     * @param {Pointer<PSP_FILE_CALLBACK_A>} MsgHandler Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> routine that will process the notifications 
     * <b>SetupIterateCabinet</b> returns as it iterates through the files in the cabinet file. The callback routine may then return a value specifying whether to decompress, copy, or skip the file.
     * @param {Pointer<Void>} Context Context value that is passed into the routine specified in <i>MsgHandler</i>. This enables the callback routine to track values between notifications, without having to use global variables.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupiteratecabineta
     * @since windows5.1.2600
     */
    static SetupIterateCabinetA(CabinetFile, MsgHandler, Context) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        CabinetFile := CabinetFile is String? StrPtr(CabinetFile) : CabinetFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupIterateCabinetA", "ptr", CabinetFile, "uint", Reserved, "ptr", MsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupIterateCabinet function iterates through all the files in a cabinet and sends a notification to a callback function for each file found. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupIterateCabinet as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} CabinetFile Cabinet (.CAB) file to iterate through.
     * @param {Pointer<PSP_FILE_CALLBACK_W>} MsgHandler Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a> routine that will process the notifications 
     * <b>SetupIterateCabinet</b> returns as it iterates through the files in the cabinet file. The callback routine may then return a value specifying whether to decompress, copy, or skip the file.
     * @param {Pointer<Void>} Context Context value that is passed into the routine specified in <i>MsgHandler</i>. This enables the callback routine to track values between notifications, without having to use global variables.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupiteratecabinetw
     * @since windows5.1.2600
     */
    static SetupIterateCabinetW(CabinetFile, MsgHandler, Context) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        CabinetFile := CabinetFile is String? StrPtr(CabinetFile) : CabinetFile

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupIterateCabinetW", "ptr", CabinetFile, "uint", Reserved, "ptr", MsgHandler, "ptr", Context, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupPromptReboot function asks the user if he wants to reboot the system, optionally dependent on whether any files in a committed file queue were in use during a file operation.
     * @param {Pointer<Void>} FileQueue Optional pointer to a handle to the file queue upon which to base the decision about whether shutdown is necessary. If <i>FileQueue</i> is not specified, 
     * <b>SetupPromptReboot</b> assumes shutdown is necessary and asks the user what to do.
     * @param {Pointer<HWND>} Owner Handle for the parent window to own windows created by this function.
     * @param {Integer} ScanOnly Indicates whether or not to prompt the user when 
     * <b>SetupPromptReboot</b> is called. 
     * 
     * 
     * 
     * 
     * If <b>TRUE</b>, the user is never asked about rebooting, and system shutdown is not initiated. In this case, <i>FileQueue</i> must be specified. If <b>FALSE</b>, the user is asked about rebooting, as previously described.
     * 
     * Use <i>ScanOnly</i> to determine if shutdown is necessary separately from actually initiating a shutdown.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuppromptreboot
     * @since windows5.1.2600
     */
    static SetupPromptReboot(FileQueue, Owner, ScanOnly) {
        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupPromptReboot", "ptr", FileQueue, "ptr", Owner, "int", ScanOnly)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupInitDefaultQueueCallback function initializes the context used by the default queue callback routine included with the Setup API.
     * @remarks
     * Regardless of whether you initialized the context used by the default queue callback routine with 
     * <b>SetupInitDefaultQueueCallback</b> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a>, after the queued operations have finished processing, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setuptermdefaultqueuecallback">SetupTermDefaultQueueCallback</a> to release the resources allocated in initializing the context structure. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/initializing-and-terminating-the-callback-context">Initializing and Terminating the Callback Context</a>.
     * @param {Pointer<HWND>} OwnerWindow Handle to the window to use as the parent of any dialog boxes generated by the default callback routine.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback
     * @since windows5.1.2600
     */
    static SetupInitDefaultQueueCallback(OwnerWindow) {
        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupInitDefaultQueueCallback", "ptr", OwnerWindow)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Initializes the context used by the default queue callback routine included with the Setup API in the same manner as SetupInitDefaultQueueCallback, except that an additional window is provided to the callback function to accept progress messages.
     * @remarks
     * When the queue starts to commit the copy subqueue, the default queue callback routine sends a message to the window specified in <i>AlternateProgressWindow</i>. <i>Reserved1</i> has the value 0, and <i>Reserved2</i> contains a pointer to the number of enqueued file copy operations.
     * 
     * For each file copy operation completed, the default queue callback routine sends a message to <i>AlternateProgressWindow</i>, which can be used to 'tick' the progress bar. <i>Reserved1</i> has the value 1, and <i>Reserved2</i> is zero.
     * 
     * <b>SetupInitDefaultQueueCallbackEx</b> can be used to get the default behavior for disk prompting, error handling, and so on, and also provide a gauge embedded in a wizard page or other specialized dialog box.
     * 
     * Regardless of whether you initialized the context used by the default queue callback routine with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <b>SetupInitDefaultQueueCallbackEx</b>, after the queued operations have finished processing, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setuptermdefaultqueuecallback">SetupTermDefaultQueueCallback</a> to release the resources allocated in initializing the context structure. For more information see 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/initializing-and-terminating-the-callback-context">Initializing and Terminating the Callback Context</a>.
     * @param {Pointer<HWND>} OwnerWindow Handle to the window to use as the parent of any dialog boxes generated by the default callback routine.
     * @param {Pointer<HWND>} AlternateProgressWindow Handle to a window that receives the progress messages. To prevent progress messages from being displayed, you can specify this parameter to be INVALID_HANDLE_VALUE.
     * @param {Integer} ProgressMessage Message that is sent to <i>AlternateProgressWindow</i> when the copy queue is started, and each time a file is copied.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex
     * @since windows5.1.2600
     */
    static SetupInitDefaultQueueCallbackEx(OwnerWindow, AlternateProgressWindow, ProgressMessage) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        DllCall("SETUPAPI.dll\SetupInitDefaultQueueCallbackEx", "ptr", OwnerWindow, "ptr", AlternateProgressWindow, "uint", ProgressMessage, "uint", Reserved1, "ptr", Reserved2)
    }

    /**
     * The SetupTermDefaultQueueCallback function is called after a queue has finished committing. It frees resources allocated by previous calls to SetupInitDefaultQueueCallback or SetupInitDefaultQueueCallbackEx.
     * @remarks
     * Regardless of whether you initialized the context used by the default queue callback routine with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a>, after the queued operations have finished processing, call 
     * <b>SetupTermDefaultQueueCallback</b> to release the resources allocated in initializing the context structure. For more information see 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/initializing-and-terminating-the-callback-context">Initializing and Terminating the Callback Context</a>.
     * @param {Pointer<Void>} Context Pointer to the context used by the default callback routine.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuptermdefaultqueuecallback
     * @since windows5.1.2600
     */
    static SetupTermDefaultQueueCallback(Context) {
        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupTermDefaultQueueCallback", "ptr", Context)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupDefaultQueueCallback function is the default queue callback routine included with the Setup API. You can use it to process notifications sent by the SetupCommitFileQueue function. (ANSI)
     * @remarks
     * The 
     * <b>SetupDefaultQueueCallback</b> function is usually only called explicitly by a custom queue callback routine. The custom callback handles a subset of the queue commit notifications and calls the 
     * <b>SetupDefaultQueueCallback</b> function to handle the rest of the notifications.
     * 
     * For more information see, 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/queue-notifications">Queue Notifications</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDefaultQueueCallback as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Context Pointer to the context initialized by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a> functions.
     * @param {Integer} Notification Notification of a queue action. This parameter can be one of the  values shown in the following table. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTQUEUE"></a><a id="spfilenotify_startqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started queued file operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDQUEUE"></a><a id="spfilenotify_endqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished queued file operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTSUBQUEUE"></a><a id="spfilenotify_startsubqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTSUBQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a copy, rename, or delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDSUBQUEUE"></a><a id="spfilenotify_endsubqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDSUBQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a copy, rename, or delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTRENAME"></a><a id="spfilenotify_startrename"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTRENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a rename operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDRENAME"></a><a id="spfilenotify_endrename"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDRENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a rename operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_RENAMEERROR"></a><a id="spfilenotify_renameerror"></a><dl>
     * <dt><b>SPFILENOTIFY_RENAMEERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while renaming a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTDELETE"></a><a id="spfilenotify_startdelete"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTDELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a delete operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDDELETE"></a><a id="spfilenotify_enddelete"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDDELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a delete operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_DELETEERROR"></a><a id="spfilenotify_deleteerror"></a><dl>
     * <dt><b>SPFILENOTIFY_DELETEERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while deleting a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTCOPY"></a><a id="spfilenotify_startcopy"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTCOPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDCOPY"></a><a id="spfilenotify_endcopy"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDCOPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_COPYERROR"></a><a id="spfilenotify_copyerror"></a><dl>
     * <dt><b>SPFILENOTIFY_COPYERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while copying a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_NEEDMEDIA"></a><a id="spfilenotify_needmedia"></a><dl>
     * <dt><b>SPFILENOTIFY_NEEDMEDIA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * New media is required.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_LANGMISMATCH"></a><a id="spfilenotify_langmismatch"></a><dl>
     * <dt><b>SPFILENOTIFY_LANGMISMATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Existing target file is in a different language than the source.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_TARGETEXISTS"></a><a id="spfilenotify_targetexists"></a><dl>
     * <dt><b>SPFILENOTIFY_TARGETEXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target file exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_TARGETNEWER_"></a><a id="spfilenotify_targetnewer_"></a><dl>
     * <dt><b>SPFILENOTIFY_TARGETNEWER </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Existing target file is newer than source.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} Param1 Additional message information. The content of this parameter depends on the value of the <i>Notification</i> parameter.
     * @param {Pointer} Param2 Additional message information. The content of this parameter depends on the value of the <i>Notification</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdefaultqueuecallbacka
     * @since windows5.1.2600
     */
    static SetupDefaultQueueCallbackA(Context, Notification, Param1, Param2) {
        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupDefaultQueueCallbackA", "ptr", Context, "uint", Notification, "ptr", Param1, "ptr", Param2)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupDefaultQueueCallback function is the default queue callback routine included with the Setup API. You can use it to process notifications sent by the SetupCommitFileQueue function. (Unicode)
     * @remarks
     * The 
     * <b>SetupDefaultQueueCallback</b> function is usually only called explicitly by a custom queue callback routine. The custom callback handles a subset of the queue commit notifications and calls the 
     * <b>SetupDefaultQueueCallback</b> function to handle the rest of the notifications.
     * 
     * For more information see, 
     * <a href="https://docs.microsoft.com/windows/desktop/SetupApi/queue-notifications">Queue Notifications</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDefaultQueueCallback as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Context Pointer to the context initialized by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallback">SetupInitDefaultQueueCallback</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitdefaultqueuecallbackex">SetupInitDefaultQueueCallbackEx</a> functions.
     * @param {Integer} Notification Notification of a queue action. This parameter can be one of the  values shown in the following table. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTQUEUE"></a><a id="spfilenotify_startqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started queued file operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDQUEUE"></a><a id="spfilenotify_endqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished queued file operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTSUBQUEUE"></a><a id="spfilenotify_startsubqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTSUBQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a copy, rename, or delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDSUBQUEUE"></a><a id="spfilenotify_endsubqueue"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDSUBQUEUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a copy, rename, or delete subqueue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTRENAME"></a><a id="spfilenotify_startrename"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTRENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a rename operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDRENAME"></a><a id="spfilenotify_endrename"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDRENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a rename operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_RENAMEERROR"></a><a id="spfilenotify_renameerror"></a><dl>
     * <dt><b>SPFILENOTIFY_RENAMEERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while renaming a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTDELETE"></a><a id="spfilenotify_startdelete"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTDELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a delete operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDDELETE"></a><a id="spfilenotify_enddelete"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDDELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a delete operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_DELETEERROR"></a><a id="spfilenotify_deleteerror"></a><dl>
     * <dt><b>SPFILENOTIFY_DELETEERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while deleting a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_STARTCOPY"></a><a id="spfilenotify_startcopy"></a><dl>
     * <dt><b>SPFILENOTIFY_STARTCOPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Started a copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_ENDCOPY"></a><a id="spfilenotify_endcopy"></a><dl>
     * <dt><b>SPFILENOTIFY_ENDCOPY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finished a copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_COPYERROR"></a><a id="spfilenotify_copyerror"></a><dl>
     * <dt><b>SPFILENOTIFY_COPYERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encountered an error while copying a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_NEEDMEDIA"></a><a id="spfilenotify_needmedia"></a><dl>
     * <dt><b>SPFILENOTIFY_NEEDMEDIA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * New media is required.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_LANGMISMATCH"></a><a id="spfilenotify_langmismatch"></a><dl>
     * <dt><b>SPFILENOTIFY_LANGMISMATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Existing target file is in a different language than the source.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_TARGETEXISTS"></a><a id="spfilenotify_targetexists"></a><dl>
     * <dt><b>SPFILENOTIFY_TARGETEXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Target file exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPFILENOTIFY_TARGETNEWER_"></a><a id="spfilenotify_targetnewer_"></a><dl>
     * <dt><b>SPFILENOTIFY_TARGETNEWER </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Existing target file is newer than source.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} Param1 Additional message information. The content of this parameter depends on the value of the <i>Notification</i> parameter.
     * @param {Pointer} Param2 Additional message information. The content of this parameter depends on the value of the <i>Notification</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdefaultqueuecallbackw
     * @since windows5.1.2600
     */
    static SetupDefaultQueueCallbackW(Context, Notification, Param1, Param2) {
        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupDefaultQueueCallbackW", "ptr", Context, "uint", Notification, "ptr", Param1, "ptr", Param2)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupInstallFromInfSection function carries out all the directives in an INF file Install section. (ANSI)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists 
     *     before you call <b>SetupInstallFromInfSection</b>. The setup functions do not check for 
     *     the existence of and do not create UNC directories. If the target UNC directory does not exist, the file 
     *     installation will fail.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallFromInfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} Owner Optional pointer to the window handle to the window that owns any dialog boxes that are generated during 
     *       installation, such as for disk prompting or file copying. If <i>Owner</i> is not specified, 
     *       these dialog boxes become top-level windows.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the section to be processed.
     * @param {Pointer<PSTR>} SectionName Name of the <b>Install</b> section in the INF file to process.
     * @param {Integer} Flags 
     * @param {Pointer<HKEY>} RelativeKeyRoot Optional parameter that must be specified if <i>Flags</i> includes SPINST_REGISTRY or 
     *       SPINST_INI2REG. Handle to a registry key to be used as the root when the INF file specifies HKR as the key. 
     *       Note that this parameter is ignored if <b>SetupInstallFromInfSection</b> is called 
     *       with the optional <i>DeviceInfoSet</i> and <i>DeviceInfoData</i> set.
     * @param {Pointer<PSTR>} SourceRootPath Source root for file copies. An example would be A:\ or \\pegasus\win\install. If 
     *       <i>Flags</i> includes SPINST_FILES, and <i>SourceRootPath</i> is NULL, 
     *       the system provides a default root path.
     * @param {Integer} CopyFlags Optional parameter that must be specified if <i>Flags</i> includes SPINST_FILES. 
     *        Specifies flags to be passed to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupqueuecopysectiona">SetupQueueCopySection</a> function when files
     * @param {Pointer<PSP_FILE_CALLBACK_A>} MsgHandler Pointer to the callback routine. The callback routine must be in the format of 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a>. See 
     *        <a href="https://docs.microsoft.com/windows/desktop/SetupApi/notifications">Notifications</a> for more information.
     * 
     * This parameter is optional only if the <i>Flags</i> parameter does not include 
     *        SPINST_FILES, SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR, or SPINST_UNREGSVR.
     * 
     * <i>MsgHandler</i> must be set if <i>Flags</i> includes SPINST_FILES. In 
     *        this case, notification is sent to the callback routine when the file queue is committed with 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>.
     * 
     * <i>MsgHandler</i> must be set if <i>Flags</i> includes 
     *         SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR or SPINST_UNREGSVR. In this case a 
     *         <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-startregistration">SPFILENOTIFY_STARTREGISTRATION</a> 
     *         or 
     *         <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-endregistration">SPFILENOTIFY_ENDREGISTRATION</a> 
     *         is sent to the callback routine once each time a file is registered or unregistered using the 
     *         <b>RegisterDlls</b> INF directive on Windows2000.
     * @param {Pointer<Void>} Context Value to be passed to the callback function when the file queue built by this routine internally is 
     *       committed via 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>. The 
     *       <i>Context</i> parameter is optional only if the <i>Flags</i> parameter 
     *       does not include SPINST_FIlLES. This parameter must be specified if <i>Flags</i> includes 
     *       SPINST_FIlLES.
     * @param {Pointer} DeviceInfoSet Optional pointer to a handle to a device information set. For more information about 
     *       the Device Installer setup functions, see the DDK 
     *       <i>Programmer's Guide</i>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData Optional pointer to a pointer to the <b>SP_DEVINFO_DATA</b> 
     *       structure that provides a context to a specific element in the set specified by 
     *       <i>DeviceInfoSet.</i> For more information about the Device Installer setup functions, see 
     *       the DDK <i>Programmer's Guide</i>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallfrominfsectiona
     * @since windows5.1.2600
     */
    static SetupInstallFromInfSectionA(Owner, InfHandle, SectionName, Flags, RelativeKeyRoot, SourceRootPath, CopyFlags, MsgHandler, Context, DeviceInfoSet, DeviceInfoData) {
        SectionName := SectionName is String? StrPtr(SectionName) : SectionName
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFromInfSectionA", "ptr", Owner, "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "ptr", RelativeKeyRoot, "ptr", SourceRootPath, "uint", CopyFlags, "ptr", MsgHandler, "ptr", Context, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFromInfSection function carries out all the directives in an INF file Install section. (Unicode)
     * @remarks
     * If a UNC directory is specified as the target directory of a file copy operation, you must ensure it exists 
     *     before you call <b>SetupInstallFromInfSection</b>. The setup functions do not check for 
     *     the existence of and do not create UNC directories. If the target UNC directory does not exist, the file 
     *     installation will fail.
     * 
     * This function requires a Windows INF file. Some older INF file  formats may not be supported. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallFromInfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} Owner Optional pointer to the window handle to the window that owns any dialog boxes that are generated during 
     *       installation, such as for disk prompting or file copying. If <i>Owner</i> is not specified, 
     *       these dialog boxes become top-level windows.
     * @param {Pointer<Void>} InfHandle Handle to the INF file that contains the section to be processed.
     * @param {Pointer<PWSTR>} SectionName Name of the <b>Install</b> section in the INF file to process.
     * @param {Integer} Flags 
     * @param {Pointer<HKEY>} RelativeKeyRoot Optional parameter that must be specified if <i>Flags</i> includes SPINST_REGISTRY or 
     *       SPINST_INI2REG. Handle to a registry key to be used as the root when the INF file specifies HKR as the key. 
     *       Note that this parameter is ignored if <b>SetupInstallFromInfSection</b> is called 
     *       with the optional <i>DeviceInfoSet</i> and <i>DeviceInfoData</i> set.
     * @param {Pointer<PWSTR>} SourceRootPath Source root for file copies. An example would be A:\ or \\pegasus\win\install. If 
     *       <i>Flags</i> includes SPINST_FILES, and <i>SourceRootPath</i> is NULL, 
     *       the system provides a default root path.
     * @param {Integer} CopyFlags Optional parameter that must be specified if <i>Flags</i> includes SPINST_FILES. 
     *        Specifies flags to be passed to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupqueuecopysectiona">SetupQueueCopySection</a> function when files
     * @param {Pointer<PSP_FILE_CALLBACK_W>} MsgHandler Pointer to the callback routine. The callback routine must be in the format of 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nc-setupapi-psp_file_callback_a">FileCallback</a>. See 
     *        <a href="https://docs.microsoft.com/windows/desktop/SetupApi/notifications">Notifications</a> for more information.
     * 
     * This parameter is optional only if the <i>Flags</i> parameter does not include 
     *        SPINST_FILES, SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR, or SPINST_UNREGSVR.
     * 
     * <i>MsgHandler</i> must be set if <i>Flags</i> includes SPINST_FILES. In 
     *        this case, notification is sent to the callback routine when the file queue is committed with 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>.
     * 
     * <i>MsgHandler</i> must be set if <i>Flags</i> includes 
     *         SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR or SPINST_UNREGSVR. In this case a 
     *         <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-startregistration">SPFILENOTIFY_STARTREGISTRATION</a> 
     *         or 
     *         <a href="https://docs.microsoft.com/windows/desktop/SetupApi/spfilenotify-endregistration">SPFILENOTIFY_ENDREGISTRATION</a> 
     *         is sent to the callback routine once each time a file is registered or unregistered using the 
     *         <b>RegisterDlls</b> INF directive on Windows2000.
     * @param {Pointer<Void>} Context Value to be passed to the callback function when the file queue built by this routine internally is 
     *       committed via 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupcommitfilequeuea">SetupCommitFileQueue</a>. The 
     *       <i>Context</i> parameter is optional only if the <i>Flags</i> parameter 
     *       does not include SPINST_FIlLES. This parameter must be specified if <i>Flags</i> includes 
     *       SPINST_FIlLES.
     * @param {Pointer} DeviceInfoSet Optional pointer to a handle to a device information set. For more information about 
     *       the Device Installer setup functions, see the DDK 
     *       <i>Programmer's Guide</i>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData Optional pointer to a pointer to the <b>SP_DEVINFO_DATA</b> 
     *       structure that provides a context to a specific element in the set specified by 
     *       <i>DeviceInfoSet.</i> For more information about the Device Installer setup functions, see 
     *       the DDK <i>Programmer's Guide</i>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallfrominfsectionw
     * @since windows5.1.2600
     */
    static SetupInstallFromInfSectionW(Owner, InfHandle, SectionName, Flags, RelativeKeyRoot, SourceRootPath, CopyFlags, MsgHandler, Context, DeviceInfoSet, DeviceInfoData) {
        SectionName := SectionName is String? StrPtr(SectionName) : SectionName
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFromInfSectionW", "ptr", Owner, "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "ptr", RelativeKeyRoot, "ptr", SourceRootPath, "uint", CopyFlags, "ptr", MsgHandler, "ptr", Context, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFilesFromInfSection function queues all the files for an installation that are specified in the Copy Files, Delete Files, and Rename Files sections that are listed by an Install section. (ANSI)
     * @remarks
     * <b>SetupInstallFilesFromInfSection</b> can be called multiple times to queue the files that are specified in multiple INF sections. After the queue is committed successfully and the files are copied, renamed, and/or deleted, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinstallfrominfsectiona">SetupInstallFromInfSection</a> can be called to perform registry and INI installation operations.
     * 
     * If a UNC directory is specified as the target directory of a file installation, you must ensure that the UNC directory exists before you call 
     * <b>SetupInstallFilesFromInfSection</b>. The setup functions do not check for the existence of directories and do not create UNC directories. If the target UNC directory does not exist, the file installation fails.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallFilesFromInfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle The handle to an INF file that contains the section to be installed.
     * @param {Pointer<Void>} LayoutInfHandle An optional pointer to a handle to the INF file that contains the SourceDisksFiles and SourceDisksNames sections. 
     * 
     * If <i>LayoutInfHandle</i> is not specified, then the SourceDisksFiles and SourceDisksNames sections from <i>InfHandle</i> are used.
     * @param {Pointer<Void>} FileQueue The handle to the queue where installation operations are to be added.
     * @param {Pointer<PSTR>} SectionName The name of the Install section in  the <i>InfHandle</i> parameter that lists the Copy Files, Delete Files, and  Rename Files sections that contain the files to install. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {Pointer<PSTR>} SourceRootPath An optional pointer to a root path to the source files to copy, for example, A:\ or \\pegasus\win\install. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {Integer} CopyFlags An optional pointer to a set of flags that control the behavior of the file copy operation.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallfilesfrominfsectiona
     * @since windows5.1.2600
     */
    static SetupInstallFilesFromInfSectionA(InfHandle, LayoutInfHandle, FileQueue, SectionName, SourceRootPath, CopyFlags) {
        SectionName := SectionName is String? StrPtr(SectionName) : SectionName
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFilesFromInfSectionA", "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", FileQueue, "ptr", SectionName, "ptr", SourceRootPath, "uint", CopyFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallFilesFromInfSection function queues all the files for an installation that are specified in the Copy Files, Delete Files, and Rename Files sections that are listed by an Install section. (Unicode)
     * @remarks
     * <b>SetupInstallFilesFromInfSection</b> can be called multiple times to queue the files that are specified in multiple INF sections. After the queue is committed successfully and the files are copied, renamed, and/or deleted, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinstallfrominfsectiona">SetupInstallFromInfSection</a> can be called to perform registry and INI installation operations.
     * 
     * If a UNC directory is specified as the target directory of a file installation, you must ensure that the UNC directory exists before you call 
     * <b>SetupInstallFilesFromInfSection</b>. The setup functions do not check for the existence of directories and do not create UNC directories. If the target UNC directory does not exist, the file installation fails.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallFilesFromInfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle The handle to an INF file that contains the section to be installed.
     * @param {Pointer<Void>} LayoutInfHandle An optional pointer to a handle to the INF file that contains the SourceDisksFiles and SourceDisksNames sections. 
     * 
     * If <i>LayoutInfHandle</i> is not specified, then the SourceDisksFiles and SourceDisksNames sections from <i>InfHandle</i> are used.
     * @param {Pointer<Void>} FileQueue The handle to the queue where installation operations are to be added.
     * @param {Pointer<PWSTR>} SectionName The name of the Install section in  the <i>InfHandle</i> parameter that lists the Copy Files, Delete Files, and  Rename Files sections that contain the files to install. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {Pointer<PWSTR>} SourceRootPath An optional pointer to a root path to the source files to copy, for example, A:\ or \\pegasus\win\install. 
     * 
     * Use a <b>null</b>-terminated string.
     * @param {Integer} CopyFlags An optional pointer to a set of flags that control the behavior of the file copy operation.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallfilesfrominfsectionw
     * @since windows5.1.2600
     */
    static SetupInstallFilesFromInfSectionW(InfHandle, LayoutInfHandle, FileQueue, SectionName, SourceRootPath, CopyFlags) {
        SectionName := SectionName is String? StrPtr(SectionName) : SectionName
        SourceRootPath := SourceRootPath is String? StrPtr(SourceRootPath) : SourceRootPath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallFilesFromInfSectionW", "ptr", InfHandle, "ptr", LayoutInfHandle, "ptr", FileQueue, "ptr", SectionName, "ptr", SourceRootPath, "uint", CopyFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallServicesFromInfSection function performs service installation and deletion operations that are specified in the Service Install sections listed in the Service section of an INF file. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallServicesFromInfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <b>Service</b> section.
     * @param {Pointer<PSTR>} SectionName The name of the <b>Service</b> section to process. You should use a null-terminated 
     *       string.
     * @param {Integer} Flags The controls for the installation of each service in the specified section.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl>
     * <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: move the service tag to the front of its group order list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
     * <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt>
     * <dt>0x004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: delete the event log entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a id="spsvcinst_noclobber_displayname"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt>
     * <dt>0x008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the display name if one already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt>
     * <dt>0x010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the start type value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt>
     * <dt>0x020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the error control value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
     * <dt>0x040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the load order group if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt>
     * <dt>0x080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the dependencies list if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt>
     * <dt>0x100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl>
     * <dt><b>SPSVCINST_STOPSERVICE</b></dt>
     * <dt>0x200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: Stop the associated service specified in the entry before deleting the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a id="spsvcinst_clobber_security"></a><dl>
     * <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt>
     * <dt>0x400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Security settings the service are overwritten if the service already exists in the 
     *          system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2003 and WindowsXP.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a id="spsvcinst_startservice"></a><dl>
     * <dt><b>SPSVCINST_STARTSERVICE</b></dt>
     * <dt>0x800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Start the service after the service is installed. This flag cannot be used to start a 
     *          service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise, 
     *          this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control 
     *          Manager (SCM.)
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008 and WindowsVista.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a id="spsvcinst_noclobber_requiredprivileges"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Do not overwrite the given service's required privileges if the service already exists 
     *          in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008R2 and Windows7.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero. The function calls 
     *        <b>SetLastError</b> with ERROR_SUCCESS_REBOOT_REQUIRED if a reboot of the system is 
     *        required.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallservicesfrominfsectiona
     * @since windows5.1.2600
     */
    static SetupInstallServicesFromInfSectionA(InfHandle, SectionName, Flags) {
        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallServicesFromInfSectionA", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallServicesFromInfSection function performs service installation and deletion operations that are specified in the Service Install sections listed in the Service section of an INF file. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallServicesFromInfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <b>Service</b> section.
     * @param {Pointer<PWSTR>} SectionName The name of the <b>Service</b> section to process. You should use a null-terminated 
     *       string.
     * @param {Integer} Flags The controls for the installation of each service in the specified section.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl>
     * <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: move the service tag to the front of its group order list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
     * <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt>
     * <dt>0x004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: delete the event log entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a id="spsvcinst_noclobber_displayname"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt>
     * <dt>0x008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the display name if one already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt>
     * <dt>0x010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the start type value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt>
     * <dt>0x020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the error control value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
     * <dt>0x040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the load order group if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt>
     * <dt>0x080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: do not overwrite the dependencies list if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt>
     * <dt>0x100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl>
     * <dt><b>SPSVCINST_STOPSERVICE</b></dt>
     * <dt>0x200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: Stop the associated service specified in the entry before deleting the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a id="spsvcinst_clobber_security"></a><dl>
     * <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt>
     * <dt>0x400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Security settings the service are overwritten if the service already exists in the 
     *          system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2003 and WindowsXP.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a id="spsvcinst_startservice"></a><dl>
     * <dt><b>SPSVCINST_STARTSERVICE</b></dt>
     * <dt>0x800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Start the service after the service is installed. This flag cannot be used to start a 
     *          service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise, 
     *          this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control 
     *          Manager (SCM.)
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008 and WindowsVista.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a id="spsvcinst_noclobber_requiredprivileges"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Do not overwrite the given service's required privileges if the service already exists 
     *          in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008R2 and Windows7.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero. The function calls 
     *        <b>SetLastError</b> with ERROR_SUCCESS_REBOOT_REQUIRED if a reboot of the system is 
     *        required.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallservicesfrominfsectionw
     * @since windows5.1.2600
     */
    static SetupInstallServicesFromInfSectionW(InfHandle, SectionName, Flags) {
        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallServicesFromInfSectionW", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallServicesFromInfSectionEx function performs service installation and deletion operations that are specified in the Service Install sections listed in the Service section of an INF file. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallServicesFromInfSectionEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <b>Service</b> section.
     * @param {Pointer<PSTR>} SectionName The name of the <b>Service</b> section to process. You should use a null-terminated string.
     * @param {Integer} Flags The controls for the installation. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl>
     * <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Move the service tag to the front of its group order list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_ASSOCSERVICE"></a><a id="spsvcinst_assocservice"></a><dl>
     * <dt><b>SPSVCINST_ASSOCSERVICE</b></dt>
     * <dt>0x002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
     * <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt>
     * <dt>0x004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the event log entry for a specified service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a id="spsvcinst_noclobber_displayname"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt>
     * <dt>0x008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the display name if one already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt>
     * <dt>0x010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the start type value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt>
     * <dt>0x020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the error control value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
     * <dt>0x040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the load order group if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt>
     * <dt>0x080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the dependencies list if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt>
     * <dt>0x100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl>
     * <dt><b>SPSVCINST_STOPSERVICE</b></dt>
     * <dt>0x200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: Stop the associated service specified in the entry before deleting the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a id="spsvcinst_clobber_security"></a><dl>
     * <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt>
     * <dt>0x400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Security settings the service are overwritten if the service already exists in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2003 and WindowsXP.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a id="spsvcinst_startservice"></a><dl>
     * <dt><b>SPSVCINST_STARTSERVICE</b></dt>
     * <dt>0x800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Start the service after the service is installed. This flag cannot be used to start a service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise, this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control Manager (SCM.)
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008 and WindowsVista.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a id="spsvcinst_noclobber_requiredprivileges"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Do not overwrite the given service's required privileges if the service already exists in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008R2 and Windows7.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} DeviceInfoSet An optional pointer to a handle to a device information set. For more information, see the DDK <i>Programmer's Guide</i>. (This resource may not be available in some languages 
     * 
     * and countries.)
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData An optional pointer to  the <b>SP_DEVINFO_DATA</b> structure that provides a context to a specific element in the set that  <i>DeviceInfoSet</i> specifies. For more information, see the DDK <i>Programmer's Guide</i>. (This resource may not be available in some languages 
     * 
     * and countries.)
     * @returns {Integer} If the function succeeds, the return value is nonzero.  The function calls <b>SetLastError</b> with ERROR_SUCCESS_REBOOT_REQUIRED  if a reboot of the system is required.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallservicesfrominfsectionexa
     * @since windows5.1.2600
     */
    static SetupInstallServicesFromInfSectionExA(InfHandle, SectionName, Flags, DeviceInfoSet, DeviceInfoData) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallServicesFromInfSectionExA", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupInstallServicesFromInfSectionEx function performs service installation and deletion operations that are specified in the Service Install sections listed in the Service section of an INF file. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupInstallServicesFromInfSectionEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <b>Service</b> section.
     * @param {Pointer<PWSTR>} SectionName The name of the <b>Service</b> section to process. You should use a null-terminated string.
     * @param {Integer} Flags The controls for the installation. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl>
     * <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
     * <dt>0x001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Move the service tag to the front of its group order list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_ASSOCSERVICE"></a><a id="spsvcinst_assocservice"></a><dl>
     * <dt><b>SPSVCINST_ASSOCSERVICE</b></dt>
     * <dt>0x002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
     * <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt>
     * <dt>0x004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the event log entry for a specified service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a id="spsvcinst_noclobber_displayname"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt>
     * <dt>0x008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the display name if one already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt>
     * <dt>0x010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the start type value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt>
     * <dt>0x020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the error control value if the service already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
     * <dt>0x040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the load order group if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt>
     * <dt>0x080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not overwrite the dependencies list if it already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt>
     * <dt>0x100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: mark this service as the function driver for the device being installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl>
     * <dt><b>SPSVCINST_STOPSERVICE</b></dt>
     * <dt>0x200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * DelService section: Stop the associated service specified in the entry before deleting the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a id="spsvcinst_clobber_security"></a><dl>
     * <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt>
     * <dt>0x400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Security settings the service are overwritten if the service already exists in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2003 and WindowsXP.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a id="spsvcinst_startservice"></a><dl>
     * <dt><b>SPSVCINST_STARTSERVICE</b></dt>
     * <dt>0x800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Start the service after the service is installed. This flag cannot be used to start a service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise, this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control Manager (SCM.)
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008 and WindowsVista.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a id="spsvcinst_noclobber_requiredprivileges"></a><dl>
     * <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * AddService section: Do not overwrite the given service's required privileges if the service already exists in the system.
     * 
     * <div class="alert"><b>Note</b>Available starting with Windows Server2008R2 and Windows7.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} DeviceInfoSet An optional pointer to a handle to a device information set. For more information, see the DDK <i>Programmer's Guide</i>. (This resource may not be available in some languages 
     * 
     * and countries.)
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData An optional pointer to  the <b>SP_DEVINFO_DATA</b> structure that provides a context to a specific element in the set that  <i>DeviceInfoSet</i> specifies. For more information, see the DDK <i>Programmer's Guide</i>. (This resource may not be available in some languages 
     * 
     * and countries.)
     * @returns {Integer} If the function succeeds, the return value is nonzero.  The function calls <b>SetLastError</b> with ERROR_SUCCESS_REBOOT_REQUIRED  if a reboot of the system is required.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinstallservicesfrominfsectionexw
     * @since windows5.1.2600
     */
    static SetupInstallServicesFromInfSectionExW(InfHandle, SectionName, Flags, DeviceInfoSet, DeviceInfoData) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupInstallServicesFromInfSectionExW", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * InstallHinfSection is an entry-point function exported by Setupapi.dll that you can use to execute a section of an .inf file. InstallHinfSection can be invoked by calling the Rundll32.exe utility as described in the Remarks section. (ANSI)
     * @remarks
     * Note that three exports exist: 
     * <b>InstallHinfSection</b> (for RunDll32), <b>InstallHinfSectionA</b>, and <b>InstallHinfSectionW</b>. 
     * 
     * To run an <b>Install</b> section of a specified .inf file, you can invoke 
     * <b>InstallHinfSection</b> with the Rundll32.exe by using the following syntax.
     * 
     * <b>RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection </b><i>&lt;section&gt;</i><i>&lt;mode&gt;</i><i>&lt;path&gt;</i>
     * 
     * This passes "<i>&lt;section&gt;</i><i>&lt;mode&gt;</i><i>&lt;path&gt;</i>" to <i>CmdLineBuffer</i>.
     * 
     * Alternatively, your program may call 
     * <b>InstallHinfSection</b>, <b>InstallHinfSectionA</b>, or <b>InstallHinfSectionW</b> directly, setting the <i>CmdLineBuffer</i> parameter to the following.
     * 
     * 
     * ``` syntax
     * "<section> <mode> <path>"
     * ```
     * 
     * Where <i>path</i> is the full path to the .inf file, <i>mode</i> is the reboot mode parameter, and <i>section</i> is any <b>Install</b> section in the .inf file. The comma separator between SETUPAPI.DLL and 
     * <b>InstallHinfSection</b> on the command line is required. Note that there cannot be any white space on the command line between the comma and SETUPAPI.DLL or 
     * <b>InstallHinfSection</b>.
     * 
     * It is recommended that you specify the full path to the .inf file as <i>path</i>.
     * 
     * You may specify any <b>Install</b> section in the .inf file as <i>section</i>. No spaces are allowed.
     * 
     * You should use a combination of the following values for <i>mode</i>. You must include 128 to set the default path of the installation to the location of the INF, otherwise a system-provided INF is assumed. Add values to specify rebooting. Note that only the values 128 or 132 are recommended, other values may cause the computer to reboot unnecessarily or not reboot when it required.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>System provided INF.</td>
     * </tr>
     * <tr>
     * <td>128</td>
     * <td>Set the default path of the installation to the location of the INF. This is the typical setting.</td>
     * </tr>
     * <tr>
     * <td>+0</td>
     * <td>Never reboot the computer.</td>
     * </tr>
     * <tr>
     * <td>+1</td>
     * <td>Reboot the computer in all cases.</td>
     * </tr>
     * <tr>
     * <td>+2</td>
     * <td>Always ask the users if they want to reboot.</td>
     * </tr>
     * <tr>
     * <td>+3</td>
     * <td>Reboot the computer if necessary without asking user for permission.</td>
     * </tr>
     * <tr>
     * <td>+4</td>
     * <td>If a reboot of the computer is necessary, ask the user for permission before rebooting.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * <div></div>
     * 
     * 
     * For example, the following command line runs the DefaultInstall section of the Shell.inf file. If Setup determines a reboot is required, the user is will be prompted with a "Reboot the computer, Yes/No" dialog box.
     * 
     * <b>RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultInstall 132 C:\WINDOWS\INF\SHELL.INF</b>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines InstallHinfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} Window The parent window handle. Typically <i>hwnd</i> is Null.
     * @param {Pointer<HINSTANCE>} ModuleHandle Reserved and should be Null.
     * @param {Pointer<PSTR>} CommandLine Pointer to buffer containing the command line. You should use a null-terminated string.
     * @param {Integer} ShowCommand Reserved and should be zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-installhinfsectiona
     * @since windows5.1.2600
     */
    static InstallHinfSectionA(Window, ModuleHandle, CommandLine, ShowCommand) {
        CommandLine := CommandLine is String? StrPtr(CommandLine) : CommandLine

        DllCall("SETUPAPI.dll\InstallHinfSectionA", "ptr", Window, "ptr", ModuleHandle, "ptr", CommandLine, "int", ShowCommand)
    }

    /**
     * InstallHinfSection is an entry-point function exported by Setupapi.dll that you can use to execute a section of an .inf file. InstallHinfSection can be invoked by calling the Rundll32.exe utility as described in the Remarks section. (Unicode)
     * @remarks
     * Note that three exports exist: 
     * <b>InstallHinfSection</b> (for RunDll32), <b>InstallHinfSectionA</b>, and <b>InstallHinfSectionW</b>. 
     * 
     * To run an <b>Install</b> section of a specified .inf file, you can invoke 
     * <b>InstallHinfSection</b> with the Rundll32.exe by using the following syntax.
     * 
     * <b>RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection </b><i>&lt;section&gt;</i><i>&lt;mode&gt;</i><i>&lt;path&gt;</i>
     * 
     * This passes "<i>&lt;section&gt;</i><i>&lt;mode&gt;</i><i>&lt;path&gt;</i>" to <i>CmdLineBuffer</i>.
     * 
     * Alternatively, your program may call 
     * <b>InstallHinfSection</b>, <b>InstallHinfSectionA</b>, or <b>InstallHinfSectionW</b> directly, setting the <i>CmdLineBuffer</i> parameter to the following.
     * 
     * 
     * ``` syntax
     * "<section> <mode> <path>"
     * ```
     * 
     * Where <i>path</i> is the full path to the .inf file, <i>mode</i> is the reboot mode parameter, and <i>section</i> is any <b>Install</b> section in the .inf file. The comma separator between SETUPAPI.DLL and 
     * <b>InstallHinfSection</b> on the command line is required. Note that there cannot be any white space on the command line between the comma and SETUPAPI.DLL or 
     * <b>InstallHinfSection</b>.
     * 
     * It is recommended that you specify the full path to the .inf file as <i>path</i>.
     * 
     * You may specify any <b>Install</b> section in the .inf file as <i>section</i>. No spaces are allowed.
     * 
     * You should use a combination of the following values for <i>mode</i>. You must include 128 to set the default path of the installation to the location of the INF, otherwise a system-provided INF is assumed. Add values to specify rebooting. Note that only the values 128 or 132 are recommended, other values may cause the computer to reboot unnecessarily or not reboot when it required.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>System provided INF.</td>
     * </tr>
     * <tr>
     * <td>128</td>
     * <td>Set the default path of the installation to the location of the INF. This is the typical setting.</td>
     * </tr>
     * <tr>
     * <td>+0</td>
     * <td>Never reboot the computer.</td>
     * </tr>
     * <tr>
     * <td>+1</td>
     * <td>Reboot the computer in all cases.</td>
     * </tr>
     * <tr>
     * <td>+2</td>
     * <td>Always ask the users if they want to reboot.</td>
     * </tr>
     * <tr>
     * <td>+3</td>
     * <td>Reboot the computer if necessary without asking user for permission.</td>
     * </tr>
     * <tr>
     * <td>+4</td>
     * <td>If a reboot of the computer is necessary, ask the user for permission before rebooting.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * <div></div>
     * 
     * 
     * For example, the following command line runs the DefaultInstall section of the Shell.inf file. If Setup determines a reboot is required, the user is will be prompted with a "Reboot the computer, Yes/No" dialog box.
     * 
     * <b>RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultInstall 132 C:\WINDOWS\INF\SHELL.INF</b>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines InstallHinfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} Window The parent window handle. Typically <i>hwnd</i> is Null.
     * @param {Pointer<HINSTANCE>} ModuleHandle Reserved and should be Null.
     * @param {Pointer<PWSTR>} CommandLine Pointer to buffer containing the command line. You should use a null-terminated string.
     * @param {Integer} ShowCommand Reserved and should be zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-installhinfsectionw
     * @since windows5.1.2600
     */
    static InstallHinfSectionW(Window, ModuleHandle, CommandLine, ShowCommand) {
        CommandLine := CommandLine is String? StrPtr(CommandLine) : CommandLine

        DllCall("SETUPAPI.dll\InstallHinfSectionW", "ptr", Window, "ptr", ModuleHandle, "ptr", CommandLine, "int", ShowCommand)
    }

    /**
     * The SetupInitializeFileLog function initializes a file to record installation operations and outcomes. This can be the system log, where the system tracks the files installed as part of Windows, or any other file. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupInitializeFileLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} LogFileName Optional pointer to the file name of the file to use as the log file. You should use a <b>null</b>-terminated string. The <i>LogFileName</i> parameter must be specified if <i>Flags</i> does not include SPFILELOG_SYSTEMLOG. The <i>LogFileName</i> parameter must not be specified if <i>Flags</i> includes SPFILELOG_SYSTEMLOG. This parameter can be <b>NULL</b>.
     * @param {Integer} Flags 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinitializefileloga
     * @since windows5.1.2600
     */
    static SetupInitializeFileLogA(LogFileName, Flags) {
        LogFileName := LogFileName is String? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupInitializeFileLogA", "ptr", LogFileName, "uint", Flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupInitializeFileLog function initializes a file to record installation operations and outcomes. This can be the system log, where the system tracks the files installed as part of Windows, or any other file. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupInitializeFileLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} LogFileName Optional pointer to the file name of the file to use as the log file. You should use a <b>null</b>-terminated string. The <i>LogFileName</i> parameter must be specified if <i>Flags</i> does not include SPFILELOG_SYSTEMLOG. The <i>LogFileName</i> parameter must not be specified if <i>Flags</i> includes SPFILELOG_SYSTEMLOG. This parameter can be <b>NULL</b>.
     * @param {Integer} Flags 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupinitializefilelogw
     * @since windows5.1.2600
     */
    static SetupInitializeFileLogW(LogFileName, Flags) {
        LogFileName := LogFileName is String? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        DllCall("SETUPAPI.dll\SetupInitializeFileLogW", "ptr", LogFileName, "uint", Flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetupTerminateFileLog function releases resources associated with a file log.
     * @param {Pointer<Void>} FileLogHandle Handle to the log file as returned by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupterminatefilelog
     * @since windows5.1.2600
     */
    static SetupTerminateFileLog(FileLogHandle) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupTerminateFileLog", "ptr", FileLogHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupLogFile function adds an entry to the log file. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupLogFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>. The caller must not have passed SPFILELOG_QUERYONLY when the log file was initialized.
     * @param {Pointer<PSTR>} LogSectionName Optional pointer to the name for a logical grouping of names within the log file. You should use a <b>null</b>-terminated string.  Required if SPFILELOG_SYSTEMLOG was not passed when the file log was initialized. Otherwise, this parameter can be <b>NULL</b>.
     * @param {Pointer<PSTR>} SourceFilename Name of the file as it exists on the source media from which it was installed. This name should be in whatever format is meaningful to the caller. You should use a <b>null</b>-terminated string.
     * @param {Pointer<PSTR>} TargetFilename Name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller. You should use a <b>null</b>-terminated string.
     * @param {Integer} Checksum Optional pointer to a  checksum value. Required for the system log.
     * @param {Pointer<PSTR>} DiskTagfile Optional pointer to the tagfile for the media from which the file was installed. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. Ignored for the system log if SPFILELOG_OEMFILE is not specified. Required for the system log if SPFILELOG_OEMFILE is specified. Otherwise, this parameter can be <b>NULL</b>.
     * @param {Pointer<PSTR>} DiskDescription Optional pointer to the human-readable description of the media from which the file was installed. You should use a <b>null</b>-terminated string.  Ignored for the system log if SPFILELOG_OEMFILE is not specified in the <i>Flags</i> parameter.  Required for the system log if SPFILELOG_OEMFILE is specified in the Flags parameter. Otherwise, this parameter can be <b>NULL</b>.
     * @param {Pointer<PSTR>} OtherInfo Optional pointer to additional information to be associated with the file. You should use a <b>null</b>-terminated string.  This parameter can be <b>NULL</b>.
     * @param {Integer} Flags This parameter can be SPFILELOG_OEMFILE, which is meaningful only for the system log and indicates that the file is not supplied by Microsoft. This parameter can be used to convert an existing file's entry, such as when an OEM overwrites a Microsoft-supplied system file.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuplogfilea
     * @since windows5.1.2600
     */
    static SetupLogFileA(FileLogHandle, LogSectionName, SourceFilename, TargetFilename, Checksum, DiskTagfile, DiskDescription, OtherInfo, Flags) {
        LogSectionName := LogSectionName is String? StrPtr(LogSectionName) : LogSectionName
        SourceFilename := SourceFilename is String? StrPtr(SourceFilename) : SourceFilename
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename
        DiskTagfile := DiskTagfile is String? StrPtr(DiskTagfile) : DiskTagfile
        DiskDescription := DiskDescription is String? StrPtr(DiskDescription) : DiskDescription
        OtherInfo := OtherInfo is String? StrPtr(OtherInfo) : OtherInfo

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupLogFileA", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", SourceFilename, "ptr", TargetFilename, "uint", Checksum, "ptr", DiskTagfile, "ptr", DiskDescription, "ptr", OtherInfo, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupLogFile function adds an entry to the log file. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupLogFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>. The caller must not have passed SPFILELOG_QUERYONLY when the log file was initialized.
     * @param {Pointer<PWSTR>} LogSectionName Optional pointer to the name for a logical grouping of names within the log file. You should use a <b>null</b>-terminated string.  Required if SPFILELOG_SYSTEMLOG was not passed when the file log was initialized. Otherwise, this parameter can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} SourceFilename Name of the file as it exists on the source media from which it was installed. This name should be in whatever format is meaningful to the caller. You should use a <b>null</b>-terminated string.
     * @param {Pointer<PWSTR>} TargetFilename Name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller. You should use a <b>null</b>-terminated string.
     * @param {Integer} Checksum Optional pointer to a  checksum value. Required for the system log.
     * @param {Pointer<PWSTR>} DiskTagfile Optional pointer to the tagfile for the media from which the file was installed. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. Ignored for the system log if SPFILELOG_OEMFILE is not specified. Required for the system log if SPFILELOG_OEMFILE is specified. Otherwise, this parameter can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} DiskDescription Optional pointer to the human-readable description of the media from which the file was installed. You should use a <b>null</b>-terminated string.  Ignored for the system log if SPFILELOG_OEMFILE is not specified in the <i>Flags</i> parameter.  Required for the system log if SPFILELOG_OEMFILE is specified in the Flags parameter. Otherwise, this parameter can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} OtherInfo Optional pointer to additional information to be associated with the file. You should use a <b>null</b>-terminated string.  This parameter can be <b>NULL</b>.
     * @param {Integer} Flags This parameter can be SPFILELOG_OEMFILE, which is meaningful only for the system log and indicates that the file is not supplied by Microsoft. This parameter can be used to convert an existing file's entry, such as when an OEM overwrites a Microsoft-supplied system file.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuplogfilew
     * @since windows5.1.2600
     */
    static SetupLogFileW(FileLogHandle, LogSectionName, SourceFilename, TargetFilename, Checksum, DiskTagfile, DiskDescription, OtherInfo, Flags) {
        LogSectionName := LogSectionName is String? StrPtr(LogSectionName) : LogSectionName
        SourceFilename := SourceFilename is String? StrPtr(SourceFilename) : SourceFilename
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename
        DiskTagfile := DiskTagfile is String? StrPtr(DiskTagfile) : DiskTagfile
        DiskDescription := DiskDescription is String? StrPtr(DiskDescription) : DiskDescription
        OtherInfo := OtherInfo is String? StrPtr(OtherInfo) : OtherInfo

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupLogFileW", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", SourceFilename, "ptr", TargetFilename, "uint", Checksum, "ptr", DiskTagfile, "ptr", DiskDescription, "ptr", OtherInfo, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFileLogEntry function removes an entry or section from a file log. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveFileLogEntry as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>. The caller must not have passed SPFILELOG_QUERYONLY when the log file was initialized.
     * @param {Pointer<PSTR>} LogSectionName Pointer to a <b>null</b>-terminated string that specifies the name for a logical grouping of names within the log file. Required for non-system logs. Otherwise, <i>LogSectionName</i> may be <b>NULL</b>.
     * @param {Pointer<PSTR>} TargetFilename Pointer to a <b>null</b>-terminated string that specifies the name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller. If <b>NULL</b>, the section specified by <i>LogSectionName</i> is removed. The main section cannot be removed.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremovefilelogentrya
     * @since windows5.1.2600
     */
    static SetupRemoveFileLogEntryA(FileLogHandle, LogSectionName, TargetFilename) {
        LogSectionName := LogSectionName is String? StrPtr(LogSectionName) : LogSectionName
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFileLogEntryA", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", TargetFilename, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupRemoveFileLogEntry function removes an entry or section from a file log. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupRemoveFileLogEntry as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>. The caller must not have passed SPFILELOG_QUERYONLY when the log file was initialized.
     * @param {Pointer<PWSTR>} LogSectionName Pointer to a <b>null</b>-terminated string that specifies the name for a logical grouping of names within the log file. Required for non-system logs. Otherwise, <i>LogSectionName</i> may be <b>NULL</b>.
     * @param {Pointer<PWSTR>} TargetFilename Pointer to a <b>null</b>-terminated string that specifies the name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller. If <b>NULL</b>, the section specified by <i>LogSectionName</i> is removed. The main section cannot be removed.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupremovefilelogentryw
     * @since windows5.1.2600
     */
    static SetupRemoveFileLogEntryW(FileLogHandle, LogSectionName, TargetFilename) {
        LogSectionName := LogSectionName is String? StrPtr(LogSectionName) : LogSectionName
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupRemoveFileLogEntryW", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", TargetFilename, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryFileLog function returns information from a setup file log. (ANSI)
     * @remarks
     * If this function is called with a <i>DataOut</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the value of <i>DesiredInfo</i> is greater than <b>SetupFileLogOtherInfo</b> the function will fail, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_PARAMETER.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryFileLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>.
     * @param {Pointer<PSTR>} LogSectionName Optional pointer to the section name for the log file in a format that is meaningful to the caller. You should use a <b>null</b>-terminated string. Required for non-system logs. If no <i>LogSectionName</i> is specified for a system log, a default is supplied.
     * @param {Pointer<PSTR>} TargetFilename Name of the file for which log information is desired. You should use a <b>null</b>-terminated string.
     * @param {Integer} DesiredInfo Indicates what information should be returned to the <i>DataOut</i> buffer. This parameter can be one of the following enumerated values. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogSourceFile_name"></a><a id="setupfilelogsourcefile_name"></a><a id="SETUPFILELOGSOURCEFILE_NAME"></a><dl>
     * <dt><b>SetupFileLogSourceFile name</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Name of the source file as it exists on the source media
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogChecksum"></a><a id="setupfilelogchecksum"></a><a id="SETUPFILELOGCHECKSUM"></a><dl>
     * <dt><b>SetupFileLogChecksum</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A  checksum value used by the system log
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogDiskTagfile"></a><a id="setupfilelogdisktagfile"></a><a id="SETUPFILELOGDISKTAGFILE"></a><dl>
     * <dt><b>SetupFileLogDiskTagfile</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Name of the tag file of the media source containing the source file
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogDiskDescription"></a><a id="setupfilelogdiskdescription"></a><a id="SETUPFILELOGDISKDESCRIPTION"></a><dl>
     * <dt><b>SetupFileLogDiskDescription</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The human-readable description of the media where the source file resides
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogOtherInfo"></a><a id="setupfilelogotherinfo"></a><a id="SETUPFILELOGOTHERINFO"></a><dl>
     * <dt><b>SetupFileLogOtherInfo</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Additional information associated with the logged file
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the value of <i>DesiredInfo</i> is greater than <b>SetupFileLogOtherInfo</b> the function will fail, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_PARAMETER.
     * @param {Pointer<PSTR>} DataOut Optional pointer to a buffer in which this function returns the requested information for the file. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. Not all information is provided for every file. An error is not returned if an empty entry for the file exists in the log. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the <i>DataOut</i> buffer,  in characters. This includes the <b>null</b> terminator. If the buffer is too small and <i>DataOut</i> is specified, data is not stored in the buffer and the function returns zero. If <i>DataOut</i> is not specified, the <i>ReturnBufferSize</i> parameter is ignored.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size of <i>DataOut</i>, in characters. This number includes the <b>null</b> terminator.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryfileloga
     * @since windows5.1.2600
     */
    static SetupQueryFileLogA(FileLogHandle, LogSectionName, TargetFilename, DesiredInfo, DataOut, ReturnBufferSize, RequiredSize) {
        LogSectionName := LogSectionName is String? StrPtr(LogSectionName) : LogSectionName
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename
        DataOut := DataOut is String? StrPtr(DataOut) : DataOut

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryFileLogA", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", TargetFilename, "int", DesiredInfo, "ptr", DataOut, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupQueryFileLog function returns information from a setup file log. (Unicode)
     * @remarks
     * If this function is called with a <i>DataOut</i> of <b>NULL</b> and a <i>ReturnBufferSize</i> of zero, the function puts the buffer size needed to hold the specified data into the variable pointed to by <i>RequiredSize</i>. If the function succeeds in this, the return value is a nonzero value. Otherwise, the return value is zero and extended error information can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the value of <i>DesiredInfo</i> is greater than <b>SetupFileLogOtherInfo</b> the function will fail, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_PARAMETER.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupQueryFileLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} FileLogHandle Handle to the file log as returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupinitializefileloga">SetupInitializeFileLog</a>.
     * @param {Pointer<PWSTR>} LogSectionName Optional pointer to the section name for the log file in a format that is meaningful to the caller. You should use a <b>null</b>-terminated string. Required for non-system logs. If no <i>LogSectionName</i> is specified for a system log, a default is supplied.
     * @param {Pointer<PWSTR>} TargetFilename Name of the file for which log information is desired. You should use a <b>null</b>-terminated string.
     * @param {Integer} DesiredInfo Indicates what information should be returned to the <i>DataOut</i> buffer. This parameter can be one of the following enumerated values. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogSourceFile_name"></a><a id="setupfilelogsourcefile_name"></a><a id="SETUPFILELOGSOURCEFILE_NAME"></a><dl>
     * <dt><b>SetupFileLogSourceFile name</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Name of the source file as it exists on the source media
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogChecksum"></a><a id="setupfilelogchecksum"></a><a id="SETUPFILELOGCHECKSUM"></a><dl>
     * <dt><b>SetupFileLogChecksum</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A  checksum value used by the system log
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogDiskTagfile"></a><a id="setupfilelogdisktagfile"></a><a id="SETUPFILELOGDISKTAGFILE"></a><dl>
     * <dt><b>SetupFileLogDiskTagfile</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Name of the tag file of the media source containing the source file
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogDiskDescription"></a><a id="setupfilelogdiskdescription"></a><a id="SETUPFILELOGDISKDESCRIPTION"></a><dl>
     * <dt><b>SetupFileLogDiskDescription</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The human-readable description of the media where the source file resides
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SetupFileLogOtherInfo"></a><a id="setupfilelogotherinfo"></a><a id="SETUPFILELOGOTHERINFO"></a><dl>
     * <dt><b>SetupFileLogOtherInfo</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Additional information associated with the logged file
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the value of <i>DesiredInfo</i> is greater than <b>SetupFileLogOtherInfo</b> the function will fail, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_PARAMETER.
     * @param {Pointer<PWSTR>} DataOut Optional pointer to a buffer in which this function returns the requested information for the file. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this technique, you can avoid errors due to an insufficient buffer size. Not all information is provided for every file. An error is not returned if an empty entry for the file exists in the log. This parameter can be <b>NULL</b>.
     * @param {Integer} ReturnBufferSize Size of the <i>DataOut</i> buffer,  in characters. This includes the <b>null</b> terminator. If the buffer is too small and <i>DataOut</i> is specified, data is not stored in the buffer and the function returns zero. If <i>DataOut</i> is not specified, the <i>ReturnBufferSize</i> parameter is ignored.
     * @param {Pointer<UInt32>} RequiredSize Optional pointer to a variable that receives the required size of <i>DataOut</i>, in characters. This number includes the <b>null</b> terminator.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupqueryfilelogw
     * @since windows5.1.2600
     */
    static SetupQueryFileLogW(FileLogHandle, LogSectionName, TargetFilename, DesiredInfo, DataOut, ReturnBufferSize, RequiredSize) {
        LogSectionName := LogSectionName is String? StrPtr(LogSectionName) : LogSectionName
        TargetFilename := TargetFilename is String? StrPtr(TargetFilename) : TargetFilename
        DataOut := DataOut is String? StrPtr(DataOut) : DataOut

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupQueryFileLogW", "ptr", FileLogHandle, "ptr", LogSectionName, "ptr", TargetFilename, "int", DesiredInfo, "ptr", DataOut, "uint", ReturnBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupOpenLog function opens the log files.
     * @remarks
     * The log files are located in the Windows directory, and the file names are Setupact.log and Setuperr.log.
     * @param {Integer} Erase Must be FALSE.
     * @returns {Integer} <b>TRUE</b> if the log file can be opened. <b>FALSE</b> if an error occurs. To get the  error code, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupopenlog
     * @since windows5.1.2600
     */
    static SetupOpenLog(Erase) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupOpenLog", "int", Erase, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupLogError function writes an error message to a log file. (ANSI)
     * @remarks
     * <ul>
     * <li>The action log is intended for recording all modifications made to the system during installation of Windows.</li>
     * <li>The error log is intended for errors during installation of Windows only.</li>
     * <li>The <i>MessageString</i> parameter may be formatted further by Setup (though it does no additional processing now).</li>
     * <li>The error log will be presented to the user at the end of system  setup.</li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupLogError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} MessageString Pointer to the string that should be saved to Setup's log. The message must end with a return-linefeed combination (\r\n). You should use a null-terminated string. The null-terminated string should not exceed the size of the destination buffer. The message is always saved to the action log, setupact.log. If <i>Severity</i> is <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>, Setup also saves the message to the error log, setuperr.log. Both logs are stored in the Windows directory.
     * @param {Integer} Severity Severity of the message, one of the following: <b>LogSevInformation</b>, <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuplogerrora
     * @since windows5.1.2600
     */
    static SetupLogErrorA(MessageString, Severity) {
        MessageString := MessageString is String? StrPtr(MessageString) : MessageString

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupLogErrorA", "ptr", MessageString, "uint", Severity, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupLogError function writes an error message to a log file. (Unicode)
     * @remarks
     * <ul>
     * <li>The action log is intended for recording all modifications made to the system during installation of Windows.</li>
     * <li>The error log is intended for errors during installation of Windows only.</li>
     * <li>The <i>MessageString</i> parameter may be formatted further by Setup (though it does no additional processing now).</li>
     * <li>The error log will be presented to the user at the end of system  setup.</li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupLogError as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} MessageString Pointer to the string that should be saved to Setup's log. The message must end with a return-linefeed combination (\r\n). You should use a null-terminated string. The null-terminated string should not exceed the size of the destination buffer. The message is always saved to the action log, setupact.log. If <i>Severity</i> is <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>, Setup also saves the message to the error log, setuperr.log. Both logs are stored in the Windows directory.
     * @param {Integer} Severity Severity of the message, one of the following: <b>LogSevInformation</b>, <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setuplogerrorw
     * @since windows5.1.2600
     */
    static SetupLogErrorW(MessageString, Severity) {
        MessageString := MessageString is String? StrPtr(MessageString) : MessageString

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupLogErrorW", "ptr", MessageString, "uint", Severity, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupCloseLog function closes the log files.
     * @remarks
     * The log files are located in the Windows directory, and the file names are Setupact.log and Setuperr.log.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupcloselog
     * @since windows5.1.2600
     */
    static SetupCloseLog() {
        DllCall("SETUPAPI.dll\SetupCloseLog")
    }

    /**
     * The SetupGetThreadLogToken function retrieves the log token for the thread from which this function was called.
     * @remarks
     * To set a log token for a thread, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupsetthreadlogtoken">SetupSetThreadLogToken</a>. 
     * 
     * For more information about log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">Log Tokens</a>.
     * 
     * For more information about using log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-and-getting-a-log-token-for-a-thread">Setting and Getting a Log Token for a Thread</a>.
     * @returns {Integer} <b>SetupGetThreadLogToken</b> returns the log token for the thread from which the function was called. If a log token is not set for the thread, <b>SetupGetThreadLogToken</b> returns the system-defined log token LOGTOKEN_UNSPECIFIED.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetthreadlogtoken
     * @since windows6.0.6000
     */
    static SetupGetThreadLogToken() {
        result := DllCall("SETUPAPI.dll\SetupGetThreadLogToken", "uint")
        return result
    }

    /**
     * The SetupSetThreadLogToken function sets the log context, as represented by a log token, for the thread from which this function was called.
     * @remarks
     * <b>SetupSetThreadLogToken</b> establishes a log context for the thread from which the function was called. The log context is represented by a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a>, which can be retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>. 
     * 
     * For more information about log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">Log Tokens</a>.
     * 
     * For more information about using log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-and-getting-a-log-token-for-a-thread">Setting and Getting a Log Token for a Thread</a>.
     * @param {Integer} LogToken A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a> that is either a system-defined log token or was returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetthreadlogtoken
     * @since windows6.0.6000
     */
    static SetupSetThreadLogToken(LogToken) {
        DllCall("SETUPAPI.dll\SetupSetThreadLogToken", "uint", LogToken)
    }

    /**
     * The SetupWriteTextLog function writes a log entry in a SetupAPI text log.
     * @remarks
     * If the value of <i>LogToken</i> was returned by a call to <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a> and the corresponding text log section can be found, <b>SetupWriteTextLog</b> writes the log entry in that text log section. If <b>SetupWriteTextLog</b> cannot locate the section, <b>SetupWriteTextLog</b> writes the log entry in the corresponding text log, but does not include the log entry in a section.
     * 
     * If the value of <i>LogToken</i> is one of the system-defined log tokens listed in the following table, <b>SetupWriteTextLog</b> performs the write operation that is indicated for that log token.
     * 
     * <table>
     * <tr>
     * <th>System-defined log token </th>
     * <th>Write operation</th>
     * </tr>
     * <tr>
     * <td>
     * LOGTOKEN_NOLOG
     * 
     * </td>
     * <td>
     * The log entry is not written to any text log.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LOG_TOKEN_UNSPECIFIED
     * 
     * </td>
     * <td>
     * The log entry is written to the application installation text log. The log entry is not included in a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/format-of-a-text-log-section">text log section</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LOGTOKEN_SETUPAPI_APPLOG
     * 
     * </td>
     * <td>
     * The log entry is written to the application installation text log. The log entry is not included in a text log section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LOGTOKEN_SETUPAPI_DEVLOG
     * 
     * </td>
     * <td>
     * The log entry is written to the device installation text log. The log entry is not included in a text log section.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>Setting the value of <i>LogToken</i> to one of the system-defined log tokens does not change the value of the current log token for the thread.</div>
     * <div></div>
     * In addition, <b>SetupWriteTextLog</b> does not write a log entry when any of the following are true:
     * 
     * <ul>
     * <li>
     * The <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-the-event-level-for-a-text-log">event level set for the text log</a> is less than the event level that is specified for the log entry. 
     * 
     * </li>
     * <li>
     * The event category for the log entry is not enabled for the text log. For more information about event categories, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/enabling-event-categories-for-a-text-log">Enabling Event Categories for a Text Log</a>.
     * 
     * </li>
     * </ul>
     * The maximum length, in characters, of a log entry is 336.
     * 
     * To write information about a SetupAPI-specific error or a Win32 error in a text log, an application can use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupwritetextlogerror">SetupWriteTextLogError</a>.
     * 
     * For general information about writing log entries in the SetupAPI text logs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupapi-logging--windows-vista-and-later-">SetupAPI Logging (Windows Vista and Later)</a>. 
     * 
     * For more information about the operation of <b>SetupWriteTextLog</b>, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-setupwritetextlog">Calling SetupWriteTextLog</a>. 
     * 
     * For more information about log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">Log Tokens</a>.
     * 
     * For more information about using log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-and-getting-a-log-token-for-a-thread">Setting and Getting a Log Token for a Thread</a>.
     * @param {Integer} LogToken A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a> that is either a system-defined log token or was returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>.
     * @param {Integer} Category A DWORD-typed value that indicates the event category for the log entry. The event categories that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event categories, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/enabling-event-categories-for-a-text-log">Enabling Event Categories for a SetupAPI Text Log</a>.
     * @param {Integer} Flags A DWORD-typed value that is a bitwise OR of flag values, which specify the following:
     * 
     * <ul>
     * <li>
     * The event level for the log entry. The event levels that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event level flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-the-event-level-for-a-text-log">Setting the Event Level for a SetupAPI Text Log</a>. 
     * 
     * </li>
     * <li>
     * Whether to include a time stamp in the log entry. The time stamp flag value is TXTLOG_TIMESTAMP.
     * 
     * </li>
     * <li>
     * The change, if any, to the indentation depth of the section and the current log entry. For information about how to use the indentation flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-indented-log-entries">Writing Indented Log Entries</a>.
     * 
     * </li>
     * </ul>
     * @param {Pointer<PSTR>} MessageStr A pointer to a NULL-terminated constant string that contains a <b>printf</b>-compatible format string, which specifies the formatted message to include in the log entry. The comma-separated parameter list that follows <i>MessageStr</i> must match the format specifiers in the format string.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupwritetextlog
     * @since windows6.0.6000
     */
    static SetupWriteTextLog(LogToken, Category, Flags, MessageStr) {
        MessageStr := MessageStr is String? StrPtr(MessageStr) : MessageStr

        DllCall("SETUPAPI.dll\SetupWriteTextLog", "uint", LogToken, "uint", Category, "uint", Flags, "ptr", MessageStr, "CDecl ")
    }

    /**
     * The SetupWriteTextLogError function writes information about a SetupAPI-specific error or a Win32 system error to a SetupAPI text log.
     * @remarks
     * If an installation application has a SetupAPI-specific error code or a Win32 error code that is associated with an installation error, the application can call <b>SetupWriteTextLogError</b> instead of <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupwritetextlog">SetupWriteTextLog</a> to write two entries into a text log. The first entry will be the same as that written by <b>SetupWriteTextLog</b> and the second entry will log the error code and a user-friendly description of the error.
     * 
     * The log token, event category, and flags that a caller supplies affect the operation of <b>SetupWriteTextLogError</b> is the same manner as that described for <b>SetupWriteTextLog</b>.
     * 
     * <b>SetupWriteTextLogError</b> writes the first log entry in the following format: 
     * 
     * <i>entry-prefix</i> <i>time_stamp category</i><i>indentation</i> <i>formatted-message</i>
     * 
     * <b>SetupWriteTextLogError</b> writes the second log entry in the following format:
     * 
     * <i>entry-prefix</i> <i>time_stamp</i> <i>category</i>
     *      <i>indentation</i> 
     *      <b>Error:</b><i>error-numbererror-description</i>
     * 
     * Where:
     * 
     * <ul>
     * <li>
     * The <i>entry-prefix</i>, <i>time-stamp</i>, <i>category</i>, <i>indentation</i>, and <i>formatted-message</i> fields are the same as those described in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/format-of-a-text-log-section-body">Format of a Text Log Section Body</a>.
     * 
     * </li>
     * <li>
     * The <i>error-number</i> field contains the error number.
     * 
     * </li>
     * <li>
     * The <i>error-description</i> field contains a user-friendly description of the error.
     * 
     * </li>
     * </ul>
     * For general information about writing log entries in the SetupAPI text logs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupapi-logging--windows-vista-and-later-">SetupAPI Logging (Windows Vista)</a>. 
     * 
     * For more information about the operation of <b>SetupWriteTextLogError</b>, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-setupwritetextlogerror">Calling SetupWriteTextLogError</a>. 
     * 
     * For more information about log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">Log Tokens</a>.
     * 
     * For more information about using log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-and-getting-a-log-token-for-a-thread">Setting and Getting a Log Token for a Thread</a>.
     * @param {Integer} LogToken A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a> that is either a system-defined log token or was returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>.
     * @param {Integer} Category A value of type DWORD that indicates the event category for the log entry. The event categories that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event categories, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/enabling-event-categories-for-a-text-log">Enabling Event Categories for a SetupAPI Text Log</a>.
     * @param {Integer} LogFlags A value of type DWORD that is a bitwise OR of flag values, which specify the following:
     * 
     * <ul>
     * <li>
     * The event level for the log entry. The event levels that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event level flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-the-event-level-for-a-text-log">Setting the Event Level for a Text Log</a>. 
     * 
     * </li>
     * <li>
     * Whether to include a time stamp in the log entry. The time stamp flag value is TXTLOG_TIMESTAMP.
     * 
     * </li>
     * <li>
     * The change, if any, to the indentation depth of the section and the current log entry. For information about how to use the indentation flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-indented-log-entries">Writing Indented Log Entries</a>.
     * 
     * </li>
     * </ul>
     * @param {Integer} Error A SetupAPI-specific error code or a Win32 error code. The SetupAPI-specific error codes are listed in <i>Setupapi.h</i>. The Win32 error codes are listed in <i>Winerror.h</i>.
     * @param {Pointer<PSTR>} MessageStr A pointer to a NULL-terminated constant string that contains a <b>printf</b>-compatible format string, which specifies the formatted message to include in the log entry.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupwritetextlogerror
     * @since windows6.0.6000
     */
    static SetupWriteTextLogError(LogToken, Category, LogFlags, Error, MessageStr) {
        MessageStr := MessageStr is String? StrPtr(MessageStr) : MessageStr

        DllCall("SETUPAPI.dll\SetupWriteTextLogError", "uint", LogToken, "uint", Category, "uint", LogFlags, "uint", Error, "ptr", MessageStr, "CDecl ")
    }

    /**
     * The SetupWriteTextLogInfLine function writes a log entry in a SetupAPI text log that contains the text of a specified INF file line.
     * @remarks
     * <b>SetupWriteTextLogInfLine</b> writes a log entry in the following format:
     * 
     * <i>entry-prefix</i> <i>time-stamp</i><b>inf:</b><i>indentation</i><i>inf-line-text</i><b>(</b><i>inf-file-name</i><b>line</b><i>line-number</i><b>)</b>
     * 
     * Where:
     * 
     * <ul>
     * <li>
     * The <i>entry-prefix</i> and <i>time-stamp</i> fields are the same as those described in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/format-of-a-text-log-section-body">Format of a Text Log Section Body</a>.
     * 
     * </li>
     * <li>
     * The <i>inf-line-text</i> field contains the text of the specified INF file line. 
     * 
     * </li>
     * <li>
     * The <i>inf-file-name</i> field contains the name of the INF file that contains the specified INF file line.
     * 
     * </li>
     * <li>
     * The <i>line-number</i> field contains the line number of the specified line in the INF file.
     * 
     * </li>
     * </ul>
     * The log token and flags that a caller supplies affect the operation of <b>SetupWriteTextLogInfLine</b> in the same manner as that described for <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupwritetextlog">SetupWriteTextLog</a> and <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupwritetextlogerror">SetupWriteTextLogError</a>. In addition, <b>SetupWriteTextLogInfLine</b> uses the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/enabling-event-categories-for-a-text-log">event category</a> TXTLOG_INF. 
     * 
     * For general information about writing log entries in the SetupAPI text logs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupapi-logging--windows-vista-and-later-">SetupAPI Logging (Windows Vista)</a>. 
     * 
     * For more information about the operation of <b>SetupWriteTextLogInfLine</b>, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-setupwritetextloginfline">Calling SetupWriteTextLogInfLine</a>. 
     * 
     * For more information about the various types of log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">Log Tokens</a>.
     * 
     * For more information about using log tokens, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-and-getting-a-log-token-for-a-thread">Setting and Getting a Log Token for a Thread</a>.
     * @param {Integer} LogToken A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/log-tokens">log token</a> that is either a system-defined log token or was returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetthreadlogtoken">SetupGetThreadLogToken</a>.
     * @param {Integer} Flags A value of type DWORD that is a bitwise OR of flag values, which specify the following:
     * 
     * <ul>
     * <li>
     * The event level for the log entry. The event levels that can be specified for a log entry are the same as those that can be enabled for a text log. For a list of event level flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setting-the-event-level-for-a-text-log">Setting the Event Level for a SetupAPI Text Log</a>. 
     * 
     * </li>
     * <li>
     * Whether to include a time stamp in the log entry. The time stamp flag value is TXTLOG_TIMESTAMP.
     * 
     * </li>
     * <li>
     * The change, if any, to the indentation depth of the section and the current log entry. For information about how to use the indentation flags, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-indented-log-entries">Writing Indented Log Entries</a>.
     * 
     * </li>
     * </ul>
     * @param {Pointer<Void>} InfHandle A handle to the INF file that includes the line of text to be written to the text log. A handle to an INF file is obtained by calling <b>SetupOpenInfFile</b>, which is documented in the Platform SDK.
     * @param {Pointer<INFCONTEXT>} Context A pointer to an INF file context that specifies the  line of text to be written to the text log. An INF file context for a line is obtained by calling the <b>SetupFind</b><i>Xxx</i><b>Line</b> functions. For information about INF files and an INF file context, see the information that is provided in the Platform SDK about using INF files, obtaining an INF file context, and the INFCONTEXT structure.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupwritetextloginfline
     * @since windows6.0.6000
     */
    static SetupWriteTextLogInfLine(LogToken, Flags, InfHandle, Context) {
        DllCall("SETUPAPI.dll\SetupWriteTextLogInfLine", "uint", LogToken, "uint", Flags, "ptr", InfHandle, "ptr", Context)
    }

    /**
     * 
     * @param {Pointer<Void>} QueueHandle 
     * @param {Pointer<SP_BACKUP_QUEUE_PARAMS_V2_A>} BackupParams 
     * @returns {Integer} 
     */
    static SetupGetBackupInformationA(QueueHandle, BackupParams) {
        result := DllCall("SETUPAPI.dll\SetupGetBackupInformationA", "ptr", QueueHandle, "ptr", BackupParams, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} QueueHandle 
     * @param {Pointer<SP_BACKUP_QUEUE_PARAMS_V2_W>} BackupParams 
     * @returns {Integer} 
     */
    static SetupGetBackupInformationW(QueueHandle, BackupParams) {
        result := DllCall("SETUPAPI.dll\SetupGetBackupInformationW", "ptr", QueueHandle, "ptr", BackupParams, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} QueueHandle 
     * @param {Pointer<PSTR>} BackupPath 
     * @param {Integer} RestoreFlags 
     * @returns {Integer} 
     */
    static SetupPrepareQueueForRestoreA(QueueHandle, BackupPath, RestoreFlags) {
        BackupPath := BackupPath is String? StrPtr(BackupPath) : BackupPath

        result := DllCall("SETUPAPI.dll\SetupPrepareQueueForRestoreA", "ptr", QueueHandle, "ptr", BackupPath, "uint", RestoreFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} QueueHandle 
     * @param {Pointer<PWSTR>} BackupPath 
     * @param {Integer} RestoreFlags 
     * @returns {Integer} 
     */
    static SetupPrepareQueueForRestoreW(QueueHandle, BackupPath, RestoreFlags) {
        BackupPath := BackupPath is String? StrPtr(BackupPath) : BackupPath

        result := DllCall("SETUPAPI.dll\SetupPrepareQueueForRestoreW", "ptr", QueueHandle, "ptr", BackupPath, "uint", RestoreFlags, "int")
        return result
    }

    /**
     * The SetupSetNonInteractiveMode function sets a non-interactive SetupAPI flag that determines whether SetupAPI can interact with a user in the caller's context.
     * @remarks
     * Installation applications and <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-a-co-installer">co-installers</a> can use this function to control whether SetupAPI can display interactive user interface elements, such as dialog boxes, in the caller's context. 
     * 
     * An installation application or an installer can call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupgetnoninteractivemode">SetupGetNonInteractiveMode</a> to retrieve the current value of the non-interactive flag.
     * @param {Integer} NonInteractiveFlag The Boolean value of the non-interactive flag. If <i>NonInteractive</i> is set to <b>TRUE</b>, SetupAPI runs in a non-interactive user mode and if <i>NonInteractive</i> is set to <b>FALSE</b>, SetupAPI runs in an interactive user mode.
     * @returns {Integer} <b>SetupSetNonInteractiveMode</b> returns the previous setting of the non-interactive flag.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupsetnoninteractivemode
     * @since windows5.1.2600
     */
    static SetupSetNonInteractiveMode(NonInteractiveFlag) {
        result := DllCall("SETUPAPI.dll\SetupSetNonInteractiveMode", "int", NonInteractiveFlag, "int")
        return result
    }

    /**
     * The SetupGetNonInteractiveMode function returns the value of a SetupAPI non-interactive flag that indicates whether the caller's process can interact with a user through user interface components, such as dialog boxes.
     * @remarks
     * Installation applications and <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-a-co-installer">co-installers</a> can use this function to determine whether the current process can display interactive user interface elements such as dialog boxes. <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupapi">SetupAPI</a> runs a class installer or a co-installer either in an interactive or in a non-interactive process, depending on which <a href="https://docs.microsoft.com/windows-hardware/drivers/install/handling-dif-codes">DIF code</a> SetupAPI is processing.
     * 
     * An installation application can call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupsetnoninteractivemode">SetupSetNonInteractiveMode</a> to set the SetupAPI non-interactive flag that controls whether SetupAPI can display interactive user interface elements in the caller's context.
     * @returns {Integer} <b>SetupGetNonInteractiveMode</b> returns <b>TRUE</b> if the caller's process cannot display interactive user interface elements, such as dialog boxes. Otherwise, the function returns <b>FALSE</b>, which indicates that the process can display interactive user interface elements.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupgetnoninteractivemode
     * @since windows5.1.2600
     */
    static SetupGetNonInteractiveMode() {
        result := DllCall("SETUPAPI.dll\SetupGetNonInteractiveMode", "int")
        return result
    }

    /**
     * The SetupDiCreateDeviceInfoList function creates an empty device information set and optionally associates the set with a device setup class and a top-level window.
     * @remarks
     * The caller of this function must delete the returned device information set when it is no longer needed by calling <b>SetupDiDestroyDeviceInfoList</b>. 
     * 
     * To create a device information list for a remote computer use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinfolistexa">SetupDiCreateDeviceInfoListEx</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to the <b>GUID</b> of the device setup class to associate with the newly created device information set. If this parameter is specified, only devices of this class can be included in this device information set. If this parameter is set to <b>NULL</b>, the device information set is not associated with a specific device setup class.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to use for any user interface that is related to non-device-specific actions (such as a select-device dialog box that uses the global class driver list). This handle is optional and can be <b>NULL</b>. If a specific top-level window is not required, set <i>hwndParent</i> to <b>NULL</b>.
     * @returns {Pointer} The function returns a handle to an empty device information set if it is successful. Otherwise, it returns <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinfolist
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoList(ClassGuid, hwndParent) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoList", "ptr", ClassGuid, "ptr", hwndParent, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDeviceInfoList function creates an empty device information set on a remote or a local computer and optionally associates the set with a device setup class . (ANSI)
     * @remarks
     * The caller of this function must delete the returned device information set when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroydeviceinfolist">SetupDiDestroyDeviceInfoList</a>. 
     * 
     * If the device information set is for devices on a remote computer (<i>MachineName</i> is not <b>NULL</b>), all subsequent operations on this set or any of its elements must use routines that support device information sets with remote elements. The <b>SetupDi</b><i>Xxx</i> routines that do not provide this support, such as <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicallclassinstaller">SetupDiCallClassInstaller</a>, have a statement to that effect in their reference page.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDeviceInfoListEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the device setup class to associate with the newly created device information set. If this parameter is specified, only devices of this class can be included in this device information set. If this parameter is set to <b>NULL</b>, the device information set is not associated with a specific device setup class.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to use for any user interface that is related to non-device-specific actions (such as a select-device dialog box that uses the global class driver list). This handle is optional and can be <b>NULL</b>. If a specific top-level window is not required, set <i>hwndParent</i> to <b>NULL</b>.
     * @param {Pointer<PSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a computer on a network. If a name is specified, only devices on that computer can be created and opened in this device information set. If this parameter is set to <b>NULL</b>, the device information set is for devices on the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Pointer} The function returns a handle to an empty device information set if it is successful. Otherwise, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinfolistexa
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoListExA(ClassGuid, hwndParent, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoListExA", "ptr", ClassGuid, "ptr", hwndParent, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDeviceInfoList function creates an empty device information set on a remote or a local computer and optionally associates the set with a device setup class . (Unicode)
     * @remarks
     * The caller of this function must delete the returned device information set when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroydeviceinfolist">SetupDiDestroyDeviceInfoList</a>. 
     * 
     * If the device information set is for devices on a remote computer (<i>MachineName</i> is not <b>NULL</b>), all subsequent operations on this set or any of its elements must use routines that support device information sets with remote elements. The <b>SetupDi</b><i>Xxx</i> routines that do not provide this support, such as <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicallclassinstaller">SetupDiCallClassInstaller</a>, have a statement to that effect in their reference page.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDeviceInfoListEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the device setup class to associate with the newly created device information set. If this parameter is specified, only devices of this class can be included in this device information set. If this parameter is set to <b>NULL</b>, the device information set is not associated with a specific device setup class.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to use for any user interface that is related to non-device-specific actions (such as a select-device dialog box that uses the global class driver list). This handle is optional and can be <b>NULL</b>. If a specific top-level window is not required, set <i>hwndParent</i> to <b>NULL</b>.
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a computer on a network. If a name is specified, only devices on that computer can be created and opened in this device information set. If this parameter is set to <b>NULL</b>, the device information set is for devices on the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Pointer} The function returns a handle to an empty device information set if it is successful. Otherwise, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinfolistexw
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoListExW(ClassGuid, hwndParent, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoListExW", "ptr", ClassGuid, "ptr", hwndParent, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInfoListClass function retrieves the GUID for the device setup class associated with a device information set if the set has an associated class.
     * @remarks
     * If the specified device information set does not have an associated class because a class GUID was not specified when the set was created with <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinfolist">SetupDiCreateDeviceInfoList</a>, the function fails. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_ASSOCIATED_CLASS.
     * 
     * If a device information set is for a remote computer, use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila">SetupDiGetDeviceInfoListDetail</a> to get the associated remote computer handle and computer name.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to query.
     * @param {Pointer<Guid>} ClassGuid A pointer to variable of type GUID that receives the GUID for the associated class.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinfolistclass
     * @since windows5.0
     */
    static SetupDiGetDeviceInfoListClass(DeviceInfoSet, ClassGuid) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInfoListClass", "ptr", DeviceInfoSet, "ptr", ClassGuid, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInfoListDetail function retrieves information associated with a device information set including the class GUID, remote computer handle, and remote computer name. (ANSI)
     * @remarks
     * If the parameters are valid, <b>SetupDiGetDeviceInfoListDetail</b> sets values in the <i>DeviceInfoSetDetailData</i> structure (except for the <b>cbSize</b> field) and returns status NO_ERROR. 
     * 
     * A caller of <b>SetupDiGetDeviceInfoListDetail</b> must set <i>DeviceInfoSetDetailData.</i><b>cbSize</b> to <b>sizeof</b>(SP_DEVINFO_LIST_DETAIL_DATA) or the function will fail and the call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_USER_BUFFER.
     * 
     * If <b>SetupDiGetDeviceInfoListDetail</b> completes successfully, <i>DeviceInfoSetDetailData.</i><b>ClassGuid</b> contains the class GUID associated with the device information set or a GUID_NULL structure.
     * 
     * If <b>SetupDiGetDeviceInfoListDetail</b> completes successfully and the device information set is for a remote system, <i>DeviceInfoSetDetailData.</i><b>RemoteMachineHandle</b> contains the ConfigMgr32 system handle for accessing the remote system and <i>DeviceInfoSetDetailData.</i><b>RemoteMachineName</b> contains the name of the remote system. If there is a remote handle for the device information set, it must be used when calling <b>CM_</b><i>Xxx</i><b>_Ex</b> functions because the DevInst handles are relative to the remote handle.
     * 
     * If the device information set is for the local computer, <i>DeviceInfoSetDetailData.</i><b>RemoteMachineHandle</b> is <b>NULL</b> and <i>DeviceInfoSetDetailData.</i><b>RemoteMachineName</b> is an empty string. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceInfoListDetail as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to retrieve information.
     * @param {Pointer<SP_DEVINFO_LIST_DETAIL_DATA_A>} DeviceInfoSetDetailData A pointer to a caller-initialized <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure that receives the device information set information. For more information about this structure, see the following <b>Remarks</b> section.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila
     * @since windows5.0
     */
    static SetupDiGetDeviceInfoListDetailA(DeviceInfoSet, DeviceInfoSetDetailData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInfoListDetailA", "ptr", DeviceInfoSet, "ptr", DeviceInfoSetDetailData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInfoListDetail function retrieves information associated with a device information set including the class GUID, remote computer handle, and remote computer name. (Unicode)
     * @remarks
     * If the parameters are valid, <b>SetupDiGetDeviceInfoListDetail</b> sets values in the <i>DeviceInfoSetDetailData</i> structure (except for the <b>cbSize</b> field) and returns status NO_ERROR. 
     * 
     * A caller of <b>SetupDiGetDeviceInfoListDetail</b> must set <i>DeviceInfoSetDetailData.</i><b>cbSize</b> to <b>sizeof</b>(SP_DEVINFO_LIST_DETAIL_DATA) or the function will fail and the call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_USER_BUFFER.
     * 
     * If <b>SetupDiGetDeviceInfoListDetail</b> completes successfully, <i>DeviceInfoSetDetailData.</i><b>ClassGuid</b> contains the class GUID associated with the device information set or a GUID_NULL structure.
     * 
     * If <b>SetupDiGetDeviceInfoListDetail</b> completes successfully and the device information set is for a remote system, <i>DeviceInfoSetDetailData.</i><b>RemoteMachineHandle</b> contains the ConfigMgr32 system handle for accessing the remote system and <i>DeviceInfoSetDetailData.</i><b>RemoteMachineName</b> contains the name of the remote system. If there is a remote handle for the device information set, it must be used when calling <b>CM_</b><i>Xxx</i><b>_Ex</b> functions because the DevInst handles are relative to the remote handle.
     * 
     * If the device information set is for the local computer, <i>DeviceInfoSetDetailData.</i><b>RemoteMachineHandle</b> is <b>NULL</b> and <i>DeviceInfoSetDetailData.</i><b>RemoteMachineName</b> is an empty string. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceInfoListDetail as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to retrieve information.
     * @param {Pointer<SP_DEVINFO_LIST_DETAIL_DATA_W>} DeviceInfoSetDetailData A pointer to a caller-initialized <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure that receives the device information set information. For more information about this structure, see the following <b>Remarks</b> section.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetailw
     * @since windows5.0
     */
    static SetupDiGetDeviceInfoListDetailW(DeviceInfoSet, DeviceInfoSetDetailData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInfoListDetailW", "ptr", DeviceInfoSet, "ptr", DeviceInfoSetDetailData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDeviceInfo function creates a new device information element and adds it as a new member to the specified device information set. (ANSI)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * If this device instance is being added to a set that has an associated class, the device class must be the same or the call fails. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_CLASS_MISMATCH.
     * 
     * If the specified device instance is the same as an existing device instance key in the registry, the call fails. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_DEVINST_ALREADY_EXISTS. This occurs only if the DICD_GENERATE_ID flag is not set.
     * 
     * If the new device information element was successfully created but the caller-supplied <i>DeviceInfoData</i> buffer is invalid, the function returns <b>FALSE</b>. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_USER_BUFFER. However, the device information element will have been added as a new member of the set already.
     * 
     * The <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDeviceInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local computer.
     * @param {Pointer<PSTR>} DeviceName A pointer to a NULL-terminated string that supplies either a full <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> (for example, "Root\*PNP0500\0000") or a root-enumerated <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-ids">device ID</a> without the enumerator prefix and instance identifier suffix (for example, "*PNP0500"). The root-enumerated device identifier can be used only if the DICD_GENERATE_ID flag is specified in the <i>CreationFlags</i> parameter.
     * @param {Pointer<Guid>} ClassGuid A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> GUID for the device. If the device setup class of the device is not known, set *<i>ClassGuid</i> to a GUID_NULL structure.
     * @param {Pointer<PSTR>} DeviceDescription A pointer to a NULL-terminated string that supplies the text description of the device. This pointer is optional and can be <b>NULL</b>.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to use for any user interface that is related to installing the device. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} CreationFlags 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that receives the new device information element. This pointer is optional and can be <b>NULL</b>. If the structure is supplied, the caller must set the <b>cbSize</b> member of this structure to <b>sizeof(</b>SP_DEVINFO_DATA<b>)</b> before calling the function. For more information, see the following <b>Remarks</b> section.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinfoa
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoA(DeviceInfoSet, DeviceName, ClassGuid, DeviceDescription, hwndParent, CreationFlags, DeviceInfoData) {
        DeviceName := DeviceName is String? StrPtr(DeviceName) : DeviceName
        DeviceDescription := DeviceDescription is String? StrPtr(DeviceDescription) : DeviceDescription

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoA", "ptr", DeviceInfoSet, "ptr", DeviceName, "ptr", ClassGuid, "ptr", DeviceDescription, "ptr", hwndParent, "uint", CreationFlags, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDeviceInfo function creates a new device information element and adds it as a new member to the specified device information set. (Unicode)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * If this device instance is being added to a set that has an associated class, the device class must be the same or the call fails. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_CLASS_MISMATCH.
     * 
     * If the specified device instance is the same as an existing device instance key in the registry, the call fails. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_DEVINST_ALREADY_EXISTS. This occurs only if the DICD_GENERATE_ID flag is not set.
     * 
     * If the new device information element was successfully created but the caller-supplied <i>DeviceInfoData</i> buffer is invalid, the function returns <b>FALSE</b>. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_USER_BUFFER. However, the device information element will have been added as a new member of the set already.
     * 
     * The <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDeviceInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local computer.
     * @param {Pointer<PWSTR>} DeviceName A pointer to a NULL-terminated string that supplies either a full <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> (for example, "Root\*PNP0500\0000") or a root-enumerated <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-ids">device ID</a> without the enumerator prefix and instance identifier suffix (for example, "*PNP0500"). The root-enumerated device identifier can be used only if the DICD_GENERATE_ID flag is specified in the <i>CreationFlags</i> parameter.
     * @param {Pointer<Guid>} ClassGuid A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> GUID for the device. If the device setup class of the device is not known, set *<i>ClassGuid</i> to a GUID_NULL structure.
     * @param {Pointer<PWSTR>} DeviceDescription A pointer to a NULL-terminated string that supplies the text description of the device. This pointer is optional and can be <b>NULL</b>.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to use for any user interface that is related to installing the device. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} CreationFlags 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that receives the new device information element. This pointer is optional and can be <b>NULL</b>. If the structure is supplied, the caller must set the <b>cbSize</b> member of this structure to <b>sizeof(</b>SP_DEVINFO_DATA<b>)</b> before calling the function. For more information, see the following <b>Remarks</b> section.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinfow
     * @since windows5.0
     */
    static SetupDiCreateDeviceInfoW(DeviceInfoSet, DeviceName, ClassGuid, DeviceDescription, hwndParent, CreationFlags, DeviceInfoData) {
        DeviceName := DeviceName is String? StrPtr(DeviceName) : DeviceName
        DeviceDescription := DeviceDescription is String? StrPtr(DeviceDescription) : DeviceDescription

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInfoW", "ptr", DeviceInfoSet, "ptr", DeviceName, "ptr", ClassGuid, "ptr", DeviceDescription, "ptr", hwndParent, "uint", CreationFlags, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenDeviceInfo function adds a device information element for a device instance to a device information set, if one does not already exist in the device information set, and retrieves information that identifies the device information element for the device instance in the device information set. (ANSI)
     * @remarks
     * If this device instance is being added to a set that has an associated class, the device class must be the same or the call will fail. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_CLASS_MISMATCH.
     * 
     * If the new device information element is successfully opened but the caller-supplied <i>DeviceInfoData</i> buffer is invalid, this function returns <b>FALSE</b>. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_USER_BUFFER. However, the device information element is added as a new member of the set anyway.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiOpenDeviceInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to which <b>SetupDiOpenDeviceInfo</b> adds a device information element, if one does not already exist, for the device instance that is specified by <i>DeviceInstanceId</i>.
     * @param {Pointer<PSTR>} DeviceInstanceId A pointer to a NULL-terminated string that supplies the device instance identifier of a device (for example, "Root\*PNP0500\0000"). If <i>DeviceInstanceId</i> is <b>NULL</b> or references a zero-length string, <b>SetupDiOpenDeviceInfo</b> adds a device information element to the supplied device information set, if one does not already exist, for the root device in the device tree.
     * @param {Pointer<HWND>} hwndParent The handle to the top-level window to use for any user interface related to installing the device.
     * @param {Integer} OpenFlags A variable of DWORD type that controls how the device information element is opened. The value of this parameter can be one or more of the following:
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a caller-supplied <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that receives information about the device information element for the device instance that is specified by <i>DeviceInstanceId</i>. The caller must set <b>cbSize</b> to <b>sizeof(</b>SP_DEVINFO_DATA<b>)</b>. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} <b>SetupDiOpenDeviceInfo</b> returns <b>TRUE</b> if it is successful. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendeviceinfoa
     * @since windows5.0
     */
    static SetupDiOpenDeviceInfoA(DeviceInfoSet, DeviceInstanceId, hwndParent, OpenFlags, DeviceInfoData) {
        DeviceInstanceId := DeviceInstanceId is String? StrPtr(DeviceInstanceId) : DeviceInstanceId

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInfoA", "ptr", DeviceInfoSet, "ptr", DeviceInstanceId, "ptr", hwndParent, "uint", OpenFlags, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenDeviceInfo function adds a device information element for a device instance to a device information set, if one does not already exist in the device information set, and retrieves information that identifies the device information element for the device instance in the device information set. (Unicode)
     * @remarks
     * If this device instance is being added to a set that has an associated class, the device class must be the same or the call will fail. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_CLASS_MISMATCH.
     * 
     * If the new device information element is successfully opened but the caller-supplied <i>DeviceInfoData</i> buffer is invalid, this function returns <b>FALSE</b>. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_USER_BUFFER. However, the device information element is added as a new member of the set anyway.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiOpenDeviceInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to which <b>SetupDiOpenDeviceInfo</b> adds a device information element, if one does not already exist, for the device instance that is specified by <i>DeviceInstanceId</i>.
     * @param {Pointer<PWSTR>} DeviceInstanceId A pointer to a NULL-terminated string that supplies the device instance identifier of a device (for example, "Root\*PNP0500\0000"). If <i>DeviceInstanceId</i> is <b>NULL</b> or references a zero-length string, <b>SetupDiOpenDeviceInfo</b> adds a device information element to the supplied device information set, if one does not already exist, for the root device in the device tree.
     * @param {Pointer<HWND>} hwndParent The handle to the top-level window to use for any user interface related to installing the device.
     * @param {Integer} OpenFlags A variable of DWORD type that controls how the device information element is opened. The value of this parameter can be one or more of the following:
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a caller-supplied <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that receives information about the device information element for the device instance that is specified by <i>DeviceInstanceId</i>. The caller must set <b>cbSize</b> to <b>sizeof(</b>SP_DEVINFO_DATA<b>)</b>. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} <b>SetupDiOpenDeviceInfo</b> returns <b>TRUE</b> if it is successful. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendeviceinfow
     * @since windows5.0
     */
    static SetupDiOpenDeviceInfoW(DeviceInfoSet, DeviceInstanceId, hwndParent, OpenFlags, DeviceInfoData) {
        DeviceInstanceId := DeviceInstanceId is String? StrPtr(DeviceInstanceId) : DeviceInstanceId

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInfoW", "ptr", DeviceInfoSet, "ptr", DeviceInstanceId, "ptr", hwndParent, "uint", OpenFlags, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInstanceId function retrieves the device instance ID that is associated with a device information element. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceInstanceId as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element that represents the device for which to retrieve a device instance ID.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Pointer<PSTR>} DeviceInstanceId A pointer to the character buffer that will receive the NULL-terminated device instance ID for the specified device information element. For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * @param {Integer} DeviceInstanceIdSize The size, in characters, of the <i>DeviceInstanceId</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to the variable that receives the number of characters required to store the device instance ID.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinstanceida
     * @since windows5.0
     */
    static SetupDiGetDeviceInstanceIdA(DeviceInfoSet, DeviceInfoData, DeviceInstanceId, DeviceInstanceIdSize, RequiredSize) {
        DeviceInstanceId := DeviceInstanceId is String? StrPtr(DeviceInstanceId) : DeviceInstanceId

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInstanceIdA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstanceId, "uint", DeviceInstanceIdSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInstanceId function retrieves the device instance ID that is associated with a device information element. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceInstanceId as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element that represents the device for which to retrieve a device instance ID.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Pointer<PWSTR>} DeviceInstanceId A pointer to the character buffer that will receive the NULL-terminated device instance ID for the specified device information element. For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * @param {Integer} DeviceInstanceIdSize The size, in characters, of the <i>DeviceInstanceId</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to the variable that receives the number of characters required to store the device instance ID.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinstanceidw
     * @since windows5.0
     */
    static SetupDiGetDeviceInstanceIdW(DeviceInfoSet, DeviceInfoData, DeviceInstanceId, DeviceInstanceIdSize, RequiredSize) {
        DeviceInstanceId := DeviceInstanceId is String? StrPtr(DeviceInstanceId) : DeviceInstanceId

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInstanceIdW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstanceId, "uint", DeviceInstanceIdSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDeleteDeviceInfo function deletes a device information element from a device information set. This function does not delete the actual device.
     * @remarks
     * If the specified device information element is in use (for example, by a wizard page), the function fails. In this case, a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_DEVINFO_DATA_LOCKED. This happens if a handle to a wizard page is retrieved with a call to <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupdigetwizardpage">SetupDiGetWizardPage</a> with this device information element specified and the DIWP_FLAG_USE_DEVINFO_DATA flag set. To delete this device information element, you must first close the wizard's HPROPSHEETPAGE handle.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element to delete.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device information element in <i>DeviceInfoSet </i> to delete.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdideletedeviceinfo
     * @since windows5.0
     */
    static SetupDiDeleteDeviceInfo(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDeleteDeviceInfo", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiEnumDeviceInfo function returns a SP_DEVINFO_DATA structure that specifies a device information element in a device information set.
     * @remarks
     * Repeated calls to this function return a device information element for a different device. This function can be called repeatedly to get information about all devices in the device information set.
     * 
     * To enumerate device information elements, an installer should initially call <b>SetupDiEnumDeviceInfo</b> with the <i>MemberIndex</i> parameter set to 0. The installer should then increment <i>MemberIndex</i> and call <b>SetupDiEnumDeviceInfo</b> until there are no more values (the function fails and a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NO_MORE_ITEMS</b>).
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a> to get a context structure for a device <i>interface</i> element (versus a device <i>information</i> element).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to return an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents a device information element.
     * @param {Integer} MemberIndex A zero-based index of the device information element to retrieve.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure to receive information about an enumerated device information element. The caller must set <i>DeviceInfoData</i>.<b>cbSize</b> to <c>sizeof(SP_DEVINFO_DATA)</c>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdienumdeviceinfo
     * @since windows5.0
     */
    static SetupDiEnumDeviceInfo(DeviceInfoSet, MemberIndex, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiEnumDeviceInfo", "ptr", DeviceInfoSet, "uint", MemberIndex, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDestroyDeviceInfoList function deletes a device information set and frees all associated memory.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to delete.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdidestroydeviceinfolist
     * @since windows5.0
     */
    static SetupDiDestroyDeviceInfoList(DeviceInfoSet) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDestroyDeviceInfoList", "ptr", DeviceInfoSet, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiEnumDeviceInterfaces function enumerates the device interfaces that are contained in a device information set.
     * @remarks
     * Repeated calls to this function return an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure for a different device interface. This function can be called repeatedly to get information about interfaces in a device information set that are associated with a particular device information element or that are associated with all device information elements.
     * 
     * <i>DeviceInterfaceData</i> points to a structure that identifies a requested device interface. To get detailed information about an interface, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinterfacedetaila">SetupDiGetDeviceInterfaceDetail</a>. The detailed information includes the name of the device interface that can be passed to a Win32 function such as <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> (described in Microsoft Windows SDK documentation) to get a handle to the interface.
     * 
     * See <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">Overview of Device Interface Classes</a> for more info.
     * @param {Pointer} DeviceInfoSet A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interfaces for which to return information. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiEnumDeviceInterfaces</b> constrains the enumeration to the interfaces that are supported by the specified device. If this parameter is <b>NULL</b>, repeated calls to <b>SetupDiEnumDeviceInterfaces</b> return information about the interfaces that are associated with all the device information elements in <i>DeviceInfoSet</i>. This pointer is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinfo">SetupDiEnumDeviceInfo</a>.
     * @param {Pointer<Guid>} InterfaceClassGuid A pointer to a GUID that specifies the device interface class for the requested interface.
     * @param {Integer} MemberIndex A zero-based index into the list of interfaces in the device information set. The caller should call this function first with <i>MemberIndex</i> set to zero to obtain the first interface. Then, repeatedly increment <i>MemberIndex</i> and retrieve an interface until this function fails and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_MORE_ITEMS.
     * 
     * If <i>DeviceInfoData</i> specifies a particular device, the <i>MemberIndex</i> is relative to only the interfaces exposed by that device.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to a caller-allocated buffer that contains, on successful return, a completed <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that identifies an interface that meets the search parameters. The caller must set <i>DeviceInterfaceData</i>.<b>cbSize</b> to <b>sizeof</b>(SP_DEVICE_INTERFACE_DATA) before calling this function.
     * @returns {Integer} <b>SetupDiEnumDeviceInterfaces</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces
     * @since windows5.0
     */
    static SetupDiEnumDeviceInterfaces(DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, MemberIndex, DeviceInterfaceData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiEnumDeviceInterfaces", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", InterfaceClassGuid, "uint", MemberIndex, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDeviceInterface function registers a device interface on a local system or a remote system. (ANSI)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * <b>SetupDiCreateDeviceInterface</b> registers an interface for a device. If a device has more than one interface, call this function once for each interface being registered. 
     * 
     * If this function successfully registers an interface for the device that corresponds to the specified device information element, it also adds the interface to the interface list that is associated with the device information element in the specified device information set.
     * 
     * Before a registered interface can be used by applications and other system components the interface must be enabled by the driver for the device.
     * 
     * This function creates a registry key for the new device interface. Callers of this function can access nonvolatile storage under this key using <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiopendeviceinterfaceregkey">SetupDiOpenDeviceInterfaceRegKey</a>.
     * 
     * If <b>SetupDiCreateDeviceInterface</b> successfully creates a new device interface, but the caller-supplied buffer in the <i>DeviceInterfaceData</i> parameter is invalid, this function will return <b>FALSE</b> and a subsequent call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_USER_BUFFER. However, the function does create and register the new device interface. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDeviceInterface as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>. This set contains a device information element that represents the device for which to register an interface. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Pointer<Guid>} InterfaceClassGuid A pointer to a class GUID that specifies the interface class for the new interface.
     * @param {Pointer<PSTR>} ReferenceString A pointer to a NULL-terminated string that supplies a reference string. This pointer is optional and can be <b>NULL</b>. Reference strings are used only by a few bus drivers that use device interfaces as placeholders for software devices that are created on demand.
     * @param {Integer} CreationFlags Reserved. Must be zero.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to a caller-initialized <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure to receive information about the new device interface. This pointer is optional and can be <b>NULL</b>. If the structure is supplied, the caller must set the <b>cbSize</b> member of this structure to <b>sizeof(</b>SP_DEVICE_INTERFACE_DATA<b>)</b> before calling this function. For more information, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>SetupDiCreateDeviceInterface</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, it returns <b>FALSE</b> and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea
     * @since windows5.0
     */
    static SetupDiCreateDeviceInterfaceA(DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, ReferenceString, CreationFlags, DeviceInterfaceData) {
        ReferenceString := ReferenceString is String? StrPtr(ReferenceString) : ReferenceString

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInterfaceA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", InterfaceClassGuid, "ptr", ReferenceString, "uint", CreationFlags, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDeviceInterface function registers a device interface on a local system or a remote system. (Unicode)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * <b>SetupDiCreateDeviceInterface</b> registers an interface for a device. If a device has more than one interface, call this function once for each interface being registered. 
     * 
     * If this function successfully registers an interface for the device that corresponds to the specified device information element, it also adds the interface to the interface list that is associated with the device information element in the specified device information set.
     * 
     * Before a registered interface can be used by applications and other system components the interface must be enabled by the driver for the device.
     * 
     * This function creates a registry key for the new device interface. Callers of this function can access nonvolatile storage under this key using <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiopendeviceinterfaceregkey">SetupDiOpenDeviceInterfaceRegKey</a>.
     * 
     * If <b>SetupDiCreateDeviceInterface</b> successfully creates a new device interface, but the caller-supplied buffer in the <i>DeviceInterfaceData</i> parameter is invalid, this function will return <b>FALSE</b> and a subsequent call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_USER_BUFFER. However, the function does create and register the new device interface. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDeviceInterface as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>. This set contains a device information element that represents the device for which to register an interface. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Pointer<Guid>} InterfaceClassGuid A pointer to a class GUID that specifies the interface class for the new interface.
     * @param {Pointer<PWSTR>} ReferenceString A pointer to a NULL-terminated string that supplies a reference string. This pointer is optional and can be <b>NULL</b>. Reference strings are used only by a few bus drivers that use device interfaces as placeholders for software devices that are created on demand.
     * @param {Integer} CreationFlags Reserved. Must be zero.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to a caller-initialized <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure to receive information about the new device interface. This pointer is optional and can be <b>NULL</b>. If the structure is supplied, the caller must set the <b>cbSize</b> member of this structure to <b>sizeof(</b>SP_DEVICE_INTERFACE_DATA<b>)</b> before calling this function. For more information, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>SetupDiCreateDeviceInterface</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, it returns <b>FALSE</b> and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacew
     * @since windows5.0
     */
    static SetupDiCreateDeviceInterfaceW(DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, ReferenceString, CreationFlags, DeviceInterfaceData) {
        ReferenceString := ReferenceString is String? StrPtr(ReferenceString) : ReferenceString

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInterfaceW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", InterfaceClassGuid, "ptr", ReferenceString, "uint", CreationFlags, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenDeviceInterface function retrieves information about a device interface and adds the interface to the specified device information set for a local system or a remote system. (ANSI)
     * @remarks
     * If a device interface element for the interface already exists in <i>DeviceInfoSet</i>, <b>SetupDiOpenDeviceInterface</b> updates the flags. Therefore, this function can be used to update the flags for a device interface. For example, an interface might have been inactive when it was first opened, but has subsequently become active. If the device information element for the underlying device is not already present in <i>DeviceInfoSet</i>, this function creates one and adds it to <i>DeviceInfoSet</i>. 
     * 
     * If the function successfully opens the new device interface but the caller did not supply a valid structure in the <i>DeviceInterfaceData</i> parameter, the function will return <b>FALSE</b> and a subsequent call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_USER_BUFFER. However, in this situation, <b>SetupDiOpenDeviceInterface</b> does add the requested interface to the device information set.
     * 
     * If the new device interface is successfully opened, but the caller-supplied <i>DeviceInterfaceData</i> buffer is invalid, this function returns <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_USER_BUFFER. The caller's buffer error does not prevent the interface from being opened.
     * 
     * If the DIODI_NO_ADD flag is specified for the <i>OpenFlags</i> parameter, and a device information element for the underlying device is not already present in the specified <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>, this function returns <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_SUCH_DEVICE_INTERFACE. 
     * 
     * When the application has finished using the information that <b>SetupDiOpenDeviceInterface</b> retrieved<b>,</b> the application must call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdideletedeviceinterfacedata">SetupDiDeleteDeviceInterfaceData</a>.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/medfound/mf-devsource-attribute-source-type-vidcap-symbolic-link">MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK</a> attribute can be passed in as the value of the <i>DevicePath</i> argument of the <b>SetupDiOpenDeviceInterface</b> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiOpenDeviceInterface as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains, or will contain, a device information element that represents the device that supports the interface to open.
     * @param {Pointer<PSTR>} DevicePath A pointer to a NULL-terminated string that supplies the name of the device interface to be opened. This name is a Win32 device path that is typically received in a PnP notification structure or obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a> and its related functions.
     * @param {Integer} OpenFlags Flags that determine how the device interface element is to be opened. The only valid flag is as follows:
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to a caller-initialized  <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that receives the requested interface data. This pointer is optional and can be <b>NULL</b>. If a buffer is supplied, the caller must set the <b>cbSize</b> member of the structure to <b>sizeof(</b>SP_DEVICE_INTERFACE_DATA<b>)</b> before calling <b>SetupDiOpenDeviceInterface</b>. For more information, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>SetupDiOpenDeviceInterface</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, it returns <b>FALSE</b> and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendeviceinterfacea
     * @since windows5.0
     */
    static SetupDiOpenDeviceInterfaceA(DeviceInfoSet, DevicePath, OpenFlags, DeviceInterfaceData) {
        DevicePath := DevicePath is String? StrPtr(DevicePath) : DevicePath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInterfaceA", "ptr", DeviceInfoSet, "ptr", DevicePath, "uint", OpenFlags, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenDeviceInterface function retrieves information about a device interface and adds the interface to the specified device information set for a local system or a remote system. (Unicode)
     * @remarks
     * If a device interface element for the interface already exists in <i>DeviceInfoSet</i>, <b>SetupDiOpenDeviceInterface</b> updates the flags. Therefore, this function can be used to update the flags for a device interface. For example, an interface might have been inactive when it was first opened, but has subsequently become active. If the device information element for the underlying device is not already present in <i>DeviceInfoSet</i>, this function creates one and adds it to <i>DeviceInfoSet</i>. 
     * 
     * If the function successfully opens the new device interface but the caller did not supply a valid structure in the <i>DeviceInterfaceData</i> parameter, the function will return <b>FALSE</b> and a subsequent call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INVALID_USER_BUFFER. However, in this situation, <b>SetupDiOpenDeviceInterface</b> does add the requested interface to the device information set.
     * 
     * If the new device interface is successfully opened, but the caller-supplied <i>DeviceInterfaceData</i> buffer is invalid, this function returns <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_USER_BUFFER. The caller's buffer error does not prevent the interface from being opened.
     * 
     * If the DIODI_NO_ADD flag is specified for the <i>OpenFlags</i> parameter, and a device information element for the underlying device is not already present in the specified <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>, this function returns <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_SUCH_DEVICE_INTERFACE. 
     * 
     * When the application has finished using the information that <b>SetupDiOpenDeviceInterface</b> retrieved<b>,</b> the application must call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdideletedeviceinterfacedata">SetupDiDeleteDeviceInterfaceData</a>.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/medfound/mf-devsource-attribute-source-type-vidcap-symbolic-link">MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK</a> attribute can be passed in as the value of the <i>DevicePath</i> argument of the <b>SetupDiOpenDeviceInterface</b> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiOpenDeviceInterface as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains, or will contain, a device information element that represents the device that supports the interface to open.
     * @param {Pointer<PWSTR>} DevicePath A pointer to a NULL-terminated string that supplies the name of the device interface to be opened. This name is a Win32 device path that is typically received in a PnP notification structure or obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a> and its related functions.
     * @param {Integer} OpenFlags Flags that determine how the device interface element is to be opened. The only valid flag is as follows:
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to a caller-initialized  <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that receives the requested interface data. This pointer is optional and can be <b>NULL</b>. If a buffer is supplied, the caller must set the <b>cbSize</b> member of the structure to <b>sizeof(</b>SP_DEVICE_INTERFACE_DATA<b>)</b> before calling <b>SetupDiOpenDeviceInterface</b>. For more information, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>SetupDiOpenDeviceInterface</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, it returns <b>FALSE</b> and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendeviceinterfacew
     * @since windows5.0
     */
    static SetupDiOpenDeviceInterfaceW(DeviceInfoSet, DevicePath, OpenFlags, DeviceInterfaceData) {
        DevicePath := DevicePath is String? StrPtr(DevicePath) : DevicePath

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInterfaceW", "ptr", DeviceInfoSet, "ptr", DevicePath, "uint", OpenFlags, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfaceAlias function returns an alias of a specified device interface.
     * @remarks
     * Device interfaces are considered aliases if they are of different interface classes but are supported by the same device and have identical reference strings.
     * 
     * <b>SetupDiGetDeviceInterfaceAlias</b> can be used to locate a device that exposes more than one interface. For example, consider a disk that can be part of a fault-tolerant volume and can contain encrypted data. The function driver for the disk device could register a fault-tolerant-volume interface and an encrypted-volume interface. These interfaces are device interface aliases if the function driver registers them with identical reference strings and they refer to the same device. (The reference strings will likely be <b>NULL</b> and therefore are equal.)
     * 
     * To locate such a multi-interface device, first locate all available devices that expose one of the interfaces, such as the fault-tolerant-volume interface, using <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a> and <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>. Then, pass a device with the first interface (fault-tolerant-volume) to <b>SetupDiGetDeviceInterfaceAlias</b> and request an alias of the other interface class (encrypted-volume). 
     * 
     * If the requested alias exists but the caller-supplied <i>AliasDeviceInterfaceData</i> buffer is invalid, this function successfully adds the device interface element to <i>DevInfoSet</i> but returns <b>FALSE</b> for the return value. In this case, <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_USER_BUFFER.
     * @param {Pointer} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface for which to retrieve an alias. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i> for which to retrieve an alias. This pointer is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @param {Pointer<Guid>} AliasInterfaceClassGuid A pointer to a GUID that specifies the interface class of the alias to retrieve.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} AliasDeviceInterfaceData A pointer to a caller-allocated buffer that contains, on successful return, a completed <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that identifies the requested alias. The caller must set <i>AliasDeviceInterfaceData</i><b>.cbSize</b> to <b>sizeof</b>(SP_DEVICE_INTERFACE_DATA) before calling this function.
     * @returns {Integer} <b>SetupDiGetDeviceInterfaceAlias</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Possible errors returned by <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> are listed in the following table.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid <i>DeviceInfoSet</i> or invalid <i>DeviceInterfaceData</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_DEVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no alias of class <i>AliasInterfaceClassGuid</i> for the specified device interface.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid <i>AliasDeviceInterfaceData</i> buffer. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinterfacealias
     * @since windows5.0
     */
    static SetupDiGetDeviceInterfaceAlias(DeviceInfoSet, DeviceInterfaceData, AliasInterfaceClassGuid, AliasDeviceInterfaceData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfaceAlias", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", AliasInterfaceClassGuid, "ptr", AliasDeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDeleteDeviceInterfaceData function deletes a device interface from a device information set.
     * @remarks
     * <b>SetupDiDeleteDeviceInterfaceData</b> deletes a device interface element from a device information set. This function has no effect on the device interface or the underlying device.
     * @param {Pointer} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface to delete. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the interface in <i>DeviceInfoSet</i> to delete. This structure is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @returns {Integer} <b>SetupDiDeleteDeviceInterfaceData</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, it returns <b>FALSE</b> and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdideletedeviceinterfacedata
     * @since windows5.0
     */
    static SetupDiDeleteDeviceInterfaceData(DeviceInfoSet, DeviceInterfaceData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDeleteDeviceInterfaceData", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRemoveDeviceInterface function removes a registered device interface from the system.
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * <b>SetupDiRemoveDeviceInterface</b> removes the specified device interface from the system. This includes deleting the associated registry key. 
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdideletedeviceinterfacedata">SetupDiDeleteDeviceInterfaceData</a> to delete the interface from a device information list.
     * 
     * A device interface must be disabled to be removed. If the interface is enabled, this function fails and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_DEVICE_INTERFACE_ACTIVE. Disable an interface by using whatever interface-specific mechanism is provided (for example, an IOCTL). If the caller has no way to disable an interface and the interface must be removed, the caller must stop the underlying device by using <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdichangestate">SetupDiChangeState</a>. Stopping the device disables all the interfaces exposed by the device.
     * @param {Pointer} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface to remove. This handle is typically returned by <b>SetupDiGetClassDevs</b>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i> to remove. This pointer is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * 
     * After the interface is removed, this function sets the SPINT_REMOVED flag in <i>DeviceInterfaceData</i><b>.Flags</b>. It also clears the SPINT_ACTIVE flag, but be aware that this flag should have already been cleared before this function was called.
     * @returns {Integer} <b>SetupDiRemoveDeviceInterface</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, it returns <b>FALSE</b> and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiremovedeviceinterface
     * @since windows5.0
     */
    static SetupDiRemoveDeviceInterface(DeviceInfoSet, DeviceInterfaceData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiRemoveDeviceInterface", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfaceDetail function returns details about a device interface. (ANSI)
     * @remarks
     * Using this function to get details about an interface is typically a two-step process:
     * 
     * <ol>
     * <li>
     * Get the required buffer size. Call <b>SetupDiGetDeviceInterfaceDetail</b> with a <b>NULL</b><i>DeviceInterfaceDetailData</i> pointer, a <i>DeviceInterfaceDetailDataSize</i> of zero, and a valid <i>RequiredSize</i> variable. In response to such a call, this function returns the required buffer size at <i>RequiredSize</i> and fails with <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning ERROR_INSUFFICIENT_BUFFER.
     * 
     * </li>
     * <li>
     * Allocate an appropriately sized buffer and call the function again to get the interface details.
     * 
     * </li>
     * </ol>
     * The interface detail returned by this function consists of a device path that can be passed to Win32 functions such as <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>. Do not attempt to parse the device path symbolic name. The device path can be reused across system starts.
     * 
     * <b>SetupDiGetDeviceInterfaceDetail</b> can be used to get just the <i>DeviceInfoData</i>. If the interface exists but <i>DeviceInterfaceDetailData</i> is <b>NULL</b>, this function fails, <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER, and the <i>DeviceInfoData</i> structure is filled with information about the device that exposes the interface.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceInterfaceDetail as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface for which to retrieve details. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the interface in <i>DeviceInfoSet</i> for which to retrieve details. A pointer of this type is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DETAIL_DATA_A>} DeviceInterfaceDetailData A pointer to an <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_device_interface_detail_data_a">SP_DEVICE_INTERFACE_DETAIL_DATA</a> structure to receive information about the specified interface. This parameter is optional and can be <b>NULL</b>. This parameter must be <b>NULL</b> if <i>DeviceInterfaceDetailSize</i> is zero. If this parameter is specified, the caller must set <i>DeviceInterfaceDetailData</i><b>.cbSize</b> to <b>sizeof</b>(SP_DEVICE_INTERFACE_DETAIL_DATA) before calling this function. The <b>cbSize</b> member always contains the size of the fixed part of the data structure, not a size reflecting the variable-length string at the end.
     * @param {Integer} DeviceInterfaceDetailDataSize The size of the <i>DeviceInterfaceDetailData</i> buffer. The buffer must be at least (<b>offsetof</b>(SP_DEVICE_INTERFACE_DETAIL_DATA, <b>DevicePath</b>) + <b>sizeof</b>(TCHAR)) bytes, to contain the fixed part of the structure and a single <b>NULL</b> to terminate an empty MULTI_SZ string. 
     * 
     * This parameter must be zero if <i>DeviceInterfaceDetailData</i> is <b>NULL</b>.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the required size of the <i>DeviceInterfaceDetailData</i> buffer. This size includes the size of the fixed part of the structure plus the number of bytes required for the variable-length device path string. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a buffer that receives information about the device that supports the requested interface. The caller must set <i>DeviceInfoData</i><b>.cbSize</b> to <b>sizeof</b>(SP_DEVINFO_DATA). This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} <b>SetupDiGetDeviceInterfaceDetail</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinterfacedetaila
     * @since windows5.0
     */
    static SetupDiGetDeviceInterfaceDetailA(DeviceInfoSet, DeviceInterfaceData, DeviceInterfaceDetailData, DeviceInterfaceDetailDataSize, RequiredSize, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfaceDetailA", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", DeviceInterfaceDetailData, "uint", DeviceInterfaceDetailDataSize, "ptr", RequiredSize, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfaceDetail function returns details about a device interface. (Unicode)
     * @remarks
     * Using this function to get details about an interface is typically a two-step process:
     * 
     * <ol>
     * <li>
     * Get the required buffer size. Call <b>SetupDiGetDeviceInterfaceDetail</b> with a <b>NULL</b><i>DeviceInterfaceDetailData</i> pointer, a <i>DeviceInterfaceDetailDataSize</i> of zero, and a valid <i>RequiredSize</i> variable. In response to such a call, this function returns the required buffer size at <i>RequiredSize</i> and fails with <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning ERROR_INSUFFICIENT_BUFFER.
     * 
     * </li>
     * <li>
     * Allocate an appropriately sized buffer and call the function again to get the interface details.
     * 
     * </li>
     * </ol>
     * The interface detail returned by this function consists of a device path that can be passed to Win32 functions such as <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>. Do not attempt to parse the device path symbolic name. The device path can be reused across system starts.
     * 
     * <b>SetupDiGetDeviceInterfaceDetail</b> can be used to get just the <i>DeviceInfoData</i>. If the interface exists but <i>DeviceInterfaceDetailData</i> is <b>NULL</b>, this function fails, <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER, and the <i>DeviceInfoData</i> structure is filled with information about the device that exposes the interface.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceInterfaceDetail as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface for which to retrieve details. This handle is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the interface in <i>DeviceInfoSet</i> for which to retrieve details. A pointer of this type is typically returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @param {Pointer<SP_DEVICE_INTERFACE_DETAIL_DATA_W>} DeviceInterfaceDetailData A pointer to an <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_device_interface_detail_data_a">SP_DEVICE_INTERFACE_DETAIL_DATA</a> structure to receive information about the specified interface. This parameter is optional and can be <b>NULL</b>. This parameter must be <b>NULL</b> if <i>DeviceInterfaceDetailSize</i> is zero. If this parameter is specified, the caller must set <i>DeviceInterfaceDetailData</i><b>.cbSize</b> to <b>sizeof</b>(SP_DEVICE_INTERFACE_DETAIL_DATA) before calling this function. The <b>cbSize</b> member always contains the size of the fixed part of the data structure, not a size reflecting the variable-length string at the end.
     * @param {Integer} DeviceInterfaceDetailDataSize The size of the <i>DeviceInterfaceDetailData</i> buffer. The buffer must be at least (<b>offsetof</b>(SP_DEVICE_INTERFACE_DETAIL_DATA, <b>DevicePath</b>) + <b>sizeof</b>(TCHAR)) bytes, to contain the fixed part of the structure and a single <b>NULL</b> to terminate an empty MULTI_SZ string. 
     * 
     * This parameter must be zero if <i>DeviceInterfaceDetailData</i> is <b>NULL</b>.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the required size of the <i>DeviceInterfaceDetailData</i> buffer. This size includes the size of the fixed part of the structure plus the number of bytes required for the variable-length device path string. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to a buffer that receives information about the device that supports the requested interface. The caller must set <i>DeviceInfoData</i><b>.cbSize</b> to <b>sizeof</b>(SP_DEVINFO_DATA). This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} <b>SetupDiGetDeviceInterfaceDetail</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinterfacedetailw
     * @since windows5.0
     */
    static SetupDiGetDeviceInterfaceDetailW(DeviceInfoSet, DeviceInterfaceData, DeviceInterfaceDetailData, DeviceInterfaceDetailDataSize, RequiredSize, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfaceDetailW", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", DeviceInterfaceDetailData, "uint", DeviceInterfaceDetailDataSize, "ptr", RequiredSize, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallDeviceInterfaces function is the default handler for the DIF_INSTALLINTERFACES installation request.
     * @remarks
     * <b>SetupDiInstallDeviceInterfaces</b> processes each <b>AddInterface</b> entry in the <i>DDInstall</i>.<b>Interfaces</b> section of a device INF file and creates each interface by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea">SetupDiCreateDeviceInterface</a>.
     * 
     * The caller of <b>SetupDiInstallDeviceInterfaces</b> must be a member of the Administrators group. 
     * 
     * <div class="alert"><b>Note</b>Only a <a href="https://docs.microsoft.com/windows-hardware/drivers/">class installer</a> should call <b>SetupDiInstallDeviceInterfaces</b> and only in those situations where the class installer must perform device interface installation operations after <b>SetupDiInstallDeviceInterfaces</b> completes the default device interface installation operation. In such situations, the class installer must directly call <b>SetupDiInstallDeviceInterfaces</b> when the installer processes a DIF_INSTALLINTERFACES request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * For information about INF file format, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-file-sections-and-directives">INF File Sections and Directives</a>.
     * @param {Pointer} DeviceInfoSet A pointer to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to install interfaces. The device information set must contain only elements for the local system.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @returns {Integer} <b>SetupDiInstallDeviceInterfaces</b> returns <b>TRUE</b> if the function completed without error. If the function completed with an error, <b>FALSE</b> is returned and the error code for the failure can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstalldeviceinterfaces
     * @since windows5.0
     */
    static SetupDiInstallDeviceInterfaces(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallDeviceInterfaces", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceInterfaceDefault function sets a device interface as the default interface for a device interface class.
     * @remarks
     * A caller must have Administrator privileges to set the default interface for a device interface class. However, if the requested default interface is the same as the currently set default interface, the function returns <b>TRUE</b> regardless of whether the caller has Administrator privileges. 
     * 
     * If the function successfully sets the specified device interface as the default for the device class, it updates the Flags member of the supplied SP_DEVICE_INTERFACE_DATA structure.
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a> to obtain a <i>DevInfoSet</i> handle to a device information set that contains the device interface to set as the default for a device interface class. To obtain the <i>DeviceInterfaceData </i> pointer to the device interface element, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a> to enumerate the interfaces in the device information set. To retrieve information about an enumerated interface, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinterfacedetaila">SetupDiGetDeviceInterfaceDetail</a>.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface to set as the default for a device interface class.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i>.
     * @param {Integer} Flags Not used, must be zero.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceinterfacedefault
     * @since windows5.1.2600
     */
    static SetupDiSetDeviceInterfaceDefault(DeviceInfoSet, DeviceInterfaceData, Flags) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceInterfaceDefault", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Flags, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRegisterDeviceInfo function is the default handler for the DIF_REGISTERDEVICE request.
     * @remarks
     * <b>SetupDiRegisterDeviceInfo</b> is primarily designed to register a non-PnP device with the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/pnp-manager">Plug and Play (PnP) manager</a> on a local computer. Although <b>SetupDiRegisterDeviceInfo</b> will not fail if the device information set is for a remote computer, the result is of limited use because the device information set cannot subsequently be used with DIF_<i>Xxx</i> installation requests or <b>SetupDi</b><i>Xxx</i> functions that do not support operations on a remote computer. For example, calling <b>SetupDiCreateDevRegKey</b> to execute an INF section for a newly registered device on a remote computer will fail.
     * 
     * <div class="alert"><b>Note</b>Only a class installer should call <b>SetupDiRegisterDeviceInfo</b> and only in those situations where the class installer must perform device registration operations after <b>SetupDiRegisterDeviceInfo</b> completes the default device registration operation. In such situations, the class installer must directly call <b>SetupDiRegisterDeviceInfo</b> when the installer processes a DIF_REGISTERDEVICE request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * After registering a device information element, the caller should update any stored copies of the <b>DevInst</b> handle associated with this device. This is necessary because the handle value might have changed during registration. The caller does not have to retrieve the SP_DEVINFO_DATA structure again because the <b>DevInst</b> field of the structure is updated to reflect the current value of the handle. 
     * 
     * Do not directly call this function for PnP device instances. PnP device instances are automatically registered by the operating system. However, you must register non-PnP device instances in one of the following ways:
     * 
     * <ol>
     * <li>
     * If your installation application uses a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-detect">DIF_DETECT</a> request to successfully detect a device, it should also use a DIF_REGISTERDEVICE request to register the device instance. The request should be handled in the default manner. (By default, <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicallclassinstaller">SetupDiCallClassInstaller</a> first calls the class installer and class co-installers to do duplicate detection and register the device instance. If these installers do not register the device instance, <b>SetupDiCallClassInstaller</b> calls <b>SetupDiRegisterDeviceInfo</b> to do duplicate detection and register the device instance.)
     * 
     * </li>
     * <li>
     * If your installation application creates a device instance (for example, by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinfoa">SetupDiCreateDeviceInfo</a>) but does not do duplicate detection, your installation application should use a DIF_REGISTERDEVICE request to register the device instance. The request should be handled in the default manner as described earlier.
     * 
     * </li>
     * <li>
     * If your installation application creates a new device and does duplicate detection, your installation application should use a DIF_REGISTERDEVICE request but should prevent <b>SetupDiCallClassInstaller</b> from calling <b>SetupDiRegisterDeviceInfo</b>. To prevent <b>SetupDiCallClassInstaller</b> from calling <b>SetupDiRegisterDeviceInfo</b>, set the DI_NODI_DEFAULTACTION flag in the <b>Flags</b> member of the SP_DEVINSTALL_PARAMS structure for the device instance.
     * 
     * If <b>SetupDiCallClassInstaller</b> returns <b>TRUE</b> for the DIF_REGISTERDEVICE request, the class installer or class co-installers registered the device instance. In this case, the installation application can continue to install the device.
     * 
     * If <b>SetupDiCallClassInstaller</b> returns <b>FALSE</b> for the DIF_REGISTERDEVICE request, the class installer or class co-installers did not register the device instance. In this case, the installation application should do one of the following, depending on the last error that <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns for the request:
     * 
     * <ul>
     * <li>If the last error is ERROR_DI_DO_DEFAULT, the installation application can directly call <b>SetupDiRegisterDeviceInfo</b> and supply a <i>CompareProc</i> to do duplicate detection. If this call is successful and no duplicates are found, device installation can continue. If a duplicate is found, <b>SetupDiRegisterDeviceInfo</b> returns <b>FALSE</b>, and the installation application must terminate device installation.</li>
     * <li>If the last error is not ERROR_DI_DO_DEFAULT, the installation application must terminate device installation.</li>
     * </ul>
     * The caller of <b>SetupDiRegisterDeviceInfo</b> must be a member of the Administrators group.
     * 
     * </li>
     * </ol>
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device to register. The device information set must not contain any remote elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoData.</i><b>DevInst</b> might be updated with a new handle value upon return.
     * @param {Integer} Flags A flag value that controls how the device is registered, which can be zero or the following value:
     * @param {Pointer<PSP_DETSIG_CMPPROC>} CompareProc A pointer to a comparison callback function to use in duplicate detection. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, the callback function is called for each device instance that is of the same class as the device instance that is being registered. The prototype of the callback function is as follows:
     * 
     * 
     * ```
     * typedef  DWORD (CALLBACK* PSP_DETSIG_CMPPROC) (
     *     IN HDEVINFO  DeviceInfoSet,
     *     IN PSP_DEVINFO_DATA  NewDeviceData,
     *     IN PSP_DEVINFO_DATA  ExistingDeviceData,
     *     IN PVOID  CompareContextOPTIONAL
     *     );
     * ```
     * 
     * 
     * The compare function must return ERROR_DUPLICATE_FOUND if it finds that the two devices are duplicates. Otherwise, it should return NO_ERROR. If some other error is encountered, the callback function should return the appropriate ERROR_* code to indicate the failure.
     * 
     * If <i>CompareProc</i> is not specified and duplication detection is requested, a default comparison behavior is used. The default is to compare the new device's detect signature with the detect signature of all other devices in the class. The detect signature is contained in the class-specific resource descriptor of the device's boot log configuration.
     * @param {Pointer<Void>} CompareContext A pointer to a caller-supplied context buffer that is passed into the callback function. This parameter is ignored if <i>CompareProc</i> is not specified.
     * @param {Pointer<SP_DEVINFO_DATA>} DupDeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure to receive information about a duplicate device instance, if any, discovered as a result of attempting to register this device. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, the caller must set <i>DupDeviceInfoData.</i><b>cbSize</b> to <b>sizeof</b>(SP_DEVINFO_DATA). This will be filled in if the function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_DUPLICATE_FOUND. This device information element is added as a member of the specified <i>DeviceInfoSet</i>, if not already a member. If <i>DupDeviceInfoData</i> is not specified, the duplicate is not added to the device information set.
     * 
     * If you call this function when handling a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-registerdevice">DIF_REGISTERDEVICE</a> request, the <i>DupDeviceInfoData</i> parameter must be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiregisterdeviceinfo
     * @since windows5.0
     */
    static SetupDiRegisterDeviceInfo(DeviceInfoSet, DeviceInfoData, Flags, CompareProc, CompareContext, DupDeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiRegisterDeviceInfo", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Flags, "ptr", CompareProc, "ptr", CompareContext, "ptr", DupDeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiBuildDriverInfoList function builds a list of drivers that is associated with a specific device or with the global class driver list for a device information set.
     * @remarks
     * The device information set should be for a local computer because <b>SetupDiBuildDriverInfoList</b> searches for drivers only on a local computer. If the device information set is for a remote computer, the function returns <b>TRUE</b> but does not actually update the existing driver list for the device information set or, if supplied, the driver list for the device information element.
     * 
     * The caller can set <b>Flags</b> in the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> that are associated with the device information set or with a specific device (<i>DeviceInfoData</i>) to control how the list is built. For example, the caller can set the <b>DI_FLAGSEX_ALLOWEXCLUDEDDRVS</b> flag to include drivers that are marked Exclude From Select.
     * 
     * A driver is "Exclude From Select" if either it is marked <b>ExcludeFromSelect</b> in the INF file or it is a driver for a device whose whole setup class is marked <b>NoInstallClass</b> or <b>NoUseClass</b> in the class installer INF file. Drivers for PnP devices are typically "Exclude From Select"; PnP devices should not be manually installed. To build a list of driver files for a PnP device a caller of <b>SetupDiBuildDriverInfoList</b> must set this flag. 
     * 
     * The <b>DriverPath</b> in the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> contains either a path of a directory that contain INF files or a path of a specific INF file. If <b>DI_ENUMSINGLEINF</b> is set, <b>DriverPath</b> contains a path of a single INF file. If <b>DriverPath</b> is <b>NULL</b>, this function builds the driver list from the default INF file location, %SystemRoot%\inf. 
     * 
     * After this function has built the specified driver list, the caller can enumerate the elements of the list by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdriverinfoa">SetupDiEnumDriverInfo</a>.
     * 
     * If the driver list is associated with a device instance (that is, <i>DeviceInfoData</i> is specified), the resulting list is composed of drivers that have the same class as the device instance with which they are associated. If this is a global class driver list (that is, <i>DriverType</i> is <b>SPDIT_CLASSDRIVER</b> and <i>DeviceInfoData</i> is not specified), the class that is used when building the list is the class associated with the device information set. If the device information set has no associated class, drivers of all classes are used when building the list.
     * 
     * Another thread can terminate the building of a driver list by a call to <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicanceldriverinfosearch">SetupDiCancelDriverInfoSearch</a>.
     * 
     * The <i>DeviceInfoSet</i> must only contain elements on the local computer. This function only searches for local drivers.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to contain the driver list, either globally for all device information elements or specifically for a single device information element. The device information set must not contain remote device information elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for the device information element in <i>DeviceInfoSet</i> that represents the device for which to build a driver list. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, the list is associated with the specified device. If this parameter is <b>NULL</b>, the list is associated with the global class driver list for <i>DeviceInfoSet</i>. 
     * 
     * If the class of this device is updated because of building a compatible driver list, <i>DeviceInfoData.</i><b>ClassGuid</b> is updated upon return.
     * @param {Integer} DriverType 
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdibuilddriverinfolist
     * @since windows5.0
     */
    static SetupDiBuildDriverInfoList(DeviceInfoSet, DeviceInfoData, DriverType) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiBuildDriverInfoList", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", DriverType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCancelDriverInfoSearch function cancels a driver list search that is currently in progress in a different thread.
     * @remarks
     * <b>SetupDiCancelDriverInfoSearch</b> is a synchronous call. Therefore, it does not return until the driver search thread responds to the termination request.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which a driver list is being built.
     * @returns {Integer} If a driver list search is underway for the specified device information set when this function is called, the search is terminated. <b>SetupDiCancelDriverInfoSearch</b> returns <b>TRUE</b> when the termination is confirmed. Otherwise, it returns <b>FALSE</b> and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_HANDLE.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicanceldriverinfosearch
     * @since windows5.0
     */
    static SetupDiCancelDriverInfoSearch(DeviceInfoSet) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCancelDriverInfoSearch", "ptr", DeviceInfoSet, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiEnumDriverInfo function enumerates the members of a driver list. (ANSI)
     * @remarks
     * To enumerate driver information set members, an installer should first call <b>SetupDiEnumDriverInfo</b> with the <i>MemberIndex</i> parameter set to 0. It should then increment <i>MemberIndex</i> and call <b>SetupDiEnumDriverInfo</b> until there are no more values. When there are no more values, the function fails and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_MORE_ITEMS.
     * 
     * If you do not properly initialize the <b>cbSize</b> member of the SP_DRVINFO_DATA structure that is supplied by the pointer <i>DriverInfoData</i>, the function will fail and log the error ERROR_INVALID_USER_BUFFER.
     * 
     * To build a list of drivers associated with a specific device or with the global class driver list for a device information set first use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdibuilddriverinfolist">SetupDiBuildDriverInfoList</a> then pass that list to <b>SetupDiEnumDriverInfo</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiEnumDriverInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the driver list to enumerate.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiEnumDriverInfo</b> enumerates a driver list for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiEnumDriverInfo</b> enumerates the global class driver list that is associated with <i>DeviceInfoSet</i> (this list is of type SPDIT_CLASSDRIVER).
     * @param {Integer} DriverType 
     * @param {Integer} MemberIndex The zero-based index of the driver information member to retrieve.
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData A pointer to a caller-initialized <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v2_a">SP_DRVINFO_DATA</a> structure that receives information about the enumerated driver. The caller must set <i>DriverInfoData.</i><b>cbSize</b> to <b>sizeof(</b>SP_DRVINFO_DATA<b>)</b> before calling <b>SetupDiEnumDriverInfo</b>. If the <b>cbSize</b> member is not properly set, <b>SetupDiEnumDriverInfo</b> will return <b>FALSE</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdienumdriverinfoa
     * @since windows5.0
     */
    static SetupDiEnumDriverInfoA(DeviceInfoSet, DeviceInfoData, DriverType, MemberIndex, DriverInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiEnumDriverInfoA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", DriverType, "uint", MemberIndex, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiEnumDriverInfo function enumerates the members of a driver list. (Unicode)
     * @remarks
     * To enumerate driver information set members, an installer should first call <b>SetupDiEnumDriverInfo</b> with the <i>MemberIndex</i> parameter set to 0. It should then increment <i>MemberIndex</i> and call <b>SetupDiEnumDriverInfo</b> until there are no more values. When there are no more values, the function fails and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_MORE_ITEMS.
     * 
     * If you do not properly initialize the <b>cbSize</b> member of the SP_DRVINFO_DATA structure that is supplied by the pointer <i>DriverInfoData</i>, the function will fail and log the error ERROR_INVALID_USER_BUFFER.
     * 
     * To build a list of drivers associated with a specific device or with the global class driver list for a device information set first use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdibuilddriverinfolist">SetupDiBuildDriverInfoList</a> then pass that list to <b>SetupDiEnumDriverInfo</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiEnumDriverInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the driver list to enumerate.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiEnumDriverInfo</b> enumerates a driver list for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiEnumDriverInfo</b> enumerates the global class driver list that is associated with <i>DeviceInfoSet</i> (this list is of type SPDIT_CLASSDRIVER).
     * @param {Integer} DriverType 
     * @param {Integer} MemberIndex The zero-based index of the driver information member to retrieve.
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData A pointer to a caller-initialized <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v2_w">SP_DRVINFO_DATA</a> structure that receives information about the enumerated driver. The caller must set <i>DriverInfoData.</i><b>cbSize</b> to <b>sizeof(</b>SP_DRVINFO_DATA<b>)</b> before calling <b>SetupDiEnumDriverInfo</b>. If the <b>cbSize</b> member is not properly set, <b>SetupDiEnumDriverInfo</b> will return <b>FALSE</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdienumdriverinfow
     * @since windows5.0
     */
    static SetupDiEnumDriverInfoW(DeviceInfoSet, DeviceInfoData, DriverType, MemberIndex, DriverInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiEnumDriverInfoW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", DriverType, "uint", MemberIndex, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetSelectedDriver function retrieves the selected driver for a device information set or a particular device information element. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetSelectedDriver as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to retrieve a selected driver.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element that represents the device in <i>DeviceInfoSet</i> for which to retrieve the selected driver. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetSelectedDriver</b> retrieves the selected driver for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetSelectedDriver</b> retrieves the selected class driver in the global class driver list that is associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that receives information about the selected driver.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If a driver has not been selected for the specified device instance, the logged error is ERROR_NO_DRIVER_SELECTED.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetselecteddrivera
     * @since windows5.0
     */
    static SetupDiGetSelectedDriverA(DeviceInfoSet, DeviceInfoData, DriverInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetSelectedDriverA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetSelectedDriver function retrieves the selected driver for a device information set or a particular device information element. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetSelectedDriver as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to retrieve a selected driver.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element that represents the device in <i>DeviceInfoSet</i> for which to retrieve the selected driver. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetSelectedDriver</b> retrieves the selected driver for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetSelectedDriver</b> retrieves the selected class driver in the global class driver list that is associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that receives information about the selected driver.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If a driver has not been selected for the specified device instance, the logged error is ERROR_NO_DRIVER_SELECTED.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetselecteddriverw
     * @since windows5.0
     */
    static SetupDiGetSelectedDriverW(DeviceInfoSet, DeviceInfoData, DriverInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetSelectedDriverW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetSelectedDriver function sets, or resets, the selected driver for a device information element or the selected class driver for a device information set. (ANSI)
     * @remarks
     * If the caller of <b>SetupDiSetSelectedDriver</b> is a member of the Administrators group, the class of the device is set to the class of the selected driver, provided that the two classes are different.
     * 
     * If <i>DriverInfoData</i> is <b>NULL</b>, <b>SetupDiSetSelectedDriver</b> resets the selected driver. As a result, there is no selected driver. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetSelectedDriver as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the driver list from which to select a driver for a device information element or for the device information set.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSetSelectedDriver</b> sets, or resets, the selected driver for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetSelectedDriver</b> sets, or resets, the selected class driver for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver to be selected. This parameter is optional and can be <b>NULL</b>. If this parameter and <i>DeviceInfoData</i> are supplied, the specified driver must be a member of a driver list that is associated with <i>DeviceInfoData</i>. If this parameter is specified and <i>DeviceInfoData</i> is <b>NULL</b>, the driver must be a member of the global class driver list for <i>DeviceInfoSet</i>. If this parameter is <b>NULL</b>, the selected driver is reset for the device information element, if <i>DeviceInfoData</i> is specified, or the device information set, if <i>DeviceInfoData</i> is <b>NULL</b>.
     * 
     * If the <i>DriverInfoData.</i><b>Reserved</b> is <b>NULL</b>, the caller is requesting a search for a driver node with the specified parameters (<b>DriverType</b>, <b>Description</b>, and <b>ProviderName</b>). If a match is found, that driver node is selected. The <b>Reserved</b> field is updated on output to reflect the actual driver node where the match was found. If a match is not found, the function fails and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_PARAMETER.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetselecteddrivera
     * @since windows5.0
     */
    static SetupDiSetSelectedDriverA(DeviceInfoSet, DeviceInfoData, DriverInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetSelectedDriverA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetSelectedDriver function sets, or resets, the selected driver for a device information element or the selected class driver for a device information set. (Unicode)
     * @remarks
     * If the caller of <b>SetupDiSetSelectedDriver</b> is a member of the Administrators group, the class of the device is set to the class of the selected driver, provided that the two classes are different.
     * 
     * If <i>DriverInfoData</i> is <b>NULL</b>, <b>SetupDiSetSelectedDriver</b> resets the selected driver. As a result, there is no selected driver. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetSelectedDriver as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the driver list from which to select a driver for a device information element or for the device information set.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSetSelectedDriver</b> sets, or resets, the selected driver for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetSelectedDriver</b> sets, or resets, the selected class driver for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver to be selected. This parameter is optional and can be <b>NULL</b>. If this parameter and <i>DeviceInfoData</i> are supplied, the specified driver must be a member of a driver list that is associated with <i>DeviceInfoData</i>. If this parameter is specified and <i>DeviceInfoData</i> is <b>NULL</b>, the driver must be a member of the global class driver list for <i>DeviceInfoSet</i>. If this parameter is <b>NULL</b>, the selected driver is reset for the device information element, if <i>DeviceInfoData</i> is specified, or the device information set, if <i>DeviceInfoData</i> is <b>NULL</b>.
     * 
     * If the <i>DriverInfoData.</i><b>Reserved</b> is <b>NULL</b>, the caller is requesting a search for a driver node with the specified parameters (<b>DriverType</b>, <b>Description</b>, and <b>ProviderName</b>). If a match is found, that driver node is selected. The <b>Reserved</b> field is updated on output to reflect the actual driver node where the match was found. If a match is not found, the function fails and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_PARAMETER.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetselecteddriverw
     * @since windows5.0
     */
    static SetupDiSetSelectedDriverW(DeviceInfoSet, DeviceInfoData, DriverInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetSelectedDriverW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDriverInfoDetail function retrieves driver information detail for a device information set or a particular device information element in the device information set. (ANSI)
     * @remarks
     * If the specified driver information member and the caller-supplied buffer are both valid, this function is guaranteed to fill in all static fields in the SP_DRVINFO_DETAIL_DATA structure and as many IDs as possible in the variable-length buffer at the end while still maintaining REG_MULTI_SZ format. In this case, the function returns <b>FALSE</b> and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER. If specified, <i>RequiredSize</i> contains the total number of bytes required for the structure with all IDs.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDriverInfoDetail as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a driver information element for which to retrieve driver information.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element that represents the device for which to retrieve driver information. This parameter is optional and can be  <b>NULL</b>. If this parameter is specified, <b>SetupDiGetDriverInfoDetail</b> retrieves information about a driver in a driver list for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetDriverInfoDetail</b> retrieves information about a driver that is a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver information element that represents the driver for which to retrieve details. If <i>DeviceInfoData</i> is specified, the driver must be a member of the driver list for the device that is specified by <i>DeviceInfoData</i>. Otherwise, the driver must be a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DETAIL_DATA_A>} DriverInfoDetailData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_detail_data_a">SP_DRVINFO_DETAIL_DATA</a> structure that receives detailed information about the specified driver. If this parameter is not specified, <i>DriverInfoDetailDataSize</i> must be zero. If this parameter is specified, <i>DriverInfoDetailData.</i><b>cbSize</b> must be set to the value of <b>sizeof(</b>SP_DRVINFO_DETAIL_DATA<b>)</b> before it calls <b>SetupDiGetDriverInfoDetail</b>.
     * 
     * <div class="alert"><b>Note</b><i>DriverInfoDetailData.</i><b>cbSize</b> must not be set to the value of the <i>DriverInfoDetailDataSize </i> parameter<i>.</i></div>
     * <div></div>
     * @param {Integer} DriverInfoDetailDataSize The size, in bytes, of the <i>DriverInfoDetailData</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable that receives the number of bytes required to store the detailed driver information. This value includes both the size of the structure and the additional bytes required for the variable-length character buffer at the end that holds the hardware ID list and the compatible ID list. The lists are in REG_MULTI_SZ format. For information about hardware and compatible IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdriverinfodetaila
     * @since windows5.0
     */
    static SetupDiGetDriverInfoDetailA(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInfoDetailData, DriverInfoDetailDataSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDriverInfoDetailA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInfoDetailData, "uint", DriverInfoDetailDataSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDriverInfoDetail function retrieves driver information detail for a device information set or a particular device information element in the device information set. (Unicode)
     * @remarks
     * If the specified driver information member and the caller-supplied buffer are both valid, this function is guaranteed to fill in all static fields in the SP_DRVINFO_DETAIL_DATA structure and as many IDs as possible in the variable-length buffer at the end while still maintaining REG_MULTI_SZ format. In this case, the function returns <b>FALSE</b> and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER. If specified, <i>RequiredSize</i> contains the total number of bytes required for the structure with all IDs.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDriverInfoDetail as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a driver information element for which to retrieve driver information.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element that represents the device for which to retrieve driver information. This parameter is optional and can be  <b>NULL</b>. If this parameter is specified, <b>SetupDiGetDriverInfoDetail</b> retrieves information about a driver in a driver list for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetDriverInfoDetail</b> retrieves information about a driver that is a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver information element that represents the driver for which to retrieve details. If <i>DeviceInfoData</i> is specified, the driver must be a member of the driver list for the device that is specified by <i>DeviceInfoData</i>. Otherwise, the driver must be a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DETAIL_DATA_W>} DriverInfoDetailData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_detail_data_a">SP_DRVINFO_DETAIL_DATA</a> structure that receives detailed information about the specified driver. If this parameter is not specified, <i>DriverInfoDetailDataSize</i> must be zero. If this parameter is specified, <i>DriverInfoDetailData.</i><b>cbSize</b> must be set to the value of <b>sizeof(</b>SP_DRVINFO_DETAIL_DATA<b>)</b> before it calls <b>SetupDiGetDriverInfoDetail</b>.
     * 
     * <div class="alert"><b>Note</b><i>DriverInfoDetailData.</i><b>cbSize</b> must not be set to the value of the <i>DriverInfoDetailDataSize </i> parameter<i>.</i></div>
     * <div></div>
     * @param {Integer} DriverInfoDetailDataSize The size, in bytes, of the <i>DriverInfoDetailData</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable that receives the number of bytes required to store the detailed driver information. This value includes both the size of the structure and the additional bytes required for the variable-length character buffer at the end that holds the hardware ID list and the compatible ID list. The lists are in REG_MULTI_SZ format. For information about hardware and compatible IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdriverinfodetailw
     * @since windows5.0
     */
    static SetupDiGetDriverInfoDetailW(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInfoDetailData, DriverInfoDetailDataSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDriverInfoDetailW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInfoDetailData, "uint", DriverInfoDetailDataSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDestroyDriverInfoList function deletes a driver list.
     * @remarks
     * If the currently selected driver is a member of the list being deleted, the selection is reset.
     * 
     * If a class driver list is being deleted, the DI_FLAGSEX_DIDINFOLIST and DI_DIDCLASS flags are reset for the corresponding device information set or device information element. The DI_MULTMFGS flags is also reset.
     * 
     * If a compatible driver list is being destroyed, the DI_FLAGSEX_DIDCOMPATINFO and DI_DIDCOMPAT flags are reset for the corresponding device information element.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the driver list to delete.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be set to <b>NULL</b>. If this parameter is specified, <b>SetupDiDestroyDriverInfoList</b> deletes the driver list for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiDestroyDriverInfoList</b> deletes the global class driver list that is associated with <i>DeviceInfoSet</i>.
     * @param {Integer} DriverType 
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdidestroydriverinfolist
     * @since windows5.0
     */
    static SetupDiDestroyDriverInfoList(DeviceInfoSet, DeviceInfoData, DriverType) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDestroyDriverInfoList", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", DriverType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDevs function returns a handle to a device information set that contains requested device information elements for a local computer. (ANSI)
     * @remarks
     * The caller of <b>SetupDiGetClassDevs</b> must delete the returned device information set when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroydeviceinfolist">SetupDiDestroyDeviceInfoList</a>.
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsexa">SetupDiGetClassDevsEx</a> to retrieve the devices for a class on a remote computer.
     * 
     * <h3><a id="device_setup_class_control_options"></a><a id="DEVICE_SETUP_CLASS_CONTROL_OPTIONS"></a>Device Setup Class Control Options</h3>
     * Use the following filtering options to control whether <b>SetupDiGetClassDevs</b> returns devices for all device setup classes or only for a specified device setup class:
     * 
     * <ul>
     * <li>
     * To return devices for all device setup classes, set the DIGCF_ALLCLASSES flag, and set the <i>ClassGuid</i> parameter to <b>NULL</b>.
     * 
     * </li>
     * <li>
     * To return devices only for a specific device setup class, do not set DIGCF_ALLCLASSES, and use <i>ClassGuid</i> to supply the GUID of the device setup class.
     * 
     * </li>
     * </ul>
     * In addition, you can use the following filtering options in combination with one another to further restrict which devices are returned:
     * 
     * <ul>
     * <li>
     * To return only devices that are present in the system, set the DIGCF_PRESENT flag.
     * 
     * </li>
     * <li>
     * To return only devices that are part of the current hardware profile, set the DIGCF_PROFILE flag.
     * 
     * </li>
     * <li>
     * To return devices only for a specific PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>, use the <i>Enumerator</i> parameter to supply the GUID or symbolic name of the enumerator<i>. </i>If <i>Enumerator</i> is <b>NULL</b>, <b>SetupDiGetClassDevs</b> returns devices for all PnP enumerators.
     * 
     * </li>
     * </ul>
     * <h3><a id="device_interface_class_control_options"></a><a id="DEVICE_INTERFACE_CLASS_CONTROL_OPTIONS"></a>Device Interface Class Control Options</h3>
     * Use the following filtering options to control whether <b>SetupDiGetClassDevs</b> returns devices that support any device interface class or only devices that support a specified device interface class:
     * 
     * <ul>
     * <li>
     * To return devices that support a device interface of any class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_ALLCLASSES flag, and set <i>ClassGuid</i> to <b>NULL</b>. The function adds to the device information set a device information element that represents such a device and then adds to the device information element a device interface list that contains all the device interfaces that the device supports.
     * 
     * </li>
     * <li>
     * To return only devices that support a device interface of a specified class, set the DIGCF_DEVICEINTERFACE flag and use the <i>ClassGuid</i> parameter to supply the class GUID of the device interface class. The function adds to the device information set a device information element that represents such a device and then adds a device interface of the specified class to the device interface list for that device information element.
     * 
     * </li>
     * </ul>
     * In addition, you can use the following filtering options to control whether <b>SetupDiGetClassDevs</b> returns only devices that support the system default interface for device interface classes:
     * 
     * <ul>
     * <li>
     * To return only the device that supports the system default interface, if one is set, for a specified device interface class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_DEFAULT flag, and use <i>ClassGuid</i> to supply the class GUID of the device interface class. The function adds to the device information set a device information element that represents such a device and then adds the system default interface to the device interface list for that device information element.
     * 
     * </li>
     * <li>
     * To return a device that supports a system default interface for an unspecified device interface class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_ALLCLASSES flag, set the DIGCF_DEFAULT flag, and set <i>ClassGuid</i> to <b>NULL</b>. The function adds to the device information set a device information element that represents such a device and then adds the system default interface to the device interface list for that device information element.
     * 
     * </li>
     * </ul>
     * You can also use the following options in combination with the other options to further restrict which devices are returned:
     * 
     * <ul>
     * <li>
     * To return only devices that are present in the system, set the DIGCF_PRESENT flag.
     * 
     * </li>
     * <li>
     * To return only devices that are part of the current hardware profile, set the DIGCF_PROFILE flag.
     * 
     * </li>
     * <li>
     * To return only a specific device, set the DIGCF_DEVICEINTERFACE flag and use the <i>Enumerator</i> parameter to supply the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> of the device<i>. </i>To include all possible devices, set <i>Enumerator</i> to <b>NULL</b>.
     * 
     * </li>
     * </ul>
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> or a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>. This pointer is optional and can be <b>NULL</b>. For more information about how to set <i>ClassGuid</i>, see the following <b>Remarks</b> section.
     * @param {Pointer<PSTR>} Enumerator A pointer to a NULL-terminated string that specifies:
     * 
     * <ul>
     * <li>
     * An identifier (ID) of a Plug and Play (PnP) <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>. This ID can either be the value's globally unique identifier (GUID) or symbolic name. For example, "PCI" can be used to specify the PCI PnP value. Other examples of symbolic names for PnP values include "USB," "PCMCIA," and "SCSI".
     * 
     * </li>
     * <li>
     * A PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. When specifying a PnP device instance ID, DIGCF_DEVICEINTERFACE must be set in the Flags parameter.
     * 
     * </li>
     * </ul>
     * This pointer is optional and can be <b>NULL</b>. If an <i>enumeration</i> value is not used to select devices, set <i>Enumerator</i> to <b>NULL</b>
     * 
     * For more information about how to set the <i>Enumerator</i> value, see the following <b>Remarks</b> section.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to be used for a user interface that is associated with installing a device instance in the device information set. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} Flags A variable of type DWORD that specifies control options that filter the device information elements that are added to the device information set. This parameter can be a bitwise OR of zero or more of the following flags. For more information about combining these flags, see the following <b>Remarks</b> section.
     * @returns {Pointer} If the operation succeeds, <b>SetupDiGetClassDevs</b> returns a handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains all installed devices that matched the supplied parameters. If the operation fails, the function returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsa
     * @since windows5.0
     */
    static SetupDiGetClassDevsA(ClassGuid, Enumerator, hwndParent, Flags) {
        Enumerator := Enumerator is String? StrPtr(Enumerator) : Enumerator

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevsA", "ptr", ClassGuid, "ptr", Enumerator, "ptr", hwndParent, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDevs function returns a handle to a device information set that contains requested device information elements for a local computer. (Unicode)
     * @remarks
     * The caller of <b>SetupDiGetClassDevs</b> must delete the returned device information set when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroydeviceinfolist">SetupDiDestroyDeviceInfoList</a>.
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsexa">SetupDiGetClassDevsEx</a> to retrieve the devices for a class on a remote computer.
     * 
     * <h3><a id="device_setup_class_control_options"></a><a id="DEVICE_SETUP_CLASS_CONTROL_OPTIONS"></a>Device Setup Class Control Options</h3>
     * Use the following filtering options to control whether <b>SetupDiGetClassDevs</b> returns devices for all device setup classes or only for a specified device setup class:
     * 
     * <ul>
     * <li>
     * To return devices for all device setup classes, set the DIGCF_ALLCLASSES flag, and set the <i>ClassGuid</i> parameter to <b>NULL</b>.
     * 
     * </li>
     * <li>
     * To return devices only for a specific device setup class, do not set DIGCF_ALLCLASSES, and use <i>ClassGuid</i> to supply the GUID of the device setup class.
     * 
     * </li>
     * </ul>
     * In addition, you can use the following filtering options in combination with one another to further restrict which devices are returned:
     * 
     * <ul>
     * <li>
     * To return only devices that are present in the system, set the DIGCF_PRESENT flag.
     * 
     * </li>
     * <li>
     * To return only devices that are part of the current hardware profile, set the DIGCF_PROFILE flag.
     * 
     * </li>
     * <li>
     * To return devices only for a specific PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>, use the <i>Enumerator</i> parameter to supply the GUID or symbolic name of the enumerator<i>. </i>If <i>Enumerator</i> is <b>NULL</b>, <b>SetupDiGetClassDevs</b> returns devices for all PnP enumerators.
     * 
     * </li>
     * </ul>
     * <h3><a id="device_interface_class_control_options"></a><a id="DEVICE_INTERFACE_CLASS_CONTROL_OPTIONS"></a>Device Interface Class Control Options</h3>
     * Use the following filtering options to control whether <b>SetupDiGetClassDevs</b> returns devices that support any device interface class or only devices that support a specified device interface class:
     * 
     * <ul>
     * <li>
     * To return devices that support a device interface of any class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_ALLCLASSES flag, and set <i>ClassGuid</i> to <b>NULL</b>. The function adds to the device information set a device information element that represents such a device and then adds to the device information element a device interface list that contains all the device interfaces that the device supports.
     * 
     * </li>
     * <li>
     * To return only devices that support a device interface of a specified class, set the DIGCF_DEVICEINTERFACE flag and use the <i>ClassGuid</i> parameter to supply the class GUID of the device interface class. The function adds to the device information set a device information element that represents such a device and then adds a device interface of the specified class to the device interface list for that device information element.
     * 
     * </li>
     * </ul>
     * In addition, you can use the following filtering options to control whether <b>SetupDiGetClassDevs</b> returns only devices that support the system default interface for device interface classes:
     * 
     * <ul>
     * <li>
     * To return only the device that supports the system default interface, if one is set, for a specified device interface class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_DEFAULT flag, and use <i>ClassGuid</i> to supply the class GUID of the device interface class. The function adds to the device information set a device information element that represents such a device and then adds the system default interface to the device interface list for that device information element.
     * 
     * </li>
     * <li>
     * To return a device that supports a system default interface for an unspecified device interface class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_ALLCLASSES flag, set the DIGCF_DEFAULT flag, and set <i>ClassGuid</i> to <b>NULL</b>. The function adds to the device information set a device information element that represents such a device and then adds the system default interface to the device interface list for that device information element.
     * 
     * </li>
     * </ul>
     * You can also use the following options in combination with the other options to further restrict which devices are returned:
     * 
     * <ul>
     * <li>
     * To return only devices that are present in the system, set the DIGCF_PRESENT flag.
     * 
     * </li>
     * <li>
     * To return only devices that are part of the current hardware profile, set the DIGCF_PROFILE flag.
     * 
     * </li>
     * <li>
     * To return only a specific device, set the DIGCF_DEVICEINTERFACE flag and use the <i>Enumerator</i> parameter to supply the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> of the device<i>. </i>To include all possible devices, set <i>Enumerator</i> to <b>NULL</b>.
     * 
     * </li>
     * </ul>
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> or a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>. This pointer is optional and can be <b>NULL</b>. For more information about how to set <i>ClassGuid</i>, see the following <b>Remarks</b> section.
     * @param {Pointer<PWSTR>} Enumerator A pointer to a NULL-terminated string that specifies:
     * 
     * <ul>
     * <li>
     * An identifier (ID) of a Plug and Play (PnP) <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>. This ID can either be the value's globally unique identifier (GUID) or symbolic name. For example, "PCI" can be used to specify the PCI PnP value. Other examples of symbolic names for PnP values include "USB," "PCMCIA," and "SCSI".
     * 
     * </li>
     * <li>
     * A PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. When specifying a PnP device instance ID, DIGCF_DEVICEINTERFACE must be set in the Flags parameter.
     * 
     * </li>
     * </ul>
     * This pointer is optional and can be <b>NULL</b>. If an <i>enumeration</i> value is not used to select devices, set <i>Enumerator</i> to <b>NULL</b>
     * 
     * For more information about how to set the <i>Enumerator</i> value, see the following <b>Remarks</b> section.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to be used for a user interface that is associated with installing a device instance in the device information set. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} Flags A variable of type DWORD that specifies control options that filter the device information elements that are added to the device information set. This parameter can be a bitwise OR of zero or more of the following flags. For more information about combining these flags, see the following <b>Remarks</b> section.
     * @returns {Pointer} If the operation succeeds, <b>SetupDiGetClassDevs</b> returns a handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains all installed devices that matched the supplied parameters. If the operation fails, the function returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsw
     * @since windows5.0
     */
    static SetupDiGetClassDevsW(ClassGuid, Enumerator, hwndParent, Flags) {
        Enumerator := Enumerator is String? StrPtr(Enumerator) : Enumerator

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevsW", "ptr", ClassGuid, "ptr", Enumerator, "ptr", hwndParent, "uint", Flags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDevsEx function returns a handle to a device information set that contains requested device information elements for a local or a remote computer. (ANSI)
     * @remarks
     * The caller of <b>SetupDiGetClassDevsEx</b> must delete the returned device information set when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroydeviceinfolist">SetupDiDestroyDeviceInfoList</a>. 
     * 
     * If <i>DeviceInfoSet</i> is <b>NULL</b>, <b>SetupDiGetClassDevsEx</b> creates a new device information set that contains the retrieved device information elements and returns a handle to the new device information set. If the caller requests that the function retrieve devices for a device setup class that is supplied by the <i>ClassGuid </i> parameter, the function sets the device setup class of the new device information set to the supplied class GUID.  
     * 
     * If <i>DeviceInfoSet</i> is not set to <b>NULL</b>, the function adds the retrieved device information elements to the device information set that is associated with the supplied handle, and returns the supplied handle. If <i>ClassGuid</i> supplies a device setup class, the device setup class of the supplied device information set must be set to the supplied class GUID. 
     * 
     * <h3><a id="device_setup_class_control_options"></a><a id="DEVICE_SETUP_CLASS_CONTROL_OPTIONS"></a>Device Setup Class Control Options</h3>
     * Use the following filtering options to control whether <b>SetupDiGetClassDevsEx</b> returns devices for all device setup classes or only for a specified device setup class:
     * 
     * <ul>
     * <li>
     * To return devices for all device setup classes, set the DIGCF_ALLCLASSES flag and set the <i>ClassGuid</i> parameter to <b>NULL</b>.
     * 
     * </li>
     * <li>
     * To return devices only for a specific device setup class, do not set DIGCF_ALLCLASSES and use <i>ClassGuid</i> to supply the GUID of the device setup class.
     * 
     * </li>
     * </ul>
     * In addition, you can use the following filtering options to further restrict which devices are returned. 
     * 
     * <ul>
     * <li>
     * To return only devices that are present in the system, set the DIGCF_PRESENT flag. 
     * 
     * </li>
     * <li>
     * To return only devices that are part of the current hardware profile, set the DIGCF_PROFILE flag. 
     * 
     * </li>
     * <li>
     * To return devices for a specific PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a> only, use the <i>Enumerator</i> parameter to supply the GUID or symbolic name of the enumerator<i>. </i>If <i>Enumerator</i> is <b>NULL</b>, <b>SetupDiGetClassDevsEx</b> returns devices for all PnP enumerators.
     * 
     * </li>
     * </ul>
     * <h3><a id="device_interface_class_control_options"></a><a id="DEVICE_INTERFACE_CLASS_CONTROL_OPTIONS"></a>Device Interface Class Control Options</h3>
     * Use the following filtering options to control whether <b>SetupDiGetClassDevsEx</b> returns devices that support any device interface class or only devices that support a specified device interface class:
     * 
     * <ul>
     * <li>
     * To return devices that support a device interface of any class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_ALLCLASSES flag, and set <i>ClassGuid</i> to <b>NULL</b>. The function adds to the device information set a device information element that represents such a device, and then adds to the device information element a device interface list that contains all the device interfaces that the device supports.
     * 
     * </li>
     * <li>
     * To return only devices that support a device interface of a specified class, set the DIGCF_DEVICEINTERFACE flag and use the <i>ClassGuid</i> parameter to supply the class GUID of the device interface class. The function adds to the device information set a device information element that represents such a device, and then adds a device interface of the specified class to the device interface list for that device information element.
     * 
     * </li>
     * </ul>
     * In addition, you can use the following filtering options to control whether <b>SetupDiGetClassDevsEx</b> returns only devices that support the system default interface for device interface classes:
     * 
     * <ul>
     * <li>
     * To return only the device that supports the system default interface, if one is set, for a specified device interface class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_DEFAULT flag, and use <i>ClassGuid</i> to supply the class GUID of the device interface class. The function adds to the device information set a device information element that represents such a device, and then adds the system default interface to the device interface list for that device information element. 
     * 
     * </li>
     * <li>
     * To return a device that supports a system default interface for an unspecified device interface class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_ALLCLASSES flag, set the DIGCF_DEFAULT flag, and set <i>ClassGuid</i> to <b>NULL</b>. The function adds to the device information set a device information element that represents such a device, and then adds the system default interface to the device interface list for that device information element. 
     * 
     * </li>
     * </ul>
     * You can also use the following options in combination with the other options to further restrict which devices are returned. 
     * 
     * <ul>
     * <li>
     * To return only devices that are present in the system, set the DIGCF_PRESENT flag. 
     * 
     * </li>
     * <li>
     * To return only devices that are part of the current hardware profile, set the DIGCF_PROFILE flag. 
     * 
     * </li>
     * <li>
     * To return only a specific device, set the DIGCF_DEVICEINTERFACE flag and use the <i>Enumerator</i> parameter to supply the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> of the device<i>. </i>To include all possible devices, set <i>Enumerator</i> to <b>NULL</b>.
     * 
     * </li>
     * </ul>
     * <h3><a id="retrieving_devices_in_a_device_setup_class_that_support_a_device_inter"></a><a id="RETRIEVING_DEVICES_IN_A_DEVICE_SETUP_CLASS_THAT_SUPPORT_A_DEVICE_INTER"></a>Retrieving Devices in a Device Setup Class That Support a Device Interface Class</h3>
     * An installer can use <b>SetupDiGetClassDevsEx</b> to retrieve a list of devices of a particular device setup class that support a device interface of a specified device interface class. For example, to retrieve a list of all devices on a local computer that support a device interface in the "mounted device" interface class and that are members of the "Volume" device setup class, an installer should perform the following operations:
     * 
     * <ol>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinfolistexa">SetupDiCreateDeviceInfoList</a> to create an empty device information set for the "Volume" device setup class. Set <i>ClassGuid</i> to a pointer to the class GUID for the "Volume" device setup class and set <i>hwndParent</i> as appropriate. In response to such a call, the function will return a handle to type HDEVINFO to the device information set.
     * 
     * </li>
     * <li>Call <b>SetupDiGetClassDevsEx</b> with the following settings:<ul>
     * <li>Set <i>ClassGuid</i> to a pointer to the class GUID of the "mounted device" device interface class.</li>
     * <li>Set <i>Flags</i> to DIGCF_DEVICEINTERFACE.</li>
     * <li>Set <i>DeviceInfoSet</i> to the HDEVINFO handle obtained in step (1).</li>
     * <li>Set <i>hwndParent</i> as appropriate and the remaining parameters to <b>NULL</b>.</li>
     * </ul>
     * </li>
     * </ol>
     * In an operation of this type, <b>SetupDiGetClassDevsEx</b> returns a device if the device setup class of the device is the same as the supplied device information set and if the device supports a device interface whose class is the same as the specified device interface class.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassDevsEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> or a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>. This pointer is optional and can be <b>NULL</b>. If a GUID value is not used to select devices, set <i>ClassGuid</i> to <b>NULL</b>. For more information about how to use <i>ClassGuid</i>, see the following <b>Remarks</b> section.
     * @param {Pointer<PSTR>} Enumerator A pointer to a NULL-terminated string that specifies:
     * 
     * <ul>
     * <li>
     * An identifier (ID) of a Plug and Play (PnP) <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>. This ID can either be the enumerator's globally unique identifier (GUID) or symbolic name. For example, "PCI" can be used to specify the PCI PnP enumerator. Other examples of symbolic names for PnP enumerators include "USB", "PCMCIA", and "SCSI".
     * 
     * </li>
     * <li>
     *  A PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance IDs</a>. When specifying a PnP device instance ID, DIGCF_DEVICEINTERFACE must be set in the Flags parameter.
     * 
     * </li>
     * </ul>
     * This pointer is optional and can be <b>NULL</b>. If an <i>Enumerator</i> value is not used to select devices, set <i>Enumerator</i> to <b>NULL</b>
     * 
     * For more information about how to set the <i>Enumerator</i> value, see the following <b>Remarks</b> section.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to be used for a user interface that is associated with installing a device instance in the device information set. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} Flags A variable of type DWORD that specifies control options that filter the device information elements that are added to the device information set. This parameter can be a bitwise OR of one or more of the following flags. For more information about combining these control options, see the following <b>Remarks</b> section.
     * @param {Pointer} DeviceInfoSet The handle to an existing <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to which <b>SetupDiGetClassDevsEx</b> adds the requested device information elements. This parameter is optional and can be set to <b>NULL</b>. For more information about using this parameter, see the following <b>Remarks</b> section.
     * @param {Pointer<PSTR>} MachineName A pointer to a constant string that contains the name of a remote computer on which the devices reside. A value of <b>NULL</b> for <i>MachineName</i> specifies that the device is installed on the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Pointer} If the operation succeeds, <b>SetupDiGetClassDevsEx</b> returns a handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains all installed devices that matched the supplied parameters. If the operation fails, the function returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsexa
     * @since windows5.0
     */
    static SetupDiGetClassDevsExA(ClassGuid, Enumerator, hwndParent, Flags, DeviceInfoSet, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        Enumerator := Enumerator is String? StrPtr(Enumerator) : Enumerator
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevsExA", "ptr", ClassGuid, "ptr", Enumerator, "ptr", hwndParent, "uint", Flags, "ptr", DeviceInfoSet, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDevsEx function returns a handle to a device information set that contains requested device information elements for a local or a remote computer. (Unicode)
     * @remarks
     * The caller of <b>SetupDiGetClassDevsEx</b> must delete the returned device information set when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroydeviceinfolist">SetupDiDestroyDeviceInfoList</a>. 
     * 
     * If <i>DeviceInfoSet</i> is <b>NULL</b>, <b>SetupDiGetClassDevsEx</b> creates a new device information set that contains the retrieved device information elements and returns a handle to the new device information set. If the caller requests that the function retrieve devices for a device setup class that is supplied by the <i>ClassGuid </i> parameter, the function sets the device setup class of the new device information set to the supplied class GUID.  
     * 
     * If <i>DeviceInfoSet</i> is not set to <b>NULL</b>, the function adds the retrieved device information elements to the device information set that is associated with the supplied handle, and returns the supplied handle. If <i>ClassGuid</i> supplies a device setup class, the device setup class of the supplied device information set must be set to the supplied class GUID. 
     * 
     * <h3><a id="device_setup_class_control_options"></a><a id="DEVICE_SETUP_CLASS_CONTROL_OPTIONS"></a>Device Setup Class Control Options</h3>
     * Use the following filtering options to control whether <b>SetupDiGetClassDevsEx</b> returns devices for all device setup classes or only for a specified device setup class:
     * 
     * <ul>
     * <li>
     * To return devices for all device setup classes, set the DIGCF_ALLCLASSES flag and set the <i>ClassGuid</i> parameter to <b>NULL</b>.
     * 
     * </li>
     * <li>
     * To return devices only for a specific device setup class, do not set DIGCF_ALLCLASSES and use <i>ClassGuid</i> to supply the GUID of the device setup class.
     * 
     * </li>
     * </ul>
     * In addition, you can use the following filtering options to further restrict which devices are returned. 
     * 
     * <ul>
     * <li>
     * To return only devices that are present in the system, set the DIGCF_PRESENT flag. 
     * 
     * </li>
     * <li>
     * To return only devices that are part of the current hardware profile, set the DIGCF_PROFILE flag. 
     * 
     * </li>
     * <li>
     * To return devices for a specific PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a> only, use the <i>Enumerator</i> parameter to supply the GUID or symbolic name of the enumerator<i>. </i>If <i>Enumerator</i> is <b>NULL</b>, <b>SetupDiGetClassDevsEx</b> returns devices for all PnP enumerators.
     * 
     * </li>
     * </ul>
     * <h3><a id="device_interface_class_control_options"></a><a id="DEVICE_INTERFACE_CLASS_CONTROL_OPTIONS"></a>Device Interface Class Control Options</h3>
     * Use the following filtering options to control whether <b>SetupDiGetClassDevsEx</b> returns devices that support any device interface class or only devices that support a specified device interface class:
     * 
     * <ul>
     * <li>
     * To return devices that support a device interface of any class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_ALLCLASSES flag, and set <i>ClassGuid</i> to <b>NULL</b>. The function adds to the device information set a device information element that represents such a device, and then adds to the device information element a device interface list that contains all the device interfaces that the device supports.
     * 
     * </li>
     * <li>
     * To return only devices that support a device interface of a specified class, set the DIGCF_DEVICEINTERFACE flag and use the <i>ClassGuid</i> parameter to supply the class GUID of the device interface class. The function adds to the device information set a device information element that represents such a device, and then adds a device interface of the specified class to the device interface list for that device information element.
     * 
     * </li>
     * </ul>
     * In addition, you can use the following filtering options to control whether <b>SetupDiGetClassDevsEx</b> returns only devices that support the system default interface for device interface classes:
     * 
     * <ul>
     * <li>
     * To return only the device that supports the system default interface, if one is set, for a specified device interface class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_DEFAULT flag, and use <i>ClassGuid</i> to supply the class GUID of the device interface class. The function adds to the device information set a device information element that represents such a device, and then adds the system default interface to the device interface list for that device information element. 
     * 
     * </li>
     * <li>
     * To return a device that supports a system default interface for an unspecified device interface class, set the DIGCF_DEVICEINTERFACE flag, set the DIGCF_ALLCLASSES flag, set the DIGCF_DEFAULT flag, and set <i>ClassGuid</i> to <b>NULL</b>. The function adds to the device information set a device information element that represents such a device, and then adds the system default interface to the device interface list for that device information element. 
     * 
     * </li>
     * </ul>
     * You can also use the following options in combination with the other options to further restrict which devices are returned. 
     * 
     * <ul>
     * <li>
     * To return only devices that are present in the system, set the DIGCF_PRESENT flag. 
     * 
     * </li>
     * <li>
     * To return only devices that are part of the current hardware profile, set the DIGCF_PROFILE flag. 
     * 
     * </li>
     * <li>
     * To return only a specific device, set the DIGCF_DEVICEINTERFACE flag and use the <i>Enumerator</i> parameter to supply the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> of the device<i>. </i>To include all possible devices, set <i>Enumerator</i> to <b>NULL</b>.
     * 
     * </li>
     * </ul>
     * <h3><a id="retrieving_devices_in_a_device_setup_class_that_support_a_device_inter"></a><a id="RETRIEVING_DEVICES_IN_A_DEVICE_SETUP_CLASS_THAT_SUPPORT_A_DEVICE_INTER"></a>Retrieving Devices in a Device Setup Class That Support a Device Interface Class</h3>
     * An installer can use <b>SetupDiGetClassDevsEx</b> to retrieve a list of devices of a particular device setup class that support a device interface of a specified device interface class. For example, to retrieve a list of all devices on a local computer that support a device interface in the "mounted device" interface class and that are members of the "Volume" device setup class, an installer should perform the following operations:
     * 
     * <ol>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinfolistexa">SetupDiCreateDeviceInfoList</a> to create an empty device information set for the "Volume" device setup class. Set <i>ClassGuid</i> to a pointer to the class GUID for the "Volume" device setup class and set <i>hwndParent</i> as appropriate. In response to such a call, the function will return a handle to type HDEVINFO to the device information set.
     * 
     * </li>
     * <li>Call <b>SetupDiGetClassDevsEx</b> with the following settings:<ul>
     * <li>Set <i>ClassGuid</i> to a pointer to the class GUID of the "mounted device" device interface class.</li>
     * <li>Set <i>Flags</i> to DIGCF_DEVICEINTERFACE.</li>
     * <li>Set <i>DeviceInfoSet</i> to the HDEVINFO handle obtained in step (1).</li>
     * <li>Set <i>hwndParent</i> as appropriate and the remaining parameters to <b>NULL</b>.</li>
     * </ul>
     * </li>
     * </ol>
     * In an operation of this type, <b>SetupDiGetClassDevsEx</b> returns a device if the device setup class of the device is the same as the supplied device information set and if the device supports a device interface whose class is the same as the specified device interface class.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassDevsEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> or a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>. This pointer is optional and can be <b>NULL</b>. If a GUID value is not used to select devices, set <i>ClassGuid</i> to <b>NULL</b>. For more information about how to use <i>ClassGuid</i>, see the following <b>Remarks</b> section.
     * @param {Pointer<PWSTR>} Enumerator A pointer to a NULL-terminated string that specifies:
     * 
     * <ul>
     * <li>
     * An identifier (ID) of a Plug and Play (PnP) <a href="https://docs.microsoft.com/windows-hardware/drivers/">enumerator</a>. This ID can either be the enumerator's globally unique identifier (GUID) or symbolic name. For example, "PCI" can be used to specify the PCI PnP enumerator. Other examples of symbolic names for PnP enumerators include "USB", "PCMCIA", and "SCSI".
     * 
     * </li>
     * <li>
     *  A PnP <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance IDs</a>. When specifying a PnP device instance ID, DIGCF_DEVICEINTERFACE must be set in the Flags parameter.
     * 
     * </li>
     * </ul>
     * This pointer is optional and can be <b>NULL</b>. If an <i>Enumerator</i> value is not used to select devices, set <i>Enumerator</i> to <b>NULL</b>
     * 
     * For more information about how to set the <i>Enumerator</i> value, see the following <b>Remarks</b> section.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to be used for a user interface that is associated with installing a device instance in the device information set. This handle is optional and can be <b>NULL</b>.
     * @param {Integer} Flags A variable of type DWORD that specifies control options that filter the device information elements that are added to the device information set. This parameter can be a bitwise OR of one or more of the following flags. For more information about combining these control options, see the following <b>Remarks</b> section.
     * @param {Pointer} DeviceInfoSet The handle to an existing <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to which <b>SetupDiGetClassDevsEx</b> adds the requested device information elements. This parameter is optional and can be set to <b>NULL</b>. For more information about using this parameter, see the following <b>Remarks</b> section.
     * @param {Pointer<PWSTR>} MachineName A pointer to a constant string that contains the name of a remote computer on which the devices reside. A value of <b>NULL</b> for <i>MachineName</i> specifies that the device is installed on the local computer. Remote computer is not supported beginning with Windows 8 and Windows Server 2012.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Pointer} If the operation succeeds, <b>SetupDiGetClassDevsEx</b> returns a handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains all installed devices that matched the supplied parameters. If the operation fails, the function returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsexw
     * @since windows5.0
     */
    static SetupDiGetClassDevsExW(ClassGuid, Enumerator, hwndParent, Flags, DeviceInfoSet, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        Enumerator := Enumerator is String? StrPtr(Enumerator) : Enumerator
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevsExW", "ptr", ClassGuid, "ptr", Enumerator, "ptr", hwndParent, "uint", Flags, "ptr", DeviceInfoSet, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetINFClass function returns the class of a specified device INF file. (ANSI)
     * @remarks
     * Do not use this function with INF files for Windows 9x or Millennium Edition.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetINFClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} InfName A pointer to a NULL-terminated string that supplies the name of a device INF file. This name can include a path. However, if just the file name is specified, the file is searched for in each directory that is listed in the <b>DevicePath</b> entry under the <b>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion</b> subkey of the registry. The maximum length in characters, including a NULL terminator, of a NULL-terminated INF file name is MAX_PATH.
     * @param {Pointer<Guid>} ClassGuid A pointer to a variable of type GUID that receives the class GUID for the specified INF file. If the INF file does not specify a class name, the function returns a GUID_NULL structure. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiclassguidsfromnamea">SetupDiClassGuidsFromName</a> to determine whether one or more classes with this name are already installed.
     * @param {Pointer<PSTR>} ClassName A pointer to a buffer that receives a NULL-terminated string that contains the name of the class for the specified INF file. If the INF file does not specify a class name but does specify a GUID, this buffer receives the name that is retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiclassnamefromguida">SetupDiClassNameFromGuid</a>. However, if <b>SetupDiClassNameFromGuid</b> cannot retrieve a class name (for example, the class is not installed), it returns an empty string.
     * @param {Integer} ClassNameSize The size, in characters, of the buffer that is pointed to by the <i>ClassName</i> parameter. The maximum length of a NULL-terminated class name, in characters, is MAX_CLASS_NAME_LEN.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the number of characters that are required to store the class name, including a terminating <b>NULL</b>. This pointer is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetinfclassa
     * @since windows5.0
     */
    static SetupDiGetINFClassA(InfName, ClassGuid, ClassName, ClassNameSize, RequiredSize) {
        InfName := InfName is String? StrPtr(InfName) : InfName
        ClassName := ClassName is String? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetINFClassA", "ptr", InfName, "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetINFClass function returns the class of a specified device INF file. (Unicode)
     * @remarks
     * Do not use this function with INF files for Windows 9x or Millennium Edition.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetINFClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} InfName A pointer to a NULL-terminated string that supplies the name of a device INF file. This name can include a path. However, if just the file name is specified, the file is searched for in each directory that is listed in the <b>DevicePath</b> entry under the <b>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion</b> subkey of the registry. The maximum length in characters, including a NULL terminator, of a NULL-terminated INF file name is MAX_PATH.
     * @param {Pointer<Guid>} ClassGuid A pointer to a variable of type GUID that receives the class GUID for the specified INF file. If the INF file does not specify a class name, the function returns a GUID_NULL structure. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiclassguidsfromnamea">SetupDiClassGuidsFromName</a> to determine whether one or more classes with this name are already installed.
     * @param {Pointer<PWSTR>} ClassName A pointer to a buffer that receives a NULL-terminated string that contains the name of the class for the specified INF file. If the INF file does not specify a class name but does specify a GUID, this buffer receives the name that is retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiclassnamefromguida">SetupDiClassNameFromGuid</a>. However, if <b>SetupDiClassNameFromGuid</b> cannot retrieve a class name (for example, the class is not installed), it returns an empty string.
     * @param {Integer} ClassNameSize The size, in characters, of the buffer that is pointed to by the <i>ClassName</i> parameter. The maximum length of a NULL-terminated class name, in characters, is MAX_CLASS_NAME_LEN.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the number of characters that are required to store the class name, including a terminating <b>NULL</b>. This pointer is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetinfclassw
     * @since windows5.0
     */
    static SetupDiGetINFClassW(InfName, ClassGuid, ClassName, ClassNameSize, RequiredSize) {
        InfName := InfName is String? StrPtr(InfName) : InfName
        ClassName := ClassName is String? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetINFClassW", "ptr", InfName, "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiBuildClassInfoList function returns a list of setup class GUIDs that identify the classes that are installed on a local computer.
     * @remarks
     * To retrieve the number of classes that are installed on a local computer, call <b>SetupDiBuildClassInfoList</b> with <i>ClassGuidList</i> set to <b>NULL</b> and <i>ClassGuidSize</i> set to zero. In response to such a call, the function returns the number of classes in <b>*</b><i>RequiredSize</i>.
     * 
     * <b>SetupDiBuildClassInfoList</b> does not return a class GUID for a class if the <b>NoUseClass</b> value entry exists in the registry key of the class.
     * 
     * To retrieve the list of setup class GUIDs installed on a remote system use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdibuildclassinfolistexa">SetupDiBuildClassInfoListEx</a>.
     * @param {Integer} Flags 
     * @param {Pointer<Guid>} ClassGuidList A pointer to a GUID-typed array that receives a list of setup class GUIDs. This pointer is optional and can be <b>NULL</b>.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the array that is pointed to by the <i>ClassGuildList</i> parameter. If <i>ClassGuidList</i> is <b>NULL</b>, <i>ClassGuidSize</i> must be zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the number of GUIDs that are returned (if the number is less than or equal to the size, in GUIDs, of the array that is pointed to by the <i>ClassGuidList</i> parameter). 
     * 
     * If this number is greater than the size of the <i>ClassGuidList</i> array, it indicates how large the <i>ClassGuidList</i> array must be in order to contain all the class GUIDs.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdibuildclassinfolist
     * @since windows5.0
     */
    static SetupDiBuildClassInfoList(Flags, ClassGuidList, ClassGuidListSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiBuildClassInfoList", "uint", Flags, "ptr", ClassGuidList, "uint", ClassGuidListSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiBuildClassInfoListEx function returns a list of setup class GUIDs that includes every class installed on the local system or a remote system. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiBuildClassInfoListEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<Guid>} ClassGuidList A pointer to a buffer that receives a list of setup class GUIDs.
     * @param {Integer} ClassGuidListSize Supplies the number of GUIDs in the <i>ClassGuildList</i> array.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable that receives the number of GUIDs returned. If this number is greater than the size of the <i>ClassGuidList</i>, the number indicates how large the <i>ClassGuidList</i> array must be in order to contain the list.
     * @param {Pointer<PSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote computer from which to retrieve installed setup classes. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, this function builds a list of classes installed on the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdibuildclassinfolistexa
     * @since windows5.0
     */
    static SetupDiBuildClassInfoListExA(Flags, ClassGuidList, ClassGuidListSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiBuildClassInfoListExA", "uint", Flags, "ptr", ClassGuidList, "uint", ClassGuidListSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiBuildClassInfoListEx function returns a list of setup class GUIDs that includes every class installed on the local system or a remote system. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiBuildClassInfoListEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Flags 
     * @param {Pointer<Guid>} ClassGuidList A pointer to a buffer that receives a list of setup class GUIDs.
     * @param {Integer} ClassGuidListSize Supplies the number of GUIDs in the <i>ClassGuildList</i> array.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable that receives the number of GUIDs returned. If this number is greater than the size of the <i>ClassGuidList</i>, the number indicates how large the <i>ClassGuidList</i> array must be in order to contain the list.
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote computer from which to retrieve installed setup classes. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, this function builds a list of classes installed on the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdibuildclassinfolistexw
     * @since windows5.0
     */
    static SetupDiBuildClassInfoListExW(Flags, ClassGuidList, ClassGuidListSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiBuildClassInfoListExW", "uint", Flags, "ptr", ClassGuidList, "uint", ClassGuidListSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDescription function retrieves the class description associated with the specified setup class GUID. (ANSI)
     * @remarks
     * Call <b>SetupDiGetClassDescriptionEx</b> to retrieve the description of a setup class installed on a remote computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassDescription as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid The GUID of the setup class whose description is to be retrieved.
     * @param {Pointer<PSTR>} ClassDescription A pointer to a character buffer that receives the class description.
     * @param {Integer} ClassDescriptionSize The size, in characters, of the <i>ClassDescription</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to variable of type DWORD that receives the size, in characters, that is required to store the class description (including a NULL terminator). <i>RequiredSize</i> is always less than LINE_LEN. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdescriptiona
     * @since windows5.0
     */
    static SetupDiGetClassDescriptionA(ClassGuid, ClassDescription, ClassDescriptionSize, RequiredSize) {
        ClassDescription := ClassDescription is String? StrPtr(ClassDescription) : ClassDescription

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDescriptionA", "ptr", ClassGuid, "ptr", ClassDescription, "uint", ClassDescriptionSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDescription function retrieves the class description associated with the specified setup class GUID. (Unicode)
     * @remarks
     * Call <b>SetupDiGetClassDescriptionEx</b> to retrieve the description of a setup class installed on a remote computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassDescription as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid The GUID of the setup class whose description is to be retrieved.
     * @param {Pointer<PWSTR>} ClassDescription A pointer to a character buffer that receives the class description.
     * @param {Integer} ClassDescriptionSize The size, in characters, of the <i>ClassDescription</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to variable of type DWORD that receives the size, in characters, that is required to store the class description (including a NULL terminator). <i>RequiredSize</i> is always less than LINE_LEN. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdescriptionw
     * @since windows5.0
     */
    static SetupDiGetClassDescriptionW(ClassGuid, ClassDescription, ClassDescriptionSize, RequiredSize) {
        ClassDescription := ClassDescription is String? StrPtr(ClassDescription) : ClassDescription

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDescriptionW", "ptr", ClassGuid, "ptr", ClassDescription, "uint", ClassDescriptionSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDescriptionEx function retrieves the description of a setup class installed on a local or remote computer. (ANSI)
     * @remarks
     * If there is a friendly name in the registry key for the class, this routine returns the friendly name. Otherwise, this routine returns the class name.
     * 
     * <b>SetupDiGetClassDescriptionEx</b> does not enforce a restriction on the length of the class description that it can return. This function returns the required size for a NULL-terminated class description even if it is greater than LINE_LEN. However, LINE_LEN is the maximum length of a valid NULL-terminated class description. A caller should never need a buffer that is larger than LINE_LEN. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassDescriptionEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for the setup class whose description is to be retrieved.
     * @param {Pointer<PSTR>} ClassDescription A pointer to a character buffer that receives the class description.
     * @param {Integer} ClassDescriptionSize The size, in characters, of the buffer that is pointed to by the <i>ClassDescription</i> parameter. The maximum length, in characters, of a NULL-terminated class description is LINE_LEN. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, that is required to store the requested NULL-terminated class description. This pointer is optional and can be <b>NULL</b>.
     * @param {Pointer<PSTR>} MachineName A pointer to a NULL-terminated string that supplies the name of a remote computer on which the setup class resides. This pointer is optional and can be <b>NULL</b>. If the class is installed on a local computer, set the pointer to <b>NULL</b>.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdescriptionexa
     * @since windows5.0
     */
    static SetupDiGetClassDescriptionExA(ClassGuid, ClassDescription, ClassDescriptionSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassDescription := ClassDescription is String? StrPtr(ClassDescription) : ClassDescription
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDescriptionExA", "ptr", ClassGuid, "ptr", ClassDescription, "uint", ClassDescriptionSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDescriptionEx function retrieves the description of a setup class installed on a local or remote computer. (Unicode)
     * @remarks
     * If there is a friendly name in the registry key for the class, this routine returns the friendly name. Otherwise, this routine returns the class name.
     * 
     * <b>SetupDiGetClassDescriptionEx</b> does not enforce a restriction on the length of the class description that it can return. This function returns the required size for a NULL-terminated class description even if it is greater than LINE_LEN. However, LINE_LEN is the maximum length of a valid NULL-terminated class description. A caller should never need a buffer that is larger than LINE_LEN. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassDescriptionEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID for the setup class whose description is to be retrieved.
     * @param {Pointer<PWSTR>} ClassDescription A pointer to a character buffer that receives the class description.
     * @param {Integer} ClassDescriptionSize The size, in characters, of the buffer that is pointed to by the <i>ClassDescription</i> parameter. The maximum length, in characters, of a NULL-terminated class description is LINE_LEN. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in characters, that is required to store the requested NULL-terminated class description. This pointer is optional and can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that supplies the name of a remote computer on which the setup class resides. This pointer is optional and can be <b>NULL</b>. If the class is installed on a local computer, set the pointer to <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdescriptionexw
     * @since windows5.0
     */
    static SetupDiGetClassDescriptionExW(ClassGuid, ClassDescription, ClassDescriptionSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassDescription := ClassDescription is String? StrPtr(ClassDescription) : ClassDescription
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDescriptionExW", "ptr", ClassGuid, "ptr", ClassDescription, "uint", ClassDescriptionSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCallClassInstaller function calls the appropriate class installer, and any registered co-installers, with the specified installation request (DIF code).
     * @remarks
     * <b>SetupDiCallClassInstaller</b> calls the class installer and any co-installers that are registered for a device or a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a>. This function loads the installers if they are not yet loaded. The function also calls the default handler for the DIF request, if there is a default handler and if the installers return a status indicating that the default handler should be called.
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/">Device installation applications</a> call this function with a variety of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/handling-dif-codes">device installation function codes</a> (DIF codes). The function ensures that all the appropriate installers and default handlers are called, in the correct order, for a given DIF request. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/handling-dif-codes">Handling DIF Codes</a>.
     * 
     * After <b>SetupDiCallClassInstaller</b> returns <b>TRUE</b>, the device installation application must call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinstallparamsa">SetupDiGetDeviceInstallParams</a> to obtain an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure. If the structure's <b>DI_NEEDREBOOT</b> or <b>DI_NEEDRESTART</b> flag is set, the caller must prompt the user to restart the system. For example, the caller can do this by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setuppromptreboot">SetupPromptReboot</a>. 
     * 
     * However, be aware that a device installation application should request a system restart one time at most. Therefore, any device installation application that creates multiple calls to <b>SetupDiCallClassInstaller</b> and <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinstallparamsa">SetupDiGetDeviceInstallParams</a> should save the <b>DI_NEEDREBOOT</b> and <b>DI_NEEDRESTART</b> flags after each call. However, it should prompt the user only after the last call returns. 
     * 
     * In response to a DIF code supplied by <b>SetupDiCallClassInstaller</b>, class installers and co-installers might perform operations that require the system to be restarted. In such situations, the installer or co-installer should do the following: 
     * 
     * <ol>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinstallparamsa">SetupDiGetDeviceInstallParams</a> to obtain the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure. 
     * 
     * </li>
     * <li>
     * Set the <b>DI_NEEDREBOOT</b> or <b>DI_NEEDRESTART</b> flag in the structure's <i>Flags</i> member.
     * 
     * </li>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetdeviceinstallparamsa">SetupDiSetDeviceInstallParams</a>, supplying the updated <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure, to save the revised <i>Flags</i> member.
     * 
     * </li>
     * </ol>
     * After <b>SetupDiCallClassInstaller</b> returns, the device installation application that called it should call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinstallparamsa">SetupDiGetDeviceInstallParams</a>, check the flags, and request a restart if necessary.
     * 
     * The device information set specified by <i>DeviceInfoSet</i> must only contain elements for devices on the local computer.
     * 
     * For information about the design and operation of co-installers, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-a-co-installer">Writing a Co-installer</a>.
     * @param {Integer} InstallFunction The device installation request (DIF request) to pass to the co-installers and class installer. DIF codes have the format <b>DIF_<i>XXX</i></b> and are defined in Setupapi.h. See <a href="https://docs.microsoft.com/windows-hardware/drivers/install/handling-dif-codes">Device Installation Function Codes</a> for more information.
     * 
     * <div class="alert"><b>Note</b>For certain DIF requests, the caller must be a member of the Administrators group. For such DIF requests, this requirement is listed on the reference page for the associated default handler.</div>
     * <div></div>
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local computer. This set contains a device installation element which represents the device for which to perform the specified installation function.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in the <i>DeviceInfoSet</i> that represents the device for which to perform the specified installation function. This parameter is optional and can be set to <b>NULL</b>. If this parameter is specified, <b>SetupDiCallClassInstaller</b> performs the specified function on the <i>DeviceInfoData</i> element. If <i>DeviceInfoData</i> is <b>NULL</b>, <b>SetupDiCallClassInstaller</b> calls the installers for the setup class that is associated with <i>DeviceInfoSet</i>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * When GetLastError returns <b>ERROR_IN_WOW64</b>, this means that the calling application is a 32-bit application attempting to execute in a 64-bit environment, which is not allowed.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicallclassinstaller
     * @since windows5.0
     */
    static SetupDiCallClassInstaller(InstallFunction, DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCallClassInstaller", "uint", InstallFunction, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSelectDevice function is the default handler for the DIF_SELECTDEVICE request.
     * @remarks
     * <b>SetupDiSelectDevice</b> handles the user interface that allows the user to select a driver for the specified device, or a device information set if a device is not specified. By setting the <b>Flags</b> field of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure for the device, or the device information set if a device is not specified, the caller can specify special handling of the user interface, for example, to allow users to select a driver from an OEM installation disk. 
     * 
     * <div class="alert"><b>Note</b>Only a class installer should call <b>SetupDiSelectDevice</b> and only in those situations where the class installer must perform driver selection operations after <b>SetupDiSelectDevice</b> completes the default driver selection operation. In such situations, the class installer must directly call <b>SetupDiSelectDevice</b> when the installer processes a DIF_SELECTDEVICE request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * <b>SetupDiSelectDevice</b> is primarily designed to select a driver for a device on a local computer before installing the device. Although <b>SetupDiSelectDevice</b> will not fail if the device information set is for a remote computer, the result is of limited use because the device information set cannot subsequently be used with DIF_<i>Xxx</i> installation requests or <b>SetupDi</b><i>Xxx</i> functions that do not support operations on a remote computer. In particular, the device information set cannot be used as input with a DIF_INSTALLDEVICE installation request to install a device on a remote computer.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to select a driver.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSelectDevice</b> selects the driver for the specified device and sets <i>DeviceInfoData.</i><b>ClassGuid</b> to the GUID of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for the selected driver. If this parameter is <b>NULL</b>, <b>SetupDiSelectDevice</b> sets the selected driver in the global class driver list for <i>DeviceInfoSet</i>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiselectdevice
     * @since windows5.0
     */
    static SetupDiSelectDevice(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSelectDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSelectBestCompatDrv function is the default handler for the DIF_SELECTBESTCOMPATDRV installation request.
     * @remarks
     * If the caller of <b>SetupDiSelectBestCompatDrv</b> is a member of the Administrators group and the class of the device is different that the class of the selected driver, <b>SetupDiSelectBestCompatDrv</b> sets the class of the device to the class of the driver. If this behavior is not desired, call this function at a lower privilege level. 
     * 
     * <div class="alert"><b>Note</b>Only a class installer should call <b>SetupDiSelectBestCompatDrv</b> and only in those situations where the class installer must perform driver selection operations after <b>SetupDiSelectBestCompatDrv</b> completes the default driver selection operation. In such situations, the class installer must directly call <b>SetupDiSelectBestCompatDrv</b> when the installer processes a DIF_SELECTBESTCOMPATDRV request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * <b>SetupDiSelectBestCompatDrv </b> is primarily designed to select the best compatible driver for a device information element on a local computer. Although <b>SetupDiSelectBestCompatDrv </b> will not fail if the device information set is for a remote computer, the result is of limited use because the device information set cannot subsequently be used as input with DIF_<i>Xxx</i> installation requests or <b>SetupDi</b><i>Xxx</i> functions that do not support operations for a remote computer. In particular, the device information set cannot subsequently be used as input with a DIF_INSTALLDEVICE installation request to install a device on a remote computer.
     * 
     * For information about how the best driver is selected, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>.
     * 
     * To get the selected driver for a device, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetselecteddrivera">SetupDiGetSelectedDriver</a>.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to select the best compatible driver.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. <b>SetupDiSelectBestCompatDrv</b> selects the best driver for a device information element from the compatible driver list for the specified device.
     * @returns {Integer} If the operation succeeds, <b>SetupDiSelectBestCompatDrv</b> returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiselectbestcompatdrv
     * @since windows5.0
     */
    static SetupDiSelectBestCompatDrv(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSelectBestCompatDrv", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallDevice function is the default handler for the DIF_INSTALLDEVICE installation request.
     * @remarks
     * <b>SetupDiInstallDevice</b> installs a driver from the INF file. SetupAPI's definition of the "<i>driver</i>" is really a "<a href="https://docs.microsoft.com/windows-hardware/drivers/">driver node</a>." Therefore, when this function installs a driver, it also installs the items in the following list:
     * 
     * <ul>
     * <li>
     * The service(s) for the device.
     * 
     * </li>
     * <li>
     * The driver files.
     * 
     * </li>
     * <li>
     * Device-specific co-installers (if any).
     * 
     * </li>
     * <li>
     * Property-page providers (if any).
     * 
     * </li>
     * <li>
     * Control-panel applets (if any).
     * 
     * </li>
     * </ul>
     * This function also registers any required device interfaces. 
     * 
     * A successful installation includes, but is not limited to, the following steps:
     * 
     * <ul>
     * <li>
     * Create a <a href="https://docs.microsoft.com/windows-hardware/drivers/">driver key</a> in the registry and write appropriate entries (such as <b>InfPath</b> and <b>ProviderName</b>).
     * 
     * </li>
     * <li>
     * Locate and process the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-section">INF DDInstall section</a> for the device. The section might be OS/architecture-specific. The <i>DDInstall</i> section's <b>AddReg</b> and <b>DelReg</b> entries are directed at the device's <a href="https://docs.microsoft.com/windows-hardware/drivers/">software key</a>. Locate and process the <i>DDInstall</i><b>.HW</b> section whose <b>AddReg</b> and <b>DelReg</b> entries are directed at the device's <a href="https://docs.microsoft.com/windows-hardware/drivers/">hardware key</a>. Locate and process the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-logconfigoverride-section">INF DDInstall.LogConfigOverride section</a>, if present, to supply an <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">override configuration</a> for the device. Locate and process the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-services-section">INF DDInstall.Services section</a> to add services for the device (and potentially remove any old services that are no longer necessary).
     * 
     * </li>
     * <li>
     * Copy the INF file to the system INF directory.
     * 
     * </li>
     * <li>
     * Possibly perform the other file operations, based on flag settings in the device installation parameters. 
     * 
     * If the DI_NOFILECOPY flag and the DI_NOVCP flag are <i>clear</i>, perform any file operations specified in the <i>DDInstall </i> section. If the DI_NOVCP flag is set, queue any file operations. 
     * 
     * If the DI_NOFILECOPY flag is set, do not copy the files. This flag might be set if, for example, a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-installdevicefiles">DIF_INSTALLDEVICEFILES</a> operation was already performed for this device installation. 
     * 
     * </li>
     * <li>
     * Load the drivers for the device. This includes the function driver and any upper or lower-filter drivers.
     * 
     * </li>
     * <li>
     * Call the drivers' <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/nc-wdm-driver_add_device">AddDevice</a> routines.
     * 
     * </li>
     * <li>
     * Start the device by sending an  <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-start-device">IRP_MN_START_DEVICE</a> I/O request packet (IRP).
     * 
     * </li>
     * </ul>
     * Windows does not start the device if the DI_NEEDRESTART, DI_NEEDREBOOT, or DI_DONOTCALLCONFIGMG flag is set in the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure.
     * 
     * A class installer should return ERROR_DI_DO_DEFAULT or call this function when handling a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-installdevice">DIF_INSTALLDEVICE</a> request. This function performs many tasks for device installation and that list of tasks might be expanded in future releases. If a class installer performs device installation without calling this function, the class installer might not work correctly on future versions of the operating system. 
     * 
     * If Windows cannot locate an INF file for the device, it will send DIF_INSTALLDEVICE in an attempt to install a <a href="https://docs.microsoft.com/windows-hardware/drivers/">null driver</a>. <b>SetupDiInstallDevice</b> installs a null driver only if the device supports <a href="https://docs.microsoft.com/windows-hardware/drivers/">raw mode</a> or is a non-PnP device (reported by <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-ioreportdetecteddevice">IoReportDetectedDevice</a>). For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-installdevice">DIF_INSTALLDEVICE</a>.
     * 
     * If the DI_FLAGSEX_SETFAILEDINSTALL flag is set in the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure, <b>SetupDiInstallDevice</b> just sets the FAILEDINSTALL flag in the device's <b>ConfigFlags</b> registry value.
     * 
     * <div class="alert"><b>Note</b>Only a <a href="https://docs.microsoft.com/windows-hardware/drivers/">class installer</a> should call <b>SetupDiInstallDevice</b> and only in those situations where the class installer must perform device installation operations after <b>SetupDiInstallDevice</b> completes the default device installation operation. In such situations, the class installer must directly call <b>SetupDiInstallDevice</b> when the installer processes a DIF_INSTALLDEVICE request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * The caller of <b>SetupDiInstallDevice</b> must be a member of the Administrators group.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local system that contains a device information element that represents the device to install.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoData.</i><b>DevInst</b> might be updated with a new handle value upon return.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstalldevice
     * @since windows5.0
     */
    static SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallDriverFiles function is the default handler for the DIF_INSTALLDEVICEFILES installation request.
     * @remarks
     * The caller of <b>SetupDiInstallDriverFiles</b> must be a member of the Administrators group if this function is being used to install files. However, if this function is being used to build up a file queue, membership in the Administrators group is not required.
     * 
     * <div class="alert"><b>Note</b>Only a class installer should call <b>SetupDiInstallDriverFiles</b> and only in those situations where the class installer must perform driver file installation operations after <b>SetupDiInstallDriverFiles</b> completes the default driver file installation operation. In such situations, the class installer must directly call <b>SetupDiInstallDriverFiles</b> when the installer processes a DIF_INSTALLDEVICEFILES request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * The operation of <b>SetupDiInstallDriverFiles</b> is similar to the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiinstalldevice">SetupDiInstallDevice</a> function. However, this function performs only the file copy operations that are performed by <b>SetupDiInstallDevice</b>. 
     * 
     * A driver must be selected for the specified device information set or element before this function is called.
     * 
     * This function processes the <b>CopyFiles</b>, <b>Delfiles</b>, and <b>Renfiles</b> entries in the selected INF file.
     * 
     * The <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element that represents the device for which to install files. The device information set must not contain remote elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstalldriverfiles
     * @since windows5.0
     */
    static SetupDiInstallDriverFiles(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallDriverFiles", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRegisterCoDeviceInstallers function is the default handler for DIF_REGISTER_COINSTALLERS.
     * @remarks
     * The caller of <b>SetupDiRegisterCoDeviceInstallers</b> must be a member of the Administrators group.
     * 
     * <div class="alert"><b>Note</b>Only a class installer should call <b>SetupDiRegisterCoDeviceInstallers</b> and only in those situations where the class installer must perform co-installer registration operations after <b>SetupDiRegisterCoDeviceInstallers</b> completes the default co-installer registration operation. In such situations, the class installer must directly call <b>SetupDiRegisterCoDeviceInstallers</b> when the installer processes a DIF_REGISTER_COINSTALLERS request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * <b>SetupDiRegisterCoDeviceInstallers</b> reads the INF file for the device specified by <i>DeviceInfoData</i> and creates registry entries to register any device-specific co-installers listed in the INF file. Co-installers are listed in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-coinstallers-section">INF DDInstall.CoInstallers section</a>. This function also copies the files for the co-installers, unless the DI_NOFILECOPY flag is set. 
     * 
     * If there is no driver selected, or the device has an INF file for Windows 9x or Millennium Edition, this function does not register any co-installers.
     * 
     * Registering a new device-specific co-installer invalidates the Device Installer's current list of co-installers. After a successful registration, the Device Installer updates its list of co-installers.
     * 
     * This function only registers device-specific co-installers, not class co-installers. 
     * 
     * For more information about how to write and register device-specific co-installers, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-a-co-installer">Writing a Co-installer</a>.
     * 
     * The device information set specified by <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to register co-installers. The device information set must not contain any remote elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @returns {Integer} <b>SetupDiRegisterCoDeviceInstallers</b> returns <b>TRUE</b> if the function succeeds. If the function returns <b>FALSE</b>, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiregistercodeviceinstallers
     * @since windows5.0
     */
    static SetupDiRegisterCoDeviceInstallers(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiRegisterCoDeviceInstallers", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRemoveDevice function is the default handler for the DIF_REMOVE installation request.
     * @remarks
     * <b>SetupDiRemoveDevice</b> removes the device from the system. It deletes the device's hardware and software registry keys and any hardware-profile-specific registry keys (configuration-specific registry keys). This function dynamically stops the device if its <b>DevInst</b> is active and this is a global removal or the last configuration-specific removal. If the device cannot be dynamically stopped, flags are set in the Install Parameter block of the device information set that eventually cause the user to be prompted to restart the computer. 
     * 
     * Device removal is either global to all hardware profiles or specific to one hardware profile as specified by the <b>Scope</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_removedevice_params">SP_REMOVEDEVICE_PARAMS</a> structure that supplies the class installation parameters for the DIF_REMOVE request. Configuration-specific removal is only appropriate for root-enumerated devices and should only be requested by system code. 
     * 
     * The caller of <b>SetupDiRemoveDevice</b> must be a member of the Administrators group.
     * 
     * <div class="alert"><b>Note</b>Only a <a href="https://docs.microsoft.com/windows-hardware/drivers/">class installer</a> should call <b>SetupDiRemoveDevice </b> and only in those situations where the class installer must perform device removal operations after <b>SetupDiRemoveDevice </b> completes the default device removal operation. In such situations, the class installer must directly call <b>SetupDiRemoveDevice</b> when the installer processes a DIF_REMOVE request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>. </div>
     * <div></div>
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local system that contains a device information element that represents the device to remove.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoSet</i>.<b>DevInst</b> might be updated with a new handle value upon return. If this is a global removal or the last hardware profile-specific removal, all traces of the device instance are deleted from the registry and the handle will be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <b>GetLastError</b>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiremovedevice
     * @since windows5.0
     */
    static SetupDiRemoveDevice(DeviceInfoSet, DeviceInfoData) {
        result := DllCall("SETUPAPI.dll\SetupDiRemoveDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        return result
    }

    /**
     * The SetupDiUnremoveDevice function is the default handler for the DIF_UNREMOVE installation request.
     * @remarks
     * <b>SetupDiUnremoveDevice</b> restores a device to a hardware profile. This function starts the device, if possible, or it sets a flag in the device install parameters that eventually causes the user to be prompted to shut down the system.
     * 
     * <div class="alert"><b>Note</b>Only a class installer should call <b>SetupDiUnremoveDevice</b> and only in those situations where the class installer must perform device unremove operations after <b>SetupDiUnremoveDevice</b> completes the default device unremove operation. In such situations, the class installer must directly call <b>SetupDiUnremoveDevice</b> when the installer processes a DIF_UNREMOVE request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * The device being restored must have class install parameters for <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-unremove">DIF_UNREMOVE</a> or the function fails and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_CLASSINSTALL_PARAMS.
     * 
     * The <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * 
     * The caller of <b>SetupDiUnremoveDevice</b> must be a member of the Administrators group.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local system that contains a device information element that represents a device to restore and to restart.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoData.</i><b>DevInst</b> might be updated with a new handle value on return.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiunremovedevice
     * @since windows5.0
     */
    static SetupDiUnremoveDevice(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiUnremoveDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiRestartDevices function restarts a specified device or, if necessary, restarts all devices that are operated by the same function and filter drivers that operate the specified device.
     * @remarks
     * <b>SetupDiRestartDevices</b> should be called only by a class installer when a class installer is handling a DIF_INSTALLDEVICE request and only in rare situations where the class installer must perform operations after all default installation operations, except for starting a device, have completed . For more information about calling <b>SetupDiRestartDevices</b> in these situations, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-installdevice">DIF_INSTALLDEVICE</a>.
     * 
     * <b>SetupDiRestartDevices</b> restarts only the specified device if the restart can be performed without affecting the installation of other devices that are operated by the same function driver or filter drivers that operate the device. Specifically, if the restart of the specified device does not copy new files or modify any files that were previously installed for the device, <b>SetupDiRestartDevices</b> restarts only the specified device. Otherwise, the function restarts all devices that are operated by the same function and filter drivers that operate the specified device. 
     * 
     * <b>SetupDiRestartDevices</b> updates the device installation parameters and device status to reflect the result of the attempted restart operation. For example:
     * 
     * <ul>
     * <li>
     * If the device is started, <b>SetupDiRestartDevices</b> sets the device status to DN_STARTED. 
     * 
     * </li>
     * <li>
     * If a system restart is necessary to start a device, <b>SetupDiRestartDevices</b> sets the DI_NEEDREBOOT flag in the <b>Flags</b> member of the SP_DEVINSTALL_PARAMETER structure that is associated with the device information element and sets the problem code for the device to CM_PROB_NEED_RESTART. 
     * 
     * </li>
     * </ul>
     * The <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status">CM_Get_DevNode_Status</a> function retrieves the status and problem code for a device instance and the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinstallparamsa">SetupDiGetDeviceInstallParams</a> function retrieves the device installation parameters for the device information element that represents the device instance.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element that represents the device to restart.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for the device information member that represents the device to restart. This parameter is also an output parameter because <b>SetupDiRestartDevices</b> updates the device installation parameters for this device information member and the status and problem code of the corresponding device instance. For more information about these updates, see the following <b>Remarks</b> section.
     * @returns {Integer} If the operation succeeds, <b>SetupDiRestartDevices</b> returns <b>TRUE</b>; otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdirestartdevices
     */
    static SetupDiRestartDevices(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiRestartDevices", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiChangeState function is the default handler for the DIF_PROPERTYCHANGE installation request.
     * @remarks
     * <b>SetupDiChangeState</b> changes the state of an installed device.
     * 
     * The caller of <b>SetupDiChangeState</b> must be a member of the Administrators group.
     * 
     * <div class="alert"><b>Note</b>Only a class installer should call <b>SetupDiChangeState</b> and only in those situations where the class installer must perform property change operations after <b>SetupDiChangeState</b> completes the default property change operation. In such situations, the class installer must directly call <b>SetupDiChangeState</b> when the installer processes a DIF_PROPERTYCHANGE request. For more information about calling the default handler, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/calling-the-default-dif-code-handlers">Calling Default DIF Code Handlers</a>.</div>
     * <div></div>
     * Callers of <b>SetupDiChangeState</b> must specify a DICS_<i>XXX</i> flag in the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_propchange_params">SP_PROPCHANGE_PARAMS</a> for the device element that indicates the type of state change to perform on the device. Callers of this function must set the appropriate fields in the SP_PROPCHANGE_PARAMS and call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclassinstallparamsa">SetupDiSetClassInstallParams</a> before calling this function.
     * 
     * If you specify the DICS_FLAG_CONFIGSPECIFIC flag in the SP_PROPCHANGE_PARAMS then you must fill in the <b>HwProfile</b> field. A value of zero for <b>HwProfile</b> indicates the current profile. 
     * 
     * To enable/disable a device in the current hardware profile, set the DICS_FLAG_CONFIGSPECIFIC flag in the SP_PROPCHANGE_PARAMS. To enable/disable a device globally, such as in both the docked and undocked hardware profiles, set the DICS_FLAG_GLOBAL flag.
     * 
     * This function does the following:
     * 
     * 
     * 
     * Callers of this function should not specify DICS_STOP or DICS_START in the SP_PROPCHANGE_PARAMS. Use DICS_PROPCHANGE to stop and restart a device to cause changes in the device's configuration to take effect.
     * 
     * If DI_DONOTCALLCONFIGMG is set for a device, you should not call <b>SetupDiChangeState</b> for the device but should instead set the DI_NEEDREBOOT flag.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local computer. This set contains a device information element that represents the device whose state is to be changed.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This is an IN-OUT parameter because <i>DeviceInfoData.</i><b>DevInst</b> might be updated with a new handle value upon return.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdichangestate
     * @since windows5.0
     */
    static SetupDiChangeState(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiChangeState", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallClass function installs the ClassInstall32 section of the specified INF file. (ANSI)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * This function is called by a class installer when it installs a device of a new device class.
     * 
     * To install an interface class or a device class, use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiinstallclassexa">SetupDiInstallClassEx</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiInstallClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent The handle to the parent window for any user interface that is used to install this class. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<PSTR>} InfFileName A pointer to a NULL-terminated string that contains the name of the INF file that contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-classinstall32-section">INF ClassInstall32 section</a>.
     * @param {Integer} Flags These flags control the installation process. Can be a combination of the following:
     * @param {Pointer<Void>} FileQueue If the DI_NOVCP flag is set, this parameter supplies a handle to a file queue where file operations should be queued but not committed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstallclassa
     * @since windows5.0
     */
    static SetupDiInstallClassA(hwndParent, InfFileName, Flags, FileQueue) {
        InfFileName := InfFileName is String? StrPtr(InfFileName) : InfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallClassA", "ptr", hwndParent, "ptr", InfFileName, "uint", Flags, "ptr", FileQueue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallClass function installs the ClassInstall32 section of the specified INF file. (Unicode)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * This function is called by a class installer when it installs a device of a new device class.
     * 
     * To install an interface class or a device class, use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiinstallclassexa">SetupDiInstallClassEx</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiInstallClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent The handle to the parent window for any user interface that is used to install this class. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} InfFileName A pointer to a NULL-terminated string that contains the name of the INF file that contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-classinstall32-section">INF ClassInstall32 section</a>.
     * @param {Integer} Flags These flags control the installation process. Can be a combination of the following:
     * @param {Pointer<Void>} FileQueue If the DI_NOVCP flag is set, this parameter supplies a handle to a file queue where file operations should be queued but not committed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstallclassw
     * @since windows5.0
     */
    static SetupDiInstallClassW(hwndParent, InfFileName, Flags, FileQueue) {
        InfFileName := InfFileName is String? StrPtr(InfFileName) : InfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallClassW", "ptr", hwndParent, "ptr", InfFileName, "uint", Flags, "ptr", FileQueue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallClassEx function installs a class installer or an interface class. (ANSI)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * <b>SetupDiInstallClassEx</b> is typically called by a class installer to install a new <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> or a new <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>. 
     * 
     * <div class="alert"><b>Note</b>An interface class can also be installed automatically by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiinstalldeviceinterfaces">SetupDiInstallDeviceInterfaces</a> to install the device interfaces for a device.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiInstallClassEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent The handle to the parent window for any user interface that is used to install this class. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<PSTR>} InfFileName A pointer to a NULL-terminated string that contains the name of an INF file. This parameter is optional and can be <b>NULL</b>. If this function is being used to install a class installer, the INF file contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-classinstall32-section">INF ClassInstall32 section</a> and this parameter must not be <b>NULL</b>.
     * 
     * If this function is being used to install an interface class, the INF file contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-interfaceinstall32-section">INF InterfaceInstall32 section</a>.
     * @param {Integer} Flags 
     * @param {Pointer<Void>} FileQueue If the DI_NOVCP flag is set, this parameter supplies a handle to a file queue where file operations should be queued but not committed.
     * @param {Pointer<Guid>} InterfaceClassGuid A pointer to a GUID that identifies the interface class to be installed. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, this function is being used to install the interface class represented by the GUID. If this parameter is <b>NULL</b>, this function is being used to install a class installer.
     * @returns {Integer} <b>SetupDiInstallClassEx</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstallclassexa
     * @since windows5.0
     */
    static SetupDiInstallClassExA(hwndParent, InfFileName, Flags, FileQueue, InterfaceClassGuid) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        InfFileName := InfFileName is String? StrPtr(InfFileName) : InfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallClassExA", "ptr", hwndParent, "ptr", InfFileName, "uint", Flags, "ptr", FileQueue, "ptr", InterfaceClassGuid, "ptr", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiInstallClassEx function installs a class installer or an interface class. (Unicode)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * <b>SetupDiInstallClassEx</b> is typically called by a class installer to install a new <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> or a new <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>. 
     * 
     * <div class="alert"><b>Note</b>An interface class can also be installed automatically by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiinstalldeviceinterfaces">SetupDiInstallDeviceInterfaces</a> to install the device interfaces for a device.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiInstallClassEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent The handle to the parent window for any user interface that is used to install this class. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} InfFileName A pointer to a NULL-terminated string that contains the name of an INF file. This parameter is optional and can be <b>NULL</b>. If this function is being used to install a class installer, the INF file contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-classinstall32-section">INF ClassInstall32 section</a> and this parameter must not be <b>NULL</b>.
     * 
     * If this function is being used to install an interface class, the INF file contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-interfaceinstall32-section">INF InterfaceInstall32 section</a>.
     * @param {Integer} Flags 
     * @param {Pointer<Void>} FileQueue If the DI_NOVCP flag is set, this parameter supplies a handle to a file queue where file operations should be queued but not committed.
     * @param {Pointer<Guid>} InterfaceClassGuid A pointer to a GUID that identifies the interface class to be installed. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, this function is being used to install the interface class represented by the GUID. If this parameter is <b>NULL</b>, this function is being used to install a class installer.
     * @returns {Integer} <b>SetupDiInstallClassEx</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiinstallclassexw
     * @since windows5.0
     */
    static SetupDiInstallClassExW(hwndParent, InfFileName, Flags, FileQueue, InterfaceClassGuid) {
        static Reserved1 := 0, Reserved2 := 0 ;Reserved parameters must always be NULL

        InfFileName := InfFileName is String? StrPtr(InfFileName) : InfFileName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiInstallClassExW", "ptr", hwndParent, "ptr", InfFileName, "uint", Flags, "ptr", FileQueue, "ptr", InterfaceClassGuid, "ptr", Reserved1, "ptr", Reserved2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenClassRegKey function opens the setup class registry key or a specific class's subkey.
     * @remarks
     * Depending on the value that is passed in the <i>samDesired</i> parameter, it might be necessary for the caller of this function to be a member of the Administrators group.
     * 
     * This function does not create a registry key if it does not already exist.
     * 
     * The handle returned from this function must be closed by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * 
     * To open the interface class registry key or a specific interface class subkey, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiopenclassregkeyexa">SetupDiOpenClassRegKeyEx</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the setup class whose key is to be opened. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the root of the setup class tree (<b>HKLM\SYSTEM\CurrentControlSet\Control\Class</b>) is opened.
     * @param {Integer} samDesired The registry security access for the key to be opened. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @returns {Pointer<HKEY>} If the function is successful, it returns a handle to an opened registry key where information about this setup class can be stored/retrieved. 
     * 
     * If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopenclassregkey
     * @since windows5.0
     */
    static SetupDiOpenClassRegKey(ClassGuid, samDesired) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenClassRegKey", "ptr", ClassGuid, "uint", samDesired, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenClassRegKeyEx function opens the device setup class registry key, the device interface class registry key, or a specific class's subkey. This function opens the specified key on the local computer or on a remote computer. (ANSI)
     * @remarks
     * Depending on the value that is passed in the <i>samDesired</i> parameter, it might be necessary for the caller of this function to be a member of the Administrators group.
     * 
     * <b>SetupDiOpenClassRegKeyEx</b> does not create a registry key if it does not already exist.
     * 
     * Callers of this function must close the handle returned from this function by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiOpenClassRegKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the class whose registry key is to be opened. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the root of the class tree (<b>HKLM\SYSTEM\CurrentControlSet\Control\Class</b>) is opened.
     * @param {Integer} samDesired The registry security access for the key to be opened. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @param {Integer} Flags The type of registry key to be opened, which is specified by one of the following:
     * @param {Pointer<PSTR>} MachineName Optionally points to a string that contains the name of a remote computer on which to open the specified key.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Pointer<HKEY>} <b>SetupDiOpenClassRegKeyEx</b> returns a handle to an opened registry key where information about this setup class can be stored/retrieved. 
     * 
     * If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopenclassregkeyexa
     * @since windows5.0
     */
    static SetupDiOpenClassRegKeyExA(ClassGuid, samDesired, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenClassRegKeyExA", "ptr", ClassGuid, "uint", samDesired, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenClassRegKeyEx function opens the device setup class registry key, the device interface class registry key, or a specific class's subkey. This function opens the specified key on the local computer or on a remote computer. (Unicode)
     * @remarks
     * Depending on the value that is passed in the <i>samDesired</i> parameter, it might be necessary for the caller of this function to be a member of the Administrators group.
     * 
     * <b>SetupDiOpenClassRegKeyEx</b> does not create a registry key if it does not already exist.
     * 
     * Callers of this function must close the handle returned from this function by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiOpenClassRegKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the class whose registry key is to be opened. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the root of the class tree (<b>HKLM\SYSTEM\CurrentControlSet\Control\Class</b>) is opened.
     * @param {Integer} samDesired The registry security access for the key to be opened. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @param {Integer} Flags The type of registry key to be opened, which is specified by one of the following:
     * @param {Pointer<PWSTR>} MachineName Optionally points to a string that contains the name of a remote computer on which to open the specified key.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Pointer<HKEY>} <b>SetupDiOpenClassRegKeyEx</b> returns a handle to an opened registry key where information about this setup class can be stored/retrieved. 
     * 
     * If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopenclassregkeyexw
     * @since windows5.0
     */
    static SetupDiOpenClassRegKeyExW(ClassGuid, samDesired, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenClassRegKeyExW", "ptr", ClassGuid, "uint", samDesired, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDeviceInterfaceRegKey function creates a registry key for storing information about a device interface and returns a handle to the key. (ANSI)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * If the requested key for the device interface already exists, <b>SetupDiCreateDeviceInterfaceRegKey</b> returns a handle to that key; otherwise, <b>SetupDiCreateDeviceInterfaceRegKey</b> creates a new nonvolatile registry key for the specified device interface. Callers of this function can store private configuration data for the device interface in this key. The driver for the device can access this key using <b>Io</b><i>Xxx</i> routines.
     * 
     * Close the handle returned from this function by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * 
     * For installations that use layout files (specified by the <b>LayoutFile</b> entry in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-version-section">INF Version section</a>), the layout file must be opened by a call to <b>SetupOpenAppendInfFile</b> (described in Windows SDK documentation) before <b>SetupDiCreateDeviceInterfaceRegKey</b> is called.
     * 
     * The device information set specified by <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDeviceInterfaceRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface for which to create a registry key. The device information set must not contain remote elements.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i>. This pointer is possibly returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea">SetupDiCreateDeviceInterface</a>.
     * @param {Integer} samDesired The registry security access that the caller requests for the key that is being created. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @param {Pointer<Void>} InfHandle The handle to an open INF file that contains a <i>DDInstall</i> section to be executed for the newly-created key. This parameter is optional and can be <b>NULL</b>. If this parameter is not <b>NULL</b>, <i>InfSectionName</i> must be specified as well.
     * @param {Pointer<PSTR>} InfSectionName A pointer to the name of an INF <i>DDInstall</i> section in the INF file that is specified by <i>InfHandle</i>. This section is executed for the newly created key. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <i>InfHandle</i> must be specified as well.
     * @returns {Pointer<HKEY>} If <b>SetupDiCreateDeviceInterfaceRegKey</b> succeeds, the function returns a handle to the requested registry key in which interface information can be stored and retrieved. If <b>SetupDiCreateDeviceInterfaceRegKey</b> fails, the function returns INVALID_HANDLE_VALUE. Call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinterfaceregkeya
     * @since windows5.0
     */
    static SetupDiCreateDeviceInterfaceRegKeyA(DeviceInfoSet, DeviceInterfaceData, samDesired, InfHandle, InfSectionName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionName := InfSectionName is String? StrPtr(InfSectionName) : InfSectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInterfaceRegKeyA", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Reserved, "uint", samDesired, "ptr", InfHandle, "ptr", InfSectionName, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDeviceInterfaceRegKey function creates a registry key for storing information about a device interface and returns a handle to the key. (Unicode)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * If the requested key for the device interface already exists, <b>SetupDiCreateDeviceInterfaceRegKey</b> returns a handle to that key; otherwise, <b>SetupDiCreateDeviceInterfaceRegKey</b> creates a new nonvolatile registry key for the specified device interface. Callers of this function can store private configuration data for the device interface in this key. The driver for the device can access this key using <b>Io</b><i>Xxx</i> routines.
     * 
     * Close the handle returned from this function by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * 
     * For installations that use layout files (specified by the <b>LayoutFile</b> entry in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-version-section">INF Version section</a>), the layout file must be opened by a call to <b>SetupOpenAppendInfFile</b> (described in Windows SDK documentation) before <b>SetupDiCreateDeviceInterfaceRegKey</b> is called.
     * 
     * The device information set specified by <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDeviceInterfaceRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface for which to create a registry key. The device information set must not contain remote elements.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i>. This pointer is possibly returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea">SetupDiCreateDeviceInterface</a>.
     * @param {Integer} samDesired The registry security access that the caller requests for the key that is being created. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @param {Pointer<Void>} InfHandle The handle to an open INF file that contains a <i>DDInstall</i> section to be executed for the newly-created key. This parameter is optional and can be <b>NULL</b>. If this parameter is not <b>NULL</b>, <i>InfSectionName</i> must be specified as well.
     * @param {Pointer<PWSTR>} InfSectionName A pointer to the name of an INF <i>DDInstall</i> section in the INF file that is specified by <i>InfHandle</i>. This section is executed for the newly created key. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <i>InfHandle</i> must be specified as well.
     * @returns {Pointer<HKEY>} If <b>SetupDiCreateDeviceInterfaceRegKey</b> succeeds, the function returns a handle to the requested registry key in which interface information can be stored and retrieved. If <b>SetupDiCreateDeviceInterfaceRegKey</b> fails, the function returns INVALID_HANDLE_VALUE. Call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedeviceinterfaceregkeyw
     * @since windows5.0
     */
    static SetupDiCreateDeviceInterfaceRegKeyW(DeviceInfoSet, DeviceInterfaceData, samDesired, InfHandle, InfSectionName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionName := InfSectionName is String? StrPtr(InfSectionName) : InfSectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDeviceInterfaceRegKeyW", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Reserved, "uint", samDesired, "ptr", InfHandle, "ptr", InfSectionName, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenDeviceInterfaceRegKey function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface.
     * @remarks
     * Depending on the value that is passed in the <i>samDesired</i> parameter, it might be necessary for the caller of this function to be a member of the Administrators group.
     * 
     * Close the handle returned from by function by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * @param {Pointer} DeviceInfoSet A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface for which to open a registry subkey.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface. This pointer can be returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea">SetupDiCreateDeviceInterface</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @param {Integer} samDesired The requested registry security access to the registry subkey. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @returns {Pointer<HKEY>} <b>SetupDiOpenDeviceInterfaceRegKey</b> returns a handle to the opened registry key. If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendeviceinterfaceregkey
     * @since windows5.0
     */
    static SetupDiOpenDeviceInterfaceRegKey(DeviceInfoSet, DeviceInterfaceData, samDesired) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDeviceInterfaceRegKey", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Reserved, "uint", samDesired, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDeleteDeviceInterfaceRegKey function deletes the registry subkey that is used by applications and drivers to store interface-specific information.
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * <b>SetupDiDeleteDeviceInterfaceRegKey</b> deletes the subkey used by drivers and applications to store information about the device interface instance. This subkey was created by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinterfaceregkeya">SetupDiCreateDeviceInterfaceRegKey</a> or by the driver's call to an associated <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/_kernel/#io-manager-routines">I/O manager routine</a>. <b>SetupDiDeleteDeviceInterfaceRegKey</b> does not affect the main registry key for the device interface instance nor any other subkeys that may have been created.
     * 
     * The <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * @param {Pointer} DeviceInfoSet A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the interface for which to delete interface-specific information in the registry. The device information set must not contain remote elements.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that specifies the device interface in <i>DeviceInfoSet</i>. This pointer is possibly returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicreatedeviceinterfacea">SetupDiCreateDeviceInterface</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinterfaces">SetupDiEnumDeviceInterfaces</a>.
     * @returns {Integer} <b>SetupDiDeleteDeviceInterfaceRegKey</b> returns <b>TRUE</b> if it is successful; otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdideletedeviceinterfaceregkey
     * @since windows5.0
     */
    static SetupDiDeleteDeviceInterfaceRegKey(DeviceInfoSet, DeviceInterfaceData) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDeleteDeviceInterfaceRegKey", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "uint", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDevRegKey function creates a registry key for device-specific configuration information and returns a handle to the key. (ANSI)
     * @remarks
     * The caller of <b>SetupDiCreateDevRegKey</b> must be a member of the Administrators group.
     * 
     * Close the handle returned from <b>SetupDiCreateDevRegKey</b> by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * 
     * If the specified key already exists, <b>SetupDiCreateDevRegKey</b> returns a handle to that key. Otherwise, <b>SetupDiCreateDevRegKey</b> creates the specified key and returns a handle to the new key. For Windows Server 2003 and later versions of Windows, the key handle has KEY_READ and KEY_WRITE access only. For previous Windows versions, this handle has KEY_ALL_ACCESS access. 
     * 
     * The specified device instance must be registered before <b>SetupDiCreateDevRegKey</b> is called. Note, however, that the operating system automatically registers PnP device instances. For information about how to register non-PnP device instances, see <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiregisterdeviceinfo">SetupDiRegisterDeviceInfo</a>.
     * 
     * For installations that use layout files (specified by the <b>LayoutFile</b> entry in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-version-section">INF Version section</a>), the layout file must be opened by a call to <b>SetupOpenAppendInfFile</b> (described in the Microsoft Windows SDK documentation) before <b>SetupDiCreateDevRegKey</b> is called.
     * 
     * If the supplied device information set contains device information elements for a remote system, and <i>InfHandle</i> and <i>InfSectionName</i> are also specified, the create request will fail, and a subsequent call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_REMOTE_REQUEST_UNSUPPORTED.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDevRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to create a registry key.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} Scope 
     * @param {Integer} HwProfile The hardware profile for which to create a key if <i>HwProfileFlags</i> is set to SPDICS_FLAG_CONFIGSPECIFIC. If <i>HwProfile</i> is 0, the key for the current hardware profile is created. If <i>HwProfileFlags</i> is SPDICS_FLAG_GLOBAL, <i>HwProfile</i> is ignored.
     * @param {Integer} KeyType 
     * @param {Pointer<Void>} InfHandle The handle to an open INF file that contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-section">INF DDInstall section</a> to be executed for the newly created key. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <i>InfSectionName</i> must be specified as well.
     * @param {Pointer<PSTR>} InfSectionName The name of an INF <i>DDInstall</i> section in the INF file specified by <i>InfHandle</i>. This section is executed for the newly created key. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <i>InfHandle</i> must be specified as well.
     * @returns {Pointer<HKEY>} If <b>SetupDiCreateDevRegKey</b> succeeds, the function returns a handle to the specified registry key in which device-specific configuration data can be stored and retrieved. If <b>SetupDiCreateDevRegKey</b> fails, the function returns INVALID_HANDLE_VALUE. Call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedevregkeya
     * @since windows5.0
     */
    static SetupDiCreateDevRegKeyA(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, InfHandle, InfSectionName) {
        InfSectionName := InfSectionName is String? StrPtr(InfSectionName) : InfSectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDevRegKeyA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Scope, "uint", HwProfile, "uint", KeyType, "ptr", InfHandle, "ptr", InfSectionName, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiCreateDevRegKey function creates a registry key for device-specific configuration information and returns a handle to the key. (Unicode)
     * @remarks
     * The caller of <b>SetupDiCreateDevRegKey</b> must be a member of the Administrators group.
     * 
     * Close the handle returned from <b>SetupDiCreateDevRegKey</b> by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * 
     * If the specified key already exists, <b>SetupDiCreateDevRegKey</b> returns a handle to that key. Otherwise, <b>SetupDiCreateDevRegKey</b> creates the specified key and returns a handle to the new key. For Windows Server 2003 and later versions of Windows, the key handle has KEY_READ and KEY_WRITE access only. For previous Windows versions, this handle has KEY_ALL_ACCESS access. 
     * 
     * The specified device instance must be registered before <b>SetupDiCreateDevRegKey</b> is called. Note, however, that the operating system automatically registers PnP device instances. For information about how to register non-PnP device instances, see <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiregisterdeviceinfo">SetupDiRegisterDeviceInfo</a>.
     * 
     * For installations that use layout files (specified by the <b>LayoutFile</b> entry in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-version-section">INF Version section</a>), the layout file must be opened by a call to <b>SetupOpenAppendInfFile</b> (described in the Microsoft Windows SDK documentation) before <b>SetupDiCreateDevRegKey</b> is called.
     * 
     * If the supplied device information set contains device information elements for a remote system, and <i>InfHandle</i> and <i>InfSectionName</i> are also specified, the create request will fail, and a subsequent call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_REMOTE_REQUEST_UNSUPPORTED.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiCreateDevRegKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to create a registry key.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} Scope 
     * @param {Integer} HwProfile The hardware profile for which to create a key if <i>HwProfileFlags</i> is set to SPDICS_FLAG_CONFIGSPECIFIC. If <i>HwProfile</i> is 0, the key for the current hardware profile is created. If <i>HwProfileFlags</i> is SPDICS_FLAG_GLOBAL, <i>HwProfile</i> is ignored.
     * @param {Integer} KeyType 
     * @param {Pointer<Void>} InfHandle The handle to an open INF file that contains an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-section">INF DDInstall section</a> to be executed for the newly created key. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <i>InfSectionName</i> must be specified as well.
     * @param {Pointer<PWSTR>} InfSectionName The name of an INF <i>DDInstall</i> section in the INF file specified by <i>InfHandle</i>. This section is executed for the newly created key. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <i>InfHandle</i> must be specified as well.
     * @returns {Pointer<HKEY>} If <b>SetupDiCreateDevRegKey</b> succeeds, the function returns a handle to the specified registry key in which device-specific configuration data can be stored and retrieved. If <b>SetupDiCreateDevRegKey</b> fails, the function returns INVALID_HANDLE_VALUE. Call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdicreatedevregkeyw
     * @since windows5.0
     */
    static SetupDiCreateDevRegKeyW(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, InfHandle, InfSectionName) {
        InfSectionName := InfSectionName is String? StrPtr(InfSectionName) : InfSectionName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiCreateDevRegKeyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Scope, "uint", HwProfile, "uint", KeyType, "ptr", InfHandle, "ptr", InfSectionName, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiOpenDevRegKey function opens a registry key for device-specific configuration information.
     * @remarks
     * Depending on the value that is passed in the <i>samDesired</i> parameter, it might be necessary for the caller of this function to be a member of the Administrators group.
     * 
     * Close the handle returned from this function by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>.
     * 
     * The specified device instance must be registered before this function is called. However, be aware that the operating system automatically registers PnP device instances. For information about how to register non-PnP device instances, see <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiregisterdeviceinfo">SetupDiRegisterDeviceInfo</a>.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to open a registry key.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} Scope 
     * @param {Integer} HwProfile A hardware profile value, which is set as follows:
     * 
     * <ul>
     * <li>
     * If <i>Scope</i> is set to DICS_FLAG_CONFIGSPECIFIC, <i>HwProfile</i> specifies the hardware profile of the key that is to be opened. 
     * 
     * </li>
     * <li>
     * If <i>HwProfile</i> is 0, the key for the current hardware profile is opened. 
     * 
     * </li>
     * <li>
     * If <i>Scope</i> is DICS_FLAG_GLOBAL, <i>HwProfile</i> is ignored.
     * 
     * </li>
     * </ul>
     * @param {Integer} KeyType 
     * @param {Integer} samDesired The registry security access that is required for the requested key. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.
     * @returns {Pointer<HKEY>} If the function is successful, it returns a handle to an opened registry key where private configuration data about this device instance can be stored/retrieved.
     * 
     * If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopendevregkey
     * @since windows5.0
     */
    static SetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, samDesired) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiOpenDevRegKey", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Scope, "uint", HwProfile, "uint", KeyType, "uint", samDesired, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDeleteDevRegKey function deletes specified user-accessible registry keys that are associated with a device information element.
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * The <i>DeviceInfoSet</i> must only contain elements on the local computer.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to delete registry keys. The device information set must not contain remote elements.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} Scope 
     * @param {Integer} HwProfile If <i>Scope</i> is set to DICS_FLAG_CONFIGSPECIFIC, the <i>HwProfile</i> parameter specifies the hardware profile for which to delete the registry key. If <i>HwProfile</i> is 0, the key for the current hardware profile is deleted. If <i>HwProfile</i> is 0xFFFFFFFF, the registry key for all hardware profiles is deleted.
     * @param {Integer} KeyType 
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdideletedevregkey
     * @since windows5.0
     */
    static SetupDiDeleteDevRegKey(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDeleteDevRegKey", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Scope, "uint", HwProfile, "uint", KeyType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileList function retrieves a list of all currently defined hardware profile IDs.
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigethwprofilelistexa">SetupDiGetHwProfileListEx</a> to retrieve the hardware profile IDs for a remote computer.
     * @param {Pointer<UInt32>} HwProfileList A pointer to an array to receive the list of currently defined hardware profile IDs.
     * @param {Integer} HwProfileListSize The number of DWORDs in the <i>HwProfileList</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of hardware profiles currently defined. If the number is larger than <i>HwProfileListSize</i>, the list is truncated to fit the array size. The value returned in <i>RequiredSize</i> indicates the array size required to store the entire list of hardware profiles. In this case, the function fails and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @param {Pointer<UInt32>} CurrentlyActiveIndex A pointer to a variable of type DWORD that receives the index of the currently active hardware profile in the retrieved hardware profile list. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigethwprofilelist
     * @since windows5.0
     */
    static SetupDiGetHwProfileList(HwProfileList, HwProfileListSize, RequiredSize, CurrentlyActiveIndex) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileList", "ptr", HwProfileList, "uint", HwProfileListSize, "ptr", RequiredSize, "ptr", CurrentlyActiveIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileListEx function retrieves a list of all currently defined hardware profile IDs on a local or remote computer. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetHwProfileListEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} HwProfileList A pointer to an array to receive the list of currently defined hardware profile IDs.
     * @param {Integer} HwProfileListSize The number of DWORDs in the <i>HwProfileList</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of hardware profiles that are currently defined. If the number is larger than <i>HwProfileListSize</i>, the list is truncated to fit the array size. The value returned in <i>RequiredSize</i> indicates the array size required to store the entire list of hardware profiles.
     * @param {Pointer<UInt32>} CurrentlyActiveIndex A pointer to a variable that receives the index of the currently active hardware profile in the retrieved hardware profile list. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<PSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system for which to retrieve the list of hardware profile IDs. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the list is retrieved for the local system.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the required size is larger than <i>HwProfileListSize</i>, <b>SetupDiGetHwProfileListEx</b> returns <b>FALSE</b> and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigethwprofilelistexa
     * @since windows5.0
     */
    static SetupDiGetHwProfileListExA(HwProfileList, HwProfileListSize, RequiredSize, CurrentlyActiveIndex, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileListExA", "ptr", HwProfileList, "uint", HwProfileListSize, "ptr", RequiredSize, "ptr", CurrentlyActiveIndex, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileListEx function retrieves a list of all currently defined hardware profile IDs on a local or remote computer. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetHwProfileListEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} HwProfileList A pointer to an array to receive the list of currently defined hardware profile IDs.
     * @param {Integer} HwProfileListSize The number of DWORDs in the <i>HwProfileList</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of hardware profiles that are currently defined. If the number is larger than <i>HwProfileListSize</i>, the list is truncated to fit the array size. The value returned in <i>RequiredSize</i> indicates the array size required to store the entire list of hardware profiles.
     * @param {Pointer<UInt32>} CurrentlyActiveIndex A pointer to a variable that receives the index of the currently active hardware profile in the retrieved hardware profile list. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system for which to retrieve the list of hardware profile IDs. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the list is retrieved for the local system.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the required size is larger than <i>HwProfileListSize</i>, <b>SetupDiGetHwProfileListEx</b> returns <b>FALSE</b> and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INSUFFICIENT_BUFFER.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigethwprofilelistexw
     * @since windows5.0
     */
    static SetupDiGetHwProfileListExW(HwProfileList, HwProfileListSize, RequiredSize, CurrentlyActiveIndex, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileListExW", "ptr", HwProfileList, "uint", HwProfileListSize, "ptr", RequiredSize, "ptr", CurrentlyActiveIndex, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDevicePropertyKeys function retrieves an array of the device property keys that represent the device properties that are set for a device instance.
     * @remarks
     * <b>SetupDiGetDevicePropertyKeys</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>. 
     * 
     * If the <i>ProperKeyArray</i> buffer is not large enough to hold all the requested property keys, <b>SetupDiGetDevicePropertyKeys</b> does not retrieve any property keys and returns ERROR_INSUFFICIENT_BUFFER. If the caller supplied a <i>RequiredPropertyKeyCount</i> pointer, <b>SetupDiGetDevicePropertyKeys</b> sets the value of *<i>RequiredPropertyKeyCount</i> to the required size, in DEVPROPKEY-typed values, of the <i>PropertyKeyArray </i> buffer<i>.</i>
     * 
     * To retrieve a device instance property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdevicepropertyw">SetupDiGetDeviceProperty</a>, and to set a device instance property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetdevicepropertyw">SetupDiSetDeviceProperty</a>.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>. This device information set contains the device instance for which this function retrieves an array of device property keys. The property keys represent the device properties that are set for the device instance.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device instance for which to retrieve the requested array of device property keys.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray A pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device instance. The pointer is optional and can be <b>NULL</b>. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyKeyCount The size, in DEVPROPKEY-typed values, of the <i>PropertyKeyArray </i> buffer<i>. </i>If <i>PropertyKeyArray</i> is set to <b>NULL</b>, <i>PropertyKeyCount</i> must be set to zero.
     * @param {Pointer<UInt32>} RequiredPropertyKeyCount A pointer to a DWORD-typed variable that receives the number of requested device property keys. The pointer is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {Integer} <b>SetupDiGetDevicePropertyKeys</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device information element is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyKeyArray</i> is <b>NULL</b> and <i>PropertKeyCount</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device instance that is specified by <i>DevInfoData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyKeyArray</i> buffer is too small to hold all the requested property keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdevicepropertykeys
     * @since windows6.0.6000
     */
    static SetupDiGetDevicePropertyKeys(DeviceInfoSet, DeviceInfoData, PropertyKeyArray, PropertyKeyCount, RequiredPropertyKeyCount, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDevicePropertyKeys", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertyKeyArray, "uint", PropertyKeyCount, "ptr", RequiredPropertyKeyCount, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceProperty function retrieves a device instance property.
     * @remarks
     * <b>SetupDiGetDeviceProperty</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>.
     * 
     * SetupAPI supports only a Unicode version of <b>SetupDiGetDeviceProperty</b>.
     * 
     * To obtain the device property keys that represent the device properties that are set for a device instance, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdevicepropertykeys">SetupDiGetDevicePropertyKeys</a>.
     * 
     * To set a device instance property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetdevicepropertyw">SetupDiSetDeviceProperty</a>.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device instance for which to retrieve a device instance property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device instance for which to retrieve a device instance property.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device instance property.
     * @param {Pointer<UInt32>} PropertyType A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device instance property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the requested device instance property. <b>SetupDiGetDeviceProperty</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be <b>NULL</b>. If the pointer is set to <b>NULL</b> and <i>RequiredSize</i> is supplied, <b>SetupDiGetDeviceProperty</b> returns the size of the property, in bytes, in *<i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in bytes, of either the device instance property if the property is retrieved or the required buffer size if the buffer is not large enough. This pointer can be set to <b>NULL</b>.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {Integer} <b>SetupDiGetDeviceProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device information element is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b> and <i>PropertBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device instance that is specified by <i>DevInfoData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyBuffer</i> buffer is too small to hold the requested property value, or an internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested device property does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdevicepropertyw
     * @since windows6.0.6000
     */
    static SetupDiGetDevicePropertyW(DeviceInfoSet, DeviceInfoData, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, RequiredSize, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDevicePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceProperty function sets a device instance property.
     * @remarks
     * <b>SetupDiSetDeviceProperty</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>. 
     * 
     * SetupAPI supports only a Unicode version of <b>SetupDiSetDeviceProperty</b>. 
     * 
     * A caller of <b>SetupDiSetDeviceProperty</b> must be a member of the Administrators group to set a device instance property. 
     * 
     * <b>SetupDiSetDeviceProperty</b> enforces requirements on the property-data-type identifier and the property value. 
     * 
     * To obtain the device property keys for the instance device properties that are set for a device, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdevicepropertykeys">SetupDiGetDevicePropertyKeys</a>.
     * 
     * To retrieve a device instance property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdevicepropertyw">SetupDiGetDeviceProperty</a>.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>. This device information set contains a device information element that represents the device instance for which to set a device instance property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that identifies the device instance for which to set a device instance property.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the device instance property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device instance property. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that contains the device instance property value. If the property is being deleted or set to a <b>NULL</b> value, this pointer must be <b>NULL</b>, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer </i> is <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device information element is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid or the property is not writable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property-data-type identifier that is supplied by <i>PropertyType</i>, or the property value that is supplied by <i>PropertyBuffer,</i> is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device instance that is specified by <i>DevInfoData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal element was not found. One possibility is that the property to be deleted does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdevicepropertyw
     * @since windows6.0.6000
     */
    static SetupDiSetDevicePropertyW(DeviceInfoSet, DeviceInfoData, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDevicePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfacePropertyKeys function retrieves an array of device property keys that represent the device properties that are set for a device interface.
     * @remarks
     * <b>SetupDiGetDeviceInterfacePropertyKeys</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>. 
     * 
     * If the <i>PropertyKeyArray</i> buffer is not large enough to hold all the requested property keys, <b>SetupDiGetDeviceInterfacePropertyKeys</b> does not retrieve any property keys and returns ERROR_INSUFFICIENT_BUFFER. If the caller supplied a <i>RequiredPropertyKeyCount</i> pointer, <b>SetupDiGetDeviceInterfacePropertyKeys</b> sets the value of *<i>RequiredPropertyKeyCount</i> to the required size, in DEVPROPKEY-typed values, of the <i>PropertyKeyArray </i> buffer<i>.</i>
     * 
     * To retrieve a device interface property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinterfacepropertyw">SetupDiGetDeviceInterfaceProperty</a><b>,</b> and to set a device interface property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetdeviceinterfacepropertyw">SetupDiSetDeviceInterfaceProperty</a>.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a>. This device information set contains a device interface for which to retrieve an array of the device property keys that represent the device properties that are set for a device interface.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that represents the device interface for which to retrieve the requested array of device property keys.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray A pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key for a device property that is set for the device interface. The pointer is optional and can be <b>NULL</b>. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyKeyCount The size, in DEVPROPKEY-typed elements, of the <i>PropertyKeyArray </i> buffer<i>. </i>If <i>PropertyKeyArray</i> is <b>NULL</b>, <i>PropertyKeyCount</i> must be set to zero.
     * @param {Pointer<UInt32>} RequiredPropertyKeyCount A pointer to a DWORD-typed variable that receives the number of requested device property keys. The pointer is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter is not valid. One possibility is that the device interface that is specified by <i>DevInterfaceData</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyKeyArray</i> is <b>NULL</b>, and <i>PropertKeyCount</i> is not zero. .
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface that is specified by <i>DeviceInterfaceData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyKeyArray</i> buffer is not large enough to hold all the requested property keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinterfacepropertykeys
     * @since windows6.0.6000
     */
    static SetupDiGetDeviceInterfacePropertyKeys(DeviceInfoSet, DeviceInterfaceData, PropertyKeyArray, PropertyKeyCount, RequiredPropertyKeyCount, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfacePropertyKeys", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", PropertyKeyArray, "uint", PropertyKeyCount, "ptr", RequiredPropertyKeyCount, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInterfaceProperty function retrieves a device property that is set for a device interface.
     * @remarks
     * <b>SetupDiGetDeviceInterfaceProperty</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>. 
     * 
     * SetupAPI supports only a Unicode version of <b>SetupDiGetDeviceInterfaceProperty</b>. 
     * 
     * A caller of <b>SetupDiGetDeviceInterfaceProperty</b> must be a member of the Administrators group to set a device interface property. 
     * 
     * To obtain the device property keys that represent the device properties that are set for a device interface, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinterfacepropertykeys">SetupDiGetDeviceInterfacePropertyKeys</a>.
     * 
     * To set a device interface property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetdeviceinterfacepropertyw">SetupDiSetDeviceInterfaceProperty</a>.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device interface for which to retrieve a device interface property.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that represents the device interface for which to retrieve a device interface property.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device interface property key of the device interface property to retrieve.
     * @param {Pointer<UInt32>} PropertyType A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device interface property. The property-data-type identifier is a bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the requested device interface property. <b>SetupDiGetDeviceInterfaceProperty</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be <b>NULL</b>. If the pointer is set to <b>NULL</b> and <i>RequiredSize</i> is supplied, <b>SetupDiGetDeviceInterfaceProperty</b> returns the size of the property, in bytes, in *<i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives the size, in bytes, of either the device interface property if the property is retrieved or the required buffer size, if the buffer is not large enough. This pointer can be set to <b>NULL</b>.
     * @param {Integer} Flags This parameter must be set to zero.
     * @returns {Integer} <b>SetupDiGetDeviceInterfaceProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. Other error codes can be set by the device installer functions that are called by this API.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device interface that is specified by <i>DeviceInterfaceData</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface that is specified by <i>DeviceInterfaceData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyBuffer</i> buffer is not large enough to hold the property value, or an internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested device property does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinterfacepropertyw
     * @since windows6.0.6000
     */
    static SetupDiGetDeviceInterfacePropertyW(DeviceInfoSet, DeviceInterfaceData, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, RequiredSize, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInterfacePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceInterfaceProperty function sets a device property of a device interface.
     * @remarks
     * <b>SetupDiSetDeviceInterfaceProperty</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>. 
     * 
     * SetupAPI supports only a Unicode version of <b>SetupDiSetDeviceInterfaceProperty</b>. 
     * 
     * A caller of <b>SetupDiSetDeviceInterfaceProperty</b> must be a member of the Administrators group to set a device interface property. 
     * 
     * <b>SetupDiSetDeviceInterfaceProperty</b> enforces requirements on the property-data-type identifier and the property value. 
     * 
     * To obtain the device property keys that represent the device properties that are set for a device interface, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinterfacepropertykeys">SetupDiGetDeviceInterfacePropertyKeys</a>.
     * 
     * To retrieve a device interface property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinterfacepropertyw">SetupDiGetDeviceInterfaceProperty</a>.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device interface for which to set a device interface property.
     * @param {Pointer<SP_DEVICE_INTERFACE_DATA>} DeviceInterfaceData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_device_interface_data">SP_DEVICE_INTERFACE_DATA</a> structure that represents the device interface for which to set a device interface property.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the device interface property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier of the device interface property to set. For more information about the property-data-type identifier, see the <b>Remarks</b> section later in this topic.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that contains the device interface property value. If either the property or the interface value is being deleted, this pointer must be set to <b>NULL</b>, and <i>PropertyBufferSize</i> must be set to zero. For more information about property value data, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. The property buffer size must be consistent with the property-data-type identifier that is supplied by <i>PropertyType</i>. If <i>PropertyBuffer </i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} Flags Must be set to zero.
     * @returns {Integer} <b>SetupDiSetDeviceInterfaceProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, this function returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device information set that is specified by <i>DevInfoSet</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not valid. One possibility is that the device interface specified by <i>DeviceInterfaceData</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified data value was not valid. This error could be logged if either the symbolic link name of the device interface is not valid or the property-data-type identifier is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface that is specified by <i>DeviceInterfaceData</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal element was not found. One possibility is that a property to be deleted does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceinterfacepropertyw
     * @since windows6.0.6000
     */
    static SetupDiSetDeviceInterfacePropertyW(DeviceInfoSet, DeviceInterfaceData, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceInterfacePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInterfaceData, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassPropertyKeys function retrieves an array of the device property keys that represent the device properties that are set for a device setup class or a device interface class.
     * @remarks
     * <b>SetupDiGetClassPropertyKeys</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>. 
     * 
     * A caller of <b>SetupDiGetClassPropertyKeys</b> must be a member of the Administrators group to retrieve device property keys for a device class. 
     * 
     * If the <i>PropertyKeyArray</i> buffer is not large enough to hold all the requested property keys, <b>SetupDiGetClassPropertyKeys</b> does not retrieve any property keys and returns ERROR_INSUFFICIENT_BUFFER. If the caller supplied a <i>RequiredPropertyKeyCount</i> pointer, <b>SetupDiGetClassPropertyKeys</b> sets the value of *<i>RequiredPropertyKeyCount</i> to the required size, in DEVPROPKEY-typed values, of the <i>PropertyKeyArray </i> buffer<i>.</i>
     * 
     * To retrieve a device class property on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertyw">SetupDiGetClassProperty</a>. To set a device class property on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclasspropertyw">SetupDiSetClassProperty</a>.
     * 
     * To retrieve the property keys for a device setup class or device interface class on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertykeysexw">SetupDiGetClassPropertyKeysEx</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that represents a device setup class or a device interface class. <b>SetupDiGetClassPropertyKeys</b> retrieves an array of the device property keys that represent device properties that are set for the specified class. For information about specifying the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray A pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device class. The pointer is optional and can be <b>NULL</b>. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyKeyCount The size, in DEVPROPKEY-typed values, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to <b>NULL</b>, <i>PropertyKeyCount</i> must be set to zero.
     * @param {Pointer<UInt32>} RequiredPropertyKeyCount A pointer to a DWORD-typed variable that receives the number of requested property keys. The parameter is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags 
     * @returns {Integer} <b>SetupDiGetClassPropertyKeys</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the DICLASSPROP_INSTALLER flag is specified, this error code indicates that the device setup class that is specified by <i>ClassGuid</i> does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The reference string for the device interface that is specified by <i>ClassGuild</i> is not valid. This error can be returned if the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified data value is not valid. One possibility is that the <i>ClassGuid</i> value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified parameter is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyKeyArray</i> is <b>NULL</b>, and <i>PropertKeyCount</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the DICLASSPROP_INTERFACE flag is specified, this error code indicates that the device interface class that is specified by <i>ClassGuid</i> does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyKeyArray</i> buffer is not large enough to hold all the property keys, or an internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclasspropertykeys
     * @since windows6.0.6000
     */
    static SetupDiGetClassPropertyKeys(ClassGuid, PropertyKeyArray, PropertyKeyCount, RequiredPropertyKeyCount, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassPropertyKeys", "ptr", ClassGuid, "ptr", PropertyKeyArray, "uint", PropertyKeyCount, "ptr", RequiredPropertyKeyCount, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassPropertyKeysEx function retrieves an array of the device property keys that represent the device properties that are set for a device setup class or a device interface class on a local or a remote computer.
     * @remarks
     * <b>SetupDiGetClassPropertyKeysEx</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>.
     * 
     * A caller of <b>SetupDiGetClassPropertyKeysEx</b> must be a member of the Administrators group to retrieve device property keys for a device class. 
     * 
     * If the <i>PropertyKeyArray</i> buffer is not large enough to hold all the requested property keys, <b>SetupDiGetClassPropertyKeysEx</b> does not retrieve any property keys and returns ERROR_INSUFFICIENT_BUFFER. If the caller supplied a <i>RequiredPropertyKeyCount</i> pointer, <b>SetupDiGetClassPropertyKeysEx</b> sets the value of *<i>RequiredPropertyKeyCount</i> to the required size, in DEVPROPKEY-typed values, of the <i>PropertyKeyArray </i> buffer<i>.</i>
     * 
     * To retrieve a device class property on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertyexw">SetupDiGetClassPropertyEx</a>, and to set a device class property on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclasspropertyexw">SetupDiSetClassPropertyEx</a>.
     * 
     * To retrieve the property keys for a device setup class or device interface class on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertykeys">SetupDiGetClassPropertyKeys</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that represents a device setup class or a device interface class. <b>SetupDiGetClassPropertyKeysEx</b> retrieves an array of the device property keys that represent device properties that are set for the specified class. For information about specifying the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray A pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device setup class. The pointer is optional and can be <b>NULL</b>. For more information, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyKeyCount The size, in DEVPROPKEY-type values, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to <b>NULL</b>, <i>PropertyKeyCount</i> must be set to zero.
     * @param {Pointer<UInt32>} RequiredPropertyKeyCount A pointer to a DWORD-typed variable that receives the number of requested property keys. The pointer is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags 
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the UNC name, including the "\\" prefix, of a computer. The pointer can be <b>NULL</b>. If the pointer is <b>NULL</b>, <b>SetupDiGetClassPropertyKeysEx</b> retrieves the requested information from the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} <b>SetupDiGetClassPropertyKeysEx</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the DICLASSPROP_INSTALLER flag is specified, this error code indicates that the device setup class that is specified by <i>ClassGuid</i> does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The reference string for the device interface that is specified by <i>ClassGuild</i> is not valid. This error might be returned when the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified data value is not valid. One possibility is that the <i>ClassGuid</i> value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified parameter is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyKeyArray</i> is <b>NULL</b>, and <i>PropertKeyCount</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_MACHINENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name that is specified by <i>MachineName</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the DICLASSPROP_INTERFACE flag is specified, this error code indicates that the device interface class that is specified by <i>ClassGuid</i> does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>PropertyKeyArray</i> buffer is not large enough to hold all the property keys, or an internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclasspropertykeysexw
     * @since windows6.0.6000
     */
    static SetupDiGetClassPropertyKeysExW(ClassGuid, PropertyKeyArray, PropertyKeyCount, RequiredPropertyKeyCount, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassPropertyKeysExW", "ptr", ClassGuid, "ptr", PropertyKeyArray, "uint", PropertyKeyCount, "ptr", RequiredPropertyKeyCount, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassProperty function retrieves a device property that is set for a device setup class or a device interface class.
     * @remarks
     * <b>SetupDiGetClassProperty</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>.
     * 
     * SetupAPI supports only a Unicode version of <b>SetupDiGetClassProperty</b>. 
     * 
     * A caller of <b>SetupDiGetClassProperty</b> must be a member of the Administrators group to set a device interface property. 
     * 
     * To obtain the device property keys that represent the device properties that are set for a device class on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertykeys">SetupDiGetClassPropertyKeys</a>.
     * 
     * To retrieve a device class property on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertyexw">SetupDiGetClassPropertyEx</a>.
     * 
     * To set a device class property on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclasspropertyw">SetupDiSetClassProperty</a><b>,</b> and to set a device class property on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclasspropertyexw">SetupDiSetClassPropertyEx</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that identifies the device setup class or device interface class for which to retrieve a device property that is set for the device class. For information about specifying the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device class property.
     * @param {Pointer<UInt32>} PropertyType A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device class property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the requested device class property. <b>SetupDiGetClassProperty</b> retrieves the requested property value only if the buffer is large enough to hold all the property value data. The pointer can be <b>NULL</b>. If the pointer is set to <b>NULL</b> and <i>RequiredSize</i> is supplied, <b>SetupDiGetClassProperty</b> returns the size of the device class property, in bytes, in *<i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives either the size, in bytes, of the device class property if the device class property is retrieved or the required buffer size if the buffer is not large enough. This pointer can be set to <b>NULL</b>.
     * @param {Integer} Flags 
     * @returns {Integer} <b>SetupDiGetClassProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device setup class that is specified by <i>ClassGuid</i> is not valid. This error can occur only if the DICLASSPROP_INSTALLER flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified parameter is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface reference string is not valid. This error can be returned if the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface class that is specified by <i>ClassGuid</i> does not exist. This error can occur only if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested device property does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclasspropertyw
     * @since windows6.0.6000
     */
    static SetupDiGetClassPropertyW(ClassGuid, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, RequiredSize, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassPropertyW", "ptr", ClassGuid, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassPropertyEx function retrieves a class property for a device setup class or a device interface class on a local or remote computer.
     * @remarks
     * <b>SetupDiGetClassPropertyEx</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>.
     * 
     * SetupAPI supports only a Unicode version of <b>SetupDiGetClassPropertyEx</b>. 
     * 
     * A caller of <b>SetupDiGetClassPropertyEx</b> must be a member of the Administrators group to set a device interface property. 
     * 
     * To obtain the device property keys that represent the device properties that are set for a device class on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertykeysexw">SetupDiGetClassPropertyKeysEx</a>.
     * 
     * To retrieve a device class property on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertyw">SetupDiGetClassProperty</a>.
     * 
     * To set a device class property on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclasspropertyw">SetupDiSetClassProperty</a><b>,</b> and to set a device class property on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclasspropertyexw">SetupDiSetClassPropertyEx</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that identifies the device setup class or device interface class for which to retrieve a device property for the device class. For information about specifying the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device class property.
     * @param {Pointer<UInt32>} PropertyType A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device class property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the requested device class property. <b>SetupDiGetClassPropertyEx</b> retrieves the requested property value only if the buffer is large enough to hold all the property value data. The pointer can be <b>NULL</b>. If the pointer is set to <b>NULL</b> and <i>RequiredSize</i> is supplied, <b>SetupDiGetClassPropertyEx</b> returns the size of the device class property, in bytes, in *<i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-typed variable that receives either the size, in bytes, of the device class property if the property is retrieved or the required buffer size if the buffer is not large enough. This pointer can be set to <b>NULL</b>.
     * @param {Integer} Flags 
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the UNC name, including the "\\" prefix, of a computer. The pointer can be set to <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, <b>SetupDiGetClassPropertyEx</b> retrieves the requested device class property from the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} <b>SetupDiGetClassPropertyEx</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device setup class that is specified by <i>ClassGuid</i> is not valid. This error can occur only if the DICLASSPROP_INSTALLER flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified parameter is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface reference string is not valid. This error can be returned if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_MACHINENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name that is specified by <i>MachineName</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface class that is specified by <i>ClassGuid</i> does not exist. This error can occur only if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested device property does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclasspropertyexw
     * @since windows6.0.6000
     */
    static SetupDiGetClassPropertyExW(ClassGuid, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, RequiredSize, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassPropertyExW", "ptr", ClassGuid, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassProperty function sets a class property for a device setup class or a device interface class.
     * @remarks
     * <b>SetupDiSetClassProperty</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>.
     * 
     * SetupAPI supports only a Unicode version of <b>SetupDiSetClassProperty</b>. 
     * 
     * A caller of <b>SetupDiSetClassProperty</b> must be a member of the Administrators group to set a device interface property. 
     * 
     * <b>SetupDiSetClassProperty</b> enforces requirements on the property-data-type identifier and the property value. 
     * 
     * To obtain the device property keys that represent the device properties that are set for a device class on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertykeys">SetupDiGetClassPropertyKeys</a>.
     * 
     * To retrieve a device class property on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertyw">SetupDiGetClassProperty</a>, and to retrieve a device class property on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertyexw">SetupDiGetClassPropertyEx</a>.
     * 
     * To set a device class property on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclasspropertyexw">SetupDiSetClassPropertyEx</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that identifies the device setup class or device interface class for which to set a device property. For information about how to specify the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the device class property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device class property. For more information about the property-data-type identifier, see the <b>Remarks</b> section later in this topic.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that contains the property value of the device class. If either the property or the data is being deleted, this pointer must be set to <b>NULL</b>, and <i>PropertyBufferSize</i> must be set to zero. For more information about property data, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer </i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} Flags 
     * @returns {Integer} <b>SetupDiSetClassProperty</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is invalid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device setup class that is specified by <i>ClassGuid</i> is not valid. This error can occur only if the DICLASSPROP_INSTALLER flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface reference string is not valid. This error can occur only if the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid. This error could be logged if the <i>ClassGuid</i> value is not a valid GUID or the property value is not consistent with the property type specified by <i>PropertyType.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface class that is specified by <i>ClassGuid</i> does not exist. This error can occur only if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified item was not found. One possibility is that the property to be deleted does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclasspropertyw
     * @since windows6.0.6000
     */
    static SetupDiSetClassPropertyW(ClassGuid, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, Flags) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassPropertyW", "ptr", ClassGuid, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassPropertyEx function sets a device property for a device setup class or a device interface class on a local or remote computer.
     * @remarks
     * <b>SetupDiSetClassPropertyEx</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">unified device property model</a>. 
     * 
     * SetupAPI supports only a Unicode version of <b>SetupDiSetClassPropertyEx</b>. 
     * 
     * A caller of <b>SetupDiSetClassPropertyEx</b> must be a member of the Administrators group to set a device interface property. 
     * 
     * <b>SetupDiSetClassPropertyEx</b> enforces requirements on the property-data-type identifier and the property value. 
     * 
     * To obtain the device property keys that represent the device properties that are set for a device class on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertykeysexw">SetupDiGetClassPropertyKeysEx</a>.
     * 
     * To retrieve a device class property on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertyw">SetupDiGetClassProperty</a><b>,</b> and to retrieve a device class property on a remote computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclasspropertyexw">SetupDiGetClassPropertyEx</a>.
     * 
     * To set a device class property on a local computer, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdisetclasspropertyw">SetupDiSetClassProperty</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID that identifies the device setup class or device interface class for which to set a device property. For information about how to specify the class type, see the <i>Flags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey A pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the device class property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the class property. For more information about the property-data-type identifier, see the <b>Remarks</b> section later in this topic.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that contains the class property value. If either the property or the property value is being deleted, this pointer must be set to <b>NULL</b>, and <i>PropertyBufferSize</i> must be set to zero. For more information about property value requirements, see the <b>Remarks</b> section later in this topic.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. The property buffer size must be consistent with the property-data-type identifier that is supplied by <i>PropertyType</i>. If <i>PropertyBuffer </i> is set to <b>NULL</b>, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} Flags 
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated Unicode string that contains the UNC name, including the "\\" prefix, of a computer. This pointer can be set to <b>NULL</b>. If the pointer is <b>NULL</b>, <b>SetupDiSetClassPropertyEx</b> sets the class property for a class that is installed on the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} <b>SetupDiSetClassPropertyEx</b> returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b>, and the logged error can be retrieved by calling <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table includes some of the more common error codes that this function might log. 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of<i> Flags</i> is invalid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device setup class that is specified by <i>ClassGuid</i> is not valid. This error can occur only if the DICLASSPROP_INSTALLER flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REFERENCE_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface reference string is not valid. This error can occur only if the DICLASSPROP_INTERFACE flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_REG_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property key that is supplied by <i>PropertyKey</i> is not valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified internal data value was not valid. This error could be logged if either the <i>ClassGuid</i> value is not a valid GUID or the property value does not match the property type specified by <i>PropertyType</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_USER_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A user buffer is not valid. One possibility is that <i>PropertyBuffer</i> is <b>NULL</b>, and <i>PropertyBufferSize</i> is not zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_MACHINENAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name that is specified by <i>MachineName</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_INTERFACE_CLASS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device interface class that is specified by <i>ClassGuid</i> does not exist. This error can occur only if the DICLASSPROP_INTERFACE flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal data buffer that was passed to a system call was too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough system memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unspecified item was not found. One possibility is that the property to be deleted does not exist. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclasspropertyexw
     * @since windows6.0.6000
     */
    static SetupDiSetClassPropertyExW(ClassGuid, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, Flags, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassPropertyExW", "ptr", ClassGuid, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", Flags, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceRegistryProperty function retrieves a specified Plug and Play device property. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceRegistryProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to retrieve a Plug and Play property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} Property 
     * @param {Pointer<UInt32>} PropertyRegDataType A pointer to a variable that receives the data type of the property that is being retrieved. This is one of the standard registry data types. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the property that is being retrieved. If this parameter is set to <b>NULL</b>, and <i>PropertyBufferSize</i> is also set to zero, the function returns the required size for the buffer in <i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the required size, in bytes, of the <i>PropertyBuffer</i> buffer that is required to hold the data for the requested property. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} <b>SetupDiGetDeviceRegistryProperty</b> returns <b>TRUE</b> if the call was successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>SetupDiGetDeviceRegistryProperty</b> returns the ERROR_INVALID_DATA error code if the requested property does not exist for a device or if the property data is not valid.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertya
     * @since windows5.0
     */
    static SetupDiGetDeviceRegistryPropertyA(DeviceInfoSet, DeviceInfoData, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceRegistryPropertyA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Property, "ptr", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceRegistryProperty function retrieves a specified Plug and Play device property. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceRegistryProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to retrieve a Plug and Play property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} Property 
     * @param {Pointer<UInt32>} PropertyRegDataType A pointer to a variable that receives the data type of the property that is being retrieved. This is one of the standard registry data types. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the property that is being retrieved. If this parameter is set to <b>NULL</b>, and <i>PropertyBufferSize</i> is also set to zero, the function returns the required size for the buffer in <i>RequiredSize</i>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the required size, in bytes, of the <i>PropertyBuffer</i> buffer that is required to hold the data for the requested property. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} <b>SetupDiGetDeviceRegistryProperty</b> returns <b>TRUE</b> if the call was successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>SetupDiGetDeviceRegistryProperty</b> returns the ERROR_INVALID_DATA error code if the requested property does not exist for a device or if the property data is not valid.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertyw
     * @since windows5.0
     */
    static SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, DeviceInfoData, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceRegistryPropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Property, "ptr", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassRegistryProperty function retrieves a property for a specified device setup class from the registry. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassRegistryProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID representing the device setup class for which a property is to be retrieved.
     * @param {Integer} Property 
     * @param {Pointer<UInt32>} PropertyRegDataType A pointer to a variable of type DWORD that receives the property data type as one of the REG_-prefixed registry data types. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, <b>SetupDiGetClassRegistryProperty</b> does not return the data type.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the requested property.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the required size, in bytes, of the <i>PropertyBuffer </i> buffer. If the <i>PropertyBuffer</i> buffer is too small, and <i>RequiredSize</i> is not <b>NULL</b>, the function sets <i>RequiredSize</i> to the minimum buffer size that is required to receive the requested property.
     * @param {Pointer<PSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system from which to retrieve the specified device class property. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the property is retrieved from the local system.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassregistrypropertya
     * @since windows5.1.2600
     */
    static SetupDiGetClassRegistryPropertyA(ClassGuid, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassRegistryPropertyA", "ptr", ClassGuid, "uint", Property, "ptr", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassRegistryProperty function retrieves a property for a specified device setup class from the registry. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassRegistryProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to a GUID representing the device setup class for which a property is to be retrieved.
     * @param {Integer} Property 
     * @param {Pointer<UInt32>} PropertyRegDataType A pointer to a variable of type DWORD that receives the property data type as one of the REG_-prefixed registry data types. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, <b>SetupDiGetClassRegistryProperty</b> does not return the data type.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the requested property.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the required size, in bytes, of the <i>PropertyBuffer </i> buffer. If the <i>PropertyBuffer</i> buffer is too small, and <i>RequiredSize</i> is not <b>NULL</b>, the function sets <i>RequiredSize</i> to the minimum buffer size that is required to receive the requested property.
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system from which to retrieve the specified device class property. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the property is retrieved from the local system.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassregistrypropertyw
     * @since windows5.1.2600
     */
    static SetupDiGetClassRegistryPropertyW(ClassGuid, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassRegistryPropertyW", "ptr", ClassGuid, "uint", Property, "ptr", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceRegistryProperty function sets a Plug and Play device property for a device. (ANSI)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * The class name property cannot be set because it is based on the corresponding class GUID and is automatically updated when that property is changed. When the ClassGUID property changes, <b>SetupDiSetDeviceRegistryProperty</b> automatically cleans up any software keys associated with the device.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetDeviceRegistryProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to set a Plug and Play device property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. If the <b>ClassGuid</b> property is set, <i>DeviceInfoData.</i><b>ClassGuid</b> is set upon return to the new class for the device.
     * @param {Integer} Property 
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that contains the new data for the property. If the property is being cleared, then this pointer should be <b>NULL</b> and <i>PropertyBufferSize</i> must be zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of <i>PropertyBuffer</i>. If <i>PropertyBuffer</i> is <b>NULL</b>, then this field must be zero.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceregistrypropertya
     * @since windows5.0
     */
    static SetupDiSetDeviceRegistryPropertyA(DeviceInfoSet, DeviceInfoData, Property, PropertyBuffer, PropertyBufferSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceRegistryPropertyA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Property, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceRegistryProperty function sets a Plug and Play device property for a device. (Unicode)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * The class name property cannot be set because it is based on the corresponding class GUID and is automatically updated when that property is changed. When the ClassGUID property changes, <b>SetupDiSetDeviceRegistryProperty</b> automatically cleans up any software keys associated with the device.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetDeviceRegistryProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to set a Plug and Play device property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. If the <b>ClassGuid</b> property is set, <i>DeviceInfoData.</i><b>ClassGuid</b> is set upon return to the new class for the device.
     * @param {Integer} Property 
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that contains the new data for the property. If the property is being cleared, then this pointer should be <b>NULL</b> and <i>PropertyBufferSize</i> must be zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of <i>PropertyBuffer</i>. If <i>PropertyBuffer</i> is <b>NULL</b>, then this field must be zero.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceregistrypropertyw
     * @since windows5.0
     */
    static SetupDiSetDeviceRegistryPropertyW(DeviceInfoSet, DeviceInfoData, Property, PropertyBuffer, PropertyBufferSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceRegistryPropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Property, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassRegistryProperty function sets a specified device class property in the registry. (ANSI)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * To determine the data type for a device class property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassregistrypropertya">SetupDiGetClassRegistryProperty</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetClassRegistryProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that identifies the device class for which a property is to be set.
     * @param {Integer} Property A value that identifies the property to be set, which must be one of the following:
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that supplies the specified property. This parameter is optional and can be <b>NULL</b>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i> buffer.
     * @param {Pointer<PSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system on which to set the specified device class property. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the property is set on the name of the local system.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclassregistrypropertya
     * @since windows5.1.2600
     */
    static SetupDiSetClassRegistryPropertyA(ClassGuid, Property, PropertyBuffer, PropertyBufferSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassRegistryPropertyA", "ptr", ClassGuid, "uint", Property, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassRegistryProperty function sets a specified device class property in the registry. (Unicode)
     * @remarks
     * The caller of this function must be a member of the Administrators group.
     * 
     * To determine the data type for a device class property, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassregistrypropertya">SetupDiGetClassRegistryProperty</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetClassRegistryProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that identifies the device class for which a property is to be set.
     * @param {Integer} Property A value that identifies the property to be set, which must be one of the following:
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that supplies the specified property. This parameter is optional and can be <b>NULL</b>.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i> buffer.
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system on which to set the specified device class property. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the property is set on the name of the local system.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclassregistrypropertyw
     * @since windows5.1.2600
     */
    static SetupDiSetClassRegistryPropertyW(ClassGuid, Property, PropertyBuffer, PropertyBufferSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassRegistryPropertyW", "ptr", ClassGuid, "uint", Property, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInstallParams function retrieves device installation parameters for a device information set or a particular device information element. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device installation parameters to retrieve.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetDeviceInstallParams</b> retrieves the installation parameters for the specified device. If this parameter is <b>NULL</b>, the function retrieves the global device installation parameters that are associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DEVINSTALL_PARAMS_A>} DeviceInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure that receives the device install parameters. <i>DeviceInstallParams</i>.<b>cbSize</b> must be set to the size, in bytes, of the structure before calling this function.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinstallparamsa
     * @since windows5.0
     */
    static SetupDiGetDeviceInstallParamsA(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDeviceInstallParams function retrieves device installation parameters for a device information set or a particular device information element. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDeviceInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device installation parameters to retrieve.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetDeviceInstallParams</b> retrieves the installation parameters for the specified device. If this parameter is <b>NULL</b>, the function retrieves the global device installation parameters that are associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DEVINSTALL_PARAMS_W>} DeviceInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure that receives the device install parameters. <i>DeviceInstallParams</i>.<b>cbSize</b> must be set to the size, in bytes, of the structure before calling this function.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinstallparamsw
     * @since windows5.0
     */
    static SetupDiGetDeviceInstallParamsW(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDeviceInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassInstallParams function retrieves class installation parameters for a device information set or a particular device information element. (ANSI)
     * @remarks
     * The class install parameters are specific to a particular <a href="https://docs.microsoft.com/windows-hardware/drivers/install/handling-dif-codes">device installation function code</a> that is stored in the <b>ClassInstallHeader</b> field located at the beginning of the <i>ClassInstallParams</i> buffer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the class install parameters to retrieve.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specified a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetClassInstallParams</b> retrieves the class installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetClassInstallParams</b> retrieves the class install parameters for the global class driver list that is associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_CLASSINSTALL_HEADER>} ClassInstallParams A pointer to a buffer that contains an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classinstall_header">SP_CLASSINSTALL_HEADER</a> structure. This structure must have its <b>cbSize</b> member set to <b>sizeof(</b>SP_CLASSINSTALL_HEADER<b>)</b> on input or the buffer is considered to be invalid. On output, the <b>InstallFunction</b> member is filled with the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/handling-dif-codes">device installation function code</a> for the class installation parameters being retrieved. If the buffer is large enough, it also receives the class installation parameters structure specific to the function code. If <i>ClassInstallParams</i> is not specified, <i>ClassInstallParamsSize</i> must be 0.
     * @param {Integer} ClassInstallParamsSize The size, in bytes, of the <i>ClassInstallParams</i> buffer. If the buffer is supplied, it must be at least as large as <b>sizeof(</b>SP_CLASSINSTALL_HEADER<b>)</b>. If the buffer is not supplied, <i>ClassInstallParamsSize</i> must be 0<i>.</i>
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of bytes required to store the class install parameters. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassinstallparamsa
     * @since windows5.0
     */
    static SetupDiGetClassInstallParamsA(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", ClassInstallParams, "uint", ClassInstallParamsSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassInstallParams function retrieves class installation parameters for a device information set or a particular device information element. (Unicode)
     * @remarks
     * The class install parameters are specific to a particular <a href="https://docs.microsoft.com/windows-hardware/drivers/install/handling-dif-codes">device installation function code</a> that is stored in the <b>ClassInstallHeader</b> field located at the beginning of the <i>ClassInstallParams</i> buffer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the class install parameters to retrieve.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specified a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetClassInstallParams</b> retrieves the class installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetClassInstallParams</b> retrieves the class install parameters for the global class driver list that is associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_CLASSINSTALL_HEADER>} ClassInstallParams A pointer to a buffer that contains an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classinstall_header">SP_CLASSINSTALL_HEADER</a> structure. This structure must have its <b>cbSize</b> member set to <b>sizeof(</b>SP_CLASSINSTALL_HEADER<b>)</b> on input or the buffer is considered to be invalid. On output, the <b>InstallFunction</b> member is filled with the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/handling-dif-codes">device installation function code</a> for the class installation parameters being retrieved. If the buffer is large enough, it also receives the class installation parameters structure specific to the function code. If <i>ClassInstallParams</i> is not specified, <i>ClassInstallParamsSize</i> must be 0.
     * @param {Integer} ClassInstallParamsSize The size, in bytes, of the <i>ClassInstallParams</i> buffer. If the buffer is supplied, it must be at least as large as <b>sizeof(</b>SP_CLASSINSTALL_HEADER<b>)</b>. If the buffer is not supplied, <i>ClassInstallParamsSize</i> must be 0<i>.</i>
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of bytes required to store the class install parameters. This parameter is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassinstallparamsw
     * @since windows5.0
     */
    static SetupDiGetClassInstallParamsW(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize, RequiredSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", ClassInstallParams, "uint", ClassInstallParamsSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceInstallParams function sets device installation parameters for a device information set or a particular device information element. (ANSI)
     * @remarks
     * All parameters are validated before any changes are made. Therefore, a return value of <b>FALSE</b> indicates that no parameters were modified.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetDeviceInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to set device installation parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be set to <b>NULL</b>. If this parameter is specified, <b>SetupDiSetDeviceInstallParams</b> sets the installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetDeviceInstallParams</b> sets the installation parameters that are associated with the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DEVINSTALL_PARAMS_A>} DeviceInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure that contains the new values of the parameters. The <i>DeviceInstallParams.</i><b>cbSize</b> must be set to the size, in bytes, of the structure before this function is called.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceinstallparamsa
     * @since windows5.0
     */
    static SetupDiSetDeviceInstallParamsA(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDeviceInstallParams function sets device installation parameters for a device information set or a particular device information element. (Unicode)
     * @remarks
     * All parameters are validated before any changes are made. Therefore, a return value of <b>FALSE</b> indicates that no parameters were modified.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetDeviceInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to set device installation parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be set to <b>NULL</b>. If this parameter is specified, <b>SetupDiSetDeviceInstallParams</b> sets the installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetDeviceInstallParams</b> sets the installation parameters that are associated with the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DEVINSTALL_PARAMS_W>} DeviceInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure that contains the new values of the parameters. The <i>DeviceInstallParams.</i><b>cbSize</b> must be set to the size, in bytes, of the structure before this function is called.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdeviceinstallparamsw
     * @since windows5.0
     */
    static SetupDiSetDeviceInstallParamsW(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDeviceInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DeviceInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassInstallParams function sets or clears class install parameters for a device information set or a particular device information element. (ANSI)
     * @remarks
     * All parameters are validated before any changes are made. Therefore, a return value of <b>FALSE</b> indicates that no parameters were modified.
     * 
     * A side effect of setting class install parameters is that the DI_CLASSINSTALLPARAMS flag is set. If the caller wants to set the parameters, but disable their use, this flag must be cleared by a call to <b>SetupDiSetDeviceInstallParams</b>. 
     * 
     * If the class install parameters are cleared, the DI_CLASSINSTALLPARAMS flag is reset.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetClassInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to set class install parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device for which to set class install parameters. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSetClassInstallParams</b> sets the class installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetClassInstallParams</b> sets the class install parameters that are associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_CLASSINSTALL_HEADER>} ClassInstallParams A pointer to a buffer that contains the new class install parameters to use. The <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classinstall_header">SP_CLASSINSTALL_HEADER</a> structure at the beginning of this buffer must have its <b>cbSize</b> field set to <b>sizeof(</b>SP_CLASSINSTALL_HEADER<b>)</b> and the <b>InstallFunction</b> field must be set to the DI_FUNCTION code that reflects the type of parameters contained in the rest of the buffer. 
     * 
     * If <i>ClassInstallParams</i> is not specified, the current class install parameters, if any, are cleared for the specified device information set or element.
     * @param {Integer} ClassInstallParamsSize The size, in bytes, of the <i>ClassInstallParams</i> buffer. If the buffer is not supplied (that is, the class install parameters are being cleared), <i>ClassInstallParamsSize</i> must be 0<i>.</i>
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclassinstallparamsa
     * @since windows5.0
     */
    static SetupDiSetClassInstallParamsA(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", ClassInstallParams, "uint", ClassInstallParamsSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetClassInstallParams function sets or clears class install parameters for a device information set or a particular device information element. (Unicode)
     * @remarks
     * All parameters are validated before any changes are made. Therefore, a return value of <b>FALSE</b> indicates that no parameters were modified.
     * 
     * A side effect of setting class install parameters is that the DI_CLASSINSTALLPARAMS flag is set. If the caller wants to set the parameters, but disable their use, this flag must be cleared by a call to <b>SetupDiSetDeviceInstallParams</b>. 
     * 
     * If the class install parameters are cleared, the DI_CLASSINSTALLPARAMS flag is reset.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetClassInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to set class install parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device for which to set class install parameters. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSetClassInstallParams</b> sets the class installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetClassInstallParams</b> sets the class install parameters that are associated with <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_CLASSINSTALL_HEADER>} ClassInstallParams A pointer to a buffer that contains the new class install parameters to use. The <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classinstall_header">SP_CLASSINSTALL_HEADER</a> structure at the beginning of this buffer must have its <b>cbSize</b> field set to <b>sizeof(</b>SP_CLASSINSTALL_HEADER<b>)</b> and the <b>InstallFunction</b> field must be set to the DI_FUNCTION code that reflects the type of parameters contained in the rest of the buffer. 
     * 
     * If <i>ClassInstallParams</i> is not specified, the current class install parameters, if any, are cleared for the specified device information set or element.
     * @param {Integer} ClassInstallParamsSize The size, in bytes, of the <i>ClassInstallParams</i> buffer. If the buffer is not supplied (that is, the class install parameters are being cleared), <i>ClassInstallParamsSize</i> must be 0<i>.</i>
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetclassinstallparamsw
     * @since windows5.0
     */
    static SetupDiSetClassInstallParamsW(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetClassInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", ClassInstallParams, "uint", ClassInstallParamsSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDriverInstallParams function retrieves driver installation parameters for a device information set or a particular device information element. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDriverInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a driver information element that represents the driver for which to retrieve installation parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that contains a device information element that represents the device for which to retrieve installation parameters. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetDriverInstallParams</b> retrieves information about a driver that is a member of a driver list for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetDriverInstallParams</b> retrieves information about a driver  that is a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver information element that represents the driver for which to retrieve installation parameters. If <i>DeviceInfoData</i> is supplied, the driver must be a member of the driver list for the device that is specified by <i>DeviceInfoData</i>. Otherwise, the driver must be a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINSTALL_PARAMS>} DriverInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinstall_params">SP_DRVINSTALL_PARAMS</a> structure to receive the installation parameters for this driver.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdriverinstallparamsa
     * @since windows5.0
     */
    static SetupDiGetDriverInstallParamsA(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDriverInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetDriverInstallParams function retrieves driver installation parameters for a device information set or a particular device information element. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetDriverInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a driver information element that represents the driver for which to retrieve installation parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that contains a device information element that represents the device for which to retrieve installation parameters. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetDriverInstallParams</b> retrieves information about a driver that is a member of a driver list for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetDriverInstallParams</b> retrieves information about a driver  that is a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver information element that represents the driver for which to retrieve installation parameters. If <i>DeviceInfoData</i> is supplied, the driver must be a member of the driver list for the device that is specified by <i>DeviceInfoData</i>. Otherwise, the driver must be a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINSTALL_PARAMS>} DriverInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinstall_params">SP_DRVINSTALL_PARAMS</a> structure to receive the installation parameters for this driver.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetdriverinstallparamsw
     * @since windows5.0
     */
    static SetupDiGetDriverInstallParamsW(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetDriverInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDriverInstallParams function sets driver installation parameters for a driver information element. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetDriverInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a driver information element that represents the driver for which to set installation parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be set to <b>NULL</b>. If this parameter is specified, <b>SetupDiSetDriverInstallParams</b> sets the driver installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetDriverInstallParams</b> sets driver installation parameters for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_A>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver for which installation parameters are set. If <i>DeviceInfoData</i> is specified, this driver must be a member of a driver list that is associated with <i>DeviceInfoData</i>. If <i>DeviceInfoData</i> is <b>NULL</b>, this driver must be a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINSTALL_PARAMS>} DriverInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinstall_params">SP_DRVINSTALL_PARAMS</a> structure that specifies the new driver install parameters.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdriverinstallparamsa
     * @since windows5.0
     */
    static SetupDiSetDriverInstallParamsA(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDriverInstallParamsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetDriverInstallParams function sets driver installation parameters for a driver information element. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiSetDriverInstallParams as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a driver information element that represents the driver for which to set installation parameters.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be set to <b>NULL</b>. If this parameter is specified, <b>SetupDiSetDriverInstallParams</b> sets the driver installation parameters for the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSetDriverInstallParams</b> sets driver installation parameters for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver for which installation parameters are set. If <i>DeviceInfoData</i> is specified, this driver must be a member of a driver list that is associated with <i>DeviceInfoData</i>. If <i>DeviceInfoData</i> is <b>NULL</b>, this driver must be a member of the global class driver list for <i>DeviceInfoSet</i>.
     * @param {Pointer<SP_DRVINSTALL_PARAMS>} DriverInstallParams A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinstall_params">SP_DRVINSTALL_PARAMS</a> structure that specifies the new driver install parameters.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetdriverinstallparamsw
     * @since windows5.0
     */
    static SetupDiSetDriverInstallParamsW(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetDriverInstallParamsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "ptr", DriverInstallParams, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiLoadClassIcon function loads both the large and mini-icon for the specified class.
     * @remarks
     * The icons of the class are either predefined and loaded from the device installer's internal cache, or they are loaded directly from the class installer's executable. This function queries the registry value <b>ICON</b> in the specified class's section. If the <b>ICON</b> value is specified, it indicates which mini-icon to load. 
     * 
     * If the <b>ICON</b> value is negative, the absolute value represents a predefined icon in the class's registry. See <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidrawminiicon">SetupDiDrawMiniIcon</a> for a list of the predefined mini-icons. 
     * 
     * If the <b>ICON</b> value is positive, it represents an icon in the class installer's executable image that will be extracted. The value 1 is reserved. This function also uses the <b>INSTALLER32</b> registry value and then the <b>ENUMPROPPAGES32</b> registry value to determine which executable image to extract the icons from. For more information about these registry values, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-classinstall32-section">INF ClassInstall32 Section</a>.
     * 
     * When a caller is finished using the icon, the caller must call <b>DestroyIcon</b> (which is described in the Microsoft Windows SDK documentation).
     * 
     * If the <i>LargeIcon </i> parameter is specified, but the <i>ClassGuid</i> parameter does not supply a valid class GUID or the <b>Icon</b> registry value of the class is not valid, <b>SetupDiLoadClassIcon</b> loads the default large icon, returns the handle for the large icon, and, if the <i>MiniIconIndex</i> parameter is specified, returns the index of the default mini-icon.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the class for which the icon(s) should be loaded.
     * @param {Pointer<HICON>} LargeIcon A pointer to an icon handle that receives the handle value for the loaded large icon for the specified class. This pointer is optional and can be <b>NULL</b>. If the pointer is <b>NULL</b>, the large icon is not loaded.
     * @param {Pointer<Int32>} MiniIconIndex A pointer to an INT-typed variable that receives the index of the mini-icon for the specified class. The mini-icon is stored in the device installer's mini-icon cache. The pointer is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiloadclassicon
     * @since windows5.0
     */
    static SetupDiLoadClassIcon(ClassGuid, LargeIcon, MiniIconIndex) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiLoadClassIcon", "ptr", ClassGuid, "ptr", LargeIcon, "ptr", MiniIconIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiLoadDeviceIcon function retrieves an icon for a specified device.
     * @remarks
     * <b>SetupDiLoadDeviceIcon</b> attempts to retrieve an icon for the device as follows: 
     * 
     * <ul>
     * <li>
     * If the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpkey-drvpkg-icon">DEVPKEY_DrvPkg_Icon</a> device property of the device includes a list of resource-identifier strings, the function attempts to retrieve the icon that is specified by the first resource-identifier string in the list. 
     * 
     * The <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">device property data type</a> of the DEVPKEY_DrvPkg_Icon device property is <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devprop-type-string-list">DEVPROP_TYPE_STRING_LIST</a>. 
     * 
     * The format of a resource-identifier string is
     * 
     * 
     * ```
     * [filepath\]filename,-resourceID
     * ```
     * 
     * 
     * Where:
     * 
     * <ul>
     * <li><i>filepath,</i> followed by the backslash character (\\)<i>,</i> is optional and specifies a path of the file that contains the icon.</li>
     * <li><i>FileName</i>, followed by the comma character (",") specifies the name of the file that contains the icon.</li>
     * <li><i>ResourceID</i>, preceded by a dash character ("-"), specifies the resource ID of the icon.</li>
     * </ul>
     * </li>
     * <li>
     * If the function cannot retrieve a device-specific icon, it will then attempt to retrieve the class icon for the device. For information about class icons, see <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiloadclassicon">SetupDiLoadClassIcon</a>.
     * 
     * </li>
     * <li>
     * If the function cannot retrieve the class icon for the device, it will then attempt to retrieve the icon for the Unknown <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a>, where the icon for the Unknown device setup class includes the image of a question mark (?).
     * 
     * </li>
     * </ul>
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element that represents the device for which to retrieve an icon.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Integer} cxIcon The width, in pixels, of the icon to be retrieved. Use the system metric index SM_CXICON to specify a default-sized icon or use the system metric index SM_CXSMICON to specify a small icon. The system metric indexes are defined in <i>Winuser.h</i>, and their associated values can be retrieved by a call to the <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> function. (The <b>GetSystemMetrics</b> function is documented in the Microsoft Windows SDK.)
     * @param {Integer} cyIcon The height, in pixels, of the icon to be retrieved. Use SM_CXICON to specify a default-sized icon or use SM_CXSMICON to specify a small icon.
     * @param {Integer} Flags Not used. Must set to zero.
     * @param {Pointer<HICON>} hIcon A pointer to a handle to an icon that receives a handle to the icon that this function retrieves. After the application that calls this function is finished using the icon, the application must call <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> to delete the icon. (<b>DestroyIcon</b> is documented in the Microsoft Windows SDK.)
     * @returns {Integer} <b>SetupDiLoadDeviceIcon</b> returns <b>TRUE</b> if the function succeeds in retrieving the icon for the specified device. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiloaddeviceicon
     * @since windows6.0.6000
     */
    static SetupDiLoadDeviceIcon(DeviceInfoSet, DeviceInfoData, cxIcon, cyIcon, Flags, hIcon) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiLoadDeviceIcon", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", cxIcon, "uint", cyIcon, "uint", Flags, "ptr", hIcon, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDrawMiniIcon function draws the specified mini-icon at the location requested.
     * @remarks
     * By default, the icon is centered vertically and forced against the left side of the specified rectangle.
     * 
     * <b>SetupDiDrawMiniIcon</b> draws the 16-bit version of the icon that is specified by the <i>MiniIconIndex </i> parameter. Instead of <b>SetupDiDrawMiniIcon</b>, you should use <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiloadclassicon">SetupDiLoadClassIcon</a> together with <b>DrawIcon</b> or <b>DrawIconEx</b> to draw the 32-bit version of the icon. The following is an example of how to use <b>DrawIconEx</b> to display an icon:
     * 
     * 
     * ```
     * HICON hIcon;
     * 
     * if (SetupDiLoadClassIcon(&GUID_DEVCLASS_USB, &hIcon, NULL)) {
     *     DrawIconEx(hDC, 0, 0, hIcon, GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON), 0, NULL, DI_NORMAL); 
     * DestroyIcon(hIcon);
     * }
     * ```
     * 
     * 
     * For more information about <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-drawicon">DrawIcon</a> or <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex">DrawIconEx</a>, refer to the Microsoft Windows Software Development Kit (SDK) for Windows7 and .NET Framework4.0 documentation.
     * @param {Pointer<HDC>} hdc The handle to the device context in which the mini-icon will be drawn.
     * @param {Pointer} rc The rectangle in the specified device context handle to draw the mini-icon in.
     * @param {Integer} MiniIconIndex The index of the mini-icon, as retrieved from <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiloadclassicon">SetupDiLoadClassIcon</a> or <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassbitmapindex">SetupDiGetClassBitmapIndex</a>. The following predefined indexes for devices can be used:
     * 
     * <table>
     * <tr>
     * <th>        Class</th>
     * <th>Index</th>
     * </tr>
     * <tr>
     * <td>
     *         Computer/System
     * 
     * </td>
     * <td>
     * 0
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Display/Monitor
     * 
     * </td>
     * <td>
     * 2
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Network Adapter
     * 
     * </td>
     * <td>
     * 3
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Mouse
     * 
     * </td>
     * <td>
     * 5
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Keyboard
     * 
     * </td>
     * <td>
     * 6
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Sound
     * 
     * </td>
     * <td>
     * 8
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         FDC/HDC
     * 
     * </td>
     * <td>
     * 9
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Ports
     * 
     * </td>
     * <td>
     * 10
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Printer
     * 
     * </td>
     * <td>
     * 14
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Network Transport
     * 
     * </td>
     * <td>
     * 15
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Network Client
     * 
     * </td>
     * <td>
     * 16
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Network Service
     * 
     * </td>
     * <td>
     * 17
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     *         Unknown
     * 
     * </td>
     * <td>
     * 18
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Flags These flags control the drawing operation. The LOWORD contains the actual flags defined as follows:
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdidrawminiicon
     * @since windows5.0
     */
    static SetupDiDrawMiniIcon(hdc, rc, MiniIconIndex, Flags) {
        DllCall("SETUPAPI.dll\SetupDiDrawMiniIcon", "ptr", hdc, "ptr", rc, "int", MiniIconIndex, "uint", Flags)
    }

    /**
     * The SetupDiGetClassBitmapIndex function retrieves the index of the mini-icon supplied for the specified class.
     * @remarks
     * For a list of the device setup class mini-icons and their corresponding indexes, see <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidrawminiicon">SetupDiDrawMiniIcon</a>.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to retrieve the mini-icon. This pointer is optional and can be <b>NULL</b>.
     * @param {Pointer<Int32>} MiniIconIndex A pointer to a variable of type INT that receives the index of the mini-icon for the specified device setup class. If the <i>ClassGuid</i> parameter is <b>NULL</b> or if there is no mini-icon for the specified class, <b>SetupDiGetClassBitmapIndex</b> returns the index of the mini-icon for the Unknown device setup class.
     * @returns {Integer} If there is a min-icon for the specified device setup class, <b>SetupDiGetClassBitmapIndex</b> returns <b>TRUE</b>. Otherwise, this function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the <i>ClassGuid</i> parameter is <b>NULL</b>, or if there is no mini-icon for the specified class, the function returns <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_DEVICE_ICON.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassbitmapindex
     * @since windows5.0
     */
    static SetupDiGetClassBitmapIndex(ClassGuid, MiniIconIndex) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassBitmapIndex", "ptr", ClassGuid, "ptr", MiniIconIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassImageList function builds an image list that contains bitmaps for every installed class and returns the list in a data structure.
     * @remarks
     * The image list built by this function should be destroyed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroyclassimagelist">SetupDiDestroyClassImageList</a>.
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassimagelistexa">SetupDiGetClassImageListEx</a> to retrieve the image list for classes installed on a remote computer.
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classimagelist_data">SP_CLASSIMAGELIST_DATA</a> structure to receive information regarding the class image list, including a handle to the image list. The <b>cbSize</b> field of this structure must be initialized with the size of the structure, in bytes, before calling this function or it will fail.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassimagelist
     * @since windows5.0
     */
    static SetupDiGetClassImageList(ClassImageListData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassImageList", "ptr", ClassImageListData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassImageListEx function builds an image list of bitmaps for every class installed on a local or remote system. (ANSI)
     * @remarks
     * The image list built by this function should be destroyed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroyclassimagelist">SetupDiDestroyClassImageList</a>.
     * 
     * <div class="alert"><b>Note</b>  Class-specific icons on a remote computer can only be displayed if the class is also present on the local computer. Thus, if the remote computer has class <i>X</i>, but class <i>X</i> is not installed locally, then the generic (unknown) icon will be returned.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassImageListEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classimagelist_data">SP_CLASSIMAGELIST_DATA</a> structure to receive information regarding the class image list, including a handle to the image list. The <b>cbSize</b> field of this structure must be initialized with the size of the structure, in bytes, before calling this function or it will fail.
     * @param {Pointer<PSTR>} MachineName A pointer to NULL-terminated string that supplies the name of a remote system for whose classes <b>SetupDiGetClassImageListEx must build</b> the bitmap. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, <b>SetupDiGetClassImageListEx</b> builds the list for the local system.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassimagelistexa
     * @since windows5.0
     */
    static SetupDiGetClassImageListExA(ClassImageListData, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassImageListExA", "ptr", ClassImageListData, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassImageListEx function builds an image list of bitmaps for every class installed on a local or remote system. (Unicode)
     * @remarks
     * The image list built by this function should be destroyed by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdidestroyclassimagelist">SetupDiDestroyClassImageList</a>.
     * 
     * <div class="alert"><b>Note</b>  Class-specific icons on a remote computer can only be displayed if the class is also present on the local computer. Thus, if the remote computer has class <i>X</i>, but class <i>X</i> is not installed locally, then the generic (unknown) icon will be returned.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassImageListEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classimagelist_data">SP_CLASSIMAGELIST_DATA</a> structure to receive information regarding the class image list, including a handle to the image list. The <b>cbSize</b> field of this structure must be initialized with the size of the structure, in bytes, before calling this function or it will fail.
     * @param {Pointer<PWSTR>} MachineName A pointer to NULL-terminated string that supplies the name of a remote system for whose classes <b>SetupDiGetClassImageListEx must build</b> the bitmap. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, <b>SetupDiGetClassImageListEx</b> builds the list for the local system.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassimagelistexw
     * @since windows5.0
     */
    static SetupDiGetClassImageListExW(ClassImageListData, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassImageListExW", "ptr", ClassImageListData, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassImageIndex function retrieves the index within the class image list of a specified class.
     * @remarks
     * If the specified device setup class is not included in the specified class image list, <b>SetupDiGetClassImageIndex</b> returns the image index for the Unknown device setup class in the <i>ImageIndex</i> parameter.
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classimagelist_data">SP_CLASSIMAGELIST_DATA</a> structure that describes a class image list that includes the image for the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> that is specified by the <i>ClassGuid</i> parameter.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID of the device setup class for which to retrieve the index of the class image in the specified class image list.
     * @param {Pointer<Int32>} ImageIndex A pointer to an INT-typed variable that receives the index of the specified class image in the class image list.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassimageindex
     * @since windows5.0
     */
    static SetupDiGetClassImageIndex(ClassImageListData, ClassGuid, ImageIndex) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassImageIndex", "ptr", ClassImageListData, "ptr", ClassGuid, "ptr", ImageIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiDestroyClassImageList function destroys a class image list that was built by a call to SetupDiGetClassImageList or SetupDiGetClassImageListEx.
     * @param {Pointer<SP_CLASSIMAGELIST_DATA>} ClassImageListData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_classimagelist_data">SP_CLASSIMAGELIST_DATA</a> structure that contains the class image list to destroy.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdidestroyclassimagelist
     * @since windows5.0
     */
    static SetupDiDestroyClassImageList(ClassImageListData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiDestroyClassImageList", "ptr", ClassImageListData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDevPropertySheets function retrieves handles to the property sheets of a device information element or of the device setup class of a device information set. (ANSI)
     * @remarks
     * A PROPERTYSHEETHEADER structure contains two members that are associated with a caller-supplied array that the function uses to return the handles of property sheets. The <b>phpages</b> member is a pointer to a caller-supplied array of property sheet handles, and the input value of the <b>nPages</b> member specifies the number of handles that are already contained in the handle array. The function adds property sheet handles to the handle array beginning with the array element whose array index is the input value of <b>nPages</b>. The function adds handles to the array in consecutive order until either the array is full or the handles of all the requested property sheet pages have been added to the array. The maximum number of property sheet handles that the function can return is equal to (<i>PropertySheetHeaderPageListSize</i> - (input value of <b>nPages</b>)). 
     * 
     * If the handle array is large enough to hold the handles of all the requested property sheet pages, the function:
     * 
     * <ul>
     * <li>
     * Adds the handles to the handle array.
     * 
     * </li>
     * <li>
     * Sets <b>nPages</b> to the total number of handles in the array.
     * 
     * </li>
     * <li>
     * Sets <i>RequiredSize</i> to the number of handles that it returns.
     * 
     * </li>
     * <li>
     * Returns <b>TRUE</b>.
     * 
     * </li>
     * </ul>
     * If the handle array is not large enough to hold the handles of all the specified property sheet pages, the function: 
     * 
     * <ul>
     * <li>
     * Adds as many handles as the array can hold.
     * 
     * </li>
     * <li>
     * Sets <b>nPages</b> to <i>PropertySheetHeaderPageListSize</i>.
     * 
     * </li>
     * <li>
     * Sets <i>RequiredSize</i> to the total number of requested property sheet pages. The number of handles that are not returned by the function is equal to (<i>RequiredSize</i> - <i>PropertySheetHeaderPageListSize</i> - (input value of <b>nPages</b>)).
     * 
     * </li>
     * <li>
     * Sets the error code to ERROR_INSUFFICIENT_BUFFER.
     * 
     * </li>
     * <li>
     * Returns <b>FALSE</b>.
     * 
     * </li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassDevPropertySheets as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to return property sheet handles. If <i>DeviceInfoData</i> does not specify a device information element in the device information set, the device information set must have an associated device setup class.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in DeviceInfoSet. 
     * 
     * This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetClassDevPropertySheets</b> retrieves the property sheets handles that are associated with the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetClassDevPropertySheets</b> retrieves the property sheets handles that are associated with the device setup class specified in <i>DeviceInfoSet</i>.
     * @param {Pointer<PROPSHEETHEADERA_V2>} PropertySheetHeader A pointer to a PROPERTYSHEETHEADER structure. See the <b>Remarks</b> section for information about the caller-supplied array of property sheet handles that is associated with this structure. 
     * 
     * For more documentation on this structure and property sheets in general, see the Microsoft Windows SDK.
     * @param {Integer} PropertySheetHeaderPageListSize The maximum number of handles that the caller-supplied array of property sheet handles can hold.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of property sheets that are associated with the specified device information element or the device setup class of the specified device information set. The pointer is optional and can be <b>NULL</b>.
     * @param {Integer} PropertySheetType A flag that indicates one of the following types of property sheets.
     * 
     * <table>
     * <tr>
     * <th>Property sheet type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>
     * DIGCDP_FLAG_ADVANCED
     * 
     * </td>
     * <td>
     * Advanced property sheets.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DIGCDP_FLAG_BASIC
     * 
     * </td>
     * <td>
     * Basic property sheets. Supported only in Microsoft Windows 95 and Windows 98. Do not use in Windows 2000 and later versions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DIGCDP_FLAG_REMOTE_ADVANCED
     * 
     * </td>
     * <td>
     * Advanced property sheets on a remote computer.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} The function returns <b>TRUE</b> if successful. Otherwise, the function returns <b>FALSE</b>. Call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to obtain the error code.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevpropertysheetsa
     * @since windows5.0
     */
    static SetupDiGetClassDevPropertySheetsA(DeviceInfoSet, DeviceInfoData, PropertySheetHeader, PropertySheetHeaderPageListSize, RequiredSize, PropertySheetType) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevPropertySheetsA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertySheetHeader, "uint", PropertySheetHeaderPageListSize, "ptr", RequiredSize, "uint", PropertySheetType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetClassDevPropertySheets function retrieves handles to the property sheets of a device information element or of the device setup class of a device information set. (Unicode)
     * @remarks
     * A PROPERTYSHEETHEADER structure contains two members that are associated with a caller-supplied array that the function uses to return the handles of property sheets. The <b>phpages</b> member is a pointer to a caller-supplied array of property sheet handles, and the input value of the <b>nPages</b> member specifies the number of handles that are already contained in the handle array. The function adds property sheet handles to the handle array beginning with the array element whose array index is the input value of <b>nPages</b>. The function adds handles to the array in consecutive order until either the array is full or the handles of all the requested property sheet pages have been added to the array. The maximum number of property sheet handles that the function can return is equal to (<i>PropertySheetHeaderPageListSize</i> - (input value of <b>nPages</b>)). 
     * 
     * If the handle array is large enough to hold the handles of all the requested property sheet pages, the function:
     * 
     * <ul>
     * <li>
     * Adds the handles to the handle array.
     * 
     * </li>
     * <li>
     * Sets <b>nPages</b> to the total number of handles in the array.
     * 
     * </li>
     * <li>
     * Sets <i>RequiredSize</i> to the number of handles that it returns.
     * 
     * </li>
     * <li>
     * Returns <b>TRUE</b>.
     * 
     * </li>
     * </ul>
     * If the handle array is not large enough to hold the handles of all the specified property sheet pages, the function: 
     * 
     * <ul>
     * <li>
     * Adds as many handles as the array can hold.
     * 
     * </li>
     * <li>
     * Sets <b>nPages</b> to <i>PropertySheetHeaderPageListSize</i>.
     * 
     * </li>
     * <li>
     * Sets <i>RequiredSize</i> to the total number of requested property sheet pages. The number of handles that are not returned by the function is equal to (<i>RequiredSize</i> - <i>PropertySheetHeaderPageListSize</i> - (input value of <b>nPages</b>)).
     * 
     * </li>
     * <li>
     * Sets the error code to ERROR_INSUFFICIENT_BUFFER.
     * 
     * </li>
     * <li>
     * Returns <b>FALSE</b>.
     * 
     * </li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetClassDevPropertySheets as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to return property sheet handles. If <i>DeviceInfoData</i> does not specify a device information element in the device information set, the device information set must have an associated device setup class.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in DeviceInfoSet. 
     * 
     * This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetClassDevPropertySheets</b> retrieves the property sheets handles that are associated with the specified device. If this parameter is <b>NULL</b>, <b>SetupDiGetClassDevPropertySheets</b> retrieves the property sheets handles that are associated with the device setup class specified in <i>DeviceInfoSet</i>.
     * @param {Pointer<PROPSHEETHEADERW_V2>} PropertySheetHeader A pointer to a PROPERTYSHEETHEADER structure. See the <b>Remarks</b> section for information about the caller-supplied array of property sheet handles that is associated with this structure. 
     * 
     * For more documentation on this structure and property sheets in general, see the Microsoft Windows SDK.
     * @param {Integer} PropertySheetHeaderPageListSize The maximum number of handles that the caller-supplied array of property sheet handles can hold.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of property sheets that are associated with the specified device information element or the device setup class of the specified device information set. The pointer is optional and can be <b>NULL</b>.
     * @param {Integer} PropertySheetType A flag that indicates one of the following types of property sheets.
     * 
     * <table>
     * <tr>
     * <th>Property sheet type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>
     * DIGCDP_FLAG_ADVANCED
     * 
     * </td>
     * <td>
     * Advanced property sheets.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DIGCDP_FLAG_BASIC
     * 
     * </td>
     * <td>
     * Basic property sheets. Supported only in Microsoft Windows 95 and Windows 98. Do not use in Windows 2000 and later versions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DIGCDP_FLAG_REMOTE_ADVANCED
     * 
     * </td>
     * <td>
     * Advanced property sheets on a remote computer.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} The function returns <b>TRUE</b> if successful. Otherwise, the function returns <b>FALSE</b>. Call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to obtain the error code.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevpropertysheetsw
     * @since windows5.0
     */
    static SetupDiGetClassDevPropertySheetsW(DeviceInfoSet, DeviceInfoData, PropertySheetHeader, PropertySheetHeaderPageListSize, RequiredSize, PropertySheetType) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetClassDevPropertySheetsW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", PropertySheetHeader, "uint", PropertySheetHeaderPageListSize, "ptr", RequiredSize, "uint", PropertySheetType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiAskForOEMDisk function displays a dialog that asks the user for the path of an OEM installation disk.
     * @remarks
     * <b>SetupDiAskForOEMDisk</b> allows the user to browse local and network drives for OEM installation files. However, <b>SetupDiAskForOEMDisk</b> is primarily designed to obtain the path of an OEM driver on a local computer before selecting and installing the driver for a device on that computer.
     * 
     * Although this function will not fail if the device information set if for a remote computer, the result is of limited use because the device information set cannot subsequently be used with DIF_<i>Xxx</i> installation requests or <b>SetupDi</b><i>Xxx</i> functions that do not support operations on a remote computer.
     * 
     * In particular, the device information set cannot be used as input with a DIF_SELECTDEVICE installation request to select a driver for a device, followed by a DIF_INSTALLDEVICE installation request to install a device on a remote computer.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for the local computer. This set contains a device information element that represents the device that is being installed.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiAskForOEMDisk</b> associates the driver with the device that is being installed. If this parameter is <b>NULL</b>, <b>SetupDiAskForOEMDisk</b> associates the driver with the global class driver list for <i>DeviceInfoSet</i>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful and the <b>DriverPath</b> field of the SP_DEVINSTALLPARAMS structure is updated to reflect the new path. If the user cancels the dialog, the function returns <b>FALSE</b> and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_CANCELLED.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiaskforoemdisk
     * @since windows5.0
     */
    static SetupDiAskForOEMDisk(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiAskForOEMDisk", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSelectOEMDrv function selects a driver for a device information set or a particular device information element that uses an OEM path supplied by the user.
     * @remarks
     * <b>SetupDiSelectOEMDrv </b> is primarily designed to select an OEM driver for a device on a local computer before installing the device on that computer. Although <b>SetupDiSelectOEMDrv</b> will not fail if the device information set is for a remote computer, the result is of limited use because the device information set cannot subsequently be used with DIF_<i>Xxx</i> installation requests or <b>SetupDi</b><i>Xxx</i> functions that do not support operations on a remote computer. In particular, the device information set cannot be used as input with a DIF_INSTALLDEVICE installation request to install a device on a remote computer.
     * 
     * <b>SetupDiSelectOEMDrv</b> prompts the user for the OEM path and then calls the class installer to select a driver from the OEM path.
     * @param {Pointer<HWND>} hwndParent A window handle that will be the parent of any dialogs created during the processing of this function. This parameter can be used to override the <b>hwndParent</b> field in the installation parameters block of the specified device information set or element.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to select a driver.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies a device information element in <i>DeviceInfoSet</i>. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiSelectOEMDrv</b> associates the selected driver with the specified device. If this parameter is <b>NULL</b>, <b>SetupDiSelectOEMDrv</b> associates the selected driver with the global class driver list for <i>DeviceInfoSet</i>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiselectoemdrv
     * @since windows5.0
     */
    static SetupDiSelectOEMDrv(hwndParent, DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSelectOEMDrv", "ptr", hwndParent, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassNameFromGuid function retrieves the class name associated with a class GUID. (ANSI)
     * @remarks
     * Call <b>SetupDiClassNameFromGuidEx</b> to retrieve the name for a class on a remote computer.
     * 
     * <b>SetupDiClassNameFromGuid</b> does not enforce a restriction on the length of the class name that it can return. This function returns the required size for a NULL-terminated class name even if it is greater than MAX_CLASS_NAME_LEN. However, MAX_CLASS_NAME_LEN is the maximum length of a valid NULL-terminated class name. A caller should never need a buffer that is larger than MAX_CLASS_NAME_LEN. For more information about class names, see the description of the <b>Class</b> entry of an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-version-section">INF Version section</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiClassNameFromGuid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the class GUID for the class name to retrieve.
     * @param {Pointer<PSTR>} ClassName A pointer to a buffer that receives the NULL-terminated string that contains the name of the class that is specified by the pointer in the <i>ClassGuid</i> parameter.
     * @param {Integer} ClassNameSize The size, in characters, of the buffer that is pointed to by the <i>ClassName</i> parameter. The maximum size, in characters, of a NULL-terminated class name is MAX_CLASS_NAME_LEN. For more information about the class name size, see the following <b>Remarks</b> section.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable that receives the number of characters that are required to store the requested NULL-terminated class name. This pointer is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassnamefromguida
     * @since windows5.0
     */
    static SetupDiClassNameFromGuidA(ClassGuid, ClassName, ClassNameSize, RequiredSize) {
        ClassName := ClassName is String? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassNameFromGuidA", "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassNameFromGuid function retrieves the class name associated with a class GUID. (Unicode)
     * @remarks
     * Call <b>SetupDiClassNameFromGuidEx</b> to retrieve the name for a class on a remote computer.
     * 
     * <b>SetupDiClassNameFromGuid</b> does not enforce a restriction on the length of the class name that it can return. This function returns the required size for a NULL-terminated class name even if it is greater than MAX_CLASS_NAME_LEN. However, MAX_CLASS_NAME_LEN is the maximum length of a valid NULL-terminated class name. A caller should never need a buffer that is larger than MAX_CLASS_NAME_LEN. For more information about class names, see the description of the <b>Class</b> entry of an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-version-section">INF Version section</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiClassNameFromGuid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid A pointer to the class GUID for the class name to retrieve.
     * @param {Pointer<PWSTR>} ClassName A pointer to a buffer that receives the NULL-terminated string that contains the name of the class that is specified by the pointer in the <i>ClassGuid</i> parameter.
     * @param {Integer} ClassNameSize The size, in characters, of the buffer that is pointed to by the <i>ClassName</i> parameter. The maximum size, in characters, of a NULL-terminated class name is MAX_CLASS_NAME_LEN. For more information about the class name size, see the following <b>Remarks</b> section.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable that receives the number of characters that are required to store the requested NULL-terminated class name. This pointer is optional and can be <b>NULL</b>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassnamefromguidw
     * @since windows5.0
     */
    static SetupDiClassNameFromGuidW(ClassGuid, ClassName, ClassNameSize, RequiredSize) {
        ClassName := ClassName is String? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassNameFromGuidW", "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassNameFromGuidEx function retrieves the class name associated with a class GUID. The class can be installed on a local or remote computer. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiClassNameFromGuidEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid The class GUID of the class name to retrieve.
     * @param {Pointer<PSTR>} ClassName A pointer to a string buffer that receives the NULL-terminated name of the class for the specified GUID.
     * @param {Integer} ClassNameSize The size, in characters, of the <i>ClassName</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize The number of characters required to store the class name (including a terminating null). <i>RequiredSize</i> is always less than MAX_CLASS_NAME_LEN.
     * @param {Pointer<PSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system on which the class is installed. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the local system name is used.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassnamefromguidexa
     * @since windows5.0
     */
    static SetupDiClassNameFromGuidExA(ClassGuid, ClassName, ClassNameSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassName := ClassName is String? StrPtr(ClassName) : ClassName
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassNameFromGuidExA", "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassNameFromGuidEx function retrieves the class name associated with a class GUID. The class can be installed on a local or remote computer. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiClassNameFromGuidEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} ClassGuid The class GUID of the class name to retrieve.
     * @param {Pointer<PWSTR>} ClassName A pointer to a string buffer that receives the NULL-terminated name of the class for the specified GUID.
     * @param {Integer} ClassNameSize The size, in characters, of the <i>ClassName</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize The number of characters required to store the class name (including a terminating null). <i>RequiredSize</i> is always less than MAX_CLASS_NAME_LEN.
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system on which the class is installed. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the local system name is used.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassnamefromguidexw
     * @since windows5.0
     */
    static SetupDiClassNameFromGuidExW(ClassGuid, ClassName, ClassNameSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassName := ClassName is String? StrPtr(ClassName) : ClassName
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassNameFromGuidExW", "ptr", ClassGuid, "ptr", ClassName, "uint", ClassNameSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassGuidsFromName function retrieves the GUID(s) associated with the specified class name. This list is built based on the classes currently installed on the system. (ANSI)
     * @remarks
     * Call <b>SetupDiClassGuidsFromNameEx</b> to retrieve the class GUIDs for a class on a remote computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiClassGuidsFromName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} ClassName The name of the class for which to retrieve the class GUID.
     * @param {Pointer<Guid>} ClassGuidList A pointer to an array to receive the list of GUIDs associated with the specified class name.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the <i>ClassGuidList</i> array.
     * @param {Pointer<UInt32>} RequiredSize Supplies a pointer to a variable that receives the number of GUIDs associated with the class name. If this number is greater than the size of the <i>ClassGuidList</i> buffer, the number indicates how large the array must be in order to store all the GUIDs.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassguidsfromnamea
     * @since windows5.0
     */
    static SetupDiClassGuidsFromNameA(ClassName, ClassGuidList, ClassGuidListSize, RequiredSize) {
        ClassName := ClassName is String? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassGuidsFromNameA", "ptr", ClassName, "ptr", ClassGuidList, "uint", ClassGuidListSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassGuidsFromName function retrieves the GUID(s) associated with the specified class name. This list is built based on the classes currently installed on the system. (Unicode)
     * @remarks
     * Call <b>SetupDiClassGuidsFromNameEx</b> to retrieve the class GUIDs for a class on a remote computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiClassGuidsFromName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} ClassName The name of the class for which to retrieve the class GUID.
     * @param {Pointer<Guid>} ClassGuidList A pointer to an array to receive the list of GUIDs associated with the specified class name.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the <i>ClassGuidList</i> array.
     * @param {Pointer<UInt32>} RequiredSize Supplies a pointer to a variable that receives the number of GUIDs associated with the class name. If this number is greater than the size of the <i>ClassGuidList</i> buffer, the number indicates how large the array must be in order to store all the GUIDs.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassguidsfromnamew
     * @since windows5.0
     */
    static SetupDiClassGuidsFromNameW(ClassName, ClassGuidList, ClassGuidListSize, RequiredSize) {
        ClassName := ClassName is String? StrPtr(ClassName) : ClassName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassGuidsFromNameW", "ptr", ClassName, "ptr", ClassGuidList, "uint", ClassGuidListSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassGuidsFromNameEx function retrieves the GUIDs associated with the specified class name. This resulting list contains the classes currently installed on a local or remote computer. (ANSI)
     * @remarks
     * Class names are not guaranteed to be unique; only GUIDs are unique. Therefore, one class name can return more than one GUID.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiClassGuidsFromNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} ClassName The name of the class for which to retrieve the class GUIDs.
     * @param {Pointer<Guid>} ClassGuidList A pointer to an array to receive the list of GUIDs associated with the specified class name.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the <i>ClassGuidList</i> array.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable that receives the number of GUIDs associated with the class name. If this number is greater than the size of the <i>ClassGuidList</i> buffer, the number indicates how large the array must be in order to store all the GUIDs.
     * @param {Pointer<PSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system from which to retrieve the GUIDs. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the local system name is used.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassguidsfromnameexa
     * @since windows5.0
     */
    static SetupDiClassGuidsFromNameExA(ClassName, ClassGuidList, ClassGuidListSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassName := ClassName is String? StrPtr(ClassName) : ClassName
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassGuidsFromNameExA", "ptr", ClassName, "ptr", ClassGuidList, "uint", ClassGuidListSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiClassGuidsFromNameEx function retrieves the GUIDs associated with the specified class name. This resulting list contains the classes currently installed on a local or remote computer. (Unicode)
     * @remarks
     * Class names are not guaranteed to be unique; only GUIDs are unique. Therefore, one class name can return more than one GUID.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiClassGuidsFromNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} ClassName The name of the class for which to retrieve the class GUIDs.
     * @param {Pointer<Guid>} ClassGuidList A pointer to an array to receive the list of GUIDs associated with the specified class name.
     * @param {Integer} ClassGuidListSize The number of GUIDs in the <i>ClassGuidList</i> array.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable that receives the number of GUIDs associated with the class name. If this number is greater than the size of the <i>ClassGuidList</i> buffer, the number indicates how large the array must be in order to store all the GUIDs.
     * @param {Pointer<PWSTR>} MachineName A pointer to a NULL-terminated string that contains the name of a remote system from which to retrieve the GUIDs. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the local system name is used.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiclassguidsfromnameexw
     * @since windows5.0
     */
    static SetupDiClassGuidsFromNameExW(ClassName, ClassGuidList, ClassGuidListSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        ClassName := ClassName is String? StrPtr(ClassName) : ClassName
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiClassGuidsFromNameExW", "ptr", ClassName, "ptr", ClassGuidList, "uint", ClassGuidListSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileFriendlyName function retrieves the friendly name associated with a hardware profile ID. (ANSI)
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigethwprofilefriendlynameexa">SetupDiGetHwProfileFriendlyNameEx</a> to get the friendly name of a hardware profile ID on a remote computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetHwProfileFriendlyName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} HwProfile The hardware profile ID associated with the friendly name to retrieve. If this parameter is 0, the friendly name for the current hardware profile is retrieved.
     * @param {Pointer<PSTR>} FriendlyName A pointer to a string buffer to receive the friendly name.
     * @param {Integer} FriendlyNameSize The size, in characters, of the <i>FriendlyName</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of characters required to retrieve the friendly name (including a NULL terminator).
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigethwprofilefriendlynamea
     * @since windows5.0
     */
    static SetupDiGetHwProfileFriendlyNameA(HwProfile, FriendlyName, FriendlyNameSize, RequiredSize) {
        FriendlyName := FriendlyName is String? StrPtr(FriendlyName) : FriendlyName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileFriendlyNameA", "uint", HwProfile, "ptr", FriendlyName, "uint", FriendlyNameSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileFriendlyName function retrieves the friendly name associated with a hardware profile ID. (Unicode)
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigethwprofilefriendlynameexa">SetupDiGetHwProfileFriendlyNameEx</a> to get the friendly name of a hardware profile ID on a remote computer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetHwProfileFriendlyName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} HwProfile The hardware profile ID associated with the friendly name to retrieve. If this parameter is 0, the friendly name for the current hardware profile is retrieved.
     * @param {Pointer<PWSTR>} FriendlyName A pointer to a string buffer to receive the friendly name.
     * @param {Integer} FriendlyNameSize The size, in characters, of the <i>FriendlyName</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the number of characters required to retrieve the friendly name (including a NULL terminator).
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigethwprofilefriendlynamew
     * @since windows5.0
     */
    static SetupDiGetHwProfileFriendlyNameW(HwProfile, FriendlyName, FriendlyNameSize, RequiredSize) {
        FriendlyName := FriendlyName is String? StrPtr(FriendlyName) : FriendlyName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileFriendlyNameW", "uint", HwProfile, "ptr", FriendlyName, "uint", FriendlyNameSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileFriendlyNameEx function retrieves the friendly name associated with a hardware profile ID on a local or remote computer. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetHwProfileFriendlyNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} HwProfile Supplies the hardware profile ID associated with the friendly name to retrieve. If this parameter is 0, the friendly name for the current hardware profile is retrieved.
     * @param {Pointer<PSTR>} FriendlyName A pointer to a character buffer to receive the friendly name.
     * @param {Integer} FriendlyNameSize The size, in characters, of the <i>FriendlyName</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable to receive the number of characters required to store the friendly name (including a NULL terminator). This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<PSTR>} MachineName A pointer to NULL-terminated string that contains the name of a remote computer on which the hardware profile ID resides. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the hardware profile ID is on the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigethwprofilefriendlynameexa
     * @since windows5.0
     */
    static SetupDiGetHwProfileFriendlyNameExA(HwProfile, FriendlyName, FriendlyNameSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        FriendlyName := FriendlyName is String? StrPtr(FriendlyName) : FriendlyName
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileFriendlyNameExA", "uint", HwProfile, "ptr", FriendlyName, "uint", FriendlyNameSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetHwProfileFriendlyNameEx function retrieves the friendly name associated with a hardware profile ID on a local or remote computer. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetHwProfileFriendlyNameEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} HwProfile Supplies the hardware profile ID associated with the friendly name to retrieve. If this parameter is 0, the friendly name for the current hardware profile is retrieved.
     * @param {Pointer<PWSTR>} FriendlyName A pointer to a character buffer to receive the friendly name.
     * @param {Integer} FriendlyNameSize The size, in characters, of the <i>FriendlyName</i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable to receive the number of characters required to store the friendly name (including a NULL terminator). This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<PWSTR>} MachineName A pointer to NULL-terminated string that contains the name of a remote computer on which the hardware profile ID resides. This parameter is optional and can be <b>NULL</b>. If <i>MachineName</i> is <b>NULL</b>, the hardware profile ID is on the local computer.
     * 
     * > [!CAUTION]
     * > Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigethwprofilefriendlynameexw
     * @since windows5.0
     */
    static SetupDiGetHwProfileFriendlyNameExW(HwProfile, FriendlyName, FriendlyNameSize, RequiredSize, MachineName) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        FriendlyName := FriendlyName is String? StrPtr(FriendlyName) : FriendlyName
        MachineName := MachineName is String? StrPtr(MachineName) : MachineName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetHwProfileFriendlyNameExW", "uint", HwProfile, "ptr", FriendlyName, "uint", FriendlyNameSize, "ptr", RequiredSize, "ptr", MachineName, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer} DeviceInfoSet 
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData 
     * @param {Pointer<SP_INSTALLWIZARD_DATA>} InstallWizardData 
     * @param {Integer} PageType 
     * @param {Integer} Flags 
     * @returns {Pointer<HPROPSHEETPAGE>} 
     */
    static SetupDiGetWizardPage(DeviceInfoSet, DeviceInfoData, InstallWizardData, PageType, Flags) {
        result := DllCall("SETUPAPI.dll\SetupDiGetWizardPage", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", InstallWizardData, "uint", PageType, "uint", Flags, "ptr")
        return result
    }

    /**
     * The SetupDiGetSelectedDevice function retrieves the selected device information element in a device information set.
     * @remarks
     * <b>SetupDiGetSelectedDevice</b> is usually used by an installation wizard.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> for which to retrieve the selected device information element.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that receives information about the selected device information element for <i>DeviceInfoSet</i>. The caller must set <i>DeviceInfoData.</i><b>cbSize</b> to <b>sizeof</b>(SP_DEVINFO_DATA). If a device is currently not selected, the function fails and a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_DEVICE_SELECTED.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetselecteddevice
     * @since windows5.0
     */
    static SetupDiGetSelectedDevice(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetSelectedDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiSetSelectedDevice function sets a device information element as the selected member of a device information set. This function is typically used by an installation wizard.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains the device information element to set as the selected member of the device information set.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i> to set as the selected member of <i>DeviceInfoSet</i>.
     * @returns {Integer} The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdisetselecteddevice
     * @since windows5.0
     */
    static SetupDiSetSelectedDevice(DeviceInfoSet, DeviceInfoData) {
        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiSetSelectedDevice", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualModelsSection function retrieves the appropriate decorated INF Models section to use when installing a device from a device INF file. (ANSI)
     * @remarks
     * <b>SetupDiGetActualModelsSection</b> determines which <i>TargetOSVersion</i> fields in the <i>manufacturer-identifier</i> entry (supplied by <i>Context</i>) apply to the current platform, if <i>AlternatePlatformInfo</i> is not supplied, or to an alternative platform, if alternative platform information is supplied. <b>SetupDiGetActualModelsSection</b> selects the most appropriate platform based on all the <i>TargetOSVersion</i> fields, appends the <i>TargetOSVersion</i> string to the INF <i>Models</i> section name, and returns the decorated INF <i>Models</i> section name to the caller. In a <i>manufacturer-identifier</i> entry, the operating system major version is specified by the <i>OSMajorVersion</i> field and the operating system minor version is specified by the <i>OSMinorVersion</i> field.
     * 
     * For information about retrieving an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-section">INF DDInstall section</a> for a device, see <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstalla">SetupDiGetActualSectionToInstall</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetActualModelsSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} Context A pointer to an INF file context that specifies a <i>manufacturer-identifier</i> entry in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-manufacturer-section">INF Manufacturer section</a> of an INF file. The <i>manufacturer-identifier</i> entry specifies an INF <i>Models</i> section name and optionally specifies <i>TargetOSVersion</i> decorations for the <i>Models</i> section name. For information about INF files and an INF file context, see the Platform SDK topics on <a href="https://docs.microsoft.com/windows/win32/setupapi/using-inf-files">using INF files</a> and the <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-infcontext">INFCONTEXT structure</a>.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo A pointer to an <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO</a> structure that supplies information about a Windows version and processor architecture. The <b>cbSize</b> member of this structure must be set to <b>sizeof(</b>SP_ALTPLATFORM_INFO_V2<b>)</b>. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<PSTR>} InfSectionWithExt A pointer to a buffer that receives a string that contains the decorated INF <i>Models</i> section name and a NULL terminator. If <i>AlternatePlatformInfo</i> is not supplied, the decorated INF <i>Models</i> section name applies to the current platform; otherwise the name applies to the specified alternative platform. This parameter is optional and can be set to <b>NULL</b>. If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the decorated <i>Models</i> section name and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the <i>DecoratedModelsSection </i> buffer. If <i>DecoratedModelsSection</i> is <b>NULL</b>, this parameter must be set to zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-type variable that receives the size, in characters, of the <i>DecoratedModelsSection</i> buffer that is required to retrieve the decorated <i>Models</i> section name and a terminating NULL character. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {Integer} <b>SetupDiGetActualModelsSection</b> returns <b>TRUE</b> if the operation succeeds. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetactualmodelssectiona
     */
    static SetupDiGetActualModelsSectionA(Context, AlternatePlatformInfo, InfSectionWithExt, InfSectionWithExtSize, RequiredSize) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionWithExt := InfSectionWithExt is String? StrPtr(InfSectionWithExt) : InfSectionWithExt

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualModelsSectionA", "ptr", Context, "ptr", AlternatePlatformInfo, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "ptr", RequiredSize, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualModelsSection function retrieves the appropriate decorated INF Models section to use when installing a device from a device INF file. (Unicode)
     * @remarks
     * <b>SetupDiGetActualModelsSection</b> determines which <i>TargetOSVersion</i> fields in the <i>manufacturer-identifier</i> entry (supplied by <i>Context</i>) apply to the current platform, if <i>AlternatePlatformInfo</i> is not supplied, or to an alternative platform, if alternative platform information is supplied. <b>SetupDiGetActualModelsSection</b> selects the most appropriate platform based on all the <i>TargetOSVersion</i> fields, appends the <i>TargetOSVersion</i> string to the INF <i>Models</i> section name, and returns the decorated INF <i>Models</i> section name to the caller. In a <i>manufacturer-identifier</i> entry, the operating system major version is specified by the <i>OSMajorVersion</i> field and the operating system minor version is specified by the <i>OSMinorVersion</i> field.
     * 
     * For information about retrieving an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-section">INF DDInstall section</a> for a device, see <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstalla">SetupDiGetActualSectionToInstall</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetActualModelsSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<INFCONTEXT>} Context A pointer to an INF file context that specifies a <i>manufacturer-identifier</i> entry in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-manufacturer-section">INF Manufacturer section</a> of an INF file. The <i>manufacturer-identifier</i> entry specifies an INF <i>Models</i> section name and optionally specifies <i>TargetOSVersion</i> decorations for the <i>Models</i> section name. For information about INF files and an INF file context, see the Platform SDK topics on <a href="https://docs.microsoft.com/windows/win32/setupapi/using-inf-files">using INF files</a> and the <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-infcontext">INFCONTEXT structure</a>.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo A pointer to an <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO</a> structure that supplies information about a Windows version and processor architecture. The <b>cbSize</b> member of this structure must be set to <b>sizeof(</b>SP_ALTPLATFORM_INFO_V2<b>)</b>. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<PWSTR>} InfSectionWithExt A pointer to a buffer that receives a string that contains the decorated INF <i>Models</i> section name and a NULL terminator. If <i>AlternatePlatformInfo</i> is not supplied, the decorated INF <i>Models</i> section name applies to the current platform; otherwise the name applies to the specified alternative platform. This parameter is optional and can be set to <b>NULL</b>. If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the decorated <i>Models</i> section name and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the <i>DecoratedModelsSection </i> buffer. If <i>DecoratedModelsSection</i> is <b>NULL</b>, this parameter must be set to zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a DWORD-type variable that receives the size, in characters, of the <i>DecoratedModelsSection</i> buffer that is required to retrieve the decorated <i>Models</i> section name and a terminating NULL character. This parameter is optional and can be set to <b>NULL</b>.
     * @returns {Integer} <b>SetupDiGetActualModelsSection</b> returns <b>TRUE</b> if the operation succeeds. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetactualmodelssectionw
     */
    static SetupDiGetActualModelsSectionW(Context, AlternatePlatformInfo, InfSectionWithExt, InfSectionWithExtSize, RequiredSize) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionWithExt := InfSectionWithExt is String? StrPtr(InfSectionWithExt) : InfSectionWithExt

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualModelsSectionW", "ptr", Context, "ptr", AlternatePlatformInfo, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "ptr", RequiredSize, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualSectionToInstall function retrieves the appropriate INF DDInstall section to use when installing a device from a device INF file on a local computer. (ANSI)
     * @remarks
     * This function supports the extensions to <i>DDInstall</i> section names that are used to specify OS-specific and architecture-specific installation behaviors for a device. For information about these extensions, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/creating-inf-files-for-multiple-platforms-and-operating-systems">Creating INF Files for Multiple Platforms and Operating Systems</a>. <b>SetupDiGetActualSectionToInstall</b> searches for a <i>DDInstall</i> section name that matches the local computer in the manner described below.
     * 
     * The function first searches in the specified INF file for a decorated install section name that matches the specified name and has an extension that matches the operating system and processor architecture of the local computer. If, for example, you specify a section name of <b>InstallSec</b>, the function searches for one of the following decorated names, depending on the processor architecture of the local computer:
     * 
     * <ul>
     * <li>
     * For a computer that is based on the x86 processor architecture, the function searches for the decorated name <b>InstallSec.ntx86</b>.
     * 
     * </li>
     * <li>
     * For a computer that is based on the x64 processor architecture, the function searches for the decorated name <b>InstallSec.ntamd64</b>.
     * 
     * </li>
     * <li>
     * For a computer that is based on the Itanium processor architecture, the function searches for the decorated name <b>InstallSec.ntia64</b>.
     * 
     * </li>
     * </ul>
     * If the function finds a match for the name, operating system, and processor architecture, it terminates the search and returns the corresponding decorated name. If the function does not find such a match, the function searches for a section whose name is <b>InstallSec.NT</b>. If the function finds a match for <b>InstallSec.NT</b>, it terminates the search and returns this name. If the function does not find a match for either of the above searches, it returns <b>InstallSec</b>, but does not verify that the INF file contains an install section whose name is <b>InstallSec</b>.
     * 
     * The <i>DDInstall</i> section name is used as the base for <b>Hardware</b> and <b>Services</b> section names. For example, if the <i>DDInstall</i> section name that is found is <b>InstallSec.NTX86</b>, the <b>Services</b> section name must be named <b>InstallSec.NTX86.Services</b>.
     * 
     * The original <i>DDInstall</i> section name that is specified in the driver node is written to the driver's registry key's <b>InfSection</b> value entry. The extension that was found is stored in the key as the REG_SZ value <b>InfSectionExt</b>. For example:
     * 
     * 
     * ```
     * InfSection       : REG_SZ :    "InstallSec"
     * InfSectionExt    : REG_SZ :    ".NTX86"
     * ```
     * 
     * 
     * If a driver is not selected for the specified device information element, a null driver is installed. Upon return, the flags in the device's <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure indicate whether the system should be restarted or rebooted to cause the device to start.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetActualSectionToInstall as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle The handle to the INF file that contains the <i>DDInstall</i> section.
     * @param {Pointer<PSTR>} InfSectionName A pointer to the <i>DDInstall</i> section name (as specified in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-models-section">INF Models section</a>). The maximum length of the section name, in characters, is 254.
     * @param {Pointer<PSTR>} InfSectionWithExt A pointer to a character buffer to receive the <i>DDInstall</i> section name, its platform extension, and a NULL terminator. This is the decorated section name that should be used for installation. If this parameter is <b>NULL</b>, <i>InfSectionWithExtSize</i> must be zero. If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the <i>DDInstall</i> section name, its platform extension, and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the <i>InfSectionWithExt</i> buffer. If <i>InfSectionWithExt</i> is <b>NULL</b>, this parameter must be zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to the variable that receives the size, in characters, that is required to return the <i>DDInstall</i> section name, the platform extension, and a terminating NULL character.
     * @param {Pointer<PSTR>} Extension A pointer to a variable that receives a pointer to the '.' character that marks the start of the extension in the <i>InfSectionWithExt</i> buffer. If the <i>InfSectionWithExt</i> buffer is not supplied or is too small, this parameter is not set. Set this parameter to <b>NULL</b> if a pointer to the extension is not required.
     * @returns {Integer} If the function is successful, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstalla
     * @since windows5.0
     */
    static SetupDiGetActualSectionToInstallA(InfHandle, InfSectionName, InfSectionWithExt, InfSectionWithExtSize, RequiredSize, Extension) {
        InfSectionName := InfSectionName is String? StrPtr(InfSectionName) : InfSectionName
        InfSectionWithExt := InfSectionWithExt is String? StrPtr(InfSectionWithExt) : InfSectionWithExt
        Extension := Extension is String? StrPtr(Extension) : Extension

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualSectionToInstallA", "ptr", InfHandle, "ptr", InfSectionName, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "ptr", RequiredSize, "ptr", Extension, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualSectionToInstall function retrieves the appropriate INF DDInstall section to use when installing a device from a device INF file on a local computer. (Unicode)
     * @remarks
     * This function supports the extensions to <i>DDInstall</i> section names that are used to specify OS-specific and architecture-specific installation behaviors for a device. For information about these extensions, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/creating-inf-files-for-multiple-platforms-and-operating-systems">Creating INF Files for Multiple Platforms and Operating Systems</a>. <b>SetupDiGetActualSectionToInstall</b> searches for a <i>DDInstall</i> section name that matches the local computer in the manner described below.
     * 
     * The function first searches in the specified INF file for a decorated install section name that matches the specified name and has an extension that matches the operating system and processor architecture of the local computer. If, for example, you specify a section name of <b>InstallSec</b>, the function searches for one of the following decorated names, depending on the processor architecture of the local computer:
     * 
     * <ul>
     * <li>
     * For a computer that is based on the x86 processor architecture, the function searches for the decorated name <b>InstallSec.ntx86</b>.
     * 
     * </li>
     * <li>
     * For a computer that is based on the x64 processor architecture, the function searches for the decorated name <b>InstallSec.ntamd64</b>.
     * 
     * </li>
     * <li>
     * For a computer that is based on the Itanium processor architecture, the function searches for the decorated name <b>InstallSec.ntia64</b>.
     * 
     * </li>
     * </ul>
     * If the function finds a match for the name, operating system, and processor architecture, it terminates the search and returns the corresponding decorated name. If the function does not find such a match, the function searches for a section whose name is <b>InstallSec.NT</b>. If the function finds a match for <b>InstallSec.NT</b>, it terminates the search and returns this name. If the function does not find a match for either of the above searches, it returns <b>InstallSec</b>, but does not verify that the INF file contains an install section whose name is <b>InstallSec</b>.
     * 
     * The <i>DDInstall</i> section name is used as the base for <b>Hardware</b> and <b>Services</b> section names. For example, if the <i>DDInstall</i> section name that is found is <b>InstallSec.NTX86</b>, the <b>Services</b> section name must be named <b>InstallSec.NTX86.Services</b>.
     * 
     * The original <i>DDInstall</i> section name that is specified in the driver node is written to the driver's registry key's <b>InfSection</b> value entry. The extension that was found is stored in the key as the REG_SZ value <b>InfSectionExt</b>. For example:
     * 
     * 
     * ```
     * InfSection       : REG_SZ :    "InstallSec"
     * InfSectionExt    : REG_SZ :    ".NTX86"
     * ```
     * 
     * 
     * If a driver is not selected for the specified device information element, a null driver is installed. Upon return, the flags in the device's <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure indicate whether the system should be restarted or rebooted to cause the device to start.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetActualSectionToInstall as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle The handle to the INF file that contains the <i>DDInstall</i> section.
     * @param {Pointer<PWSTR>} InfSectionName A pointer to the <i>DDInstall</i> section name (as specified in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-models-section">INF Models section</a>). The maximum length of the section name, in characters, is 254.
     * @param {Pointer<PWSTR>} InfSectionWithExt A pointer to a character buffer to receive the <i>DDInstall</i> section name, its platform extension, and a NULL terminator. This is the decorated section name that should be used for installation. If this parameter is <b>NULL</b>, <i>InfSectionWithExtSize</i> must be zero. If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the <i>DDInstall</i> section name, its platform extension, and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the <i>InfSectionWithExt</i> buffer. If <i>InfSectionWithExt</i> is <b>NULL</b>, this parameter must be zero.
     * @param {Pointer<UInt32>} RequiredSize A pointer to the variable that receives the size, in characters, that is required to return the <i>DDInstall</i> section name, the platform extension, and a terminating NULL character.
     * @param {Pointer<PWSTR>} Extension A pointer to a variable that receives a pointer to the '.' character that marks the start of the extension in the <i>InfSectionWithExt</i> buffer. If the <i>InfSectionWithExt</i> buffer is not supplied or is too small, this parameter is not set. Set this parameter to <b>NULL</b> if a pointer to the extension is not required.
     * @returns {Integer} If the function is successful, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstallw
     * @since windows5.0
     */
    static SetupDiGetActualSectionToInstallW(InfHandle, InfSectionName, InfSectionWithExt, InfSectionWithExtSize, RequiredSize, Extension) {
        InfSectionName := InfSectionName is String? StrPtr(InfSectionName) : InfSectionName
        InfSectionWithExt := InfSectionWithExt is String? StrPtr(InfSectionWithExt) : InfSectionWithExt
        Extension := Extension is String? StrPtr(Extension) : Extension

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualSectionToInstallW", "ptr", InfHandle, "ptr", InfSectionName, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "ptr", RequiredSize, "ptr", Extension, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualSectionToInstallEx function retrieves the name of the INF DDInstall section that installs a device for a specified operating system and processor architecture. (ANSI)
     * @remarks
     * <b>SetupDiGetActualSectionToInstallEx</b> is an extended form of <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstalla">SetupDiGetActualSectionToInstall</a>. These functions support the extensions to <i>DDInstall</i> section names that are used to specify OS-specific and architecture-specific installation actions for a device. For information about these extensions, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/creating-inf-files-for-multiple-platforms-and-operating-systems">Creating INF Files for Multiple Platforms and Operating Systems</a>.
     * 
     * If you do not supply alternative platform information with a call to <b>SetupDiGetActualSectionToInstallEx</b>, the function performs the same operation as <b>SetupDiGetActualSectionToInstall</b>. The latter function searches for the specified install section name using the platform information for the local computer.
     * 
     * If you supply alternative platform information with a call to <b>SetupDiGetActualSectionToInstallEx</b>, the function does the following:
     * 
     * <ul>
     * <li>
     * If you specify a platform of VER_PLATFORM_WIN32_NT, the function first searches in the specified INF file for a decorated install section name that matches the name, operating system, and processor architecture that you specify. If, for example, you specify an install section name of <b>InstallSec</b>, the function searches for one of the following decorated names, depending on the specified processor architecture:<ul>
     * <li>If you specify the x86-based processor architecture, the function searches for the decorated name <b>InstallSec.ntx86</b>.</li>
     * <li>If you specify the x64-based processor architecture, the function searches for the decorated name <b>InstallSec.ntamd64</b>.</li>
     * <li>If you specify the Itanium-based processor architecture, the function searches for the decorated name <b>InstallSec.ntia64</b>.</li>
     * </ul>
     * 
     * 
     * If the function finds a match for the name, operating system, and processor architecture, it terminates the search and returns the corresponding decorated name. If the function does not find such a match, the function searches for a section whose name is <b>InstallSec.nt</b>. If the function finds a match for <b>InstallSec.nt</b>, it terminates the search and returns this name. If the function does not find a match for either of the above searches, it returns <b>InstallSec</b>, but does not verify that the INF file contains an install section whose name is <b>InstallSec</b>.
     * 
     * </li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetActualSectionToInstallEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <i>DDInstall</i> section.
     * @param {Pointer<PSTR>} InfSectionName A pointer to the <i>DDInstall</i> section name (as specified in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-models-section">INF Models section</a>). The maximum length of the section name, in characters, is 254.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo A pointer, if non-<b>NULL</b>, to an <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO</a> structure. This structure is used to specify an operating system and processor architecture that is different from that on the local computer. To return the <i>DDInstall </i>section name for the local computer, set this parameter to <b>NULL</b>. Otherwise, provide an SP_ALTPLATFORM structure and set its members as follows:
     * @param {Pointer<PSTR>} InfSectionWithExt A pointer to a character buffer to receive the <i>DDInstall</i> section name, its platform extension, and a NULL terminator. This is the decorated section name that should be used for installation.  If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the <i>DDInstall</i> section name, its platform extension, and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the buffer that is pointed to by the <i>InfSectionWithExt</i> parameter. The maximum length of a NULL-terminated INF section name, in characters, is MAX_INF_SECTION_NAME_LENGTH.
     * @param {Pointer<UInt32>} RequiredSize A pointer to the variable that receives the size, in characters, that is required to return the <i>DDInstall</i> section name, the platform extension, and a terminating NULL character.
     * @param {Pointer<PSTR>} Extension A pointer to a variable that receives a pointer to the '.' character that marks the start of the extension in the <i>InfSectionWithExt</i> buffer. If the <i>InfSectionWithExt</i> buffer is not supplied or is too small, this parameter is not set. Set this parameter to <b>NULL</b> if a pointer to the extension is not required.
     * @returns {Integer} If the function is successful, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstallexa
     * @since windows5.1.2600
     */
    static SetupDiGetActualSectionToInstallExA(InfHandle, InfSectionName, AlternatePlatformInfo, InfSectionWithExt, InfSectionWithExtSize, RequiredSize, Extension) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionName := InfSectionName is String? StrPtr(InfSectionName) : InfSectionName
        InfSectionWithExt := InfSectionWithExt is String? StrPtr(InfSectionWithExt) : InfSectionWithExt
        Extension := Extension is String? StrPtr(Extension) : Extension

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualSectionToInstallExA", "ptr", InfHandle, "ptr", InfSectionName, "ptr", AlternatePlatformInfo, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "ptr", RequiredSize, "ptr", Extension, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetActualSectionToInstallEx function retrieves the name of the INF DDInstall section that installs a device for a specified operating system and processor architecture. (Unicode)
     * @remarks
     * <b>SetupDiGetActualSectionToInstallEx</b> is an extended form of <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstalla">SetupDiGetActualSectionToInstall</a>. These functions support the extensions to <i>DDInstall</i> section names that are used to specify OS-specific and architecture-specific installation actions for a device. For information about these extensions, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/creating-inf-files-for-multiple-platforms-and-operating-systems">Creating INF Files for Multiple Platforms and Operating Systems</a>.
     * 
     * If you do not supply alternative platform information with a call to <b>SetupDiGetActualSectionToInstallEx</b>, the function performs the same operation as <b>SetupDiGetActualSectionToInstall</b>. The latter function searches for the specified install section name using the platform information for the local computer.
     * 
     * If you supply alternative platform information with a call to <b>SetupDiGetActualSectionToInstallEx</b>, the function does the following:
     * 
     * <ul>
     * <li>
     * If you specify a platform of VER_PLATFORM_WIN32_NT, the function first searches in the specified INF file for a decorated install section name that matches the name, operating system, and processor architecture that you specify. If, for example, you specify an install section name of <b>InstallSec</b>, the function searches for one of the following decorated names, depending on the specified processor architecture:<ul>
     * <li>If you specify the x86-based processor architecture, the function searches for the decorated name <b>InstallSec.ntx86</b>.</li>
     * <li>If you specify the x64-based processor architecture, the function searches for the decorated name <b>InstallSec.ntamd64</b>.</li>
     * <li>If you specify the Itanium-based processor architecture, the function searches for the decorated name <b>InstallSec.ntia64</b>.</li>
     * </ul>
     * 
     * 
     * If the function finds a match for the name, operating system, and processor architecture, it terminates the search and returns the corresponding decorated name. If the function does not find such a match, the function searches for a section whose name is <b>InstallSec.nt</b>. If the function finds a match for <b>InstallSec.nt</b>, it terminates the search and returns this name. If the function does not find a match for either of the above searches, it returns <b>InstallSec</b>, but does not verify that the INF file contains an install section whose name is <b>InstallSec</b>.
     * 
     * </li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetActualSectionToInstallEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle to the INF file that contains the <i>DDInstall</i> section.
     * @param {Pointer<PWSTR>} InfSectionName A pointer to the <i>DDInstall</i> section name (as specified in an <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-models-section">INF Models section</a>). The maximum length of the section name, in characters, is 254.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AlternatePlatformInfo A pointer, if non-<b>NULL</b>, to an <a href="https://docs.microsoft.com/windows/win32/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO</a> structure. This structure is used to specify an operating system and processor architecture that is different from that on the local computer. To return the <i>DDInstall</i> section name for the local computer, set this parameter to <b>NULL</b>. Otherwise, provide an SP_ALTPLATFORM structure and set its members as follows:
     * @param {Pointer<PWSTR>} InfSectionWithExt A pointer to a character buffer to receive the <i>DDInstall</i> section name, its platform extension, and a NULL terminator. This is the decorated section name that should be used for installation.  If this parameter is <b>NULL</b>, the function returns <b>TRUE</b> and sets <i>RequiredSize</i> to the size, in characters, that is required to return the <i>DDInstall</i> section name, its platform extension, and a terminating NULL character.
     * @param {Integer} InfSectionWithExtSize The size, in characters, of the buffer that is pointed to by the <i>InfSectionWithExt</i> parameter. The maximum length of a NULL-terminated INF section name, in characters, is MAX_INF_SECTION_NAME_LENGTH.
     * @param {Pointer<UInt32>} RequiredSize A pointer to the variable that receives the size, in characters, that is required to return the <i>DDInstall</i> section name, the platform extension, and a terminating NULL character.
     * @param {Pointer<PWSTR>} Extension A pointer to a variable that receives a pointer to the '.' character that marks the start of the extension in the <i>InfSectionWithExt</i> buffer. If the <i>InfSectionWithExt</i> buffer is not supplied or is too small, this parameter is not set. Set this parameter to <b>NULL</b> if a pointer to the extension is not required.
     * @returns {Integer} If the function is successful, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetactualsectiontoinstallexw
     * @since windows5.1.2600
     */
    static SetupDiGetActualSectionToInstallExW(InfHandle, InfSectionName, AlternatePlatformInfo, InfSectionWithExt, InfSectionWithExtSize, RequiredSize, Extension) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        InfSectionName := InfSectionName is String? StrPtr(InfSectionName) : InfSectionName
        InfSectionWithExt := InfSectionWithExt is String? StrPtr(InfSectionWithExt) : InfSectionWithExt
        Extension := Extension is String? StrPtr(Extension) : Extension

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetActualSectionToInstallExW", "ptr", InfHandle, "ptr", InfSectionName, "ptr", AlternatePlatformInfo, "ptr", InfSectionWithExt, "uint", InfSectionWithExtSize, "ptr", RequiredSize, "ptr", Extension, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupEnumInfSections function retrieves section names from an INF file. (ANSI)
     * @remarks
     * This function can enumerate all unique section names in the INF file. If a section name appears more than once in an INF file, the function returns the name only once using a single enumeration index. To return all section names in the INF file, call the function beginning with an enumeration index of zero and then make repeated calls to the function while incrementing the index until the function returns  <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NO_MORE_ITEMS</b>.  Your application should not rely on the section names being returned in any order based on the enumeration index.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupEnumInfSections as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file that is to be queried.
     * @param {Integer} Index The zero-based index of the section name to retrieve. This index may not correspond to the order of sections as they appear in the INF file.
     * @param {Pointer<PSTR>} Buffer Pointer to a buffer that receives the section name. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the name. Using this technique, you can avoid errors caused by an insufficient buffer size. This parameter is optional. For more information, see the Remarks section.
     * @param {Integer} Size Size of the buffer pointed to by <i>ReturnBuffer</i> in characters. This number includes the terminating <b>NULL</b> character.
     * @param {Pointer<UInt32>} SizeNeeded Pointer to a location that receives the required size of the buffer pointed to by <i>ReturnBuffer</i>. The size is specified as the number of characters required to store the section name, including the terminating <b>NULL</b> character.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NO_MORE_ITEMS</b> if the value of <b>EnumerationIndex</b> is greater than or equal to the number of sections names in the INF file.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupenuminfsectionsa
     * @since windows5.1.2600
     */
    static SetupEnumInfSectionsA(InfHandle, Index, Buffer, Size, SizeNeeded) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupEnumInfSectionsA", "ptr", InfHandle, "uint", Index, "ptr", Buffer, "uint", Size, "ptr", SizeNeeded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupEnumInfSections function retrieves section names from an INF file. (Unicode)
     * @remarks
     * This function can enumerate all unique section names in the INF file. If a section name appears more than once in an INF file, the function returns the name only once using a single enumeration index. To return all section names in the INF file, call the function beginning with an enumeration index of zero and then make repeated calls to the function while incrementing the index until the function returns  <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NO_MORE_ITEMS</b>.  Your application should not rely on the section names being returned in any order based on the enumeration index.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupEnumInfSections as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle Handle to the INF file that is to be queried.
     * @param {Integer} Index The zero-based index of the section name to retrieve. This index may not correspond to the order of sections as they appear in the INF file.
     * @param {Pointer<PWSTR>} Buffer Pointer to a buffer that receives the section name. You can call the function once to get the required buffer size, allocate the necessary memory, and then call the function a second time to retrieve the name. Using this technique, you can avoid errors caused by an insufficient buffer size. This parameter is optional. For more information, see the Remarks section.
     * @param {Integer} Size Size of the buffer pointed to by <i>ReturnBuffer</i> in characters. This number includes the terminating <b>NULL</b> character.
     * @param {Pointer<UInt32>} SizeNeeded Pointer to a location that receives the required size of the buffer pointed to by <i>ReturnBuffer</i>. The size is specified as the number of characters required to store the section name, including the terminating <b>NULL</b> character.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_NO_MORE_ITEMS</b> if the value of <b>EnumerationIndex</b> is greater than or equal to the number of sections names in the INF file.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupenuminfsectionsw
     * @since windows5.1.2600
     */
    static SetupEnumInfSectionsW(InfHandle, Index, Buffer, Size, SizeNeeded) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupEnumInfSectionsW", "ptr", InfHandle, "uint", Index, "ptr", Buffer, "uint", Size, "ptr", SizeNeeded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupVerifyInfFile function verifies the digital signature of the specified INF file by using its corresponding catalog. The verification can be performed against an alternate platform. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupVerifyInfFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} InfName The name of the INF file to be verified. This name may include a path.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AltPlatformInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO_V2</a> structure that contains information about the alternate platform to use when validating the INF file. This parameter can be Null.
     * @param {Pointer<SP_INF_SIGNER_INFO_V2_A>} InfSignerInfo A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_signer_info_v1_a">SP_INF_SIGNER_INFO</a> structure that receives information about the INF digital signature, that is, if it is signed.
     * @returns {Integer} This function returns WINSETUPAPI BOOL.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupverifyinffilea
     * @since windows5.1.2600
     */
    static SetupVerifyInfFileA(InfName, AltPlatformInfo, InfSignerInfo) {
        InfName := InfName is String? StrPtr(InfName) : InfName

        result := DllCall("SETUPAPI.dll\SetupVerifyInfFileA", "ptr", InfName, "ptr", AltPlatformInfo, "ptr", InfSignerInfo, "int")
        return result
    }

    /**
     * The SetupVerifyInfFile function verifies the digital signature of the specified INF file by using its corresponding catalog. The verification can be performed against an alternate platform. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The setupapi.h header defines SetupVerifyInfFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} InfName The name of the INF file to be verified. This name may include a path.
     * @param {Pointer<SP_ALTPLATFORM_INFO_V2>} AltPlatformInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_altplatform_info_v2">SP_ALTPLATFORM_INFO_V2</a> structure that contains information about the alternate platform to use when validating the INF file. This parameter can be Null.
     * @param {Pointer<SP_INF_SIGNER_INFO_V2_W>} InfSignerInfo A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_inf_signer_info_v1_a">SP_INF_SIGNER_INFO</a> structure that receives information about the INF digital signature, that is, if it is signed.
     * @returns {Integer} This function returns WINSETUPAPI BOOL.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupverifyinffilew
     * @since windows5.1.2600
     */
    static SetupVerifyInfFileW(InfName, AltPlatformInfo, InfSignerInfo) {
        InfName := InfName is String? StrPtr(InfName) : InfName

        result := DllCall("SETUPAPI.dll\SetupVerifyInfFileW", "ptr", InfName, "ptr", AltPlatformInfo, "ptr", InfSignerInfo, "int")
        return result
    }

    /**
     * The SetupDiGetCustomDeviceProperty function retrieves a specified custom device property from the registry. (ANSI)
     * @remarks
     * <b>SetupDiGetCustomDeviceProperty</b> retrieves device properties that are associated with a single device instance or with all devices matching a certain hardware ID. (For information about hardware IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>).
     * 
     * Vendors can set properties for a device instance by using <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-addreg-directive">INF AddReg directives</a> in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-hw-section">INF DDInstall.HW sections</a> and specifying the <b>HKR</b> registry root.
     * 
     * Only the system can set properties for hardware IDs. The system supplies an "Icon" property for some hardware IDs.
     * 
     * The function first checks to see if the specified property exists for the specified device instance. If so, the property's value is returned. If not, the function checks to see if the property exists for all devices matching the hardware ID of the specified device instance. If so, the property's value is returned. If DICUSTOMDEVPROP_MERGE_MULTISZ is set in <i>Flags</i>, the function returns the property values associated with both the device instance and the hardware ID, if they both exist.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetCustomDeviceProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to retrieve a custom device property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Pointer<PSTR>} CustomPropertyName A registry value name representing a custom property.
     * @param {Integer} Flags A flag value that indicates how the requested information should be returned. The flag can be zero or one of the following:
     * @param {Pointer<UInt32>} PropertyRegDataType A pointer to a variable of type DWORD that receives the data type of the retrieved property. The data type is specified as one of the REG_-prefixed constants that represents registry data types. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives requested property information.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the buffer size, in bytes, that is required to receive the requested information. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetCustomDeviceProperty</b> returns the required size, regardless of whether the <i>PropertyBuffer</i> buffer is large enough to receive the requested information.
     * @returns {Integer} If the operation succeeds, <b>SetupDiGetCustomDeviceProperty</b> returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the <i>PropertyBuffer </i> buffer is not large enough to receive the requested information, <b>SetupDiGetCustomDeviceProperty</b> returns <b>FALSE</b> and a subsequent call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetcustomdevicepropertya
     * @since windows5.1.2600
     */
    static SetupDiGetCustomDevicePropertyA(DeviceInfoSet, DeviceInfoData, CustomPropertyName, Flags, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize) {
        CustomPropertyName := CustomPropertyName is String? StrPtr(CustomPropertyName) : CustomPropertyName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetCustomDevicePropertyA", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", CustomPropertyName, "uint", Flags, "ptr", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupDiGetCustomDeviceProperty function retrieves a specified custom device property from the registry. (Unicode)
     * @remarks
     * <b>SetupDiGetCustomDeviceProperty</b> retrieves device properties that are associated with a single device instance or with all devices matching a certain hardware ID. (For information about hardware IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>).
     * 
     * Vendors can set properties for a device instance by using <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-addreg-directive">INF AddReg directives</a> in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/inf-ddinstall-hw-section">INF DDInstall.HW sections</a> and specifying the <b>HKR</b> registry root.
     * 
     * Only the system can set properties for hardware IDs. The system supplies an "Icon" property for some hardware IDs.
     * 
     * The function first checks to see if the specified property exists for the specified device instance. If so, the property's value is returned. If not, the function checks to see if the property exists for all devices matching the hardware ID of the specified device instance. If so, the property's value is returned. If DICUSTOMDEVPROP_MERGE_MULTISZ is set in <i>Flags</i>, the function returns the property values associated with both the device instance and the hardware ID, if they both exist.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupDiGetCustomDeviceProperty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to retrieve a custom device property.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that specifies the device information element in <i>DeviceInfoSet</i>.
     * @param {Pointer<PWSTR>} CustomPropertyName A registry value name representing a custom property.
     * @param {Integer} Flags A flag value that indicates how the requested information should be returned. The flag can be zero or one of the following:
     * @param {Pointer<UInt32>} PropertyRegDataType A pointer to a variable of type DWORD that receives the data type of the retrieved property. The data type is specified as one of the REG_-prefixed constants that represents registry data types. This parameter is optional and can be <b>NULL</b>.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives requested property information.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer </i> buffer.
     * @param {Pointer<UInt32>} RequiredSize A pointer to a variable of type DWORD that receives the buffer size, in bytes, that is required to receive the requested information. This parameter is optional and can be <b>NULL</b>. If this parameter is specified, <b>SetupDiGetCustomDeviceProperty</b> returns the required size, regardless of whether the <i>PropertyBuffer</i> buffer is large enough to receive the requested information.
     * @returns {Integer} If the operation succeeds, <b>SetupDiGetCustomDeviceProperty</b> returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the <i>PropertyBuffer </i> buffer is not large enough to receive the requested information, <b>SetupDiGetCustomDeviceProperty</b> returns <b>FALSE</b> and a subsequent call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return ERROR_INSUFFICIENT_BUFFER.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdigetcustomdevicepropertyw
     * @since windows5.1.2600
     */
    static SetupDiGetCustomDevicePropertyW(DeviceInfoSet, DeviceInfoData, CustomPropertyName, Flags, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize) {
        CustomPropertyName := CustomPropertyName is String? StrPtr(CustomPropertyName) : CustomPropertyName

        A_LastError := 0

        result := DllCall("SETUPAPI.dll\SetupDiGetCustomDevicePropertyW", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", CustomPropertyName, "uint", Flags, "ptr", PropertyRegDataType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "ptr", RequiredSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetupConfigureWmiFromInfSection function configures the security of the WMI data that is exposed by an INF file when passed to the [DDInstall.WMI] section. (ANSI)
     * @remarks
     * In previous SetupAPI versions, WMI information in INF files is exposed to all users, and access could only be limited by correctly writing binary data to a registry key. Current versions read and process WMI security information provided by the DDInstall section of an INF file. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupConfigureWmiFromInfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle to an open INF file.
     * @param {Pointer<PSTR>} SectionName Name of the section in the INF file that contains WMI security information. This should be in the form of[DDinstall.WMI].
     * @param {Integer} Flags This parameter can be set as follows.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCWMI_CLOBBER_SECURITY"></a><a id="scwmi_clobber_security"></a><dl>
     * <dt><b>SCWMI_CLOBBER_SECURITY</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If and only if this flag is set does the security information passed to this function override any security information set elsewhere in the INF file. If this flag does not exist and no security information exists in the INF file, the security is set. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} This function returns WINSETUPAPI BOOL.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupconfigurewmifrominfsectiona
     * @since windowsserver2003
     */
    static SetupConfigureWmiFromInfSectionA(InfHandle, SectionName, Flags) {
        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        result := DllCall("SETUPAPI.dll\SetupConfigureWmiFromInfSectionA", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "int")
        return result
    }

    /**
     * The SetupConfigureWmiFromInfSection function configures the security of the WMI data that is exposed by an INF file when passed to the [DDInstall.WMI] section. (Unicode)
     * @remarks
     * In previous SetupAPI versions, WMI information in INF files is exposed to all users, and access could only be limited by correctly writing binary data to a registry key. Current versions read and process WMI security information provided by the DDInstall section of an INF file. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The setupapi.h header defines SetupConfigureWmiFromInfSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InfHandle A handle to an open INF file.
     * @param {Pointer<PWSTR>} SectionName Name of the section in the INF file that contains WMI security information. This should be in the form of[DDinstall.WMI].
     * @param {Integer} Flags This parameter can be set as follows.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCWMI_CLOBBER_SECURITY"></a><a id="scwmi_clobber_security"></a><dl>
     * <dt><b>SCWMI_CLOBBER_SECURITY</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If and only if this flag is set does the security information passed to this function override any security information set elsewhere in the INF file. If this flag does not exist and no security information exists in the INF file, the security is set. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} This function returns WINSETUPAPI BOOL.
     * @see https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupconfigurewmifrominfsectionw
     * @since windowsserver2003
     */
    static SetupConfigureWmiFromInfSectionW(InfHandle, SectionName, Flags) {
        SectionName := SectionName is String? StrPtr(SectionName) : SectionName

        result := DllCall("SETUPAPI.dll\SetupConfigureWmiFromInfSectionW", "ptr", InfHandle, "ptr", SectionName, "uint", Flags, "int")
        return result
    }

    /**
     * The CM_Add_Empty_Log_Conf function creates an empty logical configuration, for a specified configuration type and a specified device instance, on the local machine.
     * @remarks
     * Calling <b>CM_Add_Empty_Log_Conf</b> can cause the handles returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a> and <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a> to become invalid. Thus if you want to obtain logical configurations after calling <b>CM_Add_Empty_Log_Conf</b>, your code must call <b>CM_Get_First_Log_Conf</b> again and start at the first configuration.
     * 
     * To remove a logical configuration created by <b>CM_Add_Empty_Log_Conf</b>, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf">CM_Free_Log_Conf</a>.
     * 
     * The handle received in <i>plcLogConf</i> must be explicitly freed by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_handle">CM_Free_Log_Conf_Handle</a>.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Pointer<UIntPtr>} plcLogConf Address of a location to receive the handle to an empty logical configuration.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} Priority Caller-supplied configuration priority value. This must be one of the constant values listed in the following table. The constants are listed in order of priority, from highest to lowest. (For multiple configurations with the same <i>ulFlags</i> value, the system will attempt to use the one with the highest priority first.)
     * 
     * <table>
     * <tr>
     * <th>Priority Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_FORCECONFIG
     * 
     * </td>
     * <td>
     * Result of a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">forced configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_BOOTCONFIG
     * 
     * </td>
     * <td>
     * Result of a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">boot configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_DESIRED
     * 
     * </td>
     * <td>
     * Preferred configuration (better performance).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_NORMAL
     * 
     * </td>
     * <td>
     * Workable configuration (acceptable performance).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_LASTBESTCONFIG
     * 
     * </td>
     * <td>
     * <i>For internal use only.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_SUBOPTIMAL
     * 
     * </td>
     * <td>
     * Not a desirable configuration, but it will work.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_LASTSOFTCONFIG
     * 
     * </td>
     * <td>
     * <i>For internal use only.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_RESTART
     * 
     * </td>
     * <td>
     * The system must be restarted
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_REBOOT
     * 
     * </td>
     * <td>
     * The system must be restarted (same as LCPRI_RESTART).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_POWEROFF
     * 
     * </td>
     * <td>
     * The system must be shut down and powered off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_HARDRECONFIG
     * 
     * </td>
     * <td>
     * A jumper must be changed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_HARDWIRED
     * 
     * </td>
     * <td>
     * The configuration cannot be changed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_IMPOSSIBLE
     * 
     * </td>
     * <td>
     * The configuration cannot exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * LCPRI_DISABLED
     * 
     * </td>
     * <td>
     * Disabled configuration.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} ulFlags Caller-supplied flags that specify the type of the logical configuration. One of the following flags must be specified.
     * 
     * <table>
     * <tr>
     * <th>Configuration Type Flags</th>
     * <th>Definitions</th>
     * </tr>
     * <tr>
     * <td>
     * BASIC_LOG_CONF
     * 
     * </td>
     * <td>
     * Resource descriptors added to this configuration will describe a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">basic configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * FILTERED_LOG_CONF
     * 
     * </td>
     * <td>
     * <i>Do not use.</i> (Only the PnP manager can create a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">filtered configuration</a>.)
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * ALLOC_LOG_CONF
     * 
     * </td>
     * <td>
     * <i>Do not use.</i> (Only the PnP manager can create an <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">allocated configuration</a>.)
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * BOOT_LOG_CONF
     * 
     * </td>
     * <td>
     * Resource descriptors added to this configuration will describe a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">boot configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * FORCED_LOG_CONF
     * 
     * </td>
     * <td>
     * Resource descriptors added to this configuration will describe a <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">forced configuration</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * OVERRIDE_LOG_CONF
     * 
     * </td>
     * <td>
     * Resource descriptors added to this configuration will describe an <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">override configuration</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * One of the following bit flags can be ORed with the configuration type flag.
     * 
     * <table>
     * <tr>
     * <th>Priority Comparison Flags</th>
     * <th>Definitions</th>
     * </tr>
     * <tr>
     * <td>
     * PRIORITY_EQUAL_FIRST
     * 
     * </td>
     * <td>
     * If multiple configurations of the same type (<i>ulFlags</i>) have the same priority (<i>Priority</i>), this configuration is placed at the head of the list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * PRIORITY_EQUAL_LAST
     * 
     * </td>
     * <td>
     * (Default) If multiple configurations of the same type (<i>ulFlags</i>) have the same priority (<i>Priority</i>), this configuration is placed at the tail of the list.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Add_Empty_Log_Conf</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf
     * @since windows5.0
     */
    static CM_Add_Empty_Log_Conf(plcLogConf, dnDevInst, Priority, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Add_Empty_Log_Conf", "ptr", plcLogConf, "uint", dnDevInst, "int", Priority, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_Empty_Log_Conf_Ex function creates an empty logical configuration, for a specified configuration type and a specified device instance, on either the local or a remote machine.
     * @remarks
     * Calling <b>CM_Add_Empty_Log_Conf_Ex</b> can cause the handles returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a> and <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a> to become invalid. Thus if you want to obtain logical configurations after calling <b>CM_Add_Empty_Log_Conf_Ex</b>, your code must call <b>CM_Get_First_Log_Conf_Ex</b> again and start at the first configuration.
     * 
     * To remove a logical configuration created by <b>CM_Add_Empty_Log_Conf_Ex</b>, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_ex">CM_Free_Log_Conf_Ex</a>.
     * 
     * The handle received in <i>plcLogConf</i> must be explicitly freed by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_handle">CM_Free_Log_Conf_Handle</a>.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UIntPtr>} plcLogConf Pointer to a location to receive the handle to an empty logical configuration.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} Priority Caller-supplied configuration priority value. For a list of values, see the <i>Priority</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>.
     * @param {Integer} ulFlags Caller-supplied flags that specify the type of the logical configuration. For a list of flags, see the description <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Add_Empty_Log_Conf_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex
     * @since windows5.0
     */
    static CM_Add_Empty_Log_Conf_Ex(plcLogConf, dnDevInst, Priority, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Add_Empty_Log_Conf_Ex", "ptr", plcLogConf, "uint", dnDevInst, "int", Priority, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Add_ID function appends a specified device ID (if not already present) to a device instance's hardware ID list or compatible ID list.
     * @remarks
     * The <b>CM_Add_ID</b> function can only be used when <i>dnDevInst</i> represents a root-enumerated device. For other devices, the bus driver reports hardware and compatible IDs when enumerating a child device after receiving <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-id">IRP_MN_QUERY_ID</a>.
     * 
     * Each appended device ID is considered less compatible than IDs already existing in the specified list. For information about device IDs, hardware IDs, and compatible IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Pointer<PSTR>} pszID Caller-supplied pointer to a NULL-terminated device ID string.
     * @param {Integer} ulFlags Caller-supplied flag constant that specifies the list onto which the supplied device ID should be appended. The following flag constants are valid.
     * 
     * <table>
     * <tr>
     * <th>Flag Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_COMPATIBLE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's compatible ID list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_HARDWARE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's hardware ID list.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_ida
     */
    static CM_Add_IDA(dnDevInst, pszID, ulFlags) {
        pszID := pszID is String? StrPtr(pszID) : pszID

        result := DllCall("CFGMGR32.dll\CM_Add_IDA", "uint", dnDevInst, "ptr", pszID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_ID function appends a specified device ID (if not already present) to a device instance'shardware ID list or compatible ID list.
     * @remarks
     * The <b>CM_Add_ID</b> function can only be used when <i>dnDevInst</i> represents a root-enumerated device.     For other devices, the bus driver reports hardware and compatible IDs when enumerating a child device after receiving <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-id">IRP_MN_QUERY_ID</a>.
     * 
     * Each appended device ID is considered less compatible than IDs already existing in the specified list. For information about device IDs, hardware IDs, and compatible IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>. 
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Pointer<PWSTR>} pszID Caller-supplied pointer to a NULL-terminated device ID string.
     * @param {Integer} ulFlags Caller-supplied flag constant that specifies the list onto which the supplied device ID should be appended. The following flag constants are valid.
     * 
     * <table>
     * <tr>
     * <th>Flag Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_COMPATIBLE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's compatible ID list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_HARDWARE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's hardware ID list.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_idw
     * @since windows5.0
     */
    static CM_Add_IDW(dnDevInst, pszID, ulFlags) {
        pszID := pszID is String? StrPtr(pszID) : pszID

        result := DllCall("CFGMGR32.dll\CM_Add_IDW", "uint", dnDevInst, "ptr", pszID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_ID_Ex function appends a device ID (if not already present) to a device instance's hardware ID list or compatible ID list, on either the local or a remote machine. (ANSI)
     * @remarks
     * Each appended device ID is considered less compatible than IDs already existing in the specified list. For information about device IDs, hardware IDs, and compatible IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<PSTR>} pszID Caller-supplied pointer to a NULL-terminated device ID string.
     * @param {Integer} ulFlags Caller-supplied flag constant that specifies the list onto which the supplied device ID should be appended. The following flag constants are valid.
     * 
     * <table>
     * <tr>
     * <th>Flag Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_COMPATIBLE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's compatible ID list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_HARDWARE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's hardware ID list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_id_exa
     */
    static CM_Add_ID_ExA(dnDevInst, pszID, ulFlags, hMachine) {
        pszID := pszID is String? StrPtr(pszID) : pszID

        result := DllCall("CFGMGR32.dll\CM_Add_ID_ExA", "uint", dnDevInst, "ptr", pszID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Add_ID_Ex function appends a device ID (if not already present) to a device instance's hardware ID list or compatible ID list, on either the local or a remote machine. (Unicode)
     * @remarks
     * Each appended device ID is considered less compatible than IDs already existing in the specified list. For information about device IDs, hardware IDs, and compatible IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>. 
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by 
     * 
     * <i>hMachine</i>
     * 
     * .
     * @param {Pointer<PWSTR>} pszID Caller-supplied pointer to a NULL-terminated device ID string.
     * @param {Integer} ulFlags Caller-supplied flag constant that specifies the list onto which the supplied device ID should be appended. The following flag constants are valid.
     * 
     * <table>
     * <tr>
     * <th>Flag Constant</th>
     * <th>Definition</th>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_COMPATIBLE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's compatible ID list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * CM_ADD_ID_HARDWARE
     * 
     * </td>
     * <td>
     * The specified device ID should be appended to the specific device instance's hardware ID list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_id_exw
     * @since windows5.0
     */
    static CM_Add_ID_ExW(dnDevInst, pszID, ulFlags, hMachine) {
        pszID := pszID is String? StrPtr(pszID) : pszID

        result := DllCall("CFGMGR32.dll\CM_Add_ID_ExW", "uint", dnDevInst, "ptr", pszID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ullStartValue 
     * @param {Integer} ullEndValue 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_range
     */
    static CM_Add_Range(ullStartValue, ullEndValue, rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Add_Range", "uint", ullStartValue, "uint", ullEndValue, "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_Res_Des function adds a resource descriptor to a logical configuration.
     * @remarks
     * Callers of <b>CM_Add_Res_Des</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des_handle">CM_Free_Res_Des_Handle</a> to deallocate the resource descriptor handle, after it is no longer needed.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * @param {Pointer<UIntPtr>} prdResDes Pointer to a location to receive a handle to the new resource descriptor.
     * @param {Pointer} lcLogConf Caller-supplied handle to the logical configuration to which the resource descriptor should be added. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Integer} ResourceID Caller-supplied resource type identifier, which identifies the type of structure supplied by <i>ResourceData</i>. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Void>} ResourceData Caller-supplied pointer to one of the resource structures listed in the following table.
     * 
     * <table>
     * <tr>
     * <th><i>ResourceID </i>Parameter</th>
     * <th>Resource Structure</th>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_BusNumber</b>
     * 
     * </td>
     * <td>
     * 
     * [BUSNUMBER_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-busnumber_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_ClassSpecific</b>
     * 
     * </td>
     * <td>
     * 
     * [CS_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-cs_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_DevicePrivate</b>
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devprivate-resource">DEVPRIVATE_RESOURCE</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_DMA</b>
     * 
     * </td>
     * <td>
     * 
     * [DMA_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-dma_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_IO</b>
     * 
     * </td>
     * <td>
     * 
     * [IO_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-io_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_IRQ</b>
     * 
     * </td>
     * <td>
     * 
     * [IRQ_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-irq_resource_32)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_Mem</b>
     * 
     * </td>
     * <td>
     * 
     * [MEM_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-mem_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_MfCardConfig</b>
     * 
     * </td>
     * <td>
     * 
     * [MFCARD_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-mfcard_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_PcCardConfig</b>
     * 
     * </td>
     * <td>
     * 
     * [PCCARD_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-pccard_resource)
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8,  <b>CM_Add_Res_Des</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des
     * @since windows5.0
     */
    static CM_Add_Res_Des(prdResDes, lcLogConf, ResourceID, ResourceData, ResourceLen, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Add_Res_Des", "ptr", prdResDes, "ptr", lcLogConf, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Add_Res_Des_Ex function adds a resource descriptor to a logical configuration. The logical configuration can be on either the local or a remote machine.
     * @remarks
     * Callers of <b>CM_Add_Res_Des_Ex</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des_handle">CM_Free_Res_Des_Handle</a> to deallocate the resource descriptor handle, after it is no longer needed.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UIntPtr>} prdResDes Pointer to a location to receive a handle to the new resource descriptor.
     * @param {Pointer} lcLogConf Caller-supplied handle to the logical configuration to which the resource descriptor should be added. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Integer} ResourceID Caller-supplied resource type identifier, which identifies the type of structure supplied by <i>ResourceData</i>. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Void>} ResourceData Caller-supplied pointer to one of the resource structures listed in the following table.
     * 
     * <table>
     * <tr>
     * <th><i>ResourceID </i>Parameter</th>
     * <th>Resource Structure</th>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_BusNumber</b>
     * 
     * </td>
     * <td>
     * 
     * [BUSNUMBER_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-busnumber_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_ClassSpecific</b>
     * 
     * </td>
     * <td>
     * 
     * [CS_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-cs_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_DevicePrivate</b>
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devprivate-resource">DEVPRIVATE_RESOURCE</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_DMA</b>
     * 
     * </td>
     * <td>
     * 
     * [DMA_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-dma_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_IO</b>
     * 
     * </td>
     * <td>
     * 
     * [IO_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-io_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_IRQ</b>
     * 
     * </td>
     * <td>
     * 
     * [IRQ_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-irq_resource_32)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_Mem</b>
     * 
     * </td>
     * <td>
     * 
     * [MEM_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-mem_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_MfCardConfig</b>
     * 
     * </td>
     * <td>
     * 
     * [MFCARD_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-mfcard_resource)
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>ResType_PcCardConfig</b>
     * 
     * </td>
     * <td>
     * 
     * [PCCARD_RESOURCE](/windows/desktop/api/cfgmgr32/ns-cfgmgr32-pccard_resource)
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>, or <b>NULL</b>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Add_Res_Des_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex
     * @since windows5.0
     */
    static CM_Add_Res_Des_Ex(prdResDes, lcLogConf, ResourceID, ResourceData, ResourceLen, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Add_Res_Des_Ex", "ptr", prdResDes, "ptr", lcLogConf, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Connect_Machine function creates a connection to a remote machine. (ANSI)
     * @remarks
     * Callers of <b>CM_Connect_Machine</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_disconnect_machine">CM_Disconnect_Machine</a> to deallocate the machine handle, after it is no longer needed.
     * 
     * Use machine handles obtained with this function only with the <a href="https://docs.microsoft.com/windows/win32/api/cfgmgr32/">PnP configuration manager functions</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<PSTR>} UNCServerName Caller-supplied pointer to a text string representing the UNC name, including the <b>\\</b> prefix, of the system for which a connection will be made. If the pointer is <b>NULL</b>, the local system is used.
     * @param {Pointer<IntPtr>} phMachine Address of a location to receive a machine handle.
     * 
     * <div class="alert"><b>Note</b> Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea
     */
    static CM_Connect_MachineA(UNCServerName, phMachine) {
        UNCServerName := UNCServerName is String? StrPtr(UNCServerName) : UNCServerName

        result := DllCall("CFGMGR32.dll\CM_Connect_MachineA", "ptr", UNCServerName, "ptr", phMachine, "uint")
        return result
    }

    /**
     * The CM_Connect_Machine function creates a connection to a remote machine. (Unicode)
     * @remarks
     * Callers of <b>CM_Connect_Machine</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_disconnect_machine">CM_Disconnect_Machine</a> to deallocate the machine handle, after it is no longer needed.
     * 
     * Use machine handles obtained with this function only with the <a href="https://docs.microsoft.com/windows/win32/api/cfgmgr32/">PnP configuration manager functions</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<PWSTR>} UNCServerName Caller-supplied pointer to a text string representing the UNC name, including the <b>\\</b> prefix, of the system for which a connection will be made. If the pointer is <b>NULL</b>, the local system is used.
     * @param {Pointer<IntPtr>} phMachine Address of a location to receive a machine handle.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew
     * @since windows5.0
     */
    static CM_Connect_MachineW(UNCServerName, phMachine) {
        UNCServerName := UNCServerName is String? StrPtr(UNCServerName) : UNCServerName

        result := DllCall("CFGMGR32.dll\CM_Connect_MachineW", "ptr", UNCServerName, "ptr", phMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pdnDevInst 
     * @param {Pointer<PSTR>} pDeviceID 
     * @param {Integer} dnParent 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_devnodea
     */
    static CM_Create_DevNodeA(pdnDevInst, pDeviceID, dnParent, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Create_DevNodeA", "ptr", pdnDevInst, "ptr", pDeviceID, "uint", dnParent, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pdnDevInst 
     * @param {Pointer<PWSTR>} pDeviceID 
     * @param {Integer} dnParent 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_devnodew
     */
    static CM_Create_DevNodeW(pdnDevInst, pDeviceID, dnParent, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Create_DevNodeW", "ptr", pdnDevInst, "ptr", pDeviceID, "uint", dnParent, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pdnDevInst 
     * @param {Pointer<PSTR>} pDeviceID 
     * @param {Integer} dnParent 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_devnode_exa
     */
    static CM_Create_DevNode_ExA(pdnDevInst, pDeviceID, dnParent, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Create_DevNode_ExA", "ptr", pdnDevInst, "ptr", pDeviceID, "uint", dnParent, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pdnDevInst 
     * @param {Pointer<PWSTR>} pDeviceID 
     * @param {Integer} dnParent 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_devnode_exw
     */
    static CM_Create_DevNode_ExW(pdnDevInst, pDeviceID, dnParent, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Create_DevNode_ExW", "ptr", pdnDevInst, "ptr", pDeviceID, "uint", dnParent, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UIntPtr>} prlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_create_range_list
     */
    static CM_Create_Range_List(prlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Create_Range_List", "ptr", prlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Delete_Class_Key function removes the specified installed device class from the system.
     * @param {Pointer<Guid>} ClassGuid Pointer to the GUID of the device class to remove.
     * @param {Integer} ulFlags Delete class key flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_class_key
     * @since windows5.0
     */
    static CM_Delete_Class_Key(ClassGuid, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Delete_Class_Key", "ptr", ClassGuid, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_class_key_ex
     */
    static CM_Delete_Class_Key_Ex(ClassGuid, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Delete_Class_Key_Ex", "ptr", ClassGuid, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Delete_DevNode_Key function deletes the specified user-accessible registry keys that are associated with a device.
     * @param {Integer} dnDevNode Device instance handle that is bound to the local machine.
     * @param {Integer} ulHardwareProfile The hardware profile to delete if <i>ulFlags</i> includes CM_REGISTRY_CONFIG. If this value is zero, the key for the current hardware profile is deleted. If this value is 0xFFFFFFFF, the registry keys for all hardware profiles are deleted.
     * @param {Integer} ulFlags Delete device node key flags. Indicates the scope and type of registry storage key to delete.  Can be a combination of the following flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_devnode_key
     * @since windows5.0
     */
    static CM_Delete_DevNode_Key(dnDevNode, ulHardwareProfile, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Delete_DevNode_Key", "uint", dnDevNode, "uint", ulHardwareProfile, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevNode 
     * @param {Integer} ulHardwareProfile 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_devnode_key_ex
     */
    static CM_Delete_DevNode_Key_Ex(dnDevNode, ulHardwareProfile, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Delete_DevNode_Key_Ex", "uint", dnDevNode, "uint", ulHardwareProfile, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ullStartValue 
     * @param {Integer} ullEndValue 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_range
     */
    static CM_Delete_Range(ullStartValue, ullEndValue, rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Delete_Range", "uint", ullStartValue, "uint", ullEndValue, "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Pointer<Void>} ResourceData 
     * @param {Integer} ResourceLen 
     * @param {Pointer<Int32>} pbConflictDetected 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_detect_resource_conflict
     */
    static CM_Detect_Resource_Conflict(dnDevInst, ResourceID, ResourceData, ResourceLen, pbConflictDetected, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Detect_Resource_Conflict", "uint", dnDevInst, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "ptr", pbConflictDetected, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Pointer<Void>} ResourceData 
     * @param {Integer} ResourceLen 
     * @param {Pointer<Int32>} pbConflictDetected 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_detect_resource_conflict_ex
     */
    static CM_Detect_Resource_Conflict_Ex(dnDevInst, ResourceID, ResourceData, ResourceLen, pbConflictDetected, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Detect_Resource_Conflict_Ex", "uint", dnDevInst, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "ptr", pbConflictDetected, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Disable_DevNode function disables a device.
     * @remarks
     * By default, <b>CM_Disable_DevNode</b> disables a device at one time, but after reboot the device is enabled again. Starting in Windows10, you can specify the <b>CM_DISABLE_PERSIST</b> flag to disable the device across reboots.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Disable flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_disable_devnode
     * @since windows5.0
     */
    static CM_Disable_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Disable_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_disable_devnode_ex
     */
    static CM_Disable_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Disable_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Disconnect_Machine function removes a connection to a remote machine.
     * @remarks
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_disconnect_machine
     * @since windows5.0
     */
    static CM_Disconnect_Machine(hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Disconnect_Machine", "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlhOld 
     * @param {Pointer} rlhNew 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_dup_range_list
     */
    static CM_Dup_Range_List(rlhOld, rlhNew, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Dup_Range_List", "ptr", rlhOld, "ptr", rlhNew, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Enable_DevNode function enables a device.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enable_devnode
     * @since windows5.0
     */
    static CM_Enable_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Enable_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enable_devnode_ex
     */
    static CM_Enable_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Enable_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Classes function, when called repeatedly, enumerates the local machine's installed device classes by supplying each class's GUID.
     * @remarks
     * To enumerate the local machine's device classes, call <b>CM_Enumerate_Classes</b> repeatedly, starting with a <i>ulClassIndex</i> value of zero and incrementing the index value with each subsequent call until the function returns CR_NO_SUCH_VALUE. Some index values might represent list entries containing invalid class data, in which case the function returns CR_INVALID_DATA. This return value can be ignored.
     * 
     * The class GUIDs obtained from this function can be used as input to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/using-device-installation-functions#ddk-update-driver-function-dg">device installation functions</a>.
     * 
     * Beginning with Windows8 and later operating systems, callers can use the <b>ulFlags</b> member to specify which device classes CM_Enumerate_Classes should return. Prior to Windows8, CM_Enumerate_Classes returned only device setup classes.
     * @param {Integer} ulClassIndex Caller-supplied index into the machine's list of device classes. For more information, see the <b>Remarks</b> section.
     * @param {Pointer<Guid>} ClassGuid Caller-supplied address of a GUID structure (described in the Microsoft Windows SDK) to receive a device class's GUID.
     * @param {Integer} ulFlags Beginning with Windows8, callers can specify the following flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enumerate_classes
     * @since windows5.0
     */
    static CM_Enumerate_Classes(ulClassIndex, ClassGuid, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Enumerate_Classes", "uint", ulClassIndex, "ptr", ClassGuid, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Classes_Ex function, when called repeatedly, enumerates a local or a remote machine's installed device classes, by supplying each class's GUID.
     * @remarks
     * To enumerate the local or a remote machine's device classes, call <b>CM_Enumerate_Classes_Ex</b> repeatedly, starting with a <i>ulClassIndex</i> index value of zero and incrementing the index value with each subsequent call until the function returns CR_NO_SUCH_VALUE. Some index values might represent list entries containing invalid class data, in which case the function returns CR_INVALID_DATA. This return value can be ignored.
     * 
     * The class GUIDs obtained from this function can be used as input to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/using-device-installation-functions#ddk-update-driver-function-dg">device installation functions</a>.
     * 
     * Beginning with Windows8 and later operating systems, callers can use the <b>ulFlags</b> member to specify which device classes CM_Enumerate_Classes_Ex should return. Prior to Windows8, CM_Enumerate_Classes_Ex returned only device setup classes.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} ulClassIndex Caller-supplied index into the machine's list of device classes. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<Guid>} ClassGuid Caller-supplied address of a GUID structure (described in the Microsoft Windows SDK) to receive a device class's GUID.
     * @param {Integer} ulFlags Beginning with Windows8, callers can specify the following flags:
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enumerate_classes_ex
     * @since windows5.0
     */
    static CM_Enumerate_Classes_Ex(ulClassIndex, ClassGuid, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Enumerate_Classes_Ex", "uint", ulClassIndex, "ptr", ClassGuid, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Enumerators function enumerates the local machine's device enumerators by supplying each enumerator's name. (ANSI)
     * @remarks
     * To enumerate the local machine's device enumerators, call <b>CM_Enumerate_Enumerators</b> repeatedly, starting with a <i>ulEnumIndex</i> index value of zero. and incrementing the index value with each subsequent call until the function returns CR_NO_SUCH_VALUE.
     * 
     * After enumerator names have been obtained, the names can be used as input to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @param {Integer} ulEnumIndex Caller-supplied index into the machine's list of device enumerators. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<PSTR>} Buffer Address of a buffer to receive an enumerator name. This buffer should be MAX_DEVICE_ID_LEN-sized (or, set <i>Buffer</i> to zero and obtain the actual name length in the location referenced by <i>puLength</i>).
     * @param {Pointer<UInt32>} pulLength Caller-supplied address of a location to hold the buffer size. The caller supplies the length of the buffer pointed to by <i>Buffer</i>. The function replaces this value with the actual size of the enumerator's name string. If the caller-supplied buffer length is too small, the function supplies the required buffer size and returns CR_BUFFER_SMALL.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enumerate_enumeratorsa
     */
    static CM_Enumerate_EnumeratorsA(ulEnumIndex, Buffer, pulLength, ulFlags) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Enumerate_EnumeratorsA", "uint", ulEnumIndex, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Enumerators function enumerates the local machine's device enumerators by supplying each enumerator's name. (Unicode)
     * @remarks
     * To enumerate the local machine's device enumerators, call <b>CM_Enumerate_Enumerators</b> repeatedly, starting with a <i>ulEnumIndex</i> index value of zero. and incrementing the index value with each subsequent call until the function returns CR_NO_SUCH_VALUE.
     * 
     * After enumerator names have been obtained, the names can be used as input to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @param {Integer} ulEnumIndex Caller-supplied index into the machine's list of device enumerators. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<PWSTR>} Buffer Address of a buffer to receive an enumerator name. This buffer should be MAX_DEVICE_ID_LEN-sized (or, set <i>Buffer</i> to zero and obtain the actual name length in the location referenced by <i>puLength</i>).
     * @param {Pointer<UInt32>} pulLength Caller-supplied address of a location to hold the buffer size. The caller supplies the length of the buffer pointed to by <i>Buffer</i>. The function replaces this value with the actual size of the enumerator's name string. If the caller-supplied buffer length is too small, the function supplies the required buffer size and returns CR_BUFFER_SMALL.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enumerate_enumeratorsw
     * @since windows5.0
     */
    static CM_Enumerate_EnumeratorsW(ulEnumIndex, Buffer, pulLength, ulFlags) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Enumerate_EnumeratorsW", "uint", ulEnumIndex, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Enumerators_Ex function enumerates a local or a remote machine's device enumerators, by supplying each enumerator's name. (ANSI)
     * @remarks
     * To enumerate the local or a remote machine's device enumerators, call <b>CM_Enumerate_Enumerators_Ex</b> repeatedly, starting with a <i>ulEnumIndex</i> index value of zero, and incrementing the index value with each subsequent call until the function returns CR_NO_SUCH_VALUE.
     * 
     * After enumerator names have been obtained, the names can be used as input to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} ulEnumIndex Caller-supplied index into the machine's list of device enumerators. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<PSTR>} Buffer Address of a buffer to receive an enumerator name. This buffer should be MAX_DEVICE_ID_LEN-sized (or, set <i>Buffer</i> to zero and obtain the actual name length in the location referenced by <b>puLength</b>).
     * @param {Pointer<UInt32>} pulLength Caller-supplied address of a location to hold the buffer size. The caller supplies the length of the buffer pointed to by <i>Buffer</i>. The function replaces this value with the actual size of the enumerator's name string. If the caller-supplied buffer length is too small, the function supplies the required buffer size and returns CR_BUFFER_SMALL.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enumerate_enumerators_exa
     */
    static CM_Enumerate_Enumerators_ExA(ulEnumIndex, Buffer, pulLength, ulFlags, hMachine) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Enumerate_Enumerators_ExA", "uint", ulEnumIndex, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Enumerate_Enumerators_Ex function enumerates a local or a remote machine's device enumerators, by supplying each enumerator's name. (Unicode)
     * @remarks
     * To enumerate the local or a remote machine's device enumerators, call <b>CM_Enumerate_Enumerators_Ex</b> repeatedly, starting with a <i>ulEnumIndex</i> index value of zero, and incrementing the index value with each subsequent call until the function returns CR_NO_SUCH_VALUE.
     * 
     * After enumerator names have been obtained, the names can be used as input to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} ulEnumIndex Caller-supplied index into the machine's list of device enumerators. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer<PWSTR>} Buffer Address of a buffer to receive an enumerator name. This buffer should be MAX_DEVICE_ID_LEN-sized (or, set <i>Buffer</i> to zero and obtain the actual name length in the location referenced by <b>puLength</b>).
     * @param {Pointer<UInt32>} pulLength Caller-supplied address of a location to hold the buffer size. The caller supplies the length of the buffer pointed to by <i>Buffer</i>. The function replaces this value with the actual size of the enumerator's name string. If the caller-supplied buffer length is too small, the function supplies the required buffer size and returns CR_BUFFER_SMALL.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enumerate_enumerators_exw
     * @since windows5.0
     */
    static CM_Enumerate_Enumerators_ExW(ulEnumIndex, Buffer, pulLength, ulFlags, hMachine) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Enumerate_Enumerators_ExW", "uint", ulEnumIndex, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt64>} pullStart 
     * @param {Integer} ullStart 
     * @param {Integer} ulLength 
     * @param {Integer} ullAlignment 
     * @param {Integer} ullEnd 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_find_range
     */
    static CM_Find_Range(pullStart, ullStart, ulLength, ullAlignment, ullEnd, rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Find_Range", "ptr", pullStart, "uint", ullStart, "uint", ulLength, "uint", ullAlignment, "uint", ullEnd, "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlh 
     * @param {Pointer<UInt64>} pullStart 
     * @param {Pointer<UInt64>} pullEnd 
     * @param {Pointer<UIntPtr>} preElement 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_first_range
     */
    static CM_First_Range(rlh, pullStart, pullEnd, preElement, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_First_Range", "ptr", rlh, "ptr", pullStart, "ptr", pullEnd, "ptr", preElement, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Free_Log_Conf function removes a logical configuration and all associated resource descriptors from the local machine.
     * @remarks
     * Calling <b>CM_Free_Log_Conf</b> can cause the handles returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a> and <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a> to become invalid. Thus if you want to obtain logical configurations after calling <b>CM_Free_Log_Conf</b>, your code must call <b>CM_Get_First_Log_Conf</b> again and start at the first configuration.
     * 
     * Note that calling <b>CM_Free_Log_Conf</b> frees the configuration, but not the configuration's handle. To free the handle, call <b>CM_Free_Log_Conf_Handle</b>.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * @param {Pointer} lcLogConfToBeFreed Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Free_Log_Conf</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf
     * @since windows5.0
     */
    static CM_Free_Log_Conf(lcLogConfToBeFreed, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Free_Log_Conf", "ptr", lcLogConfToBeFreed, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Free_Log_Conf_Ex function removes a logical configuration and all associated resource descriptors from either a local or a remote machine.
     * @remarks
     * Calling <b>CM_Free_Log_Conf_Ex</b> can cause the handles returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a> and <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a> to become invalid. Thus if you want to obtain logical configurations after calling <b>CM_Free_Log_Conf_Ex</b>, your code must call <b>CM_Get_First_Log_Conf_Ex</b> again and start at the first configuration.
     * 
     * Note that calling <b>CM_Free_Log_Conf_Ex</b> frees the configuration, but not the configuration's handle. To free the handle, call <b>CM_Free_Log_Conf_Handle_Ex</b>.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer} lcLogConfToBeFreed Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Free_Log_Conf_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_ex
     * @since windows5.0
     */
    static CM_Free_Log_Conf_Ex(lcLogConfToBeFreed, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Free_Log_Conf_Ex", "ptr", lcLogConfToBeFreed, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Free_Log_Conf_Handle function invalidates a logical configuration handle and frees its associated memory allocation.
     * @remarks
     * Each time your code calls one of the functions listed under the description of <i>lcLogConf</i>, it must subsequently call <b>CM_Free_Log_Conf_Handle</b>.
     * @param {Pointer} lcLogConf Caller-supplied logical configuration handle. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_handle
     * @since windows5.0
     */
    static CM_Free_Log_Conf_Handle(lcLogConf) {
        result := DllCall("CFGMGR32.dll\CM_Free_Log_Conf_Handle", "ptr", lcLogConf, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_range_list
     */
    static CM_Free_Range_List(rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Free_Range_List", "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Free_Res_Des function removes a resource descriptor from a logical configuration on the local machine.
     * @remarks
     * Resource descriptors for each configuration are stored in an array. If you specify an address for <i>prdResDes</i>, then <b>CM_Free_Res_Des</b> returns a handle to the resource descriptor that was previous, in the array, to the one removed. If the handle specified by <i>rdResDes</i> represents the resource descriptor located first in the array, then <i>prdResDes</i> receives a handle to the logical configuration.
     * 
     * Note that calling <b>CM_Free_Res_Des</b> frees the resource descriptor, but not the descriptor's handle. To free the handle, call <b>CM_Free_Res_Des_Handle</b>.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * @param {Pointer<UIntPtr>} prdResDes Caller-supplied location to receive a handle to the configuration's previous resource descriptor. This parameter can be <b>NULL</b>. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer} rdResDes Caller-supplied handle to the resource descriptor to be removed. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Free_Res_Des</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des
     * @since windows5.0
     */
    static CM_Free_Res_Des(prdResDes, rdResDes, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Free_Res_Des", "ptr", prdResDes, "ptr", rdResDes, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Free_Res_Des_Ex function removes a resource descriptor from a logical configuration on either a local or a remote machine.
     * @remarks
     * Resource descriptors for each configuration are stored in an array. If you specify an address for <i>prdResDes</i>, then <b>CM_Free_Res_Des</b> returns a handle to the resource descriptor that was previous, in the array, to the one removed. If the handle specified by <i>rdResDes</i> represents the resource descriptor located first in the array, then <i>prdResDes</i> receives a handle to the logical configuration.
     * 
     * Note that calling <b>CM_Free_Res_Des_Ex</b> frees the resource descriptor, but not the descriptor's handle. To free the handle, call <b>CM_Free_Res_Des_Handle_Ex</b>.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UIntPtr>} prdResDes Caller-supplied location to receive a handle to the configuration's previous resource descriptor. This parameter can be <b>NULL</b>. For more information, see the following <b>Remarks</b> section.
     * @param {Pointer} rdResDes Caller-supplied handle to the resource descriptor to be removed. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Free_Res_Des_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des_ex
     * @since windows5.0
     */
    static CM_Free_Res_Des_Ex(prdResDes, rdResDes, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Free_Res_Des_Ex", "ptr", prdResDes, "ptr", rdResDes, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Free_Res_Des_Handle function invalidates a resource description handle and frees its associated memory allocation.
     * @remarks
     * Each time your code calls one of the functions listed under the description of <i>rdResDes</i>, it must subsequently call <b>CM_Free_Res_Des_Handle</b>.
     * @param {Pointer} rdResDes Caller-supplied resource descriptor handle to be freed. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des_handle
     * @since windows5.0
     */
    static CM_Free_Res_Des_Handle(rdResDes) {
        result := DllCall("CFGMGR32.dll\CM_Free_Res_Des_Handle", "ptr", rdResDes, "uint")
        return result
    }

    /**
     * The CM_Get_Child function is used to retrieve a device instance handle to the first child node of a specified device node (devnode) in the local machine's device tree.
     * @remarks
     * To enumerate all children of a devnode in the local machine's device tree, first call <b>CM_Get_Child</b> to obtain a device instance handle to the first child node, then call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_sibling">CM_Get_Sibling</a> to obtain handles for the rest of the children.
     * 
     * <b>Using Device Instance Handles</b>
     * 
     * Device instance handle that you use with <a href="https://docs.microsoft.com/windows/win32/api/cfgmgr32/">PnP configuration manager functions</a> are bound to machine handles, as follows:
     * 
     * <ul>
     * <li>
     * All local device instance handles are bound to a NULL-valued local machine handle.
     * 
     * </li>
     * <li>
     * If you use a remote machine handle to obtain a device instance handle, the resulting remote device instance handle is bound to the remote machine handle.
     * 
     * </li>
     * <li>
     * A device instance handle can be used only with the machine handle to which it is bound. 
     * 
     * </li>
     * <li>
     * A device instance handle can be used with another device instance handle only if both device instance handles are bound to the same machine handle.
     * 
     * </li>
     * </ul>
     * To obtain a device instance handle that is bound to the local machine, do one of the following.
     * 
     * <ul>
     * <li>
     * Use one of the following functions that retrieve only local device instance handles: <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnodea">CM_Locate_DevNode</a>, <b>CM_Get_Child</b>, <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_parent">CM_Get_Parent</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_sibling">CM_Get_Sibling</a>.
     * 
     * </li>
     * <li>
     * Use one of the following functions, which retrieves local and remote device instance handles, to retrieve a local device instance handle: <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnode_exw">CM_Locate_DevNode_Ex</a>, <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>, <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_parent_ex">CM_Get_Parent_Ex</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_sibling_ex">CM_Get_Sibling_Ex</a>.
     * 
     * </li>
     * </ul>
     * You can also use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/using-device-installation-functions#ddk-update-driver-function-dg">device installation functions</a> to obtain local device instance handles from a device information set that is bound to the local machine. Do the following steps: 
     * 
     * <ol>
     * <li>
     * Obtain a device information set that is bound to the local machine. (A device instance handle obtained from a device information set is bound to the machine handle to which the device information set is bound. You obtain the machine handle for a device information set from the <b>RemoteMachineHandle</b> member of its <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure. For a local device information set that is bound to the local machine, the value of <b>RemoteMachineHandle</b> is <b>NULL</b>. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila">SetupDiGetDeviceInfoListDetail</a> to obtain an SP_DEVINFO_LIST_DETAIL_DATA structure.)
     * 
     * </li>
     * <li>
     * Obtain an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for a device instance in the device information set.
     * 
     * </li>
     * <li>
     * Obtain the device instance handle for the device instance from the <b>DevInst</b> member of the SP_DEVINFO_DATA structure.
     * 
     * </li>
     * </ol>
     * @param {Pointer<UInt32>} pdnDevInst Caller-supplied pointer to the device instance handle to the child node that this function retrieves. The retrieved handle is bound to the local machine. See the <b>Remarks</b> section.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_child
     * @since windows5.0
     */
    static CM_Get_Child(pdnDevInst, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Child", "ptr", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Child_Ex function is used to retrieve a device instance handle to the first child node of a specified device node (devnode) in a local or a remote machine's device tree.
     * @remarks
     * To enumerate all children of a devnode in a local or a remote machine's device tree, first call <b>CM_Get_Child_Ex</b> to obtain a handle to the first child node, then call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_sibling_ex">CM_Get_Sibling_Ex</a> to obtain handles for the rest of the children.
     * 
     * <b>Using Device Instance Handles</b>
     * 
     * Device instance handle that you use with <a href="https://docs.microsoft.com/windows/win32/api/cfgmgr32/">PnP configuration manager functions</a> are bound to machine handles, as follows:
     * 
     * <ul>
     * <li>
     * All local device instance handles are bound to a NULL-valued local machine handle.
     * 
     * </li>
     * <li>
     * If you use a remote machine handle to obtain a device instance handle, the resulting remote device instance handle is bound to the remote machine handle.
     * 
     * </li>
     * <li>
     * A device instance handle can be used only with the machine handle to which it is bound. 
     * 
     * </li>
     * <li>
     * A device instance handle can be used with another device instance handle only if both device instance handles are bound to the same machine handle.
     * 
     * </li>
     * </ul>
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a> to obtain a remote machine handle for use with remote device instance handles.
     * 
     * To obtain a local or a remote device instance handle, do one of the following. 
     * 
     * <ul>
     * <li>
     * Use one of the following functions to retrieve a device instance handle bound to the local machine: <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnodea">CM_Locate_DevNode</a>, <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>, <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_parent">CM_Get_Parent</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_sibling">CM_Get_Sibling</a>.
     * 
     * </li>
     * <li>
     * Use one of the following functions to retrieve a device instance handle bound to a local or a remote machine: <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnode_exw">CM_Locate_DevNode_Ex</a>, <b>CM_Get_Child_Ex</b>, <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_parent_ex">CM_Get_Parent_Ex</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_sibling_ex">CM_Get_Sibling_Ex</a>.
     * 
     * </li>
     * </ul>
     * You can also use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/using-device-installation-functions#ddk-update-driver-function-dg">device installation functions</a> to obtain device instance handles. Do the following steps: 
     * 
     * <ol>
     * <li>
     * Obtain a device information set. 
     * 
     * </li>
     * <li>
     * Obtain an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for a device instance in the device information set.
     * 
     * </li>
     * <li>
     * Obtain the device instance handle for the device instance from the <b>DevInst</b> member of the SP_DEVINFO_DATA structure.
     * 
     * </li>
     * <li>
     * Obtain the machine handle to which the device instance handle is bound. A device instance handle obtained from a device information set is bound to the machine handle to which the device information set is bound. You obtain the machine handle for a device information set from the <b>RemoteMachineHandle</b> member of its <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure. (Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila">SetupDiGetDeviceInfoListDetail</a> to obtain an SP_DEVINFO_LIST_DETAIL_DATA structure.)
     * 
     * </li>
     * </ol>
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pdnDevInst Caller-supplied pointer to the device instance handle to the child node that this function retrieves. The retrieved handle is bound to the machine handle supplied by <i>hMachine</i>. See the <b>Remarks</b> section.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex
     * @since windows5.0
     */
    static CM_Get_Child_Ex(pdnDevInst, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Child_Ex", "ptr", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PSTR>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_namea
     */
    static CM_Get_Class_NameA(ClassGuid, Buffer, pulLength, ulFlags) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Class_NameA", "ptr", ClassGuid, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PWSTR>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_namew
     */
    static CM_Get_Class_NameW(ClassGuid, Buffer, pulLength, ulFlags) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Class_NameW", "ptr", ClassGuid, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PSTR>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_name_exa
     */
    static CM_Get_Class_Name_ExA(ClassGuid, Buffer, pulLength, ulFlags, hMachine) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Name_ExA", "ptr", ClassGuid, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PWSTR>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_name_exw
     */
    static CM_Get_Class_Name_ExW(ClassGuid, Buffer, pulLength, ulFlags, hMachine) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Name_ExW", "ptr", ClassGuid, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PSTR>} pszKeyName 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_key_namea
     */
    static CM_Get_Class_Key_NameA(ClassGuid, pszKeyName, pulLength, ulFlags) {
        pszKeyName := pszKeyName is String? StrPtr(pszKeyName) : pszKeyName

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Key_NameA", "ptr", ClassGuid, "ptr", pszKeyName, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PWSTR>} pszKeyName 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_key_namew
     */
    static CM_Get_Class_Key_NameW(ClassGuid, pszKeyName, pulLength, ulFlags) {
        pszKeyName := pszKeyName is String? StrPtr(pszKeyName) : pszKeyName

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Key_NameW", "ptr", ClassGuid, "ptr", pszKeyName, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PSTR>} pszKeyName 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_key_name_exa
     */
    static CM_Get_Class_Key_Name_ExA(ClassGuid, pszKeyName, pulLength, ulFlags, hMachine) {
        pszKeyName := pszKeyName is String? StrPtr(pszKeyName) : pszKeyName

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Key_Name_ExA", "ptr", ClassGuid, "ptr", pszKeyName, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PWSTR>} pszKeyName 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_key_name_exw
     */
    static CM_Get_Class_Key_Name_ExW(ClassGuid, pszKeyName, pulLength, ulFlags, hMachine) {
        pszKeyName := pszKeyName is String? StrPtr(pszKeyName) : pszKeyName

        result := DllCall("CFGMGR32.dll\CM_Get_Class_Key_Name_ExW", "ptr", ClassGuid, "ptr", pszKeyName, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Depth function is used to obtain the depth of a specified device node (devnode) within the local machine's device tree.
     * @remarks
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Pointer<UInt32>} pulDepth Caller-supplied address of a location to receive a depth value, where zero represents the device tree's root node, one represents the root node's children, and so on.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_depth
     * @since windows5.0
     */
    static CM_Get_Depth(pulDepth, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Depth", "ptr", pulDepth, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Depth_Ex function is used to obtain the depth of a specified device node (devnode) within a local or a remote machine's device tree.
     * @remarks
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pulDepth Caller-supplied address of a location to receive a depth value, where zero represents the device tree's root node, one represents the root node's children, and so on.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_depth_ex
     * @since windows5.0
     */
    static CM_Get_Depth_Ex(pulDepth, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Depth_Ex", "ptr", pulDepth, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID function retrieves the device instance ID for a specified device instance on the local machine. (ANSI)
     * @remarks
     * The function appends a NULL terminator to the supplied device instance ID string, unless the buffer is too small to hold the string. In this case, the function supplies as much of the identifier string as will fit into the buffer, and then returns CR_BUFFER_SMALL. 
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Pointer<PSTR>} Buffer Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size">CM_Get_Device_ID_Size</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_ida
     */
    static CM_Get_Device_IDA(dnDevInst, Buffer, BufferLen, ulFlags) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_IDA", "uint", dnDevInst, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID function retrieves the device instance ID for a specified device instance on the local machine. (Unicode)
     * @remarks
     * The function appends a NULL terminator to the supplied device instance ID string, unless the buffer is too small to hold the string. In this case, the function supplies as much of the identifier string as will fit into the buffer, and then returns CR_BUFFER_SMALL. 
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Pointer<PWSTR>} Buffer Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size">CM_Get_Device_ID_Size</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_idw
     * @since windows5.0
     */
    static CM_Get_Device_IDW(dnDevInst, Buffer, BufferLen, ulFlags) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_IDW", "uint", dnDevInst, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_Ex function retrieves the device instance ID for a specified device instance on a local or a remote machine. (ANSI)
     * @remarks
     * The function appends a NULL terminator to the supplied <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> string, unless the buffer is too small to hold the string. In this case, the function supplies as much of the identifier string as will fit into the buffer, and then returns CR_BUFFER_SMALL.
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<PSTR>} Buffer Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size_ex">CM_Get_Device_ID_Size_Ex</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_exa
     */
    static CM_Get_Device_ID_ExA(dnDevInst, Buffer, BufferLen, ulFlags, hMachine) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_ExA", "uint", dnDevInst, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_Ex function retrieves the device instance ID for a specified device instance on a local or a remote machine. (Unicode)
     * @remarks
     * The function appends a NULL terminator to the supplied <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> string, unless the buffer is too small to hold the string. In this case, the function supplies as much of the identifier string as will fit into the buffer, and then returns CR_BUFFER_SMALL.
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<PWSTR>} Buffer Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size_ex">CM_Get_Device_ID_Size_Ex</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_exw
     * @since windows5.0
     */
    static CM_Get_Device_ID_ExW(dnDevInst, Buffer, BufferLen, ulFlags, hMachine) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_ExW", "uint", dnDevInst, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List function retrieves a list of device instance IDs for the local computer's device instances. (ANSI)
     * @remarks
     * Starting with Windows 7, a device that supports multiple transport paths for packet-based data is referred to as a <i>composite </i> device and is represented by a <i>composite </i><a href="https://docs.microsoft.com/windows-hardware/drivers/">devnode</a>. A composite devnode logically represents the composite device to the user and applications as a single device, even though the composite devnode can have multiple paths to the physical device. 
     * 
     * Each active transport path to the physical device is represented by a transport devnode and is referred to as a <i>transport relation</i> for the composite device.
     * 
     * The composite devnode (but not the related transport devnodes) exposes device interfaces to applications and the system. When an application uses these public device interfaces, the composite device routes the packet-based data to one or more of these transport devnodes, which then transport the data to the physical device.
     * 
     * For example, if a physical cell phone is simultaneously connected to the computer on the USB and the Bluetooth buses, each bus enumerates a child transport devnode on that bus to represent the device's physical connection. 
     * 
     * In this case, if you set the CM_GETIDLIST_FILTER_TRANSPORTRELATIONS flags in <i>ulFlags</i> and specify the device instance ID of the cell phone's composite devnode in <i>pszFilter</i>, the function returns the device instance IDs for the two transport devnodes in the <i>Buffer</i> parameter.
     * 
     * For more information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_Device_ID_List as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pszFilter Caller-supplied pointer to a character string that is either set to a subset of the computer's device instance identifiers (IDs), or to <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Pointer<PSTR>} Buffer Address of a buffer to receive a set of NULL-terminated device instance identifier strings. The end of the set is terminated by an extra <b>NULL</b>. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_sizea">CM_Get_Device_ID_List_Size</a>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags One of the following caller-supplied bit flags that specifies search filters:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista
     * @since windows5.0
     */
    static CM_Get_Device_ID_ListA(pszFilter, Buffer, BufferLen, ulFlags) {
        pszFilter := pszFilter is String? StrPtr(pszFilter) : pszFilter
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_ListA", "ptr", pszFilter, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List function retrieves a list of device instance IDs for the local computer's device instances. (Unicode)
     * @remarks
     * Starting with Windows 7, a device that supports multiple transport paths for packet-based data is referred to as a <i>composite </i> device and is represented by a <i>composite </i><a href="https://docs.microsoft.com/windows-hardware/drivers/">devnode</a>. A composite devnode logically represents the composite device to the user and applications as a single device, even though the composite devnode can have multiple paths to the physical device. 
     * 
     * Each active transport path to the physical device is represented by a transport devnode and is referred to as a <i>transport relation</i> for the composite device.
     * 
     * The composite devnode (but not the related transport devnodes) exposes device interfaces to applications and the system. When an application uses these public device interfaces, the composite device routes the packet-based data to one or more of these transport devnodes, which then transport the data to the physical device.
     * 
     * For example, if a physical cell phone is simultaneously connected to the computer on the USB and the Bluetooth buses, each bus enumerates a child transport devnode on that bus to represent the device's physical connection. 
     * 
     * In this case, if you set the CM_GETIDLIST_FILTER_TRANSPORTRELATIONS flags in <i>ulFlags</i> and specify the device instance ID of the cell phone's composite devnode in <i>pszFilter</i>, the function returns the device instance IDs for the two transport devnodes in the <i>Buffer</i> parameter.
     * 
     * For more information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_Device_ID_List as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pszFilter Caller-supplied pointer to a character string that is either set to a subset of the computer's device instance identifiers (IDs), or to <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Pointer<PWSTR>} Buffer Address of a buffer to receive a set of NULL-terminated device instance identifier strings. The end of the set is terminated by an extra <b>NULL</b>. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_sizea">CM_Get_Device_ID_List_Size</a>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags One of the following caller-supplied bit flags that specifies search filters:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_listw
     * @since windows5.0
     */
    static CM_Get_Device_ID_ListW(pszFilter, Buffer, BufferLen, ulFlags) {
        pszFilter := pszFilter is String? StrPtr(pszFilter) : pszFilter
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_ListW", "ptr", pszFilter, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Ex function retrieves a list of device instance IDs for the device instances on a local or a remote machine. (ANSI)
     * @remarks
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<PSTR>} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Pointer<PSTR>} Buffer Address of a buffer to receive a set of NULL-terminated device instance identifier strings. The end of the set is terminated by an extra <b>NULL</b>. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_size_exa">CM_Get_Device_ID_List_Size_Ex</a>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exa
     */
    static CM_Get_Device_ID_List_ExA(pszFilter, Buffer, BufferLen, ulFlags, hMachine) {
        pszFilter := pszFilter is String? StrPtr(pszFilter) : pszFilter
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_ExA", "ptr", pszFilter, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Ex function retrieves a list of device instance IDs for the device instances on a local or a remote machine. (Unicode)
     * @remarks
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<PWSTR>} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Pointer<PWSTR>} Buffer Address of a buffer to receive a set of NULL-terminated device instance identifier strings. The end of the set is terminated by an extra <b>NULL</b>. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_size_exw">CM_Get_Device_ID_List_Size_Ex</a>.
     * @param {Integer} BufferLen Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exw
     * @since windows5.0
     */
    static CM_Get_Device_ID_List_ExW(pszFilter, Buffer, BufferLen, ulFlags, hMachine) {
        pszFilter := pszFilter is String? StrPtr(pszFilter) : pszFilter
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_ExW", "ptr", pszFilter, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Size function retrieves the buffer size required to hold a list of device instance IDs for the local machine's device instances. (ANSI)
     * @remarks
     * The <b>CM_Get_Device_ID_List_Size</b> function should be called to determine the buffer size required by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * 
     * The size value supplied in the location pointed to by <i>pulLen</i> is guaranteed to represent a buffer size large enough to hold all device instance identifier strings and terminating NULLs. The supplied value might actually represent a buffer size that is larger than necessary, so don't assume the value represents the true length of the character strings that <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a> will provide.
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_Device_ID_List_Size as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {Pointer<PSTR>} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies the buffer size required to hold all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_sizea
     * @since windows5.0
     */
    static CM_Get_Device_ID_List_SizeA(pulLen, pszFilter, ulFlags) {
        pszFilter := pszFilter is String? StrPtr(pszFilter) : pszFilter

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_SizeA", "ptr", pulLen, "ptr", pszFilter, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Size function retrieves the buffer size required to hold a list of device instance IDs for the local machine's device instances. (Unicode)
     * @remarks
     * The <b>CM_Get_Device_ID_List_Size</b> function should be called to determine the buffer size required by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * 
     * The size value supplied in the location pointed to by <i>pulLen</i> is guaranteed to represent a buffer size large enough to hold all device instance identifier strings and terminating NULLs. The supplied value might actually represent a buffer size that is larger than necessary, so don't assume the value represents the true length of the character strings that <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a> will provide.
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_Device_ID_List_Size as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {Pointer<PWSTR>} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies the buffer size required to hold all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_lista">CM_Get_Device_ID_List</a>.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_sizew
     * @since windows5.0
     */
    static CM_Get_Device_ID_List_SizeW(pulLen, pszFilter, ulFlags) {
        pszFilter := pszFilter is String? StrPtr(pszFilter) : pszFilter

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_SizeW", "ptr", pulLen, "ptr", pszFilter, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Size_Ex function retrieves the buffer size required to hold a list of device instance IDs for a local or a remote machine's device instances. (ANSI)
     * @remarks
     * The <b>CM_Get_Device_ID_List_Size_Ex</b> function should be called to determine the buffer size required by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exa">CM_Get_Device_ID_List_Ex</a>.
     * 
     * The size value supplied in the location pointed to by <i>pulLen</i> is guaranteed to represent a buffer size large enough to hold all device instance identifier strings and terminating NULLs. The supplied value might actually represent a buffer size that is larger than necessary, so don't assume the value represents the true length of the character strings that <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exa">CM_Get_Device_ID_List_Ex</a> will provide.
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {Pointer<PSTR>} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies the buffer size required to hold all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exa">CM_Get_Device_ID_List_Ex</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_size_exa
     */
    static CM_Get_Device_ID_List_Size_ExA(pulLen, pszFilter, ulFlags, hMachine) {
        pszFilter := pszFilter is String? StrPtr(pszFilter) : pszFilter

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_Size_ExA", "ptr", pulLen, "ptr", pszFilter, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_List_Size_Ex function retrieves the buffer size required to hold a list of device instance IDs for a local or a remote machine's device instances. (Unicode)
     * @remarks
     * The <b>CM_Get_Device_ID_List_Size_Ex</b> function should be called to determine the buffer size required by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exw">CM_Get_Device_ID_List_Ex</a>.
     * 
     * The size value supplied in the location pointed to by <i>pulLen</i> is guaranteed to represent a buffer size large enough to hold all device instance identifier strings and terminating NULLs. The supplied value might actually represent a buffer size that is larger than necessary, so don't assume the value represents the true length of the character strings that <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exw">CM_Get_Device_ID_List_Ex</a> will provide.
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {Pointer<PWSTR>} pszFilter Caller-supplied pointer to a character string specifying a subset of the machine's device instance identifiers, or <b>NULL</b>. See the following description of <i>ulFlags</i>.
     * @param {Integer} ulFlags One of the optional, caller-supplied bit flags that specify search filters. If no flags are specified, the function supplies the buffer size required to hold all instance identifiers for all device instances. For a list of bit flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_exw">CM_Get_Device_ID_List_Ex</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_list_size_exw
     * @since windows5.0
     */
    static CM_Get_Device_ID_List_Size_ExW(pulLen, pszFilter, ulFlags, hMachine) {
        pszFilter := pszFilter is String? StrPtr(pszFilter) : pszFilter

        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_List_Size_ExW", "ptr", pulLen, "ptr", pszFilter, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_Size function retrieves the buffer size required to hold a device instance ID for a device instance on the local machine.
     * @remarks
     * The <b>CM_Get_Device_ID_Size</b> function should be called to determine the buffer size required by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_idw">CM_Get_Device_ID</a>.
     * 
     * The size value supplied in the location pointed to by <i>pulLen</i> is less than MAX_DEVICE_ID_LEN, and does not include the identifier string's terminating <b>NULL</b>. If the specified device instance does not exist, the function supplies a size value of zero.
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Pointer<UInt32>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size
     * @since windows5.0
     */
    static CM_Get_Device_ID_Size(pulLen, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_Size", "ptr", pulLen, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_ID_Size_Ex function retrieves the buffer size required to hold a device instance ID for a device instance on a local or a remote machine.
     * @remarks
     * The <b>CM_Get_Device_ID_Size_Ex</b> function should be called to determine the buffer size required by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_exw">CM_Get_Device_ID_Ex</a>.
     * 
     * The size value supplied in the location pointed to by <i>pulLen</i> is less than MAX_DEVICE_ID_LEN, and does not include the identifier string's terminating <b>NULL</b>. If the specified device instance does not exist, the function supplies a size value of zero.
     * 
     * For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pulLen Receives a value representing the required buffer size, in characters.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size_ex
     * @since windows5.0
     */
    static CM_Get_Device_ID_Size_Ex(pulLen, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Device_ID_Size_Ex", "ptr", pulLen, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Property function retrieves a device instance property.
     * @remarks
     * <b>CM_Get_DevNode_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device instance property.
     * @param {Pointer<UInt32>} PropertyType Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device instance property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that receives the requested device instance property. <b>CM_Get_DevNode_Property</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<UInt32>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_DevNode_Property</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_propertyw
     * @since windows6.0.6000
     */
    static CM_Get_DevNode_PropertyW(dnDevInst, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_PropertyW", "uint", dnDevInst, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "ptr", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Property_ExW function retrieves a device instance property.
     * @remarks
     * <b>CM_Get_DevNode_Property_ExW</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device instance property.
     * @param {Pointer<UInt32>} PropertyType Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device instance property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that receives the requested device instance property. <b>CM_Get_DevNode_Property_ExW</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<UInt32>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_DevNode_Property_ExW</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_property_exw
     * @since windows10.0.10240
     */
    static CM_Get_DevNode_Property_ExW(dnDevInst, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Property_ExW", "uint", dnDevInst, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "ptr", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Property_Keys function retrieves an array of the device property keys that represent the device properties that are set for a device instance.
     * @remarks
     * <b>CM_Get_DevNode_Property_Keys</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device instance. The pointer is optional and can be NULL.
     * @param {Pointer<UInt32>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero. As output, If <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_DevNode_Property_Keys</b> returns the count of the keys in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_property_keys
     * @since windows6.0.6000
     */
    static CM_Get_DevNode_Property_Keys(dnDevInst, PropertyKeyArray, PropertyKeyCount, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Property_Keys", "uint", dnDevInst, "ptr", PropertyKeyArray, "ptr", PropertyKeyCount, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Property_Keys_Ex function retrieves an array of the device property keys that represent the device properties that are set for a device instance.
     * @remarks
     * <b>CM_Get_DevNode_Property_Keys_Ex</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device instance. The pointer is optional and can be NULL.
     * @param {Pointer<UInt32>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero. As output, If <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_DevNode_Property_Keys_Ex</b> returns the count of the keys in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_property_keys_ex
     * @since windows10.0.10240
     */
    static CM_Get_DevNode_Property_Keys_Ex(dnDevInst, PropertyKeyArray, PropertyKeyCount, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Property_Keys_Ex", "uint", dnDevInst, "ptr", PropertyKeyArray, "ptr", PropertyKeyCount, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Registry_Property function retrieves a specified device property from the registry. (ANSI)
     * @remarks
     * For information about how to use device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst A caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProperty A CM_DRP_-prefixed constant value that identifies the device property to be obtained from the registry. These constants are defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<UInt32>} pulRegDataType Optional, can be <b>NULL</b>. A pointer to a location that receives the registry data type, specified as a REG_-prefixed constant defined in <i>Winnt.h</i>.
     * @param {Pointer<Void>} Buffer Optional, can be <b>NULL</b>. A pointer to a caller-supplied buffer that receives the requested device property. If this value is <b>NULL</b>, the function supplies only the length of the requested data in the address pointed to by <i>pulLength</i>.
     * @param {Pointer<UInt32>} pulLength A pointer to a ULONG variable into which the function stores the length, in bytes, of the requested device property.
     * 
     * If the <i>Buffer</i> parameter is set to <b>NULL</b>, the ULONG variable must be set to zero.
     * 
     * If the <i>Buffer</i> parameter is not set to <b>NULL</b>, the ULONG variable must be set to the length, in bytes, of the caller-supplied buffer.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_registry_propertya
     */
    static CM_Get_DevNode_Registry_PropertyA(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Registry_PropertyA", "uint", dnDevInst, "uint", ulProperty, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Registry_Property function retrieves a specified device property from the registry. (Unicode)
     * @remarks
     * For information about how to use device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst A caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProperty A CM_DRP_-prefixed constant value that identifies the device property to be obtained from the registry. These constants are defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<UInt32>} pulRegDataType Optional, can be <b>NULL</b>. A pointer to a location that receives the registry data type, specified as a REG_-prefixed constant defined in <i>Winnt.h</i>.
     * @param {Pointer<Void>} Buffer Optional, can be <b>NULL</b>. A pointer to a caller-supplied buffer that receives the requested device property. If this value is <b>NULL</b>, the function supplies only the length of the requested data in the address pointed to by <i>pulLength</i>.
     * @param {Pointer<UInt32>} pulLength A pointer to a ULONG variable into which the function stores the length, in bytes, of the requested device property.
     * 
     * If the <i>Buffer</i> parameter is set to <b>NULL</b>, the ULONG variable must be set to zero.
     * 
     * If the <i>Buffer</i> parameter is not set to <b>NULL</b>, the ULONG variable must be set to the length, in bytes, of the caller-supplied buffer.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_registry_propertyw
     * @since windows5.0
     */
    static CM_Get_DevNode_Registry_PropertyW(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Registry_PropertyW", "uint", dnDevInst, "uint", ulProperty, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulProperty 
     * @param {Pointer<UInt32>} pulRegDataType 
     * @param {Pointer<Void>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_registry_property_exa
     */
    static CM_Get_DevNode_Registry_Property_ExA(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Registry_Property_ExA", "uint", dnDevInst, "uint", ulProperty, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulProperty 
     * @param {Pointer<UInt32>} pulRegDataType 
     * @param {Pointer<Void>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_registry_property_exw
     */
    static CM_Get_DevNode_Registry_Property_ExW(dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Registry_Property_ExW", "uint", dnDevInst, "uint", ulProperty, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<PSTR>} pszCustomPropertyName 
     * @param {Pointer<UInt32>} pulRegDataType 
     * @param {Pointer<Void>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_custom_propertya
     */
    static CM_Get_DevNode_Custom_PropertyA(dnDevInst, pszCustomPropertyName, pulRegDataType, Buffer, pulLength, ulFlags) {
        pszCustomPropertyName := pszCustomPropertyName is String? StrPtr(pszCustomPropertyName) : pszCustomPropertyName

        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Custom_PropertyA", "uint", dnDevInst, "ptr", pszCustomPropertyName, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<PWSTR>} pszCustomPropertyName 
     * @param {Pointer<UInt32>} pulRegDataType 
     * @param {Pointer<Void>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_custom_propertyw
     */
    static CM_Get_DevNode_Custom_PropertyW(dnDevInst, pszCustomPropertyName, pulRegDataType, Buffer, pulLength, ulFlags) {
        pszCustomPropertyName := pszCustomPropertyName is String? StrPtr(pszCustomPropertyName) : pszCustomPropertyName

        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Custom_PropertyW", "uint", dnDevInst, "ptr", pszCustomPropertyName, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<PSTR>} pszCustomPropertyName 
     * @param {Pointer<UInt32>} pulRegDataType 
     * @param {Pointer<Void>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_custom_property_exa
     */
    static CM_Get_DevNode_Custom_Property_ExA(dnDevInst, pszCustomPropertyName, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        pszCustomPropertyName := pszCustomPropertyName is String? StrPtr(pszCustomPropertyName) : pszCustomPropertyName

        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Custom_Property_ExA", "uint", dnDevInst, "ptr", pszCustomPropertyName, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<PWSTR>} pszCustomPropertyName 
     * @param {Pointer<UInt32>} pulRegDataType 
     * @param {Pointer<Void>} Buffer 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_custom_property_exw
     */
    static CM_Get_DevNode_Custom_Property_ExW(dnDevInst, pszCustomPropertyName, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        pszCustomPropertyName := pszCustomPropertyName is String? StrPtr(pszCustomPropertyName) : pszCustomPropertyName

        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Custom_Property_ExW", "uint", dnDevInst, "ptr", pszCustomPropertyName, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Status function obtains the status of a device instance from its device node (devnode) in the local machine's device tree.
     * @remarks
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Pointer<UInt32>} pulStatus Address of a location to receive status bit flags. The function can set any combination of the <b>DN_-</b> prefixed bit flags defined in <i>Cfg.h</i>.
     * @param {Pointer<UInt32>} pulProblemNumber Address of a location to receive one of the <b>CM_PROB_</b>-prefixed problem values defined in <i>Cfg.h</i>. Used only if DN_HAS_PROBLEM is set in <i>pulStatus</i>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status
     * @since windows5.0
     */
    static CM_Get_DevNode_Status(pulStatus, pulProblemNumber, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Status", "ptr", pulStatus, "ptr", pulProblemNumber, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_DevNode_Status_Ex function obtains the status of a device instance from its device node (devnode) on a local or a remote machine's device tree.
     * @remarks
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pulStatus Address of a location to receive status bit flags. The function can set any combination of the DN_-prefixed bit flags defined in <i>Cfg.h</i>.
     * @param {Pointer<UInt32>} pulProblemNumber Address of a location to receive one of the CM_PROB_-prefixed problem values defined in <i>Cfg.h</i>. Used only if DN_HAS_PROBLEM is set in <i>pulStatus</i>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status_ex
     * @since windows5.0
     */
    static CM_Get_DevNode_Status_Ex(pulStatus, pulProblemNumber, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_DevNode_Status_Ex", "ptr", pulStatus, "ptr", pulProblemNumber, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_First_Log_Conf function obtains the first logical configuration, of a specified configuration type, associated with a specified device instance on the local machine.
     * @remarks
     * Calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf">CM_Free_Log_Conf</a> can invalidate the handle obtained from a previous call to <b>CM_Get_First_Log_Conf</b>. Thus if you want to obtain logical configurations after calling <b>CM_Add_Empty_Log_Conf</b> or <b>CM_Free_Log_Conf</b>, your code must call <b>CM_Get_First_Log_Conf</b> again and start at the first configuration.
     * 
     * The handle received in <i>plcLogConf</i> must be explicitly freed by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_handle">CM_Free_Log_Conf_Handle</a>.
     * 
     * If <b>CM_Get_First_Log_Conf</b> is called with <i>plcLogConf</i> set to <b>NULL</b>, no handle is returned. This allows you to use the return status to determine if a configuration exists without the need to subsequently free the handle.
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Pointer<UIntPtr>} plcLogConf Address of a location to receive the handle to a logical configuration, or <b>NULL</b>. See the following <b>Remarks</b> section.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Caller-supplied flag value indicating the type of logical configuration being requested. One of the flags in the following table must be specified.
     * 
     * <table>
     * <tr>
     * <th>Configuration Type Flags</th>
     * <th>Definitions</th>
     * </tr>
     * <tr>
     * <td>
     * BASIC_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">basic configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * FILTERED_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">filtered configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * ALLOC_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">allocated configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * BOOT_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">boot configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * FORCED_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">forced configuration</a> information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * OVERRIDE_LOG_CONF
     * 
     * </td>
     * <td>
     * The caller is requesting <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/hardware-resources">override configuration</a> information.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_First_Log_Conf</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf
     * @since windows5.0
     */
    static CM_Get_First_Log_Conf(plcLogConf, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_First_Log_Conf", "ptr", plcLogConf, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_First_Log_Conf_Ex function obtains the first logical configuration associated with a specified device instance on a local or a remote machine.
     * @remarks
     * Calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_ex">CM_Free_Log_Conf_Ex</a> can invalidate the handle obtained from a previous call to <b>CM_Get_First_Log_Conf_Ex</b>. Thus if you want to obtain logical configurations after calling <b>CM_Add_Empty_Log_Conf_Ex</b> or <b>CM_Free_Log_Conf_Ex</b>, your code must call <b>CM_Get_First_Log_Conf_Ex</b> again and start at the first configuration.
     * 
     * The handle received in <i>plcLogConf</i> must be explicitly freed by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_handle">CM_Free_Log_Conf_Handle</a>.
     * 
     * If <b>CM_Get_First_Log_Conf_Ex</b> is called with <i>plcLogConf</i> set to <b>NULL</b>, no handle is returned. This allows you to use the return status to determine if a configuration exists without the need to subsequently free the handle.
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UIntPtr>} plcLogConf Address of a location to receive the handle to a logical configuration, or <b>NULL</b>. See the <b>Remarks</b> section.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Caller-supplied flag value indicating the type of logical configuration being requested. For a list of flags, see the <i>ulFlags</i> description for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_First_Log_Conf_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex
     * @since windows5.0
     */
    static CM_Get_First_Log_Conf_Ex(plcLogConf, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_First_Log_Conf_Ex", "ptr", plcLogConf, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pulState 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_global_state
     */
    static CM_Get_Global_State(pulState, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Global_State", "ptr", pulState, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pulState 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_global_state_ex
     */
    static CM_Get_Global_State_Ex(pulState, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Global_State_Ex", "ptr", pulState, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulIndex 
     * @param {Pointer<HWPROFILEINFO_A>} pHWProfileInfo 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hardware_profile_infoa
     */
    static CM_Get_Hardware_Profile_InfoA(ulIndex, pHWProfileInfo, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Hardware_Profile_InfoA", "uint", ulIndex, "ptr", pHWProfileInfo, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulIndex 
     * @param {Pointer<HWPROFILEINFO_A>} pHWProfileInfo 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hardware_profile_info_exa
     */
    static CM_Get_Hardware_Profile_Info_ExA(ulIndex, pHWProfileInfo, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Hardware_Profile_Info_ExA", "uint", ulIndex, "ptr", pHWProfileInfo, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulIndex 
     * @param {Pointer<HWPROFILEINFO_W>} pHWProfileInfo 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hardware_profile_infow
     */
    static CM_Get_Hardware_Profile_InfoW(ulIndex, pHWProfileInfo, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Hardware_Profile_InfoW", "uint", ulIndex, "ptr", pHWProfileInfo, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulIndex 
     * @param {Pointer<HWPROFILEINFO_W>} pHWProfileInfo 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hardware_profile_info_exw
     */
    static CM_Get_Hardware_Profile_Info_ExW(ulIndex, pHWProfileInfo, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Hardware_Profile_Info_ExW", "uint", ulIndex, "ptr", pHWProfileInfo, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_HW_Prof_Flags function retrieves the hardware profile-specific configuration flags for a device instance on a local machine. (ANSI)
     * @remarks
     * To retrieve a list of hardware profile IDs that are currently defined on a local machine, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigethwprofilelist">SetupDiGetHwProfileList</a>.
     * 
     * To retrieve configuration flags for a device instance on a remote machine, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flags_exa">CM_Get_HW_Prof_Flags_Ex</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_HW_Prof_Flags as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pDeviceID Pointer to a NULL-terminated string that contains the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> of the device for which to retrieve hardware profile-specific configuration flags.
     * @param {Integer} ulHardwareProfile A variable of ULONG type that specifies the identifier of the hardware profile for which to retrieve configuration flags. If this parameter is zero, this function retrieves the configuration flags for the current hardware profile.
     * @param {Pointer<UInt32>} pulValue Pointer to a caller-supplied variable of ULONG type that receives zero or a bitwise OR of the following configuration flags that are defined in <i>Regstr.h</i>:
     * @param {Integer} ulFlags Reserved for internal use. Must be set to zero.
     * @returns {Integer} If the operation succeeds, <b>CM_Get_HW_Prof_Flags</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flagsa
     * @since windows5.0
     */
    static CM_Get_HW_Prof_FlagsA(pDeviceID, ulHardwareProfile, pulValue, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_HW_Prof_FlagsA", "ptr", pDeviceID, "uint", ulHardwareProfile, "ptr", pulValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_HW_Prof_Flags function retrieves the hardware profile-specific configuration flags for a device instance on a local machine. (Unicode)
     * @remarks
     * To retrieve a list of hardware profile IDs that are currently defined on a local machine, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigethwprofilelist">SetupDiGetHwProfileList</a>.
     * 
     * To retrieve configuration flags for a device instance on a remote machine, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flags_exa">CM_Get_HW_Prof_Flags_Ex</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_HW_Prof_Flags as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pDeviceID Pointer to a NULL-terminated string that contains the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a> of the device for which to retrieve hardware profile-specific configuration flags.
     * @param {Integer} ulHardwareProfile A variable of ULONG type that specifies the identifier of the hardware profile for which to retrieve configuration flags. If this parameter is zero, this function retrieves the configuration flags for the current hardware profile.
     * @param {Pointer<UInt32>} pulValue Pointer to a caller-supplied variable of ULONG type that receives zero or a bitwise OR of the following configuration flags that are defined in <i>Regstr.h</i>:
     * @param {Integer} ulFlags Reserved for internal use. Must be set to zero.
     * @returns {Integer} If the operation succeeds, <b>CM_Get_HW_Prof_Flags</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flagsw
     * @since windows5.0
     */
    static CM_Get_HW_Prof_FlagsW(pDeviceID, ulHardwareProfile, pulValue, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_HW_Prof_FlagsW", "ptr", pDeviceID, "uint", ulHardwareProfile, "ptr", pulValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_HW_Prof_Flags_Ex function retrieves the hardware profile-specific configuration flags for a device instance on a remote machine or a local machine. (ANSI)
     * @remarks
     * To retrieve a list of the hardware profile IDs that are currently defined on a remote machine, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigethwprofilelistexa">SetupDiGetHwProfileListEx</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_HW_Prof_Flags_Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pDeviceID Pointer to a NULL-terminated string that contains the device instance ID of the device for which to retrieve hardware profile-specific configuration flags.
     * @param {Integer} ulHardwareProfile A variable of ULONG type that specifies the identifier of the hardware profile for which to retrieve configuration flags. If this parameter is zero, this function retrieves the configuration flags for the current hardware profile.
     * @param {Pointer<UInt32>} pulValue Pointer to a caller-supplied variable of ULONG type that receives zero or a bitwise OR of the following configuration flags that are defined in <i>Regstr.h</i>:
     * @param {Integer} ulFlags Reserved for internal use. Must be set to zero.
     * @param {Pointer} hMachine A machine handle that is returned by call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a> or <b>NULL</b>. If this parameter is set to <b>NULL</b>, <b>CM_Get_HW_Prof_Flags_Ex</b> retrieves the configuration flags on the local machine.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, <b>CM_Get_HW_Prof_Flags</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flags_exa
     * @since windows5.0
     */
    static CM_Get_HW_Prof_Flags_ExA(pDeviceID, ulHardwareProfile, pulValue, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_HW_Prof_Flags_ExA", "ptr", pDeviceID, "uint", ulHardwareProfile, "ptr", pulValue, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_HW_Prof_Flags_Ex function retrieves the hardware profile-specific configuration flags for a device instance on a remote machine or a local machine. (Unicode)
     * @remarks
     * To retrieve a list of the hardware profile IDs that are currently defined on a remote machine, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigethwprofilelistexa">SetupDiGetHwProfileListEx</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_HW_Prof_Flags_Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pDeviceID Pointer to a NULL-terminated string that contains the device instance ID of the device for which to retrieve hardware profile-specific configuration flags.
     * @param {Integer} ulHardwareProfile A variable of ULONG type that specifies the identifier of the hardware profile for which to retrieve configuration flags. If this parameter is zero, this function retrieves the configuration flags for the current hardware profile.
     * @param {Pointer<UInt32>} pulValue Pointer to a caller-supplied variable of ULONG type that receives zero or a bitwise OR of the following configuration flags that are defined in <i>Regstr.h</i>:
     * @param {Integer} ulFlags Reserved for internal use. Must be set to zero.
     * @param {Pointer} hMachine A machine handle that is returned by call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a> or <b>NULL</b>. If this parameter is set to <b>NULL</b>, <b>CM_Get_HW_Prof_Flags_Ex</b> retrieves the configuration flags on the local machine.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, <b>CM_Get_HW_Prof_Flags</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_hw_prof_flags_exw
     * @since windows5.0
     */
    static CM_Get_HW_Prof_Flags_ExW(pDeviceID, ulHardwareProfile, pulValue, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_HW_Prof_Flags_ExW", "ptr", pDeviceID, "uint", ulHardwareProfile, "ptr", pulValue, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Alias function returns the alias of the specified device interface instance, if the alias exists. (ANSI)
     * @remarks
     * Device interfaces are considered aliases if they are exposed by the same underlying device and have identical interface reference strings, but are of different interface classes.
     * 
     * The <i>pszDeviceInterface</i> parameter specifies a device interface instance for a particular device, belonging to a particular interface class, with a particular reference string. <b>CM_Get_Device_Interface_Alias</b> returns another device interface instance for the same device and reference string, but of a different interface class, if it exists.
     * 
     * For example, the function driver for a fault-tolerant volume could register and set two device interfaces, one of the fault-tolerant-volume interface class and one of the volume interface class. Another driver could call <b>CM_Get_Device_Interface_Alias</b> with the symbolic link for one of the interfaces and ask whether the other interface exists by specifying its interface class.
     * 
     * Two device interfaces with <b>NULL</b> reference strings are aliases if they are exposed by the same underlying device and have different interface class GUIDs.
     * @param {Pointer<PSTR>} pszDeviceInterface Pointer to the name of the device interface instance for which to retrieve an alias. The caller typically received this string from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_lista">CM_Get_Device_Interface_List</a>, or in a PnP notification structure.
     * @param {Pointer<Guid>} AliasInterfaceGuid Pointer to a GUID specifying the interface class of the alias to retrieve.
     * @param {Pointer<PSTR>} pszAliasDeviceInterface Specifies a pointer to a buffer, that upon successful return, points to a string containing the name of the alias. The caller must free this string when it is no longer needed.
     * 
     * A buffer is required.  Otherwise, the call will fail.
     * @param {Pointer<UInt32>} pulLength Supplies the count of characters in <i>pszAliasDeviceInterface</i> and receives the number of characters required to hold the alias device interface.
     * 
     * On input, this parameter must be greater than 0.
     * @param {Integer} ulFlags Reserved. Do not use.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Possibly indicates that there is no alias of the specified interface class.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is not enough memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_BUFFER_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer passed is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_aliasa
     */
    static CM_Get_Device_Interface_AliasA(pszDeviceInterface, AliasInterfaceGuid, pszAliasDeviceInterface, pulLength, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface
        pszAliasDeviceInterface := pszAliasDeviceInterface is String? StrPtr(pszAliasDeviceInterface) : pszAliasDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_AliasA", "ptr", pszDeviceInterface, "ptr", AliasInterfaceGuid, "ptr", pszAliasDeviceInterface, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Alias function returns the alias of the specified device interface instance, if the alias exists. (Unicode)
     * @remarks
     * Device interfaces are considered aliases if they are exposed by the same underlying device and have identical interface reference strings, but are of different interface classes.
     * 
     * The <i>pszDeviceInterface</i> parameter specifies a device interface instance for a particular device, belonging to a particular interface class, with a particular reference string. <b>CM_Get_Device_Interface_Alias</b> returns another device interface instance for the same device and reference string, but of a different interface class, if it exists.
     * 
     * For example, the function driver for a fault-tolerant volume could register and set two device interfaces, one of the fault-tolerant-volume interface class and one of the volume interface class. Another driver could call <b>CM_Get_Device_Interface_Alias</b> with the symbolic link for one of the interfaces and ask whether the other interface exists by specifying its interface class.
     * 
     * Two device interfaces with <b>NULL</b> reference strings are aliases if they are exposed by the same underlying device and have different interface class GUIDs.
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to the name of the device interface instance for which to retrieve an alias. The caller typically received this string from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_lista">CM_Get_Device_Interface_List</a>, or in a PnP notification structure.
     * @param {Pointer<Guid>} AliasInterfaceGuid Pointer to a GUID specifying the interface class of the alias to retrieve.
     * @param {Pointer<PWSTR>} pszAliasDeviceInterface Specifies a pointer to a buffer, that upon successful return, points to a string containing the name of the alias. The caller must free this string when it is no longer needed.
     * 
     * A buffer is required.  Otherwise, the call will fail.
     * @param {Pointer<UInt32>} pulLength Supplies the count of characters in <i>pszAliasDeviceInterface</i>          and receives the number of characters required to hold the alias device interface.
     * 
     * On input, this parameter must be greater than 0.
     * @param {Integer} ulFlags Reserved. Do not use.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_NO_SUCH_DEVICE_INTERFACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Possibly indicates that there is no alias of the specified interface class.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is not enough memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_BUFFER_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer passed is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_aliasw
     * @since windows5.0
     */
    static CM_Get_Device_Interface_AliasW(pszDeviceInterface, AliasInterfaceGuid, pszAliasDeviceInterface, pulLength, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface
        pszAliasDeviceInterface := pszAliasDeviceInterface is String? StrPtr(pszAliasDeviceInterface) : pszAliasDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_AliasW", "ptr", pszDeviceInterface, "ptr", AliasInterfaceGuid, "ptr", pszAliasDeviceInterface, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} pszDeviceInterface 
     * @param {Pointer<Guid>} AliasInterfaceGuid 
     * @param {Pointer<PSTR>} pszAliasDeviceInterface 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_alias_exa
     */
    static CM_Get_Device_Interface_Alias_ExA(pszDeviceInterface, AliasInterfaceGuid, pszAliasDeviceInterface, pulLength, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface
        pszAliasDeviceInterface := pszAliasDeviceInterface is String? StrPtr(pszAliasDeviceInterface) : pszAliasDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Alias_ExA", "ptr", pszDeviceInterface, "ptr", AliasInterfaceGuid, "ptr", pszAliasDeviceInterface, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszDeviceInterface 
     * @param {Pointer<Guid>} AliasInterfaceGuid 
     * @param {Pointer<PWSTR>} pszAliasDeviceInterface 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_alias_exw
     */
    static CM_Get_Device_Interface_Alias_ExW(pszDeviceInterface, AliasInterfaceGuid, pszAliasDeviceInterface, pulLength, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface
        pszAliasDeviceInterface := pszAliasDeviceInterface is String? StrPtr(pszAliasDeviceInterface) : pszAliasDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Alias_ExW", "ptr", pszDeviceInterface, "ptr", AliasInterfaceGuid, "ptr", pszAliasDeviceInterface, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_List function retrieves a list of device interface instances that belong to a specified device interface class. (ANSI)
     * @remarks
     * Between calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea">CM_Get_Device_Interface_List_Size</a> to get the size of the list and calling <b>CM_Get_Device_Interface_List</b> to get the list, a new device interface can be added to the system causing the size returned to no longer be valid. Callers should be robust to that condition and retry getting the size and the list if <b>CM_Get_Device_Interface_List</b> returns <b>CR_BUFFER_SMALL</b>.
     * @param {Pointer<Guid>} InterfaceClassGuid Supplies a GUID that identifies a device interface class.
     * @param {Pointer<PSTR>} pDeviceID Caller-supplied pointer to a NULL-terminated string that represents a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the function retrieves device interfaces that are supported by the device for the specified class. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves all interfaces that belong to the specified class.
     * @param {Pointer<PSTR>} Buffer Caller-supplied pointer to a buffer that receives multiple, NULL-terminated Unicode strings, each representing the symbolic link name of an interface instance.
     * @param {Integer} BufferLen Caller-supplied value that specifies the length, in characters, of the buffer pointed to by <i>Buffer</i>. Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea">CM_Get_Device_Interface_List_Size</a> to determine the required buffer size.
     * @param {Integer} ulFlags Contains one of the following caller-supplied flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the error codes with the CR_ prefix as defined in <i>Cfgmgr32.h</i>.
     * 
     * The following table includes some of the more common error codes that this function might return.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_BUFFER_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Buffer</i> buffer is too small to hold the requested list of device interfaces.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_lista
     * @since windows5.0
     */
    static CM_Get_Device_Interface_ListA(InterfaceClassGuid, pDeviceID, Buffer, BufferLen, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_ListA", "ptr", InterfaceClassGuid, "ptr", pDeviceID, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_List function retrieves a list of device interface instances that belong to a specified device interface class. (Unicode)
     * @remarks
     * Between calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea">CM_Get_Device_Interface_List_Size</a> to get the size of the list and calling <b>CM_Get_Device_Interface_List</b> to get the list, a new device interface can be added to the system causing the size returned to no longer be valid. Callers should be robust to that condition and retry getting the size and the list if <b>CM_Get_Device_Interface_List</b> returns <b>CR_BUFFER_SMALL</b>.
     * @param {Pointer<Guid>} InterfaceClassGuid Supplies a GUID that identifies a device interface class.
     * @param {Pointer<PWSTR>} pDeviceID Caller-supplied pointer to a NULL-terminated string that represents a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the function retrieves device interfaces that are supported by the device for the specified class. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves all interfaces that belong to the specified class.
     * @param {Pointer<PWSTR>} Buffer Caller-supplied pointer to a buffer that receives multiple, NULL-terminated Unicode strings, each representing the symbolic link name of an interface instance.
     * @param {Integer} BufferLen Caller-supplied value that specifies the length, in characters, of the buffer pointed to by <i>Buffer</i>. Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea">CM_Get_Device_Interface_List_Size</a> to determine the required buffer size.
     * @param {Integer} ulFlags Contains one of the following caller-supplied flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the error codes with the CR_ prefix as defined in <i>Cfgmgr32.h</i>.
     * 
     * The following table includes some of the more common error codes that this function might return.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CR_BUFFER_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Buffer</i> buffer is too small to hold the requested list of device interfaces.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_listw
     * @since windows5.0
     */
    static CM_Get_Device_Interface_ListW(InterfaceClassGuid, pDeviceID, Buffer, BufferLen, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_ListW", "ptr", InterfaceClassGuid, "ptr", pDeviceID, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {Pointer<PSTR>} pDeviceID 
     * @param {Pointer<PSTR>} Buffer 
     * @param {Integer} BufferLen 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_exa
     */
    static CM_Get_Device_Interface_List_ExA(InterfaceClassGuid, pDeviceID, Buffer, BufferLen, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_ExA", "ptr", InterfaceClassGuid, "ptr", pDeviceID, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {Pointer<PWSTR>} pDeviceID 
     * @param {Pointer<PWSTR>} Buffer 
     * @param {Integer} BufferLen 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_exw
     */
    static CM_Get_Device_Interface_List_ExW(InterfaceClassGuid, pDeviceID, Buffer, BufferLen, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_ExW", "ptr", InterfaceClassGuid, "ptr", pDeviceID, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_List_Size function retrieves the buffer size that must be passed to the CM_Get_Device_Interface_List function. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_Device_Interface_List_Size as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} pulLen Caller-supplied pointer to a location that receives the required length, in characters, of a buffer to 
     *            hold the multiple Unicode strings that will be returned by 
     *            <b>CM_Get_Device_Interface_List</b>.
     * @param {Pointer<Guid>} InterfaceClassGuid Supplies a GUID that identifies a 
     *            <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>.
     * @param {Pointer<PSTR>} pDeviceID Caller-supplied pointer to a NULL-terminated string that represents a 
     *            <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the 
     *            function retrieves the length of symbolic link names for the device interfaces that are supported by the 
     *            device, for the specified class. If this value is <b>NULL</b>, or if it points to a 
     *            zero-length string, the function retrieves the length of symbolic link names for all interfaces that belong 
     *            to the specified class.
     * @param {Integer} ulFlags Contains one of the following caller-supplied flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES"></a><a id="cm_get_device_interface_list_all_devices"></a><dl>
     * <dt><b>CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function provides the size of a list that contains device interfaces associated with all devices 
     *              that match the specified <b>GUID</b> and device instance ID, if any.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CM_GET_DEVICE_INTERFACE_LIST_PRESENT"></a><a id="cm_get_device_interface_list_present"></a><dl>
     * <dt><b>CM_GET_DEVICE_INTERFACE_LIST_PRESENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function provides the size of a list containing device interfaces associated with devices that 
     *              are currently active, and which match the specified GUID and device instance ID, if any.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns <b>CR_SUCCESS</b>. Otherwise, it 
     *            returns one of the error codes with the <b>CR_</b> prefix as defined in 
     *            Cfgmgr32.h.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea
     * @since windows5.0
     */
    static CM_Get_Device_Interface_List_SizeA(pulLen, InterfaceClassGuid, pDeviceID, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_SizeA", "ptr", pulLen, "ptr", InterfaceClassGuid, "ptr", pDeviceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_List_Size function retrieves the buffer size that must be passed to the CM_Get_Device_Interface_List function. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Get_Device_Interface_List_Size as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} pulLen Caller-supplied pointer to a location that receives the required length, in characters, of a buffer to 
     *            hold the multiple Unicode strings that will be returned by 
     *            <b>CM_Get_Device_Interface_List</b>.
     * @param {Pointer<Guid>} InterfaceClassGuid Supplies a GUID that identifies a 
     *            <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>.
     * @param {Pointer<PWSTR>} pDeviceID Caller-supplied pointer to a NULL-terminated string that represents a 
     *            <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the 
     *            function retrieves the length of symbolic link names for the device interfaces that are supported by the 
     *            device, for the specified class. If this value is <b>NULL</b>, or if it points to a 
     *            zero-length string, the function retrieves the length of symbolic link names for all interfaces that belong 
     *            to the specified class.
     * @param {Integer} ulFlags Contains one of the following caller-supplied flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES"></a><a id="cm_get_device_interface_list_all_devices"></a><dl>
     * <dt><b>CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function provides the size of a list that contains device interfaces associated with all devices 
     *              that match the specified <b>GUID</b> and device instance ID, if any.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CM_GET_DEVICE_INTERFACE_LIST_PRESENT"></a><a id="cm_get_device_interface_list_present"></a><dl>
     * <dt><b>CM_GET_DEVICE_INTERFACE_LIST_PRESENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function provides the size of a list containing device interfaces associated with devices that 
     *              are currently active, and which match the specified GUID and device instance ID, if any.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation succeeds, the function returns <b>CR_SUCCESS</b>. Otherwise, it 
     *            returns one of the error codes with the <b>CR_</b> prefix as defined in 
     *            Cfgmgr32.h.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizew
     * @since windows5.0
     */
    static CM_Get_Device_Interface_List_SizeW(pulLen, InterfaceClassGuid, pDeviceID, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_SizeW", "ptr", pulLen, "ptr", InterfaceClassGuid, "ptr", pDeviceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pulLen 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {Pointer<PSTR>} pDeviceID 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_size_exa
     */
    static CM_Get_Device_Interface_List_Size_ExA(pulLen, InterfaceClassGuid, pDeviceID, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_Size_ExA", "ptr", pulLen, "ptr", InterfaceClassGuid, "ptr", pDeviceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pulLen 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {Pointer<PWSTR>} pDeviceID 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_size_exw
     */
    static CM_Get_Device_Interface_List_Size_ExW(pulLen, InterfaceClassGuid, pDeviceID, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_List_Size_ExW", "ptr", pulLen, "ptr", InterfaceClassGuid, "ptr", pDeviceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Property function retrieves a device property that is set for a device interface.
     * @remarks
     * <b>CM_Get_Device_Interface_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance to retrieve the property from.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device interface property key of the device interface property to retrieve.
     * @param {Pointer<UInt32>} PropertyType Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device interface property. The property-data-type identifier is a bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the requested device interface property. <b>CM_Get_Device_Interface_Property</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<UInt32>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Device_Interface_Property</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_propertyw
     * @since windows6.0.6000
     */
    static CM_Get_Device_Interface_PropertyW(pszDeviceInterface, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_PropertyW", "ptr", pszDeviceInterface, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "ptr", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Property_ExW function retrieves a device property that is set for a device interface.
     * @remarks
     * <b>CM_Get_Device_Interface_Property_ExW</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance to retrieve the property from.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device interface property key of the device interface property to retrieve.
     * @param {Pointer<UInt32>} PropertyType Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device interface property. The property-data-type identifier is a bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer A pointer to a buffer that receives the requested device interface property. <b>CM_Get_Device_Interface_Property_ExW</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<UInt32>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Device_Interface_Property_ExW</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_property_exw
     * @since windows10.0.10240
     */
    static CM_Get_Device_Interface_Property_ExW(pszDeviceInterface, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Property_ExW", "ptr", pszDeviceInterface, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "ptr", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Property_Keys function retrieves an array of device property keys that represent the device properties that are set for a device interface.
     * @remarks
     * <b>CM_Get_Device_Interface_Property_Keys</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance to retrieve the property keys from.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device interface. The pointer is optional and can be NULL
     * @param {Pointer<UInt32>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero.  As output, if <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_Device_Interface_Property_Keys</b> returns the count of the keys, in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_property_keysw
     * @since windows6.0.6000
     */
    static CM_Get_Device_Interface_Property_KeysW(pszDeviceInterface, PropertyKeyArray, PropertyKeyCount, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Property_KeysW", "ptr", pszDeviceInterface, "ptr", PropertyKeyArray, "ptr", PropertyKeyCount, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Device_Interface_Property_Keys_ExW function retrieves an array of device property keys that represent the device properties that are set for a device interface.
     * @remarks
     * <b>CM_Get_Device_Interface_Property_Keys_ExW</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance to retrieve the property keys from.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device interface. The pointer is optional and can be NULL
     * @param {Pointer<UInt32>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero.  As output, if <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_Device_Interface_Property_Keys_ExW</b> returns the count of the keys, in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_property_keys_exw
     * @since windows10.0.10240
     */
    static CM_Get_Device_Interface_Property_Keys_ExW(pszDeviceInterface, PropertyKeyArray, PropertyKeyCount, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Get_Device_Interface_Property_Keys_ExW", "ptr", pszDeviceInterface, "ptr", PropertyKeyArray, "ptr", PropertyKeyCount, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Log_Conf_Priority function obtains the configuration priority of a specified logical configuration on the local machine.
     * @param {Pointer} lcLogConf Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Pointer<UInt32>} pPriority Caller-supplied address of a location to receive a configuration priority value. For a list of priority values, see the description of <i>Priority</i> for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Log_Conf_Priority</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_log_conf_priority
     * @since windows5.0
     */
    static CM_Get_Log_Conf_Priority(lcLogConf, pPriority, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Log_Conf_Priority", "ptr", lcLogConf, "ptr", pPriority, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Log_Conf_Priority_Ex function obtains the configuration priority of a specified logical configuration on a local or a remote machine.
     * @remarks
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer} lcLogConf Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf">CM_Get_Next_Log_Conf</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex">CM_Get_Next_Log_Conf_Ex</a>
     * @param {Pointer<UInt32>} pPriority Caller-supplied address of a location to receive a configuration priority value. For a list of priority values, see the description of <i>Priority</i> for <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Log_Conf_Priority_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_log_conf_priority_ex
     * @since windows5.0
     */
    static CM_Get_Log_Conf_Priority_Ex(lcLogConf, pPriority, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Log_Conf_Priority_Ex", "ptr", lcLogConf, "ptr", pPriority, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Next_Log_Conf function obtains the next logical configuration associated with a specific device instance on the local machine.
     * @remarks
     * To enumerate the logical configurations associated with a device instance, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a> to obtain the first logical configuration of a specified configuration type, then call <b>CM_Get_Next_Log_Conf</b> repeatedly until it returns CR_NO_MORE_LOG_CONF.
     * 
     * Calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf">CM_Add_Empty_Log_Conf</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf">CM_Free_Log_Conf</a> can invalidate the handle obtained from a previous call to <b>CM_Get_Next_Log_Conf</b>. Thus if you want to obtain logical configurations after calling <b>CM_Add_Empty_Log_Conf</b> or <b>CM_Free_Log_Conf</b>, your code must call <b>CM_Get_First_Log_Conf</b> again and start at the first configuration.
     * 
     * The handle received in <i>plcLogConf</i> must be explicitly freed by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_handle">CM_Free_Log_Conf_Handle</a>.
     * 
     * If <b>CM_Get_Next_Log_Conf</b> is called with <i>plcLogConf</i> set to <b>NULL</b>, no handle is returned. This allows you to use the return status to determine if a configuration exists without the need to subsequently free the handle.
     * @param {Pointer<UIntPtr>} plcLogConf Address of a location to receive the handle to a logical configuration, or <b>NULL</b>. (See the following <b>Remarks</b> section.
     * @param {Pointer} lcLogConf Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf">CM_Get_First_Log_Conf</a>
     * 
     * 
     * <b>CM_Get_Next_Log_Conf</b>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Next_Log_Conf</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf
     * @since windows5.0
     */
    static CM_Get_Next_Log_Conf(plcLogConf, lcLogConf) {
        static ulFlags := 0 ;Reserved parameters must always be NULL

        result := DllCall("CFGMGR32.dll\CM_Get_Next_Log_Conf", "ptr", plcLogConf, "ptr", lcLogConf, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Next_Log_Conf_Ex function obtains the next logical configuration associated with a specific device instance on a local or a remote machine.
     * @remarks
     * To enumerate the logical configurations associated with a device instance, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a> to obtain the first logical configuration, then call <b>CM_Get_Next_Log_Conf_Ex</b> repeatedly until it returns CR_NO_MORE_LOG_CONF.
     * 
     * Calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_empty_log_conf_ex">CM_Add_Empty_Log_Conf_Ex</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_ex">CM_Free_Log_Conf_Ex</a> can invalidate the handle obtained from a previous call to <b>CM_Get_Next_Log_Conf_Ex</b>. Thus if you want to obtain logical configurations after calling <b>CM_Add_Empty_Log_Conf_Ex</b> or <b>CM_Free_Log_Conf_Ex</b>, your code must call <b>CM_Get_First_Log_Conf_Ex</b> again and start at the first configuration.
     * 
     * The handle received in <i>plcLogConf</i> must be explicitly freed by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_log_conf_handle">CM_Free_Log_Conf_Handle</a>.
     * 
     * If <b>CM_Get_Next_Log_Conf_Ex</b> is called with <i>plcLogConf</i> set to <b>NULL</b>, no handle is returned. This allows you to use the return status to determine if a configuration exists without the need to subsequently free the handle.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UIntPtr>} plcLogConf Address of a location to receive the handle to a logical configuration, or <b>NULL</b>. (See the following <b>Remarks</b> section.
     * @param {Pointer} lcLogConf Caller-supplied handle to a logical configuration. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_first_log_conf_ex">CM_Get_First_Log_Conf_Ex</a>
     * 
     * 
     * <b>CM_Get_Next_Log_Conf_Ex</b>
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Next_Log_Conf_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_next_log_conf_ex
     * @since windows5.0
     */
    static CM_Get_Next_Log_Conf_Ex(plcLogConf, lcLogConf, hMachine) {
        static ulFlags := 0 ;Reserved parameters must always be NULL

        result := DllCall("CFGMGR32.dll\CM_Get_Next_Log_Conf_Ex", "ptr", plcLogConf, "ptr", lcLogConf, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Parent function obtains a device instance handle to the parent node of a specified device node (devnode) in the local machine's device tree.
     * @remarks
     * For information about using a device instance handle that is bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Pointer<UInt32>} pdnDevInst Caller-supplied pointer to the device instance handle to the parent node that this function retrieves. The retrieved handle is bound to the local machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_parent
     * @since windows5.0
     */
    static CM_Get_Parent(pdnDevInst, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Parent", "ptr", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Parent_Ex function obtains a device instance handle to the parent node of a specified device node (devnode) in a local or a remote machine's device tree.
     * @remarks
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pdnDevInst Caller-supplied pointer to the device instance handle to the parent node that this function retrieves. The retrieved handle is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_parent_ex
     * @since windows5.0
     */
    static CM_Get_Parent_Ex(pdnDevInst, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Parent_Ex", "ptr", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Res_Des_Data function retrieves the information stored in a resource descriptor on the local machine.
     * @remarks
     * Information returned in the buffer supplied by <i>Buffer</i> will be formatted as one of the resource type structures listed in the description of <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>, based on the resource type that was specified when <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a> was called to obtain the resource descriptor handle.
     * @param {Pointer} rdResDes Caller-supplied handle to a resource descriptor, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>.
     * @param {Pointer<Void>} Buffer Address of a buffer to receive the contents of a resource descriptor. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_size">CM_Get_Res_Des_Data_Size</a>.
     * @param {Integer} BufferLen Caller-supplied length of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Res_Des_Data</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data
     * @since windows5.0
     */
    static CM_Get_Res_Des_Data(rdResDes, Buffer, BufferLen, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Res_Des_Data", "ptr", rdResDes, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Res_Des_Data_Ex function retrieves the information stored in a resource descriptor on a local or a remote machine.
     * @remarks
     * Information returned in the buffer supplied by <i>Buffer</i> will be formatted as one of the resource type structures listed in the description of <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>, based on the resource type that was specified when <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a> was called to obtain the resource descriptor handle.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer} rdResDes Caller-supplied handle to a resource descriptor, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>.
     * @param {Pointer<Void>} Buffer Address of a buffer to receive the contents of a resource descriptor. The required buffer size should be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_size_ex">CM_Get_Res_Des_Data_Size_Ex</a>.
     * @param {Integer} BufferLen Caller-supplied length of the buffer specified by <i>Buffer</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Res_Des_Data_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_ex
     * @since windows5.0
     */
    static CM_Get_Res_Des_Data_Ex(rdResDes, Buffer, BufferLen, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Res_Des_Data_Ex", "ptr", rdResDes, "ptr", Buffer, "uint", BufferLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Res_Des_Data_Size function obtains the buffer size required to hold the information contained in a specified resource descriptor on the local machine.
     * @remarks
     * The returned size value represents the size of the appropriate resource structure (see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>). If the resource descriptor resides in a resource requirements list, the returned size includes both the size of the resource structure and the space allocated for associated range arrays.
     * @param {Pointer<UInt32>} pulSize Caller-supplied address of a location to receive the required buffer size.
     * @param {Pointer} rdResDes Caller-supplied handle to a resource descriptor, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Res_Des_Data_Size</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_size
     * @since windows5.0
     */
    static CM_Get_Res_Des_Data_Size(pulSize, rdResDes, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Res_Des_Data_Size", "ptr", pulSize, "ptr", rdResDes, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Res_Des_Data_Size_Ex function obtains the buffer size required to hold the information contained in a specified resource descriptor on a local or a remote machine.
     * @remarks
     * The returned size value represents the size of the appropriate resource structure (see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>). If the resource descriptor resides in a resource requirements list, the returned size includes both the size of the resource structure and the space allocated for associated range arrays.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pulSize Caller-supplied address of a location to receive the required buffer size.
     * @param {Pointer} rdResDes Caller-supplied handle to a resource descriptor, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Res_Des_Data_Size_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_size_ex
     * @since windows5.0
     */
    static CM_Get_Res_Des_Data_Size_Ex(pulSize, rdResDes, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Res_Des_Data_Size_Ex", "ptr", pulSize, "ptr", rdResDes, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Sibling function obtains a device instance handle to the next sibling node of a specified device node (devnode) in the local machine's device tree.
     * @remarks
     * To enumerate all children of a devnode in the local machine's device tree, first call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a> to obtain a handle to the first child node, then call <b>CM_Get_Sibling</b> to obtain handles for the rest of the children.
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Pointer<UInt32>} pdnDevInst Caller-supplied pointer to the device instance handle to the sibling node that this function retrieves. The retrieved handle is bound to the local machine.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_sibling
     * @since windows5.0
     */
    static CM_Get_Sibling(pdnDevInst, dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Sibling", "ptr", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Sibling_Ex function obtains a device instance handle to the next sibling node of a specified device node, in a local or a remote machine's device tree.
     * @remarks
     * To enumerate all children of a device node in the local machine's device tree, first call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a> to obtain a handle to the first child node, then call <b>CM_Get_Sibling_Ex</b> to obtain handles for the rest of the children.
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pdnDevInst Caller-supplied pointer to the device instance handle to the sibling node that this function retrieves. The retrieved handle is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_sibling_ex
     * @since windows5.0
     */
    static CM_Get_Sibling_Ex(pdnDevInst, dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Sibling_Ex", "ptr", pdnDevInst, "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Version function returns version 4.0 of the Plug and Play (PnP) Configuration Manager DLL (Cfgmgr32.dll) for a local machine.
     * @remarks
     * This function returns version 4.0 of the configuration manager to ensure compatibility with version 4.0 and all later versions of the configuration manager, and to ensure compatibility with all applications that require version 4.0 of the configuration manager.
     * 
     * To determine if a specific version of the configuration manager is available on a machine, use <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_version_available">CM_Is_Version_Available</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_version_available_ex">CM_Is_Version_Available_Ex</a>.
     * @returns {Integer} If the function succeeds, it returns the major revision number in the high-order byte, and the minor revision number in the low-order byte. Version 4.0 is returned as 0x0400. By default, version 4.0 is supported by Microsoft Windows 2000 and later versions of Windows. If an internal error occurs, the function returns 0x0000. Call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to obtain the error code for the failure.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_version
     * @since windows5.0
     */
    static CM_Get_Version() {
        A_LastError := 0

        result := DllCall("CFGMGR32.dll\CM_Get_Version", "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CM_Get_Version_Ex function returns version 4.0 of the Plug and Play (PnP) Configuration Manager DLL (Cfgmgr32.dll) for a local or a remote machine.
     * @remarks
     * This function returns version 4.0 of the configuration manager to ensure compatibility with version 4.0 and all later versions of the configuration manager, and to ensure compatibility with all applications that require version 4.0 of the configuration manager.
     * 
     * To determine if a specific version of the configuration manager is available on a machine, use <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_version_available">CM_Is_Version_Available</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_version_available_ex">CM_Is_Version_Available_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer} hMachine Supplies a machine handle that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the function succeeds, it returns the major revision number in the high-order byte and the minor revision number in the low-order byte. Version 4.0 is returned as 0x0400. By default, version 4.0 is supported  by Microsoft Windows 2000 and later versions of Windows. If an internal error occurs, the function returns 0x0000. Call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to obtain the error code for the failure.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_version_ex
     * @since windows5.0
     */
    static CM_Get_Version_Ex(hMachine) {
        A_LastError := 0

        result := DllCall("CFGMGR32.dll\CM_Get_Version_Ex", "ptr", hMachine, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CM_Is_Version_Available function indicates whether a specified version of the Plug and Play (PnP) Configuration Manager DLL (Cfgmgr32.dll) is supported by a local machine.
     * @remarks
     * Use this function to determine whether a specified version of the configuration manager is supported by a local machine. If the specified version is supported, all versions earlier and including this version are supported by the machine. You can also use <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_version_available_ex">CM_Is_Version_Available_Ex</a> to determine if a local or a remote machine supports a specific version of the configuration manager.
     * @param {Integer} wVersion Identifies a version of the configuration manager. The supported version of the configuration manager corresponds directly to the operating system version. The major version is specified by the high-order byte and the minor version is specified by the low-order byte. 
     * 
     * For example, 0x0400 specifies version 4.0, which is supported by default by Microsoft Windows 2000 and later versions of Windows. 0x0501 specifies version 5.1, which is supported by Windows XP and later versions of Windows.
     * @returns {Integer} The function returns <b>TRUE</b> if the local machine supports the specified version of the configuration manager. Otherwise, the function returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_is_version_available
     * @since windows5.1.2600
     */
    static CM_Is_Version_Available(wVersion) {
        result := DllCall("CFGMGR32.dll\CM_Is_Version_Available", "ushort", wVersion, "int")
        return result
    }

    /**
     * The CM_Is_Version_Available_Ex function indicates whether a specified version of the Plug and Play (PNP) Configuration Manager DLL (Cfgmgr32.dll) is supported by a local or a remote machine.
     * @remarks
     * Use this function to determine whether a specified version of the configuration manager is supported by a local or a remote machine. If the specified version is supported, all versions earlier and including this version are supported by the machine. You can also use <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_version_available">CM_Is_Version_Available</a> to determine if the local machine supports a specific version of the configuration manager. 
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} wVersion Identifies a version of the configuration manager. The supported version of the configuration manager corresponds directly to the operating system version. The major version is specified by the high-order byte and the minor version is specified by the low-order byte. For example, 0x0400 specifies version 4.0, which is supported by default by Microsoft Windows NT 4.0 and later versions of Windows. Version 0x0501 specifies version 5.1, which is supported by Windows XP and later versions of Windows.
     * @param {Pointer} hMachine Supplies a machine handle that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} The function returns <b>TRUE</b> if the function can connect to the specified machine and if the machine supports the specified version. Otherwise, the function returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_is_version_available_ex
     * @since windows5.1.2600
     */
    static CM_Is_Version_Available_Ex(wVersion, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Is_Version_Available_Ex", "ushort", wVersion, "ptr", hMachine, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} rlhOld1 
     * @param {Pointer} rlhOld2 
     * @param {Pointer} rlhNew 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_intersect_range_list
     */
    static CM_Intersect_Range_List(rlhOld1, rlhOld2, rlhNew, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Intersect_Range_List", "ptr", rlhOld1, "ptr", rlhOld2, "ptr", rlhNew, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlhOld 
     * @param {Pointer} rlhNew 
     * @param {Integer} ullMaxValue 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_invert_range_list
     */
    static CM_Invert_Range_List(rlhOld, rlhNew, ullMaxValue, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Invert_Range_List", "ptr", rlhOld, "ptr", rlhNew, "uint", ullMaxValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Locate_DevNode function obtains a device instance handle to the device node that is associated with a specified device instance ID on the local machine. (ANSI)
     * @remarks
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Locate_DevNode as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} pdnDevInst A pointer to a device instance handle that <b>CM_Locate_DevNode</b> retrieves. The retrieved handle is bound to the local machine.
     * @param {Pointer<PSTR>} pDeviceID A pointer to a NULL-terminated string representing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves a device instance handle to the device at the root of the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/device-tree">device tree</a>.
     * @param {Integer} ulFlags A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:
     * @returns {Integer} If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnodea
     * @since windows5.0
     */
    static CM_Locate_DevNodeA(pdnDevInst, pDeviceID, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Locate_DevNodeA", "ptr", pdnDevInst, "ptr", pDeviceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Locate_DevNode function obtains a device instance handle to the device node that is associated with a specified device instance ID on the local machine. (Unicode)
     * @remarks
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Locate_DevNode as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} pdnDevInst A pointer to a device instance handle that <b>CM_Locate_DevNode</b> retrieves. The retrieved handle is bound to the local machine.
     * @param {Pointer<PWSTR>} pDeviceID A pointer to a NULL-terminated string representing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves a device instance handle to the device at the root of the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/device-tree">device tree</a>.
     * @param {Integer} ulFlags A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:
     * @returns {Integer} If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnodew
     * @since windows5.0
     */
    static CM_Locate_DevNodeW(pdnDevInst, pDeviceID, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Locate_DevNodeW", "ptr", pdnDevInst, "ptr", pDeviceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Locate_DevNode_Ex function obtains a device instance handle to the device node that is associated with a specified device instance ID, on a local machine or a remote machine. (ANSI)
     * @remarks
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pdnDevInst 
     * @param {Pointer<PSTR>} pDeviceID 
     * @param {Integer} ulFlags A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:
     * @param {Pointer} hMachine A machine handle obtained from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinea">CM_Connect_Machine</a>, or a machine handle to which a device information set is bound. The machine handle for a device information set is obtained from the <b>RemoteMachineHandle</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure for the device information set. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila">SetupDiGetDeviceInfoListDetail</a> to obtain an SP_DEVINFO_LIST_DETAIL_DATA structure.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnode_exa
     */
    static CM_Locate_DevNode_ExA(pdnDevInst, pDeviceID, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Locate_DevNode_ExA", "ptr", pdnDevInst, "ptr", pDeviceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Locate_DevNode_Ex function obtains a device instance handle to the device node that is associated with a specified device instance ID, on a local machine or a remote machine. (Unicode)
     * @remarks
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UInt32>} pdnDevInst A pointer to the device instance handle that this function retrieves. The retrieved handle is bound to the machine handle specified by <i>hMachine</i>.
     * @param {Pointer<PWSTR>} pDeviceID A pointer to a NULL-terminated string representing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If this value is <b>NULL</b>, or if it points to a zero-length string, the function supplies a device instance handle to the device at the root of the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/device-tree">device tree</a>.
     * @param {Integer} ulFlags A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:
     * @param {Pointer} hMachine A machine handle obtained from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>, or a machine handle to which a device information set is bound. The machine handle for a device information set is obtained from the <b>RemoteMachineHandle</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure for the device information set. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila">SetupDiGetDeviceInfoListDetail</a> to obtain an SP_DEVINFO_LIST_DETAIL_DATA structure.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnode_exw
     * @since windows5.0
     */
    static CM_Locate_DevNode_ExW(pdnDevInst, pDeviceID, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Locate_DevNode_ExW", "ptr", pdnDevInst, "ptr", pDeviceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} rlhOld1 
     * @param {Pointer} rlhOld2 
     * @param {Pointer} rlhNew 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_merge_range_list
     */
    static CM_Merge_Range_List(rlhOld1, rlhOld2, rlhNew, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Merge_Range_List", "ptr", rlhOld1, "ptr", rlhOld2, "ptr", rlhNew, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Modify_Res_Des function modifies a specified resource descriptor on the local machine.
     * @remarks
     * The caller-supplied resource descriptor data replaces the existing data. The values specified for <i>ResourceID</i> and <i>ResourceLen</i> do not have to match the existing resource descriptor.
     * 
     * If the value specified for <i>ResourceID</i> is <b>ResType_ClassSpecific</b>, then the specified resource descriptor must be the last one associated with the logical configuration.
     * 
     * Callers of <b>CM_Modify_Res_Des</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des_handle">CM_Free_Res_Des_Handle</a> to deallocate the resource descriptor handle, after it is no longer needed.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * @param {Pointer<UIntPtr>} prdResDes Pointer to a location to receive a handle to the modified resource descriptor.
     * @param {Pointer} rdResDes Caller-supplied handle to the resource descriptor to be modified. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * <b>CM_Modify_Res_Des</b>
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>
     * @param {Integer} ResourceID Caller-supplied resource type identifier. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Void>} ResourceData Caller-supplied pointer to a resource descriptor, which can be one of the structures listed under the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a> function's description of <i>ResourceData</i>.
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Modify_Res_Des</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des
     * @since windows5.0
     */
    static CM_Modify_Res_Des(prdResDes, rdResDes, ResourceID, ResourceData, ResourceLen, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Modify_Res_Des", "ptr", prdResDes, "ptr", rdResDes, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Modify_Res_Des_Ex function modifies a specified resource descriptor on a local or a remote machine.
     * @remarks
     * The caller-supplied resource descriptor data replaces the existing data. The values specified for <i>ResourceID</i> and <i>ResourceLen</i> do not have to match the existing resource descriptor.
     * 
     * If the value specified for <i>ResourceID</i> is <b>ResType_ClassSpecific</b>, then the specified resource descriptor must be the last one associated with the logical configuration.
     * 
     * Callers of <b>CM_Modify_Res_Des_Ex</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des_handle">CM_Free_Res_Des_Handle</a> to deallocate the resource descriptor handle, after it is no longer needed.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UIntPtr>} prdResDes Pointer to a location to receive a handle to the modified resource descriptor.
     * @param {Pointer} rdResDes Caller-supplied handle to the resource descriptor to be modified. This handle must have been previously obtained by calling one of the following functions:
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des">CM_Get_Next_Res_Des</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex">CM_Get_Next_Res_Des_Ex</a>
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>
     * 
     * 
     * <b>CM_Modify_Res_Des_Ex</b>
     * @param {Integer} ResourceID Caller-supplied resource type identifier. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Void>} ResourceData Caller-supplied pointer to a resource descriptor, which can be one of the structures listed under the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des_ex">CM_Add_Res_Des_Ex</a> function's description of <i>ResourceData</i>.
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Modify_Res_Des_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex
     * @since windows5.0
     */
    static CM_Modify_Res_Des_Ex(prdResDes, rdResDes, ResourceID, ResourceData, ResourceLen, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Modify_Res_Des_Ex", "ptr", prdResDes, "ptr", rdResDes, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnFromDevInst 
     * @param {Integer} dnToDevInst 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_move_devnode
     */
    static CM_Move_DevNode(dnFromDevInst, dnToDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Move_DevNode", "uint", dnFromDevInst, "uint", dnToDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnFromDevInst 
     * @param {Integer} dnToDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_move_devnode_ex
     */
    static CM_Move_DevNode_Ex(dnFromDevInst, dnToDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Move_DevNode_Ex", "uint", dnFromDevInst, "uint", dnToDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UIntPtr>} preElement 
     * @param {Pointer<UInt64>} pullStart 
     * @param {Pointer<UInt64>} pullEnd 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_next_range
     */
    static CM_Next_Range(preElement, pullStart, pullEnd, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Next_Range", "ptr", preElement, "ptr", pullStart, "ptr", pullEnd, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Next_Res_Des function obtains a handle to the next resource descriptor, of a specified resource type, for a logical configuration on the local machine.
     * @remarks
     * To enumerate a logical configuration's resource descriptors, begin by calling <b>CM_Get_Next_Res_Des</b> with the logical configuration's handle as the argument for <i>rdResDes</i>. This obtains a handle to the first resource descriptor of the type specified by <i>ForResource</i>. Then for each subsequent call to <b>CM_Get_Next_Res_Des</b>, specify the most recently obtained descriptor handle as the argument for <i>rdResDes</i>. Repeat until the function returns CR_NO_MORE_RES_DES.
     * 
     * To retrieve the information stored in a resource descriptor, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data">CM_Get_Res_Des_Data</a>.
     * 
     * To modify the information stored in a resource descriptor, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des">CM_Modify_Res_Des</a>.
     * 
     * Callers of <b>CM_Get_Next_Res_Des</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des_handle">CM_Free_Res_Des_Handle</a> to deallocate the resource descriptor handle, after it is no longer needed.
     * @param {Pointer<UIntPtr>} prdResDes Pointer to a location to receive a resource descriptor handle.
     * @param {Pointer} rdResDes Caller-supplied handle to either a resource descriptor or a logical configuration. For more information, see the following <b>Remarks</b> section.
     * @param {Integer} ForResource Caller-supplied resource type identifier, indicating the type of resource descriptor being requested. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<UInt32>} pResourceID Pointer to a location to receive a resource type identifier, if <i>ForResource</i> specifies <b>ResType_All</b>. For any other <i>ForResource</i> value, callers should set this to <b>NULL</b>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Next_Res_Des</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des
     * @since windows5.0
     */
    static CM_Get_Next_Res_Des(prdResDes, rdResDes, ForResource, pResourceID, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Next_Res_Des", "ptr", prdResDes, "ptr", rdResDes, "uint", ForResource, "ptr", pResourceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Next_Res_Des_Ex function obtains a handle to the next resource descriptor, of a specified resource type, for a logical configuration on a local or a remote machine.
     * @remarks
     * To enumerate a logical configuration's resource descriptors, begin by calling <b>CM_Get_Next_Res_Des_Ex</b> with the logical configuration's handle as the argument for <i>rdResDes</i>. This obtains a handle to the first resource descriptor of the type specified by <i>ForResource</i>. Then for each subsequent call to <b>CM_Get_Next_Res_Des_Ex</b>, specify the most recently obtained descriptor handle as the argument for <i>rdResDes</i>. Repeat until the function returns CR_NO_MORE_RES_DES.
     * 
     * To retrieve the information stored in a resource descriptor, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data_ex">CM_Get_Res_Des_Data_Ex</a>.
     * 
     * To modify the information stored in a resource descriptor, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_modify_res_des_ex">CM_Modify_Res_Des_Ex</a>.
     * 
     * Callers of <b>CM_Get_Next_Res_Des_Ex</b> must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_res_des_handle">CM_Free_Res_Des_Handle</a> to deallocate the resource descriptor handle, after it is no longer needed.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<UIntPtr>} prdResDes Pointer to a location to receive a resource descriptor handle.
     * @param {Pointer} rdResDes Caller-supplied handle to either a resource descriptor or a logical configuration. For more information, see the following <b>Remarks</b> section.
     * @param {Integer} ForResource Caller-supplied resource type identifier, indicating the type of resource descriptor being requested. This must be one of the ResType_-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<UInt32>} pResourceID Pointer to a location to receive a resource type identifier, if <i>ForResource</i> specifies <b>ResType_All</b>. For any other <i>ForResource</i> value, callers should set this to <b>NULL</b>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Get_Next_Res_Des_Ex</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_next_res_des_ex
     * @since windows5.0
     */
    static CM_Get_Next_Res_Des_Ex(prdResDes, rdResDes, ForResource, pResourceID, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Next_Res_Des_Ex", "ptr", prdResDes, "ptr", rdResDes, "uint", ForResource, "ptr", pResourceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Open_Class_Key function opens the device setup class registry key, the device interface class registry key, or a specific subkey of a class. (ANSI)
     * @remarks
     * Close the handle returned from this function by calling <b>RegCloseKey</b>.
     * @param {Pointer<Guid>} ClassGuid Pointer to the GUID of the class whose registry key is to be opened. This parameter is optional and can be NULL. If this parameter is NULL, the root of the class tree is opened.
     * @param {Pointer<PSTR>} pszClassName Reserved. Must be set to NULL.
     * @param {Integer} samDesired The registry security access for the key to be opened.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkClass Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Open class key flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_class_keya
     */
    static CM_Open_Class_KeyA(ClassGuid, pszClassName, samDesired, Disposition, phkClass, ulFlags) {
        pszClassName := pszClassName is String? StrPtr(pszClassName) : pszClassName

        result := DllCall("CFGMGR32.dll\CM_Open_Class_KeyA", "ptr", ClassGuid, "ptr", pszClassName, "uint", samDesired, "uint", Disposition, "ptr", phkClass, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Open_Class_Key function opens the device setup class registry key, the device interface class registry key, or a specific subkey of a class. (Unicode)
     * @remarks
     * Close the handle returned from this function by calling <b>RegCloseKey</b>.
     * @param {Pointer<Guid>} ClassGuid Pointer to the GUID of the class whose registry key is to be opened. This parameter is optional and can be NULL. If this parameter is NULL, the root of the class tree is opened.
     * @param {Pointer<PWSTR>} pszClassName Reserved. Must be set to NULL.
     * @param {Integer} samDesired The registry security access for the key to be opened.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkClass Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Open class key flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_class_keyw
     * @since windows5.0
     */
    static CM_Open_Class_KeyW(ClassGuid, pszClassName, samDesired, Disposition, phkClass, ulFlags) {
        pszClassName := pszClassName is String? StrPtr(pszClassName) : pszClassName

        result := DllCall("CFGMGR32.dll\CM_Open_Class_KeyW", "ptr", ClassGuid, "ptr", pszClassName, "uint", samDesired, "uint", Disposition, "ptr", phkClass, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PSTR>} pszClassName 
     * @param {Integer} samDesired 
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkClass 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_class_key_exa
     */
    static CM_Open_Class_Key_ExA(ClassGuid, pszClassName, samDesired, Disposition, phkClass, ulFlags, hMachine) {
        pszClassName := pszClassName is String? StrPtr(pszClassName) : pszClassName

        result := DllCall("CFGMGR32.dll\CM_Open_Class_Key_ExA", "ptr", ClassGuid, "ptr", pszClassName, "uint", samDesired, "uint", Disposition, "ptr", phkClass, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} ClassGuid 
     * @param {Pointer<PWSTR>} pszClassName 
     * @param {Integer} samDesired 
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkClass 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_class_key_exw
     */
    static CM_Open_Class_Key_ExW(ClassGuid, pszClassName, samDesired, Disposition, phkClass, ulFlags, hMachine) {
        pszClassName := pszClassName is String? StrPtr(pszClassName) : pszClassName

        result := DllCall("CFGMGR32.dll\CM_Open_Class_Key_ExW", "ptr", ClassGuid, "ptr", pszClassName, "uint", samDesired, "uint", Disposition, "ptr", phkClass, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Open_DevNode_Key function opens a registry key for device-specific configuration information.
     * @remarks
     * Close the handle returned from this function by calling <b>RegCloseKey</b>.
     * @param {Integer} dnDevNode Caller-supplied device instance handle that is bound to the local machine
     * @param {Integer} samDesired The registry security access that is required for the requested key.
     * @param {Integer} ulHardwareProfile The hardware profile to open if <i>ulFlags</i> includes CM_REGISTRY_CONFIG. If this value is zero, the key for the current hardware profile is opened.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDevice Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Open device node key flags. Indicates the scope and type of registry storage key to open.  Can be a combination of the following flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_devnode_key
     * @since windows5.0
     */
    static CM_Open_DevNode_Key(dnDevNode, samDesired, ulHardwareProfile, Disposition, phkDevice, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Open_DevNode_Key", "uint", dnDevNode, "uint", samDesired, "uint", ulHardwareProfile, "uint", Disposition, "ptr", phkDevice, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevNode 
     * @param {Integer} samDesired 
     * @param {Integer} ulHardwareProfile 
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDevice 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_devnode_key_ex
     */
    static CM_Open_DevNode_Key_Ex(dnDevNode, samDesired, ulHardwareProfile, Disposition, phkDevice, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Open_DevNode_Key_Ex", "uint", dnDevNode, "uint", samDesired, "uint", ulHardwareProfile, "uint", Disposition, "ptr", phkDevice, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Open_Device_Interface_Key function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface. (ANSI)
     * @remarks
     * Close the handle returned from this function by calling <b>RegCloseKey</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Open_Device_Interface_Key as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance to open the registry subkey for.
     * @param {Integer} samDesired The requested registry security access to the registry subkey.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDeviceInterface Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_device_interface_keya
     * @since windows6.0.6000
     */
    static CM_Open_Device_Interface_KeyA(pszDeviceInterface, samDesired, Disposition, phkDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Open_Device_Interface_KeyA", "ptr", pszDeviceInterface, "uint", samDesired, "uint", Disposition, "ptr", phkDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Open_Device_Interface_Key function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface. (Unicode)
     * @remarks
     * Close the handle returned from this function by calling <b>RegCloseKey</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Open_Device_Interface_Key as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance to open the registry subkey for.
     * @param {Integer} samDesired The requested registry security access to the registry subkey.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDeviceInterface Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_device_interface_keyw
     * @since windows6.0.6000
     */
    static CM_Open_Device_Interface_KeyW(pszDeviceInterface, samDesired, Disposition, phkDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Open_Device_Interface_KeyW", "ptr", pszDeviceInterface, "uint", samDesired, "uint", Disposition, "ptr", phkDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Open_Device_Interface_Key_ExA function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface.
     * @remarks
     * Close the handle returned from this function by calling <b>RegCloseKey</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Open_Device_Interface_Key_Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance to open the registry subkey for.
     * @param {Integer} samDesired The requested registry security access to the registry subkey.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDeviceInterface Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_device_interface_key_exa
     * @since windows10.0.10240
     */
    static CM_Open_Device_Interface_Key_ExA(pszDeviceInterface, samDesired, Disposition, phkDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Open_Device_Interface_Key_ExA", "ptr", pszDeviceInterface, "uint", samDesired, "uint", Disposition, "ptr", phkDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Open_Device_Interface_Key_ExW function opens the registry subkey that is used by applications and drivers to store information that is specific to a device interface.
     * @remarks
     * Close the handle returned from this function by calling <b>RegCloseKey</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Open_Device_Interface_Key_Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance to open the registry subkey for.
     * @param {Integer} samDesired The requested registry security access to the registry subkey.
     * @param {Integer} Disposition 
     * @param {Pointer<HKEY>} phkDeviceInterface Pointer to an HKEY that will receive the opened key upon success.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_open_device_interface_key_exw
     * @since windows10.0.10240
     */
    static CM_Open_Device_Interface_Key_ExW(pszDeviceInterface, samDesired, Disposition, phkDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Open_Device_Interface_Key_ExW", "ptr", pszDeviceInterface, "uint", samDesired, "uint", Disposition, "ptr", phkDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Delete_Device_Interface_Key function deletes the registry subkey that is used by applications and drivers to store interface-specific information. (ANSI)
     * @param {Pointer<PSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance of the registry subkey to delete.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_device_interface_keya
     */
    static CM_Delete_Device_Interface_KeyA(pszDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Delete_Device_Interface_KeyA", "ptr", pszDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Delete_Device_Interface_Key function deletes the registry subkey that is used by applications and drivers to store interface-specific information. (Unicode)
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance of the registry subkey to delete.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_device_interface_keyw
     * @since windows6.0.6000
     */
    static CM_Delete_Device_Interface_KeyW(pszDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Delete_Device_Interface_KeyW", "ptr", pszDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Delete_Device_Interface_Key_ExA function deletes the registry subkey that is used by applications and drivers to store interface-specific information.
     * @remarks
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Delete_Device_Interface_Key_Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance of the registry subkey to delete.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_device_interface_key_exa
     * @since windows10.0.10240
     */
    static CM_Delete_Device_Interface_Key_ExA(pszDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Delete_Device_Interface_Key_ExA", "ptr", pszDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Delete_Device_Interface_Key_ExW function deletes the registry subkey that is used by applications and drivers to store interface-specific information.
     * @remarks
     * > [!NOTE]
     * > The cfgmgr32.h header defines CM_Delete_Device_Interface_Key_Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance of the registry subkey to delete.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_delete_device_interface_key_exw
     * @since windows10.0.10240
     */
    static CM_Delete_Device_Interface_Key_ExW(pszDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Delete_Device_Interface_Key_ExW", "ptr", pszDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} pData 
     * @param {Integer} DataLen 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_arbitrator_free_data
     */
    static CM_Query_Arbitrator_Free_Data(pData, DataLen, dnDevInst, ResourceID, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Query_Arbitrator_Free_Data", "ptr", pData, "uint", DataLen, "uint", dnDevInst, "uint", ResourceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} pData 
     * @param {Integer} DataLen 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_arbitrator_free_data_ex
     */
    static CM_Query_Arbitrator_Free_Data_Ex(pData, DataLen, dnDevInst, ResourceID, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Query_Arbitrator_Free_Data_Ex", "ptr", pData, "uint", DataLen, "uint", dnDevInst, "uint", ResourceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pulSize 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_arbitrator_free_size
     */
    static CM_Query_Arbitrator_Free_Size(pulSize, dnDevInst, ResourceID, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Query_Arbitrator_Free_Size", "ptr", pulSize, "uint", dnDevInst, "uint", ResourceID, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} pulSize 
     * @param {Integer} dnDevInst 
     * @param {Integer} ResourceID 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_arbitrator_free_size_ex
     */
    static CM_Query_Arbitrator_Free_Size_Ex(pulSize, dnDevInst, ResourceID, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Query_Arbitrator_Free_Size_Ex", "ptr", pulSize, "uint", dnDevInst, "uint", ResourceID, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnAncestor 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_remove_subtree
     */
    static CM_Query_Remove_SubTree(dnAncestor, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Query_Remove_SubTree", "uint", dnAncestor, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnAncestor 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_remove_subtree_ex
     */
    static CM_Query_Remove_SubTree_Ex(dnAncestor, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Query_Remove_SubTree_Ex", "uint", dnAncestor, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Query_And_Remove_SubTree function checks whether a device instance and its children can be removed and, if so, it removes them. (ANSI)
     * @remarks
     * The purpose of the <b>CM_Query_And_Remove_SubTree</b> function is to allow an application to prepare a device for safe removal from the local machine. Use this function to remove devices only if a driver has not set the <b>SurpriseRemovalOK</b> member of <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_device_capabilities">DEVICE_CAPABILITIES</a>. If a driver has set <b>SurpriseRemovalOK</b>, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_device_ejecta">CM_Request_Device_Eject</a> instead of <b>CM_Query_And_Remove_SubTree</b>.
     * 
     * <b>CM_Query_And_Remove_SubTree</b> supports setting the flags parameter <i>ulFlags</i> with one of the following two flags; these flags apply only if Windows or an installer vetoes the removal of a device:
     * 
     * | Flag | Description |
     * |------|-------------|
     * | CM_REMOVE_UI_OK | The function allows a user dialog box to be displayed to indicate the reason for the veto. This is the default flag setting. |
     * | CM_REMOVE_UI_NOT_OK | The function suppresses the display of a user dialog box that indicates the reason for the veto. |
     * 
     * Beginning with Windows XP, <b>CM_Query_And_Remove_SubTree</b> also supports setting the following additional flag; this flag applies only if the function successfully removes the device instance:
     * 
     * 
     * | Flag | Description |
     * |------|-------------|
     * | CM_REMOVE_NO_RESTART | If this flag is set, the function configures the device status such that the device cannot be restarted until after the device status is reset. |
     * 
     * The device status is reset by the one of the following:
     * - Calling [CM_Setup_DevNode](nf-cfgmgr32-cm_setup_devnode.md) for the device and specifying CM_SETUP_DEVNODE_RESET. After the device status is reset in this manner, the device can be restarted by calling [CM_Reenumerate_DevNode](nf-cfgmgr32-cm_reenumerate_devnode.md) for the device instance. After resetting the device status, any other operation that enumerates the device will also restart the device, for example, if the Device Manager is used to reenumerate devices.
     * - The device is detached and reattached, or the computer is restarted. In this case, the device status will be reset and the device will be restarted.
     * - If this flag is not set, the device status does not have to be reset. You can restart the removed device by a calling <b>CM_Setup_DevNode</b> for the device and by specifying CM_SETUP_DEVNODE_READY. Any other operation that reenumerates the device will also restart the device. An example of an operation that reenumerates a device is calling <b>CM_Reenumerate_DevNode</b> for the device, detaching and reattaching the device, or restarting the computer. |
     * 
     * Windows applications that do not require the low-level operation <b>CM_Query_And_Remove_SubTree</b> should use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-propertychange">DIF_PROPERTYCHANGE</a> request to disable a device instead of using <b>CM_Query_And_Remove_SubTree</b> to remove a device. The DIF_PROPERTYCHANGE request can be used to enable, disable, restart, stop, or change the properties of a device.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnAncestor Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the local machine.
     * @param {Pointer<Int32>} pVetoType (<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.
     * @param {Pointer<PSTR>} pszVetoName (<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the other CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtreea
     */
    static CM_Query_And_Remove_SubTreeA(dnAncestor, pVetoType, pszVetoName, ulNameLength, ulFlags) {
        pszVetoName := pszVetoName is String? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Query_And_Remove_SubTreeA", "uint", dnAncestor, "ptr", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Query_And_Remove_SubTree function checks whether a device instance and its children can be removed and, if so, it removes them. (Unicode)
     * @remarks
     * The purpose of the <b>CM_Query_And_Remove_SubTree</b> function is to allow an application to prepare a device for safe removal from the local machine. Use this function to remove devices only if a driver has not set the <b>SurpriseRemovalOK</b> member of <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_device_capabilities">DEVICE_CAPABILITIES</a>. If a driver has set <b>SurpriseRemovalOK</b>, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_device_ejectw">CM_Request_Device_Eject</a> instead of <b>CM_Query_And_Remove_SubTree</b>.
     * 
     * <b>CM_Query_And_Remove_SubTree</b> supports setting the flags parameter <i>ulFlags</i> with one of the following two flags; these flags apply only if Windows or an installer vetoes the removal of a device: 
     * 
     * | Flag | Description |
     * |------|-------------|
     * | CM_REMOVE_UI_OK | The function allows a user dialog box to be displayed to indicate the reason for the veto. This is the default flag setting. |
     * | CM_REMOVE_UI_NOT_OK | The function suppresses the display of a user dialog box that indicates the reason for the veto. |
     * 
     * Beginning with Windows XP, <b>CM_Query_And_Remove_SubTree</b> also supports setting the following additional flag; this flag applies only if the function successfully removes the device instance:
     * 
     * 
     * | Flag | Description |
     * |------|-------------|
     * | CM_REMOVE_NO_RESTART | If this flag is set, the function configures the device status such that the device cannot be restarted until after the device status is reset. |
     * 
     * The device status is reset by the one of the following:
     * - Calling [CM_Setup_DevNode](nf-cfgmgr32-cm_setup_devnode.md) for the device and specifying CM_SETUP_DEVNODE_RESET. After the device status is reset in this manner, the device can be restarted by calling [CM_Reenumerate_DevNode](nf-cfgmgr32-cm_reenumerate_devnode.md) for the device instance. After resetting the device status, any other operation that enumerates the device will also restart the device, for example, if the Device Manager is used to reenumerate devices.
     * - The device is detached and reattached, or the computer is restarted. In this case, the device status will be reset and the device will be restarted.
     * - If this flag is not set, the device status does not have to be reset. You can restart the removed device by a calling <b>CM_Setup_DevNode</b> for the device and by specifying CM_SETUP_DEVNODE_READY. Any other operation that reenumerates the device will also restart the device. An example of an operation that reenumerates a device is calling <b>CM_Reenumerate_DevNode</b> for the device, detaching and reattaching the device, or restarting the computer. |
     * 
     * 
     * 
     * 
     * Windows applications that do not require the low-level operation <b>CM_Query_And_Remove_SubTree</b> should use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-propertychange">DIF_PROPERTYCHANGE</a> request to disable a device instead of using <b>CM_Query_And_Remove_SubTree</b> to remove a device. The DIF_PROPERTYCHANGE request can be used to enable, disable, restart, stop, or change the properties of a device. 
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnAncestor Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the local machine.
     * @param {Pointer<Int32>} pVetoType (<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.
     * @param {Pointer<PWSTR>} pszVetoName (<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the other CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtreew
     * @since windows5.0
     */
    static CM_Query_And_Remove_SubTreeW(dnAncestor, pVetoType, pszVetoName, ulNameLength, ulFlags) {
        pszVetoName := pszVetoName is String? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Query_And_Remove_SubTreeW", "uint", dnAncestor, "ptr", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Query_And_Remove_SubTree_Ex function checks whether a device instance and its children can be removed and, if so, it removes them. (ANSI)
     * @remarks
     * The purpose of the <b>CM_Query_And_Remove_SubTree_Ex</b> function is to allow an application to prepare a device for safe removal from a remote machine. Use this function to remove devices only if a driver has not set the <b>SurpriseRemovalOK</b> member of <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_device_capabilities">DEVICE_CAPABILITIES</a>. If a driver has set <b>SurpriseRemovalOK</b>, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_device_eject_exa">CM_Request_Device_Eject_Ex</a> instead of <b>CM_Query_And_Remove_SubTree_Ex</b>.
     * 
     * <b>CM_Query_And_Remove_SubTree_Ex</b> supports setting the flags parameter <i>ulFlags</i> with one of the following two flags; these flags apply only if Windows or an installer vetoes the removal of a device:
     * 
     * Beginning with Windows XP, <b>CM_Query_And_Remove_SubTree_Ex</b> also supports setting the following additional flag; this flag applies only if the function successfully removes the device instance:
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/">Device installation applications</a> that do not require the low-level operation of <b>CM_Query_And_Remove_SubTree_Ex</b> should use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-propertychange">DIF_PROPERTYCHANGE</a> request to disable a device instead of using <b>CM_Query_And_Remove_SubTree_Ex</b> to remove a device. The DIF_PROPERTYCHANGE request can be used to enable, disable, restart, stop, or change the properties of a device.
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     * Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnAncestor Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<Int32>} pVetoType (<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.
     * @param {Pointer<PSTR>} pszVetoName (<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtree_exa
     */
    static CM_Query_And_Remove_SubTree_ExA(dnAncestor, pVetoType, pszVetoName, ulNameLength, ulFlags, hMachine) {
        pszVetoName := pszVetoName is String? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Query_And_Remove_SubTree_ExA", "uint", dnAncestor, "ptr", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Query_And_Remove_SubTree_Ex function checks whether a device instance and its children can be removed and, if so, it removes them. (Unicode)
     * @remarks
     * The purpose of the <b>CM_Query_And_Remove_SubTree_Ex</b> function is to allow an application to prepare a device for safe removal from a remote machine. Use this function to remove devices only if a driver has not set the <b>SurpriseRemovalOK</b> member of <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_device_capabilities">DEVICE_CAPABILITIES</a>. If a driver has set <b>SurpriseRemovalOK</b>, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_device_eject_exw">CM_Request_Device_Eject_Ex</a> instead of <b>CM_Query_And_Remove_SubTree_Ex</b>.
     * 
     * <b>CM_Query_And_Remove_SubTree_Ex</b> supports setting the flags parameter <i>ulFlags</i> with one of the following two flags; these flags apply only if Windows or an installer vetoes the removal of a device: 
     * 
     * 
     * 
     * Beginning with Windows XP, <b>CM_Query_And_Remove_SubTree_Ex</b> also supports setting the following additional flag; this flag applies only if the function successfully removes the device instance: 
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/">Device installation applications</a> that do not require the low-level operation of <b>CM_Query_And_Remove_SubTree_Ex</b> should use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-propertychange">DIF_PROPERTYCHANGE</a> request to disable a device instead of using <b>CM_Query_And_Remove_SubTree_Ex</b> to remove a device. The DIF_PROPERTYCHANGE request can be used to enable, disable, restart, stop, or change the properties of a device. 
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnAncestor Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<Int32>} pVetoType (<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.
     * @param {Pointer<PWSTR>} pszVetoName (<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtree_exw
     * @since windows5.0
     */
    static CM_Query_And_Remove_SubTree_ExW(dnAncestor, pVetoType, pszVetoName, ulNameLength, ulFlags, hMachine) {
        pszVetoName := pszVetoName is String? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Query_And_Remove_SubTree_ExW", "uint", dnAncestor, "ptr", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Request_Device_Eject function prepares a local device instance for safe removal, if the device is removable. If the device can be physically ejected, it will be. (ANSI)
     * @remarks
     * If <i>pszVetoName</i> is <b>NULL</b>, the PnP manager displays a message to the user indicating the device was removed or, if the request failed, identifying the reason for the failure. If <i>pszVetoName</i> is not <b>NULL</b>, the PnP manager does not display a message. (Note, however, that for Microsoft Windows 2000 only, the PnP manager displays a message even if <i>pszVetoName</i> is not <b>NULL</b>, if the device's CM_DEVCAP_DOCKDEVICE capability is set.)
     * 
     * Callers of <b>CM_Request_Device_Eject</b> sometimes require <b>SeUndockPrivilege</b> or <b>SeLoadDriverPrivilege</b>, as follows:
     * 
     * <ul>
     * <li>
     * If the device's CM_DEVCAP_DOCKDEVICE capability is set (the device is a "dock" device), callers must have <b>SeUndockPrivilege</b>. (<b>SeLoadDriverPrivilege</b> is not required.)
     * 
     * </li>
     * <li>
     * If the device's CM_DEVCAP_DOCKDEVICE capability is not set (the device is not a "dock" device), <i>and</i> if the calling process is either not interactive or is running in a multi-user environment in a session not attached to the physical console (such as a remote Terminal Services session), callers of this function must have <b>SeLoadDriverPrivilege</b>. 
     * 
     * </li>
     * </ul>
     * Privileges are described in the Microsoft Windows SDK documentation.
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Pointer<Int32>} pVetoType (<i>Optional</i>.) If not <b>NULL</b>, this points to a location that, if the removal request fails, receives a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value indicating the reason for the failure.
     * @param {Pointer<PSTR>} pszVetoName (<i>Optional</i>.) If not <b>NULL</b>, this is a caller-supplied pointer to a string buffer that receives a text string. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags Not used.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_request_device_ejecta
     */
    static CM_Request_Device_EjectA(dnDevInst, pVetoType, pszVetoName, ulNameLength, ulFlags) {
        pszVetoName := pszVetoName is String? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Request_Device_EjectA", "uint", dnDevInst, "ptr", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Request_Device_Eject_Ex function prepares a local or a remote device instance for safe removal, if the device is removable. If the device can be physically ejected, it will be. (ANSI)
     * @remarks
     * If <i>pszVetoName</i> is <b>NULL</b>, the PnP manager displays a message to the user indicating the device was removed or, if the request failed, identifying the reason for the failure. If <i>pszVetoName</i> is not <b>NULL</b>, the PnP manager does not display a message. (Note, however, that for Microsoft Windows 2000 only, the PnP manager displays a message even if <i>pszVetoName</i> is not <b>NULL</b>, if the device's CM_DEVCAP_DOCKDEVICE capability is set.)
     * 
     * For remote machines, this function only works for "dock" device instances. That is, the function can only be used remotely to undock a machine. In that case, the caller must have <b>SeUndockPrivilege</b>.
     * 
     * Callers of <b>CM_Request_Eject_Ex</b> sometimes require <b>SeUndockPrivilege</b> or <b>SeLoadDriverPrivilege</b>, as follows:
     * 
     * <ul>
     * <li>
     * If the device's CM_DEVCAP_DOCKDEVICE capability is set (the device is a "dock" device), callers must have <b>SeUndockPrivilege</b>. (<b>SeLoadDriverPrivilege</b> is not required.)
     * 
     * </li>
     * <li>
     * If the device's CM_DEVCAP_DOCKDEVICE capability is not set (the device is not a "dock" device), <i>and</i> if the calling process is either not interactive or is running in a multi-user environment in a session not attached to the physical console (such as a remote Terminal Services session) callers of this function must have <b>SeLoadDriverPrivilege</b>.
     * 
     * </li>
     * </ul>
     * (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<Int32>} pVetoType (<i>Optional</i>.) If not <b>NULL</b>, this points to a location that, if the removal request fails, receives a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value indicating the reason for the failure.
     * @param {Pointer<PSTR>} pszVetoName (<i>Optional</i>.) If not <b>NULL</b>, this is a caller-supplied pointer to a string buffer that receives a text string. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags Not used.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_request_device_eject_exa
     */
    static CM_Request_Device_Eject_ExA(dnDevInst, pVetoType, pszVetoName, ulNameLength, ulFlags, hMachine) {
        pszVetoName := pszVetoName is String? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Request_Device_Eject_ExA", "uint", dnDevInst, "ptr", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Request_Device_Eject function prepares a local device instance for safe removal, if the device is removable. If the device can be physically ejected, it will be. (Unicode)
     * @remarks
     * If <i>pszVetoName</i> is <b>NULL</b>, the PnP manager displays a message to the user indicating the device was removed or, if the request failed, identifying the reason for the failure. If <i>pszVetoName</i> is not <b>NULL</b>, the PnP manager does not display a message. (Note, however, that for Microsoft Windows 2000 only, the PnP manager displays a message even if <i>pszVetoName</i> is not <b>NULL</b>, if the device's CM_DEVCAP_DOCKDEVICE capability is set.)
     * 
     * Callers of <b>CM_Request_Device_Eject</b> sometimes require <b>SeUndockPrivilege</b> or <b>SeLoadDriverPrivilege</b>, as follows:
     * 
     * <ul>
     * <li>
     * If the device's CM_DEVCAP_DOCKDEVICE capability is set (the device is a "dock" device), callers must have <b>SeUndockPrivilege</b>. (<b>SeLoadDriverPrivilege</b> is not required.)
     * 
     * </li>
     * <li>
     * If the device's CM_DEVCAP_DOCKDEVICE capability is not set (the device is not a "dock" device), <i>and</i> if the calling process is either not interactive or is running in a multi-user environment in a session not attached to the physical console (such as a remote Terminal Services session), callers of this function must have <b>SeLoadDriverPrivilege</b>. 
     * 
     * </li>
     * </ul>
     * Privileges are described in the Microsoft Windows SDK documentation.
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Pointer<Int32>} pVetoType (<i>Optional</i>.) If not <b>NULL</b>, this points to a location that, if the removal request fails, receives a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value indicating the reason for the failure.
     * @param {Pointer<PWSTR>} pszVetoName (<i>Optional</i>.) If not <b>NULL</b>, this is a caller-supplied pointer to a string buffer that receives a text string. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags Not used.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_request_device_ejectw
     * @since windows5.0
     */
    static CM_Request_Device_EjectW(dnDevInst, pVetoType, pszVetoName, ulNameLength, ulFlags) {
        pszVetoName := pszVetoName is String? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Request_Device_EjectW", "uint", dnDevInst, "ptr", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Request_Device_Eject_Ex function prepares a local or a remote device instance for safe removal, if the device is removable. If the device can be physically ejected, it will be. (Unicode)
     * @remarks
     * If <i>pszVetoName</i> is <b>NULL</b>, the PnP manager displays a message to the user indicating the device was removed or, if the request failed, identifying the reason for the failure. If <i>pszVetoName</i> is not <b>NULL</b>, the PnP manager does not display a message. (Note, however, that for Microsoft Windows 2000 only, the PnP manager displays a message even if <i>pszVetoName</i> is not <b>NULL</b>, if the device's CM_DEVCAP_DOCKDEVICE capability is set.)
     * 
     * For remote machines, this function only works for "dock" device instances. That is, the function can only be used remotely to undock a machine. In that case, the caller must have <b>SeUndockPrivilege</b>.
     * 
     * Callers of <b>CM_Request_Eject_Ex</b> sometimes require <b>SeUndockPrivilege</b> or <b>SeLoadDriverPrivilege</b>, as follows:
     * 
     * <ul>
     * <li>
     * If the device's CM_DEVCAP_DOCKDEVICE capability is set (the device is a "dock" device), callers must have <b>SeUndockPrivilege</b>. (<b>SeLoadDriverPrivilege</b> is not required.)
     * 
     * </li>
     * <li>
     * If the device's CM_DEVCAP_DOCKDEVICE capability is not set (the device is not a "dock" device), <i>and</i> if the calling process is either not interactive or is running in a multi-user environment in a session not attached to the physical console (such as a remote Terminal Services session) callers of this function must have <b>SeLoadDriverPrivilege</b>.
     * 
     * </li>
     * </ul>
     * (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Pointer<Int32>} pVetoType (<i>Optional</i>.) If not <b>NULL</b>, this points to a location that, if the removal request fails, receives a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value indicating the reason for the failure.
     * @param {Pointer<PWSTR>} pszVetoName (<i>Optional</i>.) If not <b>NULL</b>, this is a caller-supplied pointer to a string buffer that receives a text string. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.
     * @param {Integer} ulNameLength (<i>Optional</i>.) Caller-supplied value representing the length of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.
     * @param {Integer} ulFlags Not used.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_request_device_eject_exw
     * @since windows5.0
     */
    static CM_Request_Device_Eject_ExW(dnDevInst, pVetoType, pszVetoName, ulNameLength, ulFlags, hMachine) {
        pszVetoName := pszVetoName is String? StrPtr(pszVetoName) : pszVetoName

        result := DllCall("CFGMGR32.dll\CM_Request_Device_Eject_ExW", "uint", dnDevInst, "ptr", pVetoType, "ptr", pszVetoName, "uint", ulNameLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Reenumerate_DevNode function enumerates the devices identified by a specified device node and all of its children.
     * @remarks
     * If the specified device node represents a hardware or software bus device, the PnP manager queries the device's drivers for a list of children, then attempts to configure and start any child devices that were not previously configured. The PnP manager also initiates surprise-removal of devices that are no longer present (see <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-surprise-removal">IRP_MN_SURPRISE_REMOVAL</a>).
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Caller-supplied flags that specify how reenumeration should occur. This parameter can be set to a combination of the following flags, as noted:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_reenumerate_devnode
     * @since windows5.0
     */
    static CM_Reenumerate_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Reenumerate_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Reenumerate_DevNode_Ex function enumerates the devices identified by a specified device node and all of its children.
     * @remarks
     * If the specified device node represents a hardware or software bus device, the PnP manager queries the device's drivers for a list of children, then attempts to configure and start any child devices that were not previously configured. The PnP manager also initiates surprise-removal of devices that are no longer present (see <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-surprise-removal">IRP_MN_SURPRISE_REMOVAL</a>).
     * 
     * Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.)
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulFlags Caller-supplied flags that specify how reenumeration should occur. This parameter can be set to a combination of the following flags, as noted:
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_reenumerate_devnode_ex
     * @since windows5.0
     */
    static CM_Reenumerate_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Reenumerate_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {Pointer<PSTR>} pszReference 
     * @param {Pointer<PSTR>} pszDeviceInterface 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_interfacea
     */
    static CM_Register_Device_InterfaceA(dnDevInst, InterfaceClassGuid, pszReference, pszDeviceInterface, pulLength, ulFlags) {
        pszReference := pszReference is String? StrPtr(pszReference) : pszReference
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Register_Device_InterfaceA", "uint", dnDevInst, "ptr", InterfaceClassGuid, "ptr", pszReference, "ptr", pszDeviceInterface, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {Pointer<PWSTR>} pszReference 
     * @param {Pointer<PWSTR>} pszDeviceInterface 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_interfacew
     */
    static CM_Register_Device_InterfaceW(dnDevInst, InterfaceClassGuid, pszReference, pszDeviceInterface, pulLength, ulFlags) {
        pszReference := pszReference is String? StrPtr(pszReference) : pszReference
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Register_Device_InterfaceW", "uint", dnDevInst, "ptr", InterfaceClassGuid, "ptr", pszReference, "ptr", pszDeviceInterface, "ptr", pulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {Pointer<PSTR>} pszReference 
     * @param {Pointer<PSTR>} pszDeviceInterface 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_interface_exa
     */
    static CM_Register_Device_Interface_ExA(dnDevInst, InterfaceClassGuid, pszReference, pszDeviceInterface, pulLength, ulFlags, hMachine) {
        pszReference := pszReference is String? StrPtr(pszReference) : pszReference
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Register_Device_Interface_ExA", "uint", dnDevInst, "ptr", InterfaceClassGuid, "ptr", pszReference, "ptr", pszDeviceInterface, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Pointer<Guid>} InterfaceClassGuid 
     * @param {Pointer<PWSTR>} pszReference 
     * @param {Pointer<PWSTR>} pszDeviceInterface 
     * @param {Pointer<UInt32>} pulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_interface_exw
     */
    static CM_Register_Device_Interface_ExW(dnDevInst, InterfaceClassGuid, pszReference, pszDeviceInterface, pulLength, ulFlags, hMachine) {
        pszReference := pszReference is String? StrPtr(pszReference) : pszReference
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Register_Device_Interface_ExW", "uint", dnDevInst, "ptr", InterfaceClassGuid, "ptr", pszReference, "ptr", pszDeviceInterface, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Problem_Ex function sets a problem code for a device that is installed in a local or a remote machine.
     * @remarks
     * Use this function to set a problem code for a device that is installed in a local or a remote machine. You can also use the following functions to set a device's problem code and to obtain the problem code set for the device:
     * 
     * <ul>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status">CM_Get_DevNode_Status</a> returns the problem code set for a device installed in a local machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status_ex">CM_Get_DevNode_Status_Ex</a> returns the problem code set for a device installed in a local or a remote machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_problem">CM_Set_DevNode_Problem</a> sets a problem code for a device installed in a local machine.
     * 
     * </li>
     * </ul>
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * 
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ulProblem Supplies a problem code, which is zero or one of the CM_PROB_Xxx flags that are described in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-manager-error-messages">Device Manager Error Messages</a>. A value of zero indicates that a problem code is not set for the device.
     * @param {Integer} ulFlags Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_problem_ex
     * @since windows5.0
     */
    static CM_Set_DevNode_Problem_Ex(dnDevInst, ulProblem, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Problem_Ex", "uint", dnDevInst, "uint", ulProblem, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Problem function sets a problem code for a device that is installed in a local machine.
     * @remarks
     * Use this function to set a problem code for a device that is installed in a local machine. You can also use the following functions to set a device's problem code and to obtain the problem code set for the device:
     * 
     * <ul>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status">CM_Get_DevNode_Status</a> returns the problem code set for a device installed in a local machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status_ex">CM_Get_DevNode_Status_Ex</a> returns the problem code set for a device installed in a local or a remote machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_problem_ex">CM_Set_DevNode_Problem_Ex</a> sets a problem code for a device installed in a local or a remote machine.
     * 
     * </li>
     * </ul>
     * For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProblem Supplies a problem code, which is zero or one of the CM_PROB_Xxx flags that are described in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-manager-error-messages">Device Manager Error Messages</a>. A value of zero indicates that a problem is not set for the device.
     * @param {Integer} ulFlags Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_problem
     * @since windows5.0
     */
    static CM_Set_DevNode_Problem(dnDevInst, ulProblem, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Problem", "uint", dnDevInst, "uint", ulProblem, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} pszDeviceInterface 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_device_interfacea
     */
    static CM_Unregister_Device_InterfaceA(pszDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Unregister_Device_InterfaceA", "ptr", pszDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszDeviceInterface 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_device_interfacew
     */
    static CM_Unregister_Device_InterfaceW(pszDeviceInterface, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Unregister_Device_InterfaceW", "ptr", pszDeviceInterface, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} pszDeviceInterface 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_device_interface_exa
     */
    static CM_Unregister_Device_Interface_ExA(pszDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Unregister_Device_Interface_ExA", "ptr", pszDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszDeviceInterface 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_device_interface_exw
     */
    static CM_Unregister_Device_Interface_ExW(pszDeviceInterface, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Unregister_Device_Interface_ExW", "ptr", pszDeviceInterface, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_driver
     */
    static CM_Register_Device_Driver(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Register_Device_Driver", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_device_driver_ex
     */
    static CM_Register_Device_Driver_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Register_Device_Driver_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnAncestor 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_remove_subtree
     */
    static CM_Remove_SubTree(dnAncestor, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Remove_SubTree", "uint", dnAncestor, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnAncestor 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_remove_subtree_ex
     */
    static CM_Remove_SubTree_Ex(dnAncestor, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Remove_SubTree_Ex", "uint", dnAncestor, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Property function sets a device instance property.
     * @remarks
     * <b>CM_Set_DevNode_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device instance property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device instance property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that contains the property value of the device instance property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_propertyw
     * @since windows6.0.6000
     */
    static CM_Set_DevNode_PropertyW(dnDevInst, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_PropertyW", "uint", dnDevInst, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Property_ExW function sets a device instance property.
     * @remarks
     * <b>CM_Set_DevNode_Property_ExW</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device instance property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device instance property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that contains the property value of the device instance property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_property_exw
     * @since windows10.0.10240
     */
    static CM_Set_DevNode_Property_ExW(dnDevInst, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Property_ExW", "uint", dnDevInst, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Registry_Property function sets a specified device property in the registry. (ANSI)
     * @remarks
     * For information about how to use device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst A caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProperty A CM_DRP_-prefixed constant value that identifies the device property to be set in the registry. These constants are defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Void>} Buffer A pointer to a caller-supplied buffer that supplies the requested device property, formatted appropriately for the property's data type.
     * @param {Integer} ulLength The length, in bytes, of the supplied device property.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_registry_propertya
     */
    static CM_Set_DevNode_Registry_PropertyA(dnDevInst, ulProperty, Buffer, ulLength, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Registry_PropertyA", "uint", dnDevInst, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Set_DevNode_Registry_Property function sets a specified device property in the registry. (Unicode)
     * @remarks
     * For information about how to use device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.
     * @param {Integer} dnDevInst A caller-supplied device instance handle that is bound to the local machine.
     * @param {Integer} ulProperty A CM_DRP_-prefixed constant value that identifies the device property to be set in the registry. These constants are defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Void>} Buffer A pointer to a caller-supplied buffer that supplies the requested device property, formatted appropriately for the property's data type.
     * @param {Integer} ulLength The length, in bytes, of the supplied device property.
     * @param {Integer} ulFlags Not used, must be zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_registry_propertyw
     * @since windows5.0
     */
    static CM_Set_DevNode_Registry_PropertyW(dnDevInst, ulProperty, Buffer, ulLength, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Registry_PropertyW", "uint", dnDevInst, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulProperty 
     * @param {Pointer<Void>} Buffer 
     * @param {Integer} ulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_registry_property_exa
     */
    static CM_Set_DevNode_Registry_Property_ExA(dnDevInst, ulProperty, Buffer, ulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Registry_Property_ExA", "uint", dnDevInst, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulProperty 
     * @param {Pointer<Void>} Buffer 
     * @param {Integer} ulLength 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_devnode_registry_property_exw
     */
    static CM_Set_DevNode_Registry_Property_ExW(dnDevInst, ulProperty, Buffer, ulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_DevNode_Registry_Property_ExW", "uint", dnDevInst, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_Device_Interface_Property function sets a device property of a device interface.
     * @remarks
     * <b>CM_Set_Device_Interface_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance for which to set a property for.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device interface property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device interface property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that contains the property value of the device interface property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_device_interface_propertyw
     * @since windows6.0.6000
     */
    static CM_Set_Device_Interface_PropertyW(pszDeviceInterface, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Set_Device_Interface_PropertyW", "ptr", pszDeviceInterface, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Set_Device_Interface_Property_ExW function sets a device property of a device interface.
     * @remarks
     * <b>CM_Set_Device_Interface_Property_ExW</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<PWSTR>} pszDeviceInterface Pointer to a string that identifies the device interface instance for which to set a property for.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device interface property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device interface property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that contains the property value of the device interface property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_device_interface_property_exw
     * @since windows10.0.10240
     */
    static CM_Set_Device_Interface_Property_ExW(pszDeviceInterface, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        pszDeviceInterface := pszDeviceInterface is String? StrPtr(pszDeviceInterface) : pszDeviceInterface

        result := DllCall("CFGMGR32.dll\CM_Set_Device_Interface_Property_ExW", "ptr", pszDeviceInterface, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Is_Dock_Station_Present function identifies whether a docking station is present in a local machine.
     * @remarks
     * Use this function to determine whether a docking station is present in a local machine. You can also use the following related functions with docking stations:
     * 
     * <ul>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present_ex">CM_Is_Dock_Station_Present_Ex</a> identifies whether a docking station is present in a local or a remote machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_eject_pc">CM_Request_Eject_PC</a> requests that a portable PC, which is inserted in a local docking station, be ejected.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_eject_pc_ex">CM_Request_Eject_PC_Ex</a> requests that a portable PC, which is inserted in a local or a remote docking station, be ejected.
     * 
     * </li>
     * </ul>
     * @param {Pointer<Int32>} pbPresent Pointer to a Boolean value that indicates whether a docking station is present in a local machine. The function sets *<i>pbPresent</i> to <b>TRUE</b> if a docking station is present. Otherwise, the function sets *<i>pbPresent</i> to <b>FALSE</b>.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present
     * @since windows5.0
     */
    static CM_Is_Dock_Station_Present(pbPresent) {
        result := DllCall("CFGMGR32.dll\CM_Is_Dock_Station_Present", "ptr", pbPresent, "uint")
        return result
    }

    /**
     * The CM_Is_Dock_Station_Present_Ex function identifies whether a docking station is present in a local or a remote machine.
     * @remarks
     * Use this function to determine whether a docking station is present in a local or a remote machine. You can also use the following related functions with docking stations:
     * 
     * <ul>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present">CM_Is_Dock_Station_Present</a> identifies whether a docking station is present in a local machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_eject_pc">CM_Request_Eject_PC</a> requests that a portable PC, which is inserted in a local docking station, be ejected.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_eject_pc_ex">CM_Request_Eject_PC_Ex</a> requests that a portable PC, which is inserted in a local or a remote docking station, be ejected.
     * 
     * </li>
     * </ul>
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer<Int32>} pbPresent Pointer to a Boolean value that indicates whether a docking station is present in a local machine. The function sets *pbPresent to <b>TRUE</b> if a docking station is present. The function sets *<i>pbPresent</i> to <b>FALSE</b> if the function cannot connect to the specified machine or a docking station is not present.
     * @param {Pointer} hMachine Supplies a machine handle that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present_ex
     * @since windows5.0
     */
    static CM_Is_Dock_Station_Present_Ex(pbPresent, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Is_Dock_Station_Present_Ex", "ptr", pbPresent, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Request_Eject_PC function requests that a portable PC, which is inserted in a local docking station, be ejected.
     * @remarks
     * Use this function to request that a portable PC, which is inserted in a local docking station, be ejected. You can also use the following related functions with docking stations:
     * 
     * <ul>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present">CM_Is_Dock_Station_Present</a> identifies whether a docking station is present in a local machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present_ex">CM_Is_Dock_Station_Present_Ex</a> identifies whether a docking station is present in a local or a remote machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_eject_pc_ex">CM_Request_Eject_PC_Ex</a> requests that a portable PC, which is inserted in a local or a remote docking station, be ejected.
     * 
     * </li>
     * </ul>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_request_eject_pc
     * @since windows5.0
     */
    static CM_Request_Eject_PC() {
        result := DllCall("CFGMGR32.dll\CM_Request_Eject_PC", "uint")
        return result
    }

    /**
     * The CM_Request_Eject_PC_Ex function requests that a portable PC, which is inserted in a local or a remote docking station, be ejected.
     * @remarks
     * Use this function to request that a portable PC, which is inserted in a local or a remote docking station, be ejected. You can also use the following related functions with docking stations:
     * 
     * <ul>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present">CM_Is_Dock_Station_Present</a> identifies whether a docking station is present in a local machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_is_dock_station_present_ex">CM_Is_Dock_Station_Present_Ex</a> identifies whether a docking station is present in a local or a remote machine.
     * 
     * </li>
     * <li>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_eject_pc">CM_Request_Eject_PC</a> requests that a portable PC, which is inserted in a local docking station, be ejected.
     * 
     * </li>
     * </ul>
     *  Functionality to access remote machines has been removed in Windows8 and Windows Server2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.
     * @param {Pointer} hMachine Supplies a machine handle that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_request_eject_pc_ex
     * @since windows5.0
     */
    static CM_Request_Eject_PC_Ex(hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Request_Eject_PC_Ex", "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} pDeviceID 
     * @param {Integer} ulConfig 
     * @param {Integer} ulValue 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_flagsa
     */
    static CM_Set_HW_Prof_FlagsA(pDeviceID, ulConfig, ulValue, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_FlagsA", "ptr", pDeviceID, "uint", ulConfig, "uint", ulValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pDeviceID 
     * @param {Integer} ulConfig 
     * @param {Integer} ulValue 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_flagsw
     */
    static CM_Set_HW_Prof_FlagsW(pDeviceID, ulConfig, ulValue, ulFlags) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_FlagsW", "ptr", pDeviceID, "uint", ulConfig, "uint", ulValue, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} pDeviceID 
     * @param {Integer} ulConfig 
     * @param {Integer} ulValue 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_flags_exa
     */
    static CM_Set_HW_Prof_Flags_ExA(pDeviceID, ulConfig, ulValue, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_Flags_ExA", "ptr", pDeviceID, "uint", ulConfig, "uint", ulValue, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pDeviceID 
     * @param {Integer} ulConfig 
     * @param {Integer} ulValue 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_flags_exw
     */
    static CM_Set_HW_Prof_Flags_ExW(pDeviceID, ulConfig, ulValue, ulFlags, hMachine) {
        pDeviceID := pDeviceID is String? StrPtr(pDeviceID) : pDeviceID

        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_Flags_ExW", "ptr", pDeviceID, "uint", ulConfig, "uint", ulValue, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Setup_DevNode function restarts a device instance that is not running because there is a problem with the device configuration.
     * @remarks
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/">Device installation applications</a> should use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-propertychange">DIF_PROPERTYCHANGE</a> request to restart a device instead of using this function. The DIF_PROPERTYCHANGE request can be used to enable, disable, restart, stop, or change the properties of a device. 
     * 
     * If a device instance does not have a problem and is already started, <b>CM_Setup_DevNode</b> returns without changing the status of the device instance.
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status">CM_Get_DevNode_Status</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status_ex">CM_Get_DevNode_Status_Ex</a> to determine the status and problem code for a device instance.
     * @param {Integer} dnDevInst A device instance handle that is bound to the local system.
     * @param {Integer} ulFlags One of the following flag values:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise it returns one of the error codes with "CR_" prefix that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_setup_devnode
     * @since windows5.0
     */
    static CM_Setup_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Setup_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_setup_devnode_ex
     */
    static CM_Setup_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Setup_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ullStartValue 
     * @param {Integer} ullEndValue 
     * @param {Pointer} rlh 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_test_range_available
     */
    static CM_Test_Range_Available(ullStartValue, ullEndValue, rlh, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Test_Range_Available", "uint", ullStartValue, "uint", ullEndValue, "ptr", rlh, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Uninstall_DevNode function removes all persistent state associated with a device instance.
     * @remarks
     * This function uninstalls the device without sending an <b>IRP_MN_QUERY_REMOVE_DEVICE</b> request or calling class installers or co-installers.       If your application will run only on a <a href="https://docs.microsoft.com/windows-hardware/drivers/develop/windows-10-editions-for-universal-drivers">Target Platform</a> of Desktop, instead of calling <b>CM_Uninstall_DevNode</b>, the application should uninstall the device by calling <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicallclassinstaller">SetupDiCallClassInstaller</a> with the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-remove">DIF_REMOVE</a> code, or by calling <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-diuninstalldevice">DiUninstallDevice</a>.
     * 
     * Use the following sequence to call this function:
     * 
     * <ol>
     * <li>Check if <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status">CM_Get_DevNode_Status</a> returns success.  This means that the device is present.</li>
     * <li>If the device is present, call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtreew">CM_Query_And_Remove_SubTree</a>.</li>
     * <li>Call <b>CM_Uninstall_DevNode</b>.</li>
     * </ol>
     * @param {Integer} dnDevInst Device instance handle that is bound to the local machine.
     * @param {Integer} ulFlags Reserved. Must be set to zero.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_uninstall_devnode
     * @since windows5.0
     */
    static CM_Uninstall_DevNode(dnDevInst, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Uninstall_DevNode", "uint", dnDevInst, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dnDevInst 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_uninstall_devnode_ex
     */
    static CM_Uninstall_DevNode_Ex(dnDevInst, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Uninstall_DevNode_Ex", "uint", dnDevInst, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_run_detection
     */
    static CM_Run_Detection(ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Run_Detection", "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_run_detection_ex
     */
    static CM_Run_Detection_Ex(ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Run_Detection_Ex", "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulHardwareProfile 
     * @param {Integer} ulFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof
     */
    static CM_Set_HW_Prof(ulHardwareProfile, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof", "uint", ulHardwareProfile, "uint", ulFlags, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} ulHardwareProfile 
     * @param {Integer} ulFlags 
     * @param {Pointer} hMachine 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_hw_prof_ex
     */
    static CM_Set_HW_Prof_Ex(ulHardwareProfile, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_HW_Prof_Ex", "uint", ulHardwareProfile, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Query_Resource_Conflict_List function identifies device instances having resource requirements that conflict with a specified device instance's resource description.
     * @remarks
     * When calling <b>CM_Query_Resource_Conflict_List</b>, specify a device instance handle and resource descriptor. (Resource descriptors for existing device nodes can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_res_des_data">CM_Get_Res_Des_Data</a>.) These parameters indicate the specific resources you'd like a specific device to use. The resulting conflict list identifies devices that use the same resources, along with resources reserved by the machine.
     * 
     * After calling <b>CM_Query_Resource_Conflict_List</b>, an application can call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count">CM_Get_Resource_Conflict_Count</a> to determine the number of conflicts contained in the resource conflict list. (The number of conflicts can be zero.) Then the application can call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_detailsw">CM_Get_Resource_Conflict_Details</a> for each entry in the conflict list.
     * 
     * After an application has finished using the handle received for <i>pclConflictList</i>, it must call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_free_resource_conflict_handle">CM_Free_Resource_Conflict_Handle</a>.
     * 
     * For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>.
     * @param {Pointer<UIntPtr>} pclConflictList Caller-supplied address of a location to receive a handle to a conflict list.
     * @param {Integer} dnDevInst Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.
     * @param {Integer} ResourceID Caller-supplied resource type identifier. This must be one of the <b>ResType_</b>-prefixed constants defined in <i>Cfgmgr32.h</i>.
     * @param {Pointer<Void>} ResourceData Caller-supplied pointer to a resource descriptor, which can be one of the structures listed under the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_add_res_des">CM_Add_Res_Des</a> function's description of <i>ResourceData</i>.
     * @param {Integer} ResourceLen Caller-supplied length of the structure pointed to by <i>ResourceData</i>.
     * @param {Integer} ulFlags Not used, must be zero.
     * @param {Pointer} hMachine Caller-supplied machine handle to which the caller-supplied device instance handle is bound.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * 
     * <div class="alert"><b>Note</b>Starting with Windows8, <b>CM_Query_Resource_Conflict_List</b> returns CR_CALL_NOT_IMPLEMENTED when used in a Wow64 scenario. To request information about the hardware resources on a local machine it is necessary implement an architecture-native version of the application using the hardware resource APIs. For example: An AMD64 application for AMD64 systems.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list
     * @since windows5.0
     */
    static CM_Query_Resource_Conflict_List(pclConflictList, dnDevInst, ResourceID, ResourceData, ResourceLen, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Query_Resource_Conflict_List", "ptr", pclConflictList, "uint", dnDevInst, "uint", ResourceID, "ptr", ResourceData, "uint", ResourceLen, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Free_Resource_Conflict_Handle function invalidates a handle to a resource conflict list, and frees the handle's associated memory allocation.
     * @remarks
     * An application must call <b>CM_Free_Resource_Conflict_Handle</b> after it has finished using the handle that was obtained calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @param {Pointer} clConflictList Caller-supplied handle to be freed. This conflict list handle must have been previously obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_free_resource_conflict_handle
     * @since windows5.0
     */
    static CM_Free_Resource_Conflict_Handle(clConflictList) {
        result := DllCall("CFGMGR32.dll\CM_Free_Resource_Conflict_Handle", "ptr", clConflictList, "uint")
        return result
    }

    /**
     * The CM_Get_Resource_Conflict_Count function obtains the number of conflicts contained in a specified resource conflict list.
     * @remarks
     * The count value obtained by calling <b>CM_Get_Resource_Conflict_Count</b> can be used to determine the number of times to call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_detailsw">CM_Get_Resource_Conflict_Details</a>, which supplies information about each conflict.
     * 
     * If there are no entries in the conflict list, the location supplied by <i>pulCount</i> will receive zero.
     * @param {Pointer} clConflictList Caller-supplied handle to a conflict list, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @param {Pointer<UInt32>} pulCount Caller-supplied address of a location to receive the conflict count.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count
     * @since windows5.0
     */
    static CM_Get_Resource_Conflict_Count(clConflictList, pulCount) {
        result := DllCall("CFGMGR32.dll\CM_Get_Resource_Conflict_Count", "ptr", clConflictList, "ptr", pulCount, "uint")
        return result
    }

    /**
     * The CM_Get_Resource_Conflict_Details function obtains the details about one of the resource conflicts in a conflict list. (ANSI)
     * @remarks
     * To determine conflicting resource requirements between a specified device and other devices on a machine, use the following steps.
     * 
     * <ol>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a> to obtain a handle to a list of resource conflicts.
     * 
     * </li>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count">CM_Get_Resource_Conflict_Count</a> to determine the number of conflicts contained in the resource conflict list.
     * 
     * </li>
     * <li>
     * Call <b>CM_Get_Resource_Conflict_Details</b> for each entry in the conflict list.
     * 
     * </li>
     * </ol>
     * The following conflicts are typically not reported:
     * 
     * <ul>
     * <li>
     * If there are multiple conflicts for a resource, and the owners of only some of the conflicts can be determined, the conflicts without identifiable owners are not reported.
     * 
     * </li>
     * <li>
     * Conflicts that appear to be with the specified device (that is, the device conflicts with itself) are not reported.
     * 
     * </li>
     * <li>
     * If multiple non-Plug and Play devices use the same driver, resource conflicts among these devices might not be reported.
     * 
     * </li>
     * </ul>
     * Sometimes, resources assigned to the HAL might be reported as either conflicting with the HAL or not available.
     * @param {Pointer} clConflictList Caller-supplied handle to a conflict list, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @param {Integer} ulIndex Caller-supplied value used as an index into the conflict list. This value can be from zero to one less than the number returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count">CM_Get_Resource_Conflict_Count</a>.
     * @param {Pointer<CONFLICT_DETAILS_A>} pConflictDetails Caller-supplied address of a <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ns-cfgmgr32-conflict_details_a">CONFLICT_DETAILS</a> structure to receive conflict details. The caller must supply values for the structure's <i>CD_ulSize</i> and <i>CD_ulMask</i> structures.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_detailsa
     */
    static CM_Get_Resource_Conflict_DetailsA(clConflictList, ulIndex, pConflictDetails) {
        result := DllCall("CFGMGR32.dll\CM_Get_Resource_Conflict_DetailsA", "ptr", clConflictList, "uint", ulIndex, "ptr", pConflictDetails, "uint")
        return result
    }

    /**
     * The CM_Get_Resource_Conflict_Details function obtains the details about one of the resource conflicts in a conflict list. (Unicode)
     * @remarks
     * To determine conflicting resource requirements between a specified device and other devices on a machine, use the following steps.
     * 
     * <ol>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a> to obtain a handle to a list of resource conflicts.
     * 
     * </li>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count">CM_Get_Resource_Conflict_Count</a> to determine the number of conflicts contained in the resource conflict list.
     * 
     * </li>
     * <li>
     * Call <b>CM_Get_Resource_Conflict_Details</b> for each entry in the conflict list.
     * 
     * </li>
     * </ol>
     * The following conflicts are typically not reported:
     * 
     * <ul>
     * <li>
     * If there are multiple conflicts for a resource, and the owners of only some of the conflicts can be determined, the conflicts without identifiable owners are not reported.
     * 
     * </li>
     * <li>
     * Conflicts that appear to be with the specified device (that is, the device conflicts with itself) are not reported.
     * 
     * </li>
     * <li>
     * If multiple non-Plug and Play devices use the same driver, resource conflicts among these devices might not be reported.
     * 
     * </li>
     * </ul>
     * Sometimes, resources assigned to the HAL might be reported as either conflicting with the HAL or not available.
     * @param {Pointer} clConflictList Caller-supplied handle to a conflict list, obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_query_resource_conflict_list">CM_Query_Resource_Conflict_List</a>.
     * @param {Integer} ulIndex Caller-supplied value used as an index into the conflict list. This value can be from zero to one less than the number returned by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_count">CM_Get_Resource_Conflict_Count</a>.
     * @param {Pointer<CONFLICT_DETAILS_W>} pConflictDetails Caller-supplied address of a <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ns-cfgmgr32-conflict_details_a">CONFLICT_DETAILS</a> structure to receive conflict details. The caller must supply values for the structure's <i>CD_ulSize</i> and <i>CD_ulMask</i> structures.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_resource_conflict_detailsw
     * @since windows5.0
     */
    static CM_Get_Resource_Conflict_DetailsW(clConflictList, ulIndex, pConflictDetails) {
        result := DllCall("CFGMGR32.dll\CM_Get_Resource_Conflict_DetailsW", "ptr", clConflictList, "uint", ulIndex, "ptr", pConflictDetails, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Property function retrieves a device property that is set for a device interface class or device setup class.
     * @remarks
     * <b>CM_Get_Class_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a> or <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to retrieve a device property that is set for the device class. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device class property.
     * @param {Pointer<UInt32>} PropertyType Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device class property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that receives the requested device class property. <b>CM_Get_Class_Property</b> retrieves the requested property value only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<UInt32>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If the <i>PropertyBuffer</i> parameter is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Class_Property</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Class property flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_propertyw
     * @since windows6.0.6000
     */
    static CM_Get_Class_PropertyW(ClassGUID, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_PropertyW", "ptr", ClassGUID, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "ptr", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Property_ExW function retrieves a device property that is set for a device interface class or device setup class.
     * @remarks
     * <b>CM_Get_Class_Property_ExW</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a> or <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to retrieve a device property that is set for the device class. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device class property.
     * @param {Pointer<UInt32>} PropertyType Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device class property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base data type is modified, a property-data-type modifier.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that receives the requested device class property. <b>CM_Get_Class_Property_ExW</b> retrieves the requested property value only if the buffer is large enough to hold all the property value data. The pointer can be NULL.
     * @param {Pointer<UInt32>} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If the <i>PropertyBuffer</i> parameter is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Class_Property_ExW</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.
     * @param {Integer} ulFlags Class property flags:
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_property_exw
     * @since windows10.0.10240
     */
    static CM_Get_Class_Property_ExW(ClassGUID, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Property_ExW", "ptr", ClassGUID, "ptr", PropertyKey, "ptr", PropertyType, "ptr", PropertyBuffer, "ptr", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Property_Keys function retrieves an array of the device property keys that represent the device properties that are set for a device interface class or device setup class.
     * @remarks
     * <b>CM_Get_Class_Property_Keys</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a> or <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to retrieve the property keys for. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device class. The pointer is optional and can be NULL.
     * @param {Pointer<UInt32>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero. As output, if <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_Class_Property_Keys</b> returns the count of the keys, in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Class property key flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_property_keys
     * @since windows6.0.6000
     */
    static CM_Get_Class_Property_Keys(ClassGUID, PropertyKeyArray, PropertyKeyCount, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Property_Keys", "ptr", ClassGUID, "ptr", PropertyKeyArray, "ptr", PropertyKeyCount, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Property_Keys_Ex function retrieves an array of the device property keys that represent the device properties that are set for a device interface class or device setup class.
     * @remarks
     * <b>CM_Get_Class_Property_Keys_Ex</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a> or <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to retrieve the property keys for. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKeyArray Pointer to a buffer that receives an array of <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed values, where each value is a device property key that represents a device property that is set for the device class. The pointer is optional and can be NULL.
     * @param {Pointer<UInt32>} PropertyKeyCount The size, in <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a>-typed units, of the <i>PropertyKeyArray</i> buffer. If <i>PropertyKeyArray</i> is set to NULL, <i>*PropertyKeyCount</i> must be set to zero. As output, if <i>PropertyKeyArray</i> is not large enough to hold all the property key data, <b>CM_Get_Class_Property_Keys_Ex</b> returns the count of the keys, in <i>*PropertyKeyCount</i>.
     * @param {Integer} ulFlags Class property key flags:
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_property_keys_ex
     * @since windows10.0.10240
     */
    static CM_Get_Class_Property_Keys_Ex(ClassGUID, PropertyKeyArray, PropertyKeyCount, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Property_Keys_Ex", "ptr", ClassGUID, "ptr", PropertyKeyArray, "ptr", PropertyKeyCount, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_Class_Property function sets a class property for a device setup class or a device interface class.
     * @remarks
     * <b>CM_Set_Class_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a> or <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to set a device property. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device class property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device class property. To delete a property, set this to DEVPROP_TYPE_EMPTY.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that contains the property value of the device class property. If either the property or the data is to be deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Class property flags:
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_class_propertyw
     * @since windows6.0.6000
     */
    static CM_Set_Class_PropertyW(ClassGUID, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags) {
        result := DllCall("CFGMGR32.dll\CM_Set_Class_PropertyW", "ptr", ClassGUID, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "uint")
        return result
    }

    /**
     * The CM_Set_Class_Property_ExW function sets a class property for a device setup class or a device interface class.
     * @remarks
     * <b>CM_Set_Class_Property_ExW</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.
     * @param {Pointer<Guid>} ClassGUID Pointer to the GUID that identifies the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a> or <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to set a device property. For information about specifying the class type, see the <i>ulFlags</i> parameter.
     * @param {Pointer<DEVPROPKEY>} PropertyKey Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device class property to set.
     * @param {Integer} PropertyType A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device class property. To delete a property, set this to <b>DEVPROP_TYPE_EMPTY</b>.
     * @param {Pointer<Byte>} PropertyBuffer Pointer to a buffer that contains the property value of the device class property. If either the property or the data is to be deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} PropertyBufferSize The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.
     * @param {Integer} ulFlags Class property flags:
     * @param {Pointer} hMachine Caller-supplied machine handle, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>.
     * 
     * <div class="alert"><b>Note</b>Using this function to access remote machines is not supported beginning with Windows8 and Windows Server2012, as this functionality has been removed.</div>
     * <div></div>
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_class_property_exw
     * @since windows10.0.10240
     */
    static CM_Set_Class_Property_ExW(ClassGUID, PropertyKey, PropertyType, PropertyBuffer, PropertyBufferSize, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_Class_Property_ExW", "ptr", ClassGUID, "ptr", PropertyKey, "uint", PropertyType, "ptr", PropertyBuffer, "uint", PropertyBufferSize, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Registry_Property function retrieves a device setup class property. (ANSI)
     * @remarks
     * To determine the size, in bytes, of a property before attempting to retrieve the property, first call <b>CM_Get_Class_Registry_Property</b>, supplying a <b>NULL</b><i>Buffer</i> pointer and a <b>*</b><i>pulLength </i> value of zero. In response to such a call, the function does not retrieve the property, but sets <b>*</b><i>pulLength</i> to the size of the requested property and returns CR_BUFFER_SMALL. After obtaining the property size, call <b>CM_Get_Class_Registry_Property</b> again, supplying a <i>Buffer</i> pointer to the buffer to receive the property data and supplying the property size in <b>*</b><i>pulLength</i>.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that represents the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to retrieve a property.
     * @param {Integer} ulProperty A value of type ULONG that identifies the property to be retrieved. This value must be one of the following CM_CRP_<i>Xxx</i> values that are defined in <i>Cfgmgr32.h</i>:
     * @param {Pointer<UInt32>} pulRegDataType A pointer to a variable of type ULONG that receives the REG_<i>Xxx</i> constant that represents the data type of the requested property. The REG_<i>Xxx</i> constants are defined in <i>Winnt.h</i> and are described in the <b>Type</b> member of the <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_key_value_basic_information">KEY_VALUE_BASIC_INFORMATION</a> structure. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<Void>} Buffer A pointer to a buffer that receives the requested property data. For more information about this parameter and the buffer-size parameter <i>pulLength</i>, see the following <b>Remarks</b> section.
     * @param {Pointer<UInt32>} pulLength A pointer to variable of type ULONG whose value, on input, is the size, in bytes, of the buffer that is supplied by <i>Buffer</i>. On return, <b>CM_Get_Class_Registry_Property </b> sets this variable to the size, in bytes, of the requested property.
     * @param {Integer} ulFlags Reserved for internal use only. Must be set to zero.
     * @param {Pointer} hMachine A handle to a remote machine from which to retrieve the specified device class property. This parameter is optional, and, if it is set to <b>NULL</b>, the property is retrieved from the local machine.
     * @returns {Integer} If the operation succeeds, <b>CM_Get_Class_Registry_Property </b> returns CR_SUCCESS. Otherwise, the function returns one of the other CR_<i>Xxx</i> status codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_registry_propertya
     */
    static CM_Get_Class_Registry_PropertyA(ClassGuid, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Registry_PropertyA", "ptr", ClassGuid, "uint", ulProperty, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Get_Class_Registry_Property function retrieves a device setup class property. (Unicode)
     * @remarks
     * To determine the size, in bytes, of a property before attempting to retrieve the property, first call <b>CM_Get_Class_Registry_Property</b>, supplying a <b>NULL</b><i>Buffer</i> pointer and a <b>*</b><i>pulLength </i> value of zero. In response to such a call, the function does not retrieve the property, but sets <b>*</b><i>pulLength</i> to the size of the requested property and returns CR_BUFFER_SMALL. After obtaining the property size, call <b>CM_Get_Class_Registry_Property</b> again, supplying a <i>Buffer</i> pointer to the buffer to receive the property data and supplying the property size in <b>*</b><i>pulLength</i>.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that represents the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-setup-classes">device setup class</a> for which to retrieve a property.
     * @param {Integer} ulProperty A value of type ULONG that identifies the property to be retrieved. This value must be one of the following CM_CRP_<i>Xxx</i> values that are defined in <i>Cfgmgr32.h</i>:
     * @param {Pointer<UInt32>} pulRegDataType A pointer to a variable of type ULONG that receives the REG_<i>Xxx</i> constant that represents the data type of the requested property. The REG_<i>Xxx</i> constants are defined in <i>Winnt.h</i> and are described in the <b>Type</b> member of the <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_key_value_basic_information">KEY_VALUE_BASIC_INFORMATION</a> structure. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<Void>} Buffer A pointer to a buffer that receives the requested property data. For more information about this parameter and the buffer-size parameter <i>pulLength</i>, see the following <b>Remarks</b> section.
     * @param {Pointer<UInt32>} pulLength A pointer to variable of type ULONG whose value, on input, is the size, in bytes, of the buffer that is supplied by <i>Buffer</i>. On return, <b>CM_Get_Class_Registry_Property </b> sets this variable to the size, in bytes, of the requested property.
     * @param {Integer} ulFlags Reserved for internal use only. Must be set to zero.
     * @param {Pointer} hMachine A handle to a remote machine from which to retrieve the specified device class property. This parameter is optional, and, if it is set to <b>NULL</b>, the property is retrieved from the local machine.
     * @returns {Integer} If the operation succeeds, <b>CM_Get_Class_Registry_Property </b> returns CR_SUCCESS. Otherwise, the function returns one of the other CR_<i>Xxx</i> status codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_class_registry_propertyw
     * @since windows5.0
     */
    static CM_Get_Class_Registry_PropertyW(ClassGuid, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Get_Class_Registry_PropertyW", "ptr", ClassGuid, "uint", ulProperty, "ptr", pulRegDataType, "ptr", Buffer, "ptr", pulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_Class_Registry_Property function sets or deletes a property of a device setup class. (ANSI)
     * @remarks
     * If <i>Buffer</i> is <b>NULL</b>, <i>ulLength</i> must be set to zero.
     * 
     * If <i>ulLength</i> is set to zero, the function deletes the property. 
     * 
     * If <i>Buffer</i> is not set to <b>NULL</b> and <i>ulLength</i> is not set to zero, the supplied value must be the correct size for the REG_<i>Xxx</i> data type for the property that is specified in <i>ulProperty</i>.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that represents the device setup class for which to set a property.
     * @param {Integer} ulProperty A value of type ULONG that identifies the property to set. This value must be one of the CM_CRP_<i>Xxx</i> values that are described for the <i>ulProperty</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_class_registry_propertya">CM_Get_Class_Registry_Property</a> function.
     * @param {Pointer<Void>} Buffer A pointer to a buffer that contains the property data. This parameter is optional and can be set to <b>NULL</b>. For more information about setting this parameter and the corresponding <i>ulLength</i> parameter, see the following <b>Remarks</b> section.
     * @param {Integer} ulLength A value of type ULONG that specifies the size, in bytes, of the property data.
     * @param {Integer} ulFlags Reserved for internal use only. Must be set to zero.
     * @param {Pointer} hMachine A handle to a remote machine on which to set the specified <a href="https://docs.microsoft.com/windows-hardware/drivers/install/accessing-device-setup-class-properties">device setup class property</a>. This parameter is optional. If set to <b>NULL</b>, the property is set on the local machine.
     * @returns {Integer} If the operation succeeds, <b>CM_Set_Class_Registry_Property </b> returns CR_SUCCESS. Otherwise, the function returns one of the other CR_<i>Xxx</i> status codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_class_registry_propertya
     */
    static CM_Set_Class_Registry_PropertyA(ClassGuid, ulProperty, Buffer, ulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_Class_Registry_PropertyA", "ptr", ClassGuid, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * The CM_Set_Class_Registry_Property function sets or deletes a property of a device setup class. (Unicode)
     * @remarks
     * If <i>Buffer</i> is <b>NULL</b>, <i>ulLength</i> must be set to zero.
     * 
     * If <i>ulLength</i> is set to zero, the function deletes the property. 
     * 
     * If <i>Buffer</i> is not set to <b>NULL</b> and <i>ulLength</i> is not set to zero, the supplied value must be the correct size for the REG_<i>Xxx</i> data type for the property that is specified in <i>ulProperty</i>.
     * @param {Pointer<Guid>} ClassGuid A pointer to the GUID that represents the device setup class for which to set a property.
     * @param {Integer} ulProperty A value of type ULONG that identifies the property to set. This value must be one of the CM_CRP_<i>Xxx</i> values that are described for the <i>ulProperty</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_class_registry_propertyw">CM_Get_Class_Registry_Property</a> function.
     * @param {Pointer<Void>} Buffer A pointer to a buffer that contains the property data. This parameter is optional and can be set to <b>NULL</b>. For more information about setting this parameter and the corresponding <i>ulLength</i> parameter, see the following <b>Remarks</b> section.
     * @param {Integer} ulLength A value of type ULONG that specifies the size, in bytes, of the property data.
     * @param {Integer} ulFlags Reserved for internal use only. Must be set to zero.
     * @param {Pointer} hMachine A handle to a remote machine on which to set the specified <a href="https://docs.microsoft.com/windows-hardware/drivers/install/accessing-device-setup-class-properties">device setup class property</a>. This parameter is optional. If set to <b>NULL</b>, the property is set on the local machine.
     * @returns {Integer} If the operation succeeds, <b>CM_Set_Class_Registry_Property </b> returns CR_SUCCESS. Otherwise, the function returns one of the other CR_<i>Xxx</i> status codes that are defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_set_class_registry_propertyw
     * @since windows5.0
     */
    static CM_Set_Class_Registry_PropertyW(ClassGuid, ulProperty, Buffer, ulLength, ulFlags, hMachine) {
        result := DllCall("CFGMGR32.dll\CM_Set_Class_Registry_PropertyW", "ptr", ClassGuid, "uint", ulProperty, "ptr", Buffer, "uint", ulLength, "uint", ulFlags, "ptr", hMachine, "uint")
        return result
    }

    /**
     * 
     * @param {Integer} dwTimeout 
     * @returns {Integer} 
     */
    static CMP_WaitNoPendingInstallEvents(dwTimeout) {
        result := DllCall("CFGMGR32.dll\CMP_WaitNoPendingInstallEvents", "uint", dwTimeout, "uint")
        return result
    }

    /**
     * Use RegisterDeviceNotification instead of CM_Register_Notification if your code targets Windows7 or earlier versions of Windows. Kernel mode callers should use IoRegisterPlugPlayNotification instead.
     * @remarks
     * Be sure to handle Plug and Play device events as quickly as possible.  If your event handler performs any operation that may block execution (such as I/O), it is best to start another thread to perform the operation asynchronously.
     * 
     * The <b>CM_Register_Notification</b> function does not provide notification of existing device interfaces.   To retrieve existing interfaces, first call <b>CM_Register_Notification</b>, and then call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_lista">CM_Get_Device_Interface_List</a>.   If the interface is enabled after your driver calls <b>CM_Register_Notification</b>, but before your driver calls <b>CM_Get_Device_Interface_List</b>, the driver receives a notification for the interface arrival, and the interface also appears in the list of device interface instances returned by <b>CM_Get_Device_Interface_List</b>.
     * 
     * HCMNOTIFICATION handles returned by <b>CM_Register_Notification</b> must be closed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_unregister_notification">CM_Unregister_Notification</a> function when they are no longer needed.
     * 
     * A callback routine uses the following function prototype:
     * 		  
     * 
     * 
     * ```
     * typedef __callback DWORD (CALLBACK *PCM_NOTIFY_CALLBACK)(
     *     _In_ HCMNOTIFICATION       hNotify,
     *     _In_opt_ PVOID             Context,
     *     _In_ CM_NOTIFY_ACTION      Action,
     *     _In_reads_bytes_(EventDataSize) PCM_NOTIFY_EVENT_DATA EventData,
     *     _In_ DWORD                 EventDataSize
     *     );
     * ```
     * 
     * 
     * If responding to a <b>CM_NOTIFY_ACTION_DEVICEQUERYREMOVE</b> notification, the PCM_NOTIFY_CALLBACK callback should return either ERROR_SUCCESS or ERROR_CANCELLED, as appropriate.  Otherwise, the callback should return ERROR_SUCCESS. The callback should not return any other values. For a description of other actions, please refer to the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ne-cfgmgr32-cm_notify_action">CM_NOTIFY_ACTION</a> documentation.  Also see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ns-cfgmgr32-cm_notify_event_data">CM_NOTIFY_EVENT_DATA</a> for information about the structure that this callback receives in the <i>EventData</i> parameter.
     * @param {Pointer<CM_NOTIFY_FILTER>} pFilter Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ns-cfgmgr32-cm_notify_filter">CM_NOTIFY_FILTER</a> structure.
     * @param {Pointer<Void>} pContext Pointer to a caller-allocated buffer containing the context to be passed to the callback routine in <i>pCallback</i>.
     * @param {Pointer<PCM_NOTIFY_CALLBACK>} pCallback Pointer to the routine to be called when the specified PnP event occurs. See the <b>Remarks</b> section for the callback function's prototype.
     * 
     * The callback routines <i>Action</i> parameter will be a value from the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/ne-cfgmgr32-cm_notify_action">CM_NOTIFY_ACTION</a> enumeration.
     * 
     * Upon receiving a notification, how the callback examines the notification will depend on the <b>FilterType</b> member of the callback routine's <i>EventData</i> parameter:
     * @param {Pointer<HCMNOTIFICATION>} pNotifyContext Pointer to receive the HCMNOTIFICATION handle that corresponds to the registration call.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_register_notification
     * @since windows8.0
     */
    static CM_Register_Notification(pFilter, pContext, pCallback, pNotifyContext) {
        result := DllCall("CFGMGR32.dll\CM_Register_Notification", "ptr", pFilter, "ptr", pContext, "ptr", pCallback, "ptr", pNotifyContext, "uint")
        return result
    }

    /**
     * Use UnregisterDeviceNotification instead of CM_Unregister_Notification if your code targets Windows7 or earlier versions of Windows.
     * @remarks
     * Do not call <b>CM_Unregister_Notification</b> from a notification callback. Doing so may cause a deadlock because <b>CM_Unregister_Notification</b> waits for pending callbacks to finish.
     * 
     * Instead, if you want to unregister from the notification callback, you must do so asynchronously.       The following sequence shows one way to do this:
     * 
     * <ol>
     * <li>Allocate a context structure to use with your notifications.      Include a pointer to a threadpool work structure (<b>PTP_WORK</b>) and any other information you would like to pass to the notification callback.</li>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwork">CreateThreadpoolWork</a>.   Provide a callback function that calls  <b>CM_Unregister_Notification</b>.      Add the returned work structure to the previously allocated context structure.</li>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_register_notification">CM_Register_Notification</a> and provide the context structure as the <i>pContext</i> parameter.</li>
     * <li>Do work, get notifications, etc.</li>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-submitthreadpoolwork">SubmitThreadpoolWork</a> from within the notification callback, providing the pointer to a threadpool work structure (<b>PTP_WORK</b>) stored in your context structure.</li>
     * <li>When the threadpool thread runs, the work item calls <b>CM_Unregister_Notification</b>.</li>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolwork">CloseThreadpoolWork</a> to release the work object.</li>
     * </ol>
     * If you are finished with the context structure, don't forget to release resources and and free the structure.
     * 
     * <div class="alert"><b>Caution</b>Do not free the context structure until after the work item has called <b>CM_Unregister_Notification</b>.  You can still receive notifications after submitting the threadpool work item and before the work item calls <b>CM_Unregister_Notification</b>.</div>
     * <div></div>
     * @param {Pointer<HCMNOTIFICATION>} NotifyContext The HCMNOTIFICATION handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_register_notification">CM_Register_Notification</a> function.
     * @returns {Integer} If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_unregister_notification
     * @since windows8.0
     */
    static CM_Unregister_Notification(NotifyContext) {
        result := DllCall("CFGMGR32.dll\CM_Unregister_Notification", "ptr", NotifyContext, "uint")
        return result
    }

    /**
     * Converts a specified CONFIGRET code to its equivalent system error code.
     * @param {Integer} CmReturnCode The <b>CONFIGRET</b> code to be converted. <b>CONFIGRET</b> 
     *       error codes are defined in CfgMgr32.h.
     * @param {Integer} DefaultErr A default system error code to be returned when no system error code is mapped to the specified 
     *       <b>CONFIGRET</b> code.
     * @returns {Integer} The system error code that corresponds to the <b>CONFIGRET</b> code. System error codes 
     *        are defined in Winerror.h.
     * 
     * When there is no mapping from the specified <b>CONFIGRET</b> code to a system error 
     *        code, <b>CM_MapCrToWin32Err</b> returns the value 
     *        specified in the <i>DefaultErr</i> parameter.
     * @see https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_mapcrtowin32err
     * @since windows6.1
     */
    static CM_MapCrToWin32Err(CmReturnCode, DefaultErr) {
        result := DllCall("CFGMGR32.dll\CM_MapCrToWin32Err", "uint", CmReturnCode, "uint", DefaultErr, "uint")
        return result
    }

    /**
     * Given an INF file and a hardware ID, the UpdateDriverForPlugAndPlayDevices function installs updated drivers for devices that match the hardware ID. (ANSI)
     * @remarks
     * <b>UpdateDriverForPlugAndPlayDevices</b> scans the devices on the system and attempts to install the drivers specified by <i>FullInfPath</i> for any devices that match the specified <i>HardwareId</i> value. 
     * 
     * The default behavior is to only install the specified drivers if they are better match than the currently installed drivers and the specified drivers are also a better match than any drivers in %<i>SystemRoot</i>%&#92;<i>inf</i>. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>. 
     * 
     * <b>UpdateDriverForPlugAndPlayDevices</b> can also be used to determine whether the device with the specified <i>HardwareId</i> value is plugged in. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-a-device-installation-application">Writing a Device Installation Application</a>.
     * 
     * <b>UpdateDriverForPlugAndPlayDevices</b> sends an <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-remove-device">IRP_MN_QUERY_REMOVE_DEVICE</a> request to the specified device, all the children of the device, and all other devices that are recursively part of the removal relations for the device. If any of these devices fail a query remove request, <b>UpdateDriverForPlugAndPlayDevices</b> sets the DI_NEEDREBOOT flag in the <b>Flags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure for the device. For information about removal relations, see the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-device-relations">IRP_MN_QUERY_DEVICE_RELATIONS</a> request.
     * 
     * Generally, <a href="https://docs.microsoft.com/windows-hardware/drivers/">device installation applications</a> should supply <b>NULL</b> for <i>bRebootRequired</i>. So, the system will initiate a restart if necessary. An application should specify a pointer value <i>only</i> in the following cases:
     * 
     * <ul>
     * <li>
     * The application must call <b>UpdateDriverForPlugAndPlayDevices</b> several times to complete an installation. 
     * 
     * </li>
     * <li>
     * The application must perform other operations before the restart (if required) occurs.
     * 
     * </li>
     * <li>
     * The application is a class installer, which should set DI_NEEDREBOOT in <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> if a restart is needed.
     * 
     * </li>
     * </ul>
     * If the application must call <b>UpdateDriverForPlugAndPlayDevices</b> several times, it should save any <b>TRUE</b> restart status value received and then prompt for a restart after the final call has returned.
     * 
     * If the function returns ERROR_IN_WOW64 in a 32-bit application, the application is executing on a 64-bit system, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to use for any UI related to installing devices.
     * @param {Pointer<PSTR>} HardwareId A pointer to a NULL-terminated string that supplies the hardware identifier to match existing devices on the computer. The maximum length of a NULL-terminated hardware identifier is MAX_DEVICE_ID_LEN. For more information about hardware identifiers, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * @param {Pointer<PSTR>} FullInfPath A pointer to a NULL-terminated string that supplies the full path file name of an INF file. The files should be on the distribution media or in a vendor-created directory, not in a system location such as <i>%SystemRoot%\inf</i>. <b>UpdateDriverForPlugAndPlayDevices</b> copies driver files to the appropriate system locations if the installation is successful.
     * @param {Integer} InstallFlags A caller-supplied value created by using OR to combine zero or more of the following bit flags:
     * @param {Pointer<Int32>} bRebootRequired A pointer to a BOOL-typed variable that indicates whether a restart is required and who should prompt for it. This pointer is optional and can be <b>NULL</b>. 
     * 
     * If the pointer is <b>NULL</b>, <b>UpdateDriverForPlugAndPlayDevices</b> prompts for a restart after installing drivers, if necessary. If the pointer is supplied, the function returns a BOOLEAN value that is <b>TRUE</b> if the system should be restarted. It is then the caller's responsibility to prompt for a restart. 
     * 
     * For more information, see the following <b>Remarks</b> section.
     * @returns {Integer} The function returns <b>TRUE</b> if a device was upgraded to the specified driver.
     * 
     * Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <b>GetLastError</b>. Possible error values returned by <b>GetLastError</b> are included in the following table.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path that was specified for <i>FullInfPath</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application attempting to execute in a 64-bit environment, which is not allowed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>InstallFlags</i> is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>HardwareId</i> does not match any device on the system. That is, the device is not plugged in.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function found a match for the <i>HardwareId</i> value, but the specified driver was not a better match than the current driver and the caller did not specify the INSTALLFLAG_FORCE flag. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-updatedriverforplugandplaydevicesa
     * @since windows5.0
     */
    static UpdateDriverForPlugAndPlayDevicesA(hwndParent, HardwareId, FullInfPath, InstallFlags, bRebootRequired) {
        HardwareId := HardwareId is String? StrPtr(HardwareId) : HardwareId
        FullInfPath := FullInfPath is String? StrPtr(FullInfPath) : FullInfPath

        A_LastError := 0

        result := DllCall("newdev.dll\UpdateDriverForPlugAndPlayDevicesA", "ptr", hwndParent, "ptr", HardwareId, "ptr", FullInfPath, "uint", InstallFlags, "ptr", bRebootRequired, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Given an INF file and a hardware ID, the UpdateDriverForPlugAndPlayDevices function installs updated drivers for devices that match the hardware ID. (Unicode)
     * @remarks
     * <b>UpdateDriverForPlugAndPlayDevices</b> scans the devices on the system and attempts to install the drivers specified by <i>FullInfPath</i> for any devices that match the specified <i>HardwareId</i> value. 
     * 
     * The default behavior is to only install the specified drivers if they are better match than the currently installed drivers and the specified drivers are also a better match than any drivers in %<i>SystemRoot</i>%&#92;<i>inf</i>. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>. 
     * 
     * <b>UpdateDriverForPlugAndPlayDevices</b> can also be used to determine whether the device with the specified <i>HardwareId</i> value is plugged in. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-a-device-installation-application">Writing a Device Installation Application</a>.
     * 
     * <b>UpdateDriverForPlugAndPlayDevices</b> sends an <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-remove-device">IRP_MN_QUERY_REMOVE_DEVICE</a> request to the specified device, all the children of the device, and all other devices that are recursively part of the removal relations for the device. If any of these devices fail a query remove request, <b>UpdateDriverForPlugAndPlayDevices</b> sets the DI_NEEDREBOOT flag in the <b>Flags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure for the device. For information about removal relations, see the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-device-relations">IRP_MN_QUERY_DEVICE_RELATIONS</a> request.
     * 
     * Generally, <a href="https://docs.microsoft.com/windows-hardware/drivers/">device installation applications</a> should supply <b>NULL</b> for <i>bRebootRequired</i>. So, the system will initiate a restart if necessary. An application should specify a pointer value <i>only</i> in the following cases:
     * 
     * <ul>
     * <li>
     * The application must call <b>UpdateDriverForPlugAndPlayDevices</b> several times to complete an installation. 
     * 
     * </li>
     * <li>
     * The application must perform other operations before the restart (if required) occurs.
     * 
     * </li>
     * <li>
     * The application is a class installer, which should set DI_NEEDREBOOT in <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> if a restart is needed.
     * 
     * </li>
     * </ul>
     * If the application must call <b>UpdateDriverForPlugAndPlayDevices</b> several times, it should save any <b>TRUE</b> restart status value received and then prompt for a restart after the final call has returned.
     * 
     * If the function returns ERROR_IN_WOW64 in a 32-bit application, the application is executing on a 64-bit system, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window to use for any UI related to installing devices.
     * @param {Pointer<PWSTR>} HardwareId A pointer to a NULL-terminated string that supplies the hardware identifier to match existing devices on the computer. The maximum length of a NULL-terminated hardware identifier is MAX_DEVICE_ID_LEN. For more information about hardware identifiers, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.
     * @param {Pointer<PWSTR>} FullInfPath A pointer to a NULL-terminated string that supplies the full path file name of an INF file. The files should be on the distribution media or in a vendor-created directory, not in a system location such as <i>%SystemRoot%\inf</i>. <b>UpdateDriverForPlugAndPlayDevices</b> copies driver files to the appropriate system locations if the installation is successful.
     * @param {Integer} InstallFlags A caller-supplied value created by using OR to combine zero or more of the following bit flags:
     * @param {Pointer<Int32>} bRebootRequired A pointer to a BOOL-typed variable that indicates whether a restart is required and who should prompt for it. This pointer is optional and can be <b>NULL</b>. 
     * 
     * If the pointer is <b>NULL</b>, <b>UpdateDriverForPlugAndPlayDevices</b> prompts for a restart after installing drivers, if necessary. If the pointer is supplied, the function returns a BOOLEAN value that is <b>TRUE</b> if the system should be restarted. It is then the caller's responsibility to prompt for a restart. 
     * 
     * For more information, see the following <b>Remarks</b> section.
     * @returns {Integer} The function returns <b>TRUE</b> if a device was upgraded to the specified driver.
     * 
     * Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <b>GetLastError</b>. Possible error values returned by <b>GetLastError</b> are included in the following table.
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path that was specified for <i>FullInfPath</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application attempting to execute in a 64-bit environment, which is not allowed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>InstallFlags</i> is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_SUCH_DEVINST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>HardwareId</i> does not match any device on the system. That is, the device is not plugged in.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function found a match for the <i>HardwareId</i> value, but the specified driver was not a better match than the current driver and the caller did not specify the INSTALLFLAG_FORCE flag. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-updatedriverforplugandplaydevicesw
     * @since windows5.0
     */
    static UpdateDriverForPlugAndPlayDevicesW(hwndParent, HardwareId, FullInfPath, InstallFlags, bRebootRequired) {
        HardwareId := HardwareId is String? StrPtr(HardwareId) : HardwareId
        FullInfPath := FullInfPath is String? StrPtr(FullInfPath) : FullInfPath

        A_LastError := 0

        result := DllCall("newdev.dll\UpdateDriverForPlugAndPlayDevicesW", "ptr", hwndParent, "ptr", HardwareId, "ptr", FullInfPath, "uint", InstallFlags, "ptr", bRebootRequired, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiInstallDevice function installs a specified driver that is preinstalled in the driver store on a specified device that is present in the system.
     * @remarks
     * Only call <b>DiInstallDevice</b> if it is necessary to install a specific driver on a specific device. Otherwise, use <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-updatedriverforplugandplaydevicesa">UpdateDriverForPlugAndPlayDevices</a> or <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-diinstalldrivera">DiInstallDriver</a> to install a driver for a device. For more information about which of these functions to call to install a driver on a device, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupapi-functions-that-simplify-driver-installation">SetupAPI Functions that Simplify Driver Installation</a>. 
     * 
     * Before calling <b>DiInstallDevice</b>, the caller must obtain an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure to specify the device and, optionally, an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure to specify a driver for the device.
     * 
     * To create a device information set that contains the specified device and to obtain an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for the device, do one of the following:
     * 
     * <ul>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a> to retrieve a device information set that contains the device and then call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinfo">SetupDiEnumDeviceInfo</a> to enumerate the devices in the device information set. On each call, <b>SetupDiEnumDeviceInfo</b> returns an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the enumerated device in the device information set. To obtain specific information about the enumerated device, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdevicepropertyw">SetupDiGetDeviceProperty</a> and supply the <b>SP_DEVINFO_DATA</b> structure that is returned by <b>SetupDiEnumDeviceInfo</b>. 
     * 
     * - OR -
     * 
     * </li>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiopendeviceinfoa">SetupDiOpenDeviceInfo</a> to add a device with a known device instance ID to the device information set. <b>SetupDiOpenDeviceInfo</b> returns an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device in the device information set.
     * 
     * </li>
     * </ul>
     * To retrieve an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure for a selected driver, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdibuilddriverinfolist">SetupDiBuildDriverInfoList</a> to build a list of drivers for the device and then call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdriverinfoa">SetupDiEnumDriverInfo</a> to enumerate the elements of the driver list for the device. For each enumerated driver, <b>SetupDiEnumDriverInfo</b> retrieves an <b>SP_DRVINFO_DATA</b> structure that identifies the driver. <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdriverinfodetaila">SetupDiGetDriverInfoDetail</a> can also be called to retrieve additional detail about an enumerated driver. 
     * 
     * In general, an installation application should set <i>NeedReboot</i> to <b>NULL</b>. This ensures that <b>DiInstallDevice</b> prompts the user to restart the system if a restart is required to complete the installation. An application should supply a <i>NeedReboot</i> pointer only in the following cases:
     * 
     * <ul>
     * <li>
     * The application must call <b>DiInstallDevice</b> several times to complete an installation. In this case, the application should record whether a <b>TRUE</b><i>NeedReboot</i> value is returned by any of the calls to <b>DiInstallDevice </b> and, if so, prompt the user to restart the system after the final call to <b>DiInstallDevice</b> returns.
     * 
     * </li>
     * <li>
     * The application must perform required operations, other than calling <b>DiInstallDevice</b>, before a system restart should occur. If a system restart is required, the application should finish the required operations and then prompt the user to restart the system.
     * 
     * </li>
     * <li>
     * The application is a class installer, in which case, the class installer should set the <b>DI_NEEDREBOOT</b> flag in the <b>Flags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure for a device.
     * 
     * </li>
     * </ul>
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window that <b>DiInstallDevice</b> uses to display any user interface component that is associated with installing the device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer} DeviceInfoSet A handle to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the specified device.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the specified device in the specified device information set.
     * @param {Pointer<SP_DRVINFO_DATA_V2_W>} DriverInfoData An pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_drvinfo_data_v1_a">SP_DRVINFO_DATA</a> structure that specifies the driver to install on the specified device. This parameter is optional and can be set to <b>NULL</b>. If this parameter is <b>NULL</b>, <b>DiInstallDevice</b> searches the drivers preinstalled in the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a> for the driver that is the best match to the specified device, and, if one is found, installs the driver on the specified device.
     * @param {Integer} Flags A value of type <b>DWORD</b> that specifies zero or the following flag:
     * @param {Pointer<Int32>} NeedReboot A pointer to a value of type <b>BOOL</b> that <b>DiInstallDevice</b> sets to indicate whether a system restart is required to complete the installation. This parameter is optional and can be set to <b>NULL</b>. If this parameter is supplied and a system restart is required to complete the installation, <b>DiInstallDevice</b> sets the value to <b>TRUE</b>. In this case, the caller is responsible for restarting the system. If this parameter is supplied and a system restart is not required, <b>DiInstallDevice</b> sets this parameter to <b>FALSE</b>. If this parameter is <b>NULL</b> and a system restart is required to complete the installation, <b>DiInstallDevice</b> displays a system restart dialog box.
     * @returns {Integer} <b>DiInstallDevice</b> returns <b>TRUE</b> if the function successfully installed the specified driver on the specified device. Otherwise, <b>DiInstallDevice</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, WindowsVista and Windows Server2008 require that a calling process have Administrator privileges to install a driver on a device.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value that is specified for <i>Flags</i> is not zero or a bitwise OR of the valid flags.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-diinstalldevice
     * @since windows6.0.6000
     */
    static DiInstallDevice(hwndParent, DeviceInfoSet, DeviceInfoData, DriverInfoData, Flags, NeedReboot) {
        A_LastError := 0

        result := DllCall("newdev.dll\DiInstallDevice", "ptr", hwndParent, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", DriverInfoData, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiInstallDriver function preinstalls a driver in the driver store and then installs the driver on devices present in the system that the driver supports. (Unicode)
     * @remarks
     * <b>DiInstallDriver</b> performs the following operations:
     * 
     * <ol>
     * <li>
     * Preinstalls the <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a>. If there is an instance of the same driver package already preinstalled in the driver store, <b>DiInstallDriver</b> first removes that instance and then adds the new instance of the driver package to the driver store. 
     * 
     * </li>
     * <li>
     * Enumerates devices that are present in the system.
     * 
     * </li>
     * <li>
     * If <i>Flags</i> is equal to zero, installs the driver on a device only if the specified driver is a better match for the device than the driver that is currently installed on the device. 
     * 
     * </li>
     * <li>
     * If <i>Flags</i> is equal to DIIRFLAG_FORCE_INF, installs the driver on a device regardless of whether the <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> is the better match to the device than the driver that is currently installed on the device. 
     * 
     * </li>
     * </ol>
     * In general, an installation application should set <i>NeedReboot</i> to <b>NULL</b> to direct <b>DiInstallDriver</b> to prompt the user to restart the system if a restart is required to complete the installation. An application should supply a <i>NeedReboot</i> pointer only in the following cases:
     * 
     * <ul>
     * <li>
     * The application must call <b>DiInstallDriver</b> several times to complete an installation. In this case, the application should record whether a <b>TRUE</b><i>NeedReboot</i> value is returned by any of the calls to <b>DiInstallDriver</b> and, if so, prompt the user to restart the system after the final call to <b>DiInstallDriver</b> returns.
     * 
     * </li>
     * <li>
     * The application must perform required operations, other than calling <b>DiInstallDriver</b>, before a system restart should occur. If a system restart is required, the application should finish the required operations and then prompt the user to restart the system. 
     * 
     * </li>
     * <li>
     * The application is a class installer, in which case, the class installer should set the DI_NEEDREBOOT flag in the <b>Flags</b> member of the SP_DEVINSTALL_PARAMS structure for a device.
     * 
     * </li>
     * </ul>
     * To install a selected driver on a selected device, call <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-diinstalldevice">DiInstallDevice</a>. For more info, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupapi-functions-that-simplify-driver-installation">SetupAPI Functions that Simplify Driver Installation</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The newdev.h header defines DiInstallDriver as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window that <b>DiInstallDriver</b> uses to display any user interface component that is associated with installing the device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<PWSTR>} InfPath A pointer to a NULL-terminated string that supplies the fully qualified path of the INF file for the [driver package](/windows-hardware/drivers/install/driver-packages).
     * @param {Integer} Flags A value of type DWORD that specifies zero or a combination of one or more flags as described here (*Flags* is typically set to zero). 
     * 
     * If *Flags* is zero, <b>DiInstallDriver</b> only installs the specified driver on a device if the driver is a better match for a device than the driver that is currently installed on a device. For information about how Windows selects a driver for a device, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>.
     * 
     * If *Flags* includes DIIRFLAG_FORCE_INF, <b>DiInstallDriver</b> installs the specified driver on a matching device whether or not the driver is a better match for the device than the driver that is currently installed on the device.  If DIIRFLAG_INSTALL_AS_SET is also specified, DIIRFLAG_FORCE_INF is ignored.
     * 
     * <div class="alert"><b>Caution</b>Forcing the installation of the driver can result in replacing a more compatible or newer driver with a less compatible or older driver. </div>
     * <div></div>
     * 
     * If *Flags* includes DIIRFLAG_INSTALL_AS_SET (supported on Windows 10 version 1709 and later), _InfPath_ should specify a directory instead of a fully qualified path to an INF file and **DiInstallDriver** will install all INF files in that directory with special behavior.  All [driver packages](/windows-hardware/drivers/install/driver-packages) will get staged into the [Driver Store](/windows-hardware/drivers/install/driver-store) but will not be made available to be installed on devices yet.  On next shutdown of the system, these driver packages will be made available to be installed on devices going forward and they will be installed on any devices they are the best match for such that the devices are ready on next boot of the system.
     * @param {Pointer<Int32>} NeedReboot A pointer to a value of type BOOL that <b>DiInstallDriver</b> sets to indicate whether a system restart is required to complete the installation. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the installation, <b>DiInstallDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the installation, <b>DiInstallDriver</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the installation, <b>DiInstallDriver</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>DiInstallDriver</b> returns <b>TRUE</b> if the function successfully preinstalled the specified <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a>. <b>DiInstallDriver</b> also returns <b>TRUE</b> if the function successfully installed the driver on one or more devices in the system. If the driver package is not successfully installed in the driver store, <b>DiInstallDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to preinstall a <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path of the specified INF file does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or DIIRFLAG_FORCE_INF.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-diinstalldriverw
     * @since windows6.0.6000
     */
    static DiInstallDriverW(hwndParent, InfPath, Flags, NeedReboot) {
        InfPath := InfPath is String? StrPtr(InfPath) : InfPath

        A_LastError := 0

        result := DllCall("newdev.dll\DiInstallDriverW", "ptr", hwndParent, "ptr", InfPath, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiInstallDriver function preinstalls a driver in the driver store and then installs the driver on devices present in the system that the driver supports. (ANSI)
     * @remarks
     * <b>DiInstallDriver</b> performs the following operations:
     * 
     * <ol>
     * <li>
     * Preinstalls the <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a>. If there is an instance of the same driver package already preinstalled in the driver store, <b>DiInstallDriver</b> first removes that instance and then adds the new instance of the driver package to the driver store. 
     * 
     * </li>
     * <li>
     * Enumerates devices that are present in the system.
     * 
     * </li>
     * <li>
     * If <i>Flags</i> is equal to zero, installs the driver on a device only if the specified driver is a better match for the device than the driver that is currently installed on the device. 
     * 
     * </li>
     * <li>
     * If <i>Flags</i> is equal to DIIRFLAG_FORCE_INF, installs the driver on a device regardless of whether the <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> is the better match to the device than the driver that is currently installed on the device. 
     * 
     * </li>
     * </ol>
     * In general, an installation application should set <i>NeedReboot</i> to <b>NULL</b> to direct <b>DiInstallDriver</b> to prompt the user to restart the system if a restart is required to complete the installation. An application should supply a <i>NeedReboot</i> pointer only in the following cases:
     * 
     * <ul>
     * <li>
     * The application must call <b>DiInstallDriver</b> several times to complete an installation. In this case, the application should record whether a <b>TRUE</b><i>NeedReboot</i> value is returned by any of the calls to <b>DiInstallDriver</b> and, if so, prompt the user to restart the system after the final call to <b>DiInstallDriver</b> returns.
     * 
     * </li>
     * <li>
     * The application must perform required operations, other than calling <b>DiInstallDriver</b>, before a system restart should occur. If a system restart is required, the application should finish the required operations and then prompt the user to restart the system. 
     * 
     * </li>
     * <li>
     * The application is a class installer, in which case, the class installer should set the DI_NEEDREBOOT flag in the <b>Flags</b> member of the SP_DEVINSTALL_PARAMS structure for a device.
     * 
     * </li>
     * </ul>
     * To install a selected driver on a selected device, call <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-diinstalldevice">DiInstallDevice</a>. For more info, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupapi-functions-that-simplify-driver-installation">SetupAPI Functions that Simplify Driver Installation</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The newdev.h header defines DiInstallDriver as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window that <b>DiInstallDriver</b> uses to display any user interface component that is associated with installing the device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<PSTR>} InfPath A pointer to a NULL-terminated string that supplies the fully qualified path of the INF file for the [driver package](/windows-hardware/drivers/install/driver-packages).
     * @param {Integer} Flags A value of type DWORD that specifies zero or a combination of one or more flags as described here (*Flags* is typically set to zero). 
     * 
     * If *Flags* is zero, <b>DiInstallDriver</b> only installs the specified driver on a device if the driver is a better match for a device than the driver that is currently installed on a device. For information about how Windows selects a driver for a device, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>.
     * 
     * If *Flags* includes DIIRFLAG_FORCE_INF, <b>DiInstallDriver</b> installs the specified driver on a matching device whether or not the driver is a better match for the device than the driver that is currently installed on the device. If DIIRFLAG_INSTALL_AS_SET is also specified, DIIRFLAG_FORCE_INF is ignored.
     * 
     * <div class="alert"><b>Caution</b>Forcing the installation of the driver can result in replacing a more compatible or newer driver with a less compatible or older driver. </div>
     * <div></div>
     * 
     * If *Flags* includes DIIRFLAG_INSTALL_AS_SET (supported on Windows 10 version 1709 and later), _InfPath_ should specify a directory instead of a fully qualified path to an INF file and **DiInstallDriver** will install all INF files in that directory with special behavior.  All [driver packages](/windows-hardware/drivers/install/driver-packages) will get staged into the [Driver Store](/windows-hardware/drivers/install/driver-store) but will not be made available to be installed on devices yet.  On next shutdown of the system, these driver packages will be made available to be installed on devices going forward and they will be installed on any devices they are the best match for such that the devices are ready on next boot of the system.
     * @param {Pointer<Int32>} NeedReboot A pointer to a value of type BOOL that <b>DiInstallDriver</b> sets to indicate whether a system is restart is required to complete the installation. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the installation, <b>DiInstallDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the installation, <b>DiInstallDriver</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the installation, <b>DiInstallDriver</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>DiInstallDriver</b> returns <b>TRUE</b> if the function successfully preinstalled the specified <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a>. <b>DiInstallDriver</b> also returns <b>TRUE</b> if the function successfully installed the driver on one or more devices in the system. If the driver package is not successfully installed in the driver store, <b>DiInstallDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to preinstall a <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a> in the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path of the specified INF file does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or DIIRFLAG_FORCE_INF.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-diinstalldrivera
     * @since windows6.0.6000
     */
    static DiInstallDriverA(hwndParent, InfPath, Flags, NeedReboot) {
        InfPath := InfPath is String? StrPtr(InfPath) : InfPath

        A_LastError := 0

        result := DllCall("newdev.dll\DiInstallDriverA", "ptr", hwndParent, "ptr", InfPath, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiUninstallDevice function uninstalls a device and removes its device node (devnode) from the system.
     * @remarks
     * <b>DiUninstallDevice</b> performs the same function as <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdicallclassinstaller">SetupDiCallClassInstaller</a> when used with the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-remove">DIF_REMOVE</a> code. The key difference is that child devnodes for the top-level device are also deleted. <b>DiUninstallDevice</b> only returns failure if the top-level device node failed to be uninstalled, which is consistent with the behavior of <b>SetupDiCallClassInstaller</b> when used with the <b>DIF_REMOVE</b> code. Detailed information about whether child devnode uninstallation succeeded is available in the Setupapi.dev.log file.
     * 
     * The device to be uninstalled is specified by providing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that includes the referenced device, and a <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for the specific device. These are provided in the <i>DeviceInfoSet</i> and <i>DeviceInfoData</i> parameters.
     * 
     * To create a device information set that contains the specified device and to obtain an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure for the device, complete one of the following tasks:
     * 
     * <ul>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetclassdevsw">SetupDiGetClassDevs</a> to retrieve a device information set that contains the device and then call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinfo">SetupDiEnumDeviceInfo</a> to enumerate the devices in the device information set. On each call, <b>SetupDiEnumDeviceInfo</b> returns an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the enumerated device in the device information set. 
     * 
     * To obtain specific information about the enumerated device, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdevicepropertyw">SetupDiGetDeviceProperty</a> and supply the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinfo">SetupDiEnumDeviceInfo</a>.
     * 
     * </li>
     * <li>
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdienumdeviceinfo">SetupDiEnumDeviceInfo</a> to add a device with a known device instance ID to the device information set. <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiopendeviceinfoa">SetupDiOpenDeviceInfo</a> returns an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device in the device information set. 
     * 
     * </li>
     * </ul>
     * In case the device uninstallation request requires a restart of the computer, <b>DiUninstallDevice</b> prompts the user to restart the system if the <i>NeedReboot</i> parameter is set to <b>NULL</b>. If there is any user interface window that the application is using, the <i>hwndParent</i> parameter should be set to the value of that window's handle. 
     * 
     * However, if the application manages the notification of a required system restart, it must set the <i>NeedReboot</i> parameter to a non-<b>NULL</b> value. <b>DiUninstallDevice</b> sets the <i>NeedReboot</i> parameter to <b>TRUE</b> or <b>FALSE</b>, depending on whether a system restart is required. 
     * 
     * The following list shows examples of why the application might manage the system restart:
     * 
     * <ul>
     * <li>
     * The application has to uninstall several devices. After all the devices are uninstalled, the application should prompt the user to restart the system if any call to <b>DiUninstallDevice</b> returned <b>TRUE</b> in the <i>NeedReboot</i> parameter.
     * 
     * </li>
     * <li>
     * The application requires some other operations to occur before the system can be restarted. If a system restart is required, the application should finish the required operations and then prompt the user to restart the system.
     * 
     * </li>
     * <li>
     * The application is a class installer. In this case, the class installer should set the <b>DI_NEEDREBOOT</b> flag in the <b>Flags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure for a device. 
     * 
     * </li>
     * </ul>
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window that is used to display any user interface component that is associated with the uninstallation request for the device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element. This element represents the device to be uninstalled through this call.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the specified device in the specified device information set for which the uninstallation request is performed.
     * @param {Integer} Flags A value of type DWORD that specifies device uninstallation flags. Starting with Windows 7, this parameter must be set to zero.
     * @param {Pointer<Int32>} NeedReboot A pointer to a value of type BOOL that <b>DiUninstallDevice</b> sets to indicate whether a system restart is required to complete the device uninstallation request. This parameter is optional and can be set to <b>NULL</b>.
     * 
     * If the parameter is given and a system restart is required, <b>DiUninstallDevice</b> sets the value to <b>TRUE</b>. In this case, the application must prompt the user to restart the system. If this parameter is supplied and a system restart is not required, <b>DiUninstallDevice</b> sets the value to <b>FALSE</b>. 
     * 
     * If this parameter is <b>NULL</b> and a system restart is required to complete the device uninstallation, <b>DiUninstallDevice</b> displays a system restart dialog box.
     * 
     * For more information about this parameter, see the <b>Remarks</b> section.
     * @returns {Integer} <b>DiUninstallDevice</b> returns <b>TRUE</b> if the function successfully uninstalled the top-level device node that represents the device.  Otherwise, <b>DiUninstallDevice</b> returns <b>FALSE</b>, and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list shows some of the more common error values that <b>GetLastError</b> might return for this API:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to uninstall devices.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value that is specified for the <i>Flags</i> parameter is not equal to zero.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>The return value does not indicate that the removal of all child devnodes has succeeded or failed. Starting with Windows Vista, information about the status of the removal of child devnodes  is available in the <i>Setupapi.dev.log</i> file. For more information about this file, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/setupapi-text-logs">SetupAPI Text Logs</a>.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-diuninstalldevice
     * @since windows6.1
     */
    static DiUninstallDevice(hwndParent, DeviceInfoSet, DeviceInfoData, Flags, NeedReboot) {
        A_LastError := 0

        result := DllCall("newdev.dll\DiUninstallDevice", "ptr", hwndParent, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiUninstallDriver function removes a driver package from any devices it is installed on by installing those devices with another matching driver package, if available, or the null driver if no other matching driver package is available. Then the specified driver package is removed from the driver store. (Unicode)
     * @remarks
     * In general, an uninstallation application should set <i>NeedReboot</i> to <b>NULL</b> to direct <b>DiUninstallDriver</b> to prompt the user to restart the system if a restart is required to complete the removal. An application should supply a <i>NeedReboot</i> pointer only in the following cases:
     * 
     * <ul>
     * <li>
     * The application must call <b>DiUninstallDriver</b> several times to complete an uninstallation. In this case, the application should record whether a <b>TRUE</b> <i>NeedReboot</i> value is returned by any of the calls to <b>DiUninstallDriver</b> and, if so, prompt the user to restart the system after the final call to <b>DiUninstallDriver</b> returns.
     * 
     * </li>
     * <li>
     * The application must perform required operations, other than calling <b>DiUninstallDriver</b>, before a system restart should occur. If a system restart is required, the application should finish the required operations and then prompt the user to restart the system. 
     * 
     * </li>
     * 
     * </ul>
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window that <b>DiUninstallDriver</b> should use to display any user interface component that is associated with uninstalling the driver. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<PWSTR>} InfPath A pointer to a NULL-terminated string that supplies the fully qualified path of the INF file for the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-packages">driver package</a>.
     * @param {Integer} Flags A value of type DWORD that specifies zero or one or more of the following flags: DIURFLAG_NO_REMOVE_INF. Typically, this flag should be set to zero. 
     * 
     * If this flag is zero, <b>DiUninstallDriver</b> removes the driver package from any devices it is installed on by installing those devices with another matching driver package, if available, or the null driver if no other matching driver package is available. However, if this flag is set to DIURFLAG_NO_REMOVE_INF, <b>DiUninstallDriver</b> removes the driver package from any devices it is installed on, but does not remove the driver package from the Driver Store.
     * 
     * <div class="alert"><b>Caution:</b>Forcing the uninstallation of the driver package can result in replacing a more compatible or newer driver package with a less compatible or older driver. </div>
     * <div></div>
     * For information about how Windows selects a driver package for a device, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>.
     * @param {Pointer<Int32>} NeedReboot A pointer to a value of type BOOL that <b>DiUninstallDriver</b> sets to indicate whether a system restart is required to complete the uninstallation. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the uninstallation, <b>DiUninstallDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the uninstallation, <b>DiUninstallDriver</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the uninstallation, <b>DiUninstallDriver</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>DiUninstallDriver</b> returns <b>TRUE</b> if the function successfully removes the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-packages">driver package</a> from any devices it is installed on and is successfully removed from the driver store of the system. If the driver package is not successfully uninstalled from the driver store, <b>DiUninstallDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to uninstall a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-packages">driver package</a> from the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path of the specified INF file does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or DIURFLAG_NO_REMOVE_INF.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-diuninstalldriverw
     * @since windows10.0.10240
     */
    static DiUninstallDriverW(hwndParent, InfPath, Flags, NeedReboot) {
        InfPath := InfPath is String? StrPtr(InfPath) : InfPath

        A_LastError := 0

        result := DllCall("newdev.dll\DiUninstallDriverW", "ptr", hwndParent, "ptr", InfPath, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiUninstallDriver function removes a driver package from any devices it is installed on by installing those devices with another matching driver package, if available, or the null driver if no other matching driver package is available. Then the specified driver package is removed from the driver store. (ANSI)
     * @remarks
     * In general, an uninstallation application should set <i>NeedReboot</i> to <b>NULL</b> to direct <b>DiUninstallDriver</b> to prompt the user to restart the system if a restart is required to complete the removal. An application should supply a <i>NeedReboot</i> pointer only in the following cases:
     * 
     * <ul>
     * <li>
     * The application must call <b>DiUninstallDriver</b> several times to complete an uninstallation. In this case, the application should record whether a <b>TRUE</b> <i>NeedReboot</i> value is returned by any of the calls to <b>DiUninstallDriver</b> and, if so, prompt the user to restart the system after the final call to <b>DiUninstallDriver</b> returns.
     * </li>
     * 
     * <li>
     * The application must perform required operations, other than calling <b>DiUninstallDriver</b>, before a system restart should occur. If a system restart is required, the application should finish the required operations and then prompt the user to restart the system.
     * </li>
     * </ul>
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window that <b>DiUninstallDriver</b> should use to display any user interface component that is associated with uninstalling the driver. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<PSTR>} InfPath A pointer to a NULL-terminated string that supplies the fully qualified path of the INF file for the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-packages">driver package</a>.
     * @param {Integer} Flags A value of type DWORD that specifies zero or one or more of the following flags: DIURFLAG_NO_REMOVE_INF. Typically, this flag should be set to zero. 
     * 
     * If this flag is zero, <b>DiUninstallDriver</b> removes the driver package from any devices it is installed on by installing those devices with another matching driver package, if available, or the null driver if no other matching driver package is available. However, if this flag is set to DIURFLAG_NO_REMOVE_INF, <b>DiUninstallDriver</b> removes the driver package from any devices it is installed on, but does not remove the driver package from the Driver Store.
     * 
     * <div class="alert"><b>Caution:</b>Forcing the uninstallation of the driver package can result in replacing a more compatible or newer driver package with a less compatible or older driver. </div>
     * <div></div>
     * 
     * For information about how Windows selects a driver package for a device, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>.
     * @param {Pointer<Int32>} NeedReboot A pointer to a value of type BOOL that <b>DiUninstallDriver</b> sets to indicate whether a system restart is required to complete the uninstallation. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the uninstallation, <b>DiUninstallDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the uninstallation, <b>DiUninstallDriver</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the uninstallation, <b>DiUninstallDriver</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>DiUninstallDriver</b> returns <b>TRUE</b> if the function successfully removes the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-packages">driver package</a> from any devices it is installed on and is successfully removed from the driver store of the system. If the driver package is not successfully uninstalled from the driver store, <b>DiUninstallDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to uninstall a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-packages">driver package</a> from the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/driver-store">driver store</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path of the specified INF file does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or DIURFLAG_NO_REMOVE_INF.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-diuninstalldrivera
     */
    static DiUninstallDriverA(hwndParent, InfPath, Flags, NeedReboot) {
        InfPath := InfPath is String? StrPtr(InfPath) : InfPath

        A_LastError := 0

        result := DllCall("newdev.dll\DiUninstallDriverA", "ptr", hwndParent, "ptr", InfPath, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiShowUpdateDevice function displays the Hardware Update wizard for a specified device.
     * @remarks
     * <b>DiShowUpdateDevice</b> displays the Hardware Update wizard for the specified device instance. For information about how to update device drivers by using the Hardware Update wizard, see Help and Support Center.
     * 
     * In general, installation applications should set <i>NeedReboot</i> to <b>NULL</b> so that the system will automatically initiate a system restart if a restart is required to complete a hardware update. An application should supply a <i>NeedReboot</i> pointer only in the following cases:
     * 
     * <ul>
     * <li>
     * The installation application must call <b>DiShowUpdateDevice</b> several times to complete hardware updates. In this case, the application should record whether a <b>TRUE</b><i>NeedReboot</i> value is returned by any of the calls to <b>DiShowUpdateDevice</b> and, if so, prompt the user to restart the system after the final call to <b>DiShowUpdateDevice</b> returns.
     * 
     * </li>
     * <li>
     * The application must perform required operations, other than calling <b>DiShowUpdateDevice</b>, before a system restart should occur. If a system restart is required, the application should finish the required operations and then prompt the user to restart the system.
     * 
     * </li>
     * </ul>
     * To roll back a driver for a device instead of invoking the Hardware Update wizard, call <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-dirollbackdriver">DiRollbackDriver</a>.
     * 
     * To install a new driver for a device instead of invoking the Hardware Update wizard, call <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-diinstalldrivera">DiInstallDriver</a> or <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-updatedriverforplugandplaydevicesa">UpdateDriverForPlugAndPlayDevices</a>.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window that <b>DiShowUpdateDevice</b> uses to display any user interface components that are associated with updating the specified device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which to show the Hardware Update wizard.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the device for which to show the Hardware Update wizard.
     * @param {Integer} Flags This parameter must be set to zero.
     * @param {Pointer<Int32>} NeedReboot A pointer to a value of type BOOL that <b>DiShowUpdateDevice</b> sets to indicate whether a system restart is required to complete the driver update. This parameter is optional and can be <b>NULL</b>. If the parameter is supplied and a system restart is required to complete the driver update, <b>DiShowUpdateDevice</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the installation, <b>DiShowUpdateDevice</b> sets the value to <b>FALSE</b>. If the parameter is <b>NULL</b> and a system restart is required to complete the driver update, <b>DiShowUpdateDevice</b> displays a system restart dialog box. For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>DiShowUpdateDevice</b> returns <b>TRUE</b> if the Hardware Update wizard successfully updated the driver for the specified device. Otherwise, <b>DiShowUpdateDevice</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some of the more common error values that <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the calling process have Administrator privileges to update a <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user canceled the Hardware Update wizard.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-dishowupdatedevice
     * @since windows6.0.6000
     */
    static DiShowUpdateDevice(hwndParent, DeviceInfoSet, DeviceInfoData, Flags, NeedReboot) {
        A_LastError := 0

        result := DllCall("newdev.dll\DiShowUpdateDevice", "ptr", hwndParent, "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The DiRollbackDriver function rolls back the driver that is installed on a specified device.
     * @remarks
     * If a previously installed backup driver is set for a device, a driver rollback for the device replaces the driver that is currently installed on the device with the backup driver. Windows maintains at most one backup driver for a device. Windows sets a driver as the backup driver for a device immediately after the driver is successfully installed on the device and Windows determines that the device is functioning correctly. However, if a driver does not install successfully on a device or the device does not function correctly after the installation, Windows does not set the driver as the backup driver for the device. For more information about driver rollback, see information about Device Manager in Help and Support Center.
     * 
     * If the specified device has a backup driver, <b>DiRollbackDriver</b> performs the following operations:
     * 
     * <ol>
     * <li>
     * If <i>Flags</i> is set to zero, <b>DiRollbackDriver</b> prompts the user to confirm whether the backup driver should be installed. Otherwise, if <i>Flags</i> is set to ROLLBACK_FLAG_NO_UI, <b>DiRollbackDriver</b> installs the backup driver without prompting the user to confirm the installation of the backup driver.
     * 
     * </li>
     * <li>
     * <b>DiRollbackDriver</b> installs the backup driver. The driver is installed whether the backup driver is a better match for the device than the driver that is currently installed on the device.
     * 
     * </li>
     * <li>
     * If the driver that is replaced by the backup driver is not an inbox driver and is not installed on any other devices in the system, <b>DiRollbackDriver</b> removes the driver from the system. <b>DiRollbackDriver</b> removes the driver from the system because it is assumed that a user will replace a driver only if there is a problem with the driver. 
     * 
     * </li>
     * </ol>
     * If the specified device does not have a backup driver, <b>DiRollbackDriver</b> calls <b>SetLastError</b> to set the error ERROR_NO_MORE_ITEMS, does not remove the currently installed driver, and returns <b>FALSE</b>.
     * 
     * In general, installation applications should set <i>NeedReboot</i> to <b>NULL</b> so that the system will automatically initiate a system restart if a restart is required to complete the rollback. An application should supply a <i>NeedReboot</i> pointer only in the following cases:
     * 
     * <ul>
     * <li>
     * The application must call <b>DiRollbackDriver</b> several times to complete an installation. In this case, the application should record whether a <b>TRUE</b><i>NeedReboot</i> value is returned by any of the calls to <b>DiRollbackDriver</b> and, if so, prompt the user to restart the system after the final call to <b>DiRollbackDriver</b> returns.
     * 
     * </li>
     * <li>
     * The application must perform required operations, other than calling <b>DiRollbackDriver</b>, before a system restart should occur. If a system restart is required, the application should finish the required operations and then prompt the user to restart the system. 
     * 
     * </li>
     * </ul>
     * To install a new driver for a device instead of rolling back the driver for the device, call <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-diinstalldrivera">DiInstallDriver</a> or <a href="https://docs.microsoft.com/windows/desktop/api/newdev/nf-newdev-updatedriverforplugandplaydevicesa">UpdateDriverForPlugAndPlayDevices</a>.
     * @param {Pointer} DeviceInfoSet A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> that contains a device information element that represents the device for which driver rollback is performed.
     * @param {Pointer<SP_DEVINFO_DATA>} DeviceInfoData A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_data">SP_DEVINFO_DATA</a> structure that represents the specific device in the specified device information set for which driver rollback is performed.
     * @param {Pointer<HWND>} hwndParent A handle to the top-level window that <b>DiRollbackDriver</b> uses to display any user interface component that is associated with a driver rollback for the specified device. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Integer} Flags A value of type DWORD that can be set to zero or ROLLBACK_FLAG_NO_UI. 
     * 
     * Typically, this flag should be set to zero, in which case <b>DiRollbackDriver</b> does not suppress the default user interface components that are associated with a driver rollback. However, if this flag is set to ROLLBACK_FLAG_NO_UI, <b>DiRollbackDriver</b> suppresses the display of user interface components that are associated with a driver rollback.
     * @param {Pointer<Int32>} NeedReboot A pointer to a value of type BOOL that <b>DiRollbackDriver</b> sets to indicate whether a system restart is required to complete the rollback. This parameter is optional and can be <b>NULL</b>. 
     * 
     * If the parameter is supplied and a system restart is required to complete the rollback, <b>DiRollbackDriver</b> sets the value to <b>TRUE</b>. In this case, the caller must prompt the user to restart the system. If this parameter is supplied and a system restart is not required to complete the installation, <b>DiRollbackDriver</b> sets the value to <b>FALSE</b>. 
     * 
     * If the parameter is <b>NULL</b> and a system restart is required to complete the rollback, <b>DiRollbackDriver</b> displays a system restart dialog box. 
     * 
     * For more information about this parameter, see the following <b>Remarks</b> section.
     * @returns {Integer} <b>DiRollbackDriver</b> returns <b>TRUE</b> if the function successfully rolled back the driver for the device; otherwise, <b>DiRollbackDriver</b> returns <b>FALSE</b> and the logged error can be retrieved by making a call to <b>GetLastError</b>. Some of the more common error values that <b>GetLastError</b> might return are as follows:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have Administrator privileges. By default, Windows requires that the caller have Administrator privileges to roll back a <a href="https://docs.microsoft.com/previous-versions/windows/hardware/difxapi/driverpackagepreinstall">driver package</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_IN_WOW64</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling application is a 32-bit application that is attempting to execute in a 64-bit environment, which is not allowed. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-installations-on-64-bit-systems">Installing Devices on 64-Bit Systems</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for <i>Flags</i> is not equal to zero or ROLLBACK_FLAG_NO_UI.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A backup driver is not set for the device.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-dirollbackdriver
     * @since windows6.0.6000
     */
    static DiRollbackDriver(DeviceInfoSet, DeviceInfoData, hwndParent, Flags, NeedReboot) {
        A_LastError := 0

        result := DllCall("newdev.dll\DiRollbackDriver", "ptr", DeviceInfoSet, "ptr", DeviceInfoData, "ptr", hwndParent, "uint", Flags, "ptr", NeedReboot, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<HWND>} hwndParent 
     * @param {Pointer<PWSTR>} FilePath 
     * @param {Integer} Flags 
     * @param {Pointer<Int32>} NeedReboot 
     * @returns {Integer} 
     */
    static DiShowUpdateDriver(hwndParent, FilePath, Flags, NeedReboot) {
        FilePath := FilePath is String? StrPtr(FilePath) : FilePath

        result := DllCall("newdev.dll\DiShowUpdateDriver", "ptr", hwndParent, "ptr", FilePath, "uint", Flags, "ptr", NeedReboot, "int")
        return result
    }

;@endregion Methods
}
