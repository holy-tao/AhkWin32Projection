#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.Globalization
 * @version v4.0.30319
 */
class Globalization {

;@region Constants

    /**
     * @type {Integer (Int32)}
     */
    static LANG_SYSTEM_DEFAULT => 2048

    /**
     * @type {Integer (Int32)}
     */
    static LANG_USER_DEFAULT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SYSTEM_DEFAULT => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_USER_DEFAULT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static ALL_SERVICE_TYPES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static HIGHLEVEL_SERVICE_TYPES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOWLEVEL_SERVICE_TYPES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALL_SERVICES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ONLINE_SERVICES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_SERVICES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LEADBYTES => 12

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DEFAULTCHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static HIGH_SURROGATE_START => 55296

    /**
     * @type {Integer (UInt32)}
     */
    static HIGH_SURROGATE_END => 56319

    /**
     * @type {Integer (UInt32)}
     */
    static LOW_SURROGATE_START => 56320

    /**
     * @type {Integer (UInt32)}
     */
    static LOW_SURROGATE_END => 57343

    /**
     * @type {Integer (UInt32)}
     */
    static WC_COMPOSITECHECK => 512

    /**
     * @type {Integer (UInt32)}
     */
    static WC_DISCARDNS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static WC_SEPCHARS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static WC_DEFAULTCHAR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static WC_ERR_INVALID_CHARS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static WC_NO_BEST_FIT_CHARS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE3 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C1_UPPER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C1_LOWER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C1_DIGIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C1_SPACE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C1_PUNCT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static C1_CNTRL => 32

    /**
     * @type {Integer (UInt32)}
     */
    static C1_BLANK => 64

    /**
     * @type {Integer (UInt32)}
     */
    static C1_XDIGIT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static C1_ALPHA => 256

    /**
     * @type {Integer (UInt32)}
     */
    static C1_DEFINED => 512

    /**
     * @type {Integer (UInt32)}
     */
    static C2_LEFTTORIGHT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C2_RIGHTTOLEFT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPENUMBER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPESEPARATOR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPETERMINATOR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static C2_ARABICNUMBER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static C2_COMMONSEPARATOR => 7

    /**
     * @type {Integer (UInt32)}
     */
    static C2_BLOCKSEPARATOR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C2_SEGMENTSEPARATOR => 9

    /**
     * @type {Integer (UInt32)}
     */
    static C2_WHITESPACE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static C2_OTHERNEUTRAL => 11

    /**
     * @type {Integer (UInt32)}
     */
    static C2_NOTAPPLICABLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static C3_NONSPACING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C3_DIACRITIC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C3_VOWELMARK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C3_SYMBOL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C3_KATAKANA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HIRAGANA => 32

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HALFWIDTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static C3_FULLWIDTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static C3_IDEOGRAPH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static C3_KASHIDA => 512

    /**
     * @type {Integer (UInt32)}
     */
    static C3_LEXICAL => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HIGHSURROGATE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static C3_LOWSURROGATE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static C3_ALPHA => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static C3_NOTAPPLICABLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_LOWERCASE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_UPPERCASE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_TITLECASE => 768

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SORTKEY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_BYTEREV => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HIRAGANA => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_KATAKANA => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HALFWIDTH => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_FULLWIDTH => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_LINGUISTIC_CASING => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SIMPLIFIED_CHINESE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_TRADITIONAL_CHINESE => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SORTHANDLE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HASH => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_STARTSWITH => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_ENDSWITH => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_FROMSTART => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_FROMEND => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static LCID_ALTERNATE_SORTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_WINDOWS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SUPPLEMENTAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALTERNATE_SORTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_REPLACEMENT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_NEUTRALDATA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPECIFICDATA => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CP_ACP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CP_OEMCP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CP_MACCP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CP_THREAD_ACP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CP_SYMBOL => 42

    /**
     * @type {Integer (UInt32)}
     */
    static CP_UTF7 => 65000

    /**
     * @type {Integer (UInt32)}
     */
    static CP_UTF8 => 65001

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ALBANIA => 355

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ALGERIA => 213

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ARGENTINA => 54

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ARMENIA => 374

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AUSTRALIA => 61

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AUSTRIA => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AZERBAIJAN => 994

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BAHRAIN => 973

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELARUS => 375

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELGIUM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELIZE => 501

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BOLIVIA => 591

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BRAZIL => 55

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BRUNEI_DARUSSALAM => 673

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BULGARIA => 359

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CANADA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CARIBBEAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CHILE => 56

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_COLOMBIA => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_COSTA_RICA => 506

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CROATIA => 385

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CZECH => 420

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DENMARK => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DOMINICAN_REPUBLIC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ECUADOR => 593

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_EGYPT => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_EL_SALVADOR => 503

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ESTONIA => 372

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FAEROE_ISLANDS => 298

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FINLAND => 358

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FRANCE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GEORGIA => 995

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GERMANY => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GREECE => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GUATEMALA => 502

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HONDURAS => 504

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HONG_KONG => 852

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HUNGARY => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ICELAND => 354

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_INDIA => 91

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_INDONESIA => 62

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRAN => 981

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRAQ => 964

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRELAND => 353

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ISRAEL => 972

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ITALY => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JAMAICA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JAPAN => 81

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JORDAN => 962

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KAZAKSTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KENYA => 254

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KUWAIT => 965

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KYRGYZSTAN => 996

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LATVIA => 371

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LEBANON => 961

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LIBYA => 218

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LIECHTENSTEIN => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LITHUANIA => 370

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LUXEMBOURG => 352

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MACAU => 853

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MACEDONIA => 389

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MALAYSIA => 60

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MALDIVES => 960

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MEXICO => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MONACO => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MONGOLIA => 976

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MOROCCO => 212

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NETHERLANDS => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NEW_ZEALAND => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NICARAGUA => 505

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NORWAY => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_OMAN => 968

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PAKISTAN => 92

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PANAMA => 507

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PARAGUAY => 595

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PERU => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PHILIPPINES => 63

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_POLAND => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PORTUGAL => 351

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PRCHINA => 86

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PUERTO_RICO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_QATAR => 974

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ROMANIA => 40

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_RUSSIA => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SAUDI_ARABIA => 966

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SERBIA => 381

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SINGAPORE => 65

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SLOVAK => 421

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SLOVENIA => 386

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SOUTH_AFRICA => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SOUTH_KOREA => 82

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SPAIN => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SWEDEN => 46

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SWITZERLAND => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SYRIA => 963

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TAIWAN => 886

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TATARSTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_THAILAND => 66

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TRINIDAD_Y_TOBAGO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TUNISIA => 216

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TURKEY => 90

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UAE => 971

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UKRAINE => 380

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UNITED_KINGDOM => 44

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UNITED_STATES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_URUGUAY => 598

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UZBEKISTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_VENEZUELA => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_VIET_NAM => 84

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_YEMEN => 967

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ZIMBABWE => 263

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_NOUSEROVERRIDE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_USE_CP_ACP => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_RETURN_NUMBER => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_RETURN_GENITIVE_NAMES => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALLOW_NEUTRAL_NAMES => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDDISPLAYNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHDISPLAYNAME => 114

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVEDISPLAYNAME => 115

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDLANGUAGENAME => 111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHLANGUAGENAME => 4097

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVELANGUAGENAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDCOUNTRYNAME => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHCOUNTRYNAME => 4098

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECOUNTRYNAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIALINGCODE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLIST => 12

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IMEASURE => 13

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDECIMAL => 14

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STHOUSAND => 15

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SGROUPING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIGITS => 17

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILZERO => 18

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGNUMBER => 4112

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVEDIGITS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCURRENCY => 20

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SINTLSYMBOL => 21

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONDECIMALSEP => 22

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHOUSANDSEP => 23

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONGROUPING => 24

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICURRDIGITS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICURRENCY => 27

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGCURR => 28

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTDATE => 31

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLONGDATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STIMEFORMAT => 4099

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SAM => 40

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPM => 41

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICALENDARTYPE => 4105

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IOPTIONALCALENDAR => 4107

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IFIRSTDAYOFWEEK => 4108

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IFIRSTWEEKOFYEAR => 4109

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME1 => 42

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME2 => 43

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME3 => 44

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME4 => 45

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME5 => 46

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME6 => 47

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME7 => 48

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME1 => 49

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME2 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME3 => 51

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME4 => 52

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME5 => 53

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME6 => 54

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME7 => 55

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME1 => 56

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME2 => 57

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME3 => 58

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME4 => 59

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME5 => 60

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME6 => 61

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME7 => 62

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME8 => 63

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME9 => 64

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME10 => 65

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME11 => 66

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME12 => 67

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME13 => 4110

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME1 => 68

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME2 => 69

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME3 => 70

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME4 => 71

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME5 => 72

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME6 => 73

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME7 => 74

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME8 => 75

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME9 => 76

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME10 => 77

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME11 => 78

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME12 => 79

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME13 => 4111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPOSITIVESIGN => 80

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNEGATIVESIGN => 81

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSIGNPOSN => 82

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSIGNPOSN => 83

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSYMPRECEDES => 84

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSEPBYSPACE => 85

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSYMPRECEDES => 86

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSEPBYSPACE => 87

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_FONTSIGNATURE => 88

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO639LANGNAME => 89

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO3166CTRYNAME => 90

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPAPERSIZE => 4106

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGCURRNAME => 4103

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECURRNAME => 4104

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SYEARMONTH => 4102

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSORTNAME => 4115

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIGITSUBSTITUTION => 4116

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNAME => 92

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDURATION => 93

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME1 => 96

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME2 => 97

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME3 => 98

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME4 => 99

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME5 => 100

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME6 => 101

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME7 => 102

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO639LANGNAME2 => 103

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO3166CTRYNAME2 => 104

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNAN => 105

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPOSINFINITY => 106

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNEGINFINITY => 107

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSCRIPTS => 108

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPARENT => 109

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCONSOLEFALLBACKNAME => 110

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IREADINGLAYOUT => 112

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEUTRAL => 113

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGATIVEPERCENT => 116

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSITIVEPERCENT => 117

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPERCENT => 118

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPERMILLE => 119

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHDAY => 120

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTTIME => 121

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SOPENTYPELANGUAGETAG => 122

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSORTLOCALE => 123

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SRELATIVELONGDATE => 124

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICONSTRUCTEDLOCALE => 125

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTAM => 126

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTPM => 127

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IUSEUTF8LEGACYACP => 1638

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IUSEUTF8LEGACYOEMCP => 2457

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTCODEPAGE => 11

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTANSICODEPAGE => 4100

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTMACCODEPAGE => 4113

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTEBCDICCODEPAGE => 4114

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILANGUAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVLANGNAME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVCTRYNAME => 7

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IGEOID => 91

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTLANGUAGE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTCOUNTRY => 10

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IINTLCURRDIGITS => 26

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDATE => 29

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STIME => 30

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDATE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILDATE => 34

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITIME => 35

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITIMEMARKPOSN => 4101

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICENTURY => 36

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITLZERO => 37

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDAYLZERO => 38

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IMONLZERO => 39

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SKEYBOARDSTOINSTALL => 94

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLANGUAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLANGDISPLAYNAME => 111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLANGUAGE => 4097

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVELANGNAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCOUNTRY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGCOUNTRY => 4098

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECTRYNAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICOUNTRY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_S1159 => 40

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_S2359 => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_NOUSEROVERRIDE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_USE_CP_ACP => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_RETURN_NUMBER => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_RETURN_GENITIVE_NAMES => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_ICALINTVALUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SCALNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_IYEAROFFSETRANGE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SERASTRING => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTDATE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SLONGDATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME1 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME2 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME3 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME4 => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME5 => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME6 => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME7 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME1 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME2 => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME3 => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME4 => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME5 => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME6 => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME7 => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME1 => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME2 => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME3 => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME4 => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME5 => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME6 => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME7 => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME8 => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME9 => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME10 => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME11 => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME12 => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME13 => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME1 => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME2 => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME3 => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME4 => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME5 => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME6 => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME7 => 40

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME8 => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME9 => 42

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME10 => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME11 => 44

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME12 => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME13 => 46

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SYEARMONTH => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_ITWODIGITYEARMAX => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME1 => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME2 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME3 => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME4 => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME5 => 53

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME6 => 54

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME7 => 55

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHDAY => 56

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVERASTRING => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SRELATIVELONGDATE => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SENGLISHERANAME => 59

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SENGLISHABBREVERANAME => 60

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SJAPANESEERAFIRSTYEAR => 61

    /**
     * @type {Integer (UInt32)}
     */
    static ENUM_ALL_CALENDARS => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_US => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_JAPAN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_TAIWAN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_KOREA => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_HIJRI => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_THAI => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_HEBREW => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_ME_FRENCH => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_ARABIC => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_XLIT_ENGLISH => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_XLIT_FRENCH => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_PERSIAN => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_UMALQURA => 23

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_WESTERN_EUROPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_CENTRAL_EUROPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_BALTIC => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_GREEK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_CYRILLIC => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TURKIC => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TURKISH => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_JAPANESE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_KOREAN => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TRADITIONAL_CHINESE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_SIMPLIFIED_CHINESE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_THAI => 11

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_HEBREW => 12

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_ARABIC => 13

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_VIETNAMESE => 14

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_INDIC => 15

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_GEORGIAN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_ARMENIAN => 17

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_NAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MERGE_SYSTEM_FALLBACK => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MERGE_USER_FALLBACK => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_THREAD_LANGUAGES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_CONSOLE_FILTER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_COMPLEX_SCRIPT_FILTER => 512

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_RESET_FILTERS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USER_PREFERRED_UI_LANGUAGES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USE_INSTALLED_LANGUAGES => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USE_SEARCH_ALL_LANGUAGES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANG_NEUTRAL_PE_FILE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_NON_LANG_NEUTRAL_FILE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MACHINE_LANGUAGE_SETTINGS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_CHECKSUM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_LANGUAGE_NAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_RESOURCE_TYPES => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILEINFO_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FULL_LANGUAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_PARTIAL_LANGUAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LIP_LANGUAGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_INSTALLED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_LICENSED => 64

    /**
     * @type {Integer (Int32)}
     */
    static GEOID_NOT_AVAILABLE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static SORTING_PARADIGM_NLS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SORTING_PARADIGM_ICU => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_ALLOW_UNASSIGNED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_USE_STD3_ASCII_RULES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_EMAIL_ADDRESS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_RAW_PUNYCODE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static VS_ALLOW_LATIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GSS_ALLOW_INHERITED_COMMON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FORMAT_REG_COMPAT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FORMAT_INF_COMPAT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_VERIFY_FILE_EXISTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_SKIP_STRING_CACHE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_IMMUTABLE_LOOKUP => 16

    /**
     * @type {String}
     */
    static LOCALE_NAME_INVARIANT => ""

    /**
     * @type {String}
     */
    static LOCALE_NAME_SYSTEM_DEFAULT => "!x-sys-default-locale"

    /**
     * @type {Integer (UInt32)}
     */
    static MIN_SPELLING_NTDDI => 100794368

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_UNDEFINED => 0

    /**
     * @type {Integer (Int32)}
     */
    static USP_E_SCRIPT_NOT_IN_FONT => -2147220992

    /**
     * @type {Integer (UInt32)}
     */
    static SGCM_RTL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_PASSWORD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_TAB => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_CLIP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_DZWG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FALLBACK => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_BREAK => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_GLYPHS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_RTL => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_GCP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HOTKEY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_METAFILE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LINK => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HIDEHOTKEY => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HOTKEYONLY => 9216

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FULLMEASURE => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LPKANSIFALLBACK => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_PIDX => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LAYOUTRTL => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_DONTGLYPH => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_NOKASHIDA => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_CONTEXT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_NONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_NATIONAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_TRADITIONAL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static UNISCRIBE_OPENTYPE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_TAG_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_EXACT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_CPINFO => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_MBTOWC => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_WCTOMB => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static U_DISABLE_RENAMING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHOW_CPLUSPLUS_API => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEFAULT_SHOW_DRAFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_DRAFT_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_DEPRECATED_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_OBSOLETE_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_INTERNAL_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_NO_DEFAULT_INCLUDE_UTF_HEADERS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEBUG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCLN_NO_AUTO_CLEANUP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_OVERRIDE_CXX_ALLOCATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_ENABLE_TRACING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ENABLE_PLUGINS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_ENABLE_DYLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHECK_DYLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_LIB_SUFFIX => 1

    /**
     * @type {String}
     */
    static U_LIB_SUFFIX_C_NAME_STRING => ""

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ONLY_COLLATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_BREAK_ITERATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_IDNA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FORMATTING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_TRANSLITERATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_REGULAR_EXPRESSIONS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FILE_IO => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_CONVERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_LEGACY_CONVERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ONLY_HTML_CONVERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_NORMALIZATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_COLLATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_SERVICE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_HAVE_PARSEALLINPUT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FILTERED_BREAK_ITERATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_WINDOWS => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_MINGW => 1800

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_CYGWIN => 1900

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_HPUX => 2100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_SOLARIS => 2600

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_BSD => 3000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_AIX => 3100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_IRIX => 3200

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_DARWIN => 3500

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_IPHONE => 3550

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_QNX => 3700

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_LINUX => 4000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_BROWSER_NATIVE_CLIENT => 4020

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_ANDROID => 4050

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_FUCHSIA => 4100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_EMSCRIPTEN => 5010

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_OS390 => 9000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_OS400 => 9400

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM => 1800

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_USES_ONLY_WIN32_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_HAS_WIN32_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IMPLEMENTS_POSIX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IS_LINUX_BASED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IS_DARWIN_BASED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_STDINT_H => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_INTTYPES_H => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_GCC_MAJOR_MINOR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_IS_BIG_ENDIAN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_PLACEMENT_NEW => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_DEBUG_LOCATION_NEW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CPLUSPLUS_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_ASCII_FAMILY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_EBCDIC_FAMILY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHARSET_FAMILY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHARSET_IS_UTF8 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_WCHAR_H => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SIZEOF_WCHAR_T => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_WCSCPY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_CHAR16_T => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEFINE_FALSE_AND_TRUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SIZEOF_UCHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHAR16_IS_TYPEDEF => 1

    /**
     * @type {Integer (Int32)}
     */
    static U_SENTINEL => -1

    /**
     * @type {String}
     */
    static U8_LEAD3_T1_BITS => " 000000000000\u001000"

    /**
     * @type {String}
     */
    static U8_LEAD4_T1_BITS => "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001e\u000f\u000f\u000f\u0000\u0000\u0000\u0000"

    /**
     * @type {Integer (UInt32)}
     */
    static U8_MAX_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U16_MAX_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_OBSOLETE_UTF_OLD_H => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_SIZE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_ERROR_VALUE_1 => 21

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_ERROR_VALUE_2 => 159

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_ERROR_VALUE => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_MAX_CHAR_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static UTF16_MAX_CHAR_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static UTF32_MAX_CHAR_LENGTH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_MAX_CHAR_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_COPYRIGHT_STRING_LENGTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static U_MAX_VERSION_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_MAX_VERSION_STRING_LENGTH => 20

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_SECOND => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_MINUTE => 60000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_HOUR => 3600000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_DAY => 86400000

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMBINED_IMPLEMENTATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_GROW_SHRINK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_RESIZE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_NEAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_NEAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_AT_END => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_END => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_AT_BEGINNING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_BEGIN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_AUTO => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_MASK => 65539

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_MASK => 65539

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_LOGICAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_VISUAL_RTL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_VISUAL_LTR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_MASK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_SHAPE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_UNSHAPE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_SHAPE_TASHKEEL_ISOLATED => 24

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_MASK => 24

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_EN2AN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_AN2EN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_ALEN2AN_INIT_LR => 96

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_ALEN2AN_INIT_AL => 128

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_RESERVED => 160

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_MASK => 224

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_AN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_AN_EXTENDED => 256

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_RESERVED => 512

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_MASK => 768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL_MASK => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION_MASK => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SEEN_TWOCELL_NEAR => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SEEN_MASK => 7340032

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_YEHHAMZA_TWOCELL_NEAR => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_YEHHAMZA_MASK => 58720256

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_BEGIN => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_END => 393216

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_RESIZE => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_REPLACE_BY_TATWEEL => 786432

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_MASK => 917504

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SPACES_RELATIVE_TO_TEXT_BEGIN_END => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SPACES_RELATIVE_TO_TEXT_MASK => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TAIL_NEW_UNICODE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TAIL_TYPE_MASK => 134217728

    /**
     * @type {String}
     */
    static ULOC_CHINESE => "zh"

    /**
     * @type {String}
     */
    static ULOC_ENGLISH => "en"

    /**
     * @type {String}
     */
    static ULOC_FRENCH => "fr"

    /**
     * @type {String}
     */
    static ULOC_GERMAN => "de"

    /**
     * @type {String}
     */
    static ULOC_ITALIAN => "it"

    /**
     * @type {String}
     */
    static ULOC_JAPANESE => "ja"

    /**
     * @type {String}
     */
    static ULOC_KOREAN => "ko"

    /**
     * @type {String}
     */
    static ULOC_SIMPLIFIED_CHINESE => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_TRADITIONAL_CHINESE => "zh_TW"

    /**
     * @type {String}
     */
    static ULOC_CANADA => "en_CA"

    /**
     * @type {String}
     */
    static ULOC_CANADA_FRENCH => "fr_CA"

    /**
     * @type {String}
     */
    static ULOC_CHINA => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_PRC => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_FRANCE => "fr_FR"

    /**
     * @type {String}
     */
    static ULOC_GERMANY => "de_DE"

    /**
     * @type {String}
     */
    static ULOC_ITALY => "it_IT"

    /**
     * @type {String}
     */
    static ULOC_JAPAN => "ja_JP"

    /**
     * @type {String}
     */
    static ULOC_KOREA => "ko_KR"

    /**
     * @type {String}
     */
    static ULOC_TAIWAN => "zh_TW"

    /**
     * @type {String}
     */
    static ULOC_UK => "en_GB"

    /**
     * @type {String}
     */
    static ULOC_US => "en_US"

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_LANG_CAPACITY => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_COUNTRY_CAPACITY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_FULLNAME_CAPACITY => 157

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_SCRIPT_CAPACITY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORDS_CAPACITY => 96

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_AND_VALUES_CAPACITY => 100

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_SEPARATOR_UNICODE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_ASSIGN_UNICODE => 61

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE => 59

    /**
     * @type {String}
     */
    static UCNV_SUB_STOP_ON_ILLEGAL => "i"

    /**
     * @type {String}
     */
    static UCNV_SKIP_STOP_ON_ILLEGAL => "i"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_JAVA => "J"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_C => "C"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_XML_DEC => "D"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_XML_HEX => "X"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_UNICODE => "U"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_CSS2 => "S"

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_MAX_CONVERTER_NAME_LENGTH => 60

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_SI => 15

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_SO => 14

    /**
     * @type {String}
     */
    static UCNV_OPTION_SEP_STRING => ","

    /**
     * @type {String}
     */
    static UCNV_VALUE_SEP_STRING => "="

    /**
     * @type {String}
     */
    static UCNV_LOCALE_OPTION_STRING => ",locale="

    /**
     * @type {String}
     */
    static UCNV_VERSION_OPTION_STRING => ",version="

    /**
     * @type {String}
     */
    static UCNV_SWAP_LFNL_OPTION_STRING => ",swaplfnl"

    /**
     * @type {Integer (UInt32)}
     */
    static U_FOLD_CASE_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_FOLD_CASE_EXCLUDE_SPECIAL_I => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_WHOLE_STRING => 32

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_SENTENCES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_NO_LOWERCASE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_NO_BREAK_ADJUSTMENT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_ADJUST_TO_CASED => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static U_EDITS_NO_RESET => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static U_OMIT_UNCHANGED_TEXT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMPARE_CODE_POINT_ORDER => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMPARE_IGNORE_CASE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static UNORM_INPUT_IS_FCD => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static UCHAR_MIN_VALUE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCHAR_MAX_VALUE => 1114111

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DEFAULT_LTR => 254

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DEFAULT_RTL => 255

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_MAX_EXPLICIT_LEVEL => 125

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_LEVEL_OVERRIDE => 128

    /**
     * @type {Integer (Int32)}
     */
    static UBIDI_MAP_NOWHERE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_KEEP_BASE_COMBINING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DO_MIRRORING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_INSERT_LRM_FOR_NUMERIC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_REMOVE_BIDI_CONTROLS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_OUTPUT_REVERSE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static USPREP_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static USPREP_ALLOW_UNASSIGNED => 1

    /**
     * @type {String}
     */
    static U_ICU_VERSION_BUNDLE => "icuver"

    /**
     * @type {String}
     */
    static U_ICU_DATA_KEY => "DataVersion"

    /**
     * @type {String}
     */
    static UCAL_UNKNOWN_ZONE_ID => "Etc/Unknown"

    /**
     * @type {String}
     */
    static UDAT_YEAR => "y"

    /**
     * @type {String}
     */
    static UDAT_QUARTER => "QQQQ"

    /**
     * @type {String}
     */
    static UDAT_ABBR_QUARTER => "QQQ"

    /**
     * @type {String}
     */
    static UDAT_YEAR_QUARTER => "yQQQQ"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_QUARTER => "yQQQ"

    /**
     * @type {String}
     */
    static UDAT_MONTH => "MMMM"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH => "MMM"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH => "M"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH => "yMMMM"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH => "yMMM"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH => "yM"

    /**
     * @type {String}
     */
    static UDAT_DAY => "d"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH_DAY => "yMMMMd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH_DAY => "yMMMd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH_DAY => "yMd"

    /**
     * @type {String}
     */
    static UDAT_WEEKDAY => "EEEE"

    /**
     * @type {String}
     */
    static UDAT_ABBR_WEEKDAY => "E"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH_WEEKDAY_DAY => "yMMMMEEEEd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH_WEEKDAY_DAY => "yMMMEd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH_WEEKDAY_DAY => "yMEd"

    /**
     * @type {String}
     */
    static UDAT_MONTH_DAY => "MMMMd"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH_DAY => "MMMd"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH_DAY => "Md"

    /**
     * @type {String}
     */
    static UDAT_MONTH_WEEKDAY_DAY => "MMMMEEEEd"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH_WEEKDAY_DAY => "MMMEd"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH_WEEKDAY_DAY => "MEd"

    /**
     * @type {String}
     */
    static UDAT_HOUR => "j"

    /**
     * @type {String}
     */
    static UDAT_HOUR24 => "H"

    /**
     * @type {String}
     */
    static UDAT_MINUTE => "m"

    /**
     * @type {String}
     */
    static UDAT_HOUR_MINUTE => "jm"

    /**
     * @type {String}
     */
    static UDAT_HOUR24_MINUTE => "Hm"

    /**
     * @type {String}
     */
    static UDAT_SECOND => "s"

    /**
     * @type {String}
     */
    static UDAT_HOUR_MINUTE_SECOND => "jms"

    /**
     * @type {String}
     */
    static UDAT_HOUR24_MINUTE_SECOND => "Hms"

    /**
     * @type {String}
     */
    static UDAT_MINUTE_SECOND => "ms"

    /**
     * @type {String}
     */
    static UDAT_LOCATION_TZ => "VVVV"

    /**
     * @type {String}
     */
    static UDAT_GENERIC_TZ => "vvvv"

    /**
     * @type {String}
     */
    static UDAT_ABBR_GENERIC_TZ => "v"

    /**
     * @type {String}
     */
    static UDAT_SPECIFIC_TZ => "zzzz"

    /**
     * @type {String}
     */
    static UDAT_ABBR_SPECIFIC_TZ => "z"

    /**
     * @type {String}
     */
    static UDAT_ABBR_UTC_TZ => "ZZZZ"

    /**
     * @type {Integer (Int32)}
     */
    static USEARCH_DONE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_STD_STRING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_FORMAT_FASTPATHS_49 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_HAS_WINUWP_API => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_IOSTREAM_SOURCE => 199711

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_RVALUE_REFERENCES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_USING_ICU_NAMESPACE => 1

    /**
     * @type {String}
     */
    static U_ICUDATA_TYPE_LETTER => "e"

    /**
     * @type {String}
     */
    static U_UNICODE_VERSION => "8.0"

    /**
     * @type {Integer (UInt32)}
     */
    static CANITER_SKIP_ZEROES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NUMSYS_NAME_CAPACITY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_RBNF => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMECP_NAME => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMECSET_NAME => 50

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMEFACE_NAME => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_RFC1766_NAME => 6

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LOCALE_NAME => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SCRIPT_NAME => 48

    /**
     * @type {Integer (Int32)}
     */
    static CPIOD_PEEK => 1073741824

    /**
     * @type {Integer (Int32)}
     */
    static CPIOD_FORCE_PROMPT => -2147483648

    /**
     * @type {Integer (Int32)}
     */
    static UITER_UNKNOWN_INDEX => -2

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_SHIFT => 6

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_DATA_BLOCK_LENGTH => 64

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_DATA_MASK => 63

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_SMALL_MAX => 4095

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET => 1

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET => 2

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE => 1

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_STABLE_CHUNKS => 2

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_WRITABLE => 3

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_HAS_META_DATA => 4

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_OWNS_TEXT => 5

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_MAGIC => 878368812

    /**
     * @type {Integer (Int32)}
     */
    static USET_IGNORE_SPACE => 1

    /**
     * @type {Integer (Int32)}
     */
    static USET_CASE_INSENSITIVE => 2

    /**
     * @type {Integer (Int32)}
     */
    static USET_ADD_CASE_MAPPINGS => 4

    /**
     * @type {Integer (Int32)}
     */
    static USET_SERIALIZED_STATIC_ARRAY_CAPACITY => 8

    /**
     * @type {Integer (Int32)}
     */
    static U_PARSE_CONTEXT_LEN => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_DEFAULT => 0

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_USE_STD3_RULES => 2

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_BIDI => 4

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_CONTEXTJ => 8

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_NONTRANSITIONAL_TO_ASCII => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_NONTRANSITIONAL_TO_UNICODE => 32

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_CONTEXTO => 64

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_EMPTY_LABEL => 1

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LABEL_TOO_LONG => 2

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_DOMAIN_NAME_TOO_LONG => 4

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LEADING_HYPHEN => 8

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_TRAILING_HYPHEN => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_HYPHEN_3_4 => 32

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LEADING_COMBINING_MARK => 64

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_DISALLOWED => 128

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_PUNYCODE => 256

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LABEL_HAS_DOT => 512

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_INVALID_ACE_LABEL => 1024

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_BIDI => 2048

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTJ => 4096

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTO_PUNCTUATION => 8192

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTO_DIGITS => 16384

    /**
     * @type {String}
     */
    static ELS_GUID_LANGUAGE_DETECTION => "{cf7e00b1-909b-4d95-a8f4-611f7c377702}"

    /**
     * @type {String}
     */
    static ELS_GUID_SCRIPT_DETECTION => "{2d64b439-6caf-4f6b-b688-e5d0f4faa7d7}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_HANT_TO_HANS => "{a3a8333b-f4fc-42f6-a0c4-0462fe7317cb}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_HANS_TO_HANT => "{3caccdc8-5590-42dc-9a7b-b5a6b5b3b63b}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_MALAYALAM_TO_LATIN => "{d8b983b1-f8bf-4a2b-bcd5-5b5ea20613e1}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_DEVANAGARI_TO_LATIN => "{c4a4dcfe-2661-4d02-9835-f48187109803}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_CYRILLIC_TO_LATIN => "{3dd12a98-5afd-4903-a13f-e17e6c0bfe01}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_BENGALI_TO_LATIN => "{f4dfd825-91a4-489f-855e-9ad9bee55727}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_HANGUL_DECOMPOSITION => "{4ba2a721-e43d-41b7-b330-536ae1e48863}"

    /**
     * @type {Integer (Int32)}
     */
    static UMSGPAT_ARG_NAME_NOT_NUMBER => -1

    /**
     * @type {Integer (Int32)}
     */
    static UMSGPAT_ARG_NAME_NOT_VALID => -2
;@endregion Constants

;@region Methods
    /**
     * Retrieves a character set identifier for the font that is currently selected into a specified device context.
     * @param {Pointer<HDC>} hdc Handle to a device context. The function obtains a character set identifier for the font that is selected into this device context.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-gettextcharset
     * @since windows5.0
     */
    static GetTextCharset(hdc) {
        DllCall("GDI32.dll\GetTextCharset", "ptr", hdc)
    }

    /**
     * Retrieves information about the character set of the font that is currently selected into a specified device context.
     * @param {Pointer<HDC>} hdc Handle to a device context. The function obtains information about the font that is selected into this device context.
     * @param {Pointer<FONTSIGNATURE>} lpSig Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> data structure that receives font-signature information.
     * 
     * If a TrueType font is currently selected into the device context, the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure receives information that identifies the code page and Unicode subranges for which the font provides glyphs.
     * 
     * If a font other than TrueType is currently selected into the device context, the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure receives zeros. In this case, the application should use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-translatecharsetinfo">TranslateCharsetInfo</a> function to obtain generic font-signature information for the character set.
     * 
     * The <i>lpSig</i> parameter specifies <b>NULL</b> if the application does not require the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> information. In this case, the application can also call the       <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gettextcharset">GetTextCharset</a> function, which is equivalent to calling       <b>GetTextCharsetInfo</b> with <i>lpSig</i> set to <b>NULL</b>.
     * @param {Integer} dwFlags Reserved; must be set to 0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-gettextcharsetinfo
     * @since windows5.0
     */
    static GetTextCharsetInfo(hdc, lpSig, dwFlags) {
        DllCall("GDI32.dll\GetTextCharsetInfo", "ptr", hdc, "ptr", lpSig, "uint", dwFlags)
    }

    /**
     * Translates character set information and sets all members of a destination structure to appropriate values.
     * @param {Pointer<UInt32>} lpSrc Pointer to the <b>fsCsb</b> member of a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure if <i>dwFlags</i> is set to TCI_SRCFONTSIG. Otherwise, this parameter is set to a DWORD value indicating the source.
     * @param {Pointer<CHARSETINFO>} lpCs Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-charsetinfo">CHARSETINFO</a> structure that receives the translated character set information.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-translatecharsetinfo
     * @since windows5.0
     */
    static TranslateCharsetInfo(lpSrc, lpCs, dwFlags) {
        A_LastError := 0

        result := DllCall("GDI32.dll\TranslateCharsetInfo", "ptr", lpSrc, "ptr", lpCs, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a date as a date string for a locale specified by the locale identifier. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark ("?"). 
     *       
     * 
     * <b>Starting with Windows 8: </b><b>GetDateFormat</b>  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The datetimeapi.h header defines GetDateFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale this function formats the date string for. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying date format options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application sets this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {Pointer<PSTR>} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {Pointer<PSTR>} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-getdateformata
     * @since windows5.0
     */
    static GetDateFormatA(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetDateFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a date as a date string for a locale specified by the locale identifier. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark ("?"). 
     *       
     * 
     * <b>Starting with Windows 8: </b><b>GetDateFormat</b>  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The datetimeapi.h header defines GetDateFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale this function formats the date string for. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying date format options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application sets this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {Pointer<PWSTR>} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {Pointer<PWSTR>} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-getdateformatw
     * @since windows5.0
     */
    static GetDateFormatW(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetDateFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats time as a time string for a locale specified by identifier. The function formats either a specified time or the local system time. (ANSI)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * <b>Starting with Windows 8: </b><b>GetTimeFormat</b>  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The datetimeapi.h header defines GetTimeFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying time format options. For detailed definitions see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {Pointer<PSTR>} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {Pointer<PSTR>} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in TCHAR values, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-gettimeformata
     * @since windows5.0
     */
    static GetTimeFormatA(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetTimeFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats time as a time string for a locale specified by identifier. The function formats either a specified time or the local system time. (Unicode)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * <b>Starting with Windows 8: </b><b>GetTimeFormat</b>  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The datetimeapi.h header defines GetTimeFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying time format options. For detailed definitions see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {Pointer<PWSTR>} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {Pointer<PWSTR>} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in TCHAR values, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-gettimeformatw
     * @since windows5.0
     */
    static GetTimeFormatW(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetTimeFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats time as a time string for a locale specified by name.
     * @remarks
     * If a time marker exists and the TIME_NOTIMEMARKER flag is not set, the function localizes the time marker based on the specified locale identifier. Examples of time markers are "AM" and "PM" for English (United States).
     * 
     * The time values in the structure indicated by <i>lpTime</i> must be valid. The function checks each of the time values to determine that it is within the appropriate range of values. If any of the time values are outside the correct range, the function fails, and sets the last error to ERROR_INVALID_PARAMETER.
     * 
     * The function ignores the date members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure. These include: <b>wYear</b>, <b>wMonth</b>, <b>wDayOfWeek</b>, and <b>wDay</b>.
     * 
     * If TIME_NOMINUTESORSECONDS or TIME_NOSECONDS is specified, the function removes the separators following the minutes and/or seconds members.
     * 
     * If TIME_NOTIMEMARKER is specified, the function removes the separators preceding and following the time marker.
     * 
     * If TIME_FORCE24HOURFORMAT is specified, the function displays any existing time marker, unless the TIME_NOTIMEMARKER flag is also set.
     * 
     * The function does not include milliseconds as part of the formatted time string.
     * 
     * The function returns no errors for a bad format string, but just forms the best possible time string. If more than two hour, minute, second, or time marker format pictures are passed in, the function defaults to two. For example, the only time marker pictures that are valid are "t" and "tt". If "ttt" is passed in, the function assumes "tt".
     * 
     * To obtain the time format without performing any actual formatting, the application should use the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> function, specifying <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIMEFORMAT</a>.
     * 
     * The application can use the following elements to construct a format picture string. If spaces are used to separate the elements in the format string, these spaces appear in the same location in the output string. The letters must be in uppercase or lowercase as shown, for example, "ss", not "SS". Characters in the format string that are enclosed in single quotation marks appear in the same location and unchanged in the output string.
     * 
     * <table>
     * <tr>
     * <th>Picture</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>h</td>
     * <td>Hours with no leading zero for single-digit hours; 12-hour clock</td>
     * </tr>
     * <tr>
     * <td>hh</td>
     * <td>Hours with leading zero for single-digit hours; 12-hour clock</td>
     * </tr>
     * <tr>
     * <td>H</td>
     * <td>Hours with no leading zero for single-digit hours; 24-hour clock</td>
     * </tr>
     * <tr>
     * <td>HH</td>
     * <td>Hours with leading zero for single-digit hours; 24-hour clock</td>
     * </tr>
     * <tr>
     * <td>m</td>
     * <td>Minutes with no leading zero for single-digit minutes</td>
     * </tr>
     * <tr>
     * <td>mm</td>
     * <td>Minutes with leading zero for single-digit minutes</td>
     * </tr>
     * <tr>
     * <td>s</td>
     * <td>Seconds with no leading zero for single-digit seconds</td>
     * </tr>
     * <tr>
     * <td>ss</td>
     * <td>Seconds with leading zero for single-digit seconds</td>
     * </tr>
     * <tr>
     * <td>t</td>
     * <td>One character time marker string, such as A or P</td>
     * </tr>
     * <tr>
     * <td>tt</td>
     * <td>Multi-character time marker string, such as AM or PM</td>
     * </tr>
     * </table>
     *  
     * 
     * For example, to get the time string
     * 
     * 
     * ``` syntax
     * "11:29:40 PM"
     * ```
     * 
     * the application should use the picture string
     * 
     * 
     * ``` syntax
     * "hh':'mm':'ss tt"
     * ```
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * 
     * <b>Beginning in Windows 8: </b><b>GetTimeFormatEx</b>  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {Pointer<PWSTR>} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {Pointer<PWSTR>} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in characters, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-gettimeformatex
     * @since windows6.0.6000
     */
    static GetTimeFormatEx(lpLocaleName, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetTimeFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a date as a date string for a locale specified by name.
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * The earliest date supported by this function is January 1, 1601.
     * 
     * The day name, abbreviated day name, month name, and abbreviated month name are all localized based on the locale identifier.
     * 
     * The date values in the structure indicated by <i>lpDate</i> must be valid. The function checks each of the date values: year, month, day, and day of week. If the day of the week is incorrect, the function uses the correct value, and returns no error. If any of the other date values are outside the correct range, the function fails, and sets the last error to ERROR_INVALID_PARAMETER.
     * 
     * The function ignores the time members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure indicated by <i>lpDate</i>. These include <b>wHour</b>, <b>wMinute</b>, <b>wSecond</b>, and <b>wMilliseconds</b>.
     * 
     * If the <i>lpFormat</i> parameter contains a bad format string, the function returns no errors, but just forms the best possible date string. For example, the only year pictures that are valid are L"yyyy" and L"yy", where the "L" indicates a Unicode (16-bit characters) string. If L"y" is passed in, the function assumes L"yy". If L"yyy" is passed in, the function assumes L"yyyy". If more than four date (L"dddd") or four month (L"MMMM") pictures are passed in, the function defaults to L"dddd" or L"MMMM".
     * 
     * The application should enclose any text that should remain in its exact form in the date string within single quotation marks in the date format picture. The single quotation mark can also be used as an escape character to allow the single quotation mark itself to be displayed in the date string. However, the escape sequence must be enclosed within two single quotation marks. For example, to display the date as "May '93", the format string is: L"MMMM ''''yy". The first and last single quotation marks are the enclosing quotation marks. The second and third single quotation marks are the escape sequence to allow the single quotation mark to be displayed before the century.
     * 
     * When the date picture contains both a numeric form of the day (either d or dd) and the full month name (MMMM), the genitive form of the month name is retrieved in the date string.
     * 
     * To obtain the default short and long date format without performing any actual formatting, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> with the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sshortdate">LOCALE_SSHORTDATE</a> or <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-slongdate">LOCALE_SLONGDATE</a> constant. To get the date format for an alternate calendar, the application uses <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> with the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ioptionalcalendar">LOCALE_IOPTIONALCALENDAR</a> constant. To get the date format for a particular calendar, the application uses <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcalendarinfoex">GetCalendarInfoEx</a>, passing the appropriate <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar Identifier</a>. It can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a> to retrieve date formats for a particular calendar.
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * The DATE_LONGDATE format includes two kinds of date patterns: patterns that include the day of the week and patterns that do not include the day of the week. For example, "Tuesday, October 18, 2016" or "October 18, 2016".  If your application needs to ensure that dates use one of these kinds of patterns and not the other kind, your application should perform the following actions:<ol>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a> function to get all of the date formats for the DATE_LONGDATE format.</li>
     * <li>Look for the first date format passed to the callback function that you specified for  <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a> that matches your requested calendar identifier and has a date format string that matches the requirements of your application. For example, look for the first date format that includes "dddd" if your application requires that the date include the full name of the day of the week, or look for the first date format that includes neither "ddd" nor "dddd" if your application requires that the date includes nether the abbreviated name nor the full name of the day of the week.</li>
     * <li>Call the <b>GetDateFormatEx</b> function with the  <i>lpFormat</i> parameter set to the date format string that you identified as the appropriate format in the callback function.</li>
     * </ol>
     * 
     * 
     * If the presence or absence of the day of the week in the long date format does not matter to your application, your application can call <b>GetDateFormatEx</b> directly without first enumerating all of the long date formats by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * 
     * <b>Beginning in Windows 8: </b><b>GetDateFormatEx</b>  is declared in Datetimeapi.h. Before Windows 8, it was declared in Winnls.h.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {Pointer<PWSTR>} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * For example, to get the date string "Wed, Aug 31 94", the application uses the picture string "ddd',' MMM dd yy".
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {Pointer<PWSTR>} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @param {Pointer<PWSTR>} lpCalendar Reserved; must set to <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-getdateformatex
     * @since windows6.0.6000
     */
    static GetDateFormatEx(lpLocaleName, dwFlags, lpDate, lpFormat, lpDateStr, cchDate, lpCalendar) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetDateFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "ptr", lpCalendar)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a duration of time as a time string for a locale specified by name.
     * @remarks
     * This function can be used with multimedia applications that display file time and sporting event applications that display finish times.
     * 
     * The function ignores the first three members of the [SYSTEMTIME](https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-systemtime) structure: **wYear**, **wMonth**, and **wDayOfWeek**.
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * The following are characteristics of duration format strings:
     * 
     * <ul>
     * <li>
     * Formatting characters are lowercase.
     * 
     * <div class="alert"><b>Note</b>  An exception is made for (H) to be consistent with <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.</div>
     * <div> </div>
     * </li>
     * <li>Two-digit format strings for hours, minutes, and seconds prepend a leading zero if the value is less than 10.</li>
     * <li>The first output field is not subject to any bounds testing (hours&lt;24, minutes&lt;60, seconds&lt;60, milliseconds&lt;1000). Days are not subject to bounds testing.</li>
     * <li>The function assumes that all format strings are in decreasing field size, for example, hours, minutes, seconds, milliseconds.</li>
     * <li>The first field to be displayed is normalized, as defined by the format string. For example, if the application specifies 310 seconds and the format string is m:ss, the output is 5:10. However, if the format string specifies minutes and seconds but the application specifies hours, the minutes field is adjusted accordingly.</li>
     * <li>If fractions are not the first field, the number of "f" characters in the format string indicates the number of decimals to show (limit of 9). If fractions are the first field, the number of "f" characters indicates the number of significant digits below one second.</li>
     * <li>Round-off occurs by truncation, not by the rule of five rounds up and four rounds down.</li>
     * <li>Single quotes are used to escape characters.</li>
     * </ul>
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * 
     * <b>Examples</b>
     * 
     * Following are examples of duration formats and corresponding outputs for specified time durations.
     * 
     * <b>SYSTEMTIME = 14 days, 2 hours, 45 minutes, 12 seconds, and 247 milliseconds</b>
     * 
     * <table>
     * <tr>
     * <th>Format</th>
     * <th>Output</th>
     * </tr>
     * <tr>
     * <td>d:hh:mm:ss</td>
     * <td>14:02:45:12</td>
     * </tr>
     * <tr>
     * <td>hh:mm:ss:ff</td>
     * <td>338:45:12:24</td>
     * </tr>
     * <tr>
     * <td>hh:mm:ss:fff</td>
     * <td>338:45:12:247</td>
     * </tr>
     * <tr>
     * <td>h' h 'mm' m 'ss' s'</td>
     * <td>338 h 45 m 12 s</td>
     * </tr>
     * </table>
     *  
     * 
     * <b>SYSTEMTIME = 345 seconds</b>
     * 
     * <table>
     * <tr>
     * <th>Format</th>
     * <th>Output</th>
     * </tr>
     * <tr>
     * <td>hh:mm:ss</td>
     * <td>00:05:45</td>
     * </tr>
     * <tr>
     * <td>h:mm:ss</td>
     * <td>0:05:45</td>
     * </tr>
     * <tr>
     * <td>mm:ss</td>
     * <td>05:45</td>
     * </tr>
     * <tr>
     * <td>m:ss</td>
     * <td>5:45</td>
     * </tr>
     * <tr>
     * <td>mm' m 'ss' s'</td>
     * <td>05 m 45 s</td>
     * </tr>
     * <tr>
     * <td>ss</td>
     * <td>345</td>
     * </tr>
     * <tr>
     * <td>ss' seconds'</td>
     * <td>345 seconds</td>
     * </tr>
     * </table>
     *  
     * 
     * <b>uulDuration = 51234567 (5.1234567 seconds)</b>
     * 
     * <table>
     * <tr>
     * <th>Format</th>
     * <th>Output</th>
     * </tr>
     * <tr>
     * <td>s.fff</td>
     * <td>5.123</td>
     * </tr>
     * <tr>
     * <td>s.ffffff</td>
     * <td>5.123456</td>
     * </tr>
     * <tr>
     * <td>s.fffffffff</td>
     * <td>5.123456700 (add trailing zeros)</td>
     * </tr>
     * <tr>
     * <td>fff 'ms'</td>
     * <td>5123 ms</td>
     * </tr>
     * <tr>
     * <td>ffffff 'microseconds'</td>
     * <td>5123456 microseconds</td>
     * </tr>
     * <tr>
     * <td>fffffffff 'ns'</td>
     * <td>5123456700 ns</td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying function options. If <i>lpFormat</i> is not set to <b>NULL</b>, this parameter must be set to 0. If <i>lpFormat</i> is set to <b>NULL</b>, your application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default duration format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>  Use of <b>LOCALE_NOUSEROVERRIDE</b> is strongly discouraged as it disables user preferences.</div>
     * <div> </div>
     * @param {Pointer<SYSTEMTIME>} lpDuration Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time duration information to format. The application sets this parameter to <b>NULL</b> if the function is to ignore it and use <i>ullDuration</i>.
     * @param {Integer} ullDuration 64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both <i>lpDuration</i> and <i>ullDuration</i> are set, the <i>lpDuration</i> parameter takes precedence. If <i>lpDuration</i> is set to <b>NULL</b> and <i>ullDuration</i> is set to 0, the duration is 0.
     * @param {Pointer<PWSTR>} lpFormat Pointer to the format string with characters as shown below. The application can set this parameter to <b>NULL</b> if the function is to format the string according to the duration format for the specified locale. If <i>lpFormat</i> is not set to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="d"></a><a id="D"></a><dl>
     * <dt><b>d</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * days
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="h_or_H"></a><a id="h_or_h"></a><a id="H_OR_H"></a><dl>
     * <dt><b>h or H</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * hours
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="hh_or_HH"></a><a id="hh_or_hh"></a><a id="HH_OR_HH"></a><dl>
     * <dt><b>hh or HH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * hours; if less than ten,  prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="m"></a><a id="M"></a><dl>
     * <dt><b>m</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * minutes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="mm"></a><a id="MM"></a><dl>
     * <dt><b>mm</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * minutes; if less than ten, prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="s"></a><a id="S"></a><dl>
     * <dt><b>s</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * seconds
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ss"></a><a id="SS"></a><dl>
     * <dt><b>ss</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * seconds; if less than ten, prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="f"></a><a id="F"></a><dl>
     * <dt><b>f</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * fractions of a second
     * 
     * 
     * <div class="alert"><b>Note</b>  The character "f" can occur up to nine consecutive times (fffffffff), although support for frequency timers is limited to 100 nanoseconds. Thus, if nine characters are present, the last two digits are always 0.</div>
     * <div> </div>
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} lpDurationStr Pointer to the buffer in which the function retrieves the duration string.
     * 
     * Alternatively, this parameter retrieves <b>NULL</b> if <i>cchDuration</i> is set to 0. In this case, the function returns the required size for the duration string buffer.
     * @param {Integer} cchDuration Size, in characters, of the buffer indicated by <i>lpDurationStr</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpDurationStr</i> and returns the required size for the duration string buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getdurationformatex
     * @since windows6.0.6000
     */
    static GetDurationFormatEx(lpLocaleName, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetDurationFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpDuration, "uint", ullDuration, "ptr", lpFormat, "ptr", lpDurationStr, "int", cchDuration)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Compares two Unicode (wide character) strings, for a locale specified by name.Caution  Using CompareStringEx incorrectly can compromise the security of your application.
     * @remarks
     * Both <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> and <b>CompareStringEx</b> are optimized to run at the highest speed when <i>dwCmpFlags</i> is set to 0 or NORM_IGNORECASE, <i>cchCount1</i> and <i>cchCount2</i> are set to -1, and the locale does not support any linguistic compressions, as when traditional Spanish sorting treats "ch" as a single character.
     * 
     * Both <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> and <b>CompareStringEx</b> ignore Arabic kashidas during the comparison. Thus, if two strings are identical except for the presence of kashidas, the function returns CSTR_EQUAL.
     *       
     * 
     * When the application uses the NORM_IGNORENONSPACE and NORM_IGNORECASE flags with the sorting function, the flags can sometimes interfere with string comparisons. This situation might result for a locale that does not support non-spacing characters or case, but uses equivalent weight levels to handle other important operations. In such cases, your application should use the LINGUISTIC_IGNOREDIACRITIC and LINGUISTIC_IGNORECASE flags. These flags provide linguistically appropriate results for sorting code points that use case and diacritic marks, and have no impact on other code points.
     * 
     * <b>Beginning in Windows Vista: </b> Both <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> and <b>CompareStringEx</b> can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     *       
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * 
     * <b>Beginning in Windows 8: </b><b>CompareStringEx</b>  is declared in Stringapiset.h. Before Windows 8, it was declared in Winnls.h.
     * 
     * <div class="alert"><b>Note</b>  The behavior of sorting can change between Windows releases. For example, there may be new Unicode code points created. Use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNlsVersionEx</a> to discover if the sort version has changed.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags 
     * @param {Pointer<PWSTR>} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {Pointer<PWSTR>} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of &lt;0, ==0, and &gt;0 is consistent with the C runtime.
     * 
     * <ul>
     * <li>CSTR_LESS_THAN. The string indicated by <i>lpString1</i> is less in lexical value than the string indicated by <i>lpString2</i>.</li>
     * <li>CSTR_EQUAL. The string indicated by <i>lpString1</i> is equivalent in lexical value to the string indicated by <i>lpString2</i>. The two strings are equivalent for sorting purposes, although not necessarily identical.</li>
     * <li>CSTR_GREATER_THAN. The string indicated by <i>lpString1</i> is greater in lexical value than the string indicated by <i>lpString2</i>.</li>
     * </ul>
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were invalid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. </li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-comparestringex
     * @since windows6.0.6000
     */
    static CompareStringEx(lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        static lpVersionInformation := 0, lpReserved := 0, lParam := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CompareStringEx", "ptr", lpLocaleName, "uint", dwCmpFlags, "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two Unicode strings to test binary equivalence.
     * @remarks
     * This function tests for binary equality, not linguistic equality. For information about the use of the function for ordinal sorting, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * 
     * Applications that are concerned with linguistic equality should use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a>, <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-lstrcmpa">lstrcmp</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-lstrcmpia">lstrcmpi</a>. For more information about linguistic sorting, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>
     * 
     * 
     * <b>Starting with Windows 8: </b><b>CompareStringOrdinal</b>  is declared in Stringapiset.h. Before Windows 8, it was declared in Winnls.h.
     * @param {Pointer<PWSTR>} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {Pointer<PWSTR>} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {Integer} bIgnoreCase <b>TRUE</b> if the function is to perform a case-insensitive comparison, using the operating system uppercase table information. The application sets this parameter to <b>FALSE</b> if the function is to compare the strings exactly as they are passed in. Note that 1 is the only numeric value that can be used to specify a true value for this boolean parameter that does not result an invalid parameter error. Boolean values for this parameter work as expected.
     * @returns {Integer} Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of &lt;0, ==0, and &gt;0 is consistent with the C runtime.
     * 
     * <ul>
     * <li>CSTR_LESS_THAN. The value indicated by <i>lpString1</i> is less than the value indicated by <i>lpString2</i>.</li>
     * <li>CSTR_EQUAL. The value indicated by <i>lpString1</i> equals the value indicated by <i>lpString2</i>.</li>
     * <li>CSTR_GREATER_THAN. The value indicated by <i>lpString1</i> is greater than the value indicated by <i>lpString2</i>.</li>
     * </ul>
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-comparestringordinal
     * @since windows6.0.6000
     */
    static CompareStringOrdinal(lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\CompareStringOrdinal", "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "int", bIgnoreCase, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CompareStringW (Unicode) function (stringapiset.h) compares two character strings, for a locale specified by identifier.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * 
     * If your application is calling the ANSI version of <b>CompareString</b>, the function converts parameters via the default code page of the supplied locale. Thus, an application can never use <b>CompareString</b> to handle UTF-8 text.
     * 
     * Normally, for case-insensitive comparisons, <b>CompareString</b> maps the lowercase "i" to the uppercase "I", even when the locale is Turkish or Azerbaijani. The  NORM_LINGUISTIC_CASING flag overrides this behavior for Turkish or Azerbaijani. If this flag is specified in conjunction with Turkish or Azerbaijani, LATIN SMALL LETTER DOTLESS I (U+0131) is the lowercase form of LATIN CAPITAL LETTER I (U+0049) and LATIN SMALL LETTER I (U+0069) is the lowercase form of LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130).
     * 
     * <b>Starting with Windows 8: </b>The ANSI version of the function is declared in Winnls.h, and the Unicode version is declared in Stringapiset.h. Before Windows 8, both versions were declared in Winnls.h.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale used for the comparison. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags Flags that indicate how the function compares the two strings. For detailed definitions, see the <i>dwCmpFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @param {Pointer<PWSTR>} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {Pointer<PWSTR>} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns the values described for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-comparestringw
     * @since windows5.0
     */
    static CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        result := DllCall("KERNEL32.dll\CompareStringW", "uint", Locale, "uint", dwCmpFlags, "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "int")
        return result
    }

    /**
     * Maps one Unicode string to another, performing the specified transformation. (FoldStringW)
     * @remarks
     * The values of the <i>lpSrcStr</i> and  and <i>lpDestStr</i> parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER.
     * 
     * The compatibility zone in Unicode consists of characters in the range 0xF900 through 0xFFEF that are assigned to characters from other encoding standards for characters but are actually variants of characters already in Unicode. The compatibility zone is used to support round-trip mapping to these standards. Applications can use the MAP_FOLDCZONE flag to avoid supporting the duplication of characters in the compatibility zone.
     * 
     * <b>Starting with Windows Vista:</b> This function supports Unicode normalization. All Unicode compatibility characters are mapped.
     * 
     * <b>Starting with Windows Vista:</b> The transformations indicated by the MAP_FOLDCZONE, MAP_PRECOMPOSED, and MAP_COMPOSITE flags use Unicode normalization forms KC, C, and D (through the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a> function) to do the mappings.
     * 
     * <b>Starting with Windows 8: </b>The ANSI version of the function is declared in Winnls.h and the Unicode version is declared in Stringapiset.h. Before Windows 8, both versions were declared in Winnls.h.
     * @param {Integer} dwMapFlags 
     * @param {Pointer<PWSTR>} lpSrcStr Pointer to a source string that the function maps.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>, excluding the terminating null character. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, the function calculates the string length automatically, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * @param {Pointer<PWSTR>} lpDestStr Pointer to a buffer in which this function retrieves the mapped string.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string. If the MAP_FOLDDIGITS flag is specified, the return value is the maximum size required, even if the actual number of characters needed is smaller than the maximum size. If the maximum size is not passed, the function fails with ERROR_INSUFFICIENT_BUFFER.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-foldstringw
     * @since windows5.0
     */
    static FoldStringW(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        A_LastError := 0

        DllCall("KERNEL32.dll\FoldStringW", "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves character type information for the characters in the specified source string.
     * @remarks
     * For an overview of the use of the string functions, see <a href="https://docs.microsoft.com/windows/desktop/menurc/strings">Strings</a>.
     * 
     * Using the ANSI code page for the supplied locale, this function translates the source string from ANSI to Unicode. It then analyzes each Unicode character for character type information.
     * 
     * The ANSI version of this function converts the source string to Unicode and calls the 
     * corresponding <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a> function. Thus the words in the output buffer correspond not to the original ANSI string but to its Unicode equivalent. The conversion from ANSI to Unicode can result in a change in string length, for example, a pair of ANSI characters can map to a single 
     * Unicode character. Therefore, the correspondence between the words in the output buffer and the characters in the original ANSI string is not one-to-one in all cases, for example, multibyte strings. Thus, the ANSI version of this function is of limited use for multi-character strings. The Unicode version of the function is recommended instead.
     * 
     * This function circumvents a limitation caused by the difference in parameters between <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringtypea">GetStringTypeA</a> and <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a <b>GetStringType*</b> function through the use of the #define UNICODE switch. On the other hand, <b>GetStringTypeEx</b>, behaves properly with regard to that switch. Thus it is the recommended function.
     * 
     *     
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * The values of the <i>lpSrcStr</i> and <i>lpCharType</i> parameters must not be the same. If they are the same, the function fails with <b>ERROR_INVALID_PARAMETER</b>.
     * 
     * The <i>Locale</i> parameter is only used to perform string conversion to Unicode. It has nothing to do with the CTYPE* values supplied by the application. These values are solely determined by Unicode code points, and do not vary on a locale basis. For example, Greek letters are specified as C1_ALPHA for any value of <i>Locale</i>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. This value uniquely defines the ANSI code page. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.
     * @param {Pointer<PWSTR>} lpSrcStr Pointer to the string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. The size refers to bytes for the ANSI version of the function or wide characters for the Unicode version. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<UInt16>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li><b>ERROR_INVALID_FLAGS</b>. The values supplied for flags were not valid.</li>
     * <li><b>ERROR_INVALID_PARAMETER</b>. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw
     * @since windows5.0
     */
    static GetStringTypeExW(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeExW", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpCharType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves character type information for the characters in the specified Unicode source string.
     * @remarks
     * For an overview of the use of the string functions, see <a href="https://docs.microsoft.com/windows/desktop/menurc/strings">Strings</a>.
     * 
     * The values of the <i>lpSrcStr</i> and <i>lpCharType</i> parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER.
     * 
     * The <i>Locale</i> parameter used by the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringtypea">GetStringTypeA</a> function is not used by this function. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a <b>GetStringType*</b> function through the use of the #define UNICODE switch. An application can circumvent this limitation by using <a href="https://docs.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw">GetStringTypeEx</a>, which is the recommended function.
     * 
     * <b>Supported Character Types</b>
     * 
     * The character type bits are divided into several levels. The information for one level can be retrieved by a single call to this function. Each level is limited to 16 bits of information so that the other mapping functions, which are limited to 16 bits of representation per character, can also return character type information.
     * 
     * <u>Ctype 1</u>
     * 
     * These types support ANSI C and POSIX (LC_CTYPE) character typing functions. A bitwise-OR of these values is retrieved in the array in the output buffer when <i>dwInfoType</i> is set to CT_CTYPE1. For DBCS locales, the type attributes apply to both narrow characters and wide characters. The Japanese hiragana and katakana characters, and the kanji ideograph characters all have the C1_ALPHA attribute.
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Name</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>C1_UPPER </td>
     * <td>0x0001</td>
     * <td>Uppercase </td>
     * </tr>
     * <tr>
     * <td>C1_LOWER</td>
     * <td>0x0002</td>
     * <td>Lowercase </td>
     * </tr>
     * <tr>
     * <td>C1_DIGIT</td>
     * <td>0x0004</td>
     * <td>Decimal digits </td>
     * </tr>
     * <tr>
     * <td>C1_SPACE</td>
     * <td>0x0008</td>
     * <td>Space characters </td>
     * </tr>
     * <tr>
     * <td>C1_PUNCT</td>
     * <td>0x0010</td>
     * <td>Punctuation </td>
     * </tr>
     * <tr>
     * <td>C1_CNTRL</td>
     * <td>0x0020</td>
     * <td>Control characters </td>
     * </tr>
     * <tr>
     * <td>C1_BLANK</td>
     * <td>0x0040</td>
     * <td>Blank characters </td>
     * </tr>
     * <tr>
     * <td>C1_XDIGIT</td>
     * <td>0x0080</td>
     * <td>Hexadecimal digits </td>
     * </tr>
     * <tr>
     * <td>C1_ALPHA</td>
     * <td>0x0100</td>
     * <td>Any linguistic character: alphabetical, syllabary, or ideographic</td>
     * </tr>
     * <tr>
     * <td>C1_DEFINED</td>
     * <td>0x0200</td>
     * <td>A defined character, but not one of the other C1_* types</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * The following character types are either constant or computable from basic types and do not need to be supported by this function.
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Type</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>Alphanumeric</td>
     * <td>Alphabetical characters and digits (C1_ALPHA and C1_DIGIT)</td>
     * </tr>
     * <tr>
     * <td>Printable</td>
     * <td>Graphic characters and blanks (all C1_* types except C1_CNTRL)</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * <u>Ctype 2</u>
     * 
     * These types support proper layout of Unicode text. For DBCS locales, the character type applies to both narrow and wide characters. The direction attributes are assigned so that the bidirectional layout algorithm standardized by Unicode produces accurate results. These types are mutually exclusive. For more information about the use of these attributes, see <a href="https://www.unicode.org/standard/standard.html">The Unicode Standard</a>.
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Name</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>Strong</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C2_LEFTTORIGHT</td>
     * <td>0x0001</td>
     * <td>Left to right </td>
     * </tr>
     * <tr>
     * <td>C2_RIGHTTOLEFT</td>
     * <td>0x0002</td>
     * <td>Right to left </td>
     * </tr>
     * <tr>
     * <td>Weak</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C2_EUROPENUMBER</td>
     * <td>0x0003</td>
     * <td>European number, European digit</td>
     * </tr>
     * <tr>
     * <td>C2_EUROPESEPARATOR</td>
     * <td>0x0004</td>
     * <td>European numeric separator </td>
     * </tr>
     * <tr>
     * <td>C2_EUROPETERMINATOR</td>
     * <td>0x0005</td>
     * <td>European numeric terminator</td>
     * </tr>
     * <tr>
     * <td>C2_ARABICNUMBER</td>
     * <td>0x0006</td>
     * <td>Arabic number </td>
     * </tr>
     * <tr>
     * <td>C2_COMMONSEPARATOR</td>
     * <td>0x0007</td>
     * <td>Common numeric separator </td>
     * </tr>
     * <tr>
     * <td>Neutral</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C2_BLOCKSEPARATOR</td>
     * <td>0x0008</td>
     * <td>Block separator </td>
     * </tr>
     * <tr>
     * <td>C2_SEGMENTSEPARATOR</td>
     * <td>0x0009</td>
     * <td>Segment separator </td>
     * </tr>
     * <tr>
     * <td>C2_WHITESPACE</td>
     * <td>0x000A</td>
     * <td>White space </td>
     * </tr>
     * <tr>
     * <td>C2_OTHERNEUTRAL</td>
     * <td>0x000B</td>
     * <td>Other neutrals </td>
     * </tr>
     * <tr>
     * <td>Not applicable</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C2_NOTAPPLICABLE</td>
     * <td>0x0000</td>
     * <td>No implicit directionality (for example, control codes)</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * <u>Ctype 3</u>
     * 
     * These types are intended to be placeholders for extensions to the POSIX types required for general text processing or for the standard C library functions. A bitwise-OR of these values is retrieved when <i>dwInfoType</i> is set to CT_CTYPE3. For DBCS locales, the Ctype 3 attributes apply to both narrow characters and wide characters. The Japanese hiragana and katakana characters, and the kanji ideograph characters all have the C3_ALPHA attribute.
     * 
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Name</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>C3_NONSPACING</td>
     * <td>0x0001</td>
     * <td>Nonspacing mark </td>
     * </tr>
     * <tr>
     * <td>C3_DIACRITIC</td>
     * <td>0x0002</td>
     * <td>Diacritic nonspacing mark </td>
     * </tr>
     * <tr>
     * <td>C3_VOWELMARK</td>
     * <td>0x0004</td>
     * <td>Vowel nonspacing mark </td>
     * </tr>
     * <tr>
     * <td>C3_SYMBOL</td>
     * <td>0x0008</td>
     * <td>Symbol </td>
     * </tr>
     * <tr>
     * <td>C3_KATAKANA</td>
     * <td>0x0010</td>
     * <td>Katakana character</td>
     * </tr>
     * <tr>
     * <td>C3_HIRAGANA</td>
     * <td>0x0020</td>
     * <td>Hiragana character </td>
     * </tr>
     * <tr>
     * <td>C3_HALFWIDTH</td>
     * <td>0x0040</td>
     * <td>Half-width (narrow) character </td>
     * </tr>
     * <tr>
     * <td>C3_FULLWIDTH</td>
     * <td>0x0080</td>
     * <td>Full-width (wide) character </td>
     * </tr>
     * <tr>
     * <td>C3_IDEOGRAPH</td>
     * <td>0x0100</td>
     * <td>Ideographic character </td>
     * </tr>
     * <tr>
     * <td>C3_KASHIDA</td>
     * <td>0x0200</td>
     * <td>Arabic kashida character </td>
     * </tr>
     * <tr>
     * <td>C3_LEXICAL</td>
     * <td>0x0400</td>
     * <td>Punctuation which is counted as part of the word (kashida, hyphen, feminine/masculine ordinal indicators, equal sign, and so forth) </td>
     * </tr>
     * <tr>
     * <td>C3_ALPHA</td>
     * <td>0x8000</td>
     * <td>All linguistic characters (alphabetical, syllabary, and ideographic)</td>
     * </tr>
     * <tr>
     * <td>C3_HIGHSURROGATE</td>
     * <td>0x0800</td>
     * <td><b>Windows Vista:</b> High surrogate code unit</td>
     * </tr>
     * <tr>
     * <td>C3_LOWSURROGATE</td>
     * <td>0x1000</td>
     * <td><b>Windows Vista:</b> Low surrogate code unit</td>
     * </tr>
     * <tr>
     * <td>Not applicable</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C3_NOTAPPLICABLE</td>
     * <td>0x0000</td>
     * <td>Not applicable</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * C3_HIGHSURROGATE and C3_LOWSURROGATE are listed only for completeness, and should never be provided to this function. They are relevant only for Unicode.
     * 
     * <b>Starting with Windows 8: </b><b>GetStringTypeW</b>  is declared in Stringapiset.h. Before Windows 8, it was declared in Winnls.h.
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. This parameter can have the following values. The character types are divided into different levels as described in the Remarks section.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE1"></a><a id="ct_ctype1"></a><dl>
     * <dt><b>CT_CTYPE1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve character type information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE2"></a><a id="ct_ctype2"></a><dl>
     * <dt><b>CT_CTYPE2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve bidirectional layout information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE3"></a><a id="ct_ctype3"></a><dl>
     * <dt><b>CT_CTYPE3</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve text processing information.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} lpSrcStr Pointer to the Unicode string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<UInt16>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-getstringtypew
     * @since windows5.0
     */
    static GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeW", "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpCharType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Maps a character string to a UTF-16 (wide character) string.
     * @remarks
     * The default behavior of this function is to translate to a precomposed form of the input character string. If a precomposed form does not exist, the function attempts to translate to a composite form.
     * 
     * The use of the MB_PRECOMPOSED flag has very little effect on most code pages because most input data is composed already. Consider calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a> after converting with <b>MultiByteToWideChar</b>. <b>NormalizeString</b> provides more accurate, standard, and consistent data, and can also be faster. Note that for the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> enumeration being passed to <b>NormalizeString</b>, NormalizationC corresponds to MB_PRECOMPOSED and NormalizationD corresponds to MB_COMPOSITE.
     * 
     * As mentioned in the caution above, the output buffer can easily be overrun if this function is not first called with <i>cchWideChar</i> set to 0 in order to obtain the required size. If the MB_COMPOSITE flag is used, the output can be three or more characters long for each input character.
     * 
     * The <i>lpMultiByteStr</i> and <i>lpWideCharStr</i> pointers must not be the same. If they are the same, the function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the value ERROR_INVALID_PARAMETER.
     * 
     * <b>MultiByteToWideChar</b> does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should pass in -1 or explicitly count the terminating null character for the input string.
     * 
     * The function fails if MB_ERR_INVALID_CHARS is set and an invalid character is encountered in the source string. An invalid character is one of the following:
     * 
     * <ul>
     * <li>A character that is not the default character in the source string, but translates to the default character when MB_ERR_INVALID_CHARS is not set</li>
     * <li>For DBCS strings, a character that has a lead byte but no valid trail byte</li>
     * </ul>
     * Starting with Windows Vista, this function fully conforms with the Unicode 4.1 specification for UTF-8 and UTF-16. The function used on earlier operating systems encodes or decodes lone <a href="https://docs.microsoft.com/windows/desktop/Intl/surrogates-and-supplementary-characters">surrogate</a> halves or mismatched surrogate pairs. Code written in earlier versions of Windows that rely on this behavior to encode random non-text binary data might run into problems. However, code that uses this function on valid UTF-8 strings will behave the same way as on earlier Windows operating systems.
     * 
     * <b>Windows XP:</b> To prevent the security problem of the non-shortest-form versions of UTF-8 characters, <b>MultiByteToWideChar</b> deletes these characters.
     * 
     * <b>Starting with Windows 8: </b><b>MultiByteToWideChar</b>  is declared in Stringapiset.h. Before Windows 8, it was declared in Winnls.h.
     * @param {Integer} CodePage Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system default Windows ANSI code page. 
     * 
     * <div class="alert"><b>Note</b>  This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system Macintosh code page. 
     * 
     * <div class="alert"><b>Note</b>  This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>   This value is used primarily in legacy code and should not generally be needed since modern Macintosh computers use Unicode for encoding.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system OEM code page. 
     * 
     * <div class="alert"><b>Note</b>  This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_SYMBOL"></a><a id="cp_symbol"></a><dl>
     * <dt><b>CP_SYMBOL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Symbol code page (42).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows ANSI code page for the current thread. 
     * 
     * <div class="alert"><b>Note</b>  This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF7"></a><a id="cp_utf7"></a><dl>
     * <dt><b>CP_UTF7</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-7. Use this value only when forced by a 7-bit transport mechanism. Use of UTF-8 is preferred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF8"></a><a id="cp_utf8"></a><dl>
     * <dt><b>CP_UTF8</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-8.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @param {Pointer<PSTR>} lpMultiByteStr Pointer to the character string to convert.
     * @param {Integer} cbMultiByte Size, in bytes, of the string indicated by the <i>lpMultiByteStr</i> parameter. Alternatively, this parameter can be set to -1 if the string is null-terminated. Note that, if <i>cbMultiByte</i> is 0, the function fails.
     * 
     * If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting Unicode string has a terminating null character, and the length returned by the function includes this character.
     * 
     * If this parameter is set to a positive integer, the function processes exactly the specified number of bytes. If the provided size does not include a terminating null character, the resulting Unicode string is not null-terminated, and the returned length does not include this character.
     * @param {Pointer<PWSTR>} lpWideCharStr Pointer to a buffer that receives the converted string.
     * @param {Integer} cchWideChar Size, in characters, of the buffer indicated by <i>lpWideCharStr</i>. If this value is 0, the function returns the required buffer size, in characters, including any terminating null character, and makes no use of the <i>lpWideCharStr</i> buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar
     * @since windows5.0
     */
    static MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar) {
        A_LastError := 0

        DllCall("KERNEL32.dll\MultiByteToWideChar", "uint", CodePage, "uint", dwFlags, "ptr", lpMultiByteStr, "int", cbMultiByte, "ptr", lpWideCharStr, "int", cchWideChar)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Maps a UTF-16 (wide character) string to a new character string.
     * @remarks
     * The <i>lpMultiByteStr</i> and <i>lpWideCharStr</i> pointers must not be the same. If they are the same, the function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_PARAMETER.
     * 
     * <b>WideCharToMultiByte</b> does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should pass in -1 or explicitly count the terminating null character for the input string.
     * 
     * If <i>cbMultiByte</i> is less than <i>cchWideChar</i>, this function writes the number of characters specified by <i>cbMultiByte</i> to the buffer indicated by <i>lpMultiByteStr</i>. However, if <i>CodePage</i> is set to CP_SYMBOL and <i>cbMultiByte</i> is less than <i>cchWideChar,</i> the function writes no characters to <i>lpMultiByteStr</i>.
     * 
     * The <b>WideCharToMultiByte</b> function operates most efficiently when both <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> are set to <b>NULL</b>. The following table shows the behavior of the function for the four possible combinations of these parameters.
     * 
     * <table>
     * <tr>
     * <th><i>lpDefaultChar</i></th>
     * <th><i>lpUsedDefaultChar</i></th>
     * <th>Result</th>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td><b>NULL</b></td>
     * <td>No default checking. These parameter settings are the most efficient ones for use with this function.</td>
     * </tr>
     * <tr>
     * <td>Non-null character</td>
     * <td><b>NULL</b></td>
     * <td>Uses the specified default character, but does not set <i>lpUsedDefaultChar</i>.</td>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td>Non-null character</td>
     * <td>Uses the system default character and sets <i>lpUsedDefaultChar</i> if necessary.</td>
     * </tr>
     * <tr>
     * <td>Non-null character</td>
     * <td>Non-null character</td>
     * <td>Uses the specified default character and sets <i>lpUsedDefaultChar</i> if necessary.</td>
     * </tr>
     * </table>
     *  
     * 
     * Starting with Windows Vista, this function fully conforms with the Unicode 4.1 specification for UTF-8 and UTF-16. The function used on earlier operating systems encodes or decodes lone <a href="https://docs.microsoft.com/windows/desktop/Intl/surrogates-and-supplementary-characters">surrogate</a> halves or mismatched surrogate pairs. Code written in earlier versions of Windows that rely on this behavior to encode random non-text binary data might run into problems. However, code that uses this function to produce valid UTF-8 strings will behave the same way as on earlier Windows operating systems.
     * 
     * <b>Starting with Windows 8: </b><b>WideCharToMultiByte</b>  is declared in Stringapiset.h. Before Windows 8, it was declared in Winnls.h.
     * 
     * <h3><a id="wc_compositecheck_and_related_flags"></a><a id="WC_COMPOSITECHECK_AND_RELATED_FLAGS"></a>WC_COMPOSITECHECK and related flags</h3>
     * As discussed in <a href="https://docs.microsoft.com/windows/desktop/Intl/using-unicode-normalization-to-represent-strings">Using Unicode Normalization to Represent Strings</a>, Unicode allows multiple representations of the same string (interpreted linguistically). For example, Capital A with dieresis (umlaut) can be represented either precomposed as a single Unicode code point "Ä" (U+00C4) or decomposed as the combination of Capital A and the combining dieresis character ("A" + "¨", that is U+0041 U+0308). However, most code pages provide only composed characters.
     * 
     * The WC_COMPOSITECHECK flag causes the <b>WideCharToMultiByte</b> function to test for decomposed Unicode characters and attempts to compose them before converting them to the requested code page. This flag is only available for conversion to <a href="https://docs.microsoft.com/windows/desktop/Intl/single-byte-character-sets">single byte (SBCS)</a> or <a href="https://docs.microsoft.com/windows/desktop/Intl/double-byte-character-sets">double byte (DBCS)</a> code pages (code pages &lt; 50000, excluding code page 42). If your application needs to convert decomposed Unicode data to single byte or double byte code pages, this flag might be useful. However, not all characters can be converted this way and it is more reliable to save and store such data as Unicode.
     * 
     * When an application is using WC_COMPOSITECHECK, some character combinations might remain incomplete or might have additional nonspacing characters left over. For example, A + ¨ + ¨ combines to Ä + ¨. Using the WC_DISCARDNS flag causes the function to discard additional nonspacing characters. Using the WC_DEFAULTCHAR flag causes the function to use the default replacement character (typically "?") instead. Using the WC_SEPCHARS flag causes the function to attempt to convert each additional nonspacing character to the target code page. Usually this flag also causes the use of the replacement character ("?"). However, for code page 1258 (Vietnamese) and 20269, nonspacing characters exist and can be used. The conversions for these code pages are not perfect. Some combinations do not convert correctly to code page 1258, and WC_COMPOSITECHECK corrupts data in code page 20269. As mentioned earlier, it is more reliable to design your application to save and store such data as Unicode.
     * @param {Integer} CodePage Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system default Windows ANSI code page. 
     * 
     * <div class="alert"><b>Note</b>  This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system Macintosh code page. 
     * 
     * <div class="alert"><b>Note</b>  This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>   This value is used primarily in legacy code and should not generally be needed since modern Macintosh computers use Unicode for encoding.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system OEM code page. 
     * 
     * <div class="alert"><b>Note</b>  This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_SYMBOL"></a><a id="cp_symbol"></a><dl>
     * <dt><b>CP_SYMBOL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows 2000:</b> Symbol code page (42).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows 2000:</b> The Windows ANSI code page for the current thread. 
     * 
     * <div class="alert"><b>Note</b>  This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF7"></a><a id="cp_utf7"></a><dl>
     * <dt><b>CP_UTF7</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-7. Use this value only when forced by a 7-bit transport mechanism. Use of UTF-8 is preferred. With this value set, <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> must be set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF8"></a><a id="cp_utf8"></a><dl>
     * <dt><b>CP_UTF8</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-8. With this value set, <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> must be set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @param {Pointer<PWSTR>} lpWideCharStr Pointer to the Unicode string to convert.
     * @param {Integer} cchWideChar Size, in characters, of the string indicated by <i>lpWideCharStr</i>. Alternatively, this parameter can be set to -1 if the string is null-terminated. If <i>cchWideChar</i> is set to 0, the function fails.
     * 
     * If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting character string has a terminating null character, and the length returned by the function includes this character.
     * 
     * If this parameter is set to a positive integer, the function processes exactly the specified number of characters. If the provided size does not include a terminating null character, the resulting character string is not null-terminated, and the returned length does not include this character.
     * @param {Pointer<PSTR>} lpMultiByteStr Pointer to a buffer that receives the converted string.
     * @param {Integer} cbMultiByte Size, in bytes, of the buffer indicated by <i>lpMultiByteStr</i>. If this value is 0, the function returns the required buffer size, in bytes, including any terminating null character, and makes no use of the <i>lpMultiByteStr</i> buffer.
     * @param {Pointer<PSTR>} lpDefaultChar Pointer to the character to use if a character cannot be represented in the specified code page. The application sets this parameter to <b>NULL</b> if the function is to use a system default value. To obtain the system default character, the application can call the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfo">GetCPInfo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a> function.
     * 
     * For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.
     * @param {Pointer<Int32>} lpUsedDefaultChar Pointer to a flag that indicates if the function has used a default character in the conversion. The flag is set to <b>TRUE</b> if one or more characters in the source string cannot be represented in the specified code page. Otherwise, the flag is set to <b>FALSE</b>. This parameter can be set to <b>NULL</b>.
     * 
     * For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte
     * @since windows5.0
     */
    static WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar) {
        A_LastError := 0

        DllCall("KERNEL32.dll\WideCharToMultiByte", "uint", CodePage, "uint", dwFlags, "ptr", lpWideCharStr, "int", cchWideChar, "ptr", lpMultiByteStr, "int", cbMultiByte, "ptr", lpDefaultChar, "ptr", lpUsedDefaultChar)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Determines if a specified code page is valid.
     * @remarks
     * A code page is considered valid only if it is installed on the operating system. Unicode is preferred.
     * 
     * Starting with Windows Vista, all code pages that can be installed are loaded by default.
     * @param {Integer} CodePage <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code page identifier</a> for the code page to check.
     * @returns {Integer} Returns a nonzero value if the code page is valid, or 0 if the code page is invalid.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidcodepage
     * @since windows5.0
     */
    static IsValidCodePage(CodePage) {
        result := DllCall("KERNEL32.dll\IsValidCodePage", "uint", CodePage, "int")
        return result
    }

    /**
     * Retrieves the current Windows ANSI code page identifier for the operating system.Caution  The ANSI API functions, for example, the ANSI version of TextOut, implicitly use GetACP to translate text to or from Unicode.
     * @remarks
     * The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, applications should use UTF-8 or UTF-16 when possible.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getacp
     * @since windows5.0
     */
    static GetACP() {
        DllCall("KERNEL32.dll\GetACP")
    }

    /**
     * Returns the current original equipment manufacturer (OEM) code page identifier for the operating system.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of OEM and other code pages.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getoemcp
     * @since windows5.0
     */
    static GetOEMCP() {
        DllCall("KERNEL32.dll\GetOEMCP")
    }

    /**
     * Retrieves information about any valid installed or available code page. (GetCPInfo)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a>.
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. For details, see the <i>CodePage</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a>.
     * @param {Pointer<CPINFO>} lpCPInfo Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfo">CPINFO</a> structure that receives information about the code page. See the Remarks section.
     * @returns {Integer} Returns 1 if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 				
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcpinfo
     * @since windows5.0
     */
    static GetCPInfo(CodePage, lpCPInfo) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfo", "uint", CodePage, "ptr", lpCPInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about any valid installed or available code page. (GetCPInfoExA)
     * @remarks
     * The information retrieved in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure is not always useful for all code pages. To determine buffer sizes, for example, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> or <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-widechartomultibyte">WideCharToMultiByte</a> to request an accurate buffer size. If <b>CPINFOEX</b> settings indicate that a lead byte exists, the conversion function does not necessarily handle lead bytes differently, for example, in the case of a missing or illegal trail byte.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCPInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. The application can specify the code page identifier for any installed or available code page, or one of the following predefined values. See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for ANSI and other code pages.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the current thread's ANSI code page.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer<CPINFOEXA>} lpCPInfoEx Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure that receives information about the code page.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcpinfoexa
     * @since windows5.0
     */
    static GetCPInfoExA(CodePage, dwFlags, lpCPInfoEx) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfoExA", "uint", CodePage, "uint", dwFlags, "ptr", lpCPInfoEx, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about any valid installed or available code page. (GetCPInfoExW)
     * @remarks
     * The information retrieved in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure is not always useful for all code pages. To determine buffer sizes, for example, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> or <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-widechartomultibyte">WideCharToMultiByte</a> to request an accurate buffer size. If <b>CPINFOEX</b> settings indicate that a lead byte exists, the conversion function does not necessarily handle lead bytes differently, for example, in the case of a missing or illegal trail byte.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCPInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. The application can specify the code page identifier for any installed or available code page, or one of the following predefined values. See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for ANSI and other code pages.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the current thread's ANSI code page.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer<CPINFOEXW>} lpCPInfoEx Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure that receives information about the code page.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcpinfoexw
     * @since windows5.0
     */
    static GetCPInfoExW(CodePage, dwFlags, lpCPInfoEx) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfoExW", "uint", CodePage, "uint", dwFlags, "ptr", lpCPInfoEx, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two character strings, for a locale specified by identifier.Caution  Using CompareString incorrectly can compromise the security of your application. (CompareStringA)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * 
     * If your application is calling the ANSI version of <b>CompareString</b>, the function converts parameters via the default code page of the supplied locale. Thus, an application can never use <b>CompareString</b> to handle UTF-8 text.
     * 
     * Normally, for case-insensitive comparisons, <b>CompareString</b> maps the lowercase "i" to the uppercase "I", even when the locale is Turkish or Azerbaijani. The  NORM_LINGUISTIC_CASING flag overrides this behavior for Turkish or Azerbaijani. If this flag is specified in conjunction with Turkish or Azerbaijani, LATIN SMALL LETTER DOTLESS I (U+0131) is the lowercase form of LATIN CAPITAL LETTER I (U+0049) and LATIN SMALL LETTER I (U+0069) is the lowercase form of LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130).
     * 
     * <b>Starting with Windows 8: </b>The ANSI version of the function is declared in Winnls.h, and the Unicode version is declared in Stringapiset.h. Before Windows 8, both versions were declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines CompareString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale used for the comparison. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags Flags that indicate how the function compares the two strings. For detailed definitions, see the <i>dwCmpFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @param {Pointer<SByte>} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {Pointer<SByte>} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns the values described for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-comparestringa
     * @since windows5.0
     */
    static CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        result := DllCall("KERNEL32.dll\CompareStringA", "uint", Locale, "uint", dwCmpFlags, "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "int")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by identifier.Caution  Because strings with very different binary representations can compare as identical, this function can raise certain security concerns. For more information, see the discussion of comparison functions in Security Considerations:\_International Features. Note  For interoperability reasons, the application should prefer the FindNLSStringEx function because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Although FindNLSString supports custom locales, most applications should use FindNLSStringEx for this type of support.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFindNLSStringFlags Flags specifying details of the find operation. For detailed definitions, see the <i>dwFindNLSStringFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.
     * @param {Pointer<PWSTR>} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<PWSTR>} lpStringValue Pointer to the search string, for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<Int32>} pcchFound Pointer to a buffer containing the length of the string that the function finds. For details, see the <i>pcchFound</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-findnlsstring
     * @since windows6.0.6000
     */
    static FindNLSString(Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound) {
        A_LastError := 0

        DllCall("KERNEL32.dll\FindNLSString", "uint", Locale, "uint", dwFindNLSStringFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, "ptr", pcchFound)
        if(A_LastError)
            throw OSError()

    }

    /**
     * For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string. (Unicode)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * 
     * The ANSI version of <b>LCMapString</b> maps strings to and from Unicode based on the default Windows (ANSI) code page associated with the specified locale. When the ANSI version of this function is used with a Unicode-only locale, the function can succeed because the operating system uses the CP_ACP value, representing the system default Windows ANSI code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines LCMapString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flags specifying the type of transformation to use during string mapping or the type of sort key to generate. For detailed definitions, see the <i>dwMapFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * @param {Pointer<PWSTR>} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapString</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {Pointer<PWSTR>} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-lcmapstringw
     * @since windows5.0
     */
    static LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        A_LastError := 0

        DllCall("KERNEL32.dll\LCMapStringW", "uint", Locale, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest)
        if(A_LastError)
            throw OSError()

    }

    /**
     * For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string. (ANSI)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * 
     * The ANSI version of <b>LCMapString</b> maps strings to and from Unicode based on the default Windows (ANSI) code page associated with the specified locale. When the ANSI version of this function is used with a Unicode-only locale, the function can succeed because the operating system uses the CP_ACP value, representing the system default Windows ANSI code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines LCMapString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flags specifying the type of transformation to use during string mapping or the type of sort key to generate. For detailed definitions, see the <i>dwMapFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * @param {Pointer<PSTR>} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapString</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {Pointer<PSTR>} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-lcmapstringa
     * @since windows5.0
     */
    static LCMapStringA(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        A_LastError := 0

        DllCall("KERNEL32.dll\LCMapStringA", "uint", Locale, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information about a locale specified by identifier. (Unicode)
     * @remarks
     * For the operation of this function, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b>   Even when the <i>LCType</i> parameter is specified as LOCALE_FONTSIGNATURE, <i>cchData</i> and the function return are still TCHAR counts. The count is different for the ANSI and Unicode versions of the function. When an application calls the generic version of <b>GetLocaleInfo</b> with LOCALE_FONTSIGNATURE, <i>cchData</i> can be safely specified as sizeof(LOCALESIGNATURE) / sizeof(TCHAR).</div>
     * <div> </div>
     * The following examples deal correctly with the buffer size for non-text values:
     * 
     * 
     * ```cpp
     * int   ret;
     * CALID calid;
     * DWORD value;
     * 
     * ret = GetLocaleInfo(LOCALE_USER_DEFAULT,
     *                     LOCALE_ICALENDARTYPE | LOCALE_RETURN_NUMBER,
     *                     (LPTSTR)&value,
     *                     sizeof(value) / sizeof(TCHAR) );
     * calid = value;
     * 
     * LOCALESIGNATURE LocSig;
     * 
     * ret = GetLocaleInfo(LOCALE_USER_DEFAULT,
     *                     LOCALE_FONTSIGNATURE,
     *                     (LPWSTR)&LocSig,
     *                     sizeof(LocSig) / sizeof(TCHAR) );
     * 
     * ```
     * 
     * 
     * The ANSI string retrieved by the ANSI version of this function is translated from Unicode to ANSI based on the default ANSI code page for the locale identifier. However, if <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> is specified, the translation is based on the system default ANSI code page.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetLocaleInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> for which to retrieve information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For detailed definitions, see the <i>LCType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b>  For <b>GetLocaleInfo</b>, the value LOCALE_USE_CP_ACP is relevant only for the ANSI version.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0. For more information, see the Remarks section.
     * @param {Integer} cchData Size, in TCHAR values, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getlocaleinfow
     * @since windows5.0
     */
    static GetLocaleInfoW(Locale, LCType, lpLCData, cchData) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetLocaleInfoW", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int", cchData)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information about a locale specified by identifier. (ANSI)
     * @remarks
     * For the operation of this function, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b>   Even when the <i>LCType</i> parameter is specified as LOCALE_FONTSIGNATURE, <i>cchData</i> and the function return are still TCHAR counts. The count is different for the ANSI and Unicode versions of the function. When an application calls the generic version of <b>GetLocaleInfo</b> with LOCALE_FONTSIGNATURE, <i>cchData</i> can be safely specified as sizeof(LOCALESIGNATURE) / sizeof(TCHAR).</div>
     * <div> </div>
     * The following examples deal correctly with the buffer size for non-text values:
     * 
     * 
     * ```cpp
     * int   ret;
     * CALID calid;
     * DWORD value;
     * 
     * ret = GetLocaleInfo(LOCALE_USER_DEFAULT,
     *                     LOCALE_ICALENDARTYPE | LOCALE_RETURN_NUMBER,
     *                     (LPTSTR)&value,
     *                     sizeof(value) / sizeof(TCHAR) );
     * calid = value;
     * 
     * LOCALESIGNATURE LocSig;
     * 
     * ret = GetLocaleInfo(LOCALE_USER_DEFAULT,
     *                     LOCALE_FONTSIGNATURE,
     *                     (LPWSTR)&LocSig,
     *                     sizeof(LocSig) / sizeof(TCHAR) );
     * 
     * ```
     * 
     * 
     * The ANSI string retrieved by the ANSI version of this function is translated from Unicode to ANSI based on the default ANSI code page for the locale identifier. However, if <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> is specified, the translation is based on the system default ANSI code page.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetLocaleInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> for which to retrieve information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For detailed definitions, see the <i>LCType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b>  For <b>GetLocaleInfo</b>, the value LOCALE_USE_CP_ACP is relevant only for the ANSI version.</div>
     * <div> </div>
     * @param {Pointer<PSTR>} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0. For more information, see the Remarks section.
     * @param {Integer} cchData Size, in TCHAR values, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getlocaleinfoa
     * @since windows5.0
     */
    static GetLocaleInfoA(Locale, LCType, lpLCData, cchData) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetLocaleInfoA", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int", cchData)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Sets an item of information in the user override portion of the current locale. This function does not set the system defaults. (ANSI)
     * @remarks
     * This function writes to the registry, where it sets values that are associated with a particular user instead of a particular application. These registry values affect the behavior of other applications run by the user. As a rule, an application should call this function only when the user has explicitly requested the changes. The registry settings should not be changed for the convenience of a single application.
     * 
     * For the <i>LCType</i> parameter, the application should set <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> to use the operating system ANSI code page instead of the locale code page for string translation.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * As of Windows Vista, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sdate">LOCALE_SDATE</a> and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIME</a> constants are obsolete. Do not use these constants. Use <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sshortdate">LOCALE_SSHORTDATE</a> and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIMEFORMAT</a> instead. A custom locale might not have a single, uniform separator character within the date or time format: for example, a format such as "12/31, 2006" or "03:56'23" might be valid.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines SetLocaleInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale For the ANSI version of the function, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale with the code page used when interpreting the <i>lpLCData</i> information. For the Unicode version, this parameter is ignored.
     * 
     * You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} LCType Type of locale information to set. For valid constants see "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. The application can specify only one value per call, but it can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> with any other constant.
     * @param {Pointer<PSTR>} lpLCData Pointer to a null-terminated string containing the locale information to set. The information must be in the format specific to the specified constant. The application uses a Unicode string for the Unicode version of the function, and an ANSI string for the ANSI version.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INVALID_ACCESS. The access code was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setlocaleinfoa
     * @since windows5.0
     */
    static SetLocaleInfoA(Locale, LCType, lpLCData) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetLocaleInfoA", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets an item of information in the user override portion of the current locale. This function does not set the system defaults. (Unicode)
     * @remarks
     * This function writes to the registry, where it sets values that are associated with a particular user instead of a particular application. These registry values affect the behavior of other applications run by the user. As a rule, an application should call this function only when the user has explicitly requested the changes. The registry settings should not be changed for the convenience of a single application.
     * 
     * For the <i>LCType</i> parameter, the application should set <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> to use the operating system ANSI code page instead of the locale code page for string translation.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * As of Windows Vista, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sdate">LOCALE_SDATE</a> and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIME</a> constants are obsolete. Do not use these constants. Use <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sshortdate">LOCALE_SSHORTDATE</a> and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIMEFORMAT</a> instead. A custom locale might not have a single, uniform separator character within the date or time format: for example, a format such as "12/31, 2006" or "03:56'23" might be valid.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines SetLocaleInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale For the ANSI version of the function, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale with the code page used when interpreting the <i>lpLCData</i> information. For the Unicode version, this parameter is ignored.
     * 
     * You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} LCType Type of locale information to set. For valid constants see "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. The application can specify only one value per call, but it can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> with any other constant.
     * @param {Pointer<PWSTR>} lpLCData Pointer to a null-terminated string containing the locale information to set. The information must be in the format specific to the specified constant. The application uses a Unicode string for the Unicode version of the function, and an ANSI string for the ANSI version.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INVALID_ACCESS. The access code was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setlocaleinfow
     * @since windows5.0
     */
    static SetLocaleInfoW(Locale, LCType, lpLCData) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetLocaleInfoW", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a calendar for a locale specified by identifier. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 
     * <div class="alert"><b>Note</b>  <b>GetCalendarInfo</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div> </div>
     * CAL_USE_CP_ACP is relevant only for the ANSI version of this function.
     * 
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {Pointer<PSTR>} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<UInt32>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcalendarinfoa
     * @since windows5.0
     */
    static GetCalendarInfoA(Locale, Calendar, CalType, lpCalData, cchData, lpValue) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetCalendarInfoA", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int", cchData, "ptr", lpValue)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information about a calendar for a locale specified by identifier. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 
     * <div class="alert"><b>Note</b>  <b>GetCalendarInfo</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div> </div>
     * CAL_USE_CP_ACP is relevant only for the ANSI version of this function.
     * 
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {Pointer<PWSTR>} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<UInt32>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcalendarinfow
     * @since windows5.0
     */
    static GetCalendarInfoW(Locale, Calendar, CalType, lpCalData, cchData, lpValue) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetCalendarInfoW", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int", cchData, "ptr", lpValue)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Sets an item of locale information for a calendar. For more information, see Date and Calendar. (ANSI)
     * @remarks
     * This function only affects the user override portion of the calendar settings. It does not set the system defaults.
     * 
     * Calendar information is always passed as a null-terminated Unicode string in the Unicode version of this function, and as a null-terminated ANSI string in the ANSI version. No integers are allowed by this function. Any numeric values must be specified as either Unicode or ANSI text.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * CAL_ITWODIGITYEARMAX can be used with any calendar, even if the calendar is not supported for the specified locale. To avoid complications, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoa">EnumCalendarInfo</a> to ensure that the calendar is supported for the locale of interest.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines SetCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> for the calendar for which to set information.
     * @param {Integer} CalType Type of calendar information to set. Only the following CALTYPE values are valid for this function. The CAL_USE_CP_ACP constant is only meaningful for the ANSI version of the function.
     * 
     * <ul>
     * <li>CAL_USE_CP_ACP</li>
     * <li>CAL_ITWODIGITYEARMAX</li>
     * </ul>
     * The application can specify only one calendar identifier per call to this function. An exception can be made if the application uses the binary OR operator to combine CAL_USE_CP_ACP with any valid CALTYPE value defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>.
     * @param {Pointer<PSTR>} lpCalData Pointer to a null-terminated calendar information string. The information must be in the format of the specified calendar type.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setcalendarinfoa
     * @since windows5.0
     */
    static SetCalendarInfoA(Locale, Calendar, CalType, lpCalData) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetCalendarInfoA", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets an item of locale information for a calendar. For more information, see Date and Calendar. (Unicode)
     * @remarks
     * This function only affects the user override portion of the calendar settings. It does not set the system defaults.
     * 
     * Calendar information is always passed as a null-terminated Unicode string in the Unicode version of this function, and as a null-terminated ANSI string in the ANSI version. No integers are allowed by this function. Any numeric values must be specified as either Unicode or ANSI text.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * CAL_ITWODIGITYEARMAX can be used with any calendar, even if the calendar is not supported for the specified locale. To avoid complications, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoa">EnumCalendarInfo</a> to ensure that the calendar is supported for the locale of interest.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines SetCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> for the calendar for which to set information.
     * @param {Integer} CalType Type of calendar information to set. Only the following CALTYPE values are valid for this function. The CAL_USE_CP_ACP constant is only meaningful for the ANSI version of the function.
     * 
     * <ul>
     * <li>CAL_USE_CP_ACP</li>
     * <li>CAL_ITWODIGITYEARMAX</li>
     * </ul>
     * The application can specify only one calendar identifier per call to this function. An exception can be made if the application uses the binary OR operator to combine CAL_USE_CP_ACP with any valid CALTYPE value defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>.
     * @param {Pointer<PWSTR>} lpCalData Pointer to a null-terminated calendar information string. The information must be in the format of the specified calendar type.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setcalendarinfow
     * @since windows5.0
     */
    static SetCalendarInfoW(Locale, Calendar, CalType, lpCalData) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetCalendarInfoW", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if a specified character is a lead byte for the system default Windows ANSI code page (CP_ACP). A lead byte is the first byte of a two-byte character in a double-byte character set (DBCS) for the code page.
     * @remarks
     * <div class="alert"><b>Note</b>  This function does not validate the presence or validity of a trail byte. Therefore, 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> might not recognize a 
     *      sequence that the application using <b>IsDBCSLeadByte</b> 
     *      reports as a lead byte. The application can easily become unsynchronized with the results of 
     *      <b>MultiByteToWideChar</b>, potentially leading to 
     *      unexpected errors or buffer size mismatches.</div>
     * <div> </div>
     * In general, instead of attempting low-level manipulation of code page data, applications should use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> to convert the 
     *     data to UTF-16 and work with it in that encoding.
     * 
     * Lead byte values are specific to each distinct DBCS. Some byte values can appear in a single code page as both 
     *     the lead and trail byte of a DBCS character.
     * 
     * To make sense of a DBCS string, an application normally starts at the beginning of a string and scans forward, 
     *     keeping track when it encounters a lead byte, and treating the next byte as the trailing part of the same 
     *     character. If the application must back up, it should use 
     *     <a href="https://docs.microsoft.com/windows/desktop/menurc/v">CharPrev</a> instead of attempting to develop its own 
     *     algorithm.
     * @param {Integer} TestChar The character to test.
     * @returns {Integer} Returns a nonzero value if the test character is potentially a lead byte. The function returns 0 if the test 
     *        character is not a lead byte or if it is a single-byte character. To get extended error information, the 
     *        application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isdbcsleadbyte
     * @since windows5.0
     */
    static IsDBCSLeadByte(TestChar) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsDBCSLeadByte", "char", TestChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if a specified character is potentially a lead byte. A lead byte is the first byte of a two-byte character in a double-byte character set (DBCS) for the code page.
     * @remarks
     * <div class="alert"><b>Note</b>   This function does not validate the presence or validity of a trail byte. Therefore, <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> might not recognize a sequence that the application using <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-isdbcsleadbyte">IsDBCSLeadByte</a> reports as a lead byte. The application can easily become unsynchronized with the results of <b>MultiByteToWideChar</b>, potentially leading to unexpected errors or buffer size mismatches.</div>
     * <div> </div>
     * In general, instead of attempting low-level manipulation of code page data, applications should use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> to convert the data to UTF-16 and work with it in that encoding.
     * 
     * Lead byte values are specific to each distinct DBCS. Some byte values can appear in a single code page as both the lead and trail byte of a DBCS character. Thus, <b>IsDBCSLeadByteEx</b> can only indicate a potential lead byte value.
     * 
     * To make sense of a DBCS string, an application normally starts at the beginning of the string and scans forward, keeping track when it encounters a lead byte, and treating the next byte as the trailing part of the same character. To back up, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-charprevexa">CharPrevExA</a> instead of attempting to develop its own algorithm.
     * @param {Integer} CodePage Identifier of the code page used to check lead byte ranges. This parameter can be one of the code page identifiers defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/unicode-and-character-set-constants">Unicode and Character Set Constants</a> or one of the following predefined values. This function validates lead byte values only in code pages 932, 936, 949, 950, and 1361.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the Windows ANSI code page for the current thread.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} TestChar The character to test.
     * @returns {Integer} Returns a nonzero value if the byte is a lead byte. The function returns 0 if the byte is not a lead byte or if the character is a single-byte character. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isdbcsleadbyteex
     * @since windows5.0
     */
    static IsDBCSLeadByteEx(CodePage, TestChar) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsDBCSLeadByteEx", "uint", CodePage, "char", TestChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a locale name to a locale identifier.
     * @remarks
     * For custom locales, including those created by Microsoft, your applications should prefer locale names over locale identifiers. See [The deprecation of LCIDs](/globalization/locale/locale-names#the-deprecation-of-lcids) for more info.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<PWSTR>} lpName Pointer to a null-terminated string representing a locale name, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags <b>Prior to Windows 7:</b>Reserved; should always be 0.
     * 
     * <b>Beginning in Windows 7:</b> Can be set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-allow-neutral-names">LOCALE_ALLOW_NEUTRAL_NAMES</a> to allow the return of a neutral LCID.
     * @returns {Integer} If successful, returns the locale identifier corresponding to the locale name.
     * 
     * If the supplied locale name corresponds to a custom locale that is the user default, this function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>.
     * 
     * If the locale name corresponds to a custom locale that is not the user default, is a transient locale, or is a CLDR (Unicode Common Locale Data Repository) locale, the function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return ERROR_INVALID_PARAMETER if any of the parameter values are invalid.
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-localenametolcid
     * @since windows6.0.6000
     */
    static LocaleNameToLCID(lpName, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\LocaleNameToLCID", "ptr", lpName, "uint", dwFlags, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a locale identifier to a locale name.
     * @param {Integer} Locale Locale identifier to translate. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Pointer<PWSTR>} lpName Pointer to a buffer in which this function retrieves the locale name, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} cchName Size, in characters, of the locale name buffer. The maximum possible length of a locale name, including a terminating null character, is <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply for this parameter.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the locale name buffer.
     * @param {Integer} dwFlags <b>Before Windows 7:</b> Reserved; should always be 0.
     * 
     * <b>Starting with Windows 7:</b> Can be set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-allow-neutral-names">LOCALE_ALLOW_NEUTRAL_NAMES</a> to allow the return of a neutral name.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-lcidtolocalename
     * @since windows6.0.6000
     */
    static LCIDToLocaleName(Locale, lpName, cchName, dwFlags) {
        A_LastError := 0

        DllCall("KERNEL32.dll\LCIDToLocaleName", "uint", Locale, "ptr", lpName, "int", cchName, "uint", dwFlags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a duration of time as a time string for a locale specified by identifier.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getdurationformatex">GetDurationFormatEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the duration. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying function options. If <i>lpFormat</i> is not set to <b>NULL</b>, this parameter must be set to 0. If <i>lpFormat</i> is set to <b>NULL</b>, your application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default duration format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div> </div>
     * @param {Pointer<SYSTEMTIME>} lpDuration Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time duration information to format. If this pointer is <b>NULL</b>, the function ignores this parameter and uses <i>ullDuration</i>.
     * @param {Integer} ullDuration 64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both <i>lpDuration</i> and <i>ullDuration</i> are present, <i>lpDuration</i> takes precedence. If <i>lpDuration</i> is set to <b>NULL</b> and <i>ullDuration</i> is set to 0, the duration is zero.
     * @param {Pointer<PWSTR>} lpFormat Pointer to the format string. For details, see the <i>lpFormat</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getdurationformatex">GetDurationFormatEx</a>.
     * @param {Pointer<PWSTR>} lpDurationStr Pointer to the buffer in which the function retrieves the duration string.
     * 
     * Alternatively, this parameter can contain <b>NULL</b> if <i>cchDuration</i> is set to 0. In this case, the function returns the required size for the duration string buffer.
     * @param {Integer} cchDuration Size, in characters, of the buffer indicated by <i>lpDurationStr</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpDurationStr</i> and returns the required size for the duration string buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getdurationformat
     * @since windows6.0.6000
     */
    static GetDurationFormat(Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetDurationFormat", "uint", Locale, "uint", dwFlags, "ptr", lpDuration, "uint", ullDuration, "ptr", lpFormat, "ptr", lpDurationStr, "int", cchDuration)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a number string as a number string customized for a locale specified by identifier. (ANSI)
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetNumberFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div> </div>
     * @param {Pointer<PSTR>} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTA>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If this parameter does is not set to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale-specific string value for the negative sign.
     * @param {Pointer<PSTR>} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string.
     * @param {Integer} cchNumber Size, in TCHAR values, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer, and does not use the <i>lpNumberStr</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnumberformata
     * @since windows5.0
     */
    static GetNumberFormatA(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetNumberFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a number string as a number string customized for a locale specified by identifier. (Unicode)
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetNumberFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If this parameter does is not set to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale-specific string value for the negative sign.
     * @param {Pointer<PWSTR>} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string.
     * @param {Integer} cchNumber Size, in TCHAR values, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer, and does not use the <i>lpNumberStr</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnumberformatw
     * @since windows5.0
     */
    static GetNumberFormatW(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetNumberFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a number string as a currency string for a locale specified by identifier. (ANSI)
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCurrencyFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the currency string. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling currency format. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>  Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div> </div>
     * @param {Pointer<PSTR>} lpValue For details, see the <i>lpValue</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcurrencyformatex">GetCurrencyFormatEx</a>.
     * @param {Pointer<CURRENCYFMTA>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure, for example, the string value for the negative sign used by the locale.
     * @param {Pointer<PSTR>} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application sets this parameter to 0 if the function is to return the size of the buffer required to hold the formatted currency string. In this case, the <i>lpCurrencyStr</i> parameter is not used.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcurrencyformata
     * @since windows5.0
     */
    static GetCurrencyFormatA(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetCurrencyFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a number string as a currency string for a locale specified by identifier. (Unicode)
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCurrencyFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the currency string. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling currency format. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>  Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpValue For details, see the <i>lpValue</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcurrencyformatex">GetCurrencyFormatEx</a>.
     * @param {Pointer<CURRENCYFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure, for example, the string value for the negative sign used by the locale.
     * @param {Pointer<PWSTR>} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application sets this parameter to 0 if the function is to return the size of the buffer required to hold the formatted currency string. In this case, the <i>lpCurrencyStr</i> parameter is not used.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcurrencyformatw
     * @since windows5.0
     */
    static GetCurrencyFormatW(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetCurrencyFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Enumerates calendar information for a specified locale.Note  To receive a calendar identifier in addition to calendar information, the application should use the EnumCalendarInfoEx function. (ANSI)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CALINFO_ENUMPROCA>} lpCalInfoEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317806(v=vs.85)">EnumCalendarInfoProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfoa
     * @since windows5.0
     */
    static EnumCalendarInfoA(lpCalInfoEnumProc, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoA", "ptr", lpCalInfoEnumProc, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates calendar information for a specified locale.Note  To receive a calendar identifier in addition to calendar information, the application should use the EnumCalendarInfoEx function. (Unicode)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CALINFO_ENUMPROCW>} lpCalInfoEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317806(v=vs.85)">EnumCalendarInfoProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfow
     * @since windows5.0
     */
    static EnumCalendarInfoW(lpCalInfoEnumProc, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoW", "ptr", lpCalInfoEnumProc, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates calendar information for a locale specified by identifier.Note  Any application that runs only on Windows Vista and later should use EnumCalendarInfoExEx in preference to this function. (ANSI)
     * @remarks
     * This function enumerates calendar information for all applicable calendars for the specified locale, or for a single requested calendar, depending on the value of the <i>Calendar</i> parameter. The function enumerates the calendar information by calling the specified application-defined callback function. It passes the callback function a pointer to a buffer containing the requested calendar information. This process continues until <b>EnumCalendarInfoEx</b> finds the last applicable calendar or the callback function returns <b>FALSE</b>.
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumCalendarInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CALINFO_ENUMPROCEXA>} lpCalInfoEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317807(v=vs.85)">EnumCalendarInfoProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfoexa
     * @since windows5.0
     */
    static EnumCalendarInfoExA(lpCalInfoEnumProcEx, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExA", "ptr", lpCalInfoEnumProcEx, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates calendar information for a locale specified by identifier.Note  Any application that runs only on Windows Vista and later should use EnumCalendarInfoExEx in preference to this function. (Unicode)
     * @remarks
     * This function enumerates calendar information for all applicable calendars for the specified locale, or for a single requested calendar, depending on the value of the <i>Calendar</i> parameter. The function enumerates the calendar information by calling the specified application-defined callback function. It passes the callback function a pointer to a buffer containing the requested calendar information. This process continues until <b>EnumCalendarInfoEx</b> finds the last applicable calendar or the callback function returns <b>FALSE</b>.
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumCalendarInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CALINFO_ENUMPROCEXW>} lpCalInfoEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317807(v=vs.85)">EnumCalendarInfoProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfoexw
     * @since windows5.0
     */
    static EnumCalendarInfoExW(lpCalInfoEnumProcEx, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExW", "ptr", lpCalInfoEnumProcEx, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by identifier.Note  For interoperability reasons, the application should prefer the EnumTimeFormatsEx function to EnumTimeFormats because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that runs only on Windows Vista and later should use EnumTimeFormatsEx. (ANSI)
     * @remarks
     * The function enumerates the time formats by passing a pointer to a buffer containing a time format to an application-defined callback function. The first value in the enumeration is always the user default (override) value. The function continues enumeration until the last time format is found or the callback function returns <b>FALSE</b>. 
     * 
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark ("?"). 
     * Note that any new values for <i>dwFlags</i> introduced in the future will not work with the ANSI version.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumTimeFormats as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<TIMEFMT_ENUMPROCA>} lpTimeFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317832(v=vs.85)">EnumTimeFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve time format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumtimeformatsa
     * @since windows5.0
     */
    static EnumTimeFormatsA(lpTimeFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsA", "ptr", lpTimeFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by identifier.Note  For interoperability reasons, the application should prefer the EnumTimeFormatsEx function to EnumTimeFormats because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that runs only on Windows Vista and later should use EnumTimeFormatsEx. (Unicode)
     * @remarks
     * The function enumerates the time formats by passing a pointer to a buffer containing a time format to an application-defined callback function. The first value in the enumeration is always the user default (override) value. The function continues enumeration until the last time format is found or the callback function returns <b>FALSE</b>. 
     * 
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark ("?"). 
     * Note that any new values for <i>dwFlags</i> introduced in the future will not work with the ANSI version.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumTimeFormats as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<TIMEFMT_ENUMPROCW>} lpTimeFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317832(v=vs.85)">EnumTimeFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve time format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumtimeformatsw
     * @since windows5.0
     */
    static EnumTimeFormatsW(lpTimeFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsW", "ptr", lpTimeFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * For details of operation of this function, see Remarks in <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a>.
     * 
     * <div class="alert"><b>Note</b>  To enumerate the date formats for locales with alternate calendars, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a>.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumDateFormats as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DATEFMT_ENUMPROCA>} lpDateFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317813(v=vs.85)">EnumDateFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsa
     * @since windows5.0
     */
    static EnumDateFormatsA(lpDateFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsA", "ptr", lpDateFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * For details of operation of this function, see Remarks in <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a>.
     * 
     * <div class="alert"><b>Note</b>  To enumerate the date formats for locales with alternate calendars, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a>.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumDateFormats as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DATEFMT_ENUMPROCW>} lpDateFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317813(v=vs.85)">EnumDateFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsw
     * @since windows5.0
     */
    static EnumDateFormatsW(lpDateFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsW", "ptr", lpDateFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale.Note  Any application that runs only on Windows Vista and later should use EnumDateFormatsExEx in preference to this function. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * The function enumerates the date formats by passing date format string pointers, one at a time, to the specified application-defined callback function. This process continues until <b>EnumDateFormatsEx</b> finds the last date format or the callback function returns <b>FALSE</b>.
     * 
     * This function enumerates all date formats for the specified locale, including alternate calendars, if any. However, the calendar identifier is not enumerated along with the date format, making formats for locales with alternate calendars difficult to use.
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * The application should use <b>EnumDateFormatsEx</b> (instead of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsa">EnumDateFormats</a>) to enumerate date formats for locales with alternate calendars.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumDateFormatsEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DATEFMT_ENUMPROCEXA>} lpDateFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317814(v=vs.85)">EnumDateFormatsProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsexa
     * @since windows5.0
     */
    static EnumDateFormatsExA(lpDateFmtEnumProcEx, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExA", "ptr", lpDateFmtEnumProcEx, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale.Note  Any application that runs only on Windows Vista and later should use EnumDateFormatsExEx in preference to this function. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * The function enumerates the date formats by passing date format string pointers, one at a time, to the specified application-defined callback function. This process continues until <b>EnumDateFormatsEx</b> finds the last date format or the callback function returns <b>FALSE</b>.
     * 
     * This function enumerates all date formats for the specified locale, including alternate calendars, if any. However, the calendar identifier is not enumerated along with the date format, making formats for locales with alternate calendars difficult to use.
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * The application should use <b>EnumDateFormatsEx</b> (instead of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsa">EnumDateFormats</a>) to enumerate date formats for locales with alternate calendars.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumDateFormatsEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DATEFMT_ENUMPROCEXW>} lpDateFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317814(v=vs.85)">EnumDateFormatsProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsexw
     * @since windows5.0
     */
    static EnumDateFormatsExW(lpDateFmtEnumProcEx, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExW", "ptr", lpDateFmtEnumProcEx, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if a language group is installed or supported on the operating system. For more information, see NLS Terminology.
     * @remarks
     * If the LGRPID_INSTALLED flag is specified and this function returns <b>TRUE</b>, the language group identifier is both supported and installed on the operating system.
     * 
     * If the LGRPID_SUPPORTED flag is specified and this function returns <b>TRUE</b>, the language group identifier is supported in the release, but not necessarily installed on the operating system.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns <b>TRUE</b> if the language group identifier passes the specified validity test, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidlanguagegroup
     * @since windows5.0
     */
    static IsValidLanguageGroup(LanguageGroup, dwFlags) {
        result := DllCall("KERNEL32.dll\IsValidLanguageGroup", "uint", LanguageGroup, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves information about the current version of a specified NLS capability for a locale specified by identifier.Note  For interoperability reasons, the application should prefer the GetNLSVersionEx function to GetNLSVersion because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. This recommendation applies especially to custom locales, for which GetNLSVersionEx retrieves enough information to determine if sort behavior has changed. Any application that runs only on Windows Vista and later should use GetNLSVersionEx or at least pass the NLSVERSIONINFOEX structure when calling GetNLSVersion to obtain additional sorting versioning data.
     * @remarks
     * This function allows an application such as Active Directory to determine if an NLS change affects the locale identifier used for a particular index table. If it does not, there is no need to re-index the table. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * @param {Integer} Function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c>sizeof(NLSVERSIONINFO)</c>.
     * 
     * <div class="alert"><b>Note</b>  On Windows Vista and later, the function can alternatively provide version information in an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure.</div>
     * <div> </div>
     * @returns {Integer} Returns <b>TRUE</b> if and only if the application has supplied valid values in <i>lpVersionInformation</i>, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnlsversion
     * @since windows6.0.6000
     */
    static GetNLSVersion(Function, Locale, lpVersionInformation) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNLSVersion", "uint", Function, "uint", Locale, "ptr", lpVersionInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if the specified locale is installed or supported on the operating system. For more information, see Locales and Languages.
     * @remarks
     * If the LCID_INSTALLED flag is specified and this function returns a nonzero value, the locale identifier is both supported and installed on the operating system. Having an identifier installed implies that the full level of language support is available for the indicated locale. Full support includes code page translation tables, keyboard layouts, fonts, and sorting and locale data.
     * 
     * If LCID_SUPPORTED is specified and this function returns 0, the locale identifier is supported in the release, but not necessarily installed on the operating system.
     * 
     * This function can handle data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale to validate. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * <b>Windows Server 2003, Windows XP and Windows 2000:  </b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * <b>Windows Server 2003, Windows XP and Windows 2000:  </b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * <b>Windows Server 2003, Windows XP and Windows 2000:  </b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a nonzero value if the locale identifier passes the specified validity test. The function returns 0 if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidlocale
     * @since windows5.0
     */
    static IsValidLocale(Locale, dwFlags) {
        result := DllCall("KERNEL32.dll\IsValidLocale", "uint", Locale, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves information about a specified geographical location. (ANSI)
     * @remarks
     * If the application specifies GEO_RFC1766 for <i>GeoType</i>, it should specify a language identifier for <i>LangId</i> that is appropriate to the specified geographical location identifier. The appropriate language is either a locale-neutral language or one with a locale corresponding to the specified identifier. The resulting string, compliant with RFC 4646 (Windows Vista), constitutes a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>.
     * 
     * For example, if <i>Location</i> is specified as 0xF4 for United States, <i>GeoType</i> is specified as GEO_RFC1766, and <i>LangId</i> is specified as either 0x09 for locale-neutral English or 0x409 for English (United States), the function retrieves "en-US" on successful return. In fact, the function ignores the locale-specific portion of the language. Thus, if the application specifies <i>LangId</i> as 0x809 for English (United Kingdom), the function also writes "en-US" to <i>lpGeoData</i>.
     * 
     * Consider another example. If <i>Location</i> is specified as 0xF4 for United States, <i>GeoType</i> is specified as GEO_RFC1766, and <i>LangId</i> is specified as 0x04 for Chinese, the function retrieves "zh-US" on successful return. This is not the name of a supported locale.
     * 
     * If the application specifies GEO_LCID for <i>GeoType</i>, the function treats the language identifier as a locale identifier (LCID). It attempts to return the locale identifier if it is associated with the provided geographical identifier in some way. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetGeoInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Location Identifier for the geographical location for which to get information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/table-of-geographical-locations">Table of Geographical Locations</a>. You can obtain the available values by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeoid">EnumSystemGeoID</a>.
     * @param {Integer} GeoType Type of information to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. If the value of <i>GeoType</i> is GEO_LCID, the function retrieves a locale identifier. If the value of <i>GeoType</i> is GEO_RFC1766, the function retrieves a string name that is compliant with RFC 4646 (Windows Vista). For more information, see the Remarks section.
     * 
     * <b>Windows XP:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is an 8-digit hexadecimal value.
     * 
     * <b>Windows Me:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is a decimal value.
     * @param {Pointer<PSTR>} lpGeoData Pointer to the buffer in which this function retrieves the information.
     * @param {Integer} cchData Size of the buffer indicated by <i>lpGeoData</i>. The size is the number of bytes for the ANSI version of the function, or the number of words for the Unicode version. The application can set this parameter to 0 if the function is to return the required size of the buffer.
     * @param {Integer} LangId Identifier for the language, used with the value of <i>Location</i>. The application can set this parameter to 0, with GEO_RFC1766 or GEO_LCID specified for <i>GeoType</i>. This setting causes the function to retrieve the language identifier by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlangid">GetUserDefaultLangID</a>.
     * 
     * <div class="alert"><b>Note</b>   The application must set this parameter to 0 if <i>GeoType</i> has any value other than GEO_RFC1766 or GEO_LCID.</div>
     * <div> </div>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getgeoinfoa
     * @since windows5.1.2600
     */
    static GetGeoInfoA(Location, GeoType, lpGeoData, cchData, LangId) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetGeoInfoA", "int", Location, "int", GeoType, "ptr", lpGeoData, "int", cchData, "ushort", LangId)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information about a specified geographical location. (Unicode)
     * @remarks
     * If the application specifies GEO_RFC1766 for <i>GeoType</i>, it should specify a language identifier for <i>LangId</i> that is appropriate to the specified geographical location identifier. The appropriate language is either a locale-neutral language or one with a locale corresponding to the specified identifier. The resulting string, compliant with RFC 4646 (Windows Vista), constitutes a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>.
     * 
     * For example, if <i>Location</i> is specified as 0xF4 for United States, <i>GeoType</i> is specified as GEO_RFC1766, and <i>LangId</i> is specified as either 0x09 for locale-neutral English or 0x409 for English (United States), the function retrieves "en-US" on successful return. In fact, the function ignores the locale-specific portion of the language. Thus, if the application specifies <i>LangId</i> as 0x809 for English (United Kingdom), the function also writes "en-US" to <i>lpGeoData</i>.
     * 
     * Consider another example. If <i>Location</i> is specified as 0xF4 for United States, <i>GeoType</i> is specified as GEO_RFC1766, and <i>LangId</i> is specified as 0x04 for Chinese, the function retrieves "zh-US" on successful return. This is not the name of a supported locale.
     * 
     * If the application specifies GEO_LCID for <i>GeoType</i>, the function treats the language identifier as a locale identifier (LCID). It attempts to return the locale identifier if it is associated with the provided geographical identifier in some way. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetGeoInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Location Identifier for the geographical location for which to get information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/table-of-geographical-locations">Table of Geographical Locations</a>. You can obtain the available values by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeoid">EnumSystemGeoID</a>.
     * @param {Integer} GeoType Type of information to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. If the value of <i>GeoType</i> is GEO_LCID, the function retrieves a locale identifier. If the value of <i>GeoType</i> is GEO_RFC1766, the function retrieves a string name that is compliant with RFC 4646 (Windows Vista). For more information, see the Remarks section.
     * 
     * <b>Windows XP:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is an 8-digit hexadecimal value.
     * 
     * <b>Windows Me:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is a decimal value.
     * @param {Pointer<PWSTR>} lpGeoData Pointer to the buffer in which this function retrieves the information.
     * @param {Integer} cchData Size of the buffer indicated by <i>lpGeoData</i>. The size is the number of bytes for the ANSI version of the function, or the number of words for the Unicode version. The application can set this parameter to 0 if the function is to return the required size of the buffer.
     * @param {Integer} LangId Identifier for the language, used with the value of <i>Location</i>. The application can set this parameter to 0, with GEO_RFC1766 or GEO_LCID specified for <i>GeoType</i>. This setting causes the function to retrieve the language identifier by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlangid">GetUserDefaultLangID</a>.
     * 
     * <div class="alert"><b>Note</b>   The application must set this parameter to 0 if <i>GeoType</i> has any value other than GEO_RFC1766 or GEO_LCID.</div>
     * <div> </div>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getgeoinfow
     * @since windows5.1.2600
     */
    static GetGeoInfoW(Location, GeoType, lpGeoData, cchData, LangId) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetGeoInfoW", "int", Location, "int", GeoType, "ptr", lpGeoData, "int", cchData, "ushort", LangId)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information about a geographic location that you specify by using a two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code.
     * @remarks
     * For information about two-letter ISO 3166-1 codes, see <a href="https://www.iso.org/iso-3166-country-codes.html">Country Codes - ISO 3166</a>.  For information about numeric UN M.49 codes, see <a href="https://unstats.un.org/unsd/methodology/m49/">Standard country or area codes for statistical use (M49)</a>.
     * @param {Pointer<PWSTR>} location The two-letter ISO 3166-1 or numeric UN M.49 code for the geographic location for which to get information.  To get the codes that are available on the operating system, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeonames">EnumSystemGeoNames</a>.
     * @param {Integer} geoType The type of information you want to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. The following values of the <b>SYSGEOTYPE</b> enumeration should not be used with <b>GetGeoInfoEx</b>:
     * 
     * <ul>
     * <li>
     * <b>GEO_ID</b>
     * 
     * This value is provided for backward compatibility.  Do not use this value in new applications, but use <b>GEO_NAME</b> instead.
     * 
     * </li>
     * <li>
     * <b>GEO_LCID</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * <li>
     * <b>GEO_NATION</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * <li>
     * <b>GEO_RFC1766</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * </ul>
     * @param {Pointer<PWSTR>} geoData A pointer to the buffer in which <b>GetGeoInfoEx</b> should write the  requested information.
     * @param {Integer} geoDataCount The size of the buffer to which the <i>GeoData</i> parameter points, in characters. Set this parameter to 0 to specify that the function should only return the size of the buffer required to store the requested information without writing the requested information to the buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getgeoinfoex
     * @since windows10.0.16299
     */
    static GetGeoInfoEx(location, geoType, geoData, geoDataCount) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetGeoInfoEx", "ptr", location, "int", geoType, "ptr", geoData, "int", geoDataCount)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Enumerates the geographical location identifiers (type GEOID) that are available on the operating system.
     * @param {Integer} GeoClass Geographical location class for which to enumerate the identifiers. At present, only GEOCLASS_NATION is supported. This type causes the function to enumerate all geographical identifiers for nations on the operating system.
     * @param {Integer} ParentGeoId Reserved. This parameter must be 0.
     * @param {Pointer<GEO_ENUMPROC>} lpGeoEnumProc Pointer to the application-defined callback function <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317817(v=vs.85)">EnumGeoInfoProc</a>. The <b>EnumSystemGeoID</b> function makes repeated calls to this callback function until it returns <b>FALSE</b>.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemgeoid
     * @since windows5.1.2600
     */
    static EnumSystemGeoID(GeoClass, ParentGeoId, lpGeoEnumProc) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemGeoID", "uint", GeoClass, "int", ParentGeoId, "ptr", lpGeoEnumProc, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the two-letter International Organization for Standardization (ISO) 3166-1 codes or numeric United Nations (UN) Series M, Number 49 (M.49) codes for geographical locations that are available on the operating system.
     * @remarks
     * For information about two-letter ISO 3166-1 codes, see <a href="https://www.iso.org/iso-3166-country-codes.html">Country Codes - ISO 3166</a>.  For information about numeric UN M.49 codes, see <a href="https://unstats.un.org/unsd/methodology/m49/">Standard country or area codes for statistical use (M49)</a>.
     * @param {Integer} geoClass The geographical location class for which to enumerate the available two-letter ISO 3166-1 or numeric UN M.49 codes.
     * @param {Pointer<GEO_ENUMNAMEPROC>} geoEnumProc Pointer to the application-defined callback function <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-geo_enumnameproc">Geo_EnumNameProc</a>. The <b>EnumSystemGeoNames</b> function calls this callback function for each of the two-letter ISO 3166-1 or numeric UN M.49 codes for geographical locations that are available on the operating system until callback function returns <b>FALSE</b>.
     * @param {Pointer} data Application-specific information to pass to the callback function that the <i>genEnumProc</i> parameter specifies.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The values supplied for flags were not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was not valid. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemgeonames
     * @since windows10.0.16299
     */
    static EnumSystemGeoNames(geoClass, geoEnumProc, data) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemGeoNames", "uint", geoClass, "ptr", geoEnumProc, "ptr", data, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the geographical location of the user. For more information, see Table of Geographical Locations.
     * @param {Integer} GeoClass Geographical location class to return. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeoclass">SYSGEOCLASS</a> enumeration.
     * @returns {Integer} Returns the geographical location identifier of the user if <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setusergeoid">SetUserGeoID</a> has been called before to set the identifier.
     * 
     * If no geographical location identifier has been set for the user, the function returns GEOID_NOT_AVAILABLE.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getusergeoid
     * @since windows5.1.2600
     */
    static GetUserGeoID(GeoClass) {
        result := DllCall("KERNEL32.dll\GetUserGeoID", "int", GeoClass, "int")
        return result
    }

    /**
     * Retrieves the two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code for the default geographical location of the user.
     * @remarks
     * For information about two-letter ISO 3166-1 codes, see <a href="https://www.iso.org/iso-3166-country-codes.html">Country Codes - ISO 3166</a>.  For information about numeric UN M.49 codes, see <a href="https://unstats.un.org/unsd/methodology/m49/">Standard country or area codes for statistical use (M49)</a>.
     * @param {Pointer<PWSTR>} geoName Pointer to a buffer in which this function should write the null-terminated two-letter ISO 3166-1 or numeric UN M.49 code for the default geographic location of the user.
     * @param {Integer} geoNameCount The size of the buffer that the <i>geoName</i> parameter specifies. If this value is zero, the function only returns the number of characters that function would copy to the output buffer, but does not write the name of the default geographic location of the user to the buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultgeoname
     * @since windows10.0.16299
     */
    static GetUserDefaultGeoName(geoName, geoNameCount) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetUserDefaultGeoName", "ptr", geoName, "int", geoNameCount)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Sets the geographical location identifier for the user. This identifier should have one of the values described in Table of Geographical Locations.
     * @remarks
     * This function writes to the registry the geographical location for a particular user instead of a particular application. This action affects the behavior of other applications run by the user. As a rule, the application should call this function only when the user has explicitly requested changes, but not for purely application-specific reasons.
     * 
     * <b>SetUserGeoID</b> is intended for use by applications that are designed to change user settings, such as the Windows Settings app. Other applications should not call this function.
     * @param {Integer} GeoId Identifier for the geographical location of the user.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.
     * 
     * <b>Windows XP, Windows Server 2003</b>: This function does not supply extended error information. Thus it is not appropriate for an application to call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> after this function. If the application does call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, it can return a value set by some previously called function.
     * 
     * If this function does not succeed, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setusergeoid
     * @since windows5.1.2600
     */
    static SetUserGeoID(GeoId) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetUserGeoID", "int", GeoId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the geographic location for the current user to the specified two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code.
     * @remarks
     * This function writes to the registry the geographical location for a particular user instead of a particular application. This action affects the behavior of other applications that the user runs. As a rule, call this function only when the user has explicitly requested changes, but not for purely application-specific reasons.
     * 
     * For information about two-letter ISO 3166-1 codes, see <a href="https://www.iso.org/iso-3166-country-codes.html">Country Codes - ISO 3166</a>.  For information about numeric UN M.49 codes, see <a href="https://unstats.un.org/unsd/methodology/m49/">Standard country or area codes for statistical use (M49)</a>.
     * 
     * <b>SetUserGeoName</b> is intended for use by applications that are designed to change user settings, such as the Windows Settings app. Other applications should not call this function.
     * @param {Pointer<PWSTR>} geoName The two-letter ISO 3166-1 or numeric UN M.49 code for the geographic location to set for the current user. To get the codes that are available on the operating system, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeonames">EnumSystemGeoNames</a>.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.
     * 
     * If this function does not succeed, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DISABLED_BY_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The group policy of the computer or the user has forbidden this operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INTERNAL_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unexpected error occurred in the function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setusergeoname
     * @since windows10.0.16299
     */
    static SetUserGeoName(geoName) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetUserGeoName", "ptr", geoName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a default locale value to an actual locale identifier.
     * @remarks
     * A call to <b>ConvertDefaultLocale</b> specifying LOCALE_SYSTEM_DEFAULT is equivalent to a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getsystemdefaultlcid">GetSystemDefaultLCID</a>. A call to <b>ConvertDefaultLocale</b> specifying LOCALE_USER_DEFAULT is equivalent to a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlcid">GetUserDefaultLCID</a>.
     * @param {Integer} Locale Default locale identifier value to convert. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @returns {Integer} Returns the appropriate locale identifier if successful.
     * 
     * This function returns the value of the <i>Locale</i> parameter if it does not succeed. The function fails when the <i>Locale</i> value is not one of the default values listed above.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-convertdefaultlocale
     * @since windows5.0
     */
    static ConvertDefaultLocale(Locale) {
        result := DllCall("KERNEL32.dll\ConvertDefaultLocale", "uint", Locale, "uint")
        return result
    }

    /**
     * Retrieves the language identifier for the system default UI language of the operating system, also known as the &quot;install language&quot; on Windows Vista and later. For more information, see User Interface Language Management.
     * @remarks
     * This function never returns a language identifier for a Language Interface Pack (LIP). It also never returns a language identifier corresponding to the locale identifier [LOCALE_CUSTOM_UNSPECIFIED](/windows/desktop/Intl/locale-custom-constants) or [LOCALE_CUSTOM_UI_DEFAULT](/windows/desktop/Intl/locale-custom-constants).
     * 
     * Note that this function does not necessarily return the identifier for the first language in the system preferred UI languages list. Therefore the return might not match the first element retrieved by [GetSystemPreferredUILanguages](/windows/desktop/api/winnls/nf-winnls-getsystempreferreduilanguages).
     * @returns {Integer} Returns the language identifier for the system default UI language of the operating system. For more information, see the Remarks section.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystemdefaultuilanguage
     * @since windows5.0
     */
    static GetSystemDefaultUILanguage() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultUILanguage", "ushort")
        return result
    }

    /**
     * Returns the locale identifier of the current locale for the calling thread.Note  This function can retrieve data that changes between releases, for example, due to a custom locale.
     * @remarks
     * When an application process launches, it uses the Standards and Formats variable for the locale. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/nls-terminology">NLS Terminology</a>.
     * 
     * When a new thread is created in a process, it inherits the locale of the creating thread. This locale can be either the default Standards and Formats locale or a different locale set for the creating thread in a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadlocale">SetThreadLocale</a>. <b>GetThreadLocale</b> and <b>SetThreadLocale</b> can be used to modify the locale of the new thread.
     * @returns {Integer} Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale associated with the current thread.
     * 
     * <b>Windows Vista</b>: This function can return the identifier of a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locale</a>. If the current thread locale is a custom locale, the function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>. If the current thread locale is a supplemental custom locale, the function can return <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. All supplemental locales share this locale identifier.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getthreadlocale
     * @since windows5.0
     */
    static GetThreadLocale() {
        result := DllCall("KERNEL32.dll\GetThreadLocale", "uint")
        return result
    }

    /**
     * Sets the current locale of the calling thread.
     * @remarks
     * When a thread is created, it uses the user locale. This value is returned by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlcid">GetUserDefaultLCID</a>. The user locale can be modified for future processes and thread creation using the regional and language options portion of the Control Panel. The thread locale can also be changed using <b>SetThreadLocale</b>.
     * 
     * <b>SetThreadLocale</b> affects the selection of resources with a <a href="https://docs.microsoft.com/windows/desktop/menurc/language-statement">LANGUAGE</a> statement. The statement affects such functions as <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdialoga">CreateDialog</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dialogboxa">DialogBox</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadmenua">LoadMenu</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadstringa">LoadString</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a>. It sets the code page implied by CP_THREAD_ACP, but does not affect <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>.
     * 
     * <b>Windows Vista and later: </b> Do not use <b>SetThreadLocale</b> to select a user interface language. The resource loader selects the resource that is defined in the .rc file with a <a href="https://docs.microsoft.com/windows/desktop/menurc/language-statement">LANGUAGE</a> statement, or the application can use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a>. Additionally, the application can use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a>.
     *       
     * 
     * <b>Windows 2000, Windows XP:</b> Do not use <b>SetThreadLocale</b> to select a user interface language. To select the resource that is defined in the .rc file with a <a href="https://docs.microsoft.com/windows/desktop/menurc/language-statement">LANGUAGE</a> statement, the application must use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a> function.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @returns {Integer} The function should return an LCID on success. This is the LCID of the previous thread locale.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setthreadlocale
     * @since windows5.0
     */
    static SetThreadLocale(Locale) {
        result := DllCall("KERNEL32.dll\SetThreadLocale", "uint", Locale, "int")
        return result
    }

    /**
     * Returns the language identifier for the user UI language for the current user.
     * @remarks
     * This function returns only a language identifier. An application can retrieve the language name using the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserpreferreduilanguages">GetUserPreferredUILanguages</a> function.
     * 
     * If the user UI language is part of a Language Interface Pack (LIP) and corresponds to a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>, this function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>.
     * 
     * <b>Windows Me, Windows 2000, Windows XP, Windows Server 2003:</b> The <b>GetUserDefaultUILanguage</b> function retrieves the language identifier for the current user language. If MUI is not installed on the operating system, the function retrieves the default computer user interface language.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.UInt16 GetUserDefaultUILanguage();
     * 
     * ```
     * @returns {Integer} Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> for the user UI language for the current user.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultuilanguage
     * @since windows5.0
     */
    static GetUserDefaultUILanguage() {
        result := DllCall("KERNEL32.dll\GetUserDefaultUILanguage", "ushort")
        return result
    }

    /**
     * Returns the language identifier of the Region Format setting for the current user.
     * @remarks
     * The return value is not necessarily the same as that returned by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getsystemdefaultlangid">GetSystemDefaultLangID</a>, even for a single-user computer.
     * @returns {Integer} Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> for the current user as set under <b>Control Panel</b> &gt; <b>Clock, Language, and Region</b> &gt; <b>Change date, time, or number formats</b> &gt; <b>Formats</b> tab &gt; <b>Format</b> dropdown.
     * 
     * For more information on language identifiers, see <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultlangid
     * @since windows5.0
     */
    static GetUserDefaultLangID() {
        result := DllCall("KERNEL32.dll\GetUserDefaultLangID", "ushort")
        return result
    }

    /**
     * Returns the language identifier for the system locale.
     * @returns {Integer} Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> for the system locale. This is  the language used when displaying text in programs that do not support Unicode. It is set by the Administrator under <b>Control Panel</b> &gt; <b>Clock, Language, and Region</b> &gt; <b>Change date, time, or number formats</b> &gt; <b>Administrative</b> tab.
     * 
     * For more information on language identifiers, see <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystemdefaultlangid
     * @since windows5.0
     */
    static GetSystemDefaultLangID() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultLangID", "ushort")
        return result
    }

    /**
     * Returns the locale identifier for the system locale.Note  Any application that runs only on Windows Vista and later should use GetSystemDefaultLocaleName in preference to this function.
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @returns {Integer} Returns the locale identifier for the system default locale, identified by <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystemdefaultlcid
     * @since windows5.0
     */
    static GetSystemDefaultLCID() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultLCID", "uint")
        return result
    }

    /**
     * Returns the locale identifier for the user default locale.Caution  If the user default locale is a custom locale, an application cannot accurately tag data with the value or exchange it.
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @returns {Integer} Returns the locale identifier for the user default locale, represented as <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>. If the user default locale is a custom locale, this function always returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>, regardless of the custom locale that is selected. For example, whether the user locale is Hawaiian (US), haw-US, or Fijiian (Fiji), fj-FJ, the function returns the same value.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultlcid
     * @since windows5.0
     */
    static GetUserDefaultLCID() {
        result := DllCall("KERNEL32.dll\GetUserDefaultLCID", "uint")
        return result
    }

    /**
     * Sets the user interface language for the current thread.
     * @remarks
     * When a thread is created, the thread user interface language setting is empty and the user interface for the thread is displayed in the user-selected language. This function enables the application to change the user interface language for the current running thread.
     * 
     * <b>Windows Vista and later:</b> Calling this function and specifying 0 for the language identifier is identical to calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a> with the MUI_CONSOLE_FILTER flag set. If the application specifies a valid nonzero language identifier, the function sets a particular user interface language for the thread. After specifying 0 for the language identifier, the application cannot use any of the following constants to correspond to a language identifier:
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * <b>Windows XP:</b> When the application calls this function with a language identifier of 0, the function first verifies that the current user interface does not require Uniscribe, and that it is supported by the console <a href="https://docs.microsoft.com/windows/desktop/Intl/code-pages">code page</a>. If the user interface passes these tests, the function uses the supplied value. If not, the function changes the thread user interface language to a language that the Windows console can display. Windows XP does not support a concept of thread user interface language separate from thread locale. Therefore, this function changes the thread locale on Windows XP. It is easy for your application to set a thread to use the most appropriate language for console display, based on user and system preferred UI languages, the language for non-Unicode applications, and the capabilities of the console.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.UInt16 SetThreadUILanguage(
     *             System.UInt16 LangId
     *             );
     * 
     * ```
     * @param {Integer} LangId <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language identifier</a> for the user interface language for the thread.
     * 
     * <b>Windows Vista and later:</b> The application can specify a language identifier of 0 or a nonzero identifier. For more information, see the Remarks section.
     * 
     * <b>Windows XP:</b> The application can only set this parameter to 0. This setting causes the function to select the language that best supports the console display. For more information, see the Remarks section.
     * @returns {Integer} Returns the input language identifier if successful. If the input identifier is nonzero, the function returns that value. If the language identifier is 0, the function always succeeds and returns the identifier of the language that best supports the Windows console. See the Remarks section.
     * 
     * If the input language identifier is nonzero and the function fails, the return value differs from the input language identifier. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setthreaduilanguage
     * @since windows5.1.2600
     */
    static SetThreadUILanguage(LangId) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetThreadUILanguage", "ushort", LangId, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns the language identifier of the first user interface language for the current thread.
     * @remarks
     * Calling this function is identical to calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> with <i>dwFlags</i> set to MUI_MERGE_SYSTEM_FALLBACK | MUI_MERGE_USER_FALLBACK | MUI_LANGUAGE_ID and using the first language in the retrieved list.
     * 
     * The return value for this function does not provide useful information about a Language Interface Pack (LIP) language if that language corresponds to a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>. For such a language, the function returns the hexadecimal value "1400", which corresponds to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a> if that language is specified in the user preferred UI languages list. If the language is not specified in the user preferred UI languages list, the function returns the value "1000", corresponding to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.UInt16 GetThreadUILanguage();
     * 
     * ```
     * @returns {Integer} Returns the identifier for a language explicitly associated with the thread by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a>. Alternatively, if no language has been explicitly associated with the current thread, the identifier can indicate a user or system user interface language.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getthreaduilanguage
     * @since windows6.0.6000
     */
    static GetThreadUILanguage() {
        result := DllCall("KERNEL32.dll\GetThreadUILanguage", "ushort")
        return result
    }

    /**
     * Retrieves the process preferred UI languages. For more information, see User Interface Language Management.
     * @remarks
     * Depending on the flags specified by the application, this function can retrieve a list consisting of the process preferred UI languages. If it encounters a duplicate language, the function only retrieves the first instance of the duplicated language.
     * 
     * When MUI_LANGUAGE_ID is specified, the language strings retrieved will be hexadecimal language identifiers 
     * 
     * that do not include the leading 0x, and will be 4 characters in length. For example, en-US will be returned 
     * 
     * as "0409" and en as "0009".
     * 
     * <div class="alert"><b>Note</b>  Use of MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID.</div>
     * <div> </div>
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetProcessPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             ref System.UInt32 pulNumLanguages,
     *             System.IntPtr pwszLanguagesBuffer,
     *             ref System.UInt32 pcchLanguagesBuffer
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying the language format to use for the process preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {Pointer<PWSTR>} pwszLanguagesBuffer Optional. Pointer to a double null-terminated multi-string buffer in which the function retrieves an ordered, null-delimited list in preference order, starting with the most preferable. 
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<UInt32>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * If the process preferred UI language list is empty or if the languages specified for the process are not valid, the function succeeds and returns an empty multistring in <i>pwszLanguagesBuffer</i> and 2 in the <i>pcchLanguagesBuffer</i> parameter.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getprocesspreferreduilanguages
     * @since windows6.1
     */
    static GetProcessPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetProcessPreferredUILanguages", "uint", dwFlags, "ptr", pulNumLanguages, "ptr", pwszLanguagesBuffer, "ptr", pcchLanguagesBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the process preferred UI languages for the application process. For more information, see User Interface Language Management.
     * @remarks
     * Ideally, applications will call <b>SetProcessPreferredUILanguages</b> as soon as possible after launching.
     * 
     * After this function returns, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getprocesspreferreduilanguages">GetProcessPreferredUILanguages</a> to verify and examine the resulting language list.
     * 
     * When MUI_LANGUAGE_ID is specified, the input parameter language strings must use hexadecimal language 
     * 
     * identifiers that do not include the leading 0x, and are 4 characters in length. For example, en-US should be 
     * 
     * passed as "0409" and en as "0009".
     * 
     * <div class="alert"><b>Note</b>  Use of MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID.</div>
     * <div> </div>
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean SetProcessPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             System.String pwszLanguagesBuffer,
     *             ref System.UInt32 pulNumLanguages
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying the language format to use for the process preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * We recommend that you use MUI_LANGUAGE_NAME instead of MUI_LANGUAGE_ID.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pwszLanguagesBuffer Pointer to a double null-terminated multi-string buffer that contains an ordered, null-delimited list in decreasing order of preference. If there are more than five languages in the buffer, the function only sets the first five valid languages.
     * 
     * Alternatively, this parameter can contain <b>NULL</b> if no language list is required. In this case, the function clears the preferred UI languages for the process.
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages that has been set in the process language list from the input buffer, up to a maximum of five.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error code:
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. An invalid parameter is specified.</li>
     * </ul>
     * If the process preferred UI languages list is empty or if the languages specified for the process are not valid, the function succeeds and sets 0 in the <i>pulNumLanguages</i> parameter.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setprocesspreferreduilanguages
     * @since windows6.1
     */
    static SetProcessPreferredUILanguages(dwFlags, pwszLanguagesBuffer, pulNumLanguages) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetProcessPreferredUILanguages", "uint", dwFlags, "ptr", pwszLanguagesBuffer, "ptr", pulNumLanguages, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the user preferred UI languages. For more information, see User Interface Language Management.
     * @remarks
     * When MUI_LANGUAGE_ID is specified, the language strings retrieved will be hexadecimal language identifiers that do not include the leading 0x, and will be 4 characters in length. For example, en-US will be returned as "0409" and en as "0009".
     * 
     * The display language cannot include more than one Language Interface Pack (LIP) language that corresponds to a [supplemental locale](/windows/desktop/Intl/custom-locales). If the list includes more than one of these languages, and if the application specifies MUI_LANGUAGE_ID in the call to the function, the language buffer contains "1400" for that language. This string corresponds to the hexadecimal value of [LOCALE_CUSTOM_UI_DEFAULT](/windows/desktop/Intl/locale-custom-constants).
     * 
     * The language list retrieved by this function has the following characteristics:
     * 
     * - Each language represents a valid NLS locale.
     * - Each language is installed on the operating system.
     * - The list contains one entry for each language, with no duplicate entries.
     * - If the list is empty or does not meet these validation criteria, the system preferred UI languages list is used instead.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the language format to use for the display language list. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * | Value | Meaning |
     * | --- | --- |
     * | **MUI_LANGUAGE_ID** | Retrieve the language strings in [language identifier](/windows/desktop/Intl/language-identifiers) |
     * | **MUI_LANGUAGE_NAME** | Retrieve the language strings in [language name](/windows/desktop/Intl/language-names) format. |
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages retrieved in *pwszLanguagesBuffer*.
     * @param {Pointer<PWSTR>} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited display language list, in the format specified by *dwflags*. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to **NULL** and *pcchLanguagesBuffer* is set to 0, the function retrieves the required size of the language buffer in *pcchLanguagesBuffer*. The required size includes the two null characters.
     * @param {Pointer<UInt32>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by *pwszLanguagesBuffer*. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and *pwszLanguagesBuffer* is set to **NULL**, the function retrieves the required size of the language buffer in *pcchLanguagesBuffer*.
     * @returns {Integer} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [GetLastError function](../errhandlingapi/nf-errhandlingapi-getlasterror.md), which can return one of the following error codes:
     * 
     * - ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to **NULL**.
     * 
     * If the function fails for any other reason, the values of *pulNumLanguages* and *pcchLanguagesBuffer* are undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserpreferreduilanguages
     * @since windows6.0.6000
     */
    static GetUserPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUserPreferredUILanguages", "uint", dwFlags, "ptr", pulNumLanguages, "ptr", pwszLanguagesBuffer, "ptr", pcchLanguagesBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the system preferred UI languages. For more information, see User Interface Language Management.
     * @remarks
     * When MUI_LANGUAGE_ID is specified, the language strings retrieved will be hexadecimal language identifiers 
     * 
     * that do not include the leading 0x, and will be 4 characters in length. For example, en-US will be returned 
     * 
     * as "0409" and en as "0009".
     * 
     * The system preferred UI languages cannot include more than one Language Interface Pack (LIP) language that corresponds to a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>. If the list includes more than one of these languages, and if the application specifies MUI_LANGUAGE_ID in the call to the function, the language buffer contains "1400" for that language. This string corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>.
     * 
     * If the MUI_MACHINE_LANGUAGE_SETTINGS flag is set, this function checks each language in the list that represents a valid NLS locale. The retrieved list can contain the following items:
     * 
     * <ul>
     * <li>Languages not installed on the system</li>
     * <li>Duplicate language entries</li>
     * <li>An empty string</li>
     * </ul>
     * If the MUI_MACHINE_LANGUAGE_SETTINGS flag is set and the system preferred UI languages list is empty, the function retrieves an empty string in the language buffer (two null characters, because it is a multistring buffer), 0 for the number of languages, and 2 for the buffer size.
     * 
     * If the MUI_MACHINE_LANGUAGE_SETTINGS flag is not set, the retrieved language list has the following characteristics:
     * 
     * <ul>
     * <li>Each language represents a valid NLS locale.</li>
     * <li>Each language is installed on the operating system.</li>
     * <li>The list contains one entry for each language, with no duplicate entries.</li>
     * </ul>
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetSystemPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             ref System.UInt32 pulNumLanguages,
     *             System.IntPtr pwszLanguagesBuffer,
     *             ref System.UInt32 pcchLanguagesBuffer
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format to use for the system preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following flag specifies whether the function is to validate the list of languages (default) or retrieve the system preferred UI languages list exactly as it is stored in the registry.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MACHINE_LANGUAGE_SETTINGS"></a><a id="mui_machine_language_settings"></a><dl>
     * <dt><b>MUI_MACHINE_LANGUAGE_SETTINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the stored system preferred UI languages list, checking only to ensure that each language name corresponds to a valid NLS locale. If this flag is not set, the function retrieves the system preferred UI languages in <i>pwszLanguagesBuffer</i>, as long as the list is non-empty and meets the validation criteria. Otherwise, the function retrieves the system default user interface language in the language buffer.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {Pointer<PWSTR>} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited system preferred UI languages list, in the format specified by <i>dwFlags</i>. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters
     * @param {Pointer<UInt32>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.
     * </li>
     * </ul>
     * 
     * 
     * If the function fails for any other reason, the parameters <i>pulNumLanguages</i> and <i>pcchLanguagesBuffer</i> are undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystempreferreduilanguages
     * @since windows6.0.6000
     */
    static GetSystemPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetSystemPreferredUILanguages", "uint", dwFlags, "ptr", pulNumLanguages, "ptr", pwszLanguagesBuffer, "ptr", pcchLanguagesBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the thread preferred UI languages for the current thread. For more information, see User Interface Language Management.
     * @remarks
     * Depending on the flags specified by the application, this function can retrieve a composite list consisting of the thread preferred UI languages, process preferred UI languages, user preferred UI languages or system preferred UI languages, and the system default UI language. If it encounters a duplicate language, the function only retrieves the first language.
     * 
     * If the application has called <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a> with the MUI_CONSOLE_FILTER or MUI_COMPLEX_SCRIPT_FILTER flag, <b>GetThreadPreferredUILanguages</b> filters the languages in the result list. The function replaces the languages the console cannot display with a substitute language. The substitution for a language is determined from the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sconsolefallbackname">LOCALE_SCONSOLEFALLBACKNAME</a> for the language. For more console information, see the description of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a>.
     * 
     * Use of MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID because the MUI_LANGUAGE_NAME flag can do a better job of handling Language Interface Pack (LIP) languages that correspond to <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locales</a>.
     * 
     * When MUI_LANGUAGE_ID is specified, the language strings retrieved will be hexadecimal language identifiers 
     * 
     * that do not include the leading 0x, and will be 4 characters in length. For example, en-US will be returned 
     * 
     * as "0409" and en as "0009".
     * 
     * If the application sets the MUI_LANGUAGE_ID flag, the thread preferred UI languages can include one or more languages that correspond to supplemental locales. On successful return from the function, the language buffer contains "1400" for any language corresponding to a supplemental locale. There can be only one such language in this list. The string "1400" corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>. Also on successful return from the function, the <i>pwszLanguagesBuffer</i> contains "1000" for any other language that corresponds to a supplemental locale. The string "1000" corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>, which is not useful as an input to any function, because it cannot distinguish among supplemental locales.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetThreadPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             ref System.UInt32 pulNumLanguages,
     *             System.IntPtr pwszLanguagesBuffer,
     *             ref System.UInt32 pcchLanguagesBuffer
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the language format to use for the thread preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following flags specify filtering for the function to use in retrieving the thread preferred UI languages. The default flag is MUI_MERGE_USER_FALLBACK.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MERGE_SYSTEM_FALLBACK"></a><a id="mui_merge_system_fallback"></a><dl>
     * <dt><b>MUI_MERGE_SYSTEM_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system fallback to retrieve a list that corresponds exactly to the language list used by the resource loader. This flag can be used only in combination with MUI_MERGE_USER_FALLBACK. Using the flags in combination alters the usual effect of MUI_MERGE_USER_FALLBACK by including fallback and neutral languages in the list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MERGE_USER_FALLBACK"></a><a id="mui_merge_user_fallback"></a><dl>
     * <dt><b>MUI_MERGE_USER_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve a composite list consisting of the thread preferred UI languages, followed by process preferred UI languages, followed by any user preferred UI languages that are distinct from these, followed by the system default UI language, if it is not already in the list. If the user preferred UI languages list is empty, the function retrieves the system preferred UI languages. This flag cannot be combined with MUI_THREAD_LANGUAGES.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_THREAD_LANGUAGES"></a><a id="mui_thread_languages"></a><dl>
     * <dt><b>MUI_THREAD_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the thread preferred UI languages for the current thread, or an empty list if no preferred languages are set for the current thread. This flag cannot be combined with MUI_MERGE_USER_FALLBACK or MUI_MERGE_SYSTEM_FALLBACK.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_UI_FALLBACK"></a><a id="mui_ui_fallback"></a><dl>
     * <dt><b>MUI_UI_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve a complete thread preferred UI languages list along with associated fallback and neutral languages. Use of this flag is equivalent to combining MUI_MERGE_SYSTEM_FALLBACK and MUI_MERGE_USER_FALLBACK. (Applicable only for Windows 7 and later).
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {Pointer<PWSTR>} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited thread preferred UI languages list, in the format specified by <i>dwFlags</i>. This list ends with two null characters. 
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<UInt32>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns one of the following error codes:
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * </ul>
     * 
     * 
     * If the function fails for any other reason, the parameters <i>pulNumLanguages</i> and <i>pcchLanguagesBuffer</i> are undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getthreadpreferreduilanguages
     * @since windows6.0.6000
     */
    static GetThreadPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetThreadPreferredUILanguages", "uint", dwFlags, "ptr", pulNumLanguages, "ptr", pwszLanguagesBuffer, "ptr", pcchLanguagesBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the thread preferred UI languages for the current thread. For more information, see User Interface Language Management.
     * @remarks
     * When the application loads resources after a call to this function, the thread-specific preferences take priority over the languages preferred by the user.
     * 
     * This function can set up to five preferred languages for the thread, in order of preference. If the language buffer contains more than five valid languages, the function sets the first five valid languages and ignores the rest.
     * 
     * If the application calls this function with the MUI_LANGUAGE_ID flag set, the strings in the language list must use hexadecimal language 
     * 
     * identifiers that do not include the leading 0x, and are 4 characters in length. For example, en-US should be 
     * 
     * passed as "0409" and en as "0009".
     * 
     * When MUI_LANGUAGE_ID is specified, the hexadecimal values in the language list must each represent an actual language identifier. In particular, the following locale identifier values cannot be used to correspond to the language identifier: 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * Calling this function with an empty language list and setting the MUI_CONSOLE_FILTER flag has the same effect as calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a> with the language identifier set to 0. The language is set appropriately for use in a console window.
     * 
     * After this function returns, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> to verify and examine the resulting language list. When MUI_CONSOLE_FILTER or MUI_COMPLEX_FILTER has been set by <b>SetThreadPreferredUILanguages</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> function replaces with the fallback the languages the console cannot display using the current operating system language setting. The fallback for a language is determined based on the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sconsolefallbackname">LOCALE_SCONSOLEFALLBACKNAME</a> for the language.
     * 
     * Setting the MUI_COMPLEX_SCRIPT_FILTER flag in the call to <b>SetThreadPreferredUILanguages</b> causes <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a>  to remove languages that the console cannot display with languages that can only be rendered using <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe">Uniscribe</a>, and insert the fallback language as the ultimate fallback. Examples of such languages are Arabic or the various Indic languages.
     * 
     * Setting the MUI_CONSOLE_FILTER flag in the call to <b>SetThreadPreferredUILanguages</b> causes <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> to remove languages the console cannot display with the current system setting and insert the fallback language as the ultimate fallback, because the console is limited to displaying characters from a single <a href="https://docs.microsoft.com/windows/desktop/Intl/code-pages">code page</a>. For example, if the user language is Japanese (Japan), but the current console code page is the code page for Russian (Russia), the console displays Japanese-language text mostly as a series of character-not-found symbols. <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> chooses a language from the fallback list that will be legible in the console.
     * 
     * <div class="alert"><b>Note</b>  Resource-loading functions, such as <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadstringa">LoadString</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a>, also make calls to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a>.</div>
     * <div> </div>
     * To change the code page, the application uses the <b>setlocale</b> function, or equivalent.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean SetThreadPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             System.String pwszLanguagesBuffer,
     *             ref System.UInt32 pulNumLanguages
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying format and filtering for the languages to set. 
     * 
     * The following <i>format flags</i> specify the language format to use for the thread preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * We recommend that you use MUI_LANGUAGE_NAME instead of MUI_LANGUAGE_ID.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following <i>filtering flags</i> specify filtering for the language list. The flags are mutually exclusive. By default, neither MUI_COMPLEX_SCRIPT_FILTER nor MUI_CONSOLE_FILTER is set. For more information about the filtering flags, see the Remarks section.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_COMPLEX_SCRIPT_FILTER"></a><a id="mui_complex_script_filter"></a><dl>
     * <dt><b>MUI_COMPLEX_SCRIPT_FILTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> should replace with the appropriate fallback all languages having <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">complex scripts</a>. When this flag is specified, <b>NULL</b> must be passed for all other parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_CONSOLE_FILTER"></a><a id="mui_console_filter"></a><dl>
     * <dt><b>MUI_CONSOLE_FILTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> should replace with the appropriate fallback all languages that cannot display properly in a console window with the current operating system settings. When this flag is specified, <b>NULL</b> must be passed for all other parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_RESET_FILTERS"></a><a id="mui_reset_filters"></a><dl>
     * <dt><b>MUI_RESET_FILTERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reset the filtering for the language list by removing any other filter settings. When this flag is specified, <b>NULL</b> must be passed for all other parameters. After setting this flag, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> to retrieve the complete unfiltered list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pwszLanguagesBuffer Pointer to a double null-terminated multi-string buffer that contains an ordered, null-delimited list, in the format specified by <i>dwFlags</i>.
     * 
     * To clear the thread preferred UI languages list, an application sets this parameter to a null string or an empty double null-terminated string. 
     * If an application clears a language list, it should specify either a format flag or 0 for the <i>dwFlags</i> parameter.
     * 
     * When the application specifies one of the filtering flags, it must set this parameter to <b>NULL</b>. In this case, the function succeeds, but does not reset the thread preferred languages.
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages that the function has set in the thread preferred UI languages list. When the application specifies one of the filtering flags, the function must set this parameter to <b>NULL</b>.
     * @returns {Integer} Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setthreadpreferreduilanguages
     * @since windows6.0.6000
     */
    static SetThreadPreferredUILanguages(dwFlags, pwszLanguagesBuffer, pulNumLanguages) {
        result := DllCall("KERNEL32.dll\SetThreadPreferredUILanguages", "uint", dwFlags, "ptr", pwszLanguagesBuffer, "ptr", pulNumLanguages, "int")
        return result
    }

    /**
     * Retrieves resource-related information about a file.
     * @remarks
     * For the MUI_QUERY_LANGUAGE_NAME flag, this function retrieves an offset, in bytes, from the beginning of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> in the <b>dwLanguageNameOffset</b> member.
     * 
     * The following is sample code that accesses the language name associated with the input file:
     * 
     * 
     * ```cpp
     * LPWSTR lpszLang = reinterpret_cast<LPWSTR>(
     *         reinterpret_cast<BYTE*>(pFileMUIInfo) +
     *         pFileMUIInfo->dwLanguageNameOffset);
     * 
     * ```
     * 
     * 
     * For the MUI_QUERY_RESOURCE_TYPES flag, this function retrieves language-specific resource file information in the following <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> members:
     * 
     * <ul>
     * <li>The <b>dwTypeIDMUIOffset</b> member contains the offset to an array of identifiers of resources contained in the language-specific resource file.</li>
     * <li>The <b>dwTypeIDMUISize</b> member contains the size of the array of resource identifiers for the language-specific resource file.</li>
     * <li>The <b>dwTypeNameMUIOffset</b> member contains the offset to an array of names of resources contained in the language-specific resource file.</li>
     * </ul>
     * If the input file is an LN file, the function fills in all the above structure members. In addition, it fills in the following members:
     * 
     * <ul>
     * <li>The <b>dwTypeIDMainOffset</b> member contains the offset to an array of identifiers of resources contained in the LN file.</li>
     * <li>The <b>dwTypeIDMainSize</b> member contains the size of the array of resource identifiers for the LN file.</li>
     * <li>The <b>dwTypeNameMainOffset</b> member contains the offset to an array of names of resources contained in the file.</li>
     * </ul>
     * The following is sample code that accesses the array of resource identifiers in the LN file.
     * 
     * 
     * ```cpp
     * DWORD *pdwTypeID = reinterpret_cast<DWORD *>(
     *         reinterpret_cast<BYTE*>(pFileMUIInfo) +
     *         pFileMUIInfo->dwTypeIDMainOffset);
     * 
     * ```
     * 
     * 
     * <div class="alert"><b>Note</b>  The lists of language-specific resources are accessed in the same way.</div>
     * <div> </div>
     * The following is sample code to access the multistring array of resource names in the LN file.
     * 
     * 
     * ```cpp
     * LPWSTR lpszNames = reinterpret_cast<LPWSTR>(
     *         reinterpret_cast<BYTE*>(pFileMUIInfo) +
     *         pFileMUIInfo->dwTypeNameMainOffset);
     * 
     * ```
     * 
     * 
     * <div class="alert"><b>Note</b>  The lists of language-specific resources are accessed in the same way.</div>
     * <div> </div>
     * Each of the code samples uses two reinterpret casts. First the code casts to BYTE* so that the pointer arithmetic for the offset is done in bytes. Then the code casts the resulting pointer to the desired type.
     * 
     * Another approach is to write the following instead of the code shown in the samples. The effect is the same and the choice is strictly one of style.
     * 
     * 
     * ```cpp
     * DWORD ix = pFileMUIInfo->dwLanguageNameOffset - 
     *         offsetof(struct _FILEMUIINFO, abBuffer);
     * LPWSTR lpszLang = reinterpret_cast<LPWSTR>(&(pFileMUIInfo->abBuffer[ix]));
     * 
     * ```
     * 
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetFileMUIInfo(
     *             System.UInt32 dwFlags,
     *             System.String pcwszFilePath,
     *             ref FILEMUIINFO pFileMUIInfo,
     *             ref System.UInt32 pcbFileMUIInfo
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags specifying the information to retrieve. Any combination of the following flags is allowed. The default value of the flags is MUI_QUERY_TYPE | MUI_QUERY_CHECKSUM.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_QUERY_TYPE"></a><a id="mui_query_type"></a><dl>
     * <dt><b>MUI_QUERY_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * @param {Pointer<PWSTR>} pcwszFilePath Pointer to a null-terminated string indicating the path to the file. Typically the file is either an LN file or a language-specific resource file. If it is not one of these types, the only significant value that the function retrieves is MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL. The function only retrieves this value if the MUI_QUERY_RESOURCE_TYPES flag is set.
     * @param {Pointer<FILEMUIINFO>} pFileMUIInfo Pointer to a buffer containing file information in a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure and possibly in data following that structure. The information buffer might have to be much larger than the size of the structure itself. Depending on flag settings, the function can store considerable information following the structure, at offsets retrieved in the structure. For more information, see the Remarks section.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if <i>pcbFileMUIInfo</i> is set to 0. In this case, the function retrieves the required size for the information buffer in <i>pcbFileMUIInfo</i>.
     * 
     * <div class="alert"><b>Note</b>  If the value of <i>pFileMUIInfo</i> is not <b>NULL</b>, the <b>dwSize</b> member must be set to the size of the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure (including the information buffer), and the <b>dwVersion</b> member must be set to the current version of 0x001.</div>
     * <div> </div>
     * @param {Pointer<UInt32>} pcbFileMUIInfo Pointer to the buffer size, in bytes, for the file information indicated by <i>pFileMUIInfo</i>. On successful return from the function, this parameter contains the size of the retrieved file information buffer and the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure that contains it.
     * 
     * Alternatively, the application can set this parameter to 0 if it sets <b>NULL</b> in <i>pFileMUIInfo</i>. In this case, the function retrieves the required file information buffer size in <i>pcbFileMUIInfo</i>. To allocate the correct amount of memory, this value should be added to the size of the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure itself.
     * 
     * <div class="alert"><b>Note</b>  The value of this parameter must match the value of the <b>dwSize</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> if the value of <i>pFileMUIInfo</i> is not <b>NULL</b>.</div>
     * <div> </div>
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getfilemuiinfo
     * @since windows6.0.6000
     */
    static GetFileMUIInfo(dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileMUIInfo", "uint", dwFlags, "ptr", pcwszFilePath, "ptr", pFileMUIInfo, "ptr", pcbFileMUIInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to all language-specific resource files associated with the supplied LN file. The application must call this function repeatedly to get the path for each resource file.
     * @remarks
     * This function verifies that language-specific resource files exist, but it does not verify that they are correct. It requires the resource files to be stored according to the storage convention explained in <a href="https://docs.microsoft.com/windows/desktop/Intl/application-deployment">Application Deployment</a>.
     * 
     * If the call to this function specifies the MUI_LANGUAGE_ID flag, the supplied language string must 
     * 
     * use a hexadecimal language identifier that does not include the leading 0x, and is 4 characters in length. 
     * 
     * For example, en-US should be passed as "0409" and en as "0009". The returned language string will be in the 
     * 
     * same format.
     * 
     * When MUI_LANGUAGE_ID is specified, each hexadecimal value in the supplied language string must represent an actual language identifier. In particular, the values corresponding to the following locales cannot be specified: 
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * To receive enumerated information, the application should call this function repeatedly until it returns <b>FALSE</b>, leaving the contents of <i>pululEnumerator</i> unchanged between calls. Since each call retrieves the path to a different language-specific resource file, the application must clear the language buffer to an empty string between calls. If the application does not do this, the input value of <i>pwszLanguage</i> takes precedence over the setting of <i>dwFlags</i>.
     * 
     * Typically the resource loader is used to find resource files. However, your application can also use this function to find the files. If the input file path is for an LN file, the function attaches a suffix of ".mui" when looking for the corresponding language-specific resource files.
     * 
     * For example, the function retrieves the following files when the application passes the string "C:\mydir\Example1.dll" in <i>pcwszFilePath</i> as the root file path, with <i>dwFlags</i> set to MUI_LANGUAGE_NAME | MUI_USE_SEARCH_ALL_LANGUAGES:
     * 
     * <ul>
     * <li>C:\mydir\Example1.dll<ul>
     * <li>C:\mydir\en-US\Example1.dll.mui</li>
     * <li>C:\mydir\ja-JP\Example1.dll.mui</li>
     * </ul>
     * </li>
     * </ul>
     * The first call to the function sets <i>pwszFileMUIPath</i>  to "C:\mydir\en-US\Example1.dll.mui". The second call sets the file path to "C:\mydir\ja-JP\Example1.dll.mui". The function returns <b>FALSE</b> when called a third time and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_MORE_FILES.
     * 
     * If the file indicated by <i>pcwszFilePath</i> does not have resource configuration data, or if the file does not exist, the function leaves the file name as it is when looking for the corresponding language-specific resource files.
     * 
     * For example, the application passes the string "C:\mydir\Example2.txt" in <i>pcwszFilePath</i> as the root file path, with <i>dwFlags</i> set to MUI_LANGUAGE_NAME | MUI_USER_PREFERRED_UI_LANGUAGES. Let's consider the case in which the user preferred UI languages (in order) are Catalan, "ca-ES", and Spanish (Spain), "es-ES", and where the following files exist:
     * 
     * <ul>
     * <li>(no corresponding file in C:\mydir)
     *             <ul>
     * <li>C:\mydir\en-US\Example2.txt</li>
     * <li>C:\mydir\en\Example2.txt</li>
     * <li>C:\mydir\es-ES\Example2.txt</li>
     * <li>C:\mydir\es\Example2.txt</li>
     * <li>C:\mydir\ja-JP\Example2.txt</li>
     * </ul>
     * </li>
     * </ul>
     * The first call to the function determines that there are no resources for "ca-ES" or for the neutral language "ca". The function then tries the next option, "es-ES", for which it succeeds in finding a match. Before returning, the function sets <i>pwszFileMUIPath</i>  to "C:\mydir\es-ES\Example2.txt". A second application call to the function continues the enumeration by setting <i>pwszFileMUIPath</i> to "C:\mydir\es\Example2.txt".
     * 
     * If the target file and its associated resource files are actually <a href="https://docs.microsoft.com/windows/desktop/SbsCs/isolated-applications-and-side-by-side-assemblies-portal">Side-by-side enabled assemblies</a>, GetFileMUIPath cannot be used to retrieve the path to the resource file. Please refer to <a href="https://docs.microsoft.com/windows/desktop/SbsCs/using-assemblies-with-a-multilanguage-user-interface">Using Assemblies with a Multilanguage User Interface</a> for details on how to use Side-by-side assemblies with MUI support.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetFileMUIPath(
     *             System.UInt32 dwFlags,
     *             System.String pcwszFilePath,
     *             System.Text.StringBuilder pwszLanguage,
     *             ref System.UInt32 pcchLanguage,
     *             System.Text.StringBuilder pwszFileMUIPath,
     *             ref System.UInt32 pcchFileMUIPath,
     *             ref System.UInt64 pululEnumerator
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language indicated by <i>pwszLanguage</i>. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language string in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language string in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following flags specify the filtering for the function to use in locating language-specific resource files if <i>pwszLanguage</i> is set to <b>NULL</b>. The filtering flags are mutually exclusive, and the default is MUI_USER_PREFERRED_UI_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USE_SEARCH_ALL_LANGUAGES"></a><a id="mui_use_search_all_languages"></a><dl>
     * <dt><b>MUI_USE_SEARCH_ALL_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve all language-specific resource files for the path indicated by <i>pcwszFilePath</i>, without considering file licensing. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USER_PREFERRED_UI_LANGUAGES"></a><a id="mui_user_preferred_ui_languages"></a><dl>
     * <dt><b>MUI_USER_PREFERRED_UI_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the files that implement languages in the fallback list. Successive calls enumerate the successive fallbacks, in the appropriate order. The first file indicated by the output value of <i>pcchFileMUIPath</i> should be the best fit. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USE_INSTALLED_LANGUAGES"></a><a id="mui_use_installed_languages"></a><dl>
     * <dt><b>MUI_USE_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the files for the languages installed on the computer. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following flags allow the user to indicate the type of file that is specified by <i>pcwszFilePath</i> so that the function can determine if it must add ".mui" to the file name. The flags are mutually exclusive. If the application passes both flags, the function fails. If the application passes neither flag, the function checks the file in the root folder to verify the file type and decide on file naming.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANG_NEUTRAL_PE_FILE"></a><a id="mui_lang_neutral_pe_file"></a><dl>
     * <dt><b>MUI_LANG_NEUTRAL_PE_FILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not verify the file passed in <i>pcwszFilePath</i> and append ".mui" to the file name before processing. For example, change Abc.exe to Abc.exe.mui.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_NON_LANG_NEUTRAL_FILE"></a><a id="mui_non_lang_neutral_file"></a><dl>
     * <dt><b>MUI_NON_LANG_NEUTRAL_FILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not verify the file passed in <i>pcwszFilePath</i> and do not append ".mui" to the file name before processing. For example, use Abc.txt or Abc.chm.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pcwszFilePath Pointer to a null-terminated string specifying a file path. The path is either for an existing LN file or for a file such as a .txt, .inf, or .msc file. If the file is an LN file, the function looks for files containing the associated language-specific resources. For all other types of files, the function seeks files that correspond exactly to the file name and path indicated. Your application can overwrite the behavior of the file type check by using the MUI_LANG_NEUTRAL_PE_FILE or MUI_NON_LANG_NEUTRAL_FILE flag. For more information, see the Remarks section.
     * 
     * <div class="alert"><b>Note</b>  The supplied file path can be a network path: for example, "\\machinename\c$\windows\system32\notepad.exe".</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} pwszLanguage Pointer to a buffer containing a language string. On input, this buffer contains the language identifier or language name for which the application should find language-specific resource files, depending on the settings of <i>dwFlags</i>. On successful return from the function, this parameter contains the language of the language-specific resource file that the function has found.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b>, with the value referenced by  <i>pcchLanguage</i> set to 0. In this case, the function retrieves the required buffer size in <i>pcchLanguage</i>.
     * @param {Pointer<UInt32>} pcchLanguage Pointer to the buffer size, in characters, for the language string indicated by <i>pwszLanguage</i>. If the application sets the value referenced by this parameter to 0 and  passes <b>NULL</b> for <i>pwszLanguage</i>, then the required buffer size will be returned in <i>pcchLanguage</i> and the returned buffer size is always <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>, because the function is typically called multiple times in succession. The function cannot determine the exact size of the language name for all successive calls, and cannot extend the buffer on subsequent calls. Thus LOCALE_NAME_MAX_LENGTH is the only safe maximum.
     * @param {Pointer<PWSTR>} pwszFileMUIPath Pointer to a buffer containing the path to the language-specific resource file. It is strongly recommended to allocate this buffer to be of size MAX_PATH.
     * 
     * Alternatively, this parameter can retrieve <b>NULL</b> if the value referenced by <i>pcchFileMUIPath</i> is set to 0. In this case, the function retrieves the required size for the file path buffer in <i>pcchFileMUIPath</i>.
     * @param {Pointer<UInt32>} pcchFileMUIPath Pointer to the buffer size, in characters, for the file path indicated by <i>pwszFileMUIPath</i>. On successful return from the function, this parameter indicates the size of the retrieved file path. If the application sets the value referenced by this parameter to 0, the function retrieves <b>NULL</b> for <i>pwszFileMUIPath</i>, the required buffer size will be returned in <i>pcchFileMUIPath</i> and the returned buffer size is always MAX_PATH, because the function is typically called multiple times in succession. The function cannot determine the exact size of the path for all successive calls, and cannot extend the buffer on subsequent calls. Thus MAX_PATH is the only safe maximum.
     * @param {Pointer<UInt64>} pululEnumerator Pointer to an enumeration variable. The first time this function is called, the value of the variable should be 0. Between subsequent calls, the application should not change the value of this parameter. After the function retrieves all possible language-specific resource file paths, it returns <b>FALSE</b>.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. If the function fails, the output parameters do not change.
     * 
     * To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_NO_MORE_FILES. There were no more files to process.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getfilemuipath
     * @since windows6.0.6000
     */
    static GetFileMUIPath(dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileMUIPath", "uint", dwFlags, "ptr", pcwszFilePath, "ptr", pwszLanguage, "ptr", pcchLanguage, "ptr", pwszFileMUIPath, "ptr", pcchFileMUIPath, "ptr", pululEnumerator, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a variety of information about an installed UI language
     * @remarks
     * MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID because it allows the function to do a better job of handling LIP languages that do not correspond to predefined locales, but instead correspond to a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>. LIP languages that correspond to predefined locales are handled just like non-LIP languages.
     * 
     * If the MUI_LANGUAGE_ID flag is specified, the supplied language strings must 
     * 
     * use hexadecimal language identifiers that do not include the leading 0x, and are 4 characters in length. 
     * 
     * For example, en-US should be passed as "0409" and en as "0009". The returned language strings will be in the 
     * 
     * same format.
     * 
     * When MUI_LANGUAGE_ID is specified, and if there is such a language in the user preferred UI languages list, there can be only one such language in the list. That language can be specified in <i>pwmszLanguage</i> as "1400", which corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>. No other such language can be specified using MUI_LANGUAGE_ID. Using "1000", which corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>, in the string indicated by <i>pwmszLanguage</i> will result in an ERROR_INVALID_PARAMETER code.
     * 
     * A partially localized language can have a fallback language that is partially localized, requiring repeated calls to <b>GetUILanguageInfo</b> to obtain full information. Consider the case of a partially localized language Lang1 that offers a choice of three fallback languages. The Lang3 fallback language is partially localized, and offers a choice of two fallback languages. The dependencies are as follows, with the default fallback listed first:
     * 
     * <ul>
     * <li>Lang1<ul>
     * <li>Lang2</li>
     * <li>Lang3<ul>
     * <li>Lang5</li>
     * <li>Lang6</li>
     * </ul>
     * </li>
     * <li>Lang4</li>
     * </ul>
     * </li>
     * </ul>
     * To get the fallback language(s) of Lang1, the application passes in <i>pwmszLanguage</i> as "Lang1\0\0". On return from the function, <i>pwszFallbackLanguages</i> is set to "Lang2\0Lang3\0Lang4\0\0". Note that the ordering of this list indicates that Lang2 is the default fallback language.
     * 
     * To get the fallback language(s) of Lang3 in relation to Lang1, the application passes in <i>pwmszLanguage</i> as "lang1\0\lang3\0\0". On return from the function, <i>pwszFallbackLanguages</i> is set to "Lang5\0Lang6\0\0".
     * 
     * This function returns ERROR_INVALID_PARAMETER for any of the following:
     * 
     * <ul>
     * <li><i>pwmszLanguage</i> is <b>NULL</b> or empty.</li>
     * <li>Both MUI_LANGUAGE_ID and MUI_LANGUAGE_NAME are set.</li>
     * <li>Any flags other than MUI_LANGUAGE_ID or MUI_LANGUAGE_NAME are set.</li>
     * <li><i>pcchFallbackLanguages</i> is greater than 0 but <i>pwszFallbackLanguages</i> is <b>NULL</b>.</li>
     * <li><i>pwmszLanguage</i> cannot be parsed as a multi-string buffer of language identifiers or language names, depending on the flag setting.</li>
     * </ul>
     * The ERROR_OBJECT_NAME_NOT_FOUND error code occurs if <i>pwmszLanguage</i> can be parsed, but is not valid. The code might also be returned for an invalid locale identifier, or if the first language in the input list is not an installed language, or if a fully localized language has defined a fallback language.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetUILanguageInfo(
     *             System.UInt32 dwFlags,
     *             System.String pwmszLanguage,
     *             System.IntPtr pwszFallbackLanguages,
     *             ref System.UInt32 pcchFallbackLanguages,
     *             ref System.UInt32 pdwAttributes
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags defining the format of the specified language. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pwmszLanguage Pointer to languages for which the function is to retrieve information. This parameter indicates an ordered, null-delimited list of language identifiers or language names, depending on the flag setting. For information on the use of this parameter, see the Remarks section.
     * @param {Pointer<PWSTR>} pwszFallbackLanguages Pointer to a buffer in which this function retrieves an ordered, null-delimited list of fallback languages, formatted as defined by the setting for <i>dwFlags</i>. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<UInt32>} pcchFallbackLanguages Pointer to the size, in characters, for the language buffer indicated by <i>pwszFallbackLanguages</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer </i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @param {Pointer<UInt32>} pAttributes Pointer to flags indicating attributes of the input language list. The function always retrieves the flag characterizing the last language listed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_FULL_LANGUAGE"></a><a id="mui_full_language"></a><dl>
     * <dt><b>MUI_FULL_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is fully localized.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_PARTIAL_LANGUAGE"></a><a id="mui_partial_language"></a><dl>
     * <dt><b>MUI_PARTIAL_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is partially localized.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LIP_LANGUAGE"></a><a id="mui_lip_language"></a><dl>
     * <dt><b>MUI_LIP_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is an LIP language.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * In addition, <i>pdwAttributes</i> includes one or both of the following flags, as appropriate.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_INSTALLED"></a><a id="mui_language_installed"></a><dl>
     * <dt><b>MUI_LANGUAGE_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is installed on this computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_LICENSED"></a><a id="mui_language_licensed"></a><dl>
     * <dt><b>MUI_LANGUAGE_LICENSED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is appropriately licensed for the current user.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. For more information, see Remarks.</li>
     * <li>ERROR_OBJECT_NAME_NOT_FOUND. The specified object name was not found, or it was not valid, or the first language in the input list is not an installed language. For more information, see Remarks.
     * </li>
     * </ul>
     * If <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns any other error code, the parameters <i>pcchFallbackLanguages</i> and <i>pdwAttributes</i> are undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuilanguageinfo
     * @since windows6.0.6000
     */
    static GetUILanguageInfo(dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUILanguageInfo", "uint", dwFlags, "ptr", pwmszLanguage, "ptr", pwszFallbackLanguages, "ptr", pcchFallbackLanguages, "ptr", pAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Integer} flags 
     * @param {Pointer<PWSTR>} languages 
     * @param {Pointer<UInt32>} numLanguagesSet 
     * @param {Pointer<HSAVEDUILANGUAGES>} snapshot 
     * @returns {Integer} 
     */
    static SetThreadPreferredUILanguages2(flags, languages, numLanguagesSet, snapshot) {
        result := DllCall("KERNEL32.dll\SetThreadPreferredUILanguages2", "uint", flags, "ptr", languages, "ptr", numLanguagesSet, "ptr", snapshot, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<HSAVEDUILANGUAGES>} snapshot 
     * @returns {String} Nothing - always returns an empty string
     */
    static RestoreThreadPreferredUILanguages(snapshot) {
        DllCall("KERNEL32.dll\RestoreThreadPreferredUILanguages", "ptr", snapshot)
    }

    /**
     * Unsupported. NotifyUILanguageChange may be altered or unavailable.
     * @remarks
     * <b>NotifyUILanguageChange</b> is not supported and may be altered or unavailable in the future.
     * @param {Integer} dwFlags Reserved.
     * @param {Pointer<PWSTR>} pcwstrNewLanguage The new language.
     * @param {Pointer<PWSTR>} pcwstrPreviousLanguage The previous language.
     * @param {Pointer<UInt32>} pdwStatusRtrn A pointer to a <b>DWORD</b> return status.
     * @returns {Integer} A <b>BOOL</b> datatype.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-notifyuilanguagechange
     * @since windows6.1
     */
    static NotifyUILanguageChange(dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, pdwStatusRtrn) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("KERNEL32.dll\NotifyUILanguageChange", "uint", dwFlags, "ptr", pcwstrNewLanguage, "ptr", pcwstrPreviousLanguage, "uint", dwReserved, "ptr", pdwStatusRtrn, "int")
        return result
    }

    /**
     * Retrieves character type information for the characters in the specified source string.
     * @remarks
     * For an overview of the use of the string functions, see <a href="https://docs.microsoft.com/windows/desktop/menurc/strings">Strings</a>.
     * 
     * Using the ANSI code page for the supplied locale, this function translates the source string from ANSI to Unicode. It then analyzes each Unicode character for character type information.
     * 
     * The ANSI version of this function converts the source string to Unicode and calls the 
     * corresponding <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a> function. Thus the words in the output buffer correspond not to the original ANSI string but to its Unicode equivalent. The conversion from ANSI to Unicode can result in a change in string length, for example, a pair of ANSI characters can map to a single 
     * Unicode character. Therefore, the correspondence between the words in the output buffer and the characters in the original ANSI string is not one-to-one in all cases, for example, multibyte strings. Thus, the ANSI version of this function is of limited use for multi-character strings. The Unicode version of the function is recommended instead.
     * 
     * This function circumvents a limitation caused by the difference in parameters between <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringtypea">GetStringTypeA</a> and <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a <b>GetStringType*</b> function through the use of the #define UNICODE switch. On the other hand, <b>GetStringTypeEx</b>, behaves properly with regard to that switch. Thus it is the recommended function.
     * 
     *     
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * The values of the <i>lpSrcStr</i> and <i>lpCharType</i> parameters must not be the same. If they are the same, the function fails with <b>ERROR_INVALID_PARAMETER</b>.
     * 
     * The <i>Locale</i> parameter is only used to perform string conversion to Unicode. It has nothing to do with the CTYPE* values supplied by the application. These values are solely determined by Unicode code points, and do not vary on a locale basis. For example, Greek letters are specified as C1_ALPHA for any value of <i>Locale</i>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. This value uniquely defines the ANSI code page. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.
     * @param {Pointer<PSTR>} lpSrcStr Pointer to the string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. The size refers to bytes for the ANSI version of the function or wide characters for the Unicode version. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<UInt16>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li><b>ERROR_INVALID_FLAGS</b>. The values supplied for flags were not valid.</li>
     * <li><b>ERROR_INVALID_PARAMETER</b>. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw
     */
    static GetStringTypeExA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        result := DllCall("KERNEL32.dll\GetStringTypeExA", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpCharType, "int")
        return result
    }

    /**
     * Deprecated. (GetStringTypeA)
     * @remarks
     * For an overview of the use of the string functions, see <a href="https://docs.microsoft.com/windows/desktop/menurc/strings">Strings</a>.
     * 
     * This function converts the source string to Unicode and calls the 
     * corresponding <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a> function. Thus the words in the output buffer correspond not to the original ANSI string but to its Unicode equivalent. The conversion from ANSI to Unicode can result in a change in string length, for example, a pair of ANSI characters can map to a single 
     * Unicode character. Therefore, the correspondence between the words in the output buffer and the characters in the original ANSI string is not one-to-one in all cases, for example, multibyte strings. Thus <b>GetStringTypeA</b> is of limited use for multi-character strings. [GetStringTypeW function](../stringapiset/nf-stringapiset-getstringtypew.md) and [GetStringTypeEx](../stringapiset/nf-stringapiset-getstringtypeexw.md) are recommended instead.
     * 
     * 			 
     * When this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * The values of the <i>lpSrcStr</i> and <i>lpCharType</i> parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER.
     * 
     * The <i>Locale</i> parameter is only used to perform string conversion to Unicode. It has nothing to do with the CTYPE* values supplied by the application. These values are solely determined by Unicode code points, and do not vary on a locale basis. For example, Greek letters are specified as C1_ALPHA for any value of <i>Locale</i>.
     * 
     * The <i>Locale</i> parameter is not used by the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a> function. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a <b>GetStringType*</b> function through the use of the #define UNICODE switch. An application can circumvent this limitation by using <a href="https://docs.microsoft.com/previous-versions/ms960831(v%3dmsdn.10)">GetStringTypeEx</a>, which is the recommended function.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>Windows Vista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.
     * @param {Pointer<PSTR>} lpSrcStr Pointer to the ANSI string for which to retrieve the character types. The string can be a double-byte character set (DBCS) string if the supplied locale is appropriate for DBCS. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<UInt16>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getstringtypea
     * @since windows5.0
     */
    static GetStringTypeA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeA", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpCharType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Maps one Unicode string to another, performing the specified transformation. (FoldStringA)
     * @remarks
     * The values of the <i>lpSrcStr</i> and  and <i>lpDestStr</i> parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER.
     * 
     * The compatibility zone in Unicode consists of characters in the range 0xF900 through 0xFFEF that are assigned to characters from other encoding standards for characters but are actually variants of characters already in Unicode. The compatibility zone is used to support round-trip mapping to these standards. Applications can use the MAP_FOLDCZONE flag to avoid supporting the duplication of characters in the compatibility zone.
     * 
     * <b>Starting with Windows Vista:</b> This function supports Unicode normalization. All Unicode compatibility characters are mapped.
     * 
     * <b>Starting with Windows Vista:</b> The transformations indicated by the MAP_FOLDCZONE, MAP_PRECOMPOSED, and MAP_COMPOSITE flags use Unicode normalization forms KC, C, and D (through the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a> function) to do the mappings.
     * 
     * <b>Starting with Windows 8: </b>The ANSI version of the function is declared in Winnls.h and the Unicode version is declared in Stringapiset.h. Before Windows 8, both versions were declared in Winnls.h.
     * @param {Integer} dwMapFlags 
     * @param {Pointer<PSTR>} lpSrcStr Pointer to a source string that the function maps.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>, excluding the terminating null character. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, the function calculates the string length automatically, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * @param {Pointer<PSTR>} lpDestStr Pointer to a buffer in which this function retrieves the mapped string.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string. If the MAP_FOLDDIGITS flag is specified, the return value is the maximum size required, even if the actual number of characters needed is smaller than the maximum size. If the maximum size is not passed, the function fails with ERROR_INSUFFICIENT_BUFFER.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-foldstringa
     * @since windows5.0
     */
    static FoldStringA(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        A_LastError := 0

        DllCall("KERNEL32.dll\FoldStringA", "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.Note  For interoperability reasons, the application should prefer the EnumSystemLocalesEx function to EnumSystemLocales because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that will be run only on Windows Vista and later should use EnumSystemLocalesEx. (ANSI)
     * @remarks
     * The function enumerates locales by passing locale identifiers, one at a time, to the specified application-defined callback function. This continues until all of the installed or supported locale identifiers have been passed to the callback function or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemLocales as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LOCALE_ENUMPROCA>} lpLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317822(v=vs.85)">EnumLocalesProc</a>.
     * @param {Integer} dwFlags Flags specifying the locale identifiers to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LCID_SUPPORTED.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_INSTALLED"></a><a id="lcid_installed"></a><dl>
     * <dt><b>LCID_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only installed locale identifiers. This value cannot be used with LCID_SUPPORTED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_SUPPORTED"></a><a id="lcid_supported"></a><dl>
     * <dt><b>LCID_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all supported locale identifiers. This value cannot be used with LCID_INSTALLED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_ALTERNATE_SORTS"></a><a id="lcid_alternate_sorts"></a><dl>
     * <dt><b>LCID_ALTERNATE_SORTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only the alternate sort locale identifiers. If this value is used with either LCID_INSTALLED or LCID_SUPPORTED, the installed or supported locales are retrieved, as well as the alternate sort locale identifiers.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlocalesa
     * @since windows5.0
     */
    static EnumSystemLocalesA(lpLocaleEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesA", "ptr", lpLocaleEnumProc, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.Note  For interoperability reasons, the application should prefer the EnumSystemLocalesEx function to EnumSystemLocales because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that will be run only on Windows Vista and later should use EnumSystemLocalesEx. (Unicode)
     * @remarks
     * The function enumerates locales by passing locale identifiers, one at a time, to the specified application-defined callback function. This continues until all of the installed or supported locale identifiers have been passed to the callback function or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemLocales as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LOCALE_ENUMPROCW>} lpLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317822(v=vs.85)">EnumLocalesProc</a>.
     * @param {Integer} dwFlags Flags specifying the locale identifiers to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LCID_SUPPORTED.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_INSTALLED"></a><a id="lcid_installed"></a><dl>
     * <dt><b>LCID_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only installed locale identifiers. This value cannot be used with LCID_SUPPORTED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_SUPPORTED"></a><a id="lcid_supported"></a><dl>
     * <dt><b>LCID_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all supported locale identifiers. This value cannot be used with LCID_INSTALLED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_ALTERNATE_SORTS"></a><a id="lcid_alternate_sorts"></a><dl>
     * <dt><b>LCID_ALTERNATE_SORTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only the alternate sort locale identifiers. If this value is used with either LCID_INSTALLED or LCID_SUPPORTED, the installed or supported locales are retrieved, as well as the alternate sort locale identifiers.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlocalesw
     * @since windows5.0
     */
    static EnumSystemLocalesW(lpLocaleEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesW", "ptr", lpLocaleEnumProc, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the language groups that are either installed on or supported by an operating system. (ANSI)
     * @remarks
     * This function enumerates language groups by passing language group identifiers, one at a time, to the specified application-defined callback function. This process continues until the last language group identifier is found or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemLanguageGroups as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LANGUAGEGROUP_ENUMPROCA>} lpLanguageGroupEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317821(v=vs.85)">EnumLanguageGroupsProc</a>.
     * @param {Integer} dwFlags 
     * @param {Pointer} lParam Application-defined value to pass to the callback function. This parameter can be used in error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlanguagegroupsa
     * @since windows5.0
     */
    static EnumSystemLanguageGroupsA(lpLanguageGroupEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLanguageGroupsA", "ptr", lpLanguageGroupEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the language groups that are either installed on or supported by an operating system. (Unicode)
     * @remarks
     * This function enumerates language groups by passing language group identifiers, one at a time, to the specified application-defined callback function. This process continues until the last language group identifier is found or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemLanguageGroups as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LANGUAGEGROUP_ENUMPROCW>} lpLanguageGroupEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317821(v=vs.85)">EnumLanguageGroupsProc</a>.
     * @param {Integer} dwFlags 
     * @param {Pointer} lParam Application-defined value to pass to the callback function. This parameter can be used in error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlanguagegroupsw
     * @since windows5.0
     */
    static EnumSystemLanguageGroupsW(lpLanguageGroupEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLanguageGroupsW", "ptr", lpLanguageGroupEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales in a specified language group. (ANSI)
     * @remarks
     * This function enumerates locales in the specified language group by passing locale identifiers, one at a time, to the application-defined callback function. This process continues until <b>EnumLanguageGroupLocales</b> finds the last locale identifier or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumLanguageGroupLocales as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LANGGROUPLOCALE_ENUMPROCA>} lpLangGroupLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-langgrouplocale_enumproca">EnumLanguageGroupLocalesProc</a>.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer} lParam An application-defined value to pass to the callback function. This value can be used for error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumlanguagegrouplocalesa
     * @since windows5.0
     */
    static EnumLanguageGroupLocalesA(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumLanguageGroupLocalesA", "ptr", lpLangGroupLocaleEnumProc, "uint", LanguageGroup, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales in a specified language group. (Unicode)
     * @remarks
     * This function enumerates locales in the specified language group by passing locale identifiers, one at a time, to the application-defined callback function. This process continues until <b>EnumLanguageGroupLocales</b> finds the last locale identifier or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumLanguageGroupLocales as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LANGGROUPLOCALE_ENUMPROCW>} lpLangGroupLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-langgrouplocale_enumproca">EnumLanguageGroupLocalesProc</a>.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer} lParam An application-defined value to pass to the callback function. This value can be used for error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumlanguagegrouplocalesw
     * @since windows5.0
     */
    static EnumLanguageGroupLocalesW(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumLanguageGroupLocalesW", "ptr", lpLangGroupLocaleEnumProc, "uint", LanguageGroup, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the user interface languages that are available on the operating system and calls the callback function with every language in the list. (ANSI)
     * @remarks
     * This function enumerates the user interface languages that are available and, depending on the flag specified, licensed for use on the operating system. It passes language identifiers or language names, one at a time, to the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. The <b>EnumUILanguages</b> function continues to pass language identifiers or names to the callback function until the last language is found or the callback function returns <b>FALSE</b>.
     * 
     * For applications that run only on Windows Vista and later, MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID. MUI_LANGUAGE_NAME allows differentiation between languages that are associated with a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>.
     * 
     * If the MUI_LANGUAGE_ID flag is specified in the call to this function, the strings passed to the callback 
     * 
     * function will be hexadecimal language identifiers that do not include the leading 0x, and will be 4 
     * 
     * characters in length. For example, en-US will be passed as "0409" and en as "0009". The value "1000" is passed to the callback function for any language associated with a supplemental locale. This value corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. It does not distinguish among supplemental locales, even if the selected language is in the user preferred UI languages list or the system preferred UI languages list.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean EnumUILanguages(
     *             EnumUILanguagesProc lpUILanguageEnumProc,
     *             System.UInt32 dwFlags,
     *             System.IntPtr lParam
     *             );
     * 
     * ```
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumUILanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UILANGUAGE_ENUMPROCA>} lpUILanguageEnumProc Pointer to an application-defined <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. <b>EnumUILanguages</b> calls this function repeatedly to enumerate the languages in the list.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language to pass to the callback function. The format flags are mutually exclusive, and MUI_LANGUAGE_ID is the default. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following flags specify the filtering for the function to use in enumerating the languages. The filtering flags are mutually exclusive, and the default is MUI_LICENSED_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_ALL_INSTALLED_LANGUAGES"></a><a id="mui_all_installed_languages"></a><dl>
     * <dt><b>MUI_ALL_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages available to the operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LICENSED_LANGUAGES"></a><a id="mui_licensed_languages"></a><dl>
     * <dt><b>MUI_LICENSED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed for use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_GROUP_POLICY"></a><a id="mui_group_policy"></a><dl>
     * <dt><b>MUI_GROUP_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed, and that are allowed by 
     * 
     * the group policy.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <b>Windows Vista and later:</b> The application can set <i>dwFlags</i> to 0, or to one or more of the specified flags. A setting of 0 causes the parameter value to default to MUI_LANGUAGE_ID | MUI_LICENSED_LANGUAGES.
     * 
     * <b>Windows 2000, Windows XP, Windows Server 2003:</b> The application must set <i>dwFlags</i> to 0.
     * @param {Pointer} lParam Application-defined value.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumuilanguagesa
     * @since windows5.0
     */
    static EnumUILanguagesA(lpUILanguageEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumUILanguagesA", "ptr", lpUILanguageEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the user interface languages that are available on the operating system and calls the callback function with every language in the list. (Unicode)
     * @remarks
     * This function enumerates the user interface languages that are available and, depending on the flag specified, licensed for use on the operating system. It passes language identifiers or language names, one at a time, to the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. The <b>EnumUILanguages</b> function continues to pass language identifiers or names to the callback function until the last language is found or the callback function returns <b>FALSE</b>.
     * 
     * For applications that run only on Windows Vista and later, MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID. MUI_LANGUAGE_NAME allows differentiation between languages that are associated with a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>.
     * 
     * If the MUI_LANGUAGE_ID flag is specified in the call to this function, the strings passed to the callback 
     * 
     * function will be hexadecimal language identifiers that do not include the leading 0x, and will be 4 
     * 
     * characters in length. For example, en-US will be passed as "0409" and en as "0009". The value "1000" is passed to the callback function for any language associated with a supplemental locale. This value corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. It does not distinguish among supplemental locales, even if the selected language is in the user preferred UI languages list or the system preferred UI languages list.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean EnumUILanguages(
     *             EnumUILanguagesProc lpUILanguageEnumProc,
     *             System.UInt32 dwFlags,
     *             System.IntPtr lParam
     *             );
     * 
     * ```
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumUILanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UILANGUAGE_ENUMPROCW>} lpUILanguageEnumProc Pointer to an application-defined <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. <b>EnumUILanguages</b> calls this function repeatedly to enumerate the languages in the list.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language to pass to the callback function. The format flags are mutually exclusive, and MUI_LANGUAGE_ID is the default. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following flags specify the filtering for the function to use in enumerating the languages. The filtering flags are mutually exclusive, and the default is MUI_LICENSED_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_ALL_INSTALLED_LANGUAGES"></a><a id="mui_all_installed_languages"></a><dl>
     * <dt><b>MUI_ALL_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages available to the operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LICENSED_LANGUAGES"></a><a id="mui_licensed_languages"></a><dl>
     * <dt><b>MUI_LICENSED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed for use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_GROUP_POLICY"></a><a id="mui_group_policy"></a><dl>
     * <dt><b>MUI_GROUP_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed, and that are allowed by 
     * 
     * the group policy.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <b>Windows Vista and later:</b> The application can set <i>dwFlags</i> to 0, or to one or more of the specified flags. A setting of 0 causes the parameter value to default to MUI_LANGUAGE_ID | MUI_LICENSED_LANGUAGES.
     * 
     * <b>Windows 2000, Windows XP, Windows Server 2003:</b> The application must set <i>dwFlags</i> to 0.
     * @param {Pointer} lParam Application-defined value.
     * @returns {Integer} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumuilanguagesw
     * @since windows5.0
     */
    static EnumUILanguagesW(lpUILanguageEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumUILanguagesW", "ptr", lpUILanguageEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the code pages that are either installed on or supported by an operating system. (ANSI)
     * @remarks
     * This function enumerates the code pages by passing code page identifiers, one at a time, to the specified application-defined callback function. This process continues until all installed or supported code page identifiers have been passed to the callback function, or the callback function returns <b>FALSE</b>.
     * 
     * When an application is using this function to determine an appropriate code page for saving data, it should use Unicode when possible. Other code pages are not as portable as Unicode between vendors or operating systems, due to different implementations of the associated standards.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemCodePages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CODEPAGE_ENUMPROCA>} lpCodePageEnumProc Pointer to an application-defined callback function. The <b>EnumSystemCodePages</b> function enumerates code pages by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317809(v=vs.85)">EnumCodePagesProc</a>.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemcodepagesa
     * @since windows5.0
     */
    static EnumSystemCodePagesA(lpCodePageEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemCodePagesA", "ptr", lpCodePageEnumProc, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the code pages that are either installed on or supported by an operating system. (Unicode)
     * @remarks
     * This function enumerates the code pages by passing code page identifiers, one at a time, to the specified application-defined callback function. This process continues until all installed or supported code page identifiers have been passed to the callback function, or the callback function returns <b>FALSE</b>.
     * 
     * When an application is using this function to determine an appropriate code page for saving data, it should use Unicode when possible. Other code pages are not as portable as Unicode between vendors or operating systems, due to different implementations of the associated standards.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemCodePages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CODEPAGE_ENUMPROCW>} lpCodePageEnumProc Pointer to an application-defined callback function. The <b>EnumSystemCodePages</b> function enumerates code pages by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317809(v=vs.85)">EnumCodePagesProc</a>.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemcodepagesw
     * @since windows5.0
     */
    static EnumSystemCodePagesW(lpCodePageEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemCodePagesW", "ptr", lpCodePageEnumProc, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts an internationalized domain name (IDN) or another internationalized label to a Unicode (wide character) representation of the ASCII string that represents the name in the Punycode transfer encoding syntax.
     * @remarks
     * The function does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should supply -1 for the <i>cchUnicodeChar</i> parameter or explicitly count the terminating null character for the input string.
     * 
     * Note that the function always fails if the input string contains control characters (U+0001 through U+0020) or the "delete" character (U+007F). Since the character U+0000 can appear only as a terminating null character, the function always fails if U+0000 appears anywhere else in the input string.
     * 
     * <b>Windows XP, Windows Server 2003</b>: 
     * 
     * No longer supported.
     * 
     * The required header file and DLL are part of the Microsoft Internationalized Domain Name (IDN) Mitigation APIs, which are no longer available for download.
     * @param {Integer} dwFlags Flags specifying conversion options. The following table lists the possible values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_ALLOW_UNASSIGNED"></a><a id="idn_allow_unassigned"></a><dl>
     * <dt><b>IDN_ALLOW_UNASSIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <div class="alert"><b>Note</b>  An application can set this value if it is just using a query string for normal lookup, as in a compare operation. However, the application should not set this value for a stored string, which is a string being prepared for storage.</div>
     * <div> </div>
     * Allow unassigned code points to be included in the input string. The default is to not allow unassigned code points, and fail with an extended error code of ERROR_INVALID_NAME.
     * 
     * This flag allows the function to process characters that are not currently legal in IDNs, but might be legal in later versions of the IDNA standard. If your application encodes unassigned code points as Punycode, the resulting domain names should be illegal. Security can be compromised if a later version of IDNA makes these names legal or if an application filters out the illegal characters to try to create a legal domain name. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-internationalized-domain-names--idns">Handling Internationalized Domain Names (IDNs)</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_USE_STD3_ASCII_RULES"></a><a id="idn_use_std3_ascii_rules"></a><dl>
     * <dt><b>IDN_USE_STD3_ASCII_RULES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Filter out ASCII characters that are not allowed in STD3 names. The only ASCII characters allowed in the input Unicode string are letters, digits, and the hyphen-minus. The string cannot begin or end with the hyphen-minus. The function fails if the input Unicode string contains ASCII characters, such as "[", "]", or "/", that cannot occur in domain names.<div class="alert"><b>Note</b>  Some local networks can allow some of these characters in computer names.</div>
     * <div> </div>
     * 
     * 
     * The function fails if the input Unicode string contains control characters (U+0001 through U+0020) or the "delete" character (U+007F). In either case, this flag has no effect on the non-ASCII characters that are allowed in the Unicode string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_EMAIL_ADDRESS"></a><a id="idn_email_address"></a><dl>
     * <dt><b>IDN_EMAIL_ADDRESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows 8:</b> Enable EAI algorithmic fallback for the local parts of email addresses (such as <i>&lt;local&gt;</i>@microsoft.com). The default is for this function to fail when an email address has an invalid address or syntax.
     * 
     * An application can set this flag to enable Email Address Internationalization (EAI) to return a discoverable fallback address, if possible. For more information, see the IETF <a href="https://datatracker.ietf.org/wg/eai/charter/">Email Address Internationalization (eai) Charter</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_RAW_PUNYCODE"></a><a id="idn_raw_punycode"></a><dl>
     * <dt><b>IDN_RAW_PUNYCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows 8:</b> Disable the validation and mapping of Punycode.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} lpUnicodeCharStr Pointer to a Unicode string representing an IDN or another internationalized label.
     * @param {Integer} cchUnicodeChar Count of characters in the input Unicode string indicated by <i>lpUnicodeCharStr</i>.
     * @param {Pointer<PWSTR>} lpASCIICharStr Pointer to a buffer that receives a Unicode string consisting only of characters in the ASCII character set. On return from this function, the buffer contains the ASCII string equivalent of the string provided in <i>lpUnicodeCharStr</i> under Punycode. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchASCIIChar</i> is set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchASCIIChar Size of the buffer indicated by <i>lpASCIICharStr</i>. The application can set the parameter to 0 to retrieve <b>NULL</b> in <i>lpASCIICharStr</i>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-idntoascii
     * @since windows6.0.6000
     */
    static IdnToAscii(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar) {
        A_LastError := 0

        DllCall("NORMALIZ.dll\IdnToAscii", "uint", dwFlags, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar, "ptr", lpASCIICharStr, "int", cchASCIIChar)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Converts the Punycode form of an internationalized domain name (IDN) or another internationalized label to the normal Unicode UTF-16 encoding syntax.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {Integer} dwFlags Flags specifying conversion options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {Pointer<PWSTR>} lpASCIICharStr Pointer to a string representing the Punycode encoding of an IDN or another internationalized label. This string must consist only of ASCII characters, and can include Punycode-encoded Unicode. The function decodes Punycode values to their UTF-16 values.
     * @param {Integer} cchASCIIChar Count of characters in the input string indicated by <i>lpASCIICharStr</i>.
     * @param {Pointer<PWSTR>} lpUnicodeCharStr Pointer to a buffer that receives a normal Unicode UTF-16 encoding equivalent to the Punycode value of the input string. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchUnicodeChar</i> set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchUnicodeChar Size, in characters, of the buffer indicated by <i>lpUnicodeCharStr</i>. The application can set the size to 0 to retrieve <b>NULL</b> in <i>lpUnicodeCharStr</i> and have the function return the required buffer size.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-idntounicode
     * @since windows6.0.6000
     */
    static IdnToUnicode(dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar) {
        A_LastError := 0

        DllCall("NORMALIZ.dll\IdnToUnicode", "uint", dwFlags, "ptr", lpASCIICharStr, "int", cchASCIIChar, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Converts an internationalized domain name (IDN) or another internationalized label to the NamePrep form specified by Network Working Group RFC 3491, but does not perform the additional conversion to Punycode.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {Integer} dwFlags Flags specifying conversion options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {Pointer<PWSTR>} lpUnicodeCharStr Pointer to a Unicode string representing an IDN or another internationalized label.
     * @param {Integer} cchUnicodeChar Count of Unicode characters in the input Unicode string indicated by <i>lpUnicodeCharStr</i>.
     * @param {Pointer<PWSTR>} lpNameprepCharStr Pointer to a buffer that receives a version of the input Unicode string converted through NamePrep processing. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchNameprepChar</i> is set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchNameprepChar Size, in characters, of the buffer indicated by <i>lpNameprepCharStr</i>. The application can set the size to 0 to retrieve <b>NULL</b> in <i>lpNameprepCharStr</i> and have the function return the required buffer size.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-idntonameprepunicode
     * @since windows6.0.6000
     */
    static IdnToNameprepUnicode(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar) {
        A_LastError := 0

        DllCall("KERNEL32.dll\IdnToNameprepUnicode", "uint", dwFlags, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar, "ptr", lpNameprepCharStr, "int", cchNameprepChar)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Normalizes characters of a text string according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.
     * @remarks
     * Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules, as described in <a href="https://docs.microsoft.com/windows/desktop/Intl/using-unicode-normalization-to-represent-strings">Using Unicode Normalization to Represent Strings</a>. The Win32 and the .NET Framework currently support normalization forms C, D, KC, and KD, as defined in <a href="https://www.unicode.org/reports/tr15">Unicode Standard Annex #15: Unicode Normalization Forms</a>. Normalized strings are typically evaluated with an ordinal comparison.
     * 
     * The following code demonstrates the use of the buffer length estimate:
     * 
     * 
     * ```cpp
     * const int maxIterations = 10;
     * LPWSTR strResult = NULL;
     * HANDLE hHeap = GetProcessHeap();
     * 
     * int iSizeEstimated = NormalizeString(form, strInput, -1, NULL, 0);
     * for (int i = 0; i < maxIterations; i++)
     * {
     *     if (strResult)
     *         HeapFree(hHeap, 0, strResult);
     *     strResult = (LPWSTR)HeapAlloc(hHeap, 0, iSizeEstimated * sizeof (WCHAR));
     *     iSizeEstimated = NormalizeString(form, strInput, -1, strResult, iSizeEstimated);
     *  
     *     if (iSizeEstimated > 0)
     *         break; // success 
     *  
     *     if (iSizeEstimated <= 0)
     *     {
     *         DWORD dwError = GetLastError();
     *         if (dwError != ERROR_INSUFFICIENT_BUFFER) break; // Real error, not buffer error 
     *  
     *         // New guess is negative of the return value. 
     *         iSizeEstimated = -iSizeEstimated;
     *     }
     * }
     * 
     * ```
     * 
     * <b>Windows XP, Windows Server 2003</b>: 
     * 
     * No longer supported.
     * 
     * The required header file and DLL are part of the Microsoft Internationalized Domain Name (IDN) Mitigation APIs, which are no longer available for download.
     * @param {Integer} NormForm Normalization form to use. <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> specifies the standard Unicode normalization forms.
     * @param {Pointer<PWSTR>} lpSrcString Pointer to the non-normalized source string.
     * @param {Integer} cwSrcLength Length, in characters, of the buffer containing the source string. The application can set this parameter to -1 if the function should assume the string to be null-terminated and calculate the length automatically.
     * @param {Pointer<PWSTR>} lpDstString Pointer to a buffer in which the function retrieves the destination string. Alternatively, this parameter contains <b>NULL</b> if <i>cwDstLength</i> is set to 0.
     * 
     * <div class="alert"><b>Note</b>  The function does not null-terminate the string if the input string length is explicitly specified without a terminating null character. To null-terminate the output string, the application should specify -1 or explicitly count the terminating null character for the input string.</div>
     * <div> </div>
     * @param {Integer} cwDstLength Length, in characters, of the buffer containing the destination string. Alternatively, the application can set this parameter to 0 to request the function to return the required size for the destination buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-normalizestring
     * @since windows6.0.6000
     */
    static NormalizeString(NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength) {
        A_LastError := 0

        DllCall("KERNEL32.dll\NormalizeString", "int", NormForm, "ptr", lpSrcString, "int", cwSrcLength, "ptr", lpDstString, "int", cwDstLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Verifies that a string is normalized according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.
     * @remarks
     * <b>Windows XP, Windows Server 2003</b>: 
     * 
     * No longer supported.
     * 
     * The required header file and DLL are part of the Microsoft Internationalized Domain Name (IDN) Mitigation APIs, which are no longer available for download.
     * @param {Integer} NormForm Normalization form to use. <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> specifies the standard Unicode normalization forms.
     * @param {Pointer<PWSTR>} lpString Pointer to the string to test.
     * @param {Integer} cwLength Length, in characters, of the input string, including a null terminating character. If this value is -1, the function assumes the string to be null-terminated and calculates the length automatically.
     * @returns {Integer} Returns <b>TRUE</b> if the input string is already normalized to the appropriate form, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in string.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * If you need to reliably determine <b>FALSE</b> from an error condition, then it must call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a>(ERROR_SUCCESS).
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isnormalizedstring
     * @since windows6.0.6000
     */
    static IsNormalizedString(NormForm, lpString, cwLength) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsNormalizedString", "int", NormForm, "ptr", lpString, "int", cwLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two enumerated lists of scripts.
     * @remarks
     * This function compares strings, such as "Latn;Cyrl;", that consist of a series of 4-character script names, with each script name followed by a semicolon. It also has a special case to account for the fact that the Latin script is often used in languages and locales for which it is not native.
     * 
     * This function is useful as part of a strategy to mitigate security issues related to <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-internationalized-domain-names--idns">internationalized domain names (IDNs)</a>.
     * 
     * The following are examples of the return of this function and a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> in various scenarios. The last two examples illustrate, respectively, a case in which the test list lacks a terminating semicolon (malformed string) and a case in which the test list is empty.
     * 
     * <table>
     * <tr>
     * <th>Locale string</th>
     * <th>Test string</th>
     * <th><i>dwFlags</i></th>
     * <th>Return value</th>
     * <th><b>GetLastError</b> return</th>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Hani;</td>
     * <td>*</td>
     * <td><b>TRUE</b></td>
     * <td>(unchanged)</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Hani;Latn;</td>
     * <td>0</td>
     * <td><b>FALSE</b></td>
     * <td>ERROR_SUCCESS</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Hani;Latn;</td>
     * <td>VS_ALLOW_LATIN</td>
     * <td><b>TRUE</b></td>
     * <td>(unchanged)</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Cyrl;</td>
     * <td>*</td>
     * <td><b>FALSE</b></td>
     * <td>ERROR_SUCCESS</td>
     * </tr>
     * <tr>
     * <td>Hani;</td>
     * <td>Hani;Hira;Kana;</td>
     * <td>*</td>
     * <td>FALSE</td>
     * <td>ERROR_SUCCESS</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Cyrl</td>
     * <td>*</td>
     * <td><b>FALSE</b></td>
     * <td>ERROR_INVALID_PARAMETER</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td></td>
     * <td>*</td>
     * <td>TRUE</td>
     * <td>(unchanged)</td>
     * </tr>
     * </table>
     *  
     * 
     * * Results are the same whether VS_ALLOW_LATIN is passed in the <i>dwFlags</i> parameter or no flags are supplied.
     * @param {Integer} dwFlags Flags specifying script verification options.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="VS_ALLOW_LATIN"></a><a id="vs_allow_latin"></a><dl>
     * <dt><b>VS_ALLOW_LATIN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow "Latn" (Latin script) in the test list even if it is not in the locale list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} lpLocaleScripts Pointer to the locale list, the enumerated list of scripts for a given locale. This list is typically populated by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> with <i>LCType</i> set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sscripts">LOCALE_SSCRIPTS</a>.
     * @param {Integer} cchLocaleScripts Size, in characters, of the string indicated by <i>lpLocaleScripts</i>. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails.
     * @param {Pointer<PWSTR>} lpTestScripts Pointer to the test list, a second enumerated list of scripts. This list is typically populated by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringscripts">GetStringScripts</a>.
     * @param {Integer} cchTestScripts Size, in characters, of the string indicated by <i>lpTestScripts</i>. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails.
     * @returns {Integer} Returns <b>TRUE</b> if the test list is non-empty and all items in the list are also included in the locale list. The function still returns <b>TRUE</b> if the locale list contains more scripts than the test list, but all the test list scripts must be contained in the locale list. If VS_ALLOW_LATIN is specified in <i>dwFlags</i>, the function behaves as if "Latn;" is always in the locale list.
     * 
     * In all other cases, the function returns <b>FALSE</b>. This return can indicate that the test list contains an item that is not in the locale list, or it can indicate an error. To distinguish between these two cases, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-verifyscripts
     * @since windows6.0.6000
     */
    static VerifyScripts(dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\VerifyScripts", "uint", dwFlags, "ptr", lpLocaleScripts, "int", cchLocaleScripts, "ptr", lpTestScripts, "int", cchTestScripts, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Provides a list of scripts used in the specified Unicode string.
     * @remarks
     * This function is useful as part of a strategy to mitigate security issues related to <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-internationalized-domain-names--idns">internationalized domain names (IDNs)</a>.
     * 
     * The script determination is based on the script values published by the Unicode Consortium in <a href="http://www.unicode.org/Public/4.1.0/ucd/Scripts.txt">http://www.unicode.org/Public/4.1.0/ucd/Scripts.txt</a>, except that the unassigned characters have the value "Zzzz" (UNASSIGNED) instead of "Zyyy" (COMMON).
     * 
     * Here are some examples of the behavior of this function:
     * 
     * <table>
     * <tr>
     * <th colspan="2">Input string</th>
     * <th><i>dwFlags</i></th>
     * <th><i>lpScripts</i></th>
     * <th>Scripts</th>
     * </tr>
     * <tr>
     * <td colspan="2">Microsoft.com</td>
     * <td>0</td>
     * <td>Latn;</td>
     * <td>Latin</td>
     * </tr>
     * <tr>
     * <td colspan="2">Microsoft.com</td>
     * <td>GSS_ALLOW_INHERITED_COMMON</td>
     * <td>Latn;Zyyy;</td>
     * <td>Latin + Common</td>
     * </tr>
     * <tr>
     * <td rowspan="2">Niño</td>
     * <td>004E 0069 0241 006F</td>
     * <td rowspan="2">GSS_ALLOW_INHERITED_COMMON</td>
     * <td rowspan="2">Latn;</td>
     * <td rowspan="2">Latin</td>
     * </tr>
     * <tr>
     * <td>Uses LATIN SMALL LETTER N WITH TILDE</td>
     * </tr>
     * <tr>
     * <td rowspan="2">Niño</td>
     * <td>004E 0069 006E 0303 006F</td>
     * <td rowspan="2">GSS_ALLOW_INHERITED_COMMON</td>
     * <td rowspan="2">Latn;Qaii;</td>
     * <td rowspan="2">Latin + Inherited</td>
     * </tr>
     * <tr>
     * <td>Uses COMBINING TILDE</td>
     * </tr>
     * <tr>
     * <td rowspan="2">Spооf</td>
     * <td>0053 0070 043e 043e 0066</td>
     * <td rowspan="2">0</td>
     * <td rowspan="2">Latn;Cyrl;</td>
     * <td rowspan="2">Latin + Cyrillic</td>
     * </tr>
     * <tr>
     * <td>Uses CYRILLIC SMALL LETTER O</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>U+f000</td>
     * <td>0</td>
     * <td>Zzzz;</td>
     * <td>Unassigned</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>U+f000</td>
     * <td>GSS_ALLOW_INHERITED_COMMON</td>
     * <td>Zzzz;</td>
     * <td>Unassigned</td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Flags specifying options for script retrieval.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GSS_ALLOW_INHERITED_COMMON"></a><a id="gss_allow_inherited_common"></a><dl>
     * <dt><b>GSS_ALLOW_INHERITED_COMMON</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve "Qaii" (INHERITED) and "Zyyy" (COMMON) script information. This flag does not affect the processing of unassigned characters. These characters in the input string always cause a "Zzzz" (UNASSIGNED script) to appear in the script string.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>   By default, <b>GetStringScripts</b> ignores any inherited or common characters in the input string indicated by <i>lpString</i>. If GSS_ALLOW_INHERITED_COMMON is not set, neither "Qaii" nor "Zyyy" appears in the script string, even if the input string contains such characters. If GSS_ALLOW_INHERITED_COMMON is set, and if the input string contains inherited and/or common characters, "Qaii" and/or "Zyyy", respectively, appear in the script string. See the Remarks section.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpString Pointer to the Unicode string to analyze.
     * @param {Integer} cchString Size, in characters, of the Unicode string indicated by <i>lpString</i>. The application sets this parameter to -1 if the Unicode string is null-terminated. If the application sets this parameter to 0, the function retrieves a null Unicode string (L"\0") in <i>lpScripts</i> and returns 1.
     * @param {Pointer<PWSTR>} lpScripts Pointer to a buffer in which this function retrieves a null-terminated string representing a list of scripts, using the 4-character notation used in <a href="http://www.unicode.org/iso15924/iso15924-codes.html">ISO 15924</a>. Each script name consists of four Latin characters, and the names are retrieved in alphabetical order. Each name, including the last, is followed by a semicolon.
     * 
     * Alternatively, this parameter contains <b>NULL</b> if <i>cchScripts</i> is set to 0. In this case, the function returns the required size for the script buffer.
     * @param {Integer} cchScripts Size, in characters, of the script buffer indicated by <i>lpScripts</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpScripts</i> and returns the required size for the script buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getstringscripts
     * @since windows6.0.6000
     */
    static GetStringScripts(dwFlags, lpString, cchString, lpScripts, cchScripts) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetStringScripts", "uint", dwFlags, "ptr", lpString, "int", cchString, "ptr", lpScripts, "int", cchScripts)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information about a locale specified by name.Note  The application should call this function in preference to GetLocaleInfo if designed to run only on Windows Vista and later. Note  This function can retrieve data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * This function normally retrieves information in text format. If the information is a numeric value and the value of <i>LCType</i> is <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ilanguage">LOCALE_ILANGUAGE</a> or <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-idefault-constants">LOCALE_IDEFAULTLANGUAGE</a>, this function retrieves strings containing hexadecimal numbers. Otherwise, the retrieved text for numeric information is a decimal number.
     * 
     * There are two exceptions to this rule. First, the application can retrieve numeric values as integers by specifying <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> in the <i>LCType</i> parameter. The second exception is that <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-fontsignature">LOCALE_FONTSIGNATURE</a> behaves differently from all other locale information constants. The application must provide a data buffer of at least sizeof(LOCALESIGNATURE) bytes. On successful return from the function, the buffer is filled in as a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-localesignature">LOCALESIGNATURE</a> structure.
     * 
     * <div class="alert"><b>Note</b>  Even when the <i>LCType</i> parameter is specified as LOCALE_FONTSIGNATURE, <i>cchData</i> and the function return are still character counts. When an application calls <b>GetLocaleInfoEx</b> with <i>LCType</i> specified as LOCALE_FONTSIGNATURE, <i>cchData</i> can be safely specified as sizeof(LOCALESIGNATURE) / sizeof(WCHAR).</div>
     * <div> </div>
     * The following examples deal correctly with the buffer size for non-text values:
     * 
     * 
     * ```cpp
     * int   ret;
     * CALID calid;
     * DWORD value;
     * 
     * ret = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT,
     *                       LOCALE_ICALENDARTYPE | LOCALE_RETURN_NUMBER,
     *                       (LPWSTR)&value,
     *                       sizeof(value) / sizeof(WCHAR) );
     * calid = value;
     * 
     * LOCALESIGNATURE LocSig;
     * 
     * ret = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT,
     *                       LOCALE_FONTSIGNATURE,
     *                       (LPWSTR)&LocSig,
     *                       sizeof(LocSig) / sizeof(WCHAR) );
     * 
     * ```
     * 
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For possible values, see the "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section in <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. Note that only one piece of locale information can be specified per call. 
     * 
     * The application can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> with any other allowed constant. In this case, the function retrieves the value as a number instead of a string. The buffer that receives the value must be at least the length of a DWORD value, which is 2.
     * 
     * <div class="alert"><b>Caution</b>  It is also possible to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> with any other constant. However, use of this constant is strongly discouraged. (Even without using the current user override, the data can differ from computer to computer, and custom locales can change the data. For example, even month or day names are subject to spelling reforms.)</div>
     * <div> </div>
     * If <i>LCType</i> is set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ioptionalcalendar">LOCALE_IOPTIONALCALENDAR</a>, the function retrieves only the first alternate calendar. 
     * 
     * <div class="alert"><b>Note</b>  To get all alternate calendars, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a>.</div>
     * <div> </div>
     * Starting with Windows Vista, your applications should not use <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ilanguage">LOCALE_ILANGUAGE</a> in the <i>LCType</i> parameter to avoid failure or retrieval of unexpected data. Instead, it is recommended for your applications to call <b>GetLocaleInfoEx</b>.
     * @param {Pointer<PWSTR>} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0.
     * @param {Integer} cchData Size, in characters, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getlocaleinfoex
     * @since windows6.0.6000
     */
    static GetLocaleInfoEx(lpLocaleName, LCType, lpLCData, cchData) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetLocaleInfoEx", "ptr", lpLocaleName, "uint", LCType, "ptr", lpLCData, "int", cchData)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information about a calendar for a locale specified by name.Note  The application should call this function in preference to GetCalendarInfo if designed to run only on Windows Vista and later. Note  This function can retrieve data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 			 
     * 
     * <div class="alert"><b>Note</b>  <b>GetCalendarInfoEx</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div> </div>
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {Pointer<PWSTR>} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<UInt32>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcalendarinfoex
     * @since windows6.0.6000
     */
    static GetCalendarInfoEx(lpLocaleName, Calendar, CalType, lpCalData, cchData, lpValue) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        DllCall("KERNEL32.dll\GetCalendarInfoEx", "ptr", lpLocaleName, "uint", Calendar, "ptr", lpReserved, "uint", CalType, "ptr", lpCalData, "int", cchData, "ptr", lpValue)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a number string as a number string customized for a locale specified by name.Note  The application should call this function in preference to GetNumberFormat if designed to run only on Windows Vista and later. Note  This function can format data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>  Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If the application does not set this parameter to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale string value for the negative sign.
     * @param {Pointer<PWSTR>} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string. Alternatively, this parameter contains <b>NULL</b> if <i>cchNumber</i> is set to 0. In this case, the function returns the required size for the number string buffer.
     * @param {Integer} cchNumber Size, in characters, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer and does not use the <i>lpNumberStr</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnumberformatex
     * @since windows6.0.6000
     */
    static GetNumberFormatEx(lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetNumberFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Formats a number string as a currency string for a locale specified by name.Note  The application should call this function in preference to GetCurrencyFormat if designed to run only on Windows Vista and later. Note  This function can format data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a> or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>  Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpValue Pointer to a null-terminated string containing the number string to format. This string can contain only the following characters. All other characters are invalid. The function returns an error if the string deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9"</li>
     * <li>One decimal point (dot) if the number is a floating-point value</li>
     * <li>A minus sign in the first character position if the number is a negative value</li>
     * </ul>
     * @param {Pointer<CURRENCYFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <b>CURRENCYFMT</b> structure, for example, the string value for the negative sign used by the locale.
     * @param {Pointer<PWSTR>} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application can set this parameter to 0 to return the size of the buffer required to hold the formatted currency string. In this case, the buffer indicated by <i>lpCurrencyStr</i> is not used.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcurrencyformatex
     * @since windows5.0
     */
    static GetCurrencyFormatEx(lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetCurrencyFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves the user default locale name.Note  The application should call this function in preference to GetUserDefaultLCID if designed to run only on Windows Vista and later.
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a buffer in which this function retrieves the locale name.
     * @param {Integer} cchLocaleName Size, in characters, of the buffer indicated by <i>lpLocaleName</i>. The maximum possible length of a locale name, including a terminating null character, is <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply in this parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultlocalename
     * @since windows6.0.6000
     */
    static GetUserDefaultLocaleName(lpLocaleName, cchLocaleName) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetUserDefaultLocaleName", "ptr", lpLocaleName, "int", cchLocaleName)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves the system default locale name.Note  It is recommended that applications call GetUserDefaultLocaleName in preference over this function.
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a buffer in which this function retrieves the locale name.
     * @param {Integer} cchLocaleName Size, in characters, of the output buffer indicated by <i>lpLocaleName</i>. The maximum possible character length of a locale name (including a terminating null character) is the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystemdefaultlocalename
     * @since windows6.0.6000
     */
    static GetSystemDefaultLocaleName(lpLocaleName, cchLocaleName) {
        A_LastError := 0

        DllCall("KERNEL32.dll\GetSystemDefaultLocaleName", "ptr", lpLocaleName, "int", cchLocaleName)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Determines if each character in a string has a defined result for a specified NLS capability.
     * @remarks
     * This function differentiates between defined and undefined strings, so that an application such as Active Directory can reject strings with undefined code points. Use of the function can minimize the necessity for the application to re-index its database. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * 
     * For example, if <i>Function</i> is set to COMPARE_STRING, <b>IsNLSDefinedString</b> checks for undefined code points, <a href="https://docs.microsoft.com/windows/desktop/Intl/surrogates-and-supplementary-characters">surrogate pairs</a> that represent undefined Unicode characters, or ill-formed surrogate pairs. If the function returns <b>TRUE</b> for a particular string, the results, as retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a> with LCMAP_SORTKEY set, are guaranteed to be identical as long as the corresponding NLS version does not change.
     * @param {Integer} Function NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {Integer} dwFlags Flags defining the function. Must be 0.
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure containing version information. Typically, the information is obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversion">GetNLSVersion</a>. The application sets this parameter to <b>NULL</b> if the function is to use the current version.
     * @param {Pointer<PWSTR>} lpString Pointer to the UTF-16 string to examine.
     * @param {Integer} cchStr Number of UTF-16 characters in the string indicated by <i>lpString</i>. This count can include a terminating null character. If the terminating null character is included in the character count, it does not affect the checking behavior because the terminating null character is always defined.
     * 
     * The application should supply -1 to indicate that the string is null-terminated. In this case, the function itself calculates the string length.
     * @returns {Integer} Returns <b>TRUE</b> if successful, only if the input string is valid, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isnlsdefinedstring
     * @since windows6.0.6000
     */
    static IsNLSDefinedString(Function, dwFlags, lpVersionInformation, lpString, cchStr) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsNLSDefinedString", "uint", Function, "uint", dwFlags, "ptr", lpVersionInformation, "ptr", lpString, "int", cchStr, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the current version of a specified NLS capability for a locale specified by name.Note  The application should call this function in preference to GetNLSVersion if designed to run only on Windows Vista and later.
     * @remarks
     * This function allows an application such as Active Directory to determine if an NLS change affects the locale used for a particular index table. If it does not, there is no need to re-index the table. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. In particular, to tell if a sort version changed and you need to reindex:
     * 
     * <ol>
     * <li>Use <b>GetNLSVersionEx</b> to retrieve an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure when doing the original indexing of your data.</li>
     * <li>Store the following properties with your index to identify the version:<ul>
     * <li><b>NLSVERSIONINFOEX.dwNLSVersion</b>. This specifies the version of the sorting table you're using.</li>
     * <li><b>NLSVERSIONINFOEX.dwEffectiveId</b>. This specifies the effective locale of your sort. A custom locale will point to an in-box locale's sort.</li>
     * <li><b>NLSVERSIONINFOEX.guidCustomVersion</b>. This is a GUID specifying a specific custom sort for custom locales that have them.</li>
     * </ul>
     * </li>
     * <li>When using the index use <b>GetNLSVersionEx</b> to discover the version of your data.</li>
     * <li>If any of the three properties has changed, the sorting data you're using could return different results and any indexing you have may fail to find records.</li>
     * <li>If you <u>know</u> that your data doesn't contain invalid Unicode code points (that is, all of your strings passed a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-isnlsdefinedstring">IsNLSDefinedString</a>) then you may consider them the same if <u>only</u> the low byte of <b>dwNLSVersion</b> changed (the minor version described above).</li>
     * </ol>
     * This is covered in more detail in the blog entry <a href="https://docs.microsoft.com/archive/blogs/shawnste/">"How to tell if the collation version changed"</a> (http://blogs.msdn.com/shawnste/archive/2007/06/01/how-to-tell-if-the-collation-version-changed.aspx).
     * 
     * This function supports <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. If <i>lpLocaleName</i> specifies a supplemental locale, the data retrieved is the correct data for the sort order associated with that supplemental locale.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Integer} function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFOEX>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c> sizeof(NLSVERSIONINFOEX)</c>. 
     * 
     * <div class="alert"><b>Note</b>  On Windows Vista and later, the function can alternatively provide version information in an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure.</div>
     * <div> </div>
     * @returns {Integer} Returns <b>TRUE</b> if and only if the application has supplied valid values in <i>lpVersionInformation</i>, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnlsversionex
     * @since windows6.0.6000
     */
    static GetNLSVersionEx(function, lpLocaleName, lpVersionInformation) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNLSVersionEx", "uint", function, "ptr", lpLocaleName, "ptr", lpVersionInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if the NLS version is valid for a given NLS function.
     * @remarks
     * Initialize the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNLSVersionEx</a>. See the Remarks for <b>GetNLSVersionEx</b> for a discussion on how the members of <b>NLSVERSIONINFOEX</b> can be used to determine if a sort version has changed and you need to reindex data.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Integer} function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFOEX>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c> sizeof(NLSVERSIONINFOEX)</c>.
     * @returns {Integer} Returns a nonzero value if the NLS version is valid, or zero if the version is invalid.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidnlsversion
     * @since windows8.0
     */
    static IsValidNLSVersion(function, lpLocaleName, lpVersionInformation) {
        result := DllCall("KERNEL32.dll\IsValidNLSVersion", "uint", function, "ptr", lpLocaleName, "ptr", lpVersionInformation, "uint")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by name.Caution  Because strings with very different binary representations can compare as identical, this function can raise certain security concerns. For more information, see the discussion of comparison functions in Security Considerations:\_International Features.
     * @remarks
     * This function provides a variety of search options, including search direction, character equivalence filtering, and locale-specific filtering. Note that equivalence depends on the locale and flags specified in the call to the function. The filtering flags can alter the results of the search. For example, the potential matches increase when the function ignores case or diacritic marks when performing the search.
     * 
     * By default, this function maps the lowercase "i" to the uppercase "I", even when the <i>Locale</i> parameter specifies Turkish (Turkey) or Azerbaijani (Azerbaijan). To override this behavior for Turkish or Azerbaijani, the application should specify NORM_LINGUISTIC_CASING. If this flag is specified for the correct locale, "ı" (lowercase dotless I) is the lowercase form of "I" (uppercase dotless I) and "i" (lowercase dotted I) is the lowercase form of "ı" (uppercase dotted I).
     * 
     * 
     * For many scripts (notably Latin scripts), NORM_IGNORENONSPACE coincides with LINGUISTIC_IGNOREDIACRITIC and NORM_IGNORECASE coincides with LINGUISTIC_IGNORECASE, with the following exceptions:
     * 
     * <ul>
     * <li>NORM_IGNORENONSPACE ignores any secondary distinction, whether or not it is a diacritic. Scripts for Korean, Japanese, Chinese, Indic languages, and others use this distinction for purposes other than diacritics. LINGUISTIC_IGNOREDIACRITIC ignores only actual diacritics, instead of simply ignoring the second sorting weight.</li>
     * <li>NORM_IGNORECASE ignores any tertiary distinction, whether or not it is actually linguistic case. For example, in Arabic and Indic scripts, this flag distinguishes alternate forms of a character. However, the differences do not correspond to linguistic case. LINGUISTIC_IGNORECASE ignores only actual linguistic casing, instead of ignoring the third sorting weight.</li>
     * </ul>
     * In contrast to other NLS API functions, which return 0 for failure, this function returns -1 if it fails. On success, it returns a 0-based index. Use of this index helps the function avoid off-by-one errors and one-character buffer overruns.
     * 
     * This function is one of the few NLS functions that calls <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> even when it succeeds. It makes this call to clear the last error in a thread when it fails to match the search string. This clears the value returned by <b>GetLastError</b>.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFindNLSStringFlags Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags with any of the filtering flags defined in the next table. If the application does not specify a flag, the function uses the default comparison for the specified locale. As discussed in <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>, there is no binary comparison mode.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMSTART"></a><a id="find_fromstart"></a><dl>
     * <dt><b>FIND_FROMSTART</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string, starting with the first character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMEND"></a><a id="find_fromend"></a><dl>
     * <dt><b>FIND_FROMEND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string in the reverse direction, starting with the last character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_STARTSWITH"></a><a id="find_startswith"></a><dl>
     * <dt><b>FIND_STARTSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the first value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_ENDSWITH"></a><a id="find_endswith"></a><dl>
     * <dt><b>FIND_ENDSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the last value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The application can use the filtering flags defined below in combination with a find flag.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNORECASE"></a><a id="linguistic_ignorecase"></a><dl>
     * <dt><b>LINGUISTIC_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case in the search, as linguistically appropriate. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNOREDIACRITIC"></a><a id="linguistic_ignorediacritic"></a><dl>
     * <dt><b>LINGUISTIC_IGNOREDIACRITIC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore diacritics, as linguistically appropriate. For more information, see the Remarks section.
     * 
     * <div class="alert"><b>Note</b>  This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORECASE"></a><a id="norm_ignorecase"></a><dl>
     * <dt><b>NORM_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case in the search. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREKANATYPE"></a><a id="norm_ignorekanatype"></a><dl>
     * <dt><b>NORM_IGNOREKANATYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORENONSPACE"></a><a id="norm_ignorenonspace"></a><dl>
     * <dt><b>NORM_IGNORENONSPACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORESYMBOLS"></a><a id="norm_ignoresymbols"></a><dl>
     * <dt><b>NORM_IGNORESYMBOLS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore symbols and punctuation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREWIDTH"></a><a id="norm_ignorewidth"></a><dl>
     * <dt><b>NORM_IGNOREWIDTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_LINGUISTIC_CASING"></a><a id="norm_linguistic_casing"></a><dl>
     * <dt><b>NORM_LINGUISTIC_CASING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use linguistic rules for casing, instead of file system rules (default). For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<PWSTR>} lpStringValue Pointer to the search string, for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<Int32>} pcchFound Pointer to a buffer containing the length of the string that the function finds. The string can be either longer or shorter than the search string. If the function fails to find the search string, this parameter is not modified.
     * 
     * The function can retrieve <b>NULL</b> in this parameter. In this case, the function makes no indication if the length of the found string differs from the length of the source string. 
     * 
     * Note that the value of <i>pcchFound</i> is often identical to the value provided in <i>cchValue</i>, but can differ in the following cases:
     * 
     * <ul>
     * <li>The value provided in <i>cchValue</i> is negative.</li>
     * <li>The strings are equivalent, but have different lengths. For example, "A" plus "Combining Ring" (U+0041 U+030A) is equivalent to the "A Ring" (U+00c5).</li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Reserved; must be <b>NULL</b>.
     * @param {Pointer} sortHandle Reserved; must be 0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-findnlsstringex
     * @since windows6.0.6000
     */
    static FindNLSStringEx(lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, sortHandle) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        DllCall("KERNEL32.dll\FindNLSStringEx", "ptr", lpLocaleName, "uint", dwFindNLSStringFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, "ptr", pcchFound, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", sortHandle)
        if(A_LastError)
            throw OSError()

    }

    /**
     * For a locale specified by name, maps an input character string to another using a specified transformation, or generates a sort key for the input string.Note  The application should call this function in preference to LCMapString if designed to run only on Windows Vista and later.
     * @remarks
     * The application can use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a> or <b>LCMapStringEx</b> to generate a sort key. To do this, the application specifies  LCMAP_SORTKEY for the <i>dwMapFlags</i> parameter. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * 
     * > [!NOTE]
     * > Sort keys are opaque byte streams. Callers should treat them as a byte array of the length returned by the API and not rely on any internal structure that may appear to be present. Zero, one or more of the bytes in the returned sort key could be 0. Absence or presence of a zero byte should not be expected.
     * 
     * Another way for your application to use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a> or <b>LCMapStringEx</b> is in mapping strings. In this case, the application does not specify LCMAP_SORTKEY for the <i>dwMapFlags</i> parameter, but supplies some other combination of flags. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * 
     * <b>Beginning in Windows Vista:</b> This function can handle data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flag specifying the type of transformation to use during string mapping or the type of sort key to generate. This parameter can have the following values.
     * 
     * | Flag | Meaning |
     * | --- | --- |
     * | **LCMAP_BYTEREV**| Use byte reversal. For example, if the application passes in 0x3450 0x4822, the result is 0x5034 0x2248. |
     * | **LCMAP_FULLWIDTH** | Use Unicode (wide) characters where applicable. This flag and LCMAP_HALFWIDTH are mutually exclusive. With this flag, the mapping may use Normalization Form C even if an input character is already full-width. For example, the string "は゛" (which is already full-width) is normalized to "ば". See [Unicode normalization forms](http://www.unicode.org/reports/tr15/). |
     * |**LCMAP_HALFWIDTH** | Use narrow characters where applicable. This flag and LCMAP_FULLWIDTH are mutually exclusive. |
     * | **LCMAP_HIRAGANA** | Map all katakana characters to hiragana. This flag and LCMAP_KATAKANA are mutually exclusive. |
     * | **LCMAP_KATAKANA** | Map all hiragana characters to katakana. This flag and LCMAP_HIRAGANA are mutually exclusive. |
     * | **LCMAP_LINGUISTIC_CASING** | Use linguistic rules for casing, instead of file system rules (default). This flag is valid with LCMAP_LOWERCASE or LCMAP_UPPERCASE only. |
     * | **LCMAP_LOWERCASE** | For locales and scripts capable of handling uppercase and lowercase, map all characters to lowercase.
     * | **LCMAP_HASH** | Return a hash of the raw sort weights of a string.<br> <br>Strings that appear equivalent typically return the same hash (for example, "hello" and "HELLO" with LCMAP_IGNORECASE). However, some complex cases, such as East Asian languages, can have similar strings with identical weights that compare as equal but do not return the same hash.<br> <br>LCMAP_HASH requires that the output buffer be of size sizeof(int) |
     * | **LCMAP_SIMPLIFIED_CHINESE** | Map traditional Chinese characters to simplified Chinese characters. This flag and LCMAP_TRADITIONAL_CHINESE are mutually exclusive. |
     * | **LCMAP_SORTHANDLE** <br> **The use of a sort handle results in minimal performance improvements and is discouraged.** | Return a token representing the resolved sort parameters for the locale (like locale name), so future calls can pass <c>NULL</c> for the sort name and pass the previously queried sort handle as the last parameter (sortHandle) in subsequent calls to [CompareStringEx](../stringapiset/nf-stringapiset-comparestringex.md) or [LCMapStringEx](nf-winnls-lcmapstringex.md).<br> <br>LCMAP_SORTHANDLE requires that the output buffer be of size sizeof(lparam) |
     * | **LCMAP_SORTKEY** | Produce a normalized sort key. If the LCMAP_SORTKEY flag is not specified, the function performs string mapping. For details of sort key generation and string mapping, see the Remarks section. |
     * | **LCMAP_TITLECASE** | Windows 7:</b> Map all characters to title case, in which the first letter of each major word is capitalized. |
     * | **LCMAP_TRADITIONAL_CHINESE** | Map simplified Chinese characters to traditional Chinese characters. This flag and LCMAP_SIMPLIFIED_CHINESE are mutually exclusive. |
     * | **LCMAP_UPPERCASE** | For locales and scripts capable of handling uppercase and lowercase, map all characters to uppercase. |
     * 
     * The following flags can be used alone, with one another, or with the LCMAP_SORTKEY and/or LCMAP_BYTEREV flags. However, they cannot be combined with the other flags listed above.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORENONSPACE"></a><a id="norm_ignorenonspace"></a><dl>
     * <dt><b>NORM_IGNORENONSPACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters. For many scripts (notably Latin scripts), NORM_IGNORENONSPACE coincides with LINGUISTIC_IGNOREDIACRITIC.
     * 
     * <div class="alert"><b>Note</b>  NORM_IGNORENONSPACE ignores any secondary distinction, whether it is a diacritic or not. Scripts for Korean, Japanese, Chinese, and Indic languages, among others, use this distinction for purposes other than diacritics. LINGUISTIC_IGNOREDIACRITIC causes the function to ignore only actual diacritics, instead of ignoring the second sorting weight.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORESYMBOLS"></a><a id="norm_ignoresymbols"></a><dl>
     * <dt><b>NORM_IGNORESYMBOLS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore symbols and punctuation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The flags listed below are used only with the LCMAP_SORTKEY flag.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNORECASE"></a><a id="linguistic_ignorecase"></a><dl>
     * <dt><b>LINGUISTIC_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case, as linguistically appropriate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNOREDIACRITIC"></a><a id="linguistic_ignorediacritic"></a><dl>
     * <dt><b>LINGUISTIC_IGNOREDIACRITIC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters, as linguistically appropriate.
     * 
     * <div class="alert"><b>Note</b>  This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORECASE"></a><a id="norm_ignorecase"></a><dl>
     * <dt><b>NORM_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case. For many scripts (notably Latin scripts), NORM_IGNORECASE coincides with LINGUISTIC_IGNORECASE.
     * 
     * <div class="alert"><b>Note</b>  NORM_IGNORECASE ignores any tertiary distinction, whether it is actually linguistic case or not. For example, in Arabic and Indic scripts, this flag distinguishes alternate forms of a character, but the differences do not correspond to linguistic case. LINGUISTIC_IGNORECASE causes the function to ignore only actual linguistic casing, instead of ignoring the third sorting weight.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  For double-byte character set (DBCS) locales, NORM_IGNORECASE has an effect on all Unicode characters as well as narrow (one-byte) characters, including Greek and Cyrillic characters.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREKANATYPE"></a><a id="norm_ignorekanatype"></a><dl>
     * <dt><b>NORM_IGNOREKANATYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREWIDTH"></a><a id="norm_ignorewidth"></a><dl>
     * <dt><b>NORM_IGNOREWIDTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_LINGUISTIC_CASING"></a><a id="norm_linguistic_casing"></a><dl>
     * <dt><b>NORM_LINGUISTIC_CASING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use linguistic rules for casing, instead of file system rules (default).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SORT_DIGITSASNUMBERS"></a><a id="sort_digitsasnumbers"></a><dl>
     * <dt><b>SORT_DIGITSASNUMBERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows 7:</b> Treat digits as numbers during sorting, for example, sort "2" before "10".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SORT_STRINGSORT"></a><a id="sort_stringsort"></a><dl>
     * <dt><b>SORT_STRINGSORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Treat punctuation the same as symbols.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set this parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapStringEx</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {Pointer<PWSTR>} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure that contains the version information about the relevant NLS capability; usually retrieved from <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNLSVersionEx</a>.
     * 
     * **Windows Vista, Windows 7:** Reserved; must set to NULL.
     * @param {Pointer} sortHandle Reserved; must be 0.
     * 
     * > [!NOTE]
     * > [CompareStringEx](../stringapiset/nf-stringapiset-comparestringex.md) and [LCMapStringEx](nf-winnls-lcmapstringex.md) can specify a sort handle (if the locale name is null).  This use is discouraged for most apps.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-lcmapstringex
     * @since windows6.0.6000
     */
    static LCMapStringEx(lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, sortHandle) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        DllCall("KERNEL32.dll\LCMapStringEx", "ptr", lpLocaleName, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", sortHandle)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Determines if the specified locale name is valid for a locale that is installed or supported on the operating system.Note  An application running only on Windows Vista and later should call this function in preference to IsValidLocale to determine the validity of a supplemental locale.
     * @remarks
     * On Windows Vista and later, all supported locales should be installed on all operating systems.
     * 
     * This function can handle the name of a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locale</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to the locale name to validate.
     * @returns {Integer} Returns a nonzero value if the locale name is valid, or returns 0 for an invalid name.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidlocalename
     * @since windows6.0.6000
     */
    static IsValidLocaleName(lpLocaleName) {
        result := DllCall("KERNEL32.dll\IsValidLocaleName", "ptr", lpLocaleName, "int")
        return result
    }

    /**
     * Enumerates calendar information for a locale specified by name.Note  The application should call this function in preference to EnumCalendarInfo or EnumCalendarInfoEx if designed to run only on Windows Vista and later. Note  This function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * This function enumerates calendar information for all applicable calendars for the specified locale, or for a single requested calendar, depending on the value of the <i>Calendar</i> parameter. The function enumerates the calendar information by calling the specified application-defined callback function. It passes the callback function a pointer to a buffer containing the requested calendar information, a calendar identifier, and an application-defined parameter that is useful for multi-threaded applications. This process continues until <b>EnumCalendarInfoExEx</b> finds the last applicable calendar or the callback function returns <b>FALSE</b>.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<CALINFO_ENUMPROCEXEX>} pCalInfoEnumProcExEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317808(v=vs.85)">EnumCalendarInfoProcExEx</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @param {Pointer} lParam Application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfoexex
     * @since windows6.0.6000
     */
    static EnumCalendarInfoExEx(pCalInfoEnumProcExEx, lpLocaleName, Calendar, CalType, lParam) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExEx", "ptr", pCalInfoEnumProcExEx, "ptr", lpLocaleName, "uint", Calendar, "ptr", lpReserved, "uint", CalType, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a locale specified by name.Note  The application should call this function in preference to EnumDateFormats or EnumDateFormatsEx if designed to run only on Windows Vista and later. Note  This function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * <div class="alert"><b>Note</b>  This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div> </div>
     * The function enumerates the date formats by passing date format string pointers, one at a time, to the specified application-defined callback function, along with an application-defined constant that is useful for multi-threaded applications. This process continues until <b>EnumDateFormatsExEx</b> finds the last date format or the callback function returns <b>FALSE</b>.
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<DATEFMT_ENUMPROCEXEX>} lpDateFmtEnumProcExEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317815(v=vs.85)">EnumDateFormatsProcExEx</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {Pointer} lParam An application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsexex
     * @since windows6.0.6000
     */
    static EnumDateFormatsExEx(lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExEx", "ptr", lpDateFmtEnumProcExEx, "ptr", lpLocaleName, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by name.Note  The application should call this function in preference to EnumTimeFormats if designed to run only on Windows Vista and later. Note  This function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * This function enumerates the time formats by passing time format string pointers, one at a time, to the specified application-defined callback function, along with an application-defined constant that is useful for multi-threaded applications. The first value in the enumeration is always the user default (override) value. The function continues enumeration until the last time format is found or the callback function returns <b>FALSE</b>. 
     * 
     * <b>Beginning in Windows 8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<TIMEFMT_ENUMPROCEX>} lpTimeFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317833(v=vs.85)">EnumTimeFormatsProcEx</a>.
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags The time format. Set to 0 to use the current user's long time format, or TIME_NOSECONDS (starting with Windows 7) to use the short time format.
     * @param {Pointer} lParam An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumtimeformatsex
     * @since windows6.0.6000
     */
    static EnumTimeFormatsEx(lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsEx", "ptr", lpTimeFmtEnumProcEx, "ptr", lpLocaleName, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.Note  The application should call this function in preference to EnumSystemLocales if designed to run only on Windows Vista and later.
     * @remarks
     * This function enumerates locales by passing locale names, one at a time, to the application-defined callback function specified by <i>lpLocaleEnumProcEx</i>. Enumeration continues until all installed or supported names have been passed to the callback function or the callback function returns <b>FALSE</b>.
     * 
     * The choices for the <i>dwFlags</i> parameter are different from those for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemlocalesa">EnumSystemLocales</a>, which must distinguish between installed and supported locales.
     * 
     * If <i>dwFlags</i> specifies <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-alternate-sorts">LOCALE_ALTERNATE_SORTS</a>, the callback function is called for every locale that represents an alternate sort order. For example, Spanish (Spain) defaults to international sort order, but traditional sort order is available for an alternate sort. German (Germany) defaults to dictionary sort order, but there is an alternate phone book sort order available.
     * @param {Pointer<LOCALE_ENUMPROCEX>} lpLocaleEnumProcEx Pointer to an application-defined callback function. The <b>EnumSystemLocalesEx</b> function enumerates locales by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-locale_enumprocex">EnumLocalesProcEx</a>.
     * @param {Integer} dwFlags Flags identifying the locales to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-all">LOCALE_ALL</a>.
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-all">LOCALE_ALL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-alternate-sorts">LOCALE_ALTERNATE_SORTS</a>; see Remarks</li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-neutraldata">LOCALE_NEUTRALDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-supplemental">LOCALE_SUPPLEMENTAL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-windows">LOCALE_WINDOWS</a>
     * </li>
     * </ul>
     * @param {Pointer} lParam An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications.
     * @returns {Integer} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlocalesex
     * @since windows6.0.6000
     */
    static EnumSystemLocalesEx(lpLocaleEnumProcEx, dwFlags, lParam) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesEx", "ptr", lpLocaleEnumProcEx, "uint", dwFlags, "ptr", lParam, "ptr", lpReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Finds a possible locale name match for the supplied name.
     * @remarks
     * The retrieved locale name indicates a specific locale, including language and country/region, even if the input language is neutral. For example, an input of "en" for English (United States) causes the function to retrieve "en-US".
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application, nor does the return of a valid locale guarantee that it will be valid on another computer. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows 8:</b> Language tags obtained from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace must be converted by  <b>ResolveLocaleName</b> before they can be used with any National Language Support functions.
     * @param {Pointer<PWSTR>} lpNameToResolve Pointer to a name to resolve, for example, "en-XA" for English (Private Use).
     * @param {Pointer<PWSTR>} lpLocaleName Pointer to a buffer in which this function retrieves the locale name that is the match for the input name. For example, the match for the name "en-XA" is "en-US" for English (United States).
     * 
     * <div class="alert"><b>Note</b>  If the function fails, the state of the output buffer is not guaranteed to be accurate. In this case, the application should check the return value and error status set by the function to determine the correct course of action.</div>
     * <div> </div>
     * @param {Integer} cchLocaleName Size, in characters, of the buffer indicated by <i>lpLocaleName</i>. The maximum possible length of a locale name, including a terminating null character, is the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply in this parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-resolvelocalename
     * @since windows6.1
     */
    static ResolveLocaleName(lpNameToResolve, lpLocaleName, cchLocaleName) {
        A_LastError := 0

        DllCall("KERNEL32.dll\ResolveLocaleName", "ptr", lpNameToResolve, "ptr", lpLocaleName, "int", cchLocaleName)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves a list of available ELS platform-supported services, along with associated information, according to application-specified criteria.
     * @remarks
     * The ELS application can either retrieve all services or filter the services according to specified options. For an associated procedure and code sample, see <a href="https://docs.microsoft.com/windows/desktop/Intl/enumerating-and-freeing-services">Enumerating and Freeing Services</a>.
     * 
     * To avoid resource leaks, the application must free the pointer indicated by <i>prgServices</i> with a call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingfreeservices">MappingFreeServices</a>.  
     * 
     * 
     * For performance reasons, it is recommended to retrieve services infrequently. For example, if the application needs a specific service, by GUID, it can be enumerated when needed and cached for future use.
     * @param {Pointer<MAPPING_ENUM_OPTIONS>} pOptions Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_enum_options">MAPPING_ENUM_OPTIONS</a> structure containing criteria to use during enumeration of services. The application specifies <b>NULL</b> for this parameter to retrieve all installed services.
     * @param {Pointer<MAPPING_SERVICE_INFO>} prgServices Address of a pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structures containing service information matching the criteria supplied in the <i>pOptions</i> parameter.
     * @param {Pointer<UInt32>} pdwServicesCount Pointer to a DWORD variable in which this function retrieves the number of retrieved services.
     * @returns {Integer} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.<div class="alert"><b>Note</b>  The application must test for any failure before proceeding with further operations.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappinggetservices
     * @since windows6.1
     */
    static MappingGetServices(pOptions, prgServices, pdwServicesCount) {
        result := DllCall("elscore.dll\MappingGetServices", "ptr", pOptions, "ptr", prgServices, "ptr", pdwServicesCount, "int")
        return result
    }

    /**
     * Frees memory and resources allocated for the application to interact with one or more ELS services. The memory and resources are allocated in an application call to MappingGetServices.
     * @remarks
     * <div class="alert"><b>Caution</b>  Services should not be freed before freeing the property bags produced by those services.</div>
     * <div> </div>
     * Since all services currently run in the application process, the ELS platform does not unload the service DLLs when the services are released. The operating system unloads the DLLs automatically when the application terminates.
     * @param {Pointer<MAPPING_SERVICE_INFO>} pServiceInfo Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structures containing service descriptions retrieved by a prior call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappinggetservices">MappingGetServices</a>. This parameter cannot be set to <b>NULL</b>.
     * @returns {Integer} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappingfreeservices
     * @since windows6.1
     */
    static MappingFreeServices(pServiceInfo) {
        result := DllCall("elscore.dll\MappingFreeServices", "ptr", pServiceInfo, "int")
        return result
    }

    /**
     * Calls upon an ELS service to recognize text. For example, the Microsoft Language Detection service will attempt to recognize the language in which the input text is written.
     * @remarks
     * The type of text to recognize depends on the service type used by the application. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/requesting-text-recognition">Requesting Text Recognition</a>.
     * 
     * <div class="alert"><b>Warning</b>  The data referred to by <i>pszText</i> and <i>pOptions</i> must remain valid until the property bag structure passed by <i>pBag</i> is freed via 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingfreepropertybag">MappingFreePropertyBag</a>. This is because both synchronous and asynchronous calls to 
     * 
     * <b>MappingRecognizeText</b> and <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingdoaction">MappingDoAction</a> will attempt to use the data passed to the initial 
     * 
     * call to <b>MappingRecognizeText</b>.</div>
     * <div> </div>
     * @param {Pointer<MAPPING_SERVICE_INFO>} pServiceInfo Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structure containing information about the service to use in text recognition. The structure must be one of the structures retrieved by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappinggetservices">MappingGetServices</a>. This parameter cannot be set to <b>NULL</b>.
     * @param {Pointer<PWSTR>} pszText Pointer to the text to recognize. The text must be UTF-16, but some services have additional requirements for the input format. This parameter cannot be set to <b>NULL</b>.
     * @param {Integer} dwLength Length, in characters, of the text specified in <i>pszText</i>.
     * @param {Integer} dwIndex Index inside the specified text to be used by the service. This value should be between 0 and <i>dwLength</i>-1. If the application wants to process the entire text, it should set this parameter to 0.
     * @param {Pointer<MAPPING_OPTIONS>} pOptions Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_options">MAPPING_OPTIONS</a> structure containing options that affect the result and behavior of text recognition. The application does not have to specify values for all structure members. This parameter can be set to <b>NULL</b> to use the default mapping options.
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pbag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure in which the service stores its results. On input, the application passes a structure with only the size provided, and the other members set to 0. On output, the structure is filled with information produced by the service during text recognition. This parameter cannot be set to <b>NULL</b>.
     * @returns {Integer} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappingrecognizetext
     * @since windows6.1
     */
    static MappingRecognizeText(pServiceInfo, pszText, dwLength, dwIndex, pOptions, pbag) {
        result := DllCall("elscore.dll\MappingRecognizeText", "ptr", pServiceInfo, "ptr", pszText, "uint", dwLength, "uint", dwIndex, "ptr", pOptions, "ptr", pbag, "int")
        return result
    }

    /**
     * Causes an ELS service to perform an action after text recognition has occurred. For example, a phone dialer service first must recognize phone numbers and then can perform the &quot;action&quot; of dialing a number.
     * @remarks
     * The application must precede the call to <b>MappingDoAction</b> with a call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a>.
     * 
     * <div class="alert"><b>Warning</b>  The data referred to by the <i>pszText</i> and <i>pOptions</i> arguments passed to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a> 
     * 
     * must remain valid until the property bag structure passed by <i>pBag</i> is freed via 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingfreepropertybag">MappingFreePropertyBag</a>. This is because both synchronous and asynchronous calls to 
     * 
     * <b>MappingRecognizeText</b> and <b>MappingDoAction</b> will attempt to use the data passed to the initial 
     * 
     * call to <b>MappingRecognizeText</b>.</div>
     * <div> </div>
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pBag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure containing the results of a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a>. This parameter cannot be set to <b>NULL</b>.
     * @param {Integer} dwRangeIndex A starting index inside the text recognition results for a recognized text range. This value should be between 0 and the range count.
     * @param {Pointer<PWSTR>} pszActionId Pointer to the identifier of the action to perform. This parameter cannot be set to <b>NULL</b>.
     * @returns {Integer} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappingdoaction
     * @since windows6.1
     */
    static MappingDoAction(pBag, dwRangeIndex, pszActionId) {
        result := DllCall("elscore.dll\MappingDoAction", "ptr", pBag, "uint", dwRangeIndex, "ptr", pszActionId, "int")
        return result
    }

    /**
     * Frees memory and resources allocated during an ELS text recognition operation.
     * @remarks
     * An ELS service allocates memory and resources for data retrieved from application calls to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a>. The <b>MappingFreePropertyBag</b> function releases these resources.
     * 
     * <div class="alert"><b>Caution</b>  Services should not be freed before freeing the property bags produced by those services.</div>
     * <div> </div>
     * <div class="alert"><b>Caution</b>  The application must call this function only once for each call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a> when the property bag is no longer needed. Not calling <b>MappingFreePropertyBag</b> after each call to <b>MappingRecognizeText</b> causes a resource leak. For more information about memory allocation for the property bag, see the remarks for the <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure.</div>
     * <div> </div>
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pBag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure containing the properties for which to free resources. This parameter cannot be set to <b>NULL</b>.
     * @returns {Integer} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappingfreepropertybag
     * @since windows6.1
     */
    static MappingFreePropertyBag(pBag) {
        result := DllCall("elscore.dll\MappingFreePropertyBag", "ptr", pBag, "int")
        return result
    }

    /**
     * Frees a script cache.
     * @remarks
     * An application can free the script cache at any time, with certain limitations if the application is multi-threaded. Uniscribe maintains reference counts in its <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">font and shaper caches</a> and frees font data only when all sizes of the font are free. It frees shaper data only when all supported fonts are freed.
     * 
     * The application should free the script cache for a style when it discards that style.
     * 
     * <b>ScriptFreeCache</b> always sets its parameter to <b>NULL</b> to help avoid misreferencing.
     * 
     * Uniscribe functions are re-entrant. Cache creation is interlocked through a single process-wide semaphore. <b>ScriptFreeCache</b> should not be called at a time when another thread might be accessing the particular cache to free. For performance reasons, the cache is not locked during <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> or <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} psc Pointer to the <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application cant test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptfreecache
     * @since windows5.0
     */
    static ScriptFreeCache(psc) {
        result := DllCall("USP10.dll\ScriptFreeCache", "ptr", psc, "int")
        return result
    }

    /**
     * Breaks a Unicode string into individually shapeable items.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * The function delimits items by either a change of shaping engine or a change of direction.
     * 
     * The application can create multiple ranges, or runs that fall entirely within a single item, from each <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structure retrieved by <b>ScriptItemize</b>. However, it should not combine multiple items into a single run. Later, when measuring or rendering, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> for each run and must pass the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure retrieved by <b>ScriptItemize</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structure.
     * 
     * If the text handled by an application can include any right-to-left content, the application uses the <i>psControl</i> and <i>psState</i> parameters in calling <b>ScriptItemize</b>. However, the application does not have to do this and can handle bidirectional text itself instead of relying on Uniscribe to do so. The <i>psControl</i> and <i>psState</i> parameters are useful in some strictly left-to-right scenarios, for example, when the <b>fLinkStringBefore</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> is not specific to right-to-left scripts. The application sets <i>psControl</i> and <i>psState</i> to <b>NULL</b> to have <b>ScriptItemize</b> break the Unicode string purely by character code.
     * 
     * The application can set all parameters to non-<b>NULL</b> values to have the function perform a full Unicode bidirectional analysis. To permit a correct Unicode bidirectional analysis, the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure should be initialized according to the reading order at paragraph start, and <b>ScriptItemize</b> should be passed the whole paragraph. In particular, the <b>uBidiLevel</b> member should be initialized to 0 for left-to-right and 1 for right-to-left.
     * 
     * The <b>fRTL</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> is referenced in <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> enabled="1". The <b>fNumeric</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> is retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetproperties">ScriptGetProperties</a>. These members together provide the same classification as the <b>lpClass</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-gcp_resultsa">GCP_RESULTS</a>, referenced by <i>lpResults</i> in <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a>.
     * 
     * European digits U+0030 through U+0039 can be rendered as national digits, as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>SCRIPT_STATE.fDigitSubstitute</th>
     * <th>SCRIPT_CONTROL.fContextDigits</th>
     * <th>Digit shapes displayed for Unicode U+0030 through U+0039</th>
     * </tr>
     * <tr>
     * <td><b>FALSE</b></td>
     * <td>Any</td>
     * <td>European digits</td>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td><b>FALSE</b></td>
     * <td>As specified in <b>uDefaultLanguage</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a>.</td>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td><b>TRUE</b></td>
     * <td>As prior strong text, defaulting to <b>uDefaultLanguage</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a>.</td>
     * </tr>
     * </table>
     *  
     * 
     * In context digit mode, one of the following actions occurs:
     * 
     * <ul>
     * <li>If the script specified by <b>uDefaultLanguage</b> is in the same direction as the output, all digits encountered before the first letters are rendered in the language indicated by <b>uDefaultLanguage</b>.</li>
     * <li>If the script specified by <b>uDefaultLanguage</b> is in the opposite direction from the output, all digits encountered before the first letters are rendered in European digits.</li>
     * </ul>
     * For example, if <b>uDefaultLanguage</b> indicates LANG_ARABIC, initial digits are in Arabic-Indic in a right-to-left embedding. However, they are in European digits in a left-to-right embedding.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/digit-shapes">Digit Shapes</a>.
     * 
     * The Unicode control characters and definitions, and their effects on <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> members, are provided in the following table. For more information on Unicode control characters, see the <a href="https://www.unicode.org/standard/standard.html">The Unicode Standard</a>.
     * 
     * <table>
     * <tr>
     * <th>Unicode control characters</th>
     * <th>Meaning</th>
     * <th>Effect on SCRIPT_STATE</th>
     * </tr>
     * <tr>
     * <td>NADS</td>
     * <td>Override European digits (NODS) with national digit shapes.</td>
     * <td>Set <b>fDigitSubstitute</b>.</td>
     * </tr>
     * <tr>
     * <td>NODS</td>
     * <td>Use nominal digit shapes, otherwise known as European digits. See NADS.</td>
     * <td>Clear <b>fDigitSubstitute</b>.</td>
     * </tr>
     * <tr>
     * <td>ASS</td>
     * <td>Activate swapping of symmetric pairs, for example, parentheses. For these characters, left and right are interpreted as opening and closing. This is the default. See ISS.</td>
     * <td>Clear <b>fInhibitSymSwap</b>.</td>
     * </tr>
     * <tr>
     * <td>ISS</td>
     * <td>Inhibit swapping of symmetric pairs. See ASS.</td>
     * <td>Set <b>fInhibitSymSwap</b>.</td>
     * </tr>
     * <tr>
     * <td>AAFS</td>
     * <td>Activate Arabic form shaping for Arabic presentation forms. See IAFS.</td>
     * <td>Set <b>fCharShape</b>.</td>
     * </tr>
     * <tr>
     * <td>IAFS</td>
     * <td>Inhibit Arabic form shaping, that is, ligatures and cursive connections, for Arabic presentation forms. Nominal Arabic characters are not affected. This is the default. See AAFS.</td>
     * <td>Clear <b>fCharShape</b>.</td>
     * </tr>
     * </table>
     *  
     * 
     * The <b>fArabicNumContext</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> supports the context-sensitive display of numerals in Arabic script text. It indicates if digits are rendered using native Arabic script digit shapes or European digits. At the beginning of a paragraph, this member should normally be initialized to <b>TRUE</b> for an Arabic locale, or <b>FALSE</b> for any other locale. The function updates the script state it as it processes strong text.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} pwcInChars Pointer to a Unicode string to itemize.
     * @param {Integer} cInChars Number of characters in <i>pwcInChars</i> to itemize.
     * @param {Integer} cMaxItems Maximum number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures defining items to process.
     * @param {Pointer<UInt32>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure indicating the type of itemization to perform.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if no <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> properties are needed. For more information, see the Remarks section.
     * @param {Pointer<UInt16>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure indicating the initial bidirectional algorithm state.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if the script state is not needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ITEM>} pItems Pointer to a buffer in which the function retrieves <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures representing the items that have been processed. The buffer should be  <c>(cMaxItems + 1) * sizeof(SCRIPT_ITEM)</c> bytes in length. It is invalid to call this function with a buffer to hold less than two <b>SCRIPT_ITEM</b> structures. The function always adds a terminal item to the item analysis array so that the length of the item with zero-based index "i" is always available as:
     * 
     * <c>pItems[i+1].iCharPos - pItems[i].iCharPos;</c>
     * @param {Pointer<Int32>} pcItems Pointer to the number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures processed.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * The function returns E_INVALIDARG if <i>pwcInChars</i> is set to <b>NULL</b>, <i>cInChars</i> is 0, <i>pItems</i> is set to <b>NULL</b>, or <i>cMaxItems</i> &lt; 2.
     * 
     * The function returns E_OUTOFMEMORY if the value of <i>cMaxItems</i> is insufficient. As in all error cases, no items are fully processed and no part of the output array contains defined values. If the function returns E_OUTOFMEMORY, the application can call it again with a larger <i>pItems</i> buffer.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptitemize
     * @since windows5.0
     */
    static ScriptItemize(pwcInChars, cInChars, cMaxItems, psControl, psState, pItems, pcItems) {
        result := DllCall("USP10.dll\ScriptItemize", "ptr", pwcInChars, "int", cInChars, "int", cMaxItems, "ptr", psControl, "ptr", psState, "ptr", pItems, "ptr", pcItems, "int")
        return result
    }

    /**
     * Converts an array of run embedding levels to a map of visual-to-logical position and/or logical-to-visual position.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function handles only data that pertains to a single line of text.
     * 
     * The run embedding levels are defined in the Unicode bidirectional algorithm. They describe the direction of a run, the direction of any runs in which it is embedded, and the direction of the paragraph. No other input is required for the call to this function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/unicode">Unicode</a>.
     * 
     * The following table lists the predefined embedding levels. The application can add levels as needed.
     * 
     * <table>
     * <tr>
     * <th>Level</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>A left-to-right run in a left-to-right paragraph.</td>
     * </tr>
     * <tr>
     * <td>1</td>
     * <td>A right-to-left run embedded in a left-to-right run in a left-to-right paragraph. Alternatively, a right-to-left run, not embedded in another run, in a right-to-left paragraph.</td>
     * </tr>
     * <tr>
     * <td>2</td>
     * <td>A left-to-right run embedded in a right-to-left run of type 1.</td>
     * </tr>
     * <tr>
     * <td>3</td>
     * <td>A right-to-left run embedded in a left-to-right run of type 2.</td>
     * </tr>
     * </table>
     *  
     * 
     * A "logical position" refers to the placement of a run relative to other runs. It is the position in a backing store, and corresponds to the order in which the user reads the text aloud. The "visual position" of a run refers to the way the run is visually displayed on the line, taking into account the possible directions that the run can have.
     * 
     * The application can call this function setting either <i>piLogicalToVisual</i> or <i>piVisualToLogical</i>, or both.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Integer} cRuns Number of runs to process.
     * @param {Pointer<Byte>} pbLevel Pointer to an array, of length indicated by <i>cRuns</i>, containing run embedding levels. Embedding levels for all runs on the line must be included, ordered logically. For more information, see the Remarks section.
     * @param {Pointer<Int32>} piVisualToLogical Pointer to an array, of length indicated by <i>cRuns</i>, in which this function retrieves the run embedding levels reordered to visual order. The first array element represents the run to display at the far left, and subsequent entries should be displayed progressing from left to right. The function sets this parameter to <b>NULL</b> if there is no output.
     * @param {Pointer<Int32>} piLogicalToVisual Pointer to an array, of length indicated by <i>cRuns</i>, in which this function retrieves the visual run positions. The first array element is the relative visual position where the first logical run should be displayed, the leftmost display position being 0. The function sets this parameter to <b>NULL</b> if there is no output.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptlayout
     * @since windows5.0
     */
    static ScriptLayout(cRuns, pbLevel, piVisualToLogical, piLogicalToVisual) {
        result := DllCall("USP10.dll\ScriptLayout", "int", cRuns, "ptr", pbLevel, "ptr", piVisualToLogical, "ptr", piLogicalToVisual, "int")
        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * If this function returns E_OUTOFMEMORY, the application might call <b>ScriptShape</b> repeatedly, with successively larger output buffers, until a large enough buffer is provided. The number of glyphs generated by a code point varies according to the script and the font. For a simple script, a Unicode code point might generate a single glyph. However, a complex script font might construct characters from components, and thus generate several times as many glyphs as characters. Also, there are special cases, such as invalid character representations, in which extra glyphs are added to represent the invalid sequence. Therefore, a reasonable guess for the size of the buffer indicated by <i>pwOutGlyphs</i> is 1.5 times the length of the character buffer, plus an additional 16 glyphs for rare cases, for example, invalid sequence representation.
     * 
     * This function can set the <b>fNoGlyphIndex</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure if the font or operating system cannot support glyph indexes.
     * 
     * The application can call <b>ScriptShape</b> to determine if a font supports the characters in a given string. If the function returns S_OK, the application should check the output for missing glyphs. If <b>fLogicalOrder</b> is set to <b>TRUE</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure, the function always generates glyphs in the same order as the original Unicode characters. If <b>fLogicalOrder</b> is set to <b>FALSE</b>, the function generates right-to-left items in reverse order so that <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a> does not have to reverse them before calling <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a>.
     * 
     * If the <b>eScript</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> is set to SCRIPT_UNDEFINED, shaping is disabled. In this case, <b>ScriptShape</b> displays the glyph that is in the font cmap table. If no glyph is in the table, the function indicates that glyphs are missing.
     * 
     * <b>ScriptShape</b> sequences clusters uniformly within the run, and sequences glyphs uniformly within a cluster. It uses the value of the <b>fRTL</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a>, from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>, to identify sequencing as left-to-right or right-to-left.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<PWSTR>} pwcChars Pointer to an array of Unicode characters defining the run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Integer} cMaxGlyphs Maximum number of glyphs to generate, and the length of <i>pwOutGlyphs</i>. A reasonable value is <c>(1.5 * cChars + 16)</c>, but this value might be insufficient in some circumstances. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure for the run, containing the results from an earlier call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<UInt16>} pwOutGlyphs Pointer to a buffer in which this function retrieves an array of glyphs with size as indicated by <i>cMaxGlyphs</i>.
     * @param {Pointer<UInt16>} pwLogClust Pointer to a buffer in which this function retrieves an array of logical cluster information. Each array element corresponds to a character in the array of Unicode characters; therefore this array has the number of elements indicated by cChars. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member is set to <b>TRUE</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure, the elements decrease as the array is read.
     * @param {Pointer<UInt16>} psva Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures containing visual attribute information. Since each glyph has only one visual attribute, this array has the number of elements indicated by <i>cMaxGlyphs</i>.
     * @param {Pointer<Int32>} pcGlyphs Pointer to the location in which this function retrieves the number of glyphs indicated in <i>pwOutGlyphs</i>.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, the content of all output parameters is undefined.
     * 
     * Error returns include:
     * 
     * <ul>
     * <li>E_OUTOFMEMORY. The output buffer length indicated by <i>cMaxGlyphs</i> is insufficient.</li>
     * <li>E_PENDING. The script cache specified by the <i>psc</i> parameter does not contain enough information to shape the string, and the device context has been passed as <b>NULL</b> so that the function is unable to complete the shaping process. The application should set up a correct device context for the run, and call this function again with the appropriate value in <i>hdc</i> and with all other parameters the same.</li>
     * <li>USP_E_SCRIPT_NOT_IN_FONT. The font corresponding to the device context does not support the script required by the run indicated by <i>pwcChars</i>. The application should choose another font, using either <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetcmap">ScriptGetCMap</a> or another function to select the font.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptshape
     * @since windows5.0
     */
    static ScriptShape(hdc, psc, pwcChars, cChars, cMaxGlyphs, psa, pwOutGlyphs, pwLogClust, psva, pcGlyphs) {
        result := DllCall("USP10.dll\ScriptShape", "ptr", hdc, "ptr", psc, "ptr", pwcChars, "int", cChars, "int", cMaxGlyphs, "ptr", psa, "ptr", pwOutGlyphs, "ptr", pwLogClust, "ptr", psva, "ptr", pcGlyphs, "int")
        return result
    }

    /**
     * Generates glyph advance width and two-dimensional offset information from the output of ScriptShape.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * The composite ABC width for the whole item identifies how much the glyphs <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">overhang</a> to the left of the start position and to the right of the length implied by the sum of the advance widths. The total advance width of the line is exactly abcA+abcB+abcC. The abcA and abcC values are maintained as proportions of the cell height represented in 8 bits and are thus roughly +/-1 percent. The total width retrieved, which is the sum of the abcA+abcB+abcC values indicated by <i>piAdvance</i>, is accurate to the resolution of the TrueType shaping engine.
     * 
     * All arrays are in visual order unless the <b>fLogicalOrder</b> member is set in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by the <i>psa</i> parameter.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<UInt16>} pwGlyphs Pointer to a glyph buffer obtained from an earlier call to the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> function.
     * @param {Integer} cGlyphs Count of glyphs in the glyph buffer.
     * @param {Pointer<UInt16>} psva Pointer to an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures indicating visual attributes.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. On input, this structure is obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>. On output, this structure contains values retrieved by <b>ScriptPlace</b>.
     * @param {Pointer<Int32>} piAdvance Pointer to an array in which this function retrieves advance width information.
     * @param {Pointer<GOFFSET>} pGoffset Optional. Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structures in which this function retrieves the x and y offsets of combining glyphs. This array must be of length indicated by <i>cGlyphs</i>.
     * @param {Pointer<ABC>} pABC Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-abc">ABC</a> structure in which this function retrieves the <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> for the entire <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">run</a>.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * The function returns E_PENDING if the script cache specified by the <i>psc</i> parameter does not contain enough information to place the glyphs, and the <i>hdc</i> parameter is set to <b>NULL</b> so that the function cannot complete the placement process. The application should set up a correct device context for the run, and call this function again with the appropriate device context and with all other parameters the same.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptplace
     * @since windows5.0
     */
    static ScriptPlace(hdc, psc, pwGlyphs, cGlyphs, psva, psa, piAdvance, pGoffset, pABC) {
        result := DllCall("USP10.dll\ScriptPlace", "ptr", hdc, "ptr", psc, "ptr", pwGlyphs, "int", cGlyphs, "ptr", psva, "ptr", psa, "ptr", piAdvance, "ptr", pGoffset, "ptr", pABC, "int")
        return result
    }

    /**
     * Displays text for the specified script shape and place information.
     * @remarks
     * This function calls the operating system <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a> function for text display. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a>.
     * 
     * All arrays are in display order unless the <b>fLogicalOrder</b> member is set in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by <i>psa</i>.
     * 
     * For any run that is rendered right-to-left and was generated in logical order by forcing the <b>fLogicalOrder</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a>, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-settextalign">SetTextAlign</a> (hdc, TA_RIGHT) and give the right-side coordinate before calling <b>ScriptTextOut</b>.
     * 
     * The array indicated by <i>piJustify</i> provides cell widths for each glyph. When the width of a glyph differs from the unjustified width, specified by <i>piAdvance</i>, space is added to or removed from the glyph cell at its trailing edge. The glyph is always aligned with the leading edge of its cell. This rule applies even in visual order.
     * 
     * When a glyph cell is extended, the extra space is usually made up by the addition of white space. However, for Arabic scripts, the extra space is made up by one or more kashida glyphs, unless the extra space is insufficient for the shortest kashida glyph in the font. The width of the shortest kashida is available by calling <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetfontproperties">ScriptGetFontProperties</a>.
     * 
     * The application should pass a value for <i>piJustify</i> only if the string must be justified by <b>ScriptTextOut</b>. Normally, the application should pass <b>NULL</b>.
     * 
     * The application should not use <b>ScriptTextOut</b> to write to a metafile unless the metafile will be played back without any font substitution, for example, immediately on the same system for scalable page preview. <b>ScriptTextOut</b> records glyph numbers in the metafile. Since glyph numbers vary considerably from one font to another, the file is unlikely to play back correctly when different fonts are substituted. For example, when a metafile is played back at a different scale, a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createfonta">CreateFont</a> request recorded in the metafile can resolve to a bitmap instead of a TrueType font. Likewise, if the metafile is played back on a different computer, the requested fonts might not be installed. To write complex scripts in a metafile in a font-independent manner, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a> to write the logical characters directly, so that glyph generation and placement do not occur until the text is played back.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>. Note that, unlike some other related Uniscribe functions, this function defines the handle as mandatory.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Integer} x Value of the x coordinate of the first glyph.
     * @param {Integer} y Value of the y coordinate of the first glyph.
     * @param {Integer} fuOptions Options equivalent to the <i>fuOptions</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a>. This parameter can be set to either ETO_CLIPPED or ETO_OPAQUE, to both values, or to neither value.
     * @param {Pointer<RECT>} lprc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the rectangle used to clip the display. The application can set this parameter to <b>NULL</b>.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<UInt16>} pwGlyphs Pointer to an array of glyphs obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>.
     * @param {Integer} cGlyphs Count of the glyphs in the array indicated by <i>pwGlyphs</i>. The maximum number of glyphs is 65,536.
     * @param {Pointer<Int32>} piAdvance Pointer to an array of advance widths obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<Int32>} piJustify Pointer to an array of justified advance widths (cell widths). The application can set this parameter to <b>NULL</b>.
     * @param {Pointer<GOFFSET>} pGoffset Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structure containing the x and y offsets for the combining glyph.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scripttextout
     * @since windows5.0
     */
    static ScriptTextOut(hdc, psc, x, y, fuOptions, lprc, psa, pwGlyphs, cGlyphs, piAdvance, piJustify, pGoffset) {
        static pwcReserved := 0, iReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("USP10.dll\ScriptTextOut", "ptr", hdc, "ptr", psc, "int", x, "int", y, "uint", fuOptions, "ptr", lprc, "ptr", psa, "ptr", pwcReserved, "int", iReserved, "ptr", pwGlyphs, "int", cGlyphs, "ptr", piAdvance, "ptr", piJustify, "ptr", pGoffset, "int")
        return result
    }

    /**
     * Creates an advance widths table to allow text justification when passed to the ScriptTextOut function.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function provides a simple implementation of multilingual justification. It establishes the amount of adjustment to make at each glyph position on the line. It interprets the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> array generated by a call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>, giving top priority to kashida. The function uses interword spacing if no kashida points are available. It uses intercharacter spacing if no interword points are available.
     * 
     * <div class="alert"><b>Note</b>  Sophisticated text formatters might generate their own delta dx array by combining formatter-specific features with the information retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> array.</div>
     * <div> </div>
     * The application should pass the justified advance widths generated by <b>ScriptJustify</b> to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a> in the <i>piJustify</i> parameter.
     * 
     * <b>ScriptJustify</b> creates a justified array containing updated advance widths for each glyph. When an advance width for a glyph is increased, the extra width is rendered to the right of the glyph, with a white space or, for Arabic text, a kashida.
     * 
     * <div class="alert"><b>Note</b>  Kashida insertion occurs to the right of the glyph to justify visually. Microsoft Word and Microsoft PowerPoint use this concept. Any change in the kashida placement algorithm should accompany a change in the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a> handler for a particular script, for example, the Arabic TextOut justification handler.</div>
     * <div> </div>
     * Sometimes the application tries to handle glyphs that cannot be justified, in which case the <b>uJustification</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> is set to SCRIPT_JUSTIFY_NONE. In this case, <b>ScriptJustify</b> copies the input array indicated by <i>piAdvance</i> to the output array indicated by <i>piJustify</i> and returns S_FALSE to the application.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<UInt16>} psva Pointer to an array, of length indicated by <i>cGlyphs</i>, containing <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures. Each structure contains visual attributes for a glyph in the line to process.
     * @param {Pointer<Int32>} piAdvance Pointer to an advance widths array, of length indicated by <i>cGlyphs</i>, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Integer} cGlyphs Count of glyphs for the arrays indicated by <i>psva</i> and <i>piAdvance</i>. This parameter also indicates the count of glyphs for the output parameter <i>piJustify</i>.
     * @param {Integer} iDx Width, in pixels, of the desired change, either an increase of decrease.
     * @param {Integer} iMinKashida Minimum width of a kashida glyph to generate.
     * @param {Pointer<Int32>} piJustify Pointer to a buffer in which this function retrieves an array, of length indicated by <i>cGlyphs</i>, containing justified advance widths. The justified widths are sometimes called "cell widths" to distinguish them from unjustified advance widths.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptjustify
     * @since windows5.0
     */
    static ScriptJustify(psva, piAdvance, cGlyphs, iDx, iMinKashida, piJustify) {
        result := DllCall("USP10.dll\ScriptJustify", "ptr", psva, "ptr", piAdvance, "int", cGlyphs, "int", iDx, "int", iMinKashida, "ptr", piJustify, "int")
        return result
    }

    /**
     * Retrieves information for determining line breaks.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function does not require a device context and does not perform glyph shaping.
     * 
     * This function retrieves cursor movement and formatting break positions for an item in an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structures. To support mixed formatting within a single word correctly, the call to <b>ScriptBreak</b> should pass whole items as retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>, and not the finer formatting runs.
     * 
     * The <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structure identifies valid caret positions and line breaks. The <b>fCharStop</b> member specifies a flag that marks cluster boundaries for scripts that are conventionally restricted from moving inside clusters. The same boundaries can also be inferred by inspecting the logical cluster information retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>. However, <b>ScriptBreak</b> is considerably faster in implementation and does not require a device context to be prepared.
     * 
     * The flags designated by the <b>fWordStop</b>, <b>fSoftBreak</b>, and <b>fWhiteSpace</b> members of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> are only available through <b>ScriptBreak</b>.
     * 
     * Most shaping engines that identify invalid sequences set the flag indicated by the <b>fInvalid</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> in <b>ScriptBreak</b>. The <b>fInvalidLogAttr</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> identifies the applicable scripts.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} pwcChars Pointer to the Unicode characters to process.
     * @param {Integer} cChars Number of Unicode characters to process.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from an earlier call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<Byte>} psla Pointer to a buffer in which this function retrieves the character attributes as a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structure.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptbreak
     * @since windows5.0
     */
    static ScriptBreak(pwcChars, cChars, psa, psla) {
        result := DllCall("USP10.dll\ScriptBreak", "ptr", pwcChars, "int", cChars, "ptr", psa, "ptr", psla, "int")
        return result
    }

    /**
     * Generates the x offset from the left end or leading edge of a run to either the leading or trailing edge of a logical character cluster.
     * @remarks
     * The leading or trailing edge of the character and the leading edge of a run depend on the direction of text in the run.
     * 
     * For scripts in which the caret is conventionally placed in the middle of clusters (for example, Arabic and Hebrew), the retrieved x position of the carat can be an interpolated position for any code point in the line.
     * 
     * For scripts in which the caret is conventionally snapped to the boundaries of clusters (for example, Thai and Indian), the x position is snapped to the requested edge of the cluster containing the logical character position indicated by <i>iCP</i>.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Integer} iCP Logical character position in the run. This parameter corresponds to the offset of any logical character in the cluster.
     * @param {Integer} fTrailing <b>TRUE</b> to use the trailing edge of the logical character cluster to compute the offset. This parameter is set to <b>FALSE</b> to use the leading edge of the logical character cluster.
     * @param {Integer} cChars Number of characters in the run.
     * @param {Integer} cGlyphs Number of glyphs in the run.
     * @param {Pointer<UInt16>} pwLogClust Pointer to the logical clusters.
     * @param {Pointer<UInt16>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> array of visual attributes.
     * @param {Pointer<Int32>} piAdvance Pointer to an advance widths value.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. The <b>fLogicalOrder</b> member specifies the end of the run from which to measure the offset. If the flag is set, the leading edge of the run is used. If the flag is not set, the left end of the run is used.
     * @param {Pointer<Int32>} piX Pointer to the buffer in which the function retrieves the x position of the caret.
     * @returns {Integer} Returns 0 if successful. This function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptcptox
     * @since windows5.0
     */
    static ScriptCPtoX(iCP, fTrailing, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, piX) {
        result := DllCall("USP10.dll\ScriptCPtoX", "int", iCP, "int", fTrailing, "int", cChars, "int", cGlyphs, "ptr", pwLogClust, "ptr", psva, "ptr", piAdvance, "ptr", psa, "ptr", piX, "int")
        return result
    }

    /**
     * Generates the leading or trailing edge of a logical character cluster from the x offset of a run.
     * @remarks
     * The values passed to this function normally are the results of earlier calls to other Uniscribe functions. See <a href="https://docs.microsoft.com/windows/desktop/Intl/managing-caret-placement-and-hit-testing">Managing Caret Placement and Hit Testing</a> for details.
     * 
     * The leading and trailing edges of the logical character are determined by the direction of text in the run (left-to-right or right-to-left). For the left-to-right direction, the leading edge is the same as the left edge. For the right-to-left direction, the leading edge is the right edge.
     * 
     * For scripts in which the caret is conventionally placed in the middle of a cluster, for example, Arabic and Hebrew, the retrieved character position can be for any code point in the line. In this case, the <i>piTrailing</i> parameter is set to either 0 or 1.
     * 
     * For scripts in which the caret is conventionally snapped to the boundaries of a cluster, the retrieved character position is always the position of the first code point in a cluster (considered logically). The <i>piTrailing</i> parameter is set to 0 or to the number of code points in the cluster.
     * 
     * The appropriate caret position for a mouse hit is always the retrieved character position plus the distance indicated by <i>piTrailing</i>.
     * 
     * When <i>iX</i> indicates a position outside the run, <b>ScriptXtoCP</b> acts as if there is an extra infinitely large character beyond each end of the run. This results in the behavior shown in the following table.
     * 
     * <table>
     * <tr>
     * <th><i>iX</i> position (outside the run)</th>
     * <th>Result</th>
     * </tr>
     * <tr>
     * <td>Before the run, that is: <i>iX</i> &lt; 0 if run is left-to-right, or <i>iX</i> &gt;= sum of advances if run is right-to-left</td>
     * <td>Value of <i>piCP</i> is -1 and value of <i>piTrailing</i> is 0</td>
     * </tr>
     * <tr>
     * <td>After the run, that is: <i>iX</i> &gt;= sum of advances if run is left-to-right, or <i>iX</i> &lt; 0 if run is right-to-left</td>
     * <td>Value of <i>piCP</i> is value of <i>cChars</i> and value of <i>piTrailing</i> is 1</td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Integer} iX Offset, in logical units, from the end of the run specified by the <b>fLogicalOrder</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by the <i>psa</i> parameter.
     * @param {Integer} cChars Count of logical code points in the run.
     * @param {Integer} cGlyphs Count of glyphs in the run.
     * @param {Pointer<UInt16>} pwLogClust Pointer to an array of logical clusters.
     * @param {Pointer<UInt16>} psva Pointer to an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures containing the visual attributes for the glyph.
     * @param {Pointer<Int32>} piAdvance Pointer to an array of advance widths.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. The <b>fLogicalOrder</b> member indicates <b>TRUE</b> to use the leading edge of the run, or <b>FALSE</b> to use the trailing edge.
     * @param {Pointer<Int32>} piCP Pointer to a buffer in which this function retrieves the character position corresponding to the x coordinate.
     * @param {Pointer<Int32>} piTrailing Pointer to a buffer in which this function retrieves the distance, in code points, from the leading edge of the logical character to the <i>iX</i> position. If this value is 0, the <i>iX</i> position is at the leading edge of the logical character. For more information, see the Remarks section.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptxtocp
     * @since windows5.0
     */
    static ScriptXtoCP(iX, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, piCP, piTrailing) {
        result := DllCall("USP10.dll\ScriptXtoCP", "int", iX, "int", cChars, "int", cGlyphs, "ptr", pwLogClust, "ptr", psva, "ptr", piAdvance, "ptr", psa, "ptr", piCP, "ptr", piTrailing, "int")
        return result
    }

    /**
     * Converts the glyph advance widths for a specific font into logical widths.
     * @remarks
     * This function is useful for recording widths in a font-independent manner. It converts the glyph advance widths calculated for a specific font into logical widths, one per code point, in the same order as the code points. If the same string is then displayed on a different device using a different font, the logical widths can be applied by using <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptapplylogicalwidth">ScriptApplyLogicalWidth</a> to approximate the original placement. This mechanism is useful when implementing print preview. On the preview screen, it is important to match the layout and placement of the final printed result.
     * 
     * <div class="alert"><b>Note</b>  Ligature glyph widths are divided evenly among the characters they represent.</div>
     * <div> </div>
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure.
     * @param {Integer} cChars Count of the logical code points in the run.
     * @param {Integer} cGlyphs Count of the glyphs in the run.
     * @param {Pointer<Int32>} piGlyphWidth Pointer to an array of glyph advance widths.
     * @param {Pointer<UInt16>} pwLogClust Pointer to an array of logical clusters.
     * @param {Pointer<UInt16>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structure defining visual attributes.
     * @param {Pointer<Int32>} piDx Pointer to an array of logical widths.
     * @returns {Integer} Currently returns S_OK in all cases.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetlogicalwidths
     * @since windows5.0
     */
    static ScriptGetLogicalWidths(psa, cChars, cGlyphs, piGlyphWidth, pwLogClust, psva, piDx) {
        result := DllCall("USP10.dll\ScriptGetLogicalWidths", "ptr", psa, "int", cChars, "int", cGlyphs, "ptr", piGlyphWidth, "ptr", pwLogClust, "ptr", psva, "ptr", piDx, "int")
        return result
    }

    /**
     * Takes an array of advance widths for a run and generates an array of adjusted advance glyph widths.
     * @remarks
     * This function can be used to reapply logical widths obtained with <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetlogicalwidths">ScriptGetLogicalWidths</a>. It can be useful in situations such as metafiling, for which advance width information must be recorded and reapplied in a font-independent manner, independent of glyph substitutions, such as ligaturization.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Int32>} piDx Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">advance widths</a> in logical order, one per code point.
     * @param {Integer} cChars Count of the logical code points in the run.
     * @param {Integer} cGlyphs Glyph count.
     * @param {Pointer<UInt16>} pwLogClust Pointer to an array of logical clusters from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>.
     * @param {Pointer<UInt16>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structure from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> and updated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<Int32>} piAdvance Pointer to an array of glyph advance widths from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a> and updated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> and <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<ABC>} pABC Pointer to the overall <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> of a run. On input, the parameter should contain the run ABC widths retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>. On output, the parameter indicates the ABC width updated to match the new widths.
     * @param {Pointer<Int32>} piJustify Pointer to an array in which the function retrieves the glyph advance widths. This array is suitable for passing to the <i>piJustify</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a>.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptapplylogicalwidth
     * @since windows5.0
     */
    static ScriptApplyLogicalWidth(piDx, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, pABC, piJustify) {
        result := DllCall("USP10.dll\ScriptApplyLogicalWidth", "ptr", piDx, "int", cChars, "int", cGlyphs, "ptr", pwLogClust, "ptr", psva, "ptr", piAdvance, "ptr", psa, "ptr", pABC, "ptr", piJustify, "int")
        return result
    }

    /**
     * Retrieves the glyph indexes of the Unicode characters in a string according to either the TrueType cmap table or the standard cmap table implemented for old-style fonts.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function can be used to determine the characters in a run that are supported by the selected font. The application can scan the retrieved glyph buffer, looking for the default glyph to determine characters that are not available. The application should determine the default glyph index for the selected font by calling <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetfontproperties">ScriptGetFontProperties</a>.
     * 
     * The return value for this function indicates the presence of any missing glyphs.
     * 
     * <div class="alert"><b>Note</b>  The function assumes a 1:1 relationship between the elements in the input and output arrays. However, the function does not support this relationship for UTF-16 surrogate pairs. For a surrogate pair, the function does not retrieve the glyph index for the supplementary-plane character. Similarly, the function does not support Unicode Variation-Selector (VS) sequences, each of which consists of a Unicode graphic character followed by one of a set of VARIATION SELECTOR characters to select a particular glyph representation for that graphic character. For a VS sequence, the function retrieves the glyph index for the default glyph mapped by the cmap for the two characters, instead of the glyph index for the particular glyph for the VS sequence.</div>
     * <div> </div>
     * Some code points can be rendered by a combination of glyphs, as well as by a single glyph, for example, 00C9; LATIN CAPITAL LETTER E WITH ACUTE. In this case, if the font supports the capital E glyph and the acute glyph, but not a single glyph for 00C9, <b>ScriptGetCMap</b> shows that 00C9 is unsupported. To determine the font support for a string that contains these kinds of code points, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>. If the function returns S_OK, the application should check the output for missing glyphs.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<PWSTR>} pwcInChars Pointer to a string of Unicode characters.
     * @param {Integer} cChars Number of Unicode characters in the string indicated by <i>pwcInChars</i>.
     * @param {Integer} dwFlags Flags specifying any special handling of the glyphs. By default, the glyphs are provided in logical order with no special handling. This parameter can have the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SGCM_RTL"></a><a id="sgcm_rtl"></a><dl>
     * <dt><b>SGCM_RTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The glyph array indicated by <i>pwOutGlyphs</i> should contain mirrored glyphs for those glyphs that have a mirrored equivalent.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt16>} pwOutGlyphs Pointer to a buffer in which the function retrieves an array of glyph indexes. This buffer should be of the same length as the input buffer indicated by <i>pwcInChars</i>. Each code point maps to a single glyph.
     * @returns {Integer} Returns S_OK if all Unicode code points are present in the font. The function returns one of the nonzero HRESULT values listed below if it does not succeed.
     *             
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>E_HANDLE</td>
     * <td>The font or the operating system does not support glyph indexes.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td>Some of the Unicode code points were mapped to the default glyph.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetcmap
     * @since windows5.0
     */
    static ScriptGetCMap(hdc, psc, pwcInChars, cChars, dwFlags, pwOutGlyphs) {
        result := DllCall("USP10.dll\ScriptGetCMap", "ptr", hdc, "ptr", psc, "ptr", pwcInChars, "int", cChars, "uint", dwFlags, "ptr", pwOutGlyphs, "int")
        return result
    }

    /**
     * Retrieves the ABC width of a given glyph.
     * @remarks
     * This function is limited in its usefulness. For example, it is useful for drawing glyph charts. It should not be used for ordinary complex script text formatting.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Integer} wGlyph Glyph to analyze.
     * @param {Pointer<ABC>} pABC Pointer to the ABC width of the specified glyph.
     * @returns {Integer} Returns S_OK if the ABC width of the glyph is retrieved. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * The function returns E_HANDLE if the font or operating system does not support glyph indexes.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetglyphabcwidth
     * @since windows5.0
     */
    static ScriptGetGlyphABCWidth(hdc, psc, wGlyph, pABC) {
        result := DllCall("USP10.dll\ScriptGetGlyphABCWidth", "ptr", hdc, "ptr", psc, "ushort", wGlyph, "ptr", pABC, "int")
        return result
    }

    /**
     * Retrieves information about the current scripts.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/determining-if-a-script-requires-glyph-shaping">Determining If a Script Requires Glyph Shaping</a> for an example of the use of this function.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<SCRIPT_PROPERTIES>} ppSp Pointer to an array of pointers to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> structures indexed by script.
     * @param {Pointer<Int32>} piNumScripts Pointer to the number of scripts. The valid range for this value is 0 through <i>piNumScripts</i>-1.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetproperties
     * @since windows5.0
     */
    static ScriptGetProperties(ppSp, piNumScripts) {
        result := DllCall("USP10.dll\ScriptGetProperties", "ptr", ppSp, "ptr", piNumScripts, "int")
        return result
    }

    /**
     * Retrieves information from the font cache on the special glyphs used by a font.
     * @remarks
     * The structure retrieved by this function identifies the glyphs that are used for blanks, missing glyphs, invalid combinations, and the smallest kashida.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_FONTPROPERTIES>} sfp Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_fontproperties">SCRIPT_FONTPROPERTIES</a> structure in which this function retrieves the information from the font cache.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontproperties
     * @since windows5.0
     */
    static ScriptGetFontProperties(hdc, psc, sfp) {
        result := DllCall("USP10.dll\ScriptGetFontProperties", "ptr", hdc, "ptr", psc, "ptr", sfp, "int")
        return result
    }

    /**
     * Retrieves the height of the currently cached font.
     * @remarks
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<Int32>} tmHeight Pointer to a buffer in which the function retrieves the font height.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptcachegetheight
     * @since windows5.0
     */
    static ScriptCacheGetHeight(hdc, psc, tmHeight) {
        result := DllCall("USP10.dll\ScriptCacheGetHeight", "ptr", hdc, "ptr", psc, "ptr", tmHeight, "int")
        return result
    }

    /**
     * Analyzes a plain text string.
     * @remarks
     * Use of this function is the first step in handling plain text strings. Such a string has only one font, one style, one size, one color, and so forth. <b>ScriptStringAnalyse</b> allocates temporary buffers for item analyses, glyphs, advance widths, and the like. Then it automatically runs <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>, <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>, <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptbreak">ScriptBreak</a>. The results are available through all the other <b>ScriptString*</b> functions.
     * 
     * On successful return from this function, <i>pssa</i> indicates a dynamically allocated structure that the application can pass successively to the other <b>ScriptString*</b> functions. The application must ultimately free the structure by calling <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringfree">ScriptStringFree</a>.
     * 
     * Although the functionality of <b>ScriptStringAnalyse</b> can be implemented by direct calls to other functions, use of the function itself drastically reduces the amount of code required in the application for plain text handling.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. If <i>dwFlags</i> is set to SSA_GLYPHS, the device context handle is required. If <i>dwFlags</i> is set to SSA_BREAK, the device context handle is optional. If the device context handle is provided, the function inspects the current font in the device context. If the current font is a symbolic font, the function treats the character string as a single neutral SCRIPT_UNDEFINED item.
     * @param {Pointer<Void>} pString Pointer to the string to analyze. The string must have at least one character. It can be a Unicode string or use the character set from a Windows ANSI <a href="https://docs.microsoft.com/windows/desktop/Intl/code-pages">code page</a>, as specified by the <i>iCharset</i> parameter.
     * @param {Integer} cString Length of the string to analyze. The length is measured in characters for an ANSI string or in wide characters for a Unicode string. The length must be at least 1.
     * @param {Integer} cGlyphs Size of the glyph buffer, in WORD values. This size is required. The recommended size is <c>(1.5 * cString + 16)</c>.
     * @param {Integer} iCharset Character set descriptor. If the input string is an ANSI string, this descriptor is set to the character set identifier. If the string is a Unicode string, this descriptor is set to -1.
     * 
     * The following character set identifiers are defined:
     * @param {Integer} dwFlags Flags indicating the analysis that is required. This parameter can have one of the values listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_BREAK"></a><a id="ssa_break"></a><dl>
     * <dt><b>SSA_BREAK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve break flags, that is, character and word stops.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_CLIP"></a><a id="ssa_clip"></a><dl>
     * <dt><b>SSA_CLIP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Clip the string at <i>iReqWidth.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_DZWG"></a><a id="ssa_dzwg"></a><dl>
     * <dt><b>SSA_DZWG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Provide representation glyphs for control characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_FALLBACK"></a><a id="ssa_fallback"></a><dl>
     * <dt><b>SSA_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use fallback fonts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_FIT"></a><a id="ssa_fit"></a><dl>
     * <dt><b>SSA_FIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Justify the string to <i>iReqWidth</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_GCP"></a><a id="ssa_gcp"></a><dl>
     * <dt><b>SSA_GCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve missing glyphs and <i>pwLogClust</i> with <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a> conventions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_GLYPHS"></a><a id="ssa_glyphs"></a><dl>
     * <dt><b>SSA_GLYPHS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Generate glyphs, positions, and attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HIDEHOTKEY"></a><a id="ssa_hidehotkey"></a><dl>
     * <dt><b>SSA_HIDEHOTKEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Remove the first "&amp;" from displayed string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HOTKEY"></a><a id="ssa_hotkey"></a><dl>
     * <dt><b>SSA_HOTKEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Replace "&amp;" with underline on subsequent code point.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HOTKEYONLY"></a><a id="ssa_hotkeyonly"></a><dl>
     * <dt><b>SSA_HOTKEYONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Display underline only. The resulting bit pattern might be displayed, using an XOR mask, to toggle the visibility of the hotkey underline without disturbing the text.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_LINK"></a><a id="ssa_link"></a><dl>
     * <dt><b>SSA_LINK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Apply East Asian font linking and association to noncomplex text.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_METAFILE"></a><a id="ssa_metafile"></a><dl>
     * <dt><b>SSA_METAFILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write items with <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOutW</a> calls, not with glyphs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_PASSWORD"></a><a id="ssa_password"></a><dl>
     * <dt><b>SSA_PASSWORD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Duplicate input string containing a single character <i>cString</i> times.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_RTL"></a><a id="ssa_rtl"></a><dl>
     * <dt><b>SSA_RTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use base embedding level 1.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_TAB"></a><a id="ssa_tab"></a><dl>
     * <dt><b>SSA_TAB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Expand tabs.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} iReqWidth Width required for fitting or clipping.
     * @param {Pointer<UInt32>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure. The application can set this parameter to <b>NULL</b> to indicate that all <b>SCRIPT_CONTROL</b> members are set to 0.
     * @param {Pointer<UInt16>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure. The application can set this parameter to <b>NULL</b> to indicate that all <b>SCRIPT_STATE</b> members are set to 0. The <b>uBidiLevel</b> member of <b>SCRIPT_STATE</b> is ignored. The value used is derived from the SSA_RTL flag in combination with the layout of the device context.
     * @param {Pointer<Int32>} piDx Pointer to the requested logical dx array.
     * @param {Pointer<SCRIPT_TABDEF>} pTabdef Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_tabdef">SCRIPT_TABDEF</a> structure. This value is only required if <i>dwFlags</i> is set to SSA_TAB.
     * @param {Pointer<Byte>} pbInClass Pointer to a BYTE value that indicates <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a> character classifications.
     * @param {Pointer<Void>} pssa Pointer to a buffer in which this function retrieves a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure. This structure is dynamically allocated on successful return from the function.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * Error returns include:
     *     <ul>
     * <li>E_INVALIDARG. An invalid parameter is found.</li>
     * <li>USP_E_SCRIPT_NOT_IN_FONT. SSA_FALLBACK has not been specified, or a standard fallback font is missing.</li>
     * </ul>
     * 
     * 
     * The function can also return a system error converted to an HRESULT type. An example is an error returned due to lack of memory or a GDI call using the device context.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringanalyse
     * @since windows5.0
     */
    static ScriptStringAnalyse(hdc, pString, cString, cGlyphs, iCharset, dwFlags, iReqWidth, psControl, psState, piDx, pTabdef, pbInClass, pssa) {
        result := DllCall("USP10.dll\ScriptStringAnalyse", "ptr", hdc, "ptr", pString, "int", cString, "int", cGlyphs, "int", iCharset, "uint", dwFlags, "int", iReqWidth, "ptr", psControl, "ptr", psState, "ptr", piDx, "ptr", pTabdef, "ptr", pbInClass, "ptr", pssa, "int")
        return result
    }

    /**
     * Frees a SCRIPT_STRING_ANALYSIS structure.
     * @remarks
     * When your application is finished with a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure, it should free the associated memory by calling this function. After this function is called, the pointers retrieved from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>, <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_plogattr">ScriptString_pLogAttr</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_psize">ScriptString_pSize</a> that are associated with the <i>pssa</i> parameter are invalid.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} pssa Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringfree
     * @since windows5.0
     */
    static ScriptStringFree(pssa) {
        result := DllCall("USP10.dll\ScriptStringFree", "ptr", pssa, "int")
        return result
    }

    /**
     * Returns a pointer to a SIZE structure for an analyzed string.
     * @remarks
     * The size returned by this function is the size before the effect of the justification requested by setting the SSA_FIT flag in <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>. The difference between the value of <i>iReqWidth</i> in <b>ScriptStringAnalyse</b> and the size returned by <b>ScriptString_pSize</b> is the effect of justification.
     * 
     * The pointer returned by this function is valid only until the application passes the associated <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringfree">ScriptStringFree</a>.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for a string.
     * @returns {Pointer<SIZE>} Returns a pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-size">SIZE</a> structure containing the size (width and height) of the analyzed string if successful. The function returns <b>NULL</b> if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstring_psize
     * @since windows5.0
     */
    static ScriptString_pSize(ssa) {
        result := DllCall("USP10.dll\ScriptString_pSize", "ptr", ssa, "ptr")
        return result
    }

    /**
     * Returns a pointer to the length of a string after clipping.
     * @remarks
     * To use this function, the application needs to specify SSA_CLIP in its original call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>.
     * 
     * The pointer returned by this function is valid only until the application passes the associated <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringfree">ScriptStringFree</a>.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @returns {Pointer<Int32>} Returns a pointer to the length of the string after clipping if successful. The length is the number of Unicode code points. The function returns <b>NULL</b> if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstring_pcoutchars
     * @since windows5.0
     */
    static ScriptString_pcOutChars(ssa) {
        result := DllCall("USP10.dll\ScriptString_pcOutChars", "ptr", ssa, "ptr")
        return result
    }

    /**
     * Returns a pointer to a logical attributes buffer for an analyzed string.
     * @remarks
     * The pointer returned by this function is valid only until the application passes the associated <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringfree">ScriptStringFree</a>.
     * 
     * The logical attribute buffer contains at least the number of integers indicated by the <i>ssa</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>.
     * 
     * When scanning the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> array for a word break point, the application should look backward for the values of the <b>fWordStop</b> and <b>fWhiteSpace</b> members. <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a> just calls <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptbreak">ScriptBreak</a> on each run, and <b>ScriptBreak</b> never sets <b>fWordBreak</b> on the first character of a run, because it has no information that the previous run ended in white space.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @returns {Pointer<Byte>} Returns a pointer to a buffer containing <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structures defining logical attributes if successful. The function returns <b>NULL</b> if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstring_plogattr
     * @since windows5.0
     */
    static ScriptString_pLogAttr(ssa) {
        result := DllCall("USP10.dll\ScriptString_pLogAttr", "ptr", ssa, "ptr")
        return result
    }

    /**
     * Creates an array that maps an original character position to a glyph position.
     * @remarks
     * When the number of glyphs and the number of characters are equal, the function retrieves an array that references every glyph. This is the same treatment that occurs in <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a>.
     * 
     * To use this function, the application needs to specify SSA_GLYPHS in its original call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Pointer<UInt32>} puOrder Pointer to a buffer in which this function retrieves an array of glyph positions, indexed by the original character position. The array should have room for at least the number of integers indicated by the <i>ssa</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringgetorder
     * @since windows5.0
     */
    static ScriptStringGetOrder(ssa, puOrder) {
        result := DllCall("USP10.dll\ScriptStringGetOrder", "ptr", ssa, "ptr", puOrder, "int")
        return result
    }

    /**
     * Retrieves the x coordinate for the leading or trailing edge of a character position.
     * @remarks
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} icp Character position in the string.
     * @param {Integer} fTrailing <b>TRUE</b> to indicate the trailing edge of the character position (<i>icp</i>) that corresponds to the x coordinate. This parameter is set to <b>FALSE</b> to indicate the leading edge of the character position.
     * @param {Pointer<Int32>} pX Pointer to a buffer in which this function retrieves the x coordinate corresponding to the character position.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringcptox
     * @since windows5.0
     */
    static ScriptStringCPtoX(ssa, icp, fTrailing, pX) {
        result := DllCall("USP10.dll\ScriptStringCPtoX", "ptr", ssa, "int", icp, "int", fTrailing, "ptr", pX, "int")
        return result
    }

    /**
     * Converts an x coordinate to a character position.
     * @remarks
     * If the x coordinate corresponds to the leading edge of the character, the value of <i>piTrailing</i> is 0. If the x coordinate corresponds to the trailing edge of the character, the value of <i>piTrailing</i> is a positive integer. As for <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptxtocp">ScriptXtoCP</a>, the value is 1 for a character that can be rendered on its own. The value is greater than 1 if the character is part of a cluster in a script for which cursors are not placed within a cluster, to indicate the offset to the next legitimate logical cursor position.
     * 
     * If the x coordinate is before the beginning of the line, the function retrieves -1 for <i>piCh</i> and 1 for <i>piTrailing</i>, indicating the trailing edge of the nonexistent character before the line. If the x coordinate is after the end of the line, the function retrieves for <i>piCh</i> the first index beyond the length of the line and 0 for <i>piTrailing</i>. The 0 value indicates the leading edge of the nonexistent character after the line.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} iX The x coordinate.
     * @param {Pointer<Int32>} piCh Pointer to a variable in which this function retrieves the character position corresponding to the x coordinate.
     * @param {Pointer<Int32>} piTrailing Pointer to a variable in which this function retrieves a value indicating if the x coordinate is for the leading edge or the trailing edge of the character position. For more information, see the Remarks section.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringxtocp
     * @since windows5.0
     */
    static ScriptStringXtoCP(ssa, iX, piCh, piTrailing) {
        result := DllCall("USP10.dll\ScriptStringXtoCP", "ptr", ssa, "int", iX, "ptr", piCh, "ptr", piTrailing, "int")
        return result
    }

    /**
     * Converts visual widths into logical widths.
     * @remarks
     * This function converts the visual widths generated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a> into logical widths, one per original character, in logical order.
     * 
     * To use this function, the application needs to specify SSA_GLYPHS in its original call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Pointer<Int32>} piDx Pointer to a buffer in which this function retrieves logical widths. The buffer should have room for at least the number of integers indicated by the <i>ssa</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringgetlogicalwidths
     * @since windows5.0
     */
    static ScriptStringGetLogicalWidths(ssa, piDx) {
        result := DllCall("USP10.dll\ScriptStringGetLogicalWidths", "ptr", ssa, "ptr", piDx, "int")
        return result
    }

    /**
     * Checks a SCRIPT_STRING_ANALYSIS structure for invalid sequences.
     * @remarks
     * This function is intended for use in editors that reject the input of invalid sequences.
     * 
     * Invalid sequences are only checked for scripts with the <b>fRejectInvalid</b> member set in the associated <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> structure. For example, it is conventional for Notepad to reject invalid Thai character sequences. However, invalid Indian sequences are not conventionally rejected, but instead are displayed in composition with a missing base character symbol.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for a string.
     * @returns {Integer} Returns S_OK if no invalid sequences are found. The function returns S_FALSE if one or more invalid sequences are found. The function returns a nonzero HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringvalidate
     * @since windows5.0
     */
    static ScriptStringValidate(ssa) {
        result := DllCall("USP10.dll\ScriptStringValidate", "ptr", ssa, "int")
        return result
    }

    /**
     * Displays a string generated by a prior call to ScriptStringAnalyse and optionally adds highlighting.
     * @remarks
     * To use this function, the application needs to specify SSA_GLYPHS in its original call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>.
     * 
     * The application should not use <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-settextalign">SetTextAlign</a> with TA_UPDATECP when using <b>ScriptStringOut</b> because selected text cannot be rendered correctly. If the application must use this flag, it can unset and reset the flag as necessary to avoid the problem.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} iX The x-coordinate of the reference point used to position the string.
     * @param {Integer} iY The y-coordinate of the reference point used to position the string.
     * @param {Integer} uOptions 
     * @param {Pointer<RECT>} prc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that defines the rectangle to use. If <i>uOptions</i> is set to ETO_OPAQUE and <b>NULL</b> is provided for <i>prc</i>, the function succeeds and returns S_OK. However, if the application sets <i>uOptions</i> to ETO_CLIPPING and provides <b>NULL</b> for <i>prc</i>, the function returns E_INVALIDARG. The application can set this parameter to <b>NULL</b> to indicate that no option is needed.
     * @param {Integer} iMinSel Zero-based index specifying the starting position in the string. For no selection, the application should set <i>iMinSel</i> &gt;= <i>iMaxSel</i>.
     * @param {Integer} iMaxSel Zero-based index specifying the ending position in the string.
     * @param {Integer} fDisabled <b>TRUE</b> if the operating system applies disabled-text highlighting by setting the background color to COLOR_HIGHLIGHT behind all selected characters. The application can set this parameter to <b>FALSE</b> if the operating system applies enabled-text highlighting by setting the background color to COLOR_HIGHLIGHT and the text color to COLOR_HIGHLIGHTTEXT for each selected character.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero <b>HRESULT</b> value if it does not succeed. The application can't test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringout
     * @since windows5.0
     */
    static ScriptStringOut(ssa, iX, iY, uOptions, prc, iMinSel, iMaxSel, fDisabled) {
        result := DllCall("USP10.dll\ScriptStringOut", "ptr", ssa, "int", iX, "int", iY, "uint", uOptions, "ptr", prc, "int", iMinSel, "int", iMaxSel, "int", fDisabled, "int")
        return result
    }

    /**
     * Determines whether a Unicode string requires complex script processing.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} pwcInChars Pointer to the string to test.
     * @param {Integer} cInChars Length of the input string, in characters.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns S_OK if the string requires complex script processing. The function returns S_FALSE if the string can be handled by standard API function calls, that is, it contains only characters laid out side-by-side and left-to-right. The function returns a nonzero HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptiscomplex
     * @since windows5.0
     */
    static ScriptIsComplex(pwcInChars, cInChars, dwFlags) {
        result := DllCall("USP10.dll\ScriptIsComplex", "ptr", pwcInChars, "int", cInChars, "uint", dwFlags, "int")
        return result
    }

    /**
     * Reads the National Language Support (NLS) native digit and digit substitution settings and records them in a SCRIPT_DIGITSUBSTITUTE structure. For more information, see Digit Shapes.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function supports context digit substitution only for Arabic and Persian locales. For other locales, context digit substitution is mapped to no substitution.
     * 
     * The following example shows the typical way to call this function.
     * 
     * 
     * ```cpp
     * SCRIPT_DIGITSUBSTITUTE sds;
     * ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
     * 
     * ```
     * 
     * 
     * At every itemization, the application can use the results as shown in the next example.
     * 
     * 
     * ```cpp
     * SCRIPT_CONTROL sc = {0};
     * SCRIPT_STATE   ss = {0};
     * ScriptApplyDigitSubstitution(&sds, &sc, &ss);
     * 
     * ```
     * 
     * 
     * For performance reasons, your application should not call <b>ScriptRecordDigitSubstitution</b> frequently. The function requires considerable overhead to call it every time <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a> is called. Instead, the application can save the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a> structure and update it only when a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message is received. Alternatively, the application can update the structure when a <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regnotifychangekeyvalue">RegNotifyChangeKeyValue</a> call in a dedicated thread indicates a change in the registry under HKCU\Control Panel\International.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale to query. Typically, the application should set this parameter to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>. Alternatively, the setting can indicate a specific locale combined with <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to obtain the default settings.
     * @param {Pointer<SCRIPT_DIGITSUBSTITUTE>} psds Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a> structure. This structure can be passed later to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptapplydigitsubstitution">ScriptApplyDigitSubstitution</a>.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * Error returns include:    
     * <ul>
     * <li>E_INVALIDARG. The <i>Locale</i> parameter indicates a locale that is invalid or not installed.</li>
     * <li>E_POINTER. The <i>psds</i> parameter is set to <b>NULL</b>.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptrecorddigitsubstitution
     * @since windows5.0
     */
    static ScriptRecordDigitSubstitution(Locale, psds) {
        result := DllCall("USP10.dll\ScriptRecordDigitSubstitution", "uint", Locale, "ptr", psds, "int")
        return result
    }

    /**
     * Applies the specified digit substitution settings to the specified script control and script state structures.
     * @remarks
     * This function does not actually substitute digits. It just fills in the structures that describe the digit substitution policy. See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<SCRIPT_DIGITSUBSTITUTE>} psds Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a> structure. The application sets this parameter to <b>NULL</b> if the function is to call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptrecorddigitsubstitution">ScriptRecordDigitSubstitution</a> with LOCALE_USER_DEFAULT.
     * @param {Pointer<UInt32>} psc Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure with the <b>fContextDigits</b> and <b>uDefaultLanguage</b> members updated.
     * @param {Pointer<UInt16>} pss Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure with the <b>fDigitSubstitute</b> member updated.
     * @returns {Integer} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * The function returns E_INVALIDARG if it does not recognize the <b>DigitSubstitute</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a>.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptapplydigitsubstitution
     * @since windows5.0
     */
    static ScriptApplyDigitSubstitution(psds, psc, pss) {
        result := DllCall("USP10.dll\ScriptApplyDigitSubstitution", "ptr", psds, "ptr", psc, "ptr", pss, "int")
        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run with OpenType information. Each run consists of one call to this function.
     * @remarks
     * <b>ScriptShapeOpenType</b> is preferred over the older <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> function. Some advantages of the <b>ScriptShapeOpenType</b> include the following:
     * 
     * <ul>
     * <li>Parameters directly correspond to OpenType tags in font layout tables.</li>
     * <li>Parameters define features applied to each character.</li>
     * <li>Input is divided into runs. Each run has OpenType properties and consists of a single call to <b>ScriptShapeOpenType</b>.</li>
     * </ul>
     * If this function returns E_OUTOFMEMORY, the application might call <b>ScriptShapeOpenType</b> repeatedly, with successively larger output buffers, until a large enough buffer is provided. The number of glyphs generated by a code point varies according to the script and the font. For a simple script, a Unicode code point might generate a single glyph. However, a complex script font might construct characters from components, and thus generate several times as many glyphs as characters. Also, there are special cases, such as invalid character representations, in which extra glyphs are added to represent the invalid sequence. Therefore, a reasonable guess for the size of the buffer indicated by <i>pwOutGlyphs</i> is 1.5 times the length of the character buffer, plus an additional 16 glyphs for rare cases, for example, invalid sequence representation.
     * 
     * This function can set the <b>fNoGlyphIndex</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure if the font or operating system cannot support glyph indexes.
     * 
     * The application can call <b>ScriptShapeOpenType</b> to determine if a font supports the characters in a given string. If the function returns S_OK, the application should check the output for missing glyphs. If <b>fLogicalOrder</b> is set to <b>TRUE</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure, the function always generates glyphs in the same order as the original Unicode characters. If <b>fLogicalOrder</b> is set to <b>FALSE</b>, the function generates right-to-left items in reverse order so that <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a> does not have to reverse them before calling <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a>.
     * 
     * If the <b>eScript</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> is set to SCRIPT_UNDEFINED, shaping is disabled. In this case, <b>ScriptShapeOpenType</b> displays the glyph that is in the font cmap table. If no glyph is in the table, the function indicates that glyphs are missing.
     * 
     * <b>ScriptShapeOpenType</b> sequences clusters uniformly within the run, and sequences glyphs uniformly within a cluster. It uses the value of the <b>fRTL</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a>, from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>, to identify if sequencing is left-to-right or right-to-left.
     * 
     * For the <i>rpRangeProperties</i> parameter, the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-textrange_properties">TEXTRANGE_PROPERTIES</a> structure points to an array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> structures. This array is used as follows:
     * 
     * <ul>
     * <li>Each element of the array indicated for <i>rpRangeProperties</i> describes a range.</li>
     * <li>Spans of text sharing particular properties tend to "nest," and nested spans can share <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> information. For example, in the illustration below:<ul>
     * <li>The rows of numbers at the top represent ranges, items, and runs, respectively.</li>
     * <li>Each span labeled here with a letter represents a single OpenType feature. The features that fall into each range are stored in the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> array of that range.</li>
     * <li>For each range, the array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> structures corresponds to the letters for the spans that contain that range.</li>
     * <li>In this illustration, range 2 is indirectly associated with the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> structures for spans A, B, and C. Range 4 is associated only with the structures for spans A and D.</li>
     * </ul>
     * </li>
     * </ul>
     * <img alt="Illustration showing the range, item, run, and feature of each word in a line of text that uses six properties to present eight words" border="" src="./images/Nested_Properties.GIF"/>
     * <div class="alert"><b>Note</b>  The illustration makes use of many calls to <b>ScriptShapeOpenType</b>, each representing one run.</div>
     * <div> </div>
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. The structure identifies the shaping engine, so that glyphs can be formed correctly.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the OpenType script tag for the writing system.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType language tag for the writing system.
     * @param {Pointer<Int32>} rcRangeChars Array of characters in each <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">range</a>. The number of array elements is indicated by <i>cRanges</i>. The values of the elements of this array add up to the value of <i>cChars</i>.
     * @param {Pointer<TEXTRANGE_PROPERTIES>} rpRangeProperties Array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-textrange_properties">TEXTRANGE_PROPERTIES</a> structures, each representing one OpenType feature range. The number of structures is indicated by the <i>cRanges</i> parameter. For more information on <i>rpRangeProperties</i>, see the Remarks section.
     * @param {Integer} cRanges The number of OpenType feature ranges.
     * @param {Pointer<PWSTR>} pwcChars Pointer to an array of Unicode characters containing the run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Integer} cMaxGlyphs Maximum number of glyphs to generate.
     * @param {Pointer<UInt16>} pwLogClust Pointer to a buffer in which this function retrieves an array of logical <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">cluster</a> information. Each array element corresponds to a character in the array of Unicode characters. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure is <b>TRUE</b>, the elements decrease as the array is read.
     * @param {Pointer<UInt16>} pCharProps Pointer to a buffer in which this function retrieves an array of character property values, of length indicated by <i>cChars</i>.
     * @param {Pointer<UInt16>} pwOutGlyphs Pointer to a buffer in which this function retrieves an array of glyphs.
     * @param {Pointer<SCRIPT_GLYPHPROP>} pOutGlyphProps Pointer to a buffer in which this function retrieves an array of attributes for each of the retrieved glyphs. The length of the values equals the value of <i>pcGlyphs</i>. Since one glyph property is indicated per glyph, the value of this parameter indicates the number of elements specified by <i>cMaxGlyphs</i>.
     * @param {Pointer<Int32>} pcGlyphs Pointer to the location in which this function retrieves the number of glyphs indicated in <i>pwOutGlyphs</i>.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, the content of all output array values is undefined.
     * 
     * Error returns include:
     * 
     * <ul>
     * <li>E_OUTOFMEMORY. The output buffer length indicated by <i>cMaxGlyphs</i> is insufficient.</li>
     * <li>E_PENDING. The script cache specified by the <i>psc</i> parameter does not contain enough information to shape the string, and the device context has been passed as <b>NULL</b> so that the function is unable to complete the shaping process. The application should set up a correct device context for the run and call this function again with the appropriate context value in <i>hdc</i> and with all other parameters the same.</li>
     * <li>USP_E_SCRIPT_NOT_IN_FONT. The font corresponding to the device context does not support the required script. The application should choose another font, using either <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetcmap">ScriptGetCMap</a> or another method to select the font.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptshapeopentype
     * @since windows6.0.6000
     */
    static ScriptShapeOpenType(hdc, psc, psa, tagScript, tagLangSys, rcRangeChars, rpRangeProperties, cRanges, pwcChars, cChars, cMaxGlyphs, pwLogClust, pCharProps, pwOutGlyphs, pOutGlyphProps, pcGlyphs) {
        result := DllCall("USP10.dll\ScriptShapeOpenType", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "ptr", rcRangeChars, "ptr", rpRangeProperties, "int", cRanges, "ptr", pwcChars, "int", cChars, "int", cMaxGlyphs, "ptr", pwLogClust, "ptr", pCharProps, "ptr", pwOutGlyphs, "ptr", pOutGlyphProps, "ptr", pcGlyphs, "int")
        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run with OpenType information from the output of ScriptShapeOpenType.
     * @remarks
     * This function is preferred over the older <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a> function. Some advantages of <b>ScriptPlaceOpenType</b> include the following:
     * 
     * <ul>
     * <li>Parameters directly correspond to OpenType tags in font layout tables.</li>
     * <li>Parameters define features applied to each character. Input is divided into ranges, and each range has OpenType properties associated with it.</li>
     * </ul>
     * The composite ABC width for the whole item identifies how much the glyphs <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">overhang</a> to the left of the start position and to the right of the length implied by the sum of the advance widths. The total advance width of the line is exactly abcA+abcB+abcC. The abcA and abcC values are maintained as proportions of the cell height represented in 8 bits and are thus roughly +/-1 percent. The total width retrieved, which is the sum of the abcA+abcB+abcC values indicated by <i>piAdvance</i>, is accurate to the resolution of the TrueType shaping engine.
     * 
     * All arrays are in visual order unless the <b>fLogicalOrder</b> member is set in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by the <i>psa</i> parameter.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This structures identifies the shaping engine that governs the generated list of glyphs and their associated widths, and x and y placement offsets.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType script tag for the writing system to use.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType language tag for the writing system.
     * @param {Pointer<Int32>} rcRangeChars Array of the number of characters in each range. The number of members is indicated in the <i>cRanges</i> parameter. The total of values should equal the value of <i>cChars</i>.
     * @param {Pointer<TEXTRANGE_PROPERTIES>} rpRangeProperties Array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-textrange_properties">TEXTRANGE_PROPERTIES</a> structures defining properties for each range. The number of elements is defined by the <i>cRanges</i> parameter.
     * @param {Integer} cRanges The number of OpenType feature ranges.
     * @param {Pointer<PWSTR>} pwcChars Pointer to an array of Unicode characters containing the run. The number of elements is defined by the <i>cRanges</i> parameter.
     * @param {Pointer<UInt16>} pwLogClust Pointer to an array of logical cluster information. Each element in the array corresponds to a character in the array defined by <i>pwcChars</i>. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure is set to <b>TRUE</b>, the elements in <i>pwLogClust</i> decrease as the array is read.
     * @param {Pointer<UInt16>} pCharProps Pointer to an array of character property values in the Unicode run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Pointer<UInt16>} pwGlyphs Pointer to a glyph buffer obtained from an earlier call to the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshapeopentype">ScriptShapeOpenType</a> function.
     * @param {Pointer<SCRIPT_GLYPHPROP>} pGlyphProps Pointer to an array of attributes for each of the glyphs to retrieve. The number of values equals the value of 
     * <i>cGlyphs</i>. Since there is one glyph property per glyph, this parameter has the number of elements indicated by <i>cGlyphs</i>.
     * @param {Integer} cGlyphs Count of glyphs in a glyph array buffer.
     * @param {Pointer<Int32>} piAdvance Pointer to an array, of length indicated by <i>cGlyphs</i>, in which this function retrieves <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">advance width</a> information.
     * @param {Pointer<GOFFSET>} pGoffset Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structures in which this structure retrieves the x and y offsets of combining glyphs. This array must be of length indicated by <i>cGlyphs</i>.
     * @param {Pointer<ABC>} pABC Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-abc">ABC</a> structure in which this function retrieves the <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> for the entire <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">run</a>.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, the output values are undefined. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * The function returns E_OUTOFMEMORY if the output buffer length indicated by <i>cGlyphs</i> is too small. The application can try calling again with larger buffers.
     * 
     * The function returns E_PENDING if the script cache specified by the <i>psc</i> parameter does not contain enough information to place the glyphs, and the <i>hdc</i> parameter is passed as <b>NULL</b> so that the function is unable to complete the placement process. The application should set up a correct device context for the run, and call this function again with the appropriate value in <i>hdc</i> and with all other parameters the same.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptplaceopentype
     * @since windows6.0.6000
     */
    static ScriptPlaceOpenType(hdc, psc, psa, tagScript, tagLangSys, rcRangeChars, rpRangeProperties, cRanges, pwcChars, pwLogClust, pCharProps, cChars, pwGlyphs, pGlyphProps, cGlyphs, piAdvance, pGoffset, pABC) {
        result := DllCall("USP10.dll\ScriptPlaceOpenType", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "ptr", rcRangeChars, "ptr", rpRangeProperties, "int", cRanges, "ptr", pwcChars, "ptr", pwLogClust, "ptr", pCharProps, "int", cChars, "ptr", pwGlyphs, "ptr", pGlyphProps, "int", cGlyphs, "ptr", piAdvance, "ptr", pGoffset, "ptr", pABC, "int")
        return result
    }

    /**
     * Breaks a Unicode string into individually shapeable items and provides an array of feature tags for each shapeable item for OpenType processing.
     * @remarks
     * <b>ScriptItemizeOpenType</b> is preferred over the older <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a> function. One advantage of <b>ScriptItemizeOpenType</b> is the availability of feature tags for each shapeable item.
     * 
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * The function delimits items by either a change of shaping engine or a change of direction.
     * 
     * The application can create multiple ranges, or runs that fall entirely within a single item, from each <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structure retrieved by <b>ScriptItemizeOpenType</b>. However, it should not combine multiple items into a single run. When measuring or rendering, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshapeopentype">ScriptShapeOpenType</a> for each run and must pass the corresponding <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structure retrieved by <b>ScriptItemizeOpenType</b>.
     * 
     * If the text handled by an application can include any right-to-left content, the application uses the <i>psControl</i> and <i>psState</i> parameters in calling <b>ScriptItemizeOpenType</b>. However, the application does not have to do this and can handle bidirectional text itself instead of relying on Uniscribe to do so. The <i>psControl</i> and <i>psState</i> parameters are useful in some strictly left-to-right scenarios, for example, when the <b>fLinkStringBefore</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> is not specific to right-to-left scripts. The application sets <i>psControl</i> and <i>psState</i> to <b>NULL</b> to have <b>ScriptItemizeOpenType</b> break the Unicode string purely by character code.
     * 
     * The application can set all parameters to non-<b>NULL</b> values to have the function perform a full Unicode bidirectional analysis. To permit a correct Unicode bidirectional analysis, the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure should be initialized according to the reading order at paragraph start, and <b>ScriptItemizeOpenType</b> should be passed the whole paragraph. In particular, the <b>uBidiLevel</b> member should be initialized to 0 for left-to-right and 1 for right-to-left.
     * 
     * The <b>fRTL</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> is referenced in <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a>. The <b>fNumeric</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> is retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetproperties">ScriptGetProperties</a>. These members together provide the same classification as the <b>lpClass</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-gcp_resultsa">GCP_RESULTS</a>, referenced by <i>lpResults</i> in <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a>.
     * 
     * European digits U+0030 through U+0039 can be rendered as national digits, as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>SCRIPT_STATE.fDigitSubstitute</th>
     * <th>SCRIPT_CONTROL.fContextDigits</th>
     * <th>Digit shapes displayed for Unicode U+0030 through U+0039</th>
     * </tr>
     * <tr>
     * <td><b>FALSE</b></td>
     * <td>Any</td>
     * <td>European digits</td>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td><b>FALSE</b></td>
     * <td>As specified in <b>uDefaultLanguage</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a>.</td>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td><b>TRUE</b></td>
     * <td>As prior strong text, defaulting to <b>uDefaultLanguage</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a>.</td>
     * </tr>
     * </table>
     *  
     * 
     * In context digit mode, one of the following actions occurs:
     * 
     * <ul>
     * <li>If the script specified by <b>uDefaultLanguage</b> is in the same direction as the output, all digits encountered before the first letters are rendered in the language indicated by <b>uDefaultLanguage</b>.</li>
     * <li>If the script specified by <b>uDefaultLanguage</b> is in the opposite direction from the output, all digits encountered before the first letters are rendered in European digits.</li>
     * </ul>
     * For example, if <b>uDefaultLanguage</b> indicates LANG_ARABIC, initial digits are in Arabic-Indic in a right-to-left embedding. However they are in European digits in a left-to-right embedding.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/digit-shapes">Digit Shapes</a>.
     * 
     * The Unicode control characters and definitions, and their effects on <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> members, are provided in the following table. For more information on Unicode control characters, see the <a href="https://www.unicode.org/standard/standard.html">The Unicode Standard</a>.
     * 
     * <table>
     * <tr>
     * <th>Unicode control characters</th>
     * <th>Meaning</th>
     * <th>Effect on SCRIPT_STATE</th>
     * </tr>
     * <tr>
     * <td>NADS</td>
     * <td>Override European digits (NODS) with national digit shapes.</td>
     * <td>Set <b>fDigitSubstitute</b>.</td>
     * </tr>
     * <tr>
     * <td>NODS</td>
     * <td>Use nominal digit shapes, otherwise known as European digits. See NADS.</td>
     * <td>Clear <b>fDigitSubstitute</b>.</td>
     * </tr>
     * <tr>
     * <td>ASS</td>
     * <td>Activate swapping of symmetric pairs, for example, parentheses. For these characters, left and right are interpreted as opening and closing. This is the default. See ISS.</td>
     * <td>Clear <b>fInhibitSymSwap</b>.</td>
     * </tr>
     * <tr>
     * <td>ISS</td>
     * <td>Inhibit swapping of symmetric pairs. See ASS.</td>
     * <td>Set <b>fInhibitSymSwap</b>.</td>
     * </tr>
     * <tr>
     * <td>AAFS</td>
     * <td>Activate Arabic form shaping for Arabic presentation forms. See IAFS.</td>
     * <td>Set <b>fCharShape</b>.</td>
     * </tr>
     * <tr>
     * <td>IAFS</td>
     * <td>Inhibit Arabic form shaping, that is, ligatures and cursive connections, for Arabic presentation forms. Nominal Arabic characters are not affected. This is the default. See AAFS.</td>
     * <td>Clear <b>fCharShape</b>.</td>
     * </tr>
     * </table>
     *  
     * 
     * The <b>fArabicNumContext</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> supports the context-sensitive display of numerals in Arabic script text. It indicates if digits are rendered using native Arabic script digit shapes or European digits. At the beginning of a paragraph, this member should normally be initialized to <b>TRUE</b> for an Arabic locale, or <b>FALSE</b> for any other locale. The function updates the script state it as it processes strong text.
     * 
     * The output parameter <i>pScriptTags</i> indicates an array with entries parallel to items. For each item, this function retrieves a script tag that should be used for shaping in all subsequent operations.
     * 
     * A script tag is usually determined by <b>ScriptItemizeOpenType</b> from input characters. If the function retrieves a specific script tag, the application should pass it to other functions without change. However, when characters are neutral (for example, digits) and the script cannot be determined, the application should choose an appropriate script tag, for example, based on font and language associated with text.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} pwcInChars Pointer to a Unicode string to itemize.
     * @param {Integer} cInChars Number of characters in <i>pwcInChars</i> to itemize.
     * @param {Integer} cMaxItems Maximum number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures defining items to process.
     * @param {Pointer<UInt32>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure indicating the type of itemization to perform.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if no <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> properties are needed. For more information, see the Remarks section.
     * @param {Pointer<UInt16>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure indicating the initial bidirectional algorithm state.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if the script state is not needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ITEM>} pItems Pointer to a buffer in which the function retrieves <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures representing the items that have been processed. The buffer should be  <c>(cMaxItems + 1) * sizeof(SCRIPT_ITEM)</c> bytes in length. It is invalid to call this function with a buffer that handles less than two <b>SCRIPT_ITEM</b> structures. The function always adds a terminal item to the item analysis array so that the length of the item with zero-based index "i" is always available as:
     * 
     * <c>pItems[i+1].iCharPos - pItems[i].iCharPos;</c>
     * @param {Pointer<UInt32>} pScriptTags Pointer to a buffer in which the function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures representing script tags. The buffer should be  <c>cMaxItems * sizeof(OPENTYPE_TAG)</c> bytes in length.
     * 
     * <div class="alert"><b>Note</b>  When all characters in an item are neutral, the value of this parameter is SCRIPT_TAG_UNKNOWN (0x00000000). This can happen, for example, if an item consists entirely of punctuation.</div>
     * <div> </div>
     * @param {Pointer<Int32>} pcItems Pointer to the number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures processed.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, no items are fully processed and no part of the output contains defined values. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * The function returns E_OUTOFMEMORY if the size indicated by <i>cMaxItems</i> is too small. The application can try calling the function again with a larger buffer.
     * 
     * The function returns E_INVALIDARG if one or more of the following conditions occur:
     * 
     * <ul>
     * <li><i>pwcInChars</i> is set to <b>NULL</b></li>
     * <li><i>cInChars</i> is 0</li>
     * <li><i>pItems</i> is set to <b>NULL</b></li>
     * <li><i>pScriptTags</i> is set to <b>NULL</b></li>
     * <li><i>cMaxItems</i> &lt; 2</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptitemizeopentype
     * @since windows6.0.6000
     */
    static ScriptItemizeOpenType(pwcInChars, cInChars, cMaxItems, psControl, psState, pItems, pScriptTags, pcItems) {
        result := DllCall("USP10.dll\ScriptItemizeOpenType", "ptr", pwcInChars, "int", cInChars, "int", cMaxItems, "ptr", psControl, "ptr", psState, "ptr", pItems, "ptr", pScriptTags, "ptr", pcItems, "int")
        return result
    }

    /**
     * Retrieves a list of scripts available in the font for OpenType processing. Scripts comprising the list are retrieved from the font located in the supplied device context or from the script shaping engine that processes the font of the current run.
     * @remarks
     * While formally declared as a ULONG type, <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> defines a 4-byte array that contains four 8-bit ASCII values of space, A-Z or a-z. For example, the script tags for Latin and Arabic scripts are "latn" and "arab", respectively.
     * 
     * This function retrieves a single tag from a font in the following cases:
     * 
     * <ul>
     * <li>The <i>psa</i> value is associated with text for a single complex script.</li>
     * <li>The <i>psa</i> parameter indicates <b>NULL</b> and the font supports a single script.</li>
     * </ul>
     * If <b>ScriptGetFontScriptTags</b> retrieves all tags from a font, the tags are usually for neutral items, such as digits. Note that more than one tag might be applicable because some text runs of neutral items are not script-specific.
     * 
     * If a tag corresponding to a particular script is present, a shaping engine might be unable to use the font to shape the given item because the engine lacks a needed item, such as a specific language system or a specific feature.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the appropriate font script tags can be retrieved. The application supplies a non-<b>NULL</b> value for this parameter to retrieve script tags appropriate for the current run.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} cMaxTags The length of the array specified by <i>pScriptTags</i>.
     * @param {Pointer<UInt32>} pScriptTags Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures defining script tags from the device context or the scripting engine associated with the current run. If the value of the <b>eScript</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure provided in the <i>psa</i> parameter has a definite script tag associated with it and the tag is present in the font, <i>pScriptTags</i> contains only this tag.
     * @param {Pointer<Int32>} pcTags Pointer to the number of elements in the script tag array indicated by <i>pScriptTags</i>.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds the value of <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontscripttags
     * @since windows6.0.6000
     */
    static ScriptGetFontScriptTags(hdc, psc, psa, cMaxTags, pScriptTags, pcTags) {
        result := DllCall("USP10.dll\ScriptGetFontScriptTags", "ptr", hdc, "ptr", psc, "ptr", psa, "int", cMaxTags, "ptr", pScriptTags, "ptr", pcTags, "int")
        return result
    }

    /**
     * Retrieves a list of language tags that are available for the specified item and are supported by a specified script tag for OpenType processing. The tags comprising the list are retrieved from the font in the specified device context or cache.
     * @remarks
     * While formally declared as a ULONG type, the <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure contains a 4-byte array that contains four 8-bit ASCII values of space, A-Z, or a-z. For example, the language tags for Romanian, Urdu, and Persian are "ROM ", "URD ", and "FAR ", respectively. Note that each tag ends with a space.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the font language tags for the appropriate font and scripts can be retrieved.
     * 
     * Alternately, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for which the list of associated language tags is requested.
     * @param {Integer} cMaxTags The length of the array specified by <i>pLangSysTags</i>.
     * @param {Pointer<UInt32>} pLangsysTags Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures identifying the language tags matching input criteria.
     * @param {Pointer<Int32>} pcTags Pointer to the number of elements in the language tag array.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontlanguagetags
     * @since windows6.0.6000
     */
    static ScriptGetFontLanguageTags(hdc, psc, psa, tagScript, cMaxTags, pLangsysTags, pcTags) {
        result := DllCall("USP10.dll\ScriptGetFontLanguageTags", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "int", cMaxTags, "ptr", pLangsysTags, "ptr", pcTags, "int")
        return result
    }

    /**
     * Retrieves a list of typographic features for the defined writing system for OpenType processing. The typographic feature tags comprising the list are retrieved from the font in the supplied device context or cache.
     * @remarks
     * While formally declared as a ULONG type, an <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure contains a 4-byte array that contains four 8-bit ASCII values of space, A-Z, or a-z. For example, the feature tag for the Ligature feature is "liga".
     * 
     * This function hides script-required or language-required features because the shaping engine controls these features. The application has no control over the shaping engine handling for language-required features. For example, <b>ScriptGetFontFeatureTags</b> hides the Arabic script features for initial, medial, and final forms.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the font feature tags for the appropriate font and scripts can be retrieved.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag associated with the specified feature tags.
     * @param {Integer} tagLangSys An <b>OPENTYPE_TAG</b> structure defining the language tag associated with the specified feature tags.
     * @param {Integer} cMaxTags The length of the array specified by <i>pFeatureTags</i>.
     * @param {Pointer<UInt32>} pFeatureTags Pointer to a buffer in which this function retrieves an array of <b>OPENTYPE_TAG</b> structures defining the typographic feature tags supported by the font in the device context or cache for the defined writing system.
     * @param {Pointer<Int32>} pcTags Pointer to the number of elements in the feature tag array.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds the value of <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontfeaturetags
     * @since windows6.0.6000
     */
    static ScriptGetFontFeatureTags(hdc, psc, psa, tagScript, tagLangSys, cMaxTags, pFeatureTags, pcTags) {
        result := DllCall("USP10.dll\ScriptGetFontFeatureTags", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "int", cMaxTags, "ptr", pFeatureTags, "ptr", pcTags, "int")
        return result
    }

    /**
     * Retrieves a list of alternate glyphs for a specified character that can be accessed through a specified OpenType feature.
     * @remarks
     * When using alternate glyphs, the application first reshapes the original glyph without applying any feature tag, then selects an alternate. The original glyph is established as the base glyph. If another alternate is required, the original glyph provides information to match with the corresponding alternates list.
     * 
     * If an alternate glyph is used as the base glyph, no matching output list is found. The user interface uses the selected final form without providing the capability to choose another alternate.
     * 
     * The operations of <b>ScriptGetFontAlternateGlyphs</b> can be emulated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptsubstitutesingleglyph">ScriptSubstituteSingleGlyph</a>. The application should try parameters one by one while glyphs are substituted.
     * 
     * For shaping fonts with Uniscribe, <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshapeopentype">ScriptShapeOpenType</a> is preferred over the older <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> function.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure defining the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the array of alternate glyphs can be created with the correct scope.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag associated with alternate glyphs.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag associated with alternate glyphs.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag associated with alternate glyphs.
     * @param {Integer} wGlyphId The identifier of the original glyph mapped from the character map table.
     * @param {Integer} cMaxAlternates Length of the array specified by <i>pAlternateGlyphs</i>.
     * @param {Pointer<UInt16>} pAlternateGlyphs Pointer to buffer in which this function retrieves an array of glyph identifiers. The array includes the original glyph, followed by alternate glyphs. The first element is always the original glyph. Alternate forms are identified by an index into the array. The index is a value greater than one and less than the value of <i>pcAlternates</i>.
     * 
     * When the user chooses an alternate form from the user interface, the alternate glyph is applied to the corresponding character and the rendering is reformatted.
     * @param {Pointer<Int32>} pcAlternates Pointer to the number of elements in the array specified by <i>pAlternateGlyphs</i>.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of alternate glyphs exceeds the value of <i>cMaxAlternates</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontalternateglyphs
     * @since windows6.0.6000
     */
    static ScriptGetFontAlternateGlyphs(hdc, psc, psa, tagScript, tagLangSys, tagFeature, wGlyphId, cMaxAlternates, pAlternateGlyphs, pcAlternates) {
        result := DllCall("USP10.dll\ScriptGetFontAlternateGlyphs", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "ushort", wGlyphId, "int", cMaxAlternates, "ptr", pAlternateGlyphs, "ptr", pcAlternates, "int")
        return result
    }

    /**
     * Enables substitution of a single glyph with one alternate form of the same glyph for OpenType processing.
     * @remarks
     * This function uses one-to-one substitution in which the application can substitute one glyph with one alternate form. Most often, applications use this function to set a bullet or an alternate glyph at the beginning or end of a line.
     * 
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure indicating the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine so that the correct substitute glyph is used.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for shaping.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag for shaping.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag to use for shaping the alternate glyph.
     * @param {Integer} lParameter Reference to the alternate glyph to substitute. This reference is an index to an array that contains all the alternate glyphs defined in the feature, as illustrated for <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a>. The alternate glyph array is one of the items retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetfontalternateglyphs">ScriptGetFontAlternateGlyphs</a>.
     * @param {Integer} wGlyphId Identifier of the original glyph.
     * @param {Pointer<UInt16>} pwOutGlyphId Pointer to the location in which this function retrieves the identifier of the alternate glyph.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptsubstitutesingleglyph
     * @since windows6.0.6000
     */
    static ScriptSubstituteSingleGlyph(hdc, psc, psa, tagScript, tagLangSys, tagFeature, lParameter, wGlyphId, pwOutGlyphId) {
        result := DllCall("USP10.dll\ScriptSubstituteSingleGlyph", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "int", lParameter, "ushort", wGlyphId, "ptr", pwOutGlyphId, "int")
        return result
    }

    /**
     * Positions a single glyph with a single adjustment using a specified feature provided in the font for OpenType processing. Most often, applications use this function to align a glyph optically at the beginning or end of a line.
     * @remarks
     * This function positions an individual glyph by adjusting the advance width and/or the offset of the given glyph. The function assumes that the font requires only one adjustment.
     * 
     * A typical use of this function is the slight adjustment of the margin to account for the visual impression made by certain characters. In Latin script, for example, at the beginning of a line it is common to make a slight adjustment to the left for an initial capital (such as "T" or "O") that does not have a vertical line on the left part of the glyph. Although doing this breaks the strict linear margin, the eye perceives the margin as more even.
     * 
     * The following examples demonstrate this effect. The first example shows strict alignment; the next two examples show an adjustment of the initial "T" to the left. The adjustments are by one pixel and two pixels, respectively. The magnified images to the right show how the "T" pushes slightly farther into the left margin in each successive case.
     * 
     * <img alt="Illustration showing the same block of text three times, with enlargements of each showing slightly different alignment" border="" src="./images/HAlign.gif"/>
     * <div class="alert"><b>Important</b>  Starting with Windows 8: To maintain the ability to run on Windows 7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div> </div>
     * @param {Pointer<HDC>} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This structure identifies the shaping engine, so that the advance widths can be retrieved.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for shaping.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag for shaping.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag to use for shaping the alternate glyph.
     * @param {Integer} lParameter A flag specifying if single substitution should be applied to the identifier specified in <i>wGlyphId</i>. The application sets this parameter to 1 to apply the single substitution feature to the identifier. The application sets the parameter to 0 if the function should not apply the feature.
     * @param {Integer} wGlyphId The identifier of the original glyph being shaped.
     * @param {Integer} iAdvance The original glyph advance width.
     * @param {Pointer} GOffset The original glyph offset. Typically, this value is an output of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplaceopentype">ScriptPlaceOpenType</a> or <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<Int32>} piOutAdvance Pointer to the location in which this function retrieves the new advance width adjusted for the alternate glyph.
     * @param {Pointer<GOFFSET>} pOutGoffset Pointer to the location in which this function retrieves the new glyph offset adjusted for the alternate glyph.
     * @returns {Integer} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptpositionsingleglyph
     * @since windows6.0.6000
     */
    static ScriptPositionSingleGlyph(hdc, psc, psa, tagScript, tagLangSys, tagFeature, lParameter, wGlyphId, iAdvance, GOffset, piOutAdvance, pOutGoffset) {
        result := DllCall("USP10.dll\ScriptPositionSingleGlyph", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "int", lParameter, "ushort", wGlyphId, "int", iAdvance, "ptr", GOffset, "ptr", piOutAdvance, "ptr", pOutGoffset, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} s 
     * @param {Pointer<Int32>} pi 
     * @param {Integer} length 
     * @param {Integer} c 
     * @param {Integer} strict 
     * @returns {Integer} 
     */
    static utf8_nextCharSafeBody(s, pi, length, c, strict) {
        result := DllCall("icuuc.dll\utf8_nextCharSafeBody", "ptr", s, "ptr", pi, "int", length, "int", c, "char", strict, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} s 
     * @param {Integer} i 
     * @param {Integer} length 
     * @param {Integer} c 
     * @param {Pointer<SByte>} pIsError 
     * @returns {Integer} 
     */
    static utf8_appendCharSafeBody(s, i, length, c, pIsError) {
        result := DllCall("icuuc.dll\utf8_appendCharSafeBody", "ptr", s, "int", i, "int", length, "int", c, "ptr", pIsError, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} s 
     * @param {Integer} start 
     * @param {Pointer<Int32>} pi 
     * @param {Integer} c 
     * @param {Integer} strict 
     * @returns {Integer} 
     */
    static utf8_prevCharSafeBody(s, start, pi, c, strict) {
        result := DllCall("icuuc.dll\utf8_prevCharSafeBody", "ptr", s, "int", start, "ptr", pi, "int", c, "char", strict, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} s 
     * @param {Integer} start 
     * @param {Integer} i 
     * @returns {Integer} 
     */
    static utf8_back1SafeBody(s, start, i) {
        result := DllCall("icuuc.dll\utf8_back1SafeBody", "ptr", s, "int", start, "int", i, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @param {Pointer<PSTR>} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionFromString(versionArray, versionString) {
        DllCall("icuuc.dll\u_versionFromString", "ptr", versionArray, "ptr", versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @param {Pointer<UInt16>} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionFromUString(versionArray, versionString) {
        DllCall("icuuc.dll\u_versionFromUString", "ptr", versionArray, "ptr", versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @param {Pointer<PSTR>} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionToString(versionArray, versionString) {
        DllCall("icuuc.dll\u_versionToString", "ptr", versionArray, "ptr", versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getVersion(versionArray) {
        DllCall("icuuc.dll\u_getVersion", "ptr", versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Integer} code 
     * @returns {Pointer<PSTR>} 
     */
    static u_errorName(code) {
        result := DllCall("icuuc.dll\u_errorName", "int", code, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} traceLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_setLevel(traceLevel) {
        DllCall("icuuc.dll\utrace_setLevel", "int", traceLevel, "CDecl ")
    }

    /**
     * 
     * @returns {Integer} 
     */
    static utrace_getLevel() {
        result := DllCall("icuuc.dll\utrace_getLevel", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UTraceEntry>} e 
     * @param {Pointer<UTraceExit>} x 
     * @param {Pointer<UTraceData>} d 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_setFunctions(context, e, x, d) {
        DllCall("icuuc.dll\utrace_setFunctions", "ptr", context, "ptr", e, "ptr", x, "ptr", d, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UTraceEntry>} e 
     * @param {Pointer<UTraceExit>} x 
     * @param {Pointer<UTraceData>} d 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_getFunctions(context, e, x, d) {
        DllCall("icuuc.dll\utrace_getFunctions", "ptr", context, "ptr", e, "ptr", x, "ptr", d, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} outBuf 
     * @param {Integer} capacity 
     * @param {Integer} indent 
     * @param {Pointer<PSTR>} fmt 
     * @param {Pointer<SByte>} args 
     * @returns {Integer} 
     */
    static utrace_vformat(outBuf, capacity, indent, fmt, args) {
        result := DllCall("icuuc.dll\utrace_vformat", "ptr", outBuf, "int", capacity, "int", indent, "ptr", fmt, "ptr", args, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} outBuf 
     * @param {Integer} capacity 
     * @param {Integer} indent 
     * @param {Pointer<PSTR>} fmt 
     * @returns {Integer} 
     */
    static utrace_format(outBuf, capacity, indent, fmt) {
        result := DllCall("icuuc.dll\utrace_format", "ptr", outBuf, "int", capacity, "int", indent, "ptr", fmt, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} fnNumber 
     * @returns {Pointer<PSTR>} 
     */
    static utrace_functionName(fnNumber) {
        result := DllCall("icuuc.dll\utrace_functionName", "int", fnNumber, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_shapeArabic(source, sourceLength, dest, destSize, options, pErrorCode) {
        result := DllCall("icuuc.dll\u_shapeArabic", "ptr", source, "int", sourceLength, "ptr", dest, "int", destSize, "uint", options, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} nameOrAbbrOrLocale 
     * @param {Pointer<Int32>} fillIn 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uscript_getCode(nameOrAbbrOrLocale, fillIn, capacity, err) {
        result := DllCall("icuuc.dll\uscript_getCode", "ptr", nameOrAbbrOrLocale, "ptr", fillIn, "int", capacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} scriptCode 
     * @returns {Pointer<PSTR>} 
     */
    static uscript_getName(scriptCode) {
        result := DllCall("icuuc.dll\uscript_getName", "int", scriptCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} scriptCode 
     * @returns {Pointer<PSTR>} 
     */
    static uscript_getShortName(scriptCode) {
        result := DllCall("icuuc.dll\uscript_getShortName", "int", scriptCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} codepoint 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static uscript_getScript(codepoint, err) {
        DllCall("icuuc.dll\uscript_getScript", "int", codepoint, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} sc 
     * @returns {Integer} 
     */
    static uscript_hasScript(c, sc) {
        result := DllCall("icuuc.dll\uscript_hasScript", "int", c, "int", sc, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<Int32>} scripts 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} errorCode 
     * @returns {Integer} 
     */
    static uscript_getScriptExtensions(c, scripts, capacity, errorCode) {
        result := DllCall("icuuc.dll\uscript_getScriptExtensions", "int", c, "ptr", scripts, "int", capacity, "ptr", errorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uscript_getSampleString(script, dest, capacity, pErrorCode) {
        result := DllCall("icuuc.dll\uscript_getSampleString", "int", script, "ptr", dest, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {String} Nothing - always returns an empty string
     */
    static uscript_getUsage(script) {
        DllCall("icuuc.dll\uscript_getUsage", "int", script, "CDecl ")
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_isRightToLeft(script) {
        result := DllCall("icuuc.dll\uscript_isRightToLeft", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_breaksBetweenLetters(script) {
        result := DllCall("icuuc.dll\uscript_breaksBetweenLetters", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_isCased(script) {
        result := DllCall("icuuc.dll\uscript_isCased", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_current32(iter) {
        result := DllCall("icuuc.dll\uiter_current32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_next32(iter) {
        result := DllCall("icuuc.dll\uiter_next32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_previous32(iter) {
        result := DllCall("icuuc.dll\uiter_previous32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_getState(iter) {
        result := DllCall("icuuc.dll\uiter_getState", "ptr", iter, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Integer} state 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setState(iter, state, pErrorCode) {
        DllCall("icuuc.dll\uiter_setState", "ptr", iter, "uint", state, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setString(iter, s, length) {
        DllCall("icuuc.dll\uiter_setString", "ptr", iter, "ptr", s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Pointer<PSTR>} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setUTF16BE(iter, s, length) {
        DllCall("icuuc.dll\uiter_setUTF16BE", "ptr", iter, "ptr", s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Pointer<PSTR>} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setUTF8(iter, s, length) {
        DllCall("icuuc.dll\uiter_setUTF8", "ptr", iter, "ptr", s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} en 
     * @returns {String} Nothing - always returns an empty string
     */
    static uenum_close(en) {
        DllCall("icuuc.dll\uenum_close", "ptr", en, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} en 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uenum_count(en, status) {
        result := DllCall("icuuc.dll\uenum_count", "ptr", en, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} en 
     * @param {Pointer<Int32>} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static uenum_unext(en, resultLength, status) {
        result := DllCall("icuuc.dll\uenum_unext", "ptr", en, "ptr", resultLength, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} en 
     * @param {Pointer<Int32>} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static uenum_next(en, resultLength, status) {
        result := DllCall("icuuc.dll\uenum_next", "ptr", en, "ptr", resultLength, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} en 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uenum_reset(en, status) {
        DllCall("icuuc.dll\uenum_reset", "ptr", en, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} strings 
     * @param {Integer} count 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uenum_openUCharStringsEnumeration(strings, count, ec) {
        DllCall("icuuc.dll\uenum_openUCharStringsEnumeration", "ptr", strings, "int", count, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<SByte>} strings 
     * @param {Integer} count 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uenum_openCharStringsEnumeration(strings, count, ec) {
        DllCall("icuuc.dll\uenum_openCharStringsEnumeration", "ptr", strings, "int", count, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @returns {Pointer<PSTR>} 
     */
    static uloc_getDefault() {
        result := DllCall("icuuc.dll\uloc_getDefault", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uloc_setDefault(localeID, status) {
        DllCall("icuuc.dll\uloc_setDefault", "ptr", localeID, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} language 
     * @param {Integer} languageCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getLanguage(localeID, language, languageCapacity, err) {
        result := DllCall("icuuc.dll\uloc_getLanguage", "ptr", localeID, "ptr", language, "int", languageCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} script 
     * @param {Integer} scriptCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getScript(localeID, script, scriptCapacity, err) {
        result := DllCall("icuuc.dll\uloc_getScript", "ptr", localeID, "ptr", script, "int", scriptCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} country 
     * @param {Integer} countryCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getCountry(localeID, country, countryCapacity, err) {
        result := DllCall("icuuc.dll\uloc_getCountry", "ptr", localeID, "ptr", country, "int", countryCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} variant 
     * @param {Integer} variantCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getVariant(localeID, variant, variantCapacity, err) {
        result := DllCall("icuuc.dll\uloc_getVariant", "ptr", localeID, "ptr", variant, "int", variantCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getName(localeID, name, nameCapacity, err) {
        result := DllCall("icuuc.dll\uloc_getName", "ptr", localeID, "ptr", name, "int", nameCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_canonicalize(localeID, name, nameCapacity, err) {
        result := DllCall("icuuc.dll\uloc_canonicalize", "ptr", localeID, "ptr", name, "int", nameCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @returns {Pointer<PSTR>} 
     */
    static uloc_getISO3Language(localeID) {
        result := DllCall("icuuc.dll\uloc_getISO3Language", "ptr", localeID, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @returns {Pointer<PSTR>} 
     */
    static uloc_getISO3Country(localeID) {
        result := DllCall("icuuc.dll\uloc_getISO3Country", "ptr", localeID, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @returns {Integer} 
     */
    static uloc_getLCID(localeID) {
        result := DllCall("icuuc.dll\uloc_getLCID", "ptr", localeID, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<PSTR>} displayLocale 
     * @param {Pointer<UInt16>} language 
     * @param {Integer} languageCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayLanguage(locale, displayLocale, language, languageCapacity, status) {
        result := DllCall("icuuc.dll\uloc_getDisplayLanguage", "ptr", locale, "ptr", displayLocale, "ptr", language, "int", languageCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<PSTR>} displayLocale 
     * @param {Pointer<UInt16>} script 
     * @param {Integer} scriptCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayScript(locale, displayLocale, script, scriptCapacity, status) {
        result := DllCall("icuuc.dll\uloc_getDisplayScript", "ptr", locale, "ptr", displayLocale, "ptr", script, "int", scriptCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<PSTR>} displayLocale 
     * @param {Pointer<UInt16>} country 
     * @param {Integer} countryCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayCountry(locale, displayLocale, country, countryCapacity, status) {
        result := DllCall("icuuc.dll\uloc_getDisplayCountry", "ptr", locale, "ptr", displayLocale, "ptr", country, "int", countryCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<PSTR>} displayLocale 
     * @param {Pointer<UInt16>} variant 
     * @param {Integer} variantCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayVariant(locale, displayLocale, variant, variantCapacity, status) {
        result := DllCall("icuuc.dll\uloc_getDisplayVariant", "ptr", locale, "ptr", displayLocale, "ptr", variant, "int", variantCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} keyword 
     * @param {Pointer<PSTR>} displayLocale 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayKeyword(keyword, displayLocale, dest, destCapacity, status) {
        result := DllCall("icuuc.dll\uloc_getDisplayKeyword", "ptr", keyword, "ptr", displayLocale, "ptr", dest, "int", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<PSTR>} keyword 
     * @param {Pointer<PSTR>} displayLocale 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayKeywordValue(locale, keyword, displayLocale, dest, destCapacity, status) {
        result := DllCall("icuuc.dll\uloc_getDisplayKeywordValue", "ptr", locale, "ptr", keyword, "ptr", displayLocale, "ptr", dest, "int", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} inLocaleID 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getDisplayName(localeID, inLocaleID, result, maxResultSize, err) {
        result := DllCall("icuuc.dll\uloc_getDisplayName", "ptr", localeID, "ptr", inLocaleID, "ptr", result, "int", maxResultSize, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @returns {Pointer<PSTR>} 
     */
    static uloc_getAvailable(n) {
        result := DllCall("icuuc.dll\uloc_getAvailable", "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static uloc_countAvailable() {
        result := DllCall("icuuc.dll\uloc_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uloc_openAvailableByType(type, status) {
        DllCall("icu.dll\uloc_openAvailableByType", "int", type, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @returns {Pointer<SByte>} 
     */
    static uloc_getISOLanguages() {
        result := DllCall("icuuc.dll\uloc_getISOLanguages", "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Pointer<SByte>} 
     */
    static uloc_getISOCountries() {
        result := DllCall("icuuc.dll\uloc_getISOCountries", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} parent 
     * @param {Integer} parentCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getParent(localeID, parent, parentCapacity, err) {
        result := DllCall("icuuc.dll\uloc_getParent", "ptr", localeID, "ptr", parent, "int", parentCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getBaseName(localeID, name, nameCapacity, err) {
        result := DllCall("icuuc.dll\uloc_getBaseName", "ptr", localeID, "ptr", name, "int", nameCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uloc_openKeywords(localeID, status) {
        DllCall("icuuc.dll\uloc_openKeywords", "ptr", localeID, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} keywordName 
     * @param {Pointer<PSTR>} buffer 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getKeywordValue(localeID, keywordName, buffer, bufferCapacity, status) {
        result := DllCall("icuuc.dll\uloc_getKeywordValue", "ptr", localeID, "ptr", keywordName, "ptr", buffer, "int", bufferCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} keywordName 
     * @param {Pointer<PSTR>} keywordValue 
     * @param {Pointer<PSTR>} buffer 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_setKeywordValue(keywordName, keywordValue, buffer, bufferCapacity, status) {
        result := DllCall("icuuc.dll\uloc_setKeywordValue", "ptr", keywordName, "ptr", keywordValue, "ptr", buffer, "int", bufferCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @returns {Integer} 
     */
    static uloc_isRightToLeft(locale) {
        result := DllCall("icuuc.dll\uloc_isRightToLeft", "ptr", locale, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeId 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uloc_getCharacterOrientation(localeId, status) {
        DllCall("icuuc.dll\uloc_getCharacterOrientation", "ptr", localeId, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeId 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uloc_getLineOrientation(localeId, status) {
        DllCall("icuuc.dll\uloc_getLineOrientation", "ptr", localeId, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} result 
     * @param {Integer} resultAvailable 
     * @param {Pointer<Int32>} outResult 
     * @param {Pointer<PSTR>} httpAcceptLanguage 
     * @param {Pointer<IntPtr>} availableLocales 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_acceptLanguageFromHTTP(result, resultAvailable, outResult, httpAcceptLanguage, availableLocales, status) {
        result := DllCall("icuuc.dll\uloc_acceptLanguageFromHTTP", "ptr", result, "int", resultAvailable, "ptr", outResult, "ptr", httpAcceptLanguage, "ptr", availableLocales, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} result 
     * @param {Integer} resultAvailable 
     * @param {Pointer<Int32>} outResult 
     * @param {Pointer<SByte>} acceptList 
     * @param {Integer} acceptListCount 
     * @param {Pointer<IntPtr>} availableLocales 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_acceptLanguage(result, resultAvailable, outResult, acceptList, acceptListCount, availableLocales, status) {
        result := DllCall("icuuc.dll\uloc_acceptLanguage", "ptr", result, "int", resultAvailable, "ptr", outResult, "ptr", acceptList, "int", acceptListCount, "ptr", availableLocales, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} hostID 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} localeCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getLocaleForLCID(hostID, locale, localeCapacity, status) {
        result := DllCall("icuuc.dll\uloc_getLocaleForLCID", "uint", hostID, "ptr", locale, "int", localeCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} maximizedLocaleID 
     * @param {Integer} maximizedLocaleIDCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_addLikelySubtags(localeID, maximizedLocaleID, maximizedLocaleIDCapacity, err) {
        result := DllCall("icuuc.dll\uloc_addLikelySubtags", "ptr", localeID, "ptr", maximizedLocaleID, "int", maximizedLocaleIDCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} minimizedLocaleID 
     * @param {Integer} minimizedLocaleIDCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_minimizeSubtags(localeID, minimizedLocaleID, minimizedLocaleIDCapacity, err) {
        result := DllCall("icuuc.dll\uloc_minimizeSubtags", "ptr", localeID, "ptr", minimizedLocaleID, "int", minimizedLocaleIDCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} langtag 
     * @param {Pointer<PSTR>} localeID 
     * @param {Integer} localeIDCapacity 
     * @param {Pointer<Int32>} parsedLength 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_forLanguageTag(langtag, localeID, localeIDCapacity, parsedLength, err) {
        result := DllCall("icuuc.dll\uloc_forLanguageTag", "ptr", langtag, "ptr", localeID, "int", localeIDCapacity, "ptr", parsedLength, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<PSTR>} langtag 
     * @param {Integer} langtagCapacity 
     * @param {Integer} strict 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_toLanguageTag(localeID, langtag, langtagCapacity, strict, err) {
        result := DllCall("icuuc.dll\uloc_toLanguageTag", "ptr", localeID, "ptr", langtag, "int", langtagCapacity, "char", strict, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} keyword 
     * @returns {Pointer<PSTR>} 
     */
    static uloc_toUnicodeLocaleKey(keyword) {
        result := DllCall("icuuc.dll\uloc_toUnicodeLocaleKey", "ptr", keyword, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} keyword 
     * @param {Pointer<PSTR>} value 
     * @returns {Pointer<PSTR>} 
     */
    static uloc_toUnicodeLocaleType(keyword, value) {
        result := DllCall("icuuc.dll\uloc_toUnicodeLocaleType", "ptr", keyword, "ptr", value, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} keyword 
     * @returns {Pointer<PSTR>} 
     */
    static uloc_toLegacyKey(keyword) {
        result := DllCall("icuuc.dll\uloc_toLegacyKey", "ptr", keyword, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} keyword 
     * @param {Pointer<PSTR>} value 
     * @returns {Pointer<PSTR>} 
     */
    static uloc_toLegacyType(keyword, value) {
        result := DllCall("icuuc.dll\uloc_toLegacyType", "ptr", keyword, "ptr", value, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} packageName 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_open(packageName, locale, status) {
        DllCall("icuuc.dll\ures_open", "ptr", packageName, "ptr", locale, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} packageName 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_openDirect(packageName, locale, status) {
        DllCall("icuuc.dll\ures_openDirect", "ptr", packageName, "ptr", locale, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} packageName 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_openU(packageName, locale, status) {
        DllCall("icuuc.dll\ures_openU", "ptr", packageName, "ptr", locale, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_close(resourceBundle) {
        DllCall("icuuc.dll\ures_close", "ptr", resourceBundle, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resB 
     * @param {Pointer<Byte>} versionInfo 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_getVersion(resB, versionInfo) {
        DllCall("icuuc.dll\ures_getVersion", "ptr", resB, "ptr", versionInfo, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ures_getLocaleByType(resourceBundle, type, status) {
        result := DllCall("icuuc.dll\ures_getLocaleByType", "ptr", resourceBundle, "int", type, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ures_getString(resourceBundle, len, status) {
        result := DllCall("icuuc.dll\ures_getString", "ptr", resourceBundle, "ptr", len, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resB 
     * @param {Pointer<PSTR>} dest 
     * @param {Pointer<Int32>} length 
     * @param {Integer} forceCopy 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ures_getUTF8String(resB, dest, length, forceCopy, status) {
        result := DllCall("icuuc.dll\ures_getUTF8String", "ptr", resB, "ptr", dest, "ptr", length, "char", forceCopy, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Byte>} 
     */
    static ures_getBinary(resourceBundle, len, status) {
        result := DllCall("icuuc.dll\ures_getBinary", "ptr", resourceBundle, "ptr", len, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Int32>} 
     */
    static ures_getIntVector(resourceBundle, len, status) {
        result := DllCall("icuuc.dll\ures_getIntVector", "ptr", resourceBundle, "ptr", len, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ures_getUInt(resourceBundle, status) {
        result := DllCall("icuuc.dll\ures_getUInt", "ptr", resourceBundle, "ptr", status, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ures_getInt(resourceBundle, status) {
        result := DllCall("icuuc.dll\ures_getInt", "ptr", resourceBundle, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @returns {Integer} 
     */
    static ures_getSize(resourceBundle) {
        result := DllCall("icuuc.dll\ures_getSize", "ptr", resourceBundle, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_getType(resourceBundle) {
        DllCall("icuuc.dll\ures_getType", "ptr", resourceBundle, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @returns {Pointer<PSTR>} 
     */
    static ures_getKey(resourceBundle) {
        result := DllCall("icuuc.dll\ures_getKey", "ptr", resourceBundle, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_resetIterator(resourceBundle) {
        DllCall("icuuc.dll\ures_resetIterator", "ptr", resourceBundle, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @returns {Integer} 
     */
    static ures_hasNext(resourceBundle) {
        result := DllCall("icuuc.dll\ures_hasNext", "ptr", resourceBundle, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Pointer<IntPtr>} fillIn 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_getNextResource(resourceBundle, fillIn, status) {
        DllCall("icuuc.dll\ures_getNextResource", "ptr", resourceBundle, "ptr", fillIn, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<SByte>} key 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ures_getNextString(resourceBundle, len, key, status) {
        result := DllCall("icuuc.dll\ures_getNextString", "ptr", resourceBundle, "ptr", len, "ptr", key, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Integer} indexR 
     * @param {Pointer<IntPtr>} fillIn 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_getByIndex(resourceBundle, indexR, fillIn, status) {
        DllCall("icuuc.dll\ures_getByIndex", "ptr", resourceBundle, "int", indexR, "ptr", fillIn, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Integer} indexS 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ures_getStringByIndex(resourceBundle, indexS, len, status) {
        result := DllCall("icuuc.dll\ures_getStringByIndex", "ptr", resourceBundle, "int", indexS, "ptr", len, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resB 
     * @param {Integer} stringIndex 
     * @param {Pointer<PSTR>} dest 
     * @param {Pointer<Int32>} pLength 
     * @param {Integer} forceCopy 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ures_getUTF8StringByIndex(resB, stringIndex, dest, pLength, forceCopy, status) {
        result := DllCall("icuuc.dll\ures_getUTF8StringByIndex", "ptr", resB, "int", stringIndex, "ptr", dest, "ptr", pLength, "char", forceCopy, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resourceBundle 
     * @param {Pointer<PSTR>} key 
     * @param {Pointer<IntPtr>} fillIn 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_getByKey(resourceBundle, key, fillIn, status) {
        DllCall("icuuc.dll\ures_getByKey", "ptr", resourceBundle, "ptr", key, "ptr", fillIn, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resB 
     * @param {Pointer<PSTR>} key 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ures_getStringByKey(resB, key, len, status) {
        result := DllCall("icuuc.dll\ures_getStringByKey", "ptr", resB, "ptr", key, "ptr", len, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} resB 
     * @param {Pointer<PSTR>} key 
     * @param {Pointer<PSTR>} dest 
     * @param {Pointer<Int32>} pLength 
     * @param {Integer} forceCopy 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ures_getUTF8StringByKey(resB, key, dest, pLength, forceCopy, status) {
        result := DllCall("icuuc.dll\ures_getUTF8StringByKey", "ptr", resB, "ptr", key, "ptr", dest, "ptr", pLength, "char", forceCopy, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} packageName 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_openAvailableLocales(packageName, status) {
        DllCall("icuuc.dll\ures_openAvailableLocales", "ptr", packageName, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} dialectHandling 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static uldn_open(locale, dialectHandling, pErrorCode) {
        DllCall("icuuc.dll\uldn_open", "ptr", locale, "int", dialectHandling, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @returns {String} Nothing - always returns an empty string
     */
    static uldn_close(ldn) {
        DllCall("icuuc.dll\uldn_close", "ptr", ldn, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @returns {Pointer<PSTR>} 
     */
    static uldn_getLocale(ldn) {
        result := DllCall("icuuc.dll\uldn_getLocale", "ptr", ldn, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @returns {String} Nothing - always returns an empty string
     */
    static uldn_getDialectHandling(ldn) {
        DllCall("icuuc.dll\uldn_getDialectHandling", "ptr", ldn, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_localeDisplayName(ldn, locale, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_localeDisplayName", "ptr", ldn, "ptr", locale, "ptr", result, "int", maxResultSize, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Pointer<PSTR>} lang 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_languageDisplayName(ldn, lang, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_languageDisplayName", "ptr", ldn, "ptr", lang, "ptr", result, "int", maxResultSize, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Pointer<PSTR>} script 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_scriptDisplayName(ldn, script, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_scriptDisplayName", "ptr", ldn, "ptr", script, "ptr", result, "int", maxResultSize, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Integer} scriptCode 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_scriptCodeDisplayName(ldn, scriptCode, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_scriptCodeDisplayName", "ptr", ldn, "int", scriptCode, "ptr", result, "int", maxResultSize, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Pointer<PSTR>} region 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_regionDisplayName(ldn, region, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_regionDisplayName", "ptr", ldn, "ptr", region, "ptr", result, "int", maxResultSize, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Pointer<PSTR>} variant 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_variantDisplayName(ldn, variant, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_variantDisplayName", "ptr", ldn, "ptr", variant, "ptr", result, "int", maxResultSize, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Pointer<PSTR>} key 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_keyDisplayName(ldn, key, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_keyDisplayName", "ptr", ldn, "ptr", key, "ptr", result, "int", maxResultSize, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Pointer<PSTR>} key 
     * @param {Pointer<PSTR>} value 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_keyValueDisplayName(ldn, key, value, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_keyValueDisplayName", "ptr", ldn, "ptr", key, "ptr", value, "ptr", result, "int", maxResultSize, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} contexts 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static uldn_openForContext(locale, contexts, length, pErrorCode) {
        DllCall("icuuc.dll\uldn_openForContext", "ptr", locale, "ptr", contexts, "int", length, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ldn 
     * @param {Integer} type 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static uldn_getContext(ldn, type, pErrorCode) {
        DllCall("icuuc.dll\uldn_getContext", "ptr", ldn, "int", type, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} buff 
     * @param {Integer} buffCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_forLocale(locale, buff, buffCapacity, ec) {
        result := DllCall("icuuc.dll\ucurr_forLocale", "ptr", locale, "ptr", buff, "int", buffCapacity, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} isoCode 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucurr_register(isoCode, locale, status) {
        DllCall("icuuc.dll\ucurr_register", "ptr", isoCode, "ptr", locale, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} key 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucurr_unregister(key, status) {
        result := DllCall("icuuc.dll\ucurr_unregister", "ptr", key, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} nameStyle 
     * @param {Pointer<SByte>} isChoiceFormat 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UInt16>} 
     */
    static ucurr_getName(currency, locale, nameStyle, isChoiceFormat, len, ec) {
        result := DllCall("icuuc.dll\ucurr_getName", "ptr", currency, "ptr", locale, "int", nameStyle, "ptr", isChoiceFormat, "ptr", len, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<SByte>} isChoiceFormat 
     * @param {Pointer<PSTR>} pluralCount 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UInt16>} 
     */
    static ucurr_getPluralName(currency, locale, isChoiceFormat, pluralCount, len, ec) {
        result := DllCall("icuuc.dll\ucurr_getPluralName", "ptr", currency, "ptr", locale, "ptr", isChoiceFormat, "ptr", pluralCount, "ptr", len, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_getDefaultFractionDigits(currency, ec) {
        result := DllCall("icuuc.dll\ucurr_getDefaultFractionDigits", "ptr", currency, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Integer} usage 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_getDefaultFractionDigitsForUsage(currency, usage, ec) {
        result := DllCall("icuuc.dll\ucurr_getDefaultFractionDigitsForUsage", "ptr", currency, "int", usage, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucurr_getRoundingIncrement(currency, ec) {
        DllCall("icuuc.dll\ucurr_getRoundingIncrement", "ptr", currency, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Integer} usage 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucurr_getRoundingIncrementForUsage(currency, usage, ec) {
        DllCall("icuuc.dll\ucurr_getRoundingIncrementForUsage", "ptr", currency, "int", usage, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Integer} currType 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucurr_openISOCurrencies(currType, pErrorCode) {
        DllCall("icuuc.dll\ucurr_openISOCurrencies", "uint", currType, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} isoCode 
     * @param {Float} from 
     * @param {Float} to 
     * @param {Pointer<Int32>} errorCode 
     * @returns {Integer} 
     */
    static ucurr_isAvailable(isoCode, from, to, errorCode) {
        result := DllCall("icuuc.dll\ucurr_isAvailable", "ptr", isoCode, "double", from, "double", to, "ptr", errorCode, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Float} date 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_countCurrencies(locale, date, ec) {
        result := DllCall("icuuc.dll\ucurr_countCurrencies", "ptr", locale, "double", date, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Float} date 
     * @param {Integer} index 
     * @param {Pointer<UInt16>} buff 
     * @param {Integer} buffCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_forLocaleAndDate(locale, date, index, buff, buffCapacity, ec) {
        result := DllCall("icuuc.dll\ucurr_forLocaleAndDate", "ptr", locale, "double", date, "int", index, "ptr", buff, "int", buffCapacity, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} key 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucurr_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        DllCall("icuuc.dll\ucurr_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @returns {Integer} 
     */
    static ucurr_getNumericCode(currency) {
        result := DllCall("icuuc.dll\ucurr_getNumericCode", "ptr", currency, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} map 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucpmap_get(map, c) {
        result := DllCall("icu.dll\ucpmap_get", "ptr", map, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} map 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<UCPMapValueFilter>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UInt32>} pValue 
     * @returns {Integer} 
     */
    static ucpmap_getRange(map, start, option, surrogateValue, filter, context, pValue) {
        result := DllCall("icu.dll\ucpmap_getRange", "ptr", map, "int", start, "int", option, "uint", surrogateValue, "ptr", filter, "ptr", context, "ptr", pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Integer} valueWidth 
     * @param {Pointer<Void>} data 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pActualLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucptrie_openFromBinary(type, valueWidth, data, length, pActualLength, pErrorCode) {
        DllCall("icu.dll\ucptrie_openFromBinary", "int", type, "int", valueWidth, "ptr", data, "int", length, "ptr", pActualLength, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucptrie_close(trie) {
        DllCall("icu.dll\ucptrie_close", "ptr", trie, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucptrie_getType(trie) {
        DllCall("icu.dll\ucptrie_getType", "ptr", trie, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucptrie_getValueWidth(trie) {
        DllCall("icu.dll\ucptrie_getValueWidth", "ptr", trie, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucptrie_get(trie, c) {
        result := DllCall("icu.dll\ucptrie_get", "ptr", trie, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<UCPMapValueFilter>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UInt32>} pValue 
     * @returns {Integer} 
     */
    static ucptrie_getRange(trie, start, option, surrogateValue, filter, context, pValue) {
        result := DllCall("icu.dll\ucptrie_getRange", "ptr", trie, "int", start, "int", option, "uint", surrogateValue, "ptr", filter, "ptr", context, "ptr", pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Pointer<Void>} data 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucptrie_toBinary(trie, data, capacity, pErrorCode) {
        result := DllCall("icu.dll\ucptrie_toBinary", "ptr", trie, "ptr", data, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucptrie_internalSmallIndex(trie, c) {
        result := DllCall("icu.dll\ucptrie_internalSmallIndex", "ptr", trie, "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} lt1 
     * @param {Integer} t2 
     * @param {Integer} t3 
     * @returns {Integer} 
     */
    static ucptrie_internalSmallU8Index(trie, lt1, t2, t3) {
        result := DllCall("icu.dll\ucptrie_internalSmallU8Index", "ptr", trie, "int", lt1, "char", t2, "char", t3, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @param {Pointer<Byte>} start 
     * @param {Pointer<Byte>} src 
     * @returns {Integer} 
     */
    static ucptrie_internalU8PrevIndex(trie, c, start, src) {
        result := DllCall("icu.dll\ucptrie_internalU8PrevIndex", "ptr", trie, "int", c, "ptr", start, "ptr", src, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} initialValue 
     * @param {Integer} errorValue 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_open(initialValue, errorValue, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_open", "uint", initialValue, "uint", errorValue, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} other 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_clone(other, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_clone", "ptr", other, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} trie 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_close(trie) {
        DllCall("icu.dll\umutablecptrie_close", "ptr", trie, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} map 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_fromUCPMap(map, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_fromUCPMap", "ptr", map, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_fromUCPTrie(trie, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_fromUCPTrie", "ptr", trie, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static umutablecptrie_get(trie, c) {
        result := DllCall("icu.dll\umutablecptrie_get", "ptr", trie, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} trie 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<UCPMapValueFilter>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UInt32>} pValue 
     * @returns {Integer} 
     */
    static umutablecptrie_getRange(trie, start, option, surrogateValue, filter, context, pValue) {
        result := DllCall("icu.dll\umutablecptrie_getRange", "ptr", trie, "int", start, "int", option, "uint", surrogateValue, "ptr", filter, "ptr", context, "ptr", pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} trie 
     * @param {Integer} c 
     * @param {Integer} value 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_set(trie, c, value, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_set", "ptr", trie, "int", c, "uint", value, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} trie 
     * @param {Integer} start 
     * @param {Integer} end 
     * @param {Integer} value 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_setRange(trie, start, end, value, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_setRange", "ptr", trie, "int", start, "int", end, "uint", value, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} trie 
     * @param {Integer} type 
     * @param {Integer} valueWidth 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_buildImmutable(trie, type, valueWidth, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_buildImmutable", "ptr", trie, "int", type, "int", valueWidth, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<UInt16>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_STOP(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_STOP", "ptr", context, "ptr", fromUArgs, "ptr", codeUnits, "int", length, "int", codePoint, "int", reason, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {Pointer<PSTR>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_STOP(context, toUArgs, codeUnits, length, reason, err) {
        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_STOP", "ptr", context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<UInt16>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_SKIP(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_SKIP", "ptr", context, "ptr", fromUArgs, "ptr", codeUnits, "int", length, "int", codePoint, "int", reason, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<UInt16>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_SUBSTITUTE(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_SUBSTITUTE", "ptr", context, "ptr", fromUArgs, "ptr", codeUnits, "int", length, "int", codePoint, "int", reason, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<UInt16>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_ESCAPE(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_ESCAPE", "ptr", context, "ptr", fromUArgs, "ptr", codeUnits, "int", length, "int", codePoint, "int", reason, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {Pointer<PSTR>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_SKIP(context, toUArgs, codeUnits, length, reason, err) {
        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_SKIP", "ptr", context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {Pointer<PSTR>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_SUBSTITUTE(context, toUArgs, codeUnits, length, reason, err) {
        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_SUBSTITUTE", "ptr", context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {Pointer<PSTR>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_ESCAPE(context, toUArgs, codeUnits, length, reason, err) {
        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_ESCAPE", "ptr", context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} name1 
     * @param {Pointer<PSTR>} name2 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_compareNames(name1, name2) {
        DllCall("icuuc.dll\ucnv_compareNames", "ptr", name1, "ptr", name2, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} converterName 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_open(converterName, err) {
        DllCall("icuuc.dll\ucnv_open", "ptr", converterName, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} name 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_openU(name, err) {
        DllCall("icuuc.dll\ucnv_openU", "ptr", name, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Integer} codepage 
     * @param {Integer} platform 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_openCCSID(codepage, platform, err) {
        DllCall("icuuc.dll\ucnv_openCCSID", "int", codepage, "int", platform, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} packageName 
     * @param {Pointer<PSTR>} converterName 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_openPackage(packageName, converterName, err) {
        DllCall("icuuc.dll\ucnv_openPackage", "ptr", packageName, "ptr", converterName, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Int32>} pBufferSize 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_safeClone(cnv, stackBuffer, pBufferSize, status) {
        DllCall("icuuc.dll\ucnv_safeClone", "ptr", cnv, "ptr", stackBuffer, "ptr", pBufferSize, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_close(converter) {
        DllCall("icuuc.dll\ucnv_close", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<PSTR>} subChars 
     * @param {Pointer<SByte>} len 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getSubstChars(converter, subChars, len, err) {
        DllCall("icuuc.dll\ucnv_getSubstChars", "ptr", converter, "ptr", subChars, "ptr", len, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<PSTR>} subChars 
     * @param {Integer} len 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setSubstChars(converter, subChars, len, err) {
        DllCall("icuuc.dll\ucnv_setSubstChars", "ptr", converter, "ptr", subChars, "char", len, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setSubstString(cnv, s, length, err) {
        DllCall("icuuc.dll\ucnv_setSubstString", "ptr", cnv, "ptr", s, "int", length, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<PSTR>} errBytes 
     * @param {Pointer<SByte>} len 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getInvalidChars(converter, errBytes, len, err) {
        DllCall("icuuc.dll\ucnv_getInvalidChars", "ptr", converter, "ptr", errBytes, "ptr", len, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<UInt16>} errUChars 
     * @param {Pointer<SByte>} len 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getInvalidUChars(converter, errUChars, len, err) {
        DllCall("icuuc.dll\ucnv_getInvalidUChars", "ptr", converter, "ptr", errUChars, "ptr", len, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_reset(converter) {
        DllCall("icuuc.dll\ucnv_reset", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_resetToUnicode(converter) {
        DllCall("icuuc.dll\ucnv_resetToUnicode", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_resetFromUnicode(converter) {
        DllCall("icuuc.dll\ucnv_resetFromUnicode", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @returns {Integer} 
     */
    static ucnv_getMaxCharSize(converter) {
        result := DllCall("icuuc.dll\ucnv_getMaxCharSize", "ptr", converter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @returns {Integer} 
     */
    static ucnv_getMinCharSize(converter) {
        result := DllCall("icuuc.dll\ucnv_getMinCharSize", "ptr", converter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<PSTR>} displayLocale 
     * @param {Pointer<UInt16>} displayName 
     * @param {Integer} displayNameCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static ucnv_getDisplayName(converter, displayLocale, displayName, displayNameCapacity, err) {
        result := DllCall("icuuc.dll\ucnv_getDisplayName", "ptr", converter, "ptr", displayLocale, "ptr", displayName, "int", displayNameCapacity, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<Int32>} err 
     * @returns {Pointer<PSTR>} 
     */
    static ucnv_getName(converter, err) {
        result := DllCall("icuuc.dll\ucnv_getName", "ptr", converter, "ptr", err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static ucnv_getCCSID(converter, err) {
        result := DllCall("icuuc.dll\ucnv_getCCSID", "ptr", converter, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getPlatform(converter, err) {
        DllCall("icuuc.dll\ucnv_getPlatform", "ptr", converter, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getType(converter) {
        DllCall("icuuc.dll\ucnv_getType", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<SByte>} starters 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getStarters(converter, starters, err) {
        DllCall("icuuc.dll\ucnv_getStarters", "ptr", converter, "ptr", starters, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<IntPtr>} setFillIn 
     * @param {Integer} whichSet 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getUnicodeSet(cnv, setFillIn, whichSet, pErrorCode) {
        DllCall("icuuc.dll\ucnv_getUnicodeSet", "ptr", cnv, "ptr", setFillIn, "int", whichSet, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<UConverterToUCallback>} action 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getToUCallBack(converter, action, context) {
        DllCall("icuuc.dll\ucnv_getToUCallBack", "ptr", converter, "ptr", action, "ptr", context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<UConverterFromUCallback>} action 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getFromUCallBack(converter, action, context) {
        DllCall("icuuc.dll\ucnv_getFromUCallBack", "ptr", converter, "ptr", action, "ptr", context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<UConverterToUCallback>} newAction 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<UConverterToUCallback>} oldAction 
     * @param {Pointer<Void>} oldContext 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setToUCallBack(converter, newAction, newContext, oldAction, oldContext, err) {
        DllCall("icuuc.dll\ucnv_setToUCallBack", "ptr", converter, "ptr", newAction, "ptr", newContext, "ptr", oldAction, "ptr", oldContext, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<UConverterFromUCallback>} newAction 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<UConverterFromUCallback>} oldAction 
     * @param {Pointer<Void>} oldContext 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setFromUCallBack(converter, newAction, newContext, oldAction, oldContext, err) {
        DllCall("icuuc.dll\ucnv_setFromUCallBack", "ptr", converter, "ptr", newAction, "ptr", newContext, "ptr", oldAction, "ptr", oldContext, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<SByte>} target 
     * @param {Pointer<PSTR>} targetLimit 
     * @param {Pointer<UInt16>} source 
     * @param {Pointer<UInt16>} sourceLimit 
     * @param {Pointer<Int32>} offsets 
     * @param {Integer} flush 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_fromUnicode(converter, target, targetLimit, source, sourceLimit, offsets, flush, err) {
        DllCall("icuuc.dll\ucnv_fromUnicode", "ptr", converter, "ptr", target, "ptr", targetLimit, "ptr", source, "ptr", sourceLimit, "ptr", offsets, "char", flush, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<UInt16>} target 
     * @param {Pointer<UInt16>} targetLimit 
     * @param {Pointer<SByte>} source 
     * @param {Pointer<PSTR>} sourceLimit 
     * @param {Pointer<Int32>} offsets 
     * @param {Integer} flush 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_toUnicode(converter, target, targetLimit, source, sourceLimit, offsets, flush, err) {
        DllCall("icuuc.dll\ucnv_toUnicode", "ptr", converter, "ptr", target, "ptr", targetLimit, "ptr", source, "ptr", sourceLimit, "ptr", offsets, "char", flush, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_fromUChars(cnv, dest, destCapacity, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_fromUChars", "ptr", cnv, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_toUChars(cnv, dest, destCapacity, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_toUChars", "ptr", cnv, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} converter 
     * @param {Pointer<SByte>} source 
     * @param {Pointer<PSTR>} sourceLimit 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static ucnv_getNextUChar(converter, source, sourceLimit, err) {
        result := DllCall("icuuc.dll\ucnv_getNextUChar", "ptr", converter, "ptr", source, "ptr", sourceLimit, "ptr", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} targetCnv 
     * @param {Pointer<IntPtr>} sourceCnv 
     * @param {Pointer<SByte>} target 
     * @param {Pointer<PSTR>} targetLimit 
     * @param {Pointer<SByte>} source 
     * @param {Pointer<PSTR>} sourceLimit 
     * @param {Pointer<UInt16>} pivotStart 
     * @param {Pointer<UInt16>} pivotSource 
     * @param {Pointer<UInt16>} pivotTarget 
     * @param {Pointer<UInt16>} pivotLimit 
     * @param {Integer} reset 
     * @param {Integer} flush 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_convertEx(targetCnv, sourceCnv, target, targetLimit, source, sourceLimit, pivotStart, pivotSource, pivotTarget, pivotLimit, reset, flush, pErrorCode) {
        DllCall("icuuc.dll\ucnv_convertEx", "ptr", targetCnv, "ptr", sourceCnv, "ptr", target, "ptr", targetLimit, "ptr", source, "ptr", sourceLimit, "ptr", pivotStart, "ptr", pivotSource, "ptr", pivotTarget, "ptr", pivotLimit, "char", reset, "char", flush, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} toConverterName 
     * @param {Pointer<PSTR>} fromConverterName 
     * @param {Pointer<PSTR>} target 
     * @param {Integer} targetCapacity 
     * @param {Pointer<PSTR>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_convert(toConverterName, fromConverterName, target, targetCapacity, source, sourceLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_convert", "ptr", toConverterName, "ptr", fromConverterName, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} algorithmicType 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<PSTR>} target 
     * @param {Integer} targetCapacity 
     * @param {Pointer<PSTR>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_toAlgorithmic(algorithmicType, cnv, target, targetCapacity, source, sourceLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_toAlgorithmic", "int", algorithmicType, "ptr", cnv, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Integer} algorithmicType 
     * @param {Pointer<PSTR>} target 
     * @param {Integer} targetCapacity 
     * @param {Pointer<PSTR>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_fromAlgorithmic(cnv, algorithmicType, target, targetCapacity, source, sourceLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_fromAlgorithmic", "ptr", cnv, "int", algorithmicType, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_flushCache() {
        result := DllCall("icuuc.dll\ucnv_flushCache", "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_countAvailable() {
        result := DllCall("icuuc.dll\ucnv_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @returns {Pointer<PSTR>} 
     */
    static ucnv_getAvailableName(n) {
        result := DllCall("icuuc.dll\ucnv_getAvailableName", "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_openAllNames(pErrorCode) {
        DllCall("icuuc.dll\ucnv_openAllNames", "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} alias 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_countAliases(alias, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_countAliases", "ptr", alias, "ptr", pErrorCode, "CDecl ushort")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} alias 
     * @param {Integer} n 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PSTR>} 
     */
    static ucnv_getAlias(alias, n, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_getAlias", "ptr", alias, "ushort", n, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} alias 
     * @param {Pointer<SByte>} aliases 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getAliases(alias, aliases, pErrorCode) {
        DllCall("icuuc.dll\ucnv_getAliases", "ptr", alias, "ptr", aliases, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} convName 
     * @param {Pointer<PSTR>} standard 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_openStandardNames(convName, standard, pErrorCode) {
        DllCall("icuuc.dll\ucnv_openStandardNames", "ptr", convName, "ptr", standard, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_countStandards() {
        result := DllCall("icuuc.dll\ucnv_countStandards", "CDecl ushort")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PSTR>} 
     */
    static ucnv_getStandard(n, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_getStandard", "ushort", n, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} name 
     * @param {Pointer<PSTR>} standard 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PSTR>} 
     */
    static ucnv_getStandardName(name, standard, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_getStandardName", "ptr", name, "ptr", standard, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} alias 
     * @param {Pointer<PSTR>} standard 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PSTR>} 
     */
    static ucnv_getCanonicalName(alias, standard, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_getCanonicalName", "ptr", alias, "ptr", standard, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Pointer<PSTR>} 
     */
    static ucnv_getDefaultName() {
        result := DllCall("icuuc.dll\ucnv_getDefaultName", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} name 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setDefaultName(name) {
        DllCall("icuuc.dll\ucnv_setDefaultName", "ptr", name, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_fixFileSeparator(cnv, source, sourceLen) {
        DllCall("icuuc.dll\ucnv_fixFileSeparator", "ptr", cnv, "ptr", source, "int", sourceLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @returns {Integer} 
     */
    static ucnv_isAmbiguous(cnv) {
        result := DllCall("icuuc.dll\ucnv_isAmbiguous", "ptr", cnv, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Integer} usesFallback 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setFallback(cnv, usesFallback) {
        DllCall("icuuc.dll\ucnv_setFallback", "ptr", cnv, "char", usesFallback, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @returns {Integer} 
     */
    static ucnv_usesFallback(cnv) {
        result := DllCall("icuuc.dll\ucnv_usesFallback", "ptr", cnv, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} signatureLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PSTR>} 
     */
    static ucnv_detectUnicodeSignature(source, sourceLength, signatureLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_detectUnicodeSignature", "ptr", source, "int", sourceLength, "ptr", signatureLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucnv_fromUCountPending(cnv, status) {
        result := DllCall("icuuc.dll\ucnv_fromUCountPending", "ptr", cnv, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucnv_toUCountPending(cnv, status) {
        result := DllCall("icuuc.dll\ucnv_toUCountPending", "ptr", cnv, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} cnv 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucnv_isFixedWidth(cnv, status) {
        result := DllCall("icuuc.dll\ucnv_isFixedWidth", "ptr", cnv, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {Pointer<PSTR>} source 
     * @param {Integer} length 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteBytes(args, source, length, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbFromUWriteBytes", "ptr", args, "ptr", source, "int", length, "int", offsetIndex, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteSub(args, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbFromUWriteSub", "ptr", args, "int", offsetIndex, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {Pointer<UInt16>} source 
     * @param {Pointer<UInt16>} sourceLimit 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteUChars(args, source, sourceLimit, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbFromUWriteUChars", "ptr", args, "ptr", source, "ptr", sourceLimit, "int", offsetIndex, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterToUnicodeArgs>} args 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} length 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbToUWriteUChars(args, source, length, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbToUWriteUChars", "ptr", args, "ptr", source, "int", length, "int", offsetIndex, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterToUnicodeArgs>} args 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbToUWriteSub(args, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbToUWriteSub", "ptr", args, "int", offsetIndex, "ptr", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_init(status) {
        DllCall("icuuc.dll\u_init", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_cleanup() {
        DllCall("icuuc.dll\u_cleanup", "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UMemAllocFn>} a 
     * @param {Pointer<UMemReallocFn>} r 
     * @param {Pointer<UMemFreeFn>} f 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_setMemoryFunctions(context, a, r, f, status) {
        DllCall("icuuc.dll\u_setMemoryFunctions", "ptr", context, "ptr", a, "ptr", r, "ptr", f, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} name 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<IntPtr>} 
     */
    static u_catopen(name, locale, ec) {
        result := DllCall("icuuc.dll\u_catopen", "ptr", name, "ptr", locale, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} catd 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_catclose(catd) {
        DllCall("icuuc.dll\u_catclose", "ptr", catd, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} catd 
     * @param {Integer} set_num 
     * @param {Integer} msg_num 
     * @param {Pointer<UInt16>} s 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UInt16>} 
     */
    static u_catgets(catd, set_num, msg_num, s, len, ec) {
        result := DllCall("icuuc.dll\u_catgets", "ptr", catd, "int", set_num, "int", msg_num, "ptr", s, "ptr", len, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_hasBinaryProperty(c, which) {
        result := DllCall("icuuc.dll\u_hasBinaryProperty", "int", c, "int", which, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<IntPtr>} 
     */
    static u_getBinaryPropertySet(property, pErrorCode) {
        result := DllCall("icu.dll\u_getBinaryPropertySet", "int", property, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUAlphabetic(c) {
        result := DllCall("icuuc.dll\u_isUAlphabetic", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isULowercase(c) {
        result := DllCall("icuuc.dll\u_isULowercase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUUppercase(c) {
        result := DllCall("icuuc.dll\u_isUUppercase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUWhiteSpace(c) {
        result := DllCall("icuuc.dll\u_isUWhiteSpace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyValue(c, which) {
        result := DllCall("icuuc.dll\u_getIntPropertyValue", "int", c, "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyMinValue(which) {
        result := DllCall("icuuc.dll\u_getIntPropertyMinValue", "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyMaxValue(which) {
        result := DllCall("icuuc.dll\u_getIntPropertyMaxValue", "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<IntPtr>} 
     */
    static u_getIntPropertyMap(property, pErrorCode) {
        result := DllCall("icu.dll\u_getIntPropertyMap", "int", property, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getNumericValue(c) {
        DllCall("icuuc.dll\u_getNumericValue", "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_islower(c) {
        result := DllCall("icuuc.dll\u_islower", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isupper(c) {
        result := DllCall("icuuc.dll\u_isupper", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_istitle(c) {
        result := DllCall("icuuc.dll\u_istitle", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isdigit(c) {
        result := DllCall("icuuc.dll\u_isdigit", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isalpha(c) {
        result := DllCall("icuuc.dll\u_isalpha", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isalnum(c) {
        result := DllCall("icuuc.dll\u_isalnum", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isxdigit(c) {
        result := DllCall("icuuc.dll\u_isxdigit", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_ispunct(c) {
        result := DllCall("icuuc.dll\u_ispunct", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isgraph(c) {
        result := DllCall("icuuc.dll\u_isgraph", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isblank(c) {
        result := DllCall("icuuc.dll\u_isblank", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isdefined(c) {
        result := DllCall("icuuc.dll\u_isdefined", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isspace(c) {
        result := DllCall("icuuc.dll\u_isspace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaSpaceChar(c) {
        result := DllCall("icuuc.dll\u_isJavaSpaceChar", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isWhitespace(c) {
        result := DllCall("icuuc.dll\u_isWhitespace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_iscntrl(c) {
        result := DllCall("icuuc.dll\u_iscntrl", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isISOControl(c) {
        result := DllCall("icuuc.dll\u_isISOControl", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isprint(c) {
        result := DllCall("icuuc.dll\u_isprint", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isbase(c) {
        result := DllCall("icuuc.dll\u_isbase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_charDirection(c) {
        DllCall("icuuc.dll\u_charDirection", "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isMirrored(c) {
        result := DllCall("icuuc.dll\u_isMirrored", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charMirror(c) {
        result := DllCall("icuuc.dll\u_charMirror", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_getBidiPairedBracket(c) {
        result := DllCall("icuuc.dll\u_getBidiPairedBracket", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charType(c) {
        result := DllCall("icuuc.dll\u_charType", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharEnumTypeRange>} enumRange 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_enumCharTypes(enumRange, context) {
        DllCall("icuuc.dll\u_enumCharTypes", "ptr", enumRange, "ptr", context, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_getCombiningClass(c) {
        result := DllCall("icuuc.dll\u_getCombiningClass", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charDigitValue(c) {
        result := DllCall("icuuc.dll\u_charDigitValue", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static ublock_getCode(c) {
        DllCall("icuuc.dll\ublock_getCode", "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Integer} code 
     * @param {Integer} nameChoice 
     * @param {Pointer<PSTR>} buffer 
     * @param {Integer} bufferLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_charName(code, nameChoice, buffer, bufferLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_charName", "int", code, "int", nameChoice, "ptr", buffer, "int", bufferLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} nameChoice 
     * @param {Pointer<PSTR>} name 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_charFromName(nameChoice, name, pErrorCode) {
        result := DllCall("icuuc.dll\u_charFromName", "int", nameChoice, "ptr", name, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<UEnumCharNamesFn>} fn 
     * @param {Pointer<Void>} context 
     * @param {Integer} nameChoice 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_enumCharNames(start, limit, fn, context, nameChoice, pErrorCode) {
        DllCall("icuuc.dll\u_enumCharNames", "int", start, "int", limit, "ptr", fn, "ptr", context, "int", nameChoice, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Integer} nameChoice 
     * @returns {Pointer<PSTR>} 
     */
    static u_getPropertyName(property, nameChoice) {
        result := DllCall("icuuc.dll\u_getPropertyName", "int", property, "int", nameChoice, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} alias 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getPropertyEnum(alias) {
        DllCall("icuuc.dll\u_getPropertyEnum", "ptr", alias, "CDecl ")
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Integer} value 
     * @param {Integer} nameChoice 
     * @returns {Pointer<PSTR>} 
     */
    static u_getPropertyValueName(property, value, nameChoice) {
        result := DllCall("icuuc.dll\u_getPropertyValueName", "int", property, "int", value, "int", nameChoice, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Pointer<PSTR>} alias 
     * @returns {Integer} 
     */
    static u_getPropertyValueEnum(property, alias) {
        result := DllCall("icuuc.dll\u_getPropertyValueEnum", "int", property, "ptr", alias, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDStart(c) {
        result := DllCall("icuuc.dll\u_isIDStart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDPart(c) {
        result := DllCall("icuuc.dll\u_isIDPart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDIgnorable(c) {
        result := DllCall("icuuc.dll\u_isIDIgnorable", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaIDStart(c) {
        result := DllCall("icuuc.dll\u_isJavaIDStart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaIDPart(c) {
        result := DllCall("icuuc.dll\u_isJavaIDPart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_tolower(c) {
        result := DllCall("icuuc.dll\u_tolower", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_toupper(c) {
        result := DllCall("icuuc.dll\u_toupper", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_totitle(c) {
        result := DllCall("icuuc.dll\u_totitle", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_foldCase(c, options) {
        result := DllCall("icuuc.dll\u_foldCase", "int", c, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} ch 
     * @param {Integer} radix 
     * @returns {Integer} 
     */
    static u_digit(ch, radix) {
        result := DllCall("icuuc.dll\u_digit", "int", ch, "char", radix, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} digit 
     * @param {Integer} radix 
     * @returns {Integer} 
     */
    static u_forDigit(digit, radix) {
        result := DllCall("icuuc.dll\u_forDigit", "int", digit, "char", radix, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<Byte>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_charAge(c, versionArray) {
        DllCall("icuuc.dll\u_charAge", "int", c, "ptr", versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getUnicodeVersion(versionArray) {
        DllCall("icuuc.dll\u_getUnicodeVersion", "ptr", versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_getFC_NFKC_Closure(c, dest, destCapacity, pErrorCode) {
        result := DllCall("icuuc.dll\u_getFC_NFKC_Closure", "int", c, "ptr", dest, "int", destCapacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_open() {
        DllCall("icuuc.dll\ubidi_open", "CDecl ")
    }

    /**
     * 
     * @param {Integer} maxLength 
     * @param {Integer} maxRunCount 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_openSized(maxLength, maxRunCount, pErrorCode) {
        DllCall("icuuc.dll\ubidi_openSized", "int", maxLength, "int", maxRunCount, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_close(pBiDi) {
        DllCall("icuuc.dll\ubidi_close", "ptr", pBiDi, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} isInverse 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setInverse(pBiDi, isInverse) {
        DllCall("icuuc.dll\ubidi_setInverse", "ptr", pBiDi, "char", isInverse, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_isInverse(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_isInverse", "ptr", pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} orderParagraphsLTR 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_orderParagraphsLTR(pBiDi, orderParagraphsLTR) {
        DllCall("icuuc.dll\ubidi_orderParagraphsLTR", "ptr", pBiDi, "char", orderParagraphsLTR, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_isOrderParagraphsLTR(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_isOrderParagraphsLTR", "ptr", pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} reorderingMode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setReorderingMode(pBiDi, reorderingMode) {
        DllCall("icuuc.dll\ubidi_setReorderingMode", "ptr", pBiDi, "int", reorderingMode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getReorderingMode(pBiDi) {
        DllCall("icuuc.dll\ubidi_getReorderingMode", "ptr", pBiDi, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} reorderingOptions 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setReorderingOptions(pBiDi, reorderingOptions) {
        DllCall("icuuc.dll\ubidi_setReorderingOptions", "ptr", pBiDi, "uint", reorderingOptions, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getReorderingOptions(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getReorderingOptions", "ptr", pBiDi, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<UInt16>} prologue 
     * @param {Integer} proLength 
     * @param {Pointer<UInt16>} epilogue 
     * @param {Integer} epiLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setContext(pBiDi, prologue, proLength, epilogue, epiLength, pErrorCode) {
        DllCall("icuuc.dll\ubidi_setContext", "ptr", pBiDi, "ptr", prologue, "int", proLength, "ptr", epilogue, "int", epiLength, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} length 
     * @param {Integer} paraLevel 
     * @param {Pointer<Byte>} embeddingLevels 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setPara(pBiDi, text, length, paraLevel, embeddingLevels, pErrorCode) {
        DllCall("icuuc.dll\ubidi_setPara", "ptr", pBiDi, "ptr", text, "int", length, "char", paraLevel, "ptr", embeddingLevels, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pParaBiDi 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<IntPtr>} pLineBiDi 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setLine(pParaBiDi, start, limit, pLineBiDi, pErrorCode) {
        DllCall("icuuc.dll\ubidi_setLine", "ptr", pParaBiDi, "int", start, "int", limit, "ptr", pLineBiDi, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getDirection(pBiDi) {
        DllCall("icuuc.dll\ubidi_getDirection", "ptr", pBiDi, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getBaseDirection(text, length) {
        DllCall("icuuc.dll\ubidi_getBaseDirection", "ptr", text, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Pointer<UInt16>} 
     */
    static ubidi_getText(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getText", "ptr", pBiDi, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getLength(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getLength", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getParaLevel(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getParaLevel", "ptr", pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_countParagraphs(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_countParagraphs", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} charIndex 
     * @param {Pointer<Int32>} pParaStart 
     * @param {Pointer<Int32>} pParaLimit 
     * @param {Pointer<Byte>} pParaLevel 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getParagraph(pBiDi, charIndex, pParaStart, pParaLimit, pParaLevel, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_getParagraph", "ptr", pBiDi, "int", charIndex, "ptr", pParaStart, "ptr", pParaLimit, "ptr", pParaLevel, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} paraIndex 
     * @param {Pointer<Int32>} pParaStart 
     * @param {Pointer<Int32>} pParaLimit 
     * @param {Pointer<Byte>} pParaLevel 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getParagraphByIndex(pBiDi, paraIndex, pParaStart, pParaLimit, pParaLevel, pErrorCode) {
        DllCall("icuuc.dll\ubidi_getParagraphByIndex", "ptr", pBiDi, "int", paraIndex, "ptr", pParaStart, "ptr", pParaLimit, "ptr", pParaLevel, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} charIndex 
     * @returns {Integer} 
     */
    static ubidi_getLevelAt(pBiDi, charIndex) {
        result := DllCall("icuuc.dll\ubidi_getLevelAt", "ptr", pBiDi, "int", charIndex, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Byte>} 
     */
    static ubidi_getLevels(pBiDi, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_getLevels", "ptr", pBiDi, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} logicalPosition 
     * @param {Pointer<Int32>} pLogicalLimit 
     * @param {Pointer<Byte>} pLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getLogicalRun(pBiDi, logicalPosition, pLogicalLimit, pLevel) {
        DllCall("icuuc.dll\ubidi_getLogicalRun", "ptr", pBiDi, "int", logicalPosition, "ptr", pLogicalLimit, "ptr", pLevel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_countRuns(pBiDi, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_countRuns", "ptr", pBiDi, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} runIndex 
     * @param {Pointer<Int32>} pLogicalStart 
     * @param {Pointer<Int32>} pLength 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getVisualRun(pBiDi, runIndex, pLogicalStart, pLength) {
        DllCall("icuuc.dll\ubidi_getVisualRun", "ptr", pBiDi, "int", runIndex, "ptr", pLogicalStart, "ptr", pLength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} logicalIndex 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getVisualIndex(pBiDi, logicalIndex, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_getVisualIndex", "ptr", pBiDi, "int", logicalIndex, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} visualIndex 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getLogicalIndex(pBiDi, visualIndex, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_getLogicalIndex", "ptr", pBiDi, "int", visualIndex, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<Int32>} indexMap 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getLogicalMap(pBiDi, indexMap, pErrorCode) {
        DllCall("icuuc.dll\ubidi_getLogicalMap", "ptr", pBiDi, "ptr", indexMap, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<Int32>} indexMap 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getVisualMap(pBiDi, indexMap, pErrorCode) {
        DllCall("icuuc.dll\ubidi_getVisualMap", "ptr", pBiDi, "ptr", indexMap, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} levels 
     * @param {Integer} length 
     * @param {Pointer<Int32>} indexMap 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_reorderLogical(levels, length, indexMap) {
        DllCall("icuuc.dll\ubidi_reorderLogical", "ptr", levels, "int", length, "ptr", indexMap, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} levels 
     * @param {Integer} length 
     * @param {Pointer<Int32>} indexMap 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_reorderVisual(levels, length, indexMap) {
        DllCall("icuuc.dll\ubidi_reorderVisual", "ptr", levels, "int", length, "ptr", indexMap, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} srcMap 
     * @param {Pointer<Int32>} destMap 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_invertMap(srcMap, destMap, length) {
        DllCall("icuuc.dll\ubidi_invertMap", "ptr", srcMap, "ptr", destMap, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getProcessedLength(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getProcessedLength", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getResultLength(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getResultLength", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getCustomizedClass(pBiDi, c) {
        DllCall("icuuc.dll\ubidi_getCustomizedClass", "ptr", pBiDi, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<UBiDiClassCallback>} newFn 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<UBiDiClassCallback>} oldFn 
     * @param {Pointer<Void>} oldContext 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setClassCallback(pBiDi, newFn, newContext, oldFn, oldContext, pErrorCode) {
        DllCall("icuuc.dll\ubidi_setClassCallback", "ptr", pBiDi, "ptr", newFn, "ptr", newContext, "ptr", oldFn, "ptr", oldContext, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<UBiDiClassCallback>} fn 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getClassCallback(pBiDi, fn, context) {
        DllCall("icuuc.dll\ubidi_getClassCallback", "ptr", pBiDi, "ptr", fn, "ptr", context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDi 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_writeReordered(pBiDi, dest, destSize, options, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_writeReordered", "ptr", pBiDi, "ptr", dest, "int", destSize, "ushort", options, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_writeReverse(src, srcLength, dest, destSize, options, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_writeReverse", "ptr", src, "int", srcLength, "ptr", dest, "int", destSize, "ushort", options, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBiDiTransform 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destSize 
     * @param {Integer} inParaLevel 
     * @param {Integer} inOrder 
     * @param {Integer} outParaLevel 
     * @param {Integer} outOrder 
     * @param {Integer} doMirroring 
     * @param {Integer} shapingOptions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubiditransform_transform(pBiDiTransform, src, srcLength, dest, destSize, inParaLevel, inOrder, outParaLevel, outOrder, doMirroring, shapingOptions, pErrorCode) {
        result := DllCall("icuuc.dll\ubiditransform_transform", "ptr", pBiDiTransform, "ptr", src, "int", srcLength, "ptr", dest, "int", destSize, "char", inParaLevel, "int", inOrder, "char", outParaLevel, "int", outOrder, "int", doMirroring, "uint", shapingOptions, "ptr", pErrorCode, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubiditransform_open(pErrorCode) {
        DllCall("icuuc.dll\ubiditransform_open", "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pBidiTransform 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubiditransform_close(pBidiTransform) {
        DllCall("icuuc.dll\ubiditransform_close", "ptr", pBidiTransform, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_close(ut) {
        DllCall("icuuc.dll\utext_close", "ptr", ut, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Pointer<PSTR>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_openUTF8(ut, s, length, status) {
        DllCall("icuuc.dll\utext_openUTF8", "ptr", ut, "ptr", s, "int64", length, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_openUChars(ut, s, length, status) {
        DllCall("icuuc.dll\utext_openUChars", "ptr", ut, "ptr", s, "int64", length, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<UText>} src 
     * @param {Integer} deep 
     * @param {Integer} readOnly 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_clone(dest, src, deep, readOnly, status) {
        DllCall("icuuc.dll\utext_clone", "ptr", dest, "ptr", src, "char", deep, "char", readOnly, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} a 
     * @param {Pointer<UText>} b 
     * @returns {Integer} 
     */
    static utext_equals(a, b) {
        result := DllCall("icuuc.dll\utext_equals", "ptr", a, "ptr", b, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_nativeLength(ut) {
        result := DllCall("icuuc.dll\utext_nativeLength", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_isLengthExpensive(ut) {
        result := DllCall("icuuc.dll\utext_isLengthExpensive", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_char32At(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_char32At", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_current32(ut) {
        result := DllCall("icuuc.dll\utext_current32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_next32(ut) {
        result := DllCall("icuuc.dll\utext_next32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_previous32(ut) {
        result := DllCall("icuuc.dll\utext_previous32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_next32From(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_next32From", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_previous32From(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_previous32From", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_getNativeIndex(ut) {
        result := DllCall("icuuc.dll\utext_getNativeIndex", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_setNativeIndex(ut, nativeIndex) {
        DllCall("icuuc.dll\utext_setNativeIndex", "ptr", ut, "int64", nativeIndex, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} delta 
     * @returns {Integer} 
     */
    static utext_moveIndex32(ut, delta) {
        result := DllCall("icuuc.dll\utext_moveIndex32", "ptr", ut, "int", delta, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_getPreviousNativeIndex(ut) {
        result := DllCall("icuuc.dll\utext_getPreviousNativeIndex", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utext_extract(ut, nativeStart, nativeLimit, dest, destCapacity, status) {
        result := DllCall("icuuc.dll\utext_extract", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, "ptr", dest, "int", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_isWritable(ut) {
        result := DllCall("icuuc.dll\utext_isWritable", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_hasMetaData(ut) {
        result := DllCall("icuuc.dll\utext_hasMetaData", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Pointer<UInt16>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utext_replace(ut, nativeStart, nativeLimit, replacementText, replacementLength, status) {
        result := DllCall("icuuc.dll\utext_replace", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, "ptr", replacementText, "int", replacementLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Integer} destIndex 
     * @param {Integer} move 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_copy(ut, nativeStart, nativeLimit, destIndex, move, status) {
        DllCall("icuuc.dll\utext_copy", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, "int64", destIndex, "char", move, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_freeze(ut) {
        DllCall("icuuc.dll\utext_freeze", "ptr", ut, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} extraSpace 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_setup(ut, extraSpace, status) {
        DllCall("icuuc.dll\utext_setup", "ptr", ut, "int", extraSpace, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_openEmpty() {
        DllCall("icuuc.dll\uset_openEmpty", "CDecl ")
    }

    /**
     * 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_open(start, end) {
        DllCall("icuuc.dll\uset_open", "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_openPattern(pattern, patternLength, ec) {
        DllCall("icuuc.dll\uset_openPattern", "ptr", pattern, "int", patternLength, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} options 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_openPatternOptions(pattern, patternLength, options, ec) {
        DllCall("icuuc.dll\uset_openPatternOptions", "ptr", pattern, "int", patternLength, "uint", options, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_close(set) {
        DllCall("icuuc.dll\uset_close", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_clone(set) {
        DllCall("icuuc.dll\uset_clone", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {Integer} 
     */
    static uset_isFrozen(set) {
        result := DllCall("icuuc.dll\uset_isFrozen", "ptr", set, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_freeze(set) {
        DllCall("icuuc.dll\uset_freeze", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_cloneAsThawed(set) {
        DllCall("icuuc.dll\uset_cloneAsThawed", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_set(set, start, end) {
        DllCall("icuuc.dll\uset_set", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} options 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uset_applyPattern(set, pattern, patternLength, options, status) {
        result := DllCall("icuuc.dll\uset_applyPattern", "ptr", set, "ptr", pattern, "int", patternLength, "uint", options, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} prop 
     * @param {Integer} value 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_applyIntPropertyValue(set, prop, value, ec) {
        DllCall("icuuc.dll\uset_applyIntPropertyValue", "ptr", set, "int", prop, "int", value, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} prop 
     * @param {Integer} propLength 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} valueLength 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_applyPropertyAlias(set, prop, propLength, value, valueLength, ec) {
        DllCall("icuuc.dll\uset_applyPropertyAlias", "ptr", set, "ptr", prop, "int", propLength, "ptr", value, "int", valueLength, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} pos 
     * @returns {Integer} 
     */
    static uset_resemblesPattern(pattern, patternLength, pos) {
        result := DllCall("icuuc.dll\uset_resemblesPattern", "ptr", pattern, "int", patternLength, "int", pos, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Integer} escapeUnprintable 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static uset_toPattern(set, result, resultCapacity, escapeUnprintable, ec) {
        result := DllCall("icuuc.dll\uset_toPattern", "ptr", set, "ptr", result, "int", resultCapacity, "char", escapeUnprintable, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_add(set, c) {
        DllCall("icuuc.dll\uset_add", "ptr", set, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<IntPtr>} additionalSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addAll(set, additionalSet) {
        DllCall("icuuc.dll\uset_addAll", "ptr", set, "ptr", additionalSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addRange(set, start, end) {
        DllCall("icuuc.dll\uset_addRange", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addString(set, str, strLen) {
        DllCall("icuuc.dll\uset_addString", "ptr", set, "ptr", str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addAllCodePoints(set, str, strLen) {
        DllCall("icuuc.dll\uset_addAllCodePoints", "ptr", set, "ptr", str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_remove(set, c) {
        DllCall("icuuc.dll\uset_remove", "ptr", set, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeRange(set, start, end) {
        DllCall("icuuc.dll\uset_removeRange", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeString(set, str, strLen) {
        DllCall("icuuc.dll\uset_removeString", "ptr", set, "ptr", str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<IntPtr>} removeSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeAll(set, removeSet) {
        DllCall("icuuc.dll\uset_removeAll", "ptr", set, "ptr", removeSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retain(set, start, end) {
        DllCall("icuuc.dll\uset_retain", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<IntPtr>} retain 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retainAll(set, retain) {
        DllCall("icuuc.dll\uset_retainAll", "ptr", set, "ptr", retain, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_compact(set) {
        DllCall("icuuc.dll\uset_compact", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complement(set) {
        DllCall("icuuc.dll\uset_complement", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<IntPtr>} complement 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementAll(set, complement) {
        DllCall("icuuc.dll\uset_complementAll", "ptr", set, "ptr", complement, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_clear(set) {
        DllCall("icuuc.dll\uset_clear", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} attributes 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_closeOver(set, attributes) {
        DllCall("icuuc.dll\uset_closeOver", "ptr", set, "int", attributes, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeAllStrings(set) {
        DllCall("icuuc.dll\uset_removeAllStrings", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {Integer} 
     */
    static uset_isEmpty(set) {
        result := DllCall("icuuc.dll\uset_isEmpty", "ptr", set, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_contains(set, c) {
        result := DllCall("icuuc.dll\uset_contains", "ptr", set, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {Integer} 
     */
    static uset_containsRange(set, start, end) {
        result := DllCall("icuuc.dll\uset_containsRange", "ptr", set, "int", start, "int", end, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {Integer} 
     */
    static uset_containsString(set, str, strLen) {
        result := DllCall("icuuc.dll\uset_containsString", "ptr", set, "ptr", str, "int", strLen, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_indexOf(set, c) {
        result := DllCall("icuuc.dll\uset_indexOf", "ptr", set, "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} charIndex 
     * @returns {Integer} 
     */
    static uset_charAt(set, charIndex) {
        result := DllCall("icuuc.dll\uset_charAt", "ptr", set, "int", charIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {Integer} 
     */
    static uset_size(set) {
        result := DllCall("icuuc.dll\uset_size", "ptr", set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @returns {Integer} 
     */
    static uset_getItemCount(set) {
        result := DllCall("icuuc.dll\uset_getItemCount", "ptr", set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Integer} itemIndex 
     * @param {Pointer<Int32>} start 
     * @param {Pointer<Int32>} end 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static uset_getItem(set, itemIndex, start, end, str, strCapacity, ec) {
        result := DllCall("icuuc.dll\uset_getItem", "ptr", set, "int", itemIndex, "ptr", start, "ptr", end, "ptr", str, "int", strCapacity, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set1 
     * @param {Pointer<IntPtr>} set2 
     * @returns {Integer} 
     */
    static uset_containsAll(set1, set2) {
        result := DllCall("icuuc.dll\uset_containsAll", "ptr", set1, "ptr", set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {Integer} 
     */
    static uset_containsAllCodePoints(set, str, strLen) {
        result := DllCall("icuuc.dll\uset_containsAllCodePoints", "ptr", set, "ptr", str, "int", strLen, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set1 
     * @param {Pointer<IntPtr>} set2 
     * @returns {Integer} 
     */
    static uset_containsNone(set1, set2) {
        result := DllCall("icuuc.dll\uset_containsNone", "ptr", set1, "ptr", set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set1 
     * @param {Pointer<IntPtr>} set2 
     * @returns {Integer} 
     */
    static uset_containsSome(set1, set2) {
        result := DllCall("icuuc.dll\uset_containsSome", "ptr", set1, "ptr", set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_span(set, s, length, spanCondition) {
        result := DllCall("icuuc.dll\uset_span", "ptr", set, "ptr", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanBack(set, s, length, spanCondition) {
        result := DllCall("icuuc.dll\uset_spanBack", "ptr", set, "ptr", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<PSTR>} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanUTF8(set, s, length, spanCondition) {
        result := DllCall("icuuc.dll\uset_spanUTF8", "ptr", set, "ptr", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<PSTR>} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanBackUTF8(set, s, length, spanCondition) {
        result := DllCall("icuuc.dll\uset_spanBackUTF8", "ptr", set, "ptr", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set1 
     * @param {Pointer<IntPtr>} set2 
     * @returns {Integer} 
     */
    static uset_equals(set1, set2) {
        result := DllCall("icuuc.dll\uset_equals", "ptr", set1, "ptr", set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} set 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uset_serialize(set, dest, destCapacity, pErrorCode) {
        result := DllCall("icuuc.dll\uset_serialize", "ptr", set, "ptr", dest, "int", destCapacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} fillSet 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @returns {Integer} 
     */
    static uset_getSerializedSet(fillSet, src, srcLength) {
        result := DllCall("icuuc.dll\uset_getSerializedSet", "ptr", fillSet, "ptr", src, "int", srcLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} fillSet 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_setSerializedToOne(fillSet, c) {
        DllCall("icuuc.dll\uset_setSerializedToOne", "ptr", fillSet, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_serializedContains(set, c) {
        result := DllCall("icuuc.dll\uset_serializedContains", "ptr", set, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @returns {Integer} 
     */
    static uset_getSerializedRangeCount(set) {
        result := DllCall("icuuc.dll\uset_getSerializedRangeCount", "ptr", set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @param {Integer} rangeIndex 
     * @param {Pointer<Int32>} pStart 
     * @param {Pointer<Int32>} pEnd 
     * @returns {Integer} 
     */
    static uset_getSerializedRange(set, rangeIndex, pStart, pEnd) {
        result := DllCall("icuuc.dll\uset_getSerializedRange", "ptr", set, "int", rangeIndex, "ptr", pStart, "ptr", pEnd, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<IntPtr>} 
     */
    static unorm2_getNFCInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFCInstance", "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<IntPtr>} 
     */
    static unorm2_getNFDInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFDInstance", "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<IntPtr>} 
     */
    static unorm2_getNFKCInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFKCInstance", "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<IntPtr>} 
     */
    static unorm2_getNFKDInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFKDInstance", "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<IntPtr>} 
     */
    static unorm2_getNFKCCasefoldInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFKCCasefoldInstance", "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} packageName 
     * @param {Pointer<PSTR>} name 
     * @param {Integer} mode 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<IntPtr>} 
     */
    static unorm2_getInstance(packageName, name, mode, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getInstance", "ptr", packageName, "ptr", name, "int", mode, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Pointer<IntPtr>} filterSet 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static unorm2_openFiltered(norm2, filterSet, pErrorCode) {
        DllCall("icuuc.dll\unorm2_openFiltered", "ptr", norm2, "ptr", filterSet, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @returns {String} Nothing - always returns an empty string
     */
    static unorm2_close(norm2) {
        DllCall("icuuc.dll\unorm2_close", "ptr", norm2, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_normalize(norm2, src, length, dest, capacity, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_normalize", "ptr", norm2, "ptr", src, "int", length, "ptr", dest, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Pointer<UInt16>} first 
     * @param {Integer} firstLength 
     * @param {Integer} firstCapacity 
     * @param {Pointer<UInt16>} second 
     * @param {Integer} secondLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_normalizeSecondAndAppend(norm2, first, firstLength, firstCapacity, second, secondLength, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_normalizeSecondAndAppend", "ptr", norm2, "ptr", first, "int", firstLength, "int", firstCapacity, "ptr", second, "int", secondLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Pointer<UInt16>} first 
     * @param {Integer} firstLength 
     * @param {Integer} firstCapacity 
     * @param {Pointer<UInt16>} second 
     * @param {Integer} secondLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_append(norm2, first, firstLength, firstCapacity, second, secondLength, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_append", "ptr", norm2, "ptr", first, "int", firstLength, "int", firstCapacity, "ptr", second, "int", secondLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Integer} c 
     * @param {Pointer<UInt16>} decomposition 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_getDecomposition(norm2, c, decomposition, capacity, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getDecomposition", "ptr", norm2, "int", c, "ptr", decomposition, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Integer} c 
     * @param {Pointer<UInt16>} decomposition 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_getRawDecomposition(norm2, c, decomposition, capacity, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getRawDecomposition", "ptr", norm2, "int", c, "ptr", decomposition, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Integer} a 
     * @param {Integer} b 
     * @returns {Integer} 
     */
    static unorm2_composePair(norm2, a, b) {
        result := DllCall("icuuc.dll\unorm2_composePair", "ptr", norm2, "int", a, "int", b, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_getCombiningClass(norm2, c) {
        result := DllCall("icuuc.dll\unorm2_getCombiningClass", "ptr", norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_isNormalized(norm2, s, length, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_isNormalized", "ptr", norm2, "ptr", s, "int", length, "ptr", pErrorCode, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static unorm2_quickCheck(norm2, s, length, pErrorCode) {
        DllCall("icuuc.dll\unorm2_quickCheck", "ptr", norm2, "ptr", s, "int", length, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_spanQuickCheckYes(norm2, s, length, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_spanQuickCheckYes", "ptr", norm2, "ptr", s, "int", length, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_hasBoundaryBefore(norm2, c) {
        result := DllCall("icuuc.dll\unorm2_hasBoundaryBefore", "ptr", norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_hasBoundaryAfter(norm2, c) {
        result := DllCall("icuuc.dll\unorm2_hasBoundaryAfter", "ptr", norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_isInert(norm2, c) {
        result := DllCall("icuuc.dll\unorm2_isInert", "ptr", norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Integer} length1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} length2 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm_compare(s1, length1, s2, length2, options, pErrorCode) {
        result := DllCall("icuuc.dll\unorm_compare", "ptr", s1, "int", length1, "ptr", s2, "int", length2, "uint", options, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<SByte>} converterList 
     * @param {Integer} converterListSize 
     * @param {Pointer<IntPtr>} excludedCodePoints 
     * @param {Integer} whichSet 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnvsel_open(converterList, converterListSize, excludedCodePoints, whichSet, status) {
        DllCall("icuuc.dll\ucnvsel_open", "ptr", converterList, "int", converterListSize, "ptr", excludedCodePoints, "int", whichSet, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sel 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnvsel_close(sel) {
        DllCall("icuuc.dll\ucnvsel_close", "ptr", sel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} buffer 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnvsel_openFromSerialized(buffer, length, status) {
        DllCall("icuuc.dll\ucnvsel_openFromSerialized", "ptr", buffer, "int", length, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sel 
     * @param {Pointer<Void>} buffer 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucnvsel_serialize(sel, buffer, bufferCapacity, status) {
        result := DllCall("icuuc.dll\ucnvsel_serialize", "ptr", sel, "ptr", buffer, "int", bufferCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sel 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnvsel_selectForString(sel, s, length, status) {
        DllCall("icuuc.dll\ucnvsel_selectForString", "ptr", sel, "ptr", s, "int", length, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sel 
     * @param {Pointer<PSTR>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnvsel_selectForUTF8(sel, s, length, status) {
        DllCall("icuuc.dll\ucnvsel_selectForUTF8", "ptr", sel, "ptr", s, "int", length, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} cs 
     * @param {Pointer<UInt16>} us 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_charsToUChars(cs, us, length) {
        DllCall("icuuc.dll\u_charsToUChars", "ptr", cs, "ptr", us, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} us 
     * @param {Pointer<PSTR>} cs 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_UCharsToChars(us, cs, length) {
        DllCall("icuuc.dll\u_UCharsToChars", "ptr", us, "ptr", cs, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @returns {Integer} 
     */
    static u_strlen(s) {
        result := DllCall("icuuc.dll\u_strlen", "ptr", s, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @returns {Integer} 
     */
    static u_countChar32(s, length) {
        result := DllCall("icuuc.dll\u_countChar32", "ptr", s, "int", length, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Integer} number 
     * @returns {Integer} 
     */
    static u_strHasMoreChar32Than(s, length, number) {
        result := DllCall("icuuc.dll\u_strHasMoreChar32Than", "ptr", s, "int", length, "int", number, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<UInt16>} src 
     * @returns {Pointer<UInt16>} 
     */
    static u_strcat(dst, src) {
        result := DllCall("icuuc.dll\u_strcat", "ptr", dst, "ptr", src, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} n 
     * @returns {Pointer<UInt16>} 
     */
    static u_strncat(dst, src, n) {
        result := DllCall("icuuc.dll\u_strncat", "ptr", dst, "ptr", src, "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Pointer<UInt16>} substring 
     * @returns {Pointer<UInt16>} 
     */
    static u_strstr(s, substring) {
        result := DllCall("icuuc.dll\u_strstr", "ptr", s, "ptr", substring, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} substring 
     * @param {Integer} subLength 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFindFirst(s, length, substring, subLength) {
        result := DllCall("icuuc.dll\u_strFindFirst", "ptr", s, "int", length, "ptr", substring, "int", subLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @returns {Pointer<UInt16>} 
     */
    static u_strchr(s, c) {
        result := DllCall("icuuc.dll\u_strchr", "ptr", s, "ushort", c, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @returns {Pointer<UInt16>} 
     */
    static u_strchr32(s, c) {
        result := DllCall("icuuc.dll\u_strchr32", "ptr", s, "int", c, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Pointer<UInt16>} substring 
     * @returns {Pointer<UInt16>} 
     */
    static u_strrstr(s, substring) {
        result := DllCall("icuuc.dll\u_strrstr", "ptr", s, "ptr", substring, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} substring 
     * @param {Integer} subLength 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFindLast(s, length, substring, subLength) {
        result := DllCall("icuuc.dll\u_strFindLast", "ptr", s, "int", length, "ptr", substring, "int", subLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @returns {Pointer<UInt16>} 
     */
    static u_strrchr(s, c) {
        result := DllCall("icuuc.dll\u_strrchr", "ptr", s, "ushort", c, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @returns {Pointer<UInt16>} 
     */
    static u_strrchr32(s, c) {
        result := DllCall("icuuc.dll\u_strrchr32", "ptr", s, "int", c, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} string 
     * @param {Pointer<UInt16>} matchSet 
     * @returns {Pointer<UInt16>} 
     */
    static u_strpbrk(string, matchSet) {
        result := DllCall("icuuc.dll\u_strpbrk", "ptr", string, "ptr", matchSet, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} string 
     * @param {Pointer<UInt16>} matchSet 
     * @returns {Integer} 
     */
    static u_strcspn(string, matchSet) {
        result := DllCall("icuuc.dll\u_strcspn", "ptr", string, "ptr", matchSet, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} string 
     * @param {Pointer<UInt16>} matchSet 
     * @returns {Integer} 
     */
    static u_strspn(string, matchSet) {
        result := DllCall("icuuc.dll\u_strspn", "ptr", string, "ptr", matchSet, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} src 
     * @param {Pointer<UInt16>} delim 
     * @param {Pointer<UInt16>} saveState 
     * @returns {Pointer<UInt16>} 
     */
    static u_strtok_r(src, delim, saveState) {
        result := DllCall("icuuc.dll\u_strtok_r", "ptr", src, "ptr", delim, "ptr", saveState, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @returns {Integer} 
     */
    static u_strcmp(s1, s2) {
        result := DllCall("icuuc.dll\u_strcmp", "ptr", s1, "ptr", s2, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @returns {Integer} 
     */
    static u_strcmpCodePointOrder(s1, s2) {
        result := DllCall("icuuc.dll\u_strcmpCodePointOrder", "ptr", s1, "ptr", s2, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Integer} length1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} length2 
     * @param {Integer} codePointOrder 
     * @returns {Integer} 
     */
    static u_strCompare(s1, length1, s2, length2, codePointOrder) {
        result := DllCall("icuuc.dll\u_strCompare", "ptr", s1, "int", length1, "ptr", s2, "int", length2, "char", codePointOrder, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter1 
     * @param {Pointer<UCharIterator>} iter2 
     * @param {Integer} codePointOrder 
     * @returns {Integer} 
     */
    static u_strCompareIter(iter1, iter2, codePointOrder) {
        result := DllCall("icuuc.dll\u_strCompareIter", "ptr", iter1, "ptr", iter2, "char", codePointOrder, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Integer} length1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} length2 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strCaseCompare(s1, length1, s2, length2, options, pErrorCode) {
        result := DllCall("icuuc.dll\u_strCaseCompare", "ptr", s1, "int", length1, "ptr", s2, "int", length2, "uint", options, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} ucs1 
     * @param {Pointer<UInt16>} ucs2 
     * @param {Integer} n 
     * @returns {Integer} 
     */
    static u_strncmp(ucs1, ucs2, n) {
        result := DllCall("icuuc.dll\u_strncmp", "ptr", ucs1, "ptr", ucs2, "int", n, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} n 
     * @returns {Integer} 
     */
    static u_strncmpCodePointOrder(s1, s2, n) {
        result := DllCall("icuuc.dll\u_strncmpCodePointOrder", "ptr", s1, "ptr", s2, "int", n, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_strcasecmp(s1, s2, options) {
        result := DllCall("icuuc.dll\u_strcasecmp", "ptr", s1, "ptr", s2, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} n 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_strncasecmp(s1, s2, n, options) {
        result := DllCall("icuuc.dll\u_strncasecmp", "ptr", s1, "ptr", s2, "int", n, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} length 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_memcasecmp(s1, s2, length, options) {
        result := DllCall("icuuc.dll\u_memcasecmp", "ptr", s1, "ptr", s2, "int", length, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<UInt16>} src 
     * @returns {Pointer<UInt16>} 
     */
    static u_strcpy(dst, src) {
        result := DllCall("icuuc.dll\u_strcpy", "ptr", dst, "ptr", src, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} n 
     * @returns {Pointer<UInt16>} 
     */
    static u_strncpy(dst, src, n) {
        result := DllCall("icuuc.dll\u_strncpy", "ptr", dst, "ptr", src, "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<PSTR>} src 
     * @returns {Pointer<UInt16>} 
     */
    static u_uastrcpy(dst, src) {
        result := DllCall("icuuc.dll\u_uastrcpy", "ptr", dst, "ptr", src, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} n 
     * @returns {Pointer<UInt16>} 
     */
    static u_uastrncpy(dst, src, n) {
        result := DllCall("icuuc.dll\u_uastrncpy", "ptr", dst, "ptr", src, "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} dst 
     * @param {Pointer<UInt16>} src 
     * @returns {Pointer<PSTR>} 
     */
    static u_austrcpy(dst, src) {
        result := DllCall("icuuc.dll\u_austrcpy", "ptr", dst, "ptr", src, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} dst 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} n 
     * @returns {Pointer<PSTR>} 
     */
    static u_austrncpy(dst, src, n) {
        result := DllCall("icuuc.dll\u_austrncpy", "ptr", dst, "ptr", src, "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memcpy(dest, src, count) {
        result := DllCall("icuuc.dll\u_memcpy", "ptr", dest, "ptr", src, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memmove(dest, src, count) {
        result := DllCall("icuuc.dll\u_memmove", "ptr", dest, "ptr", src, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memset(dest, c, count) {
        result := DllCall("icuuc.dll\u_memset", "ptr", dest, "ushort", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} buf1 
     * @param {Pointer<UInt16>} buf2 
     * @param {Integer} count 
     * @returns {Integer} 
     */
    static u_memcmp(buf1, buf2, count) {
        result := DllCall("icuuc.dll\u_memcmp", "ptr", buf1, "ptr", buf2, "int", count, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} count 
     * @returns {Integer} 
     */
    static u_memcmpCodePointOrder(s1, s2, count) {
        result := DllCall("icuuc.dll\u_memcmpCodePointOrder", "ptr", s1, "ptr", s2, "int", count, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memchr(s, c, count) {
        result := DllCall("icuuc.dll\u_memchr", "ptr", s, "ushort", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memchr32(s, c, count) {
        result := DllCall("icuuc.dll\u_memchr32", "ptr", s, "int", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memrchr(s, c, count) {
        result := DllCall("icuuc.dll\u_memrchr", "ptr", s, "ushort", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memrchr32(s, c, count) {
        result := DllCall("icuuc.dll\u_memrchr32", "ptr", s, "int", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} src 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @returns {Integer} 
     */
    static u_unescape(src, dest, destCapacity) {
        result := DllCall("icuuc.dll\u_unescape", "ptr", src, "ptr", dest, "int", destCapacity, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNESCAPE_CHAR_AT>} charAt 
     * @param {Pointer<Int32>} offset 
     * @param {Integer} length 
     * @param {Pointer<Void>} context 
     * @returns {Integer} 
     */
    static u_unescapeAt(charAt, offset, length, context) {
        result := DllCall("icuuc.dll\u_unescapeAt", "ptr", charAt, "ptr", offset, "int", length, "ptr", context, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToUpper(dest, destCapacity, src, srcLength, locale, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToUpper", "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", locale, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToLower(dest, destCapacity, src, srcLength, locale, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToLower", "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", locale, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<IntPtr>} titleIter 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToTitle(dest, destCapacity, src, srcLength, titleIter, locale, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToTitle", "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", titleIter, "ptr", locale, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strFoldCase(dest, destCapacity, src, srcLength, options, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFoldCase", "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "uint", options, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PWSTR>} 
     */
    static u_strToWCS(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToWCS", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<PWSTR>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromWCS(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromWCS", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PSTR>} 
     */
    static u_strToUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToUTF8", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromUTF8", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PSTR>} 
     */
    static u_strToUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToUTF8WithSub", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "int", subchar, "ptr", pNumSubstitutions, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromUTF8WithSub", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "int", subchar, "ptr", pNumSubstitutions, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF8Lenient(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromUTF8Lenient", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Int32>} 
     */
    static u_strToUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToUTF32", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<Int32>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromUTF32", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Int32>} 
     */
    static u_strToUTF32WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToUTF32WithSub", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "int", subchar, "ptr", pNumSubstitutions, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<Int32>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF32WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromUTF32WithSub", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "int", subchar, "ptr", pNumSubstitutions, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<PSTR>} 
     */
    static u_strToJavaModifiedUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToJavaModifiedUTF8", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromJavaModifiedUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromJavaModifiedUTF8WithSub", "ptr", dest, "int", destCapacity, "ptr", pDestLength, "ptr", src, "int", srcLength, "int", subchar, "ptr", pNumSubstitutions, "ptr", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_open(locale, options, pErrorCode) {
        DllCall("icuuc.dll\ucasemap_open", "ptr", locale, "uint", options, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_close(csm) {
        DllCall("icuuc.dll\ucasemap_close", "ptr", csm, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @returns {Pointer<PSTR>} 
     */
    static ucasemap_getLocale(csm) {
        result := DllCall("icuuc.dll\ucasemap_getLocale", "ptr", csm, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @returns {Integer} 
     */
    static ucasemap_getOptions(csm) {
        result := DllCall("icuuc.dll\ucasemap_getOptions", "ptr", csm, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setLocale(csm, locale, pErrorCode) {
        DllCall("icuuc.dll\ucasemap_setLocale", "ptr", csm, "ptr", locale, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setOptions(csm, options, pErrorCode) {
        DllCall("icuuc.dll\ucasemap_setOptions", "ptr", csm, "uint", options, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @returns {Pointer<IntPtr>} 
     */
    static ucasemap_getBreakIterator(csm) {
        result := DllCall("icuuc.dll\ucasemap_getBreakIterator", "ptr", csm, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @param {Pointer<IntPtr>} iterToAdopt 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setBreakIterator(csm, iterToAdopt, pErrorCode) {
        DllCall("icuuc.dll\ucasemap_setBreakIterator", "ptr", csm, "ptr", iterToAdopt, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_toTitle(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucasemap_toTitle", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToLower(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucasemap_utf8ToLower", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToUpper(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucasemap_utf8ToUpper", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToTitle(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucasemap_utf8ToTitle", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} csm 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<PSTR>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8FoldCase(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucasemap_utf8FoldCase", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} path 
     * @param {Pointer<PSTR>} fileName 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usprep_open(path, fileName, status) {
        DllCall("icuuc.dll\usprep_open", "ptr", path, "ptr", fileName, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usprep_openByType(type, status) {
        DllCall("icuuc.dll\usprep_openByType", "int", type, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} profile 
     * @returns {String} Nothing - always returns an empty string
     */
    static usprep_close(profile) {
        DllCall("icuuc.dll\usprep_close", "ptr", profile, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} prep 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Integer} options 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usprep_prepare(prep, src, srcLength, dest, destCapacity, options, parseError, status) {
        result := DllCall("icuuc.dll\usprep_prepare", "ptr", prep, "ptr", src, "int", srcLength, "ptr", dest, "int", destCapacity, "int", options, "ptr", parseError, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static uidna_openUTS46(options, pErrorCode) {
        DllCall("icuuc.dll\uidna_openUTS46", "uint", options, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @returns {String} Nothing - always returns an empty string
     */
    static uidna_close(idna) {
        DllCall("icuuc.dll\uidna_close", "ptr", idna, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @param {Pointer<UInt16>} label 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToASCII(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_labelToASCII", "ptr", idna, "ptr", label, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @param {Pointer<UInt16>} label 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToUnicode(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_labelToUnicode", "ptr", idna, "ptr", label, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @param {Pointer<UInt16>} name 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToASCII(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_nameToASCII", "ptr", idna, "ptr", name, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @param {Pointer<UInt16>} name 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToUnicode(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_nameToUnicode", "ptr", idna, "ptr", name, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @param {Pointer<PSTR>} label 
     * @param {Integer} length 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToASCII_UTF8(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_labelToASCII_UTF8", "ptr", idna, "ptr", label, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @param {Pointer<PSTR>} label 
     * @param {Integer} length 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToUnicodeUTF8(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_labelToUnicodeUTF8", "ptr", idna, "ptr", label, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @param {Pointer<PSTR>} name 
     * @param {Integer} length 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToASCII_UTF8(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_nameToASCII_UTF8", "ptr", idna, "ptr", name, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} idna 
     * @param {Pointer<PSTR>} name 
     * @param {Integer} length 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToUnicodeUTF8(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_nameToUnicodeUTF8", "ptr", idna, "ptr", name, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_open(type, locale, text, textLength, status) {
        DllCall("icuuc.dll\ubrk_open", "int", type, "ptr", locale, "ptr", text, "int", textLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} rules 
     * @param {Integer} rulesLength 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<UParseError>} parseErr 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_openRules(rules, rulesLength, text, textLength, parseErr, status) {
        DllCall("icuuc.dll\ubrk_openRules", "ptr", rules, "int", rulesLength, "ptr", text, "int", textLength, "ptr", parseErr, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} binaryRules 
     * @param {Integer} rulesLength 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_openBinaryRules(binaryRules, rulesLength, text, textLength, status) {
        DllCall("icuuc.dll\ubrk_openBinaryRules", "ptr", binaryRules, "int", rulesLength, "ptr", text, "int", textLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Int32>} pBufferSize 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_safeClone(bi, stackBuffer, pBufferSize, status) {
        DllCall("icuuc.dll\ubrk_safeClone", "ptr", bi, "ptr", stackBuffer, "ptr", pBufferSize, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_close(bi) {
        DllCall("icuuc.dll\ubrk_close", "ptr", bi, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_setText(bi, text, textLength, status) {
        DllCall("icuuc.dll\ubrk_setText", "ptr", bi, "ptr", text, "int", textLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_setUText(bi, text, status) {
        DllCall("icuuc.dll\ubrk_setUText", "ptr", bi, "ptr", text, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @returns {Integer} 
     */
    static ubrk_current(bi) {
        result := DllCall("icuuc.dll\ubrk_current", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @returns {Integer} 
     */
    static ubrk_next(bi) {
        result := DllCall("icuuc.dll\ubrk_next", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @returns {Integer} 
     */
    static ubrk_previous(bi) {
        result := DllCall("icuuc.dll\ubrk_previous", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @returns {Integer} 
     */
    static ubrk_first(bi) {
        result := DllCall("icuuc.dll\ubrk_first", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @returns {Integer} 
     */
    static ubrk_last(bi) {
        result := DllCall("icuuc.dll\ubrk_last", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_preceding(bi, offset) {
        result := DllCall("icuuc.dll\ubrk_preceding", "ptr", bi, "int", offset, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_following(bi, offset) {
        result := DllCall("icuuc.dll\ubrk_following", "ptr", bi, "int", offset, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} index 
     * @returns {Pointer<PSTR>} 
     */
    static ubrk_getAvailable(index) {
        result := DllCall("icuuc.dll\ubrk_getAvailable", "int", index, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ubrk_countAvailable() {
        result := DllCall("icuuc.dll\ubrk_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_isBoundary(bi, offset) {
        result := DllCall("icuuc.dll\ubrk_isBoundary", "ptr", bi, "int", offset, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @returns {Integer} 
     */
    static ubrk_getRuleStatus(bi) {
        result := DllCall("icuuc.dll\ubrk_getRuleStatus", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Pointer<Int32>} fillInVec 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ubrk_getRuleStatusVec(bi, fillInVec, capacity, status) {
        result := DllCall("icuuc.dll\ubrk_getRuleStatusVec", "ptr", bi, "ptr", fillInVec, "int", capacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ubrk_getLocaleByType(bi, type, status) {
        result := DllCall("icuuc.dll\ubrk_getLocaleByType", "ptr", bi, "int", type, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_refreshUText(bi, text, status) {
        DllCall("icuuc.dll\ubrk_refreshUText", "ptr", bi, "ptr", text, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} bi 
     * @param {Pointer<Byte>} binaryRules 
     * @param {Integer} rulesCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ubrk_getBinaryRules(bi, binaryRules, rulesCapacity, status) {
        result := DllCall("icuuc.dll\ubrk_getBinaryRules", "ptr", bi, "ptr", binaryRules, "int", rulesCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} dataVersionFillin 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getDataVersion(dataVersionFillin, status) {
        DllCall("icuuc.dll\u_getDataVersion", "ptr", dataVersionFillin, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} zoneType 
     * @param {Pointer<PSTR>} region 
     * @param {Pointer<Int32>} rawOffset 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_openTimeZoneIDEnumeration(zoneType, region, rawOffset, ec) {
        DllCall("icuin.dll\ucal_openTimeZoneIDEnumeration", "int", zoneType, "ptr", region, "ptr", rawOffset, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_openTimeZones(ec) {
        DllCall("icuin.dll\ucal_openTimeZones", "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} country 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_openCountryTimeZones(country, ec) {
        DllCall("icuin.dll\ucal_openCountryTimeZones", "ptr", country, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucal_getDefaultTimeZone(result, resultCapacity, ec) {
        result := DllCall("icuin.dll\ucal_getDefaultTimeZone", "ptr", result, "int", resultCapacity, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} zoneID 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDefaultTimeZone(zoneID, ec) {
        DllCall("icuin.dll\ucal_setDefaultTimeZone", "ptr", zoneID, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucal_getHostTimeZone(result, resultCapacity, ec) {
        result := DllCall("icu.dll\ucal_getHostTimeZone", "ptr", result, "int", resultCapacity, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} zoneID 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucal_getDSTSavings(zoneID, ec) {
        result := DllCall("icuin.dll\ucal_getDSTSavings", "ptr", zoneID, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Float} 
     */
    static ucal_getNow() {
        result := DllCall("icuin.dll\ucal_getNow", "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} zoneID 
     * @param {Integer} len 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_open(zoneID, len, locale, type, status) {
        DllCall("icuin.dll\ucal_open", "ptr", zoneID, "int", len, "ptr", locale, "int", type, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_close(cal) {
        DllCall("icuin.dll\ucal_close", "ptr", cal, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_clone(cal, status) {
        DllCall("icuin.dll\ucal_clone", "ptr", cal, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<UInt16>} zoneID 
     * @param {Integer} len 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setTimeZone(cal, zoneID, len, status) {
        DllCall("icuin.dll\ucal_setTimeZone", "ptr", cal, "ptr", zoneID, "int", len, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneID(cal, result, resultLength, status) {
        result := DllCall("icuin.dll\ucal_getTimeZoneID", "ptr", cal, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} type 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneDisplayName(cal, type, locale, result, resultLength, status) {
        result := DllCall("icuin.dll\ucal_getTimeZoneDisplayName", "ptr", cal, "int", type, "ptr", locale, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_inDaylightTime(cal, status) {
        result := DllCall("icuin.dll\ucal_inDaylightTime", "ptr", cal, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Float} date 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setGregorianChange(cal, date, pErrorCode) {
        DllCall("icuin.dll\ucal_setGregorianChange", "ptr", cal, "double", date, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Float} 
     */
    static ucal_getGregorianChange(cal, pErrorCode) {
        result := DllCall("icuin.dll\ucal_getGregorianChange", "ptr", cal, "ptr", pErrorCode, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} attr 
     * @returns {Integer} 
     */
    static ucal_getAttribute(cal, attr) {
        result := DllCall("icuin.dll\ucal_getAttribute", "ptr", cal, "int", attr, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setAttribute(cal, attr, newValue) {
        DllCall("icuin.dll\ucal_setAttribute", "ptr", cal, "int", attr, "int", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {Pointer<PSTR>} 
     */
    static ucal_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\ucal_getAvailable", "int", localeIndex, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucal_countAvailable() {
        result := DllCall("icuin.dll\ucal_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static ucal_getMillis(cal, status) {
        result := DllCall("icuin.dll\ucal_getMillis", "ptr", cal, "ptr", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Float} dateTime 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setMillis(cal, dateTime, status) {
        DllCall("icuin.dll\ucal_setMillis", "ptr", cal, "double", dateTime, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} year 
     * @param {Integer} month 
     * @param {Integer} date 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDate(cal, year, month, date, status) {
        DllCall("icuin.dll\ucal_setDate", "ptr", cal, "int", year, "int", month, "int", date, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} year 
     * @param {Integer} month 
     * @param {Integer} date 
     * @param {Integer} hour 
     * @param {Integer} minute 
     * @param {Integer} second 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDateTime(cal, year, month, date, hour, minute, second, status) {
        DllCall("icuin.dll\ucal_setDateTime", "ptr", cal, "int", year, "int", month, "int", date, "int", hour, "int", minute, "int", second, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal1 
     * @param {Pointer<Void>} cal2 
     * @returns {Integer} 
     */
    static ucal_equivalentTo(cal1, cal2) {
        result := DllCall("icuin.dll\ucal_equivalentTo", "ptr", cal1, "ptr", cal2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Integer} amount 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_add(cal, field, amount, status) {
        DllCall("icuin.dll\ucal_add", "ptr", cal, "int", field, "int", amount, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Integer} amount 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_roll(cal, field, amount, status) {
        DllCall("icuin.dll\ucal_roll", "ptr", cal, "int", field, "int", amount, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_get(cal, field, status) {
        result := DllCall("icuin.dll\ucal_get", "ptr", cal, "int", field, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Integer} value 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_set(cal, field, value) {
        DllCall("icuin.dll\ucal_set", "ptr", cal, "int", field, "int", value, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @returns {Integer} 
     */
    static ucal_isSet(cal, field) {
        result := DllCall("icuin.dll\ucal_isSet", "ptr", cal, "int", field, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_clearField(cal, field) {
        DllCall("icuin.dll\ucal_clearField", "ptr", cal, "int", field, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} calendar 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_clear(calendar) {
        DllCall("icuin.dll\ucal_clear", "ptr", calendar, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getLimit(cal, field, type, status) {
        result := DllCall("icuin.dll\ucal_getLimit", "ptr", cal, "int", field, "int", type, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ucal_getLocaleByType(cal, type, status) {
        result := DllCall("icuin.dll\ucal_getLocaleByType", "ptr", cal, "int", type, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ucal_getTZDataVersion(status) {
        result := DllCall("icuin.dll\ucal_getTZDataVersion", "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} len 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<SByte>} isSystemID 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getCanonicalTimeZoneID(id, len, result, resultCapacity, isSystemID, status) {
        result := DllCall("icuin.dll\ucal_getCanonicalTimeZoneID", "ptr", id, "int", len, "ptr", result, "int", resultCapacity, "ptr", isSystemID, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ucal_getType(cal, status) {
        result := DllCall("icuin.dll\ucal_getType", "ptr", cal, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} key 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        DllCall("icuin.dll\ucal_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} dayOfWeek 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_getDayOfWeekType(cal, dayOfWeek, status) {
        DllCall("icuin.dll\ucal_getDayOfWeekType", "ptr", cal, "int", dayOfWeek, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} dayOfWeek 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getWeekendTransition(cal, dayOfWeek, status) {
        result := DllCall("icuin.dll\ucal_getWeekendTransition", "ptr", cal, "int", dayOfWeek, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Float} date 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_isWeekend(cal, date, status) {
        result := DllCall("icuin.dll\ucal_isWeekend", "ptr", cal, "double", date, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Float} target 
     * @param {Integer} field 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getFieldDifference(cal, target, field, status) {
        result := DllCall("icuin.dll\ucal_getFieldDifference", "ptr", cal, "double", target, "int", field, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} type 
     * @param {Pointer<Double>} transition 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneTransitionDate(cal, type, transition, status) {
        result := DllCall("icuin.dll\ucal_getTimeZoneTransitionDate", "ptr", cal, "int", type, "ptr", transition, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} len 
     * @param {Pointer<UInt16>} winid 
     * @param {Integer} winidCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getWindowsTimeZoneID(id, len, winid, winidCapacity, status) {
        result := DllCall("icuin.dll\ucal_getWindowsTimeZoneID", "ptr", id, "int", len, "ptr", winid, "int", winidCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} winid 
     * @param {Integer} len 
     * @param {Pointer<PSTR>} region 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} idCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneIDForWindowsID(winid, len, region, id, idCapacity, status) {
        result := DllCall("icuin.dll\ucal_getTimeZoneIDForWindowsID", "ptr", winid, "int", len, "ptr", region, "ptr", id, "int", idCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} loc 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_open(loc, status) {
        DllCall("icuin.dll\ucol_open", "ptr", loc, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} rules 
     * @param {Integer} rulesLength 
     * @param {Integer} normalizationMode 
     * @param {Integer} strength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_openRules(rules, rulesLength, normalizationMode, strength, parseError, status) {
        DllCall("icuin.dll\ucol_openRules", "ptr", rules, "int", rulesLength, "int", normalizationMode, "int", strength, "ptr", parseError, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<IntPtr>} contractions 
     * @param {Pointer<IntPtr>} expansions 
     * @param {Integer} addPrefixes 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getContractionsAndExpansions(coll, contractions, expansions, addPrefixes, status) {
        DllCall("icuin.dll\ucol_getContractionsAndExpansions", "ptr", coll, "ptr", contractions, "ptr", expansions, "char", addPrefixes, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_close(coll) {
        DllCall("icuin.dll\ucol_close", "ptr", coll, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} target 
     * @param {Integer} targetLength 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_strcoll(coll, source, sourceLength, target, targetLength) {
        DllCall("icuin.dll\ucol_strcoll", "ptr", coll, "ptr", source, "int", sourceLength, "ptr", target, "int", targetLength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<PSTR>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<PSTR>} target 
     * @param {Integer} targetLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_strcollUTF8(coll, source, sourceLength, target, targetLength, status) {
        DllCall("icuin.dll\ucol_strcollUTF8", "ptr", coll, "ptr", source, "int", sourceLength, "ptr", target, "int", targetLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_greater(coll, source, sourceLength, target, targetLength) {
        result := DllCall("icuin.dll\ucol_greater", "ptr", coll, "ptr", source, "int", sourceLength, "ptr", target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_greaterOrEqual(coll, source, sourceLength, target, targetLength) {
        result := DllCall("icuin.dll\ucol_greaterOrEqual", "ptr", coll, "ptr", source, "int", sourceLength, "ptr", target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_equal(coll, source, sourceLength, target, targetLength) {
        result := DllCall("icuin.dll\ucol_equal", "ptr", coll, "ptr", source, "int", sourceLength, "ptr", target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<UCharIterator>} sIter 
     * @param {Pointer<UCharIterator>} tIter 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_strcollIter(coll, sIter, tIter, status) {
        DllCall("icuin.dll\ucol_strcollIter", "ptr", coll, "ptr", sIter, "ptr", tIter, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @returns {Integer} 
     */
    static ucol_getStrength(coll) {
        result := DllCall("icuin.dll\ucol_getStrength", "ptr", coll, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Integer} strength 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setStrength(coll, strength) {
        DllCall("icuin.dll\ucol_setStrength", "ptr", coll, "int", strength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Int32>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucol_getReorderCodes(coll, dest, destCapacity, pErrorCode) {
        result := DllCall("icuin.dll\ucol_getReorderCodes", "ptr", coll, "ptr", dest, "int", destCapacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Int32>} reorderCodes 
     * @param {Integer} reorderCodesLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setReorderCodes(coll, reorderCodes, reorderCodesLength, pErrorCode) {
        DllCall("icuin.dll\ucol_setReorderCodes", "ptr", coll, "ptr", reorderCodes, "int", reorderCodesLength, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Integer} reorderCode 
     * @param {Pointer<Int32>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucol_getEquivalentReorderCodes(reorderCode, dest, destCapacity, pErrorCode) {
        result := DllCall("icuin.dll\ucol_getEquivalentReorderCodes", "int", reorderCode, "ptr", dest, "int", destCapacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} objLoc 
     * @param {Pointer<PSTR>} dispLoc 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getDisplayName(objLoc, dispLoc, result, resultLength, status) {
        result := DllCall("icuin.dll\ucol_getDisplayName", "ptr", objLoc, "ptr", dispLoc, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {Pointer<PSTR>} 
     */
    static ucol_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\ucol_getAvailable", "int", localeIndex, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucol_countAvailable() {
        result := DllCall("icuin.dll\ucol_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_openAvailableLocales(status) {
        DllCall("icuin.dll\ucol_openAvailableLocales", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getKeywords(status) {
        DllCall("icuin.dll\ucol_getKeywords", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} keyword 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getKeywordValues(keyword, status) {
        DllCall("icuin.dll\ucol_getKeywordValues", "ptr", keyword, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} key 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        DllCall("icuin.dll\ucol_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<PSTR>} keyword 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<SByte>} isAvailable 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getFunctionalEquivalent(result, resultCapacity, keyword, locale, isAvailable, status) {
        result := DllCall("icuin.dll\ucol_getFunctionalEquivalent", "ptr", result, "int", resultCapacity, "ptr", keyword, "ptr", locale, "ptr", isAvailable, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Int32>} length 
     * @returns {Pointer<UInt16>} 
     */
    static ucol_getRules(coll, length) {
        result := DllCall("icuin.dll\ucol_getRules", "ptr", coll, "ptr", length, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Byte>} result 
     * @param {Integer} resultLength 
     * @returns {Integer} 
     */
    static ucol_getSortKey(coll, source, sourceLength, result, resultLength) {
        result := DllCall("icuin.dll\ucol_getSortKey", "ptr", coll, "ptr", source, "int", sourceLength, "ptr", result, "int", resultLength, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Pointer<UInt32>} state 
     * @param {Pointer<Byte>} dest 
     * @param {Integer} count 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_nextSortKeyPart(coll, iter, state, dest, count, status) {
        result := DllCall("icuin.dll\ucol_nextSortKeyPart", "ptr", coll, "ptr", iter, "ptr", state, "ptr", dest, "int", count, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} source 
     * @param {Integer} sourceLength 
     * @param {Integer} boundType 
     * @param {Integer} noOfLevels 
     * @param {Pointer<Byte>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getBound(source, sourceLength, boundType, noOfLevels, result, resultLength, status) {
        result := DllCall("icuin.dll\ucol_getBound", "ptr", source, "int", sourceLength, "int", boundType, "uint", noOfLevels, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Byte>} info 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getVersion(coll, info) {
        DllCall("icuin.dll\ucol_getVersion", "ptr", coll, "ptr", info, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Byte>} info 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getUCAVersion(coll, info) {
        DllCall("icuin.dll\ucol_getUCAVersion", "ptr", coll, "ptr", info, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} src1 
     * @param {Integer} src1Length 
     * @param {Pointer<Byte>} src2 
     * @param {Integer} src2Length 
     * @param {Pointer<Byte>} dest 
     * @param {Integer} destCapacity 
     * @returns {Integer} 
     */
    static ucol_mergeSortkeys(src1, src1Length, src2, src2Length, dest, destCapacity) {
        result := DllCall("icuin.dll\ucol_mergeSortkeys", "ptr", src1, "int", src1Length, "ptr", src2, "int", src2Length, "ptr", dest, "int", destCapacity, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Integer} attr 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setAttribute(coll, attr, value, status) {
        DllCall("icuin.dll\ucol_setAttribute", "ptr", coll, "int", attr, "int", value, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Integer} attr 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getAttribute(coll, attr, status) {
        DllCall("icuin.dll\ucol_getAttribute", "ptr", coll, "int", attr, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Integer} group 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setMaxVariable(coll, group, pErrorCode) {
        DllCall("icuin.dll\ucol_setMaxVariable", "ptr", coll, "int", group, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getMaxVariable(coll) {
        DllCall("icuin.dll\ucol_getMaxVariable", "ptr", coll, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getVariableTop(coll, status) {
        result := DllCall("icuin.dll\ucol_getVariableTop", "ptr", coll, "ptr", status, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Int32>} pBufferSize 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_safeClone(coll, stackBuffer, pBufferSize, status) {
        DllCall("icuin.dll\ucol_safeClone", "ptr", coll, "ptr", stackBuffer, "ptr", pBufferSize, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Integer} delta 
     * @param {Pointer<UInt16>} buffer 
     * @param {Integer} bufferLen 
     * @returns {Integer} 
     */
    static ucol_getRulesEx(coll, delta, buffer, bufferLen) {
        result := DllCall("icuin.dll\ucol_getRulesEx", "ptr", coll, "int", delta, "ptr", buffer, "int", bufferLen, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ucol_getLocaleByType(coll, type, status) {
        result := DllCall("icuin.dll\ucol_getLocaleByType", "ptr", coll, "int", type, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getTailoredSet(coll, status) {
        DllCall("icuin.dll\ucol_getTailoredSet", "ptr", coll, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<Byte>} buffer 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_cloneBinary(coll, buffer, capacity, status) {
        result := DllCall("icuin.dll\ucol_cloneBinary", "ptr", coll, "ptr", buffer, "int", capacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} bin 
     * @param {Integer} length 
     * @param {Pointer<IntPtr>} base 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_openBinary(bin, length, base, status) {
        DllCall("icuin.dll\ucol_openBinary", "ptr", bin, "int", length, "ptr", base, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} coll 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_openElements(coll, text, textLength, status) {
        DllCall("icuin.dll\ucol_openElements", "ptr", coll, "ptr", text, "int", textLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} key 
     * @param {Integer} length 
     * @returns {Integer} 
     */
    static ucol_keyHashCode(key, length) {
        result := DllCall("icuin.dll\ucol_keyHashCode", "ptr", key, "int", length, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} elems 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_closeElements(elems) {
        DllCall("icuin.dll\ucol_closeElements", "ptr", elems, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} elems 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_reset(elems) {
        DllCall("icuin.dll\ucol_reset", "ptr", elems, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} elems 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_next(elems, status) {
        result := DllCall("icuin.dll\ucol_next", "ptr", elems, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} elems 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_previous(elems, status) {
        result := DllCall("icuin.dll\ucol_previous", "ptr", elems, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} elems 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_getMaxExpansion(elems, order) {
        result := DllCall("icuin.dll\ucol_getMaxExpansion", "ptr", elems, "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} elems 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setText(elems, text, textLength, status) {
        DllCall("icuin.dll\ucol_setText", "ptr", elems, "ptr", text, "int", textLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} elems 
     * @returns {Integer} 
     */
    static ucol_getOffset(elems) {
        result := DllCall("icuin.dll\ucol_getOffset", "ptr", elems, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} elems 
     * @param {Integer} offset 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setOffset(elems, offset, status) {
        DllCall("icuin.dll\ucol_setOffset", "ptr", elems, "int", offset, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_primaryOrder(order) {
        result := DllCall("icuin.dll\ucol_primaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_secondaryOrder(order) {
        result := DllCall("icuin.dll\ucol_secondaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_tertiaryOrder(order) {
        result := DllCall("icuin.dll\ucol_tertiaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_open(status) {
        DllCall("icuin.dll\ucsdet_open", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsd 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_close(ucsd) {
        DllCall("icuin.dll\ucsdet_close", "ptr", ucsd, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsd 
     * @param {Pointer<PSTR>} textIn 
     * @param {Integer} len 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_setText(ucsd, textIn, len, status) {
        DllCall("icuin.dll\ucsdet_setText", "ptr", ucsd, "ptr", textIn, "int", len, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsd 
     * @param {Pointer<PSTR>} encoding 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_setDeclaredEncoding(ucsd, encoding, length, status) {
        DllCall("icuin.dll\ucsdet_setDeclaredEncoding", "ptr", ucsd, "ptr", encoding, "int", length, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsd 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static ucsdet_detect(ucsd, status) {
        result := DllCall("icuin.dll\ucsdet_detect", "ptr", ucsd, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsd 
     * @param {Pointer<Int32>} matchesFound 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static ucsdet_detectAll(ucsd, matchesFound, status) {
        result := DllCall("icuin.dll\ucsdet_detectAll", "ptr", ucsd, "ptr", matchesFound, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsm 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ucsdet_getName(ucsm, status) {
        result := DllCall("icuin.dll\ucsdet_getName", "ptr", ucsm, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsm 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucsdet_getConfidence(ucsm, status) {
        result := DllCall("icuin.dll\ucsdet_getConfidence", "ptr", ucsm, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsm 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ucsdet_getLanguage(ucsm, status) {
        result := DllCall("icuin.dll\ucsdet_getLanguage", "ptr", ucsm, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsm 
     * @param {Pointer<UInt16>} buf 
     * @param {Integer} cap 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucsdet_getUChars(ucsm, buf, cap, status) {
        result := DllCall("icuin.dll\ucsdet_getUChars", "ptr", ucsm, "ptr", buf, "int", cap, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsd 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_getAllDetectableCharsets(ucsd, status) {
        DllCall("icuin.dll\ucsdet_getAllDetectableCharsets", "ptr", ucsd, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsd 
     * @returns {Integer} 
     */
    static ucsdet_isInputFilterEnabled(ucsd) {
        result := DllCall("icuin.dll\ucsdet_isInputFilterEnabled", "ptr", ucsd, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucsd 
     * @param {Integer} filter 
     * @returns {Integer} 
     */
    static ucsdet_enableInputFilter(ucsd, filter) {
        result := DllCall("icuin.dll\ucsdet_enableInputFilter", "ptr", ucsd, "char", filter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufieldpositer_open(status) {
        DllCall("icuin.dll\ufieldpositer_open", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} fpositer 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufieldpositer_close(fpositer) {
        DllCall("icuin.dll\ufieldpositer_close", "ptr", fpositer, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} fpositer 
     * @param {Pointer<Int32>} beginIndex 
     * @param {Pointer<Int32>} endIndex 
     * @returns {Integer} 
     */
    static ufieldpositer_next(fpositer, beginIndex, endIndex) {
        result := DllCall("icuin.dll\ufieldpositer_next", "ptr", fpositer, "ptr", beginIndex, "ptr", endIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufmt_open(status) {
        DllCall("icuin.dll\ufmt_open", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufmt_close(fmt) {
        DllCall("icuin.dll\ufmt_close", "ptr", fmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufmt_getType(fmt, status) {
        DllCall("icuin.dll\ufmt_getType", "ptr", fmt, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {Integer} 
     */
    static ufmt_isNumeric(fmt) {
        result := DllCall("icuin.dll\ufmt_isNumeric", "ptr", fmt, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static ufmt_getDate(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getDate", "ptr", fmt, "ptr", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufmt_getDouble(fmt, status) {
        DllCall("icuin.dll\ufmt_getDouble", "ptr", fmt, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ufmt_getLong(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getLong", "ptr", fmt, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ufmt_getInt64(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getInt64", "ptr", fmt, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufmt_getObject(fmt, status) {
        DllCall("icuin.dll\ufmt_getObject", "ptr", fmt, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ufmt_getUChars(fmt, len, status) {
        result := DllCall("icuin.dll\ufmt_getUChars", "ptr", fmt, "ptr", len, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ufmt_getArrayLength(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getArrayLength", "ptr", fmt, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} n 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufmt_getArrayItemByIndex(fmt, n, status) {
        DllCall("icuin.dll\ufmt_getArrayItemByIndex", "ptr", fmt, "int", n, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static ufmt_getDecNumChars(fmt, len, status) {
        result := DllCall("icuin.dll\ufmt_getDecNumChars", "ptr", fmt, "ptr", len, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_open(ec) {
        DllCall("icu.dll\ucfpos_open", "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_reset(ucfpos, ec) {
        DllCall("icu.dll\ucfpos_reset", "ptr", ucfpos, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_close(ucfpos) {
        DllCall("icu.dll\ucfpos_close", "ptr", ucfpos, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Integer} category 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_constrainCategory(ucfpos, category, ec) {
        DllCall("icu.dll\ucfpos_constrainCategory", "ptr", ucfpos, "int", category, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_constrainField(ucfpos, category, field, ec) {
        DllCall("icu.dll\ucfpos_constrainField", "ptr", ucfpos, "int", category, "int", field, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getCategory(ucfpos, ec) {
        result := DllCall("icu.dll\ucfpos_getCategory", "ptr", ucfpos, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getField(ucfpos, ec) {
        result := DllCall("icu.dll\ucfpos_getField", "ptr", ucfpos, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Pointer<Int32>} pStart 
     * @param {Pointer<Int32>} pLimit 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_getIndexes(ucfpos, pStart, pLimit, ec) {
        DllCall("icu.dll\ucfpos_getIndexes", "ptr", ucfpos, "ptr", pStart, "ptr", pLimit, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getInt64IterationContext(ucfpos, ec) {
        result := DllCall("icu.dll\ucfpos_getInt64IterationContext", "ptr", ucfpos, "ptr", ec, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Integer} context 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_setInt64IterationContext(ucfpos, context, ec) {
        DllCall("icu.dll\ucfpos_setInt64IterationContext", "ptr", ucfpos, "int64", context, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucfpos_matchesField(ucfpos, category, field, ec) {
        result := DllCall("icu.dll\ucfpos_matchesField", "ptr", ucfpos, "int", category, "int", field, "ptr", ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_setState(ucfpos, category, field, start, limit, ec) {
        DllCall("icu.dll\ucfpos_setState", "ptr", ucfpos, "int", category, "int", field, "int", start, "int", limit, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ufmtval 
     * @param {Pointer<Int32>} pLength 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UInt16>} 
     */
    static ufmtval_getString(ufmtval, pLength, ec) {
        result := DllCall("icu.dll\ufmtval_getString", "ptr", ufmtval, "ptr", pLength, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ufmtval 
     * @param {Pointer<IntPtr>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ufmtval_nextPosition(ufmtval, ucfpos, ec) {
        result := DllCall("icu.dll\ufmtval_nextPosition", "ptr", ufmtval, "ptr", ucfpos, "ptr", ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<UInt16>} tzID 
     * @param {Integer} tzIDLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_open(locale, skeleton, skeletonLength, tzID, tzIDLength, status) {
        DllCall("icuin.dll\udtitvfmt_open", "ptr", locale, "ptr", skeleton, "int", skeletonLength, "ptr", tzID, "int", tzIDLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} formatter 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_close(formatter) {
        DllCall("icuin.dll\udtitvfmt_close", "ptr", formatter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_openResult(ec) {
        DllCall("icu.dll\udtitvfmt_openResult", "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<IntPtr>} 
     */
    static udtitvfmt_resultAsValue(uresult, ec) {
        result := DllCall("icu.dll\udtitvfmt_resultAsValue", "ptr", uresult, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_closeResult(uresult) {
        DllCall("icu.dll\udtitvfmt_closeResult", "ptr", uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} formatter 
     * @param {Float} fromDate 
     * @param {Float} toDate 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udtitvfmt_format(formatter, fromDate, toDate, result, resultCapacity, position, status) {
        result := DllCall("icuin.dll\udtitvfmt_format", "ptr", formatter, "double", fromDate, "double", toDate, "ptr", result, "int", resultCapacity, "ptr", position, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static ugender_getInstance(locale, status) {
        result := DllCall("icuin.dll\ugender_getInstance", "ptr", locale, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} genderInfo 
     * @param {Pointer<Int32>} genders 
     * @param {Integer} size 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ugender_getListGender(genderInfo, genders, size, status) {
        DllCall("icuin.dll\ugender_getListGender", "ptr", genderInfo, "ptr", genders, "int", size, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_open(locale, status) {
        DllCall("icuuc.dll\ulistfmt_open", "ptr", locale, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} type 
     * @param {Integer} width 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_openForType(locale, type, width, status) {
        DllCall("icu.dll\ulistfmt_openForType", "ptr", locale, "int", type, "int", width, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} listfmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_close(listfmt) {
        DllCall("icuuc.dll\ulistfmt_close", "ptr", listfmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_openResult(ec) {
        DllCall("icu.dll\ulistfmt_openResult", "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<IntPtr>} 
     */
    static ulistfmt_resultAsValue(uresult, ec) {
        result := DllCall("icu.dll\ulistfmt_resultAsValue", "ptr", uresult, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_closeResult(uresult) {
        DllCall("icu.dll\ulistfmt_closeResult", "ptr", uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} listfmt 
     * @param {Pointer<UInt16>} strings 
     * @param {Pointer<Int32>} stringLengths 
     * @param {Integer} stringCount 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulistfmt_format(listfmt, strings, stringLengths, stringCount, result, resultCapacity, status) {
        result := DllCall("icuuc.dll\ulistfmt_format", "ptr", listfmt, "ptr", strings, "ptr", stringLengths, "int", stringCount, "ptr", result, "int", resultCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} listfmt 
     * @param {Pointer<UInt16>} strings 
     * @param {Pointer<Int32>} stringLengths 
     * @param {Integer} stringCount 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_formatStringsToResult(listfmt, strings, stringLengths, stringCount, uresult, status) {
        DllCall("icu.dll\ulistfmt_formatStringsToResult", "ptr", listfmt, "ptr", strings, "ptr", stringLengths, "int", stringCount, "ptr", uresult, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_open(localeID, status) {
        DllCall("icuin.dll\ulocdata_open", "ptr", localeID, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uld 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_close(uld) {
        DllCall("icuin.dll\ulocdata_close", "ptr", uld, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uld 
     * @param {Integer} setting 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_setNoSubstitute(uld, setting) {
        DllCall("icuin.dll\ulocdata_setNoSubstitute", "ptr", uld, "char", setting, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uld 
     * @returns {Integer} 
     */
    static ulocdata_getNoSubstitute(uld) {
        result := DllCall("icuin.dll\ulocdata_getNoSubstitute", "ptr", uld, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uld 
     * @param {Pointer<IntPtr>} fillIn 
     * @param {Integer} options 
     * @param {Integer} extype 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_getExemplarSet(uld, fillIn, options, extype, status) {
        DllCall("icuin.dll\ulocdata_getExemplarSet", "ptr", uld, "ptr", fillIn, "uint", options, "int", extype, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uld 
     * @param {Integer} type 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulocdata_getDelimiter(uld, type, result, resultLength, status) {
        result := DllCall("icuin.dll\ulocdata_getDelimiter", "ptr", uld, "int", type, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_getMeasurementSystem(localeID, status) {
        DllCall("icuin.dll\ulocdata_getMeasurementSystem", "ptr", localeID, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} localeID 
     * @param {Pointer<Int32>} height 
     * @param {Pointer<Int32>} width 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_getPaperSize(localeID, height, width, status) {
        DllCall("icuin.dll\ulocdata_getPaperSize", "ptr", localeID, "ptr", height, "ptr", width, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_getCLDRVersion(versionArray, status) {
        DllCall("icuin.dll\ulocdata_getCLDRVersion", "ptr", versionArray, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uld 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulocdata_getLocaleDisplayPattern(uld, pattern, patternCapacity, status) {
        result := DllCall("icuin.dll\ulocdata_getLocaleDisplayPattern", "ptr", uld, "ptr", pattern, "int", patternCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uld 
     * @param {Pointer<UInt16>} separator 
     * @param {Integer} separatorCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulocdata_getLocaleSeparator(uld, separator, separatorCapacity, status) {
        result := DllCall("icuin.dll\ulocdata_getLocaleSeparator", "ptr", uld, "ptr", separator, "int", separatorCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static u_formatMessage(locale, pattern, patternLength, result, resultLength, status) {
        result := DllCall("icuin.dll\u_formatMessage", "ptr", locale, "ptr", pattern, "int", patternLength, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static u_vformatMessage(locale, pattern, patternLength, result, resultLength, ap, status) {
        result := DllCall("icuin.dll\u_vformatMessage", "ptr", locale, "ptr", pattern, "int", patternLength, "ptr", result, "int", resultLength, "ptr", ap, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_parseMessage(locale, pattern, patternLength, source, sourceLength, status) {
        DllCall("icuin.dll\u_parseMessage", "ptr", locale, "ptr", pattern, "int", patternLength, "ptr", source, "int", sourceLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_vparseMessage(locale, pattern, patternLength, source, sourceLength, ap, status) {
        DllCall("icuin.dll\u_vparseMessage", "ptr", locale, "ptr", pattern, "int", patternLength, "ptr", source, "int", sourceLength, "ptr", ap, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static u_formatMessageWithError(locale, pattern, patternLength, result, resultLength, parseError, status) {
        result := DllCall("icuin.dll\u_formatMessageWithError", "ptr", locale, "ptr", pattern, "int", patternLength, "ptr", result, "int", resultLength, "ptr", parseError, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static u_vformatMessageWithError(locale, pattern, patternLength, result, resultLength, parseError, ap, status) {
        result := DllCall("icuin.dll\u_vformatMessageWithError", "ptr", locale, "ptr", pattern, "int", patternLength, "ptr", result, "int", resultLength, "ptr", parseError, "ptr", ap, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_parseMessageWithError(locale, pattern, patternLength, source, sourceLength, parseError, status) {
        DllCall("icuin.dll\u_parseMessageWithError", "ptr", locale, "ptr", pattern, "int", patternLength, "ptr", source, "int", sourceLength, "ptr", parseError, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_vparseMessageWithError(locale, pattern, patternLength, source, sourceLength, ap, parseError, status) {
        DllCall("icuin.dll\u_vparseMessageWithError", "ptr", locale, "ptr", pattern, "int", patternLength, "ptr", source, "int", sourceLength, "ptr", ap, "ptr", parseError, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_open(pattern, patternLength, locale, parseError, status) {
        DllCall("icuin.dll\umsg_open", "ptr", pattern, "int", patternLength, "ptr", locale, "ptr", parseError, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_close(format) {
        DllCall("icuin.dll\umsg_close", "ptr", format, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_clone(fmt, status) {
        DllCall("icuin.dll\umsg_clone", "ptr", fmt, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<PSTR>} locale 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_setLocale(fmt, locale) {
        DllCall("icuin.dll\umsg_setLocale", "ptr", fmt, "ptr", locale, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {Pointer<PSTR>} 
     */
    static umsg_getLocale(fmt) {
        result := DllCall("icuin.dll\umsg_getLocale", "ptr", fmt, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_applyPattern(fmt, pattern, patternLength, parseError, status) {
        DllCall("icuin.dll\umsg_applyPattern", "ptr", fmt, "ptr", pattern, "int", patternLength, "ptr", parseError, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static umsg_toPattern(fmt, result, resultLength, status) {
        result := DllCall("icuin.dll\umsg_toPattern", "ptr", fmt, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static umsg_format(fmt, result, resultLength, status) {
        result := DllCall("icuin.dll\umsg_format", "ptr", fmt, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static umsg_vformat(fmt, result, resultLength, ap, status) {
        result := DllCall("icuin.dll\umsg_vformat", "ptr", fmt, "ptr", result, "int", resultLength, "ptr", ap, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} count 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_parse(fmt, source, sourceLength, count, status) {
        DllCall("icuin.dll\umsg_parse", "ptr", fmt, "ptr", source, "int", sourceLength, "ptr", count, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} count 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_vparse(fmt, source, sourceLength, count, ap, status) {
        DllCall("icuin.dll\umsg_vparse", "ptr", fmt, "ptr", source, "int", sourceLength, "ptr", count, "ptr", ap, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static umsg_autoQuoteApostrophe(pattern, patternLength, dest, destCapacity, ec) {
        result := DllCall("icuin.dll\umsg_autoQuoteApostrophe", "ptr", pattern, "int", patternLength, "ptr", dest, "int", destCapacity, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} style 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UParseError>} parseErr 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_open(style, pattern, patternLength, locale, parseErr, status) {
        DllCall("icuin.dll\unum_open", "int", style, "ptr", pattern, "int", patternLength, "ptr", locale, "ptr", parseErr, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_close(fmt) {
        DllCall("icuin.dll\unum_close", "ptr", fmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_clone(fmt, status) {
        DllCall("icuin.dll\unum_clone", "ptr", fmt, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_format(fmt, number, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_format", "ptr", fmt, "int", number, "ptr", result, "int", resultLength, "ptr", pos, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatInt64(fmt, number, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatInt64", "ptr", fmt, "int64", number, "ptr", result, "int", resultLength, "ptr", pos, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Float} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatDouble(fmt, number, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatDouble", "ptr", fmt, "double", number, "ptr", result, "int", resultLength, "ptr", pos, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Float} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<IntPtr>} fpositer 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatDoubleForFields(format, number, result, resultLength, fpositer, status) {
        result := DllCall("icuin.dll\unum_formatDoubleForFields", "ptr", format, "double", number, "ptr", result, "int", resultLength, "ptr", fpositer, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<PSTR>} number 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatDecimal(fmt, number, length, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatDecimal", "ptr", fmt, "ptr", number, "int", length, "ptr", result, "int", resultLength, "ptr", pos, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Float} number 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatDoubleCurrency(fmt, number, currency, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatDoubleCurrency", "ptr", fmt, "double", number, "ptr", currency, "ptr", result, "int", resultLength, "ptr", pos, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatUFormattable(fmt, number, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatUFormattable", "ptr", fmt, "ptr", number, "ptr", result, "int", resultLength, "ptr", pos, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_parse(fmt, text, textLength, parsePos, status) {
        result := DllCall("icuin.dll\unum_parse", "ptr", fmt, "ptr", text, "int", textLength, "ptr", parsePos, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_parseInt64(fmt, text, textLength, parsePos, status) {
        result := DllCall("icuin.dll\unum_parseInt64", "ptr", fmt, "ptr", text, "int", textLength, "ptr", parsePos, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_parseDouble(fmt, text, textLength, parsePos, status) {
        DllCall("icuin.dll\unum_parseDouble", "ptr", fmt, "ptr", text, "int", textLength, "ptr", parsePos, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<PSTR>} outBuf 
     * @param {Integer} outBufLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_parseDecimal(fmt, text, textLength, parsePos, outBuf, outBufLength, status) {
        result := DllCall("icuin.dll\unum_parseDecimal", "ptr", fmt, "ptr", text, "int", textLength, "ptr", parsePos, "ptr", outBuf, "int", outBufLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_parseDoubleCurrency(fmt, text, textLength, parsePos, currency, status) {
        DllCall("icuin.dll\unum_parseDoubleCurrency", "ptr", fmt, "ptr", text, "int", textLength, "ptr", parsePos, "ptr", currency, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} result 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_parseToUFormattable(fmt, result, text, textLength, parsePos, status) {
        DllCall("icuin.dll\unum_parseToUFormattable", "ptr", fmt, "ptr", result, "ptr", text, "int", textLength, "ptr", parsePos, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Integer} localized 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_applyPattern(format, localized, pattern, patternLength, parseError, status) {
        DllCall("icuin.dll\unum_applyPattern", "ptr", format, "char", localized, "ptr", pattern, "int", patternLength, "ptr", parseError, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {Pointer<PSTR>} 
     */
    static unum_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\unum_getAvailable", "int", localeIndex, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static unum_countAvailable() {
        result := DllCall("icuin.dll\unum_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @returns {Integer} 
     */
    static unum_getAttribute(fmt, attr) {
        result := DllCall("icuin.dll\unum_getAttribute", "ptr", fmt, "int", attr, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setAttribute(fmt, attr, newValue) {
        DllCall("icuin.dll\unum_setAttribute", "ptr", fmt, "int", attr, "int", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_getDoubleAttribute(fmt, attr) {
        DllCall("icuin.dll\unum_getDoubleAttribute", "ptr", fmt, "int", attr, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @param {Float} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setDoubleAttribute(fmt, attr, newValue) {
        DllCall("icuin.dll\unum_setDoubleAttribute", "ptr", fmt, "int", attr, "double", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} tag 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_getTextAttribute(fmt, tag, result, resultLength, status) {
        result := DllCall("icuin.dll\unum_getTextAttribute", "ptr", fmt, "int", tag, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} tag 
     * @param {Pointer<UInt16>} newValue 
     * @param {Integer} newValueLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setTextAttribute(fmt, tag, newValue, newValueLength, status) {
        DllCall("icuin.dll\unum_setTextAttribute", "ptr", fmt, "int", tag, "ptr", newValue, "int", newValueLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} isPatternLocalized 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_toPattern(fmt, isPatternLocalized, result, resultLength, status) {
        result := DllCall("icuin.dll\unum_toPattern", "ptr", fmt, "char", isPatternLocalized, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} symbol 
     * @param {Pointer<UInt16>} buffer 
     * @param {Integer} size 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_getSymbol(fmt, symbol, buffer, size, status) {
        result := DllCall("icuin.dll\unum_getSymbol", "ptr", fmt, "int", symbol, "ptr", buffer, "int", size, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} symbol 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setSymbol(fmt, symbol, value, length, status) {
        DllCall("icuin.dll\unum_setSymbol", "ptr", fmt, "int", symbol, "ptr", value, "int", length, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static unum_getLocaleByType(fmt, type, status) {
        result := DllCall("icuin.dll\unum_getLocaleByType", "ptr", fmt, "int", type, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setContext(fmt, value, status) {
        DllCall("icuin.dll\unum_setContext", "ptr", fmt, "int", value, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_getContext(fmt, type, status) {
        DllCall("icuin.dll\unum_getContext", "ptr", fmt, "int", type, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} field 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_toCalendarDateField(field) {
        DllCall("icuin.dll\udat_toCalendarDateField", "int", field, "CDecl ")
    }

    /**
     * 
     * @param {Integer} timeStyle 
     * @param {Integer} dateStyle 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UInt16>} tzID 
     * @param {Integer} tzIDLength 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_open(timeStyle, dateStyle, locale, tzID, tzIDLength, pattern, patternLength, status) {
        DllCall("icuin.dll\udat_open", "int", timeStyle, "int", dateStyle, "ptr", locale, "ptr", tzID, "int", tzIDLength, "ptr", pattern, "int", patternLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_close(format) {
        DllCall("icuin.dll\udat_close", "ptr", format, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_getBooleanAttribute(fmt, attr, status) {
        result := DllCall("icuin.dll\udat_getBooleanAttribute", "ptr", fmt, "int", attr, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setBooleanAttribute(fmt, attr, newValue, status) {
        DllCall("icuin.dll\udat_setBooleanAttribute", "ptr", fmt, "int", attr, "char", newValue, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_clone(fmt, status) {
        DllCall("icuin.dll\udat_clone", "ptr", fmt, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Float} dateToFormat 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_format(format, dateToFormat, result, resultLength, position, status) {
        result := DllCall("icuin.dll\udat_format", "ptr", format, "double", dateToFormat, "ptr", result, "int", resultLength, "ptr", position, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Pointer<Void>} calendar 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} capacity 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_formatCalendar(format, calendar, result, capacity, position, status) {
        result := DllCall("icuin.dll\udat_formatCalendar", "ptr", format, "ptr", calendar, "ptr", result, "int", capacity, "ptr", position, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Float} dateToFormat 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<IntPtr>} fpositer 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_formatForFields(format, dateToFormat, result, resultLength, fpositer, status) {
        result := DllCall("icuin.dll\udat_formatForFields", "ptr", format, "double", dateToFormat, "ptr", result, "int", resultLength, "ptr", fpositer, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Pointer<Void>} calendar 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} capacity 
     * @param {Pointer<IntPtr>} fpositer 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_formatCalendarForFields(format, calendar, result, capacity, fpositer, status) {
        result := DllCall("icuin.dll\udat_formatCalendarForFields", "ptr", format, "ptr", calendar, "ptr", result, "int", capacity, "ptr", fpositer, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static udat_parse(format, text, textLength, parsePos, status) {
        result := DllCall("icuin.dll\udat_parse", "ptr", format, "ptr", text, "int", textLength, "ptr", parsePos, "ptr", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Pointer<Void>} calendar 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_parseCalendar(format, calendar, text, textLength, parsePos, status) {
        DllCall("icuin.dll\udat_parseCalendar", "ptr", format, "ptr", calendar, "ptr", text, "int", textLength, "ptr", parsePos, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {Integer} 
     */
    static udat_isLenient(fmt) {
        result := DllCall("icuin.dll\udat_isLenient", "ptr", fmt, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} isLenient 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setLenient(fmt, isLenient) {
        DllCall("icuin.dll\udat_setLenient", "ptr", fmt, "char", isLenient, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_getCalendar(fmt) {
        DllCall("icuin.dll\udat_getCalendar", "ptr", fmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} calendarToSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setCalendar(fmt, calendarToSet) {
        DllCall("icuin.dll\udat_setCalendar", "ptr", fmt, "ptr", calendarToSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_getNumberFormat(fmt) {
        DllCall("icuin.dll\udat_getNumberFormat", "ptr", fmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} field 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_getNumberFormatForField(fmt, field) {
        DllCall("icuin.dll\udat_getNumberFormatForField", "ptr", fmt, "ushort", field, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} fields 
     * @param {Pointer<Void>} numberFormatToSet 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_adoptNumberFormatForFields(fmt, fields, numberFormatToSet, status) {
        DllCall("icuin.dll\udat_adoptNumberFormatForFields", "ptr", fmt, "ptr", fields, "ptr", numberFormatToSet, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} numberFormatToSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setNumberFormat(fmt, numberFormatToSet) {
        DllCall("icuin.dll\udat_setNumberFormat", "ptr", fmt, "ptr", numberFormatToSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} numberFormatToAdopt 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_adoptNumberFormat(fmt, numberFormatToAdopt) {
        DllCall("icuin.dll\udat_adoptNumberFormat", "ptr", fmt, "ptr", numberFormatToAdopt, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {Pointer<PSTR>} 
     */
    static udat_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\udat_getAvailable", "int", localeIndex, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static udat_countAvailable() {
        result := DllCall("icuin.dll\udat_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static udat_get2DigitYearStart(fmt, status) {
        result := DllCall("icuin.dll\udat_get2DigitYearStart", "ptr", fmt, "ptr", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Float} d 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_set2DigitYearStart(fmt, d, status) {
        DllCall("icuin.dll\udat_set2DigitYearStart", "ptr", fmt, "double", d, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} localized 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_toPattern(fmt, localized, result, resultLength, status) {
        result := DllCall("icuin.dll\udat_toPattern", "ptr", fmt, "char", localized, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Integer} localized 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_applyPattern(format, localized, pattern, patternLength) {
        DllCall("icuin.dll\udat_applyPattern", "ptr", format, "char", localized, "ptr", pattern, "int", patternLength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Integer} symbolIndex 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_getSymbols(fmt, type, symbolIndex, result, resultLength, status) {
        result := DllCall("icuin.dll\udat_getSymbols", "ptr", fmt, "int", type, "int", symbolIndex, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @returns {Integer} 
     */
    static udat_countSymbols(fmt, type) {
        result := DllCall("icuin.dll\udat_countSymbols", "ptr", fmt, "int", type, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Integer} type 
     * @param {Integer} symbolIndex 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} valueLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setSymbols(format, type, symbolIndex, value, valueLength, status) {
        DllCall("icuin.dll\udat_setSymbols", "ptr", format, "int", type, "int", symbolIndex, "ptr", value, "int", valueLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static udat_getLocaleByType(fmt, type, status) {
        result := DllCall("icuin.dll\udat_getLocaleByType", "ptr", fmt, "int", type, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setContext(fmt, value, status) {
        DllCall("icuin.dll\udat_setContext", "ptr", fmt, "int", value, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_getContext(fmt, type, status) {
        DllCall("icuin.dll\udat_getContext", "ptr", fmt, "int", type, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_open(locale, pErrorCode) {
        DllCall("icuin.dll\udatpg_open", "ptr", locale, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_openEmpty(pErrorCode) {
        DllCall("icuin.dll\udatpg_openEmpty", "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_close(dtpg) {
        DllCall("icuin.dll\udatpg_close", "ptr", dtpg, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_clone(dtpg, pErrorCode) {
        DllCall("icuin.dll\udatpg_clone", "ptr", dtpg, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} bestPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBestPattern(dtpg, skeleton, length, bestPattern, capacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_getBestPattern", "ptr", dtpg, "ptr", skeleton, "int", length, "ptr", bestPattern, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} length 
     * @param {Integer} options 
     * @param {Pointer<UInt16>} bestPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBestPatternWithOptions(dtpg, skeleton, length, options, bestPattern, capacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_getBestPatternWithOptions", "ptr", dtpg, "ptr", skeleton, "int", length, "int", options, "ptr", bestPattern, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} unusedDtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getSkeleton(unusedDtpg, pattern, length, skeleton, capacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_getSkeleton", "ptr", unusedDtpg, "ptr", pattern, "int", length, "ptr", skeleton, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} unusedDtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} baseSkeleton 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBaseSkeleton(unusedDtpg, pattern, length, baseSkeleton, capacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_getBaseSkeleton", "ptr", unusedDtpg, "ptr", pattern, "int", length, "ptr", baseSkeleton, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} override 
     * @param {Pointer<UInt16>} conflictingPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_addPattern(dtpg, pattern, patternLength, override, conflictingPattern, capacity, pLength, pErrorCode) {
        DllCall("icuin.dll\udatpg_addPattern", "ptr", dtpg, "ptr", pattern, "int", patternLength, "char", override, "ptr", conflictingPattern, "int", capacity, "ptr", pLength, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setAppendItemFormat(dtpg, field, value, length) {
        DllCall("icuin.dll\udatpg_setAppendItemFormat", "ptr", dtpg, "int", field, "ptr", value, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getAppendItemFormat(dtpg, field, pLength) {
        result := DllCall("icuin.dll\udatpg_getAppendItemFormat", "ptr", dtpg, "int", field, "ptr", pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setAppendItemName(dtpg, field, value, length) {
        DllCall("icuin.dll\udatpg_setAppendItemName", "ptr", dtpg, "int", field, "ptr", value, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getAppendItemName(dtpg, field, pLength) {
        result := DllCall("icuin.dll\udatpg_getAppendItemName", "ptr", dtpg, "int", field, "ptr", pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Integer} width 
     * @param {Pointer<UInt16>} fieldName 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getFieldDisplayName(dtpg, field, width, fieldName, capacity, pErrorCode) {
        result := DllCall("icu.dll\udatpg_getFieldDisplayName", "ptr", dtpg, "int", field, "int", width, "ptr", fieldName, "int", capacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} dtFormat 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setDateTimeFormat(dtpg, dtFormat, length) {
        DllCall("icuin.dll\udatpg_setDateTimeFormat", "ptr", dtpg, "ptr", dtFormat, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getDateTimeFormat(dtpg, pLength) {
        result := DllCall("icuin.dll\udatpg_getDateTimeFormat", "ptr", dtpg, "ptr", pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} decimal 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setDecimal(dtpg, decimal, length) {
        DllCall("icuin.dll\udatpg_setDecimal", "ptr", dtpg, "ptr", decimal, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getDecimal(dtpg, pLength) {
        result := DllCall("icuin.dll\udatpg_getDecimal", "ptr", dtpg, "ptr", pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_replaceFieldTypes(dtpg, pattern, patternLength, skeleton, skeletonLength, dest, destCapacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_replaceFieldTypes", "ptr", dtpg, "ptr", pattern, "int", patternLength, "ptr", skeleton, "int", skeletonLength, "ptr", dest, "int", destCapacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Integer} options 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_replaceFieldTypesWithOptions(dtpg, pattern, patternLength, skeleton, skeletonLength, options, dest, destCapacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_replaceFieldTypesWithOptions", "ptr", dtpg, "ptr", pattern, "int", patternLength, "ptr", skeleton, "int", skeletonLength, "int", options, "ptr", dest, "int", destCapacity, "ptr", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_openSkeletons(dtpg, pErrorCode) {
        DllCall("icuin.dll\udatpg_openSkeletons", "ptr", dtpg, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_openBaseSkeletons(dtpg, pErrorCode) {
        DllCall("icuin.dll\udatpg_openBaseSkeletons", "ptr", dtpg, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getPatternForSkeleton(dtpg, skeleton, skeletonLength, pLength) {
        result := DllCall("icuin.dll\udatpg_getPatternForSkeleton", "ptr", dtpg, "ptr", skeleton, "int", skeletonLength, "ptr", pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLen 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_openForSkeletonAndLocale(skeleton, skeletonLen, locale, ec) {
        DllCall("icu.dll\unumf_openForSkeletonAndLocale", "ptr", skeleton, "int", skeletonLen, "ptr", locale, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLen 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<UParseError>} perror 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_openForSkeletonAndLocaleWithError(skeleton, skeletonLen, locale, perror, ec) {
        DllCall("icu.dll\unumf_openForSkeletonAndLocaleWithError", "ptr", skeleton, "int", skeletonLen, "ptr", locale, "ptr", perror, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_openResult(ec) {
        DllCall("icu.dll\unumf_openResult", "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uformatter 
     * @param {Integer} value 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatInt(uformatter, value, uresult, ec) {
        DllCall("icu.dll\unumf_formatInt", "ptr", uformatter, "int64", value, "ptr", uresult, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uformatter 
     * @param {Float} value 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatDouble(uformatter, value, uresult, ec) {
        DllCall("icu.dll\unumf_formatDouble", "ptr", uformatter, "double", value, "ptr", uresult, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uformatter 
     * @param {Pointer<PSTR>} value 
     * @param {Integer} valueLen 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatDecimal(uformatter, value, valueLen, uresult, ec) {
        DllCall("icu.dll\unumf_formatDecimal", "ptr", uformatter, "ptr", value, "int", valueLen, "ptr", uresult, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<IntPtr>} 
     */
    static unumf_resultAsValue(uresult, ec) {
        result := DllCall("icu.dll\unumf_resultAsValue", "ptr", uresult, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<UInt16>} buffer 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static unumf_resultToString(uresult, buffer, bufferCapacity, ec) {
        result := DllCall("icu.dll\unumf_resultToString", "ptr", uresult, "ptr", buffer, "int", bufferCapacity, "ptr", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<UFieldPosition>} ufpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static unumf_resultNextFieldPosition(uresult, ufpos, ec) {
        result := DllCall("icu.dll\unumf_resultNextFieldPosition", "ptr", uresult, "ptr", ufpos, "ptr", ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @param {Pointer<IntPtr>} ufpositer 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_resultGetAllFieldPositions(uresult, ufpositer, ec) {
        DllCall("icu.dll\unumf_resultGetAllFieldPositions", "ptr", uresult, "ptr", ufpositer, "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uformatter 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_close(uformatter) {
        DllCall("icu.dll\unumf_close", "ptr", uformatter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_closeResult(uresult) {
        DllCall("icu.dll\unumf_closeResult", "ptr", uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumsys_open(locale, status) {
        DllCall("icuin.dll\unumsys_open", "ptr", locale, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} name 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumsys_openByName(name, status) {
        DllCall("icuin.dll\unumsys_openByName", "ptr", name, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} unumsys 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumsys_close(unumsys) {
        DllCall("icuin.dll\unumsys_close", "ptr", unumsys, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumsys_openAvailableNames(status) {
        DllCall("icuin.dll\unumsys_openAvailableNames", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} unumsys 
     * @returns {Pointer<PSTR>} 
     */
    static unumsys_getName(unumsys) {
        result := DllCall("icuin.dll\unumsys_getName", "ptr", unumsys, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} unumsys 
     * @returns {Integer} 
     */
    static unumsys_isAlgorithmic(unumsys) {
        result := DllCall("icuin.dll\unumsys_isAlgorithmic", "ptr", unumsys, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} unumsys 
     * @returns {Integer} 
     */
    static unumsys_getRadix(unumsys) {
        result := DllCall("icuin.dll\unumsys_getRadix", "ptr", unumsys, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} unumsys 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unumsys_getDescription(unumsys, result, resultLength, status) {
        result := DllCall("icuin.dll\unumsys_getDescription", "ptr", unumsys, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uplrules_open(locale, status) {
        DllCall("icuin.dll\uplrules_open", "ptr", locale, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uplrules_openForType(locale, type, status) {
        DllCall("icuin.dll\uplrules_openForType", "ptr", locale, "int", type, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uplrules 
     * @returns {String} Nothing - always returns an empty string
     */
    static uplrules_close(uplrules) {
        DllCall("icuin.dll\uplrules_close", "ptr", uplrules, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uplrules 
     * @param {Float} number 
     * @param {Pointer<UInt16>} keyword 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uplrules_select(uplrules, number, keyword, capacity, status) {
        result := DllCall("icuin.dll\uplrules_select", "ptr", uplrules, "double", number, "ptr", keyword, "int", capacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uplrules 
     * @param {Pointer<IntPtr>} number 
     * @param {Pointer<UInt16>} keyword 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uplrules_selectFormatted(uplrules, number, keyword, capacity, status) {
        result := DllCall("icu.dll\uplrules_selectFormatted", "ptr", uplrules, "ptr", number, "ptr", keyword, "int", capacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uplrules 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uplrules_getKeywords(uplrules, status) {
        DllCall("icuin.dll\uplrules_getKeywords", "ptr", uplrules, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_open(pattern, patternLength, flags, pe, status) {
        DllCall("icuin.dll\uregex_open", "ptr", pattern, "int", patternLength, "uint", flags, "ptr", pe, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} pattern 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_openUText(pattern, flags, pe, status) {
        DllCall("icuin.dll\uregex_openUText", "ptr", pattern, "uint", flags, "ptr", pe, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} pattern 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_openC(pattern, flags, pe, status) {
        DllCall("icuin.dll\uregex_openC", "ptr", pattern, "uint", flags, "ptr", pe, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_close(regexp) {
        DllCall("icuin.dll\uregex_close", "ptr", regexp, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_clone(regexp, status) {
        DllCall("icuin.dll\uregex_clone", "ptr", regexp, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} patLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static uregex_pattern(regexp, patLength, status) {
        result := DllCall("icuin.dll\uregex_pattern", "ptr", regexp, "ptr", patLength, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_patternUText(regexp, status) {
        DllCall("icuin.dll\uregex_patternUText", "ptr", regexp, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_flags(regexp, status) {
        result := DllCall("icuin.dll\uregex_flags", "ptr", regexp, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setText(regexp, text, textLength, status) {
        DllCall("icuin.dll\uregex_setText", "ptr", regexp, "ptr", text, "int", textLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setUText(regexp, text, status) {
        DllCall("icuin.dll\uregex_setUText", "ptr", regexp, "ptr", text, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static uregex_getText(regexp, textLength, status) {
        result := DllCall("icuin.dll\uregex_getText", "ptr", regexp, "ptr", textLength, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_getUText(regexp, dest, status) {
        DllCall("icuin.dll\uregex_getUText", "ptr", regexp, "ptr", dest, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_refreshUText(regexp, text, status) {
        DllCall("icuin.dll\uregex_refreshUText", "ptr", regexp, "ptr", text, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_matches(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_matches", "ptr", regexp, "int", startIndex, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_matches64(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_matches64", "ptr", regexp, "int64", startIndex, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_lookingAt(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_lookingAt", "ptr", regexp, "int", startIndex, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_lookingAt64(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_lookingAt64", "ptr", regexp, "int64", startIndex, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_find(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_find", "ptr", regexp, "int", startIndex, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_find64(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_find64", "ptr", regexp, "int64", startIndex, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_findNext(regexp, status) {
        result := DllCall("icuin.dll\uregex_findNext", "ptr", regexp, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_groupCount(regexp, status) {
        result := DllCall("icuin.dll\uregex_groupCount", "ptr", regexp, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UInt16>} groupName 
     * @param {Integer} nameLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_groupNumberFromName(regexp, groupName, nameLength, status) {
        result := DllCall("icuin.dll\uregex_groupNumberFromName", "ptr", regexp, "ptr", groupName, "int", nameLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<PSTR>} groupName 
     * @param {Integer} nameLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_groupNumberFromCName(regexp, groupName, nameLength, status) {
        result := DllCall("icuin.dll\uregex_groupNumberFromCName", "ptr", regexp, "ptr", groupName, "int", nameLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_group(regexp, groupNum, dest, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_group", "ptr", regexp, "int", groupNum, "ptr", dest, "int", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int64>} groupLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_groupUText(regexp, groupNum, dest, groupLength, status) {
        DllCall("icuin.dll\uregex_groupUText", "ptr", regexp, "int", groupNum, "ptr", dest, "ptr", groupLength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_start(regexp, groupNum, status) {
        result := DllCall("icuin.dll\uregex_start", "ptr", regexp, "int", groupNum, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_start64(regexp, groupNum, status) {
        result := DllCall("icuin.dll\uregex_start64", "ptr", regexp, "int", groupNum, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_end(regexp, groupNum, status) {
        result := DllCall("icuin.dll\uregex_end", "ptr", regexp, "int", groupNum, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_end64(regexp, groupNum, status) {
        result := DllCall("icuin.dll\uregex_end64", "ptr", regexp, "int", groupNum, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} index 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_reset(regexp, index, status) {
        DllCall("icuin.dll\uregex_reset", "ptr", regexp, "int", index, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} index 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_reset64(regexp, index, status) {
        DllCall("icuin.dll\uregex_reset64", "ptr", regexp, "int64", index, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegion(regexp, regionStart, regionLimit, status) {
        DllCall("icuin.dll\uregex_setRegion", "ptr", regexp, "int", regionStart, "int", regionLimit, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegion64(regexp, regionStart, regionLimit, status) {
        DllCall("icuin.dll\uregex_setRegion64", "ptr", regexp, "int64", regionStart, "int64", regionLimit, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegionAndStart(regexp, regionStart, regionLimit, startIndex, status) {
        DllCall("icuin.dll\uregex_setRegionAndStart", "ptr", regexp, "int64", regionStart, "int64", regionLimit, "int64", startIndex, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_regionStart(regexp, status) {
        result := DllCall("icuin.dll\uregex_regionStart", "ptr", regexp, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_regionStart64(regexp, status) {
        result := DllCall("icuin.dll\uregex_regionStart64", "ptr", regexp, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_regionEnd(regexp, status) {
        result := DllCall("icuin.dll\uregex_regionEnd", "ptr", regexp, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_regionEnd64(regexp, status) {
        result := DllCall("icuin.dll\uregex_regionEnd64", "ptr", regexp, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_hasTransparentBounds(regexp, status) {
        result := DllCall("icuin.dll\uregex_hasTransparentBounds", "ptr", regexp, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} b 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_useTransparentBounds(regexp, b, status) {
        DllCall("icuin.dll\uregex_useTransparentBounds", "ptr", regexp, "char", b, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_hasAnchoringBounds(regexp, status) {
        result := DllCall("icuin.dll\uregex_hasAnchoringBounds", "ptr", regexp, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} b 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_useAnchoringBounds(regexp, b, status) {
        DllCall("icuin.dll\uregex_useAnchoringBounds", "ptr", regexp, "char", b, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_hitEnd(regexp, status) {
        result := DllCall("icuin.dll\uregex_hitEnd", "ptr", regexp, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_requireEnd(regexp, status) {
        result := DllCall("icuin.dll\uregex_requireEnd", "ptr", regexp, "ptr", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UInt16>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_replaceAll(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_replaceAll", "ptr", regexp, "ptr", replacementText, "int", replacementLength, "ptr", destBuf, "int", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UText>} replacement 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_replaceAllUText(regexp, replacement, dest, status) {
        DllCall("icuin.dll\uregex_replaceAllUText", "ptr", regexp, "ptr", replacement, "ptr", dest, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UInt16>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_replaceFirst(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_replaceFirst", "ptr", regexp, "ptr", replacementText, "int", replacementLength, "ptr", destBuf, "int", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UText>} replacement 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_replaceFirstUText(regexp, replacement, dest, status) {
        DllCall("icuin.dll\uregex_replaceFirstUText", "ptr", regexp, "ptr", replacement, "ptr", dest, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UInt16>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Pointer<Int32>} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_appendReplacement(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_appendReplacement", "ptr", regexp, "ptr", replacementText, "int", replacementLength, "ptr", destBuf, "ptr", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UText>} replacementText 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_appendReplacementUText(regexp, replacementText, dest, status) {
        DllCall("icuin.dll\uregex_appendReplacementUText", "ptr", regexp, "ptr", replacementText, "ptr", dest, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Pointer<Int32>} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_appendTail(regexp, destBuf, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_appendTail", "ptr", regexp, "ptr", destBuf, "ptr", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_appendTailUText(regexp, dest, status) {
        DllCall("icuin.dll\uregex_appendTailUText", "ptr", regexp, "ptr", dest, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} requiredCapacity 
     * @param {Pointer<UInt16>} destFields 
     * @param {Integer} destFieldsCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_split(regexp, destBuf, destCapacity, requiredCapacity, destFields, destFieldsCapacity, status) {
        result := DllCall("icuin.dll\uregex_split", "ptr", regexp, "ptr", destBuf, "int", destCapacity, "ptr", requiredCapacity, "ptr", destFields, "int", destFieldsCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<UText>} destFields 
     * @param {Integer} destFieldsCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_splitUText(regexp, destFields, destFieldsCapacity, status) {
        result := DllCall("icuin.dll\uregex_splitUText", "ptr", regexp, "ptr", destFields, "int", destFieldsCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} limit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setTimeLimit(regexp, limit, status) {
        DllCall("icuin.dll\uregex_setTimeLimit", "ptr", regexp, "int", limit, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_getTimeLimit(regexp, status) {
        result := DllCall("icuin.dll\uregex_getTimeLimit", "ptr", regexp, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Integer} limit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setStackLimit(regexp, limit, status) {
        DllCall("icuin.dll\uregex_setStackLimit", "ptr", regexp, "int", limit, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_getStackLimit(regexp, status) {
        result := DllCall("icuin.dll\uregex_getStackLimit", "ptr", regexp, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<URegexMatchCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setMatchCallback(regexp, callback, context, status) {
        DllCall("icuin.dll\uregex_setMatchCallback", "ptr", regexp, "ptr", callback, "ptr", context, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<URegexMatchCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_getMatchCallback(regexp, callback, context, status) {
        DllCall("icuin.dll\uregex_getMatchCallback", "ptr", regexp, "ptr", callback, "ptr", context, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<URegexFindProgressCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setFindProgressCallback(regexp, callback, context, status) {
        DllCall("icuin.dll\uregex_setFindProgressCallback", "ptr", regexp, "ptr", callback, "ptr", context, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} regexp 
     * @param {Pointer<URegexFindProgressCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_getFindProgressCallback(regexp, callback, context, status) {
        DllCall("icuin.dll\uregex_getFindProgressCallback", "ptr", regexp, "ptr", callback, "ptr", context, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} regionCode 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static uregion_getRegionFromCode(regionCode, status) {
        result := DllCall("icuin.dll\uregion_getRegionFromCode", "ptr", regionCode, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} code 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static uregion_getRegionFromNumericCode(code, status) {
        result := DllCall("icuin.dll\uregion_getRegionFromNumericCode", "int", code, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregion_getAvailable(type, status) {
        DllCall("icuin.dll\uregion_getAvailable", "int", type, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @param {Pointer<IntPtr>} otherRegion 
     * @returns {Integer} 
     */
    static uregion_areEqual(uregion, otherRegion) {
        result := DllCall("icuin.dll\uregion_areEqual", "ptr", uregion, "ptr", otherRegion, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @returns {Pointer<IntPtr>} 
     */
    static uregion_getContainingRegion(uregion) {
        result := DllCall("icuin.dll\uregion_getContainingRegion", "ptr", uregion, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @param {Integer} type 
     * @returns {Pointer<IntPtr>} 
     */
    static uregion_getContainingRegionOfType(uregion, type) {
        result := DllCall("icuin.dll\uregion_getContainingRegionOfType", "ptr", uregion, "int", type, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregion_getContainedRegions(uregion, status) {
        DllCall("icuin.dll\uregion_getContainedRegions", "ptr", uregion, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregion_getContainedRegionsOfType(uregion, type, status) {
        DllCall("icuin.dll\uregion_getContainedRegionsOfType", "ptr", uregion, "int", type, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @param {Pointer<IntPtr>} otherRegion 
     * @returns {Integer} 
     */
    static uregion_contains(uregion, otherRegion) {
        result := DllCall("icuin.dll\uregion_contains", "ptr", uregion, "ptr", otherRegion, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregion_getPreferredValues(uregion, status) {
        DllCall("icuin.dll\uregion_getPreferredValues", "ptr", uregion, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @returns {Pointer<PSTR>} 
     */
    static uregion_getRegionCode(uregion) {
        result := DllCall("icuin.dll\uregion_getRegionCode", "ptr", uregion, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @returns {Integer} 
     */
    static uregion_getNumericCode(uregion) {
        result := DllCall("icuin.dll\uregion_getNumericCode", "ptr", uregion, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} uregion 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregion_getType(uregion) {
        DllCall("icuin.dll\uregion_getType", "ptr", uregion, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<Void>} nfToAdopt 
     * @param {Integer} width 
     * @param {Integer} capitalizationContext 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_open(locale, nfToAdopt, width, capitalizationContext, status) {
        DllCall("icuin.dll\ureldatefmt_open", "ptr", locale, "ptr", nfToAdopt, "int", width, "int", capitalizationContext, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} reldatefmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_close(reldatefmt) {
        DllCall("icuin.dll\ureldatefmt_close", "ptr", reldatefmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_openResult(ec) {
        DllCall("icu.dll\ureldatefmt_openResult", "ptr", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ufrdt 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<IntPtr>} 
     */
    static ureldatefmt_resultAsValue(ufrdt, ec) {
        result := DllCall("icu.dll\ureldatefmt_resultAsValue", "ptr", ufrdt, "ptr", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} ufrdt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_closeResult(ufrdt) {
        DllCall("icu.dll\ureldatefmt_closeResult", "ptr", ufrdt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_formatNumeric(reldatefmt, offset, unit, result, resultCapacity, status) {
        result := DllCall("icuin.dll\ureldatefmt_formatNumeric", "ptr", reldatefmt, "double", offset, "int", unit, "ptr", result, "int", resultCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<IntPtr>} result 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_formatNumericToResult(reldatefmt, offset, unit, result, status) {
        DllCall("icu.dll\ureldatefmt_formatNumericToResult", "ptr", reldatefmt, "double", offset, "int", unit, "ptr", result, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_format(reldatefmt, offset, unit, result, resultCapacity, status) {
        result := DllCall("icuin.dll\ureldatefmt_format", "ptr", reldatefmt, "double", offset, "int", unit, "ptr", result, "int", resultCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<IntPtr>} result 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_formatToResult(reldatefmt, offset, unit, result, status) {
        DllCall("icu.dll\ureldatefmt_formatToResult", "ptr", reldatefmt, "double", offset, "int", unit, "ptr", result, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} reldatefmt 
     * @param {Pointer<UInt16>} relativeDateString 
     * @param {Integer} relativeDateStringLen 
     * @param {Pointer<UInt16>} timeString 
     * @param {Integer} timeStringLen 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_combineDateAndTime(reldatefmt, relativeDateString, relativeDateStringLen, timeString, timeStringLen, result, resultCapacity, status) {
        result := DllCall("icuin.dll\ureldatefmt_combineDateAndTime", "ptr", reldatefmt, "ptr", relativeDateString, "int", relativeDateStringLen, "ptr", timeString, "int", timeStringLen, "ptr", result, "int", resultCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textlength 
     * @param {Pointer<PSTR>} locale 
     * @param {Pointer<IntPtr>} breakiter 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_open(pattern, patternlength, text, textlength, locale, breakiter, status) {
        DllCall("icuin.dll\usearch_open", "ptr", pattern, "int", patternlength, "ptr", text, "int", textlength, "ptr", locale, "ptr", breakiter, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textlength 
     * @param {Pointer<IntPtr>} collator 
     * @param {Pointer<IntPtr>} breakiter 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_openFromCollator(pattern, patternlength, text, textlength, collator, breakiter, status) {
        DllCall("icuin.dll\usearch_openFromCollator", "ptr", pattern, "int", patternlength, "ptr", text, "int", textlength, "ptr", collator, "ptr", breakiter, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} searchiter 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_close(searchiter) {
        DllCall("icuin.dll\usearch_close", "ptr", searchiter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setOffset(strsrch, position, status) {
        DllCall("icuin.dll\usearch_setOffset", "ptr", strsrch, "int", position, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getOffset(strsrch) {
        result := DllCall("icuin.dll\usearch_getOffset", "ptr", strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Integer} attribute 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setAttribute(strsrch, attribute, value, status) {
        DllCall("icuin.dll\usearch_setAttribute", "ptr", strsrch, "int", attribute, "int", value, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Integer} attribute 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_getAttribute(strsrch, attribute) {
        DllCall("icuin.dll\usearch_getAttribute", "ptr", strsrch, "int", attribute, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getMatchedStart(strsrch) {
        result := DllCall("icuin.dll\usearch_getMatchedStart", "ptr", strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getMatchedLength(strsrch) {
        result := DllCall("icuin.dll\usearch_getMatchedLength", "ptr", strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_getMatchedText(strsrch, result, resultCapacity, status) {
        result := DllCall("icuin.dll\usearch_getMatchedText", "ptr", strsrch, "ptr", result, "int", resultCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<IntPtr>} breakiter 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setBreakIterator(strsrch, breakiter, status) {
        DllCall("icuin.dll\usearch_setBreakIterator", "ptr", strsrch, "ptr", breakiter, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @returns {Pointer<IntPtr>} 
     */
    static usearch_getBreakIterator(strsrch) {
        result := DllCall("icuin.dll\usearch_getBreakIterator", "ptr", strsrch, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textlength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setText(strsrch, text, textlength, status) {
        DllCall("icuin.dll\usearch_setText", "ptr", strsrch, "ptr", text, "int", textlength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<Int32>} length 
     * @returns {Pointer<UInt16>} 
     */
    static usearch_getText(strsrch, length) {
        result := DllCall("icuin.dll\usearch_getText", "ptr", strsrch, "ptr", length, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_getCollator(strsrch) {
        DllCall("icuin.dll\usearch_getCollator", "ptr", strsrch, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<IntPtr>} collator 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setCollator(strsrch, collator, status) {
        DllCall("icuin.dll\usearch_setCollator", "ptr", strsrch, "ptr", collator, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setPattern(strsrch, pattern, patternlength, status) {
        DllCall("icuin.dll\usearch_setPattern", "ptr", strsrch, "ptr", pattern, "int", patternlength, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<Int32>} length 
     * @returns {Pointer<UInt16>} 
     */
    static usearch_getPattern(strsrch, length) {
        result := DllCall("icuin.dll\usearch_getPattern", "ptr", strsrch, "ptr", length, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_first(strsrch, status) {
        result := DllCall("icuin.dll\usearch_first", "ptr", strsrch, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_following(strsrch, position, status) {
        result := DllCall("icuin.dll\usearch_following", "ptr", strsrch, "int", position, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_last(strsrch, status) {
        result := DllCall("icuin.dll\usearch_last", "ptr", strsrch, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_preceding(strsrch, position, status) {
        result := DllCall("icuin.dll\usearch_preceding", "ptr", strsrch, "int", position, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_next(strsrch, status) {
        result := DllCall("icuin.dll\usearch_next", "ptr", strsrch, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_previous(strsrch, status) {
        result := DllCall("icuin.dll\usearch_previous", "ptr", strsrch, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} strsrch 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_reset(strsrch) {
        DllCall("icuin.dll\usearch_reset", "ptr", strsrch, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_open(status) {
        DllCall("icuin.dll\uspoof_open", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} data 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pActualLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_openFromSerialized(data, length, pActualLength, pErrorCode) {
        DllCall("icuin.dll\uspoof_openFromSerialized", "ptr", data, "int", length, "ptr", pActualLength, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<PSTR>} confusables 
     * @param {Integer} confusablesLen 
     * @param {Pointer<PSTR>} confusablesWholeScript 
     * @param {Integer} confusablesWholeScriptLen 
     * @param {Pointer<Int32>} errType 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_openFromSource(confusables, confusablesLen, confusablesWholeScript, confusablesWholeScriptLen, errType, pe, status) {
        DllCall("icuin.dll\uspoof_openFromSource", "ptr", confusables, "int", confusablesLen, "ptr", confusablesWholeScript, "int", confusablesWholeScriptLen, "ptr", errType, "ptr", pe, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_close(sc) {
        DllCall("icuin.dll\uspoof_close", "ptr", sc, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_clone(sc, status) {
        DllCall("icuin.dll\uspoof_clone", "ptr", sc, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Integer} checks 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setChecks(sc, checks, status) {
        DllCall("icuin.dll\uspoof_setChecks", "ptr", sc, "int", checks, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getChecks(sc, status) {
        result := DllCall("icuin.dll\uspoof_getChecks", "ptr", sc, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Integer} restrictionLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setRestrictionLevel(sc, restrictionLevel) {
        DllCall("icuin.dll\uspoof_setRestrictionLevel", "ptr", sc, "int", restrictionLevel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_getRestrictionLevel(sc) {
        DllCall("icuin.dll\uspoof_getRestrictionLevel", "ptr", sc, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<PSTR>} localesList 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setAllowedLocales(sc, localesList, status) {
        DllCall("icuin.dll\uspoof_setAllowedLocales", "ptr", sc, "ptr", localesList, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<PSTR>} 
     */
    static uspoof_getAllowedLocales(sc, status) {
        result := DllCall("icuin.dll\uspoof_getAllowedLocales", "ptr", sc, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<IntPtr>} chars 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setAllowedChars(sc, chars, status) {
        DllCall("icuin.dll\uspoof_setAllowedChars", "ptr", sc, "ptr", chars, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static uspoof_getAllowedChars(sc, status) {
        result := DllCall("icuin.dll\uspoof_getAllowedChars", "ptr", sc, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} length 
     * @param {Pointer<Int32>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_check(sc, id, length, position, status) {
        result := DllCall("icuin.dll\uspoof_check", "ptr", sc, "ptr", id, "int", length, "ptr", position, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<PSTR>} id 
     * @param {Integer} length 
     * @param {Pointer<Int32>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_checkUTF8(sc, id, length, position, status) {
        result := DllCall("icuin.dll\uspoof_checkUTF8", "ptr", sc, "ptr", id, "int", length, "ptr", position, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} length 
     * @param {Pointer<IntPtr>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_check2(sc, id, length, checkResult, status) {
        result := DllCall("icuin.dll\uspoof_check2", "ptr", sc, "ptr", id, "int", length, "ptr", checkResult, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<PSTR>} id 
     * @param {Integer} length 
     * @param {Pointer<IntPtr>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_check2UTF8(sc, id, length, checkResult, status) {
        result := DllCall("icuin.dll\uspoof_check2UTF8", "ptr", sc, "ptr", id, "int", length, "ptr", checkResult, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_openCheckResult(status) {
        DllCall("icuin.dll\uspoof_openCheckResult", "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} checkResult 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_closeCheckResult(checkResult) {
        DllCall("icuin.dll\uspoof_closeCheckResult", "ptr", checkResult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getCheckResultChecks(checkResult, status) {
        result := DllCall("icuin.dll\uspoof_getCheckResultChecks", "ptr", checkResult, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_getCheckResultRestrictionLevel(checkResult, status) {
        DllCall("icuin.dll\uspoof_getCheckResultRestrictionLevel", "ptr", checkResult, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<IntPtr>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static uspoof_getCheckResultNumerics(checkResult, status) {
        result := DllCall("icuin.dll\uspoof_getCheckResultNumerics", "ptr", checkResult, "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<UInt16>} id1 
     * @param {Integer} length1 
     * @param {Pointer<UInt16>} id2 
     * @param {Integer} length2 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_areConfusable(sc, id1, length1, id2, length2, status) {
        result := DllCall("icuin.dll\uspoof_areConfusable", "ptr", sc, "ptr", id1, "int", length1, "ptr", id2, "int", length2, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<PSTR>} id1 
     * @param {Integer} length1 
     * @param {Pointer<PSTR>} id2 
     * @param {Integer} length2 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_areConfusableUTF8(sc, id1, length1, id2, length2, status) {
        result := DllCall("icuin.dll\uspoof_areConfusableUTF8", "ptr", sc, "ptr", id1, "int", length1, "ptr", id2, "int", length2, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Integer} type 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getSkeleton(sc, type, id, length, dest, destCapacity, status) {
        result := DllCall("icuin.dll\uspoof_getSkeleton", "ptr", sc, "uint", type, "ptr", id, "int", length, "ptr", dest, "int", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Integer} type 
     * @param {Pointer<PSTR>} id 
     * @param {Integer} length 
     * @param {Pointer<PSTR>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getSkeletonUTF8(sc, type, id, length, dest, destCapacity, status) {
        result := DllCall("icuin.dll\uspoof_getSkeletonUTF8", "ptr", sc, "uint", type, "ptr", id, "int", length, "ptr", dest, "int", destCapacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static uspoof_getInclusionSet(status) {
        result := DllCall("icuin.dll\uspoof_getInclusionSet", "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<IntPtr>} 
     */
    static uspoof_getRecommendedSet(status) {
        result := DllCall("icuin.dll\uspoof_getRecommendedSet", "ptr", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<IntPtr>} sc 
     * @param {Pointer<Void>} data 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_serialize(sc, data, capacity, status) {
        result := DllCall("icuin.dll\uspoof_serialize", "ptr", sc, "ptr", data, "int", capacity, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} timeScale 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utmscale_getTimeScaleValue(timeScale, value, status) {
        result := DllCall("icuin.dll\utmscale_getTimeScaleValue", "int", timeScale, "int", value, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Integer} otherTime 
     * @param {Integer} timeScale 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utmscale_fromInt64(otherTime, timeScale, status) {
        result := DllCall("icuin.dll\utmscale_fromInt64", "int64", otherTime, "int", timeScale, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Integer} universalTime 
     * @param {Integer} timeScale 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utmscale_toInt64(universalTime, timeScale, status) {
        result := DllCall("icuin.dll\utmscale_toInt64", "int64", universalTime, "int", timeScale, "ptr", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} idLength 
     * @param {Integer} dir 
     * @param {Pointer<UInt16>} rules 
     * @param {Integer} rulesLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_openU(id, idLength, dir, rules, rulesLength, parseError, pErrorCode) {
        DllCall("icuin.dll\utrans_openU", "ptr", id, "int", idLength, "int", dir, "ptr", rules, "int", rulesLength, "ptr", parseError, "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_openInverse(trans, status) {
        DllCall("icuin.dll\utrans_openInverse", "ptr", trans, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_clone(trans, status) {
        DllCall("icuin.dll\utrans_clone", "ptr", trans, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_close(trans) {
        DllCall("icuin.dll\utrans_close", "ptr", trans, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Int32>} resultLength 
     * @returns {Pointer<UInt16>} 
     */
    static utrans_getUnicodeID(trans, resultLength) {
        result := DllCall("icuin.dll\utrans_getUnicodeID", "ptr", trans, "ptr", resultLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} adoptedTrans 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_register(adoptedTrans, status) {
        DllCall("icuin.dll\utrans_register", "ptr", adoptedTrans, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} idLength 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_unregisterID(id, idLength) {
        DllCall("icuin.dll\utrans_unregisterID", "ptr", id, "int", idLength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<UInt16>} filterPattern 
     * @param {Integer} filterPatternLen 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_setFilter(trans, filterPattern, filterPatternLen, status) {
        DllCall("icuin.dll\utrans_setFilter", "ptr", trans, "ptr", filterPattern, "int", filterPatternLen, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @returns {Integer} 
     */
    static utrans_countAvailableIDs() {
        result := DllCall("icuin.dll\utrans_countAvailableIDs", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_openIDs(pErrorCode) {
        DllCall("icuin.dll\utrans_openIDs", "ptr", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Void>} rep 
     * @param {Pointer<UReplaceableCallbacks>} repFunc 
     * @param {Integer} start 
     * @param {Pointer<Int32>} limit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_trans(trans, rep, repFunc, start, limit, status) {
        DllCall("icuin.dll\utrans_trans", "ptr", trans, "ptr", rep, "ptr", repFunc, "int", start, "ptr", limit, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Void>} rep 
     * @param {Pointer<UReplaceableCallbacks>} repFunc 
     * @param {Pointer<UTransPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transIncremental(trans, rep, repFunc, pos, status) {
        DllCall("icuin.dll\utrans_transIncremental", "ptr", trans, "ptr", rep, "ptr", repFunc, "ptr", pos, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<UInt16>} text 
     * @param {Pointer<Int32>} textLength 
     * @param {Integer} textCapacity 
     * @param {Integer} start 
     * @param {Pointer<Int32>} limit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transUChars(trans, text, textLength, textCapacity, start, limit, status) {
        DllCall("icuin.dll\utrans_transUChars", "ptr", trans, "ptr", text, "ptr", textLength, "int", textCapacity, "int", start, "ptr", limit, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<UInt16>} text 
     * @param {Pointer<Int32>} textLength 
     * @param {Integer} textCapacity 
     * @param {Pointer<UTransPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transIncrementalUChars(trans, text, textLength, textCapacity, pos, status) {
        DllCall("icuin.dll\utrans_transIncrementalUChars", "ptr", trans, "ptr", text, "ptr", textLength, "int", textCapacity, "ptr", pos, "ptr", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Integer} escapeUnprintable 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utrans_toRules(trans, escapeUnprintable, result, resultLength, status) {
        result := DllCall("icuin.dll\utrans_toRules", "ptr", trans, "char", escapeUnprintable, "ptr", result, "int", resultLength, "ptr", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Integer} ignoreFilter 
     * @param {Pointer<IntPtr>} fillIn 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_getSourceSet(trans, ignoreFilter, fillIn, status) {
        DllCall("icuin.dll\utrans_getSourceSet", "ptr", trans, "char", ignoreFilter, "ptr", fillIn, "ptr", status, "CDecl ")
    }

    /**
     * Determines the distance between the specified language code and the closest match in a list of languages.
     * @remarks
     * You can use this function for localization to find the closest match to a candidate language in the list of user languages.
     * @param {Pointer<PWSTR>} pszLanguage Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A [BCP-47](https://tools.ietf.org/html/bcp47) language tag that represents the candidate language.
     * @param {Pointer<PWSTR>} pszLanguagesList Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A character delimited list of [BCP-47](https://tools.ietf.org/html/bcp47) language tags to compare to the candidate language. This is typically the list of user languages.
     * 
     * If the *wchListDelimiter* parameter is `L'\0'`, then the *pszLanguagesList* is a double null-terminated list of language tags.
     * Otherwise, the *pszLanguagesList* is a null-terminated string in which the language tags are separated by the provided delimiter.
     * @param {Integer} wchListDelimiter Type: **[wchar_t](/windows/win32/midl/wchar-t)**
     * 
     * The character used as a delimiter in the language list, or `L'\0'` to indicate that the language list is a double null-terminated list.
     * The function is slightly more efficient if this parameter is `L'\0'`.
     * @param {Pointer<Double>} pClosestDistance Type: **[double](/windows/win32/midl/double)**
     * 
     * Receives the distance between the candidate language and the closest language in the list.
     * The value is in the range 0.0 to 1.0, where 1.0 is an exact match.
     * @returns {Integer} Type: **[HRESULT](/windows/desktop/com/structure-of-com-error-codes)**
     * 
     * If there is no match to any language in the list, the function returns `HRESULT_FROM_WIN32(ERROR_NO_MATCH)`
     * and a distance of 0.0.
     * @see https://learn.microsoft.com/windows/win32/api/bcp47mrm/nf-bcp47mrm-getdistanceofclosestlanguageinlist
     */
    static GetDistanceOfClosestLanguageInList(pszLanguage, pszLanguagesList, wchListDelimiter, pClosestDistance) {
        result := DllCall("bcp47mrm.dll\GetDistanceOfClosestLanguageInList", "ptr", pszLanguage, "ptr", pszLanguagesList, "char", wchListDelimiter, "ptr", pClosestDistance, "int")
        return result
    }

    /**
     * Determines whether a BCP-47 language tag is well-formed.
     * @remarks
     * If this function returns `true`, an application can safely construct a Windows Runtime [Language](https://docs.microsoft.com/uwp/api/Windows.Globalization.Language) by using this tag. If it returns `false`, attempting to construct a Language for the given tag will throw an exception.
     * @param {Pointer<PWSTR>} pszTag Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A [BCP-47](https://tools.ietf.org/html/bcp47) language tag.
     * @returns {Integer} `true` if the language tag is well-formed as defined by [BCP-47](https://tools.ietf.org/html/bcp47), except when the language tag can never be valid according to BCP-47. Otherwise it returns `false`.
     * @see https://learn.microsoft.com/windows/win32/api/bcp47mrm/nf-bcp47mrm-iswellformedtag
     */
    static IsWellFormedTag(pszTag) {
        result := DllCall("bcp47mrm.dll\IsWellFormedTag", "ptr", pszTag, "char")
        return result
    }

    /**
     * Deprecated. Gets the supported date range for a specified calendar.
     * @remarks
     * The earliest date supported by this function is January 1, 1601.
     * 
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * @param {Integer} Calendar [Calendar identifier](calendar-identifiers.md) for which to get the supported date range.
     * @param {Pointer<CALDATETIME>} lpCalMinDateTime Pointer to a [**CALDATETIME**](caldatetime.md) structure defining the minimum supported date.
     * @param {Pointer<CALDATETIME>} lpCalMaxDateTime Pointer to a [**CALDATETIME**](caldatetime.md) structure defining the maximum supported date.
     * @returns {Integer} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/getcalendarsupporteddaterange
     */
    static GetCalendarSupportedDateRange(Calendar, lpCalMinDateTime, lpCalMaxDateTime) {
        result := DllCall("KERNEL32.dll\GetCalendarSupportedDateRange", "uint", Calendar, "ptr", lpCalMinDateTime, "ptr", lpCalMaxDateTime, "int")
        return result
    }

    /**
     * Deprecated.
     * @remarks
     * The earliest date supported by this function is January 1, 1601.
     * 
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with that module handle and the name of this function to get the function address.
     * @param {Pointer<PWSTR>} lpszLocale Pointer to a locale name, or one of the following predefined values.
     * 
     * -   [LOCALE\_NAME\_INVARIANT](locale-name-constants.md)
     * -   [LOCALE\_NAME\_SYSTEM\_DEFAULT](locale-name-constants.md)
     * -   [LOCALE\_NAME\_USER\_DEFAULT](locale-name-constants.md)
     * @param {Integer} dwFlags Flags specifying date format options. If *lpFormat* is not set to **NULL**, this parameter must be set to 0. If *lpFormat* is set to **NULL**, the application can specify a combination of the following values and [LOCALE\_NOUSEROVERRIDE](locale-nouseroverride.md).
     * 
     * 
     * 
     * | Value                                                                                                                                                               | Meaning                                                                                                                       |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="DATE_SHORTDATE"></span><span id="date_shortdate"></span><dl> <dt>**DATE\_SHORTDATE**</dt> </dl>    | Use the short date format. This is the default. This value cannot be used with DATE\_LONGDATE or DATE\_YEARMONTH. <br/> |
     * | <span id="DATE_LONGDATE"></span><span id="date_longdate"></span><dl> <dt>**DATE\_LONGDATE**</dt> </dl>       | Use the long date format. This value cannot be used with DATE\_SHORTDATE or DATE\_YEARMONTH. <br/>                      |
     * | <span id="DATE_YEARMONTH"></span><span id="date_yearmonth"></span><dl> <dt>**DATE\_YEARMONTH**</dt> </dl>    | Use the year/month format. This value cannot be used with DATE\_SHORTDATE or DATE\_LONGDATE.<br/>                       |
     * | <span id="DATE_LTRREADING"></span><span id="date_ltrreading"></span><dl> <dt>**DATE\_LTRREADING**</dt> </dl> | Add marks for left-to-right reading layout. This value cannot be used with DATE\_RTLREADING.<br/>                       |
     * | <span id="DATE_RTLREADING"></span><span id="date_rtlreading"></span><dl> <dt>**DATE\_RTLREADING**</dt> </dl> | Add marks for right-to-left reading layout. This value cannot be used with DATE\_LTRREADING<br/>                        |
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to a [**CALDATETIME**](caldatetime.md) structure that contains the date and calendar information to format.
     * @param {Pointer<PWSTR>} lpFormat Pointer to a format picture string that is used to form the date string. Possible values for the format picture string are defined in [Day, Month, Year, and Era Format Pictures](day--month--year--and-era-format-pictures.md).
     * 
     * The format picture string must be null-terminated. The function uses the locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application sets this parameter to **NULL** if the function is to use the date format of the specified locale.
     * @param {Pointer<PWSTR>} lpDateStr Pointer to a buffer in which this function receives the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the *lpDateStr* buffer. Alternatively, the application can set this parameter to 0. In this case, the function returns the number of characters required to hold the formatted date string, and the *lpDateStr* parameter is not used.
     * @returns {Integer} Returns the number of characters written to the *lpDateStr* buffer if successful. If the *cchDate* parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_DATE\_OUT\_OF\_RANGE. The specified date was out of range.
     * -   ERROR\_INSUFFICIENT\_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to **NULL**.
     * -   ERROR\_INVALID\_FLAGS. The values supplied for flags were not valid.
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/getcalendardateformatex
     */
    static GetCalendarDateFormatEx(lpszLocale, dwFlags, lpCalDateTime, lpFormat, lpDateStr, cchDate) {
        result := DllCall("KERNEL32.dll\GetCalendarDateFormatEx", "ptr", lpszLocale, "uint", dwFlags, "ptr", lpCalDateTime, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "int")
        return result
    }

    /**
     * Deprecated. Converts a specified SYSTEMTIME structure to a CALDATETIME structure.
     * @remarks
     * The earliest date supported by this function is January 1, 1601.
     * 
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * @param {Pointer<SYSTEMTIME>} lpSysTime Pointer to the [**SYSTEMTIME**](/windows/win32/api/minwinbase/ns-minwinbase-systemtime) structure to convert.
     * @param {Integer} calId The system [calendar identifier](calendar-identifiers.md) to use in the conversion.
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to the equivalent [**CALDATETIME**](caldatetime.md) structure.
     * @returns {Integer} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/convertsystemtimetocaldatetime
     */
    static ConvertSystemTimeToCalDateTime(lpSysTime, calId, lpCalDateTime) {
        result := DllCall("KERNEL32.dll\ConvertSystemTimeToCalDateTime", "ptr", lpSysTime, "uint", calId, "ptr", lpCalDateTime, "int")
        return result
    }

    /**
     * Deprecated. Gets the day of the week that corresponds to a specified day and populates the DayOfWeek member in the specified CALDATETIME structure with that value.
     * @remarks
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with that module handle and the name of this function to get the function address.
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to the [**CALDATETIME**](caldatetime.md) structure containing the date for which to set the day of the week.
     * @returns {Integer} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_DATE\_OUT\_OF\_RANGE. The specified date was out of range.
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/updatecalendardayofweek
     */
    static UpdateCalendarDayOfWeek(lpCalDateTime) {
        result := DllCall("KERNEL32.dll\UpdateCalendarDayOfWeek", "ptr", lpCalDateTime, "int")
        return result
    }

    /**
     * Deprecated. Adjusts a date by a specified number of years, months, weeks, or days.
     * @remarks
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to a [**CALDATETIME**](caldatetime.md) structure that contains the date and calendar information to adjust.
     * @param {Integer} calUnit The [**CALDATETIME\_DATEUNIT**](caldatetime-dateunit.md) enumeration value indicating the date unit, for example, DayUnit.
     * @param {Integer} amount The amount by which to adjust the specified date.
     * @returns {Integer} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_DATE\_OUT\_OF\_RANGE. The specified date was out of range.
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/adjustcalendardate
     */
    static AdjustCalendarDate(lpCalDateTime, calUnit, amount) {
        result := DllCall("KERNEL32.dll\AdjustCalendarDate", "ptr", lpCalDateTime, "int", calUnit, "int", amount, "int")
        return result
    }

    /**
     * Deprecated. Converts a specified CALDATETIME structure to a SYSTEMTIME structure.
     * @remarks
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to the [**CALDATETIME**](caldatetime.md) structure to convert.
     * @param {Pointer<SYSTEMTIME>} lpSysTime Pointer to the equivalent [**SYSTEMTIME**](/windows/win32/api/minwinbase/ns-minwinbase-systemtime) structure.
     * @returns {Integer} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_DATE\_OUT\_OF\_RANGE. The specified date was out of range.
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/convertcaldatetimetosystemtime
     */
    static ConvertCalDateTimeToSystemTime(lpCalDateTime, lpSysTime) {
        result := DllCall("KERNEL32.dll\ConvertCalDateTimeToSystemTime", "ptr", lpCalDateTime, "ptr", lpSysTime, "int")
        return result
    }

    /**
     * Deprecated. Identifies whether the specified year is a leap year within the given era for the specific calendar.
     * @remarks
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with that module handle and the name of this function to get the function address.
     * @param {Integer} calId The [calendar identifier](calendar-identifiers.md) to use for checking leap year.
     * @param {Integer} year The year to check.
     * @param {Integer} era The era to check.
     * @returns {Integer} Returns **TRUE** if the specified year is a leap year, or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/iscalendarleapyear
     */
    static IsCalendarLeapYear(calId, year, era) {
        result := DllCall("KERNEL32.dll\IsCalendarLeapYear", "uint", calId, "uint", year, "uint", era, "int")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) in another Unicode string for a non-linguistic comparison.
     * @remarks
     * Since <b>FindStringOrdinal</b> provides a binary comparison, it does not return linguistically appropriate results. The ordinal comparison might be mistaken for English sorting behavior. However, it does not find matches when characters vary by linguistically insignificant amounts. See <a href="https://docs.microsoft.com/windows/desktop/Intl/sorting">Sorting</a> for information about choosing an appropriate sorting function.
     * 
     * In contrast to NLS functions that return 0 for failure, this function returns -1 if it fails. On success, it returns a 0-based index. Use of this index helps the function avoid off-by-one errors and one-character buffer overruns.
     * 
     * This function is one of the few NLS functions that calls <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> even when it succeeds. It makes this call to clear the last error in a thread when it fails to match the search string. This clears the value returned by <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <b>Starting with Windows 8: </b><b>FindStringOrdinal</b>  is declared in Libloaderapi.h. Before Windows 8, it was declared in Winnls.h.
     * @param {Integer} dwFindStringOrdinalFlags Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMSTART"></a><a id="find_fromstart"></a><dl>
     * <dt><b>FIND_FROMSTART</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string, starting with the first character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMEND"></a><a id="find_fromend"></a><dl>
     * <dt><b>FIND_FROMEND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string in the reverse direction, starting with the last character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_STARTSWITH"></a><a id="find_startswith"></a><dl>
     * <dt><b>FIND_STARTSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the first value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_ENDSWITH"></a><a id="find_endswith"></a><dl>
     * <dt><b>FIND_ENDSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the last value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<PWSTR>} lpStringValue Pointer to the search string for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the string is null-terminated and the function should calculate the size automatically.
     * @param {Integer} bIgnoreCase <b>TRUE</b> if the function is to perform a case-insensitive comparison, and <b>FALSE</b> otherwise. The comparison is not a linguistic operation and is not appropriate for all locales and languages. Its behavior is similar to that for English.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-findstringordinal
     * @since windows6.1
     */
    static FindStringOrdinal(dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase) {
        A_LastError := 0

        DllCall("KERNEL32.dll\FindStringOrdinal", "uint", dwFindStringOrdinalFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, "int", bIgnoreCase)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Compares two character strings. The comparison is case-sensitive. (ANSI)
     * @remarks
     * The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings. 
     * 
     *  Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect. 
     * 
     * The function calls <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings. 
     * 
     * The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.
     * 
     * With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings. 
     * 
     * The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {Pointer<PSTR>} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcmpa
     * @since windows5.0
     */
    static lstrcmpA(lpString1, lpString2) {
        DllCall("KERNEL32.dll\lstrcmpA", "ptr", lpString1, "ptr", lpString2)
    }

    /**
     * Compares two character strings. The comparison is case-sensitive. (Unicode)
     * @remarks
     * The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings. 
     * 
     *  Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect. 
     * 
     * The function calls <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings. 
     * 
     * The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.
     * 
     * With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings. 
     * 
     * The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {Pointer<PWSTR>} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcmpw
     * @since windows5.0
     */
    static lstrcmpW(lpString1, lpString2) {
        DllCall("KERNEL32.dll\lstrcmpW", "ptr", lpString1, "ptr", lpString2)
    }

    /**
     * Compares two character strings. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings. 
     * 
     *  Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect. 
     * 
     * The function calls <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.
     * 
     * For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.
     * 
     * With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings. 
     * 
     * The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {Pointer<PSTR>} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcmpia
     * @since windows5.0
     */
    static lstrcmpiA(lpString1, lpString2) {
        DllCall("KERNEL32.dll\lstrcmpiA", "ptr", lpString1, "ptr", lpString2)
    }

    /**
     * Compares two character strings. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings. 
     * 
     *  Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect. 
     * 
     * The function calls <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.
     * 
     * For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.
     * 
     * With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings. 
     * 
     * The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {Pointer<PWSTR>} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcmpiw
     * @since windows5.0
     */
    static lstrcmpiW(lpString1, lpString2) {
        DllCall("KERNEL32.dll\lstrcmpiW", "ptr", lpString1, "ptr", lpString2)
    }

    /**
     * Copies a specified number of characters from a source string into a buffer.Warning  Do not use. (ANSI)
     * @remarks
     * The buffer pointed to by <i>lpString1</i> must 
     * 			be large enough to include a terminating null character, and the string length 
     * 			value specified by <i>iMaxLength</i> includes room 
     * 			for a terminating null character. 
     * 
     * The <b>lstrcpyn</b> function has an undefined behavior if source 
     *     and destination buffers overlap.
     * 
     * <h3><a id="Security_Warning"></a><a id="security_warning"></a><a id="SECURITY_WARNING"></a>Security Warning</h3>
     * Using this function incorrectly can compromise the security 
     * 			of your application. This function uses structured exception handling (SEH) to catch 
     * 			access violations and other errors. When this function catches SEH errors, it returns 
     * 			<b>NULL</b> without null-terminating the string and without notifying the 
     * 			caller of the error. The caller is not safe to assume that insufficient space is 
     * 			the error condition.
     * 
     * If the buffer pointed to by <i>lpString1</i> is not large 
     * 			enough to contain the copied string, a buffer overrun can occur. When copying an entire 
     * 			string, note that <b>sizeof</b> returns the number of bytes. 
     * 			For example, if <i>lpString1</i> points to a buffer 
     * 			<i>szString1</i> which is declared as 
     * 			<c>TCHAR szString[100]</c>, then sizeof(szString1) gives the size of 
     * 			the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer 
     * 			overflow for the Unicode version of the function. 
     * 
     * Buffer overflow situations are the cause 
     * 			of many security problems in applications and can cause a denial of service attack against 
     * 			the application if an access violation occurs. In the worst case, a buffer overrun may 
     * 			allow an attacker to inject executable code into your process, especially if 
     * 			<i>lpString1</i> is a stack-based buffer.
     * 
     * Using <c>sizeof(szString1)/sizeof(szString1[0])</c> 
     * 				gives the proper size of the buffer. 
     * 
     * Consider using <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a> instead; use either 
     * 				<c>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</c>, 
     * 				being aware that <c>buffer</c> must not be a pointer or 
     * 				use <c>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</c>, 
     * 				being aware that, when copying to a pointer, the caller is responsible for 
     * 				passing in the size of the pointed-to memory in characters. 
     * 
     * Review <a href="https://docs.microsoft.com/windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} lpString1 Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the copied characters. The buffer 
     * 				must be large enough to contain the number of <b>TCHAR</b> values 
     * 				specified by <i>iMaxLength</i>, including room 
     * 				for a terminating null character.
     * @param {Pointer<PSTR>} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The source string from which the function is to copy characters.
     * @param {Integer} iMaxLength Type: <b>int</b>
     * 
     * The number of <b>TCHAR</b> values to be copied from the 
     * 				string pointed to by <i>lpString2</i> into the 
     * 				buffer pointed to by <i>lpString1</i>, including 
     * 				a terminating null character.
     * @returns {Pointer<PSTR>} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer. 
     * 				The function can succeed even if the source string is greater than 
     * 				<i>iMaxLength</i> characters.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcpyna
     * @since windows5.0
     */
    static lstrcpynA(lpString1, lpString2, iMaxLength) {
        result := DllCall("KERNEL32.dll\lstrcpynA", "ptr", lpString1, "ptr", lpString2, "int", iMaxLength, "ptr")
        return result
    }

    /**
     * Copies a specified number of characters from a source string into a buffer.Warning  Do not use. (Unicode)
     * @remarks
     * The buffer pointed to by <i>lpString1</i> must 
     * 			be large enough to include a terminating null character, and the string length 
     * 			value specified by <i>iMaxLength</i> includes room 
     * 			for a terminating null character. 
     * 
     * The <b>lstrcpyn</b> function has an undefined behavior if source 
     *     and destination buffers overlap.
     * 
     * <h3><a id="Security_Warning"></a><a id="security_warning"></a><a id="SECURITY_WARNING"></a>Security Warning</h3>
     * Using this function incorrectly can compromise the security 
     * 			of your application. This function uses structured exception handling (SEH) to catch 
     * 			access violations and other errors. When this function catches SEH errors, it returns 
     * 			<b>NULL</b> without null-terminating the string and without notifying the 
     * 			caller of the error. The caller is not safe to assume that insufficient space is 
     * 			the error condition.
     * 
     * If the buffer pointed to by <i>lpString1</i> is not large 
     * 			enough to contain the copied string, a buffer overrun can occur. When copying an entire 
     * 			string, note that <b>sizeof</b> returns the number of bytes. 
     * 			For example, if <i>lpString1</i> points to a buffer 
     * 			<i>szString1</i> which is declared as 
     * 			<c>TCHAR szString[100]</c>, then sizeof(szString1) gives the size of 
     * 			the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer 
     * 			overflow for the Unicode version of the function. 
     * 
     * Buffer overflow situations are the cause 
     * 			of many security problems in applications and can cause a denial of service attack against 
     * 			the application if an access violation occurs. In the worst case, a buffer overrun may 
     * 			allow an attacker to inject executable code into your process, especially if 
     * 			<i>lpString1</i> is a stack-based buffer.
     * 
     * Using <c>sizeof(szString1)/sizeof(szString1[0])</c> 
     * 				gives the proper size of the buffer. 
     * 
     * Consider using <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a> instead; use either 
     * 				<c>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</c>, 
     * 				being aware that <c>buffer</c> must not be a pointer or 
     * 				use <c>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</c>, 
     * 				being aware that, when copying to a pointer, the caller is responsible for 
     * 				passing in the size of the pointed-to memory in characters. 
     * 
     * Review <a href="https://docs.microsoft.com/windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} lpString1 Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the copied characters. The buffer 
     * 				must be large enough to contain the number of <b>TCHAR</b> values 
     * 				specified by <i>iMaxLength</i>, including room 
     * 				for a terminating null character.
     * @param {Pointer<PWSTR>} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The source string from which the function is to copy characters.
     * @param {Integer} iMaxLength Type: <b>int</b>
     * 
     * The number of <b>TCHAR</b> values to be copied from the 
     * 				string pointed to by <i>lpString2</i> into the 
     * 				buffer pointed to by <i>lpString1</i>, including 
     * 				a terminating null character.
     * @returns {Pointer<PWSTR>} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer. 
     * 				The function can succeed even if the source string is greater than 
     * 				<i>iMaxLength</i> characters.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcpynw
     * @since windows5.0
     */
    static lstrcpynW(lpString1, lpString2, iMaxLength) {
        result := DllCall("KERNEL32.dll\lstrcpynW", "ptr", lpString1, "ptr", lpString2, "int", iMaxLength, "ptr")
        return result
    }

    /**
     * Copies a string to a buffer. (ANSI)
     * @remarks
     * With a double-byte character set (DBCS) version of the system, this function can be used 
     * 			to copy a DBCS string. 
     * 
     * The <b>lstrcpy</b> function has an 
     * 			undefined behavior if source and destination buffers overlap.
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * Using this function incorrectly can compromise the security 
     * 			of your application. This function uses structured exception handling (SEH) to catch 
     * 			access violations and other errors. When this function catches SEH errors, it returns 
     * 			<b>NULL</b> without null-terminating the string and without notifying the 
     * 			caller of the error. The caller is not safe to assume that insufficient space is 
     * 			the error condition.
     * 
     * <i>lpString1</i> must be large enough to hold <i>lpString2</i> 
     * 			and the closing '\0', otherwise a buffer overrun may occur.
     * 
     * Buffer overflow situations are the cause of many security problems in applications and 
     * 			can cause a denial of service attack against the application if an access violation occurs. 
     * 			In the worst case, a buffer overrun may allow an attacker to inject executable code into 
     * 			your process, especially if <i>lpString1</i> is a stack-based buffer.
     * 
     * Consider using <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a> instead; use either 
     * 				<c>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</c>, 
     * 				being aware that <c>buffer</c> must not be a pointer or 
     * 				use <c>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</c>, 
     * 				being aware that, when copying to a pointer, the caller is responsible for 
     * 				passing in the size of the pointed-to memory in characters. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} lpString1 Type: <b>LPTSTR</b>
     * 
     * A buffer to receive the contents of the string pointed to by the 
     * 					<i>lpString2</i> parameter. 
     * 					The buffer must be large enough to contain the string, including the 
     * 					terminating null character.
     * @param {Pointer<PSTR>} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be copied.
     * @returns {Pointer<PSTR>} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcpya
     * @since windows5.0
     */
    static lstrcpyA(lpString1, lpString2) {
        result := DllCall("KERNEL32.dll\lstrcpyA", "ptr", lpString1, "ptr", lpString2, "ptr")
        return result
    }

    /**
     * Copies a string to a buffer. (Unicode)
     * @remarks
     * With a double-byte character set (DBCS) version of the system, this function can be used 
     * 			to copy a DBCS string. 
     * 
     * The <b>lstrcpy</b> function has an 
     * 			undefined behavior if source and destination buffers overlap.
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * Using this function incorrectly can compromise the security 
     * 			of your application. This function uses structured exception handling (SEH) to catch 
     * 			access violations and other errors. When this function catches SEH errors, it returns 
     * 			<b>NULL</b> without null-terminating the string and without notifying the 
     * 			caller of the error. The caller is not safe to assume that insufficient space is 
     * 			the error condition.
     * 
     * <i>lpString1</i> must be large enough to hold <i>lpString2</i> 
     * 			and the closing '\0', otherwise a buffer overrun may occur.
     * 
     * Buffer overflow situations are the cause of many security problems in applications and 
     * 			can cause a denial of service attack against the application if an access violation occurs. 
     * 			In the worst case, a buffer overrun may allow an attacker to inject executable code into 
     * 			your process, especially if <i>lpString1</i> is a stack-based buffer.
     * 
     * Consider using <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a> instead; use either 
     * 				<c>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</c>, 
     * 				being aware that <c>buffer</c> must not be a pointer or 
     * 				use <c>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</c>, 
     * 				being aware that, when copying to a pointer, the caller is responsible for 
     * 				passing in the size of the pointed-to memory in characters. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} lpString1 Type: <b>LPTSTR</b>
     * 
     * A buffer to receive the contents of the string pointed to by the 
     * 					<i>lpString2</i> parameter. 
     * 					The buffer must be large enough to contain the string, including the 
     * 					terminating null character.
     * @param {Pointer<PWSTR>} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be copied.
     * @returns {Pointer<PWSTR>} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcpyw
     * @since windows5.0
     */
    static lstrcpyW(lpString1, lpString2) {
        result := DllCall("KERNEL32.dll\lstrcpyW", "ptr", lpString1, "ptr", lpString2, "ptr")
        return result
    }

    /**
     * Appends one string to another.Warning  Do not use. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} lpString1 Type: <b>LPTSTR</b>
     * 
     * The first null-terminated string. This buffer must be large enough 
     * 				to contain both strings.
     * @param {Pointer<PSTR>} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be appended to the string 
     * 				specified in the <i>lpString1</i> parameter.
     * @returns {Pointer<PSTR>} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcata
     * @since windows5.0
     */
    static lstrcatA(lpString1, lpString2) {
        result := DllCall("KERNEL32.dll\lstrcatA", "ptr", lpString1, "ptr", lpString2, "ptr")
        return result
    }

    /**
     * Appends one string to another.Warning  Do not use. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} lpString1 Type: <b>LPTSTR</b>
     * 
     * The first null-terminated string. This buffer must be large enough 
     * 				to contain both strings.
     * @param {Pointer<PWSTR>} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be appended to the string 
     * 				specified in the <i>lpString1</i> parameter.
     * @returns {Pointer<PWSTR>} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcatw
     * @since windows5.0
     */
    static lstrcatW(lpString1, lpString2) {
        result := DllCall("KERNEL32.dll\lstrcatW", "ptr", lpString1, "ptr", lpString2, "ptr")
        return result
    }

    /**
     * Determines the length of the specified string (not including the terminating null character). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} lpString Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be checked.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrlena
     * @since windows5.0
     */
    static lstrlenA(lpString) {
        DllCall("KERNEL32.dll\lstrlenA", "ptr", lpString)
    }

    /**
     * Determines the length of the specified string (not including the terminating null character). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} lpString Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be checked.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrlenw
     * @since windows5.0
     */
    static lstrlenW(lpString) {
        DllCall("KERNEL32.dll\lstrlenW", "ptr", lpString)
    }

    /**
     * Determines if a buffer is likely to contain a form of Unicode text.
     * @remarks
     * This function uses various statistical and deterministic methods to make its determination, under the control of flags passed in the <i>lpiResult</i> parameter. When the function returns, the results of such tests are reported using the same parameter.
     * 
     * The IS_TEXT_UNICODE_STATISTICS and IS_TEXT_UNICODE_REVERSE_STATISTICS tests use statistical analysis. These tests are not foolproof. The statistical tests assume certain amounts of variation between low and high bytes in a string, and some ASCII strings can slip through. For example, if <i>lpv</i> indicates the ASCII string 0x41, 0x0A, 0x0D, 0x1D (A\n\r^Z), the string passes the IS_TEXT_UNICODE_STATISTICS test, although failure would be preferable.
     * @param {Pointer<Void>} lpv Pointer to the input buffer to examine.
     * @param {Integer} iSize Size, in bytes, of the input buffer indicated by <i>lpv</i>.
     * @param {Pointer<UInt32>} lpiResult On input, pointer to the tests to apply to the input buffer text. On output, this parameter receives the results of the specified tests: 1 if the contents of the buffer pass a test, 0 for failure. Only flags that are set upon input to the function are significant upon output.
     * 
     * If <i>lpiResult</i> is <b>NULL</b>, the function uses all available tests to determine if the data in the buffer is likely to be Unicode text.
     * @returns {Integer} Returns a nonzero value if the data in the buffer passes the specified tests. The function returns 0 if the data in the buffer does not pass the specified tests.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-istextunicode
     * @since windows5.0
     */
    static IsTextUnicode(lpv, iSize, lpiResult) {
        result := DllCall("ADVAPI32.dll\IsTextUnicode", "ptr", lpv, "int", iSize, "ptr", lpiResult, "int")
        return result
    }

;@endregion Methods
}
