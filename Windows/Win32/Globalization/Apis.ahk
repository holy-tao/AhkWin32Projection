#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\Win32Handle.ahk
#Include ..\..\..\Guid.ahk

/**
 * @namespace Windows.Win32.Globalization
 * @version v4.0.30319
 */
class Globalization {

;@region Constants

    /**
     * @type {Integer (Int32)}
     */
    static LANG_SYSTEM_DEFAULT => 2048

    /**
     * @type {Integer (Int32)}
     */
    static LANG_USER_DEFAULT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SYSTEM_DEFAULT => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_USER_DEFAULT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static ALL_SERVICE_TYPES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static HIGHLEVEL_SERVICE_TYPES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOWLEVEL_SERVICE_TYPES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALL_SERVICES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ONLINE_SERVICES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_SERVICES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LEADBYTES => 12

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DEFAULTCHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static HIGH_SURROGATE_START => 55296

    /**
     * @type {Integer (UInt32)}
     */
    static HIGH_SURROGATE_END => 56319

    /**
     * @type {Integer (UInt32)}
     */
    static LOW_SURROGATE_START => 56320

    /**
     * @type {Integer (UInt32)}
     */
    static LOW_SURROGATE_END => 57343

    /**
     * @type {Integer (UInt32)}
     */
    static WC_COMPOSITECHECK => 512

    /**
     * @type {Integer (UInt32)}
     */
    static WC_DISCARDNS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static WC_SEPCHARS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static WC_DEFAULTCHAR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static WC_ERR_INVALID_CHARS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static WC_NO_BEST_FIT_CHARS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE3 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C1_UPPER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C1_LOWER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C1_DIGIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C1_SPACE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C1_PUNCT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static C1_CNTRL => 32

    /**
     * @type {Integer (UInt32)}
     */
    static C1_BLANK => 64

    /**
     * @type {Integer (UInt32)}
     */
    static C1_XDIGIT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static C1_ALPHA => 256

    /**
     * @type {Integer (UInt32)}
     */
    static C1_DEFINED => 512

    /**
     * @type {Integer (UInt32)}
     */
    static C2_LEFTTORIGHT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C2_RIGHTTOLEFT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPENUMBER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPESEPARATOR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPETERMINATOR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static C2_ARABICNUMBER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static C2_COMMONSEPARATOR => 7

    /**
     * @type {Integer (UInt32)}
     */
    static C2_BLOCKSEPARATOR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C2_SEGMENTSEPARATOR => 9

    /**
     * @type {Integer (UInt32)}
     */
    static C2_WHITESPACE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static C2_OTHERNEUTRAL => 11

    /**
     * @type {Integer (UInt32)}
     */
    static C2_NOTAPPLICABLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static C3_NONSPACING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C3_DIACRITIC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C3_VOWELMARK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C3_SYMBOL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C3_KATAKANA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HIRAGANA => 32

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HALFWIDTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static C3_FULLWIDTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static C3_IDEOGRAPH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static C3_KASHIDA => 512

    /**
     * @type {Integer (UInt32)}
     */
    static C3_LEXICAL => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HIGHSURROGATE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static C3_LOWSURROGATE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static C3_ALPHA => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static C3_NOTAPPLICABLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_LOWERCASE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_UPPERCASE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_TITLECASE => 768

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SORTKEY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_BYTEREV => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HIRAGANA => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_KATAKANA => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HALFWIDTH => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_FULLWIDTH => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_LINGUISTIC_CASING => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SIMPLIFIED_CHINESE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_TRADITIONAL_CHINESE => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SORTHANDLE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HASH => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_STARTSWITH => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_ENDSWITH => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_FROMSTART => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_FROMEND => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static LCID_ALTERNATE_SORTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_WINDOWS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SUPPLEMENTAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALTERNATE_SORTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_REPLACEMENT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_NEUTRALDATA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPECIFICDATA => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CP_ACP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CP_OEMCP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CP_MACCP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CP_THREAD_ACP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CP_SYMBOL => 42

    /**
     * @type {Integer (UInt32)}
     */
    static CP_UTF7 => 65000

    /**
     * @type {Integer (UInt32)}
     */
    static CP_UTF8 => 65001

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ALBANIA => 355

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ALGERIA => 213

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ARGENTINA => 54

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ARMENIA => 374

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AUSTRALIA => 61

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AUSTRIA => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AZERBAIJAN => 994

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BAHRAIN => 973

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELARUS => 375

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELGIUM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELIZE => 501

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BOLIVIA => 591

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BRAZIL => 55

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BRUNEI_DARUSSALAM => 673

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BULGARIA => 359

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CANADA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CARIBBEAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CHILE => 56

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_COLOMBIA => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_COSTA_RICA => 506

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CROATIA => 385

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CZECH => 420

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DENMARK => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DOMINICAN_REPUBLIC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ECUADOR => 593

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_EGYPT => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_EL_SALVADOR => 503

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ESTONIA => 372

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FAEROE_ISLANDS => 298

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FINLAND => 358

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FRANCE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GEORGIA => 995

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GERMANY => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GREECE => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GUATEMALA => 502

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HONDURAS => 504

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HONG_KONG => 852

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HUNGARY => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ICELAND => 354

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_INDIA => 91

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_INDONESIA => 62

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRAN => 981

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRAQ => 964

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRELAND => 353

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ISRAEL => 972

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ITALY => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JAMAICA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JAPAN => 81

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JORDAN => 962

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KAZAKSTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KENYA => 254

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KUWAIT => 965

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KYRGYZSTAN => 996

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LATVIA => 371

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LEBANON => 961

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LIBYA => 218

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LIECHTENSTEIN => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LITHUANIA => 370

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LUXEMBOURG => 352

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MACAU => 853

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MACEDONIA => 389

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MALAYSIA => 60

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MALDIVES => 960

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MEXICO => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MONACO => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MONGOLIA => 976

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MOROCCO => 212

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NETHERLANDS => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NEW_ZEALAND => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NICARAGUA => 505

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NORWAY => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_OMAN => 968

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PAKISTAN => 92

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PANAMA => 507

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PARAGUAY => 595

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PERU => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PHILIPPINES => 63

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_POLAND => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PORTUGAL => 351

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PRCHINA => 86

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PUERTO_RICO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_QATAR => 974

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ROMANIA => 40

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_RUSSIA => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SAUDI_ARABIA => 966

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SERBIA => 381

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SINGAPORE => 65

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SLOVAK => 421

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SLOVENIA => 386

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SOUTH_AFRICA => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SOUTH_KOREA => 82

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SPAIN => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SWEDEN => 46

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SWITZERLAND => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SYRIA => 963

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TAIWAN => 886

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TATARSTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_THAILAND => 66

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TRINIDAD_Y_TOBAGO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TUNISIA => 216

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TURKEY => 90

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UAE => 971

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UKRAINE => 380

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UNITED_KINGDOM => 44

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UNITED_STATES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_URUGUAY => 598

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UZBEKISTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_VENEZUELA => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_VIET_NAM => 84

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_YEMEN => 967

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ZIMBABWE => 263

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_NOUSEROVERRIDE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_USE_CP_ACP => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_RETURN_NUMBER => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_RETURN_GENITIVE_NAMES => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALLOW_NEUTRAL_NAMES => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDDISPLAYNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHDISPLAYNAME => 114

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVEDISPLAYNAME => 115

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDLANGUAGENAME => 111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHLANGUAGENAME => 4097

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVELANGUAGENAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDCOUNTRYNAME => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHCOUNTRYNAME => 4098

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECOUNTRYNAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIALINGCODE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLIST => 12

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IMEASURE => 13

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDECIMAL => 14

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STHOUSAND => 15

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SGROUPING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIGITS => 17

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILZERO => 18

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGNUMBER => 4112

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVEDIGITS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCURRENCY => 20

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SINTLSYMBOL => 21

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONDECIMALSEP => 22

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHOUSANDSEP => 23

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONGROUPING => 24

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICURRDIGITS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICURRENCY => 27

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGCURR => 28

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTDATE => 31

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLONGDATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STIMEFORMAT => 4099

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SAM => 40

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPM => 41

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICALENDARTYPE => 4105

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IOPTIONALCALENDAR => 4107

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IFIRSTDAYOFWEEK => 4108

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IFIRSTWEEKOFYEAR => 4109

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME1 => 42

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME2 => 43

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME3 => 44

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME4 => 45

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME5 => 46

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME6 => 47

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME7 => 48

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME1 => 49

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME2 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME3 => 51

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME4 => 52

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME5 => 53

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME6 => 54

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME7 => 55

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME1 => 56

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME2 => 57

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME3 => 58

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME4 => 59

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME5 => 60

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME6 => 61

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME7 => 62

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME8 => 63

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME9 => 64

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME10 => 65

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME11 => 66

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME12 => 67

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME13 => 4110

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME1 => 68

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME2 => 69

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME3 => 70

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME4 => 71

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME5 => 72

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME6 => 73

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME7 => 74

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME8 => 75

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME9 => 76

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME10 => 77

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME11 => 78

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME12 => 79

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME13 => 4111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPOSITIVESIGN => 80

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNEGATIVESIGN => 81

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSIGNPOSN => 82

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSIGNPOSN => 83

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSYMPRECEDES => 84

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSEPBYSPACE => 85

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSYMPRECEDES => 86

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSEPBYSPACE => 87

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_FONTSIGNATURE => 88

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO639LANGNAME => 89

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO3166CTRYNAME => 90

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPAPERSIZE => 4106

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGCURRNAME => 4103

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECURRNAME => 4104

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SYEARMONTH => 4102

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSORTNAME => 4115

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIGITSUBSTITUTION => 4116

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNAME => 92

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDURATION => 93

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME1 => 96

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME2 => 97

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME3 => 98

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME4 => 99

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME5 => 100

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME6 => 101

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME7 => 102

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO639LANGNAME2 => 103

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO3166CTRYNAME2 => 104

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNAN => 105

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPOSINFINITY => 106

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNEGINFINITY => 107

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSCRIPTS => 108

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPARENT => 109

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCONSOLEFALLBACKNAME => 110

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IREADINGLAYOUT => 112

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEUTRAL => 113

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGATIVEPERCENT => 116

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSITIVEPERCENT => 117

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPERCENT => 118

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPERMILLE => 119

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHDAY => 120

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTTIME => 121

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SOPENTYPELANGUAGETAG => 122

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSORTLOCALE => 123

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SRELATIVELONGDATE => 124

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICONSTRUCTEDLOCALE => 125

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTAM => 126

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTPM => 127

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IUSEUTF8LEGACYACP => 1638

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IUSEUTF8LEGACYOEMCP => 2457

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTCODEPAGE => 11

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTANSICODEPAGE => 4100

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTMACCODEPAGE => 4113

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTEBCDICCODEPAGE => 4114

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILANGUAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVLANGNAME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVCTRYNAME => 7

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IGEOID => 91

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTLANGUAGE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTCOUNTRY => 10

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IINTLCURRDIGITS => 26

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDATE => 29

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STIME => 30

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDATE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILDATE => 34

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITIME => 35

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITIMEMARKPOSN => 4101

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICENTURY => 36

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITLZERO => 37

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDAYLZERO => 38

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IMONLZERO => 39

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SKEYBOARDSTOINSTALL => 94

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLANGUAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLANGDISPLAYNAME => 111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLANGUAGE => 4097

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVELANGNAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCOUNTRY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGCOUNTRY => 4098

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECTRYNAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICOUNTRY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_S1159 => 40

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_S2359 => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_NOUSEROVERRIDE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_USE_CP_ACP => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_RETURN_NUMBER => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_RETURN_GENITIVE_NAMES => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_ICALINTVALUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SCALNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_IYEAROFFSETRANGE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SERASTRING => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTDATE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SLONGDATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME1 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME2 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME3 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME4 => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME5 => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME6 => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME7 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME1 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME2 => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME3 => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME4 => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME5 => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME6 => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME7 => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME1 => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME2 => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME3 => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME4 => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME5 => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME6 => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME7 => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME8 => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME9 => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME10 => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME11 => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME12 => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME13 => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME1 => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME2 => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME3 => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME4 => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME5 => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME6 => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME7 => 40

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME8 => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME9 => 42

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME10 => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME11 => 44

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME12 => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME13 => 46

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SYEARMONTH => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_ITWODIGITYEARMAX => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME1 => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME2 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME3 => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME4 => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME5 => 53

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME6 => 54

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME7 => 55

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHDAY => 56

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVERASTRING => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SRELATIVELONGDATE => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SENGLISHERANAME => 59

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SENGLISHABBREVERANAME => 60

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SJAPANESEERAFIRSTYEAR => 61

    /**
     * @type {Integer (UInt32)}
     */
    static ENUM_ALL_CALENDARS => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_US => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_JAPAN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_TAIWAN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_KOREA => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_HIJRI => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_THAI => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_HEBREW => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_ME_FRENCH => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_ARABIC => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_XLIT_ENGLISH => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_XLIT_FRENCH => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_PERSIAN => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_UMALQURA => 23

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_WESTERN_EUROPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_CENTRAL_EUROPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_BALTIC => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_GREEK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_CYRILLIC => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TURKIC => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TURKISH => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_JAPANESE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_KOREAN => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TRADITIONAL_CHINESE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_SIMPLIFIED_CHINESE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_THAI => 11

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_HEBREW => 12

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_ARABIC => 13

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_VIETNAMESE => 14

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_INDIC => 15

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_GEORGIAN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_ARMENIAN => 17

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_NAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MERGE_SYSTEM_FALLBACK => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MERGE_USER_FALLBACK => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_THREAD_LANGUAGES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_CONSOLE_FILTER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_COMPLEX_SCRIPT_FILTER => 512

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_RESET_FILTERS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USER_PREFERRED_UI_LANGUAGES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USE_INSTALLED_LANGUAGES => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USE_SEARCH_ALL_LANGUAGES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANG_NEUTRAL_PE_FILE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_NON_LANG_NEUTRAL_FILE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MACHINE_LANGUAGE_SETTINGS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_CHECKSUM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_LANGUAGE_NAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_RESOURCE_TYPES => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILEINFO_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FULL_LANGUAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_PARTIAL_LANGUAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LIP_LANGUAGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_INSTALLED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_LICENSED => 64

    /**
     * @type {Integer (Int32)}
     */
    static GEOID_NOT_AVAILABLE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static SORTING_PARADIGM_NLS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SORTING_PARADIGM_ICU => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_ALLOW_UNASSIGNED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_USE_STD3_ASCII_RULES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_EMAIL_ADDRESS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_RAW_PUNYCODE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static VS_ALLOW_LATIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GSS_ALLOW_INHERITED_COMMON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FORMAT_REG_COMPAT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FORMAT_INF_COMPAT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_VERIFY_FILE_EXISTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_SKIP_STRING_CACHE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_IMMUTABLE_LOOKUP => 16

    /**
     * @type {String}
     */
    static LOCALE_NAME_INVARIANT => ""

    /**
     * @type {String}
     */
    static LOCALE_NAME_SYSTEM_DEFAULT => "!x-sys-default-locale"

    /**
     * @type {Integer (UInt32)}
     */
    static MIN_SPELLING_NTDDI => 100794368

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_UNDEFINED => 0

    /**
     * @type {Integer (Int32)}
     */
    static USP_E_SCRIPT_NOT_IN_FONT => -2147220992

    /**
     * @type {Integer (UInt32)}
     */
    static SGCM_RTL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_PASSWORD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_TAB => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_CLIP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_DZWG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FALLBACK => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_BREAK => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_GLYPHS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_RTL => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_GCP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HOTKEY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_METAFILE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LINK => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HIDEHOTKEY => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HOTKEYONLY => 9216

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FULLMEASURE => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LPKANSIFALLBACK => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_PIDX => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LAYOUTRTL => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_DONTGLYPH => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_NOKASHIDA => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_CONTEXT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_NONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_NATIONAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_TRADITIONAL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static UNISCRIBE_OPENTYPE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_TAG_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_EXACT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_CPINFO => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_MBTOWC => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_WCTOMB => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static U_DISABLE_RENAMING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHOW_CPLUSPLUS_API => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEFAULT_SHOW_DRAFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_DRAFT_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_DEPRECATED_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_OBSOLETE_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_INTERNAL_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_NO_DEFAULT_INCLUDE_UTF_HEADERS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEBUG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCLN_NO_AUTO_CLEANUP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_OVERRIDE_CXX_ALLOCATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_ENABLE_TRACING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ENABLE_PLUGINS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_ENABLE_DYLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHECK_DYLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_LIB_SUFFIX => 1

    /**
     * @type {String}
     */
    static U_LIB_SUFFIX_C_NAME_STRING => ""

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ONLY_COLLATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_BREAK_ITERATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_IDNA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FORMATTING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_TRANSLITERATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_REGULAR_EXPRESSIONS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FILE_IO => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_CONVERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_LEGACY_CONVERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ONLY_HTML_CONVERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_NORMALIZATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_COLLATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_SERVICE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_HAVE_PARSEALLINPUT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FILTERED_BREAK_ITERATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_WINDOWS => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_MINGW => 1800

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_CYGWIN => 1900

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_HPUX => 2100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_SOLARIS => 2600

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_BSD => 3000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_AIX => 3100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_IRIX => 3200

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_DARWIN => 3500

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_IPHONE => 3550

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_QNX => 3700

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_LINUX => 4000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_BROWSER_NATIVE_CLIENT => 4020

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_ANDROID => 4050

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_FUCHSIA => 4100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_EMSCRIPTEN => 5010

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_OS390 => 9000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_OS400 => 9400

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM => 1800

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_USES_ONLY_WIN32_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_HAS_WIN32_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IMPLEMENTS_POSIX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IS_LINUX_BASED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IS_DARWIN_BASED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_STDINT_H => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_INTTYPES_H => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_GCC_MAJOR_MINOR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_IS_BIG_ENDIAN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_PLACEMENT_NEW => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_DEBUG_LOCATION_NEW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CPLUSPLUS_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_ASCII_FAMILY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_EBCDIC_FAMILY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHARSET_FAMILY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHARSET_IS_UTF8 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_WCHAR_H => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SIZEOF_WCHAR_T => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_WCSCPY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_CHAR16_T => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEFINE_FALSE_AND_TRUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SIZEOF_UCHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHAR16_IS_TYPEDEF => 1

    /**
     * @type {Integer (Int32)}
     */
    static U_SENTINEL => -1

    /**
     * @type {String}
     */
    static U8_LEAD3_T1_BITS => " 000000000000" Chr(16) "00"

    /**
     * @type {String}
     */
    static U8_LEAD4_T1_BITS => "" Chr(0) "" Chr(0) "" Chr(0) "" Chr(0) "" Chr(0) "" Chr(0) "" Chr(0) "" Chr(0) "" Chr(30) "" Chr(15) "" Chr(15) "" Chr(15) "" Chr(0) "" Chr(0) "" Chr(0) "" Chr(0) ""

    /**
     * @type {Integer (UInt32)}
     */
    static U8_MAX_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U16_MAX_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_OBSOLETE_UTF_OLD_H => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_SIZE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_ERROR_VALUE_1 => 21

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_ERROR_VALUE_2 => 159

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_ERROR_VALUE => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_MAX_CHAR_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static UTF16_MAX_CHAR_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static UTF32_MAX_CHAR_LENGTH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_MAX_CHAR_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_COPYRIGHT_STRING_LENGTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static U_MAX_VERSION_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_MAX_VERSION_STRING_LENGTH => 20

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_SECOND => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_MINUTE => 60000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_HOUR => 3600000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_DAY => 86400000

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMBINED_IMPLEMENTATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_GROW_SHRINK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_RESIZE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_NEAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_NEAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_AT_END => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_END => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_AT_BEGINNING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_BEGIN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_AUTO => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_MASK => 65539

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_MASK => 65539

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_LOGICAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_VISUAL_RTL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_VISUAL_LTR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_MASK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_SHAPE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_UNSHAPE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_SHAPE_TASHKEEL_ISOLATED => 24

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_MASK => 24

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_EN2AN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_AN2EN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_ALEN2AN_INIT_LR => 96

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_ALEN2AN_INIT_AL => 128

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_RESERVED => 160

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_MASK => 224

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_AN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_AN_EXTENDED => 256

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_RESERVED => 512

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_MASK => 768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL_MASK => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION_MASK => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SEEN_TWOCELL_NEAR => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SEEN_MASK => 7340032

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_YEHHAMZA_TWOCELL_NEAR => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_YEHHAMZA_MASK => 58720256

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_BEGIN => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_END => 393216

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_RESIZE => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_REPLACE_BY_TATWEEL => 786432

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_MASK => 917504

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SPACES_RELATIVE_TO_TEXT_BEGIN_END => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SPACES_RELATIVE_TO_TEXT_MASK => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TAIL_NEW_UNICODE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TAIL_TYPE_MASK => 134217728

    /**
     * @type {String}
     */
    static ULOC_CHINESE => "zh"

    /**
     * @type {String}
     */
    static ULOC_ENGLISH => "en"

    /**
     * @type {String}
     */
    static ULOC_FRENCH => "fr"

    /**
     * @type {String}
     */
    static ULOC_GERMAN => "de"

    /**
     * @type {String}
     */
    static ULOC_ITALIAN => "it"

    /**
     * @type {String}
     */
    static ULOC_JAPANESE => "ja"

    /**
     * @type {String}
     */
    static ULOC_KOREAN => "ko"

    /**
     * @type {String}
     */
    static ULOC_SIMPLIFIED_CHINESE => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_TRADITIONAL_CHINESE => "zh_TW"

    /**
     * @type {String}
     */
    static ULOC_CANADA => "en_CA"

    /**
     * @type {String}
     */
    static ULOC_CANADA_FRENCH => "fr_CA"

    /**
     * @type {String}
     */
    static ULOC_CHINA => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_PRC => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_FRANCE => "fr_FR"

    /**
     * @type {String}
     */
    static ULOC_GERMANY => "de_DE"

    /**
     * @type {String}
     */
    static ULOC_ITALY => "it_IT"

    /**
     * @type {String}
     */
    static ULOC_JAPAN => "ja_JP"

    /**
     * @type {String}
     */
    static ULOC_KOREA => "ko_KR"

    /**
     * @type {String}
     */
    static ULOC_TAIWAN => "zh_TW"

    /**
     * @type {String}
     */
    static ULOC_UK => "en_GB"

    /**
     * @type {String}
     */
    static ULOC_US => "en_US"

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_LANG_CAPACITY => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_COUNTRY_CAPACITY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_FULLNAME_CAPACITY => 157

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_SCRIPT_CAPACITY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORDS_CAPACITY => 96

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_AND_VALUES_CAPACITY => 100

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_SEPARATOR_UNICODE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_ASSIGN_UNICODE => 61

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE => 59

    /**
     * @type {String}
     */
    static UCNV_SUB_STOP_ON_ILLEGAL => "i"

    /**
     * @type {String}
     */
    static UCNV_SKIP_STOP_ON_ILLEGAL => "i"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_JAVA => "J"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_C => "C"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_XML_DEC => "D"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_XML_HEX => "X"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_UNICODE => "U"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_CSS2 => "S"

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_MAX_CONVERTER_NAME_LENGTH => 60

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_SI => 15

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_SO => 14

    /**
     * @type {String}
     */
    static UCNV_OPTION_SEP_STRING => ","

    /**
     * @type {String}
     */
    static UCNV_VALUE_SEP_STRING => "="

    /**
     * @type {String}
     */
    static UCNV_LOCALE_OPTION_STRING => ",locale="

    /**
     * @type {String}
     */
    static UCNV_VERSION_OPTION_STRING => ",version="

    /**
     * @type {String}
     */
    static UCNV_SWAP_LFNL_OPTION_STRING => ",swaplfnl"

    /**
     * @type {Integer (UInt32)}
     */
    static U_FOLD_CASE_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_FOLD_CASE_EXCLUDE_SPECIAL_I => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_WHOLE_STRING => 32

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_SENTENCES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_NO_LOWERCASE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_NO_BREAK_ADJUSTMENT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_ADJUST_TO_CASED => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static U_EDITS_NO_RESET => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static U_OMIT_UNCHANGED_TEXT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMPARE_CODE_POINT_ORDER => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMPARE_IGNORE_CASE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static UNORM_INPUT_IS_FCD => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static UCHAR_MIN_VALUE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCHAR_MAX_VALUE => 1114111

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DEFAULT_LTR => 254

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DEFAULT_RTL => 255

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_MAX_EXPLICIT_LEVEL => 125

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_LEVEL_OVERRIDE => 128

    /**
     * @type {Integer (Int32)}
     */
    static UBIDI_MAP_NOWHERE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_KEEP_BASE_COMBINING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DO_MIRRORING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_INSERT_LRM_FOR_NUMERIC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_REMOVE_BIDI_CONTROLS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_OUTPUT_REVERSE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static USPREP_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static USPREP_ALLOW_UNASSIGNED => 1

    /**
     * @type {String}
     */
    static U_ICU_VERSION_BUNDLE => "icuver"

    /**
     * @type {String}
     */
    static U_ICU_DATA_KEY => "DataVersion"

    /**
     * @type {String}
     */
    static UCAL_UNKNOWN_ZONE_ID => "Etc/Unknown"

    /**
     * @type {String}
     */
    static UDAT_YEAR => "y"

    /**
     * @type {String}
     */
    static UDAT_QUARTER => "QQQQ"

    /**
     * @type {String}
     */
    static UDAT_ABBR_QUARTER => "QQQ"

    /**
     * @type {String}
     */
    static UDAT_YEAR_QUARTER => "yQQQQ"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_QUARTER => "yQQQ"

    /**
     * @type {String}
     */
    static UDAT_MONTH => "MMMM"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH => "MMM"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH => "M"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH => "yMMMM"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH => "yMMM"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH => "yM"

    /**
     * @type {String}
     */
    static UDAT_DAY => "d"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH_DAY => "yMMMMd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH_DAY => "yMMMd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH_DAY => "yMd"

    /**
     * @type {String}
     */
    static UDAT_WEEKDAY => "EEEE"

    /**
     * @type {String}
     */
    static UDAT_ABBR_WEEKDAY => "E"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH_WEEKDAY_DAY => "yMMMMEEEEd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH_WEEKDAY_DAY => "yMMMEd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH_WEEKDAY_DAY => "yMEd"

    /**
     * @type {String}
     */
    static UDAT_MONTH_DAY => "MMMMd"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH_DAY => "MMMd"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH_DAY => "Md"

    /**
     * @type {String}
     */
    static UDAT_MONTH_WEEKDAY_DAY => "MMMMEEEEd"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH_WEEKDAY_DAY => "MMMEd"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH_WEEKDAY_DAY => "MEd"

    /**
     * @type {String}
     */
    static UDAT_HOUR => "j"

    /**
     * @type {String}
     */
    static UDAT_HOUR24 => "H"

    /**
     * @type {String}
     */
    static UDAT_MINUTE => "m"

    /**
     * @type {String}
     */
    static UDAT_HOUR_MINUTE => "jm"

    /**
     * @type {String}
     */
    static UDAT_HOUR24_MINUTE => "Hm"

    /**
     * @type {String}
     */
    static UDAT_SECOND => "s"

    /**
     * @type {String}
     */
    static UDAT_HOUR_MINUTE_SECOND => "jms"

    /**
     * @type {String}
     */
    static UDAT_HOUR24_MINUTE_SECOND => "Hms"

    /**
     * @type {String}
     */
    static UDAT_MINUTE_SECOND => "ms"

    /**
     * @type {String}
     */
    static UDAT_LOCATION_TZ => "VVVV"

    /**
     * @type {String}
     */
    static UDAT_GENERIC_TZ => "vvvv"

    /**
     * @type {String}
     */
    static UDAT_ABBR_GENERIC_TZ => "v"

    /**
     * @type {String}
     */
    static UDAT_SPECIFIC_TZ => "zzzz"

    /**
     * @type {String}
     */
    static UDAT_ABBR_SPECIFIC_TZ => "z"

    /**
     * @type {String}
     */
    static UDAT_ABBR_UTC_TZ => "ZZZZ"

    /**
     * @type {Integer (Int32)}
     */
    static USEARCH_DONE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_STD_STRING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_FORMAT_FASTPATHS_49 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_HAS_WINUWP_API => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_IOSTREAM_SOURCE => 199711

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_RVALUE_REFERENCES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_USING_ICU_NAMESPACE => 1

    /**
     * @type {String}
     */
    static U_ICUDATA_TYPE_LETTER => "e"

    /**
     * @type {String}
     */
    static U_UNICODE_VERSION => "8.0"

    /**
     * @type {Integer (UInt32)}
     */
    static CANITER_SKIP_ZEROES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NUMSYS_NAME_CAPACITY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_RBNF => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMECP_NAME => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMECSET_NAME => 50

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMEFACE_NAME => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_RFC1766_NAME => 6

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LOCALE_NAME => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SCRIPT_NAME => 48

    /**
     * @type {Integer (Int32)}
     */
    static CPIOD_PEEK => 1073741824

    /**
     * @type {Integer (Int32)}
     */
    static CPIOD_FORCE_PROMPT => -2147483648

    /**
     * @type {Integer (Int32)}
     */
    static UITER_UNKNOWN_INDEX => -2

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_SHIFT => 6

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_DATA_BLOCK_LENGTH => 64

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_DATA_MASK => 63

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_SMALL_MAX => 4095

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET => 1

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET => 2

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE => 1

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_STABLE_CHUNKS => 2

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_WRITABLE => 3

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_HAS_META_DATA => 4

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_OWNS_TEXT => 5

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_MAGIC => 878368812

    /**
     * @type {Integer (Int32)}
     */
    static USET_IGNORE_SPACE => 1

    /**
     * @type {Integer (Int32)}
     */
    static USET_CASE_INSENSITIVE => 2

    /**
     * @type {Integer (Int32)}
     */
    static USET_ADD_CASE_MAPPINGS => 4

    /**
     * @type {Integer (Int32)}
     */
    static USET_SERIALIZED_STATIC_ARRAY_CAPACITY => 8

    /**
     * @type {Integer (Int32)}
     */
    static U_PARSE_CONTEXT_LEN => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_DEFAULT => 0

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_USE_STD3_RULES => 2

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_BIDI => 4

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_CONTEXTJ => 8

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_NONTRANSITIONAL_TO_ASCII => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_NONTRANSITIONAL_TO_UNICODE => 32

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_CONTEXTO => 64

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_EMPTY_LABEL => 1

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LABEL_TOO_LONG => 2

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_DOMAIN_NAME_TOO_LONG => 4

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LEADING_HYPHEN => 8

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_TRAILING_HYPHEN => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_HYPHEN_3_4 => 32

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LEADING_COMBINING_MARK => 64

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_DISALLOWED => 128

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_PUNYCODE => 256

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LABEL_HAS_DOT => 512

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_INVALID_ACE_LABEL => 1024

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_BIDI => 2048

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTJ => 4096

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTO_PUNCTUATION => 8192

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTO_DIGITS => 16384

    /**
     * @type {Guid}
     */
    static ELS_GUID_LANGUAGE_DETECTION => Guid("{cf7e00b1-909b-4d95-a8f4-611f7c377702}")

    /**
     * @type {Guid}
     */
    static ELS_GUID_SCRIPT_DETECTION => Guid("{2d64b439-6caf-4f6b-b688-e5d0f4faa7d7}")

    /**
     * @type {Guid}
     */
    static ELS_GUID_TRANSLITERATION_HANT_TO_HANS => Guid("{a3a8333b-f4fc-42f6-a0c4-0462fe7317cb}")

    /**
     * @type {Guid}
     */
    static ELS_GUID_TRANSLITERATION_HANS_TO_HANT => Guid("{3caccdc8-5590-42dc-9a7b-b5a6b5b3b63b}")

    /**
     * @type {Guid}
     */
    static ELS_GUID_TRANSLITERATION_MALAYALAM_TO_LATIN => Guid("{d8b983b1-f8bf-4a2b-bcd5-5b5ea20613e1}")

    /**
     * @type {Guid}
     */
    static ELS_GUID_TRANSLITERATION_DEVANAGARI_TO_LATIN => Guid("{c4a4dcfe-2661-4d02-9835-f48187109803}")

    /**
     * @type {Guid}
     */
    static ELS_GUID_TRANSLITERATION_CYRILLIC_TO_LATIN => Guid("{3dd12a98-5afd-4903-a13f-e17e6c0bfe01}")

    /**
     * @type {Guid}
     */
    static ELS_GUID_TRANSLITERATION_BENGALI_TO_LATIN => Guid("{f4dfd825-91a4-489f-855e-9ad9bee55727}")

    /**
     * @type {Guid}
     */
    static ELS_GUID_TRANSLITERATION_HANGUL_DECOMPOSITION => Guid("{4ba2a721-e43d-41b7-b330-536ae1e48863}")

    /**
     * @type {Integer (Int32)}
     */
    static UMSGPAT_ARG_NAME_NOT_NUMBER => -1

    /**
     * @type {Integer (Int32)}
     */
    static UMSGPAT_ARG_NAME_NOT_VALID => -2
;@endregion Constants

;@region Methods
    /**
     * Retrieves a character set identifier for the font that is currently selected into a specified device context.
     * @param {HDC} hdc Handle to a device context. The function obtains a character set identifier for the font that is selected into this device context.
     * @returns {Integer} If successful, returns a value identifying the character set of the font that is currently selected into the specified device context. The following character set identifiers are defined:
     * 
     * If the function fails, it returns DEFAULT_CHARSET.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-gettextcharset
     * @since windows5.0
     */
    static GetTextCharset(hdc) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("GDI32.dll\GetTextCharset", "ptr", hdc, "int")
        return result
    }

    /**
     * Retrieves information about the character set of the font that is currently selected into a specified device context.
     * @param {HDC} hdc Handle to a device context. The function obtains information about the font that is selected into this device context.
     * @param {Pointer<FONTSIGNATURE>} lpSig Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> data structure that receives font-signature information.
     * 
     * If a TrueType font is currently selected into the device context, the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure receives information that identifies the code page and Unicode subranges for which the font provides glyphs.
     * 
     * If a font other than TrueType is currently selected into the device context, the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure receives zeros. In this case, the application should use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-translatecharsetinfo">TranslateCharsetInfo</a> function to obtain generic font-signature information for the character set.
     * 
     * The <i>lpSig</i> parameter specifies <b>NULL</b> if the application does not require the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> information. In this case, the application can also call the       <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gettextcharset">GetTextCharset</a> function, which is equivalent to calling       <b>GetTextCharsetInfo</b> with <i>lpSig</i> set to <b>NULL</b>.
     * @param {Integer} dwFlags Reserved; must be set to 0.
     * @returns {Integer} If successful, returns a value identifying the character set of the font currently selected into the specified device context. The following character set identifiers are defined:
     * 
     * If the function fails, the return value is DEFAULT_CHARSET.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-gettextcharsetinfo
     * @since windows5.0
     */
    static GetTextCharsetInfo(hdc, lpSig, dwFlags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("GDI32.dll\GetTextCharsetInfo", "ptr", hdc, "ptr", lpSig, "uint", dwFlags, "int")
        return result
    }

    /**
     * Translates character set information and sets all members of a destination structure to appropriate values.
     * @param {Pointer<Integer>} lpSrc Pointer to the <b>fsCsb</b> member of a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure if <i>dwFlags</i> is set to TCI_SRCFONTSIG. Otherwise, this parameter is set to a DWORD value indicating the source.
     * @param {Pointer<CHARSETINFO>} lpCs Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-charsetinfo">CHARSETINFO</a> structure that receives the translated character set information.
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-translatecharsetinfo
     * @since windows5.0
     */
    static TranslateCharsetInfo(lpSrc, lpCs, dwFlags) {
        lpSrcMarshal := lpSrc is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("GDI32.dll\TranslateCharsetInfo", lpSrcMarshal, lpSrc, "ptr", lpCs, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a date as a date string for a locale specified by the locale identifier. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark ("?"). 
     *       
     * 
     * <b>Starting with Windows8: </b><b>GetDateFormat</b>  is declared in Datetimeapi.h. Before Windows8, it was declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The datetimeapi.h header defines GetDateFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale this function formats the date string for. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying date format options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application sets this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {PSTR} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {PSTR} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @returns {Integer} Returns the number of characters written to the <i>lpDateStr</i> buffer if successful. If the <i>cchDate</i> parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-getdateformata
     * @since windows5.0
     */
    static GetDateFormatA(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDateStr := lpDateStr is String ? StrPtr(lpDateStr) : lpDateStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDateFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a date as a date string for a locale specified by the locale identifier. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark ("?"). 
     *       
     * 
     * <b>Starting with Windows8: </b><b>GetDateFormat</b>  is declared in Datetimeapi.h. Before Windows8, it was declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The datetimeapi.h header defines GetDateFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale this function formats the date string for. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying date format options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application sets this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {PWSTR} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {PWSTR} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @returns {Integer} Returns the number of characters written to the <i>lpDateStr</i> buffer if successful. If the <i>cchDate</i> parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-getdateformatw
     * @since windows5.0
     */
    static GetDateFormatW(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDateStr := lpDateStr is String ? StrPtr(lpDateStr) : lpDateStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDateFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats time as a time string for a locale specified by identifier. The function formats either a specified time or the local system time. (ANSI)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * <b>Starting with Windows8: </b><b>GetTimeFormat</b>  is declared in Datetimeapi.h. Before Windows8, it was declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The datetimeapi.h header defines GetTimeFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying time format options. For detailed definitions see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {PSTR} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {PSTR} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in TCHAR values, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {Integer} Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpTimeStr</i>. If the <i>cchTime</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-gettimeformata
     * @since windows5.0
     */
    static GetTimeFormatA(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpTimeStr := lpTimeStr is String ? StrPtr(lpTimeStr) : lpTimeStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTimeFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats time as a time string for a locale specified by identifier. The function formats either a specified time or the local system time. (Unicode)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * <b>Starting with Windows8: </b><b>GetTimeFormat</b>  is declared in Datetimeapi.h. Before Windows8, it was declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The datetimeapi.h header defines GetTimeFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying time format options. For detailed definitions see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {PWSTR} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {PWSTR} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in TCHAR values, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {Integer} Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpTimeStr</i>. If the <i>cchTime</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-gettimeformatw
     * @since windows5.0
     */
    static GetTimeFormatW(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpTimeStr := lpTimeStr is String ? StrPtr(lpTimeStr) : lpTimeStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTimeFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats time as a time string for a locale specified by name.
     * @remarks
     * If a time marker exists and the TIME_NOTIMEMARKER flag is not set, the function localizes the time marker based on the specified locale identifier. Examples of time markers are "AM" and "PM" for English (United States).
     * 
     * The time values in the structure indicated by <i>lpTime</i> must be valid. The function checks each of the time values to determine that it is within the appropriate range of values. If any of the time values are outside the correct range, the function fails, and sets the last error to ERROR_INVALID_PARAMETER.
     * 
     * The function ignores the date members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure. These include: <b>wYear</b>, <b>wMonth</b>, <b>wDayOfWeek</b>, and <b>wDay</b>.
     * 
     * If TIME_NOMINUTESORSECONDS or TIME_NOSECONDS is specified, the function removes the separators following the minutes and/or seconds members.
     * 
     * If TIME_NOTIMEMARKER is specified, the function removes the separators preceding and following the time marker.
     * 
     * If TIME_FORCE24HOURFORMAT is specified, the function displays any existing time marker, unless the TIME_NOTIMEMARKER flag is also set.
     * 
     * The function does not include milliseconds as part of the formatted time string.
     * 
     * The function returns no errors for a bad format string, but just forms the best possible time string. If more than two hour, minute, second, or time marker format pictures are passed in, the function defaults to two. For example, the only time marker pictures that are valid are "t" and "tt". If "ttt" is passed in, the function assumes "tt".
     * 
     * To obtain the time format without performing any actual formatting, the application should use the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> function, specifying <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIMEFORMAT</a>.
     * 
     * The application can use the following elements to construct a format picture string. If spaces are used to separate the elements in the format string, these spaces appear in the same location in the output string. The letters must be in uppercase or lowercase as shown, for example, "ss", not "SS". Characters in the format string that are enclosed in single quotation marks appear in the same location and unchanged in the output string.
     * 
     * <table>
     * <tr>
     * <th>Picture</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>h</td>
     * <td>Hours with no leading zero for single-digit hours; 12-hour clock</td>
     * </tr>
     * <tr>
     * <td>hh</td>
     * <td>Hours with leading zero for single-digit hours; 12-hour clock</td>
     * </tr>
     * <tr>
     * <td>H</td>
     * <td>Hours with no leading zero for single-digit hours; 24-hour clock</td>
     * </tr>
     * <tr>
     * <td>HH</td>
     * <td>Hours with leading zero for single-digit hours; 24-hour clock</td>
     * </tr>
     * <tr>
     * <td>m</td>
     * <td>Minutes with no leading zero for single-digit minutes</td>
     * </tr>
     * <tr>
     * <td>mm</td>
     * <td>Minutes with leading zero for single-digit minutes</td>
     * </tr>
     * <tr>
     * <td>s</td>
     * <td>Seconds with no leading zero for single-digit seconds</td>
     * </tr>
     * <tr>
     * <td>ss</td>
     * <td>Seconds with leading zero for single-digit seconds</td>
     * </tr>
     * <tr>
     * <td>t</td>
     * <td>One character time marker string, such as A or P</td>
     * </tr>
     * <tr>
     * <td>tt</td>
     * <td>Multi-character time marker string, such as AM or PM</td>
     * </tr>
     * </table>
     * 
     * 
     * For example, to get the time string
     * 
     * 
     * ``` syntax
     * "11:29:40 PM"
     * ```
     * 
     * the application should use the picture string
     * 
     * 
     * ``` syntax
     * "hh':'mm':'ss tt"
     * ```
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * 
     * <b>Beginning in Windows8: </b><b>GetTimeFormatEx</b>  is declared in Datetimeapi.h. Before Windows8, it was declared in Winnls.h.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {PWSTR} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {PWSTR} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in characters, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpTimeStr</i>. If the <i>cchTime</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-gettimeformatex
     * @since windows6.0.6000
     */
    static GetTimeFormatEx(lpLocaleName, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpTimeStr := lpTimeStr is String ? StrPtr(lpTimeStr) : lpTimeStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTimeFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a date as a date string for a locale specified by name.
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * The earliest date supported by this function is January 1, 1601.
     * 
     * The day name, abbreviated day name, month name, and abbreviated month name are all localized based on the locale identifier.
     * 
     * The date values in the structure indicated by <i>lpDate</i> must be valid. The function checks each of the date values: year, month, day, and day of week. If the day of the week is incorrect, the function uses the correct value, and returns no error. If any of the other date values are outside the correct range, the function fails, and sets the last error to ERROR_INVALID_PARAMETER.
     * 
     * The function ignores the time members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure indicated by <i>lpDate</i>. These include <b>wHour</b>, <b>wMinute</b>, <b>wSecond</b>, and <b>wMilliseconds</b>.
     * 
     * If the <i>lpFormat</i> parameter contains a bad format string, the function returns no errors, but just forms the best possible date string. For example, the only year pictures that are valid are L"yyyy" and L"yy", where the "L" indicates a Unicode (16-bit characters) string. If L"y" is passed in, the function assumes L"yy". If L"yyy" is passed in, the function assumes L"yyyy". If more than four date (L"dddd") or four month (L"MMMM") pictures are passed in, the function defaults to L"dddd" or L"MMMM".
     * 
     * The application should enclose any text that should remain in its exact form in the date string within single quotation marks in the date format picture. The single quotation mark can also be used as an escape character to allow the single quotation mark itself to be displayed in the date string. However, the escape sequence must be enclosed within two single quotation marks. For example, to display the date as "May '93", the format string is: L"MMMM ''''yy". The first and last single quotation marks are the enclosing quotation marks. The second and third single quotation marks are the escape sequence to allow the single quotation mark to be displayed before the century.
     * 
     * When the date picture contains both a numeric form of the day (either d or dd) and the full month name (MMMM), the genitive form of the month name is retrieved in the date string.
     * 
     * To obtain the default short and long date format without performing any actual formatting, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> with the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sshortdate">LOCALE_SSHORTDATE</a> or <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-slongdate">LOCALE_SLONGDATE</a> constant. To get the date format for an alternate calendar, the application uses <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> with the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ioptionalcalendar">LOCALE_IOPTIONALCALENDAR</a> constant. To get the date format for a particular calendar, the application uses <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcalendarinfoex">GetCalendarInfoEx</a>, passing the appropriate <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar Identifier</a>. It can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a> to retrieve date formats for a particular calendar.
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * The DATE_LONGDATE format includes two kinds of date patterns: patterns that include the day of the week and patterns that do not include the day of the week. For example, "Tuesday, October 18, 2016" or "October 18, 2016".  If your application needs to ensure that dates use one of these kinds of patterns and not the other kind, your application should perform the following actions:<ol>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a> function to get all of the date formats for the DATE_LONGDATE format.</li>
     * <li>Look for the first date format passed to the callback function that you specified for  <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a> that matches your requested calendar identifier and has a date format string that matches the requirements of your application. For example, look for the first date format that includes "dddd" if your application requires that the date include the full name of the day of the week, or look for the first date format that includes neither "ddd" nor "dddd" if your application requires that the date includes nether the abbreviated name nor the full name of the day of the week.</li>
     * <li>Call the <b>GetDateFormatEx</b> function with the  <i>lpFormat</i> parameter set to the date format string that you identified as the appropriate format in the callback function.</li>
     * </ol>
     * 
     * 
     * If the presence or absence of the day of the week in the long date format does not matter to your application, your application can call <b>GetDateFormatEx</b> directly without first enumerating all of the long date formats by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * 
     * <b>Beginning in Windows8: </b><b>GetDateFormatEx</b>  is declared in Datetimeapi.h. Before Windows8, it was declared in Winnls.h.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {PWSTR} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * For example, to get the date string "Wed, Aug 31 94", the application uses the picture string "ddd',' MMM dd yy".
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {PWSTR} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @param {PWSTR} lpCalendar Reserved; must set to <b>NULL</b>.
     * @returns {Integer} Returns the number of characters written to the <i>lpDateStr</i> buffer if successful. If the <i>cchDate</i> parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/datetimeapi/nf-datetimeapi-getdateformatex
     * @since windows6.0.6000
     */
    static GetDateFormatEx(lpLocaleName, dwFlags, lpDate, lpFormat, lpDateStr, cchDate, lpCalendar) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDateStr := lpDateStr is String ? StrPtr(lpDateStr) : lpDateStr
        lpCalendar := lpCalendar is String ? StrPtr(lpCalendar) : lpCalendar

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDateFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "ptr", lpCalendar, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a duration of time as a time string for a locale specified by name.
     * @remarks
     * This function can be used with multimedia applications that display file time and sporting event applications that display finish times.
     * 
     * The function ignores the first three members of the [SYSTEMTIME](https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-systemtime) structure: **wYear**, **wMonth**, and **wDayOfWeek**.
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * The following are characteristics of duration format strings:
     * 
     * <ul>
     * <li>
     * Formatting characters are lowercase.
     * 
     * <div class="alert"><b>Note</b>An exception is made for (H) to be consistent with <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.</div>
     * <div></div>
     * </li>
     * <li>Two-digit format strings for hours, minutes, and seconds prepend a leading zero if the value is less than 10.</li>
     * <li>The first output field is not subject to any bounds testing (hours&lt;24, minutes&lt;60, seconds&lt;60, milliseconds&lt;1000). Days are not subject to bounds testing.</li>
     * <li>The function assumes that all format strings are in decreasing field size, for example, hours, minutes, seconds, milliseconds.</li>
     * <li>The first field to be displayed is normalized, as defined by the format string. For example, if the application specifies 310 seconds and the format string is m:ss, the output is 5:10. However, if the format string specifies minutes and seconds but the application specifies hours, the minutes field is adjusted accordingly.</li>
     * <li>If fractions are not the first field, the number of "f" characters in the format string indicates the number of decimals to show (limit of 9). If fractions are the first field, the number of "f" characters indicates the number of significant digits below one second.</li>
     * <li>Round-off occurs by truncation, not by the rule of five rounds up and four rounds down.</li>
     * <li>Single quotes are used to escape characters.</li>
     * </ul>
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * 
     * <b>Examples</b>
     * 
     * Following are examples of duration formats and corresponding outputs for specified time durations.
     * 
     * <b>SYSTEMTIME = 14 days, 2 hours, 45 minutes, 12 seconds, and 247 milliseconds</b>
     * 
     * <table>
     * <tr>
     * <th>Format</th>
     * <th>Output</th>
     * </tr>
     * <tr>
     * <td>d:hh:mm:ss</td>
     * <td>14:02:45:12</td>
     * </tr>
     * <tr>
     * <td>hh:mm:ss:ff</td>
     * <td>338:45:12:24</td>
     * </tr>
     * <tr>
     * <td>hh:mm:ss:fff</td>
     * <td>338:45:12:247</td>
     * </tr>
     * <tr>
     * <td>h' h 'mm' m 'ss' s'</td>
     * <td>338 h 45 m 12 s</td>
     * </tr>
     * </table>
     * 
     * 
     * <b>SYSTEMTIME = 345 seconds</b>
     * 
     * <table>
     * <tr>
     * <th>Format</th>
     * <th>Output</th>
     * </tr>
     * <tr>
     * <td>hh:mm:ss</td>
     * <td>00:05:45</td>
     * </tr>
     * <tr>
     * <td>h:mm:ss</td>
     * <td>0:05:45</td>
     * </tr>
     * <tr>
     * <td>mm:ss</td>
     * <td>05:45</td>
     * </tr>
     * <tr>
     * <td>m:ss</td>
     * <td>5:45</td>
     * </tr>
     * <tr>
     * <td>mm' m 'ss' s'</td>
     * <td>05 m 45 s</td>
     * </tr>
     * <tr>
     * <td>ss</td>
     * <td>345</td>
     * </tr>
     * <tr>
     * <td>ss' seconds'</td>
     * <td>345 seconds</td>
     * </tr>
     * </table>
     * 
     * 
     * <b>uulDuration = 51234567 (5.1234567 seconds)</b>
     * 
     * <table>
     * <tr>
     * <th>Format</th>
     * <th>Output</th>
     * </tr>
     * <tr>
     * <td>s.fff</td>
     * <td>5.123</td>
     * </tr>
     * <tr>
     * <td>s.ffffff</td>
     * <td>5.123456</td>
     * </tr>
     * <tr>
     * <td>s.fffffffff</td>
     * <td>5.123456700 (add trailing zeros)</td>
     * </tr>
     * <tr>
     * <td>fff 'ms'</td>
     * <td>5123 ms</td>
     * </tr>
     * <tr>
     * <td>ffffff 'microseconds'</td>
     * <td>5123456 microseconds</td>
     * </tr>
     * <tr>
     * <td>fffffffff 'ns'</td>
     * <td>5123456700 ns</td>
     * </tr>
     * </table>
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying function options. If <i>lpFormat</i> is not set to <b>NULL</b>, this parameter must be set to 0. If <i>lpFormat</i> is set to <b>NULL</b>, your application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default duration format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of <b>LOCALE_NOUSEROVERRIDE</b> is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {Pointer<SYSTEMTIME>} lpDuration Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time duration information to format. The application sets this parameter to <b>NULL</b> if the function is to ignore it and use <i>ullDuration</i>.
     * @param {Integer} ullDuration 64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both <i>lpDuration</i> and <i>ullDuration</i> are set, the <i>lpDuration</i> parameter takes precedence. If <i>lpDuration</i> is set to <b>NULL</b> and <i>ullDuration</i> is set to 0, the duration is 0.
     * @param {PWSTR} lpFormat Pointer to the format string with characters as shown below. The application can set this parameter to <b>NULL</b> if the function is to format the string according to the duration format for the specified locale. If <i>lpFormat</i> is not set to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="d"></a><a id="D"></a><dl>
     * <dt><b>d</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * days
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="h_or_H"></a><a id="h_or_h"></a><a id="H_OR_H"></a><dl>
     * <dt><b>h or H</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * hours
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="hh_or_HH"></a><a id="hh_or_hh"></a><a id="HH_OR_HH"></a><dl>
     * <dt><b>hh or HH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * hours; if less than ten,  prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="m"></a><a id="M"></a><dl>
     * <dt><b>m</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * minutes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="mm"></a><a id="MM"></a><dl>
     * <dt><b>mm</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * minutes; if less than ten, prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="s"></a><a id="S"></a><dl>
     * <dt><b>s</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * seconds
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ss"></a><a id="SS"></a><dl>
     * <dt><b>ss</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * seconds; if less than ten, prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="f"></a><a id="F"></a><dl>
     * <dt><b>f</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * fractions of a second
     * 
     * 
     * <div class="alert"><b>Note</b>The character "f" can occur up to nine consecutive times (fffffffff), although support for frequency timers is limited to 100 nanoseconds. Thus, if nine characters are present, the last two digits are always 0.</div>
     * <div></div>
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpDurationStr Pointer to the buffer in which the function retrieves the duration string.
     * 
     * Alternatively, this parameter retrieves <b>NULL</b> if <i>cchDuration</i> is set to 0. In this case, the function returns the required size for the duration string buffer.
     * @param {Integer} cchDuration Size, in characters, of the buffer indicated by <i>lpDurationStr</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpDurationStr</i> and returns the required size for the duration string buffer.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpDurationStr</i> if successful. If <i>lpDurationStr</i> is set to <b>NULL</b> and <i>cchDuration</i> is set to 0, the function returns the required size for the duration string buffer, including the terminating null character. For example, if 10 characters are written to the buffer, the function returns 11 to include the terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li><b>ERROR_INSUFFICIENT_BUFFER</b>. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>.</li>
     * <li><b>ERROR_INVALID_PARAMETER</b>. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getdurationformatex
     * @since windows6.0.6000
     */
    static GetDurationFormatEx(lpLocaleName, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDurationStr := lpDurationStr is String ? StrPtr(lpDurationStr) : lpDurationStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDurationFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpDuration, "uint", ullDuration, "ptr", lpFormat, "ptr", lpDurationStr, "int", cchDuration, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Compares two Unicode (wide character) strings, for a locale specified by name.CautionUsing CompareStringEx incorrectly can compromise the security of your application.
     * @remarks
     * Both <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> and <b>CompareStringEx</b> are optimized to run at the highest speed when <i>dwCmpFlags</i> is set to 0 or NORM_IGNORECASE, <i>cchCount1</i> and <i>cchCount2</i> are set to -1, and the locale does not support any linguistic compressions, as when traditional Spanish sorting treats "ch" as a single character.
     * 
     * Both <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> and <b>CompareStringEx</b> ignore Arabic kashidas during the comparison. Thus, if two strings are identical except for the presence of kashidas, the function returns CSTR_EQUAL.
     *       
     * 
     * When the application uses the NORM_IGNORENONSPACE and NORM_IGNORECASE flags with the sorting function, the flags can sometimes interfere with string comparisons. This situation might result for a locale that does not support non-spacing characters or case, but uses equivalent weight levels to handle other important operations. In such cases, your application should use the LINGUISTIC_IGNOREDIACRITIC and LINGUISTIC_IGNORECASE flags. These flags provide linguistically appropriate results for sorting code points that use case and diacritic marks, and have no impact on other code points.
     * 
     * <b>Beginning in WindowsVista: </b> Both <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> and <b>CompareStringEx</b> can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     *       
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * 
     * <b>Beginning in Windows8: </b><b>CompareStringEx</b>  is declared in Stringapiset.h. Before Windows8, it was declared in Winnls.h.
     * 
     * <div class="alert"><b>Note</b>The behavior of sorting can change between Windows releases. For example, there may be new Unicode code points created. Use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNlsVersionEx</a> to discover if the sort version has changed.</div>
     * <div></div>
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags 
     * @param {PWSTR} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {PWSTR} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of &lt;0, ==0, and &gt;0 is consistent with the C runtime.
     * 
     * <ul>
     * <li>CSTR_LESS_THAN. The string indicated by <i>lpString1</i> is less in lexical value than the string indicated by <i>lpString2</i>.</li>
     * <li>CSTR_EQUAL. The string indicated by <i>lpString1</i> is equivalent in lexical value to the string indicated by <i>lpString2</i>. The two strings are equivalent for sorting purposes, although not necessarily identical.</li>
     * <li>CSTR_GREATER_THAN. The string indicated by <i>lpString1</i> is greater in lexical value than the string indicated by <i>lpString2</i>.</li>
     * </ul>
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were invalid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. </li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-comparestringex
     * @since windows6.0.6000
     */
    static CompareStringEx(lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        static lpVersionInformation := 0, lpReserved := 0, lParam := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CompareStringEx", "ptr", lpLocaleName, "uint", dwCmpFlags, "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", lParam, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Compares two Unicode strings to test binary equivalence.
     * @remarks
     * This function tests for binary equality, not linguistic equality. For information about the use of the function for ordinal sorting, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * 
     * Applications that are concerned with linguistic equality should use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a>, <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-lstrcmpa">lstrcmp</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-lstrcmpia">lstrcmpi</a>. For more information about linguistic sorting, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>
     * 
     * 
     * <b>Starting with Windows8: </b><b>CompareStringOrdinal</b>  is declared in Stringapiset.h. Before Windows8, it was declared in Winnls.h.
     * @param {PWSTR} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {PWSTR} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {BOOL} bIgnoreCase <b>TRUE</b> if the function is to perform a case-insensitive comparison, using the operating system uppercase table information. The application sets this parameter to <b>FALSE</b> if the function is to compare the strings exactly as they are passed in. Note that 1 is the only numeric value that can be used to specify a true value for this boolean parameter that does not result an invalid parameter error. Boolean values for this parameter work as expected.
     * @returns {Integer} Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of &lt;0, ==0, and &gt;0 is consistent with the C runtime.
     * 
     * <ul>
     * <li>CSTR_LESS_THAN. The value indicated by <i>lpString1</i> is less than the value indicated by <i>lpString2</i>.</li>
     * <li>CSTR_EQUAL. The value indicated by <i>lpString1</i> equals the value indicated by <i>lpString2</i>.</li>
     * <li>CSTR_GREATER_THAN. The value indicated by <i>lpString1</i> is greater than the value indicated by <i>lpString2</i>.</li>
     * </ul>
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-comparestringordinal
     * @since windows6.0.6000
     */
    static CompareStringOrdinal(lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CompareStringOrdinal", "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "int", bIgnoreCase, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CompareStringW (Unicode) function (stringapiset.h) compares two character strings, for a locale specified by identifier.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * 
     * If your application is calling the ANSI version of <b>CompareString</b>, the function converts parameters via the default code page of the supplied locale. Thus, an application can never use <b>CompareString</b> to handle UTF-8 text.
     * 
     * Normally, for case-insensitive comparisons, <b>CompareString</b> maps the lowercase "i" to the uppercase "I", even when the locale is Turkish or Azerbaijani. The  NORM_LINGUISTIC_CASING flag overrides this behavior for Turkish or Azerbaijani. If this flag is specified in conjunction with Turkish or Azerbaijani, LATIN SMALL LETTER DOTLESS I (U+0131) is the lowercase form of LATIN CAPITAL LETTER I (U+0049) and LATIN SMALL LETTER I (U+0069) is the lowercase form of LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130).
     * 
     * <b>Starting with Windows8: </b>The ANSI version of the function is declared in Winnls.h, and the Unicode version is declared in Stringapiset.h. Before Windows8, both versions were declared in Winnls.h.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale used for the comparison. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags Flags that indicate how the function compares the two strings. For detailed definitions, see the <i>dwCmpFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @param {PWSTR} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {PWSTR} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns the values described for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-comparestringw
     * @since windows5.0
     */
    static CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\CompareStringW", "uint", Locale, "uint", dwCmpFlags, "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "int")
        return result
    }

    /**
     * Maps one Unicode string to another, performing the specified transformation. (FoldStringW)
     * @remarks
     * The values of the <i>lpSrcStr</i> and  and <i>lpDestStr</i> parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER.
     * 
     * The compatibility zone in Unicode consists of characters in the range 0xF900 through 0xFFEF that are assigned to characters from other encoding standards for characters but are actually variants of characters already in Unicode. The compatibility zone is used to support round-trip mapping to these standards. Applications can use the MAP_FOLDCZONE flag to avoid supporting the duplication of characters in the compatibility zone.
     * 
     * <b>Starting with WindowsVista:</b> This function supports Unicode normalization. All Unicode compatibility characters are mapped.
     * 
     * <b>Starting with WindowsVista:</b> The transformations indicated by the MAP_FOLDCZONE, MAP_PRECOMPOSED, and MAP_COMPOSITE flags use Unicode normalization forms KC, C, and D (through the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a> function) to do the mappings.
     * 
     * <b>Starting with Windows8: </b>The ANSI version of the function is declared in Winnls.h and the Unicode version is declared in Stringapiset.h. Before Windows8, both versions were declared in Winnls.h.
     * @param {Integer} dwMapFlags 
     * @param {PWSTR} lpSrcStr Pointer to a source string that the function maps.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>, excluding the terminating null character. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, the function calculates the string length automatically, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * @param {PWSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string. If the MAP_FOLDDIGITS flag is specified, the return value is the maximum size required, even if the actual number of characters needed is smaller than the maximum size. If the maximum size is not passed, the function fails with ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} Returns the number of characters in the translated string, including a terminating null character, if successful. If the function succeeds and the value of <i>cchDest</i> is 0, the return value is the size of the buffer required to hold the translated string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_DATA. The data was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_MOD_NOT_FOUND. The module was not found. </li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation. </li>
     * <li>ERROR_PROC_NOT_FOUND. The required procedure was not found.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-foldstringw
     * @since windows5.0
     */
    static FoldStringW(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FoldStringW", "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves character type information for the characters in the specified source string.
     * @remarks
     * For an overview of the use of the string functions, see <a href="https://docs.microsoft.com/windows/desktop/menurc/strings">Strings</a>.
     * 
     * Using the ANSI code page for the supplied locale, this function translates the source string from ANSI to Unicode. It then analyzes each Unicode character for character type information.
     * 
     * The ANSI version of this function converts the source string to Unicode and calls the 
     * corresponding <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a> function. Thus the words in the output buffer correspond not to the original ANSI string but to its Unicode equivalent. The conversion from ANSI to Unicode can result in a change in string length, for example, a pair of ANSI characters can map to a single 
     * Unicode character. Therefore, the correspondence between the words in the output buffer and the characters in the original ANSI string is not one-to-one in all cases, for example, multibyte strings. Thus, the ANSI version of this function is of limited use for multi-character strings. The Unicode version of the function is recommended instead.
     * 
     * This function circumvents a limitation caused by the difference in parameters between <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringtypea">GetStringTypeA</a> and <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a <b>GetStringType*</b> function through the use of the #define UNICODE switch. On the other hand, <b>GetStringTypeEx</b>, behaves properly with regard to that switch. Thus it is the recommended function.
     * 
     *     
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * The values of the <i>lpSrcStr</i> and <i>lpCharType</i> parameters must not be the same. If they are the same, the function fails with <b>ERROR_INVALID_PARAMETER</b>.
     * 
     * The <i>Locale</i> parameter is only used to perform string conversion to Unicode. It has nothing to do with the CTYPE* values supplied by the application. These values are solely determined by Unicode code points, and do not vary on a locale basis. For example, Greek letters are specified as C1_ALPHA for any value of <i>Locale</i>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. This value uniquely defines the ANSI code page. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.
     * @param {PWSTR} lpSrcStr Pointer to the string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. The size refers to bytes for the ANSI version of the function or wide characters for the Unicode version. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<Integer>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li><b>ERROR_INVALID_FLAGS</b>. The values supplied for flags were not valid.</li>
     * <li><b>ERROR_INVALID_PARAMETER</b>. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw
     * @since windows5.0
     */
    static GetStringTypeExW(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr

        lpCharTypeMarshal := lpCharType is VarRef ? "ushort*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeExW", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, lpCharTypeMarshal, lpCharType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves character type information for the characters in the specified Unicode source string.
     * @remarks
     * For an overview of the use of the string functions, see <a href="https://docs.microsoft.com/windows/desktop/menurc/strings">Strings</a>.
     * 
     * The values of the <i>lpSrcStr</i> and <i>lpCharType</i> parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER.
     * 
     * The <i>Locale</i> parameter used by the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringtypea">GetStringTypeA</a> function is not used by this function. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a <b>GetStringType*</b> function through the use of the #define UNICODE switch. An application can circumvent this limitation by using <a href="https://docs.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw">GetStringTypeEx</a>, which is the recommended function.
     * 
     * <b>Supported Character Types</b>
     * 
     * The character type bits are divided into several levels. The information for one level can be retrieved by a single call to this function. Each level is limited to 16 bits of information so that the other mapping functions, which are limited to 16 bits of representation per character, can also return character type information.
     * 
     * <u>Ctype 1</u>
     * 
     * These types support ANSI C and POSIX (LC_CTYPE) character typing functions. A bitwise-OR of these values is retrieved in the array in the output buffer when <i>dwInfoType</i> is set to CT_CTYPE1. For DBCS locales, the type attributes apply to both narrow characters and wide characters. The Japanese hiragana and katakana characters, and the kanji ideograph characters all have the C1_ALPHA attribute.
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Name</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>C1_UPPER </td>
     * <td>0x0001</td>
     * <td>Uppercase </td>
     * </tr>
     * <tr>
     * <td>C1_LOWER</td>
     * <td>0x0002</td>
     * <td>Lowercase </td>
     * </tr>
     * <tr>
     * <td>C1_DIGIT</td>
     * <td>0x0004</td>
     * <td>Decimal digits </td>
     * </tr>
     * <tr>
     * <td>C1_SPACE</td>
     * <td>0x0008</td>
     * <td>Space characters </td>
     * </tr>
     * <tr>
     * <td>C1_PUNCT</td>
     * <td>0x0010</td>
     * <td>Punctuation </td>
     * </tr>
     * <tr>
     * <td>C1_CNTRL</td>
     * <td>0x0020</td>
     * <td>Control characters </td>
     * </tr>
     * <tr>
     * <td>C1_BLANK</td>
     * <td>0x0040</td>
     * <td>Blank characters </td>
     * </tr>
     * <tr>
     * <td>C1_XDIGIT</td>
     * <td>0x0080</td>
     * <td>Hexadecimal digits </td>
     * </tr>
     * <tr>
     * <td>C1_ALPHA</td>
     * <td>0x0100</td>
     * <td>Any linguistic character: alphabetical, syllabary, or ideographic</td>
     * </tr>
     * <tr>
     * <td>C1_DEFINED</td>
     * <td>0x0200</td>
     * <td>A defined character, but not one of the other C1_* types</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * The following character types are either constant or computable from basic types and do not need to be supported by this function.
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Type</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>Alphanumeric</td>
     * <td>Alphabetical characters and digits (C1_ALPHA and C1_DIGIT)</td>
     * </tr>
     * <tr>
     * <td>Printable</td>
     * <td>Graphic characters and blanks (all C1_* types except C1_CNTRL)</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * <u>Ctype 2</u>
     * 
     * These types support proper layout of Unicode text. For DBCS locales, the character type applies to both narrow and wide characters. The direction attributes are assigned so that the bidirectional layout algorithm standardized by Unicode produces accurate results. These types are mutually exclusive. For more information about the use of these attributes, see <a href="https://www.unicode.org/standard/standard.html">The Unicode Standard</a>.
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Name</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>Strong</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C2_LEFTTORIGHT</td>
     * <td>0x0001</td>
     * <td>Left to right </td>
     * </tr>
     * <tr>
     * <td>C2_RIGHTTOLEFT</td>
     * <td>0x0002</td>
     * <td>Right to left </td>
     * </tr>
     * <tr>
     * <td>Weak</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C2_EUROPENUMBER</td>
     * <td>0x0003</td>
     * <td>European number, European digit</td>
     * </tr>
     * <tr>
     * <td>C2_EUROPESEPARATOR</td>
     * <td>0x0004</td>
     * <td>European numeric separator </td>
     * </tr>
     * <tr>
     * <td>C2_EUROPETERMINATOR</td>
     * <td>0x0005</td>
     * <td>European numeric terminator</td>
     * </tr>
     * <tr>
     * <td>C2_ARABICNUMBER</td>
     * <td>0x0006</td>
     * <td>Arabic number </td>
     * </tr>
     * <tr>
     * <td>C2_COMMONSEPARATOR</td>
     * <td>0x0007</td>
     * <td>Common numeric separator </td>
     * </tr>
     * <tr>
     * <td>Neutral</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C2_BLOCKSEPARATOR</td>
     * <td>0x0008</td>
     * <td>Block separator </td>
     * </tr>
     * <tr>
     * <td>C2_SEGMENTSEPARATOR</td>
     * <td>0x0009</td>
     * <td>Segment separator </td>
     * </tr>
     * <tr>
     * <td>C2_WHITESPACE</td>
     * <td>0x000A</td>
     * <td>White space </td>
     * </tr>
     * <tr>
     * <td>C2_OTHERNEUTRAL</td>
     * <td>0x000B</td>
     * <td>Other neutrals </td>
     * </tr>
     * <tr>
     * <td>Not applicable</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C2_NOTAPPLICABLE</td>
     * <td>0x0000</td>
     * <td>No implicit directionality (for example, control codes)</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * <u>Ctype 3</u>
     * 
     * These types are intended to be placeholders for extensions to the POSIX types required for general text processing or for the standard C library functions. A bitwise-OR of these values is retrieved when <i>dwInfoType</i> is set to CT_CTYPE3. For DBCS locales, the Ctype 3 attributes apply to both narrow characters and wide characters. The Japanese hiragana and katakana characters, and the kanji ideograph characters all have the C3_ALPHA attribute.
     * 
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Name</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>C3_NONSPACING</td>
     * <td>0x0001</td>
     * <td>Nonspacing mark </td>
     * </tr>
     * <tr>
     * <td>C3_DIACRITIC</td>
     * <td>0x0002</td>
     * <td>Diacritic nonspacing mark </td>
     * </tr>
     * <tr>
     * <td>C3_VOWELMARK</td>
     * <td>0x0004</td>
     * <td>Vowel nonspacing mark </td>
     * </tr>
     * <tr>
     * <td>C3_SYMBOL</td>
     * <td>0x0008</td>
     * <td>Symbol </td>
     * </tr>
     * <tr>
     * <td>C3_KATAKANA</td>
     * <td>0x0010</td>
     * <td>Katakana character</td>
     * </tr>
     * <tr>
     * <td>C3_HIRAGANA</td>
     * <td>0x0020</td>
     * <td>Hiragana character </td>
     * </tr>
     * <tr>
     * <td>C3_HALFWIDTH</td>
     * <td>0x0040</td>
     * <td>Half-width (narrow) character </td>
     * </tr>
     * <tr>
     * <td>C3_FULLWIDTH</td>
     * <td>0x0080</td>
     * <td>Full-width (wide) character </td>
     * </tr>
     * <tr>
     * <td>C3_IDEOGRAPH</td>
     * <td>0x0100</td>
     * <td>Ideographic character </td>
     * </tr>
     * <tr>
     * <td>C3_KASHIDA</td>
     * <td>0x0200</td>
     * <td>Arabic kashida character </td>
     * </tr>
     * <tr>
     * <td>C3_LEXICAL</td>
     * <td>0x0400</td>
     * <td>Punctuation which is counted as part of the word (kashida, hyphen, feminine/masculine ordinal indicators, equal sign, and so forth) </td>
     * </tr>
     * <tr>
     * <td>C3_ALPHA</td>
     * <td>0x8000</td>
     * <td>All linguistic characters (alphabetical, syllabary, and ideographic)</td>
     * </tr>
     * <tr>
     * <td>C3_HIGHSURROGATE</td>
     * <td>0x0800</td>
     * <td><b>WindowsVista:</b> High surrogate code unit</td>
     * </tr>
     * <tr>
     * <td>C3_LOWSURROGATE</td>
     * <td>0x1000</td>
     * <td><b>WindowsVista:</b> Low surrogate code unit</td>
     * </tr>
     * <tr>
     * <td>Not applicable</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>C3_NOTAPPLICABLE</td>
     * <td>0x0000</td>
     * <td>Not applicable</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * C3_HIGHSURROGATE and C3_LOWSURROGATE are listed only for completeness, and should never be provided to this function. They are relevant only for Unicode.
     * 
     * <b>Starting with Windows8: </b><b>GetStringTypeW</b>  is declared in Stringapiset.h. Before Windows8, it was declared in Winnls.h.
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. This parameter can have the following values. The character types are divided into different levels as described in the Remarks section.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE1"></a><a id="ct_ctype1"></a><dl>
     * <dt><b>CT_CTYPE1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve character type information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE2"></a><a id="ct_ctype2"></a><dl>
     * <dt><b>CT_CTYPE2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve bidirectional layout information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE3"></a><a id="ct_ctype3"></a><dl>
     * <dt><b>CT_CTYPE3</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve text processing information.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpSrcStr Pointer to the Unicode string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<Integer>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-getstringtypew
     * @since windows5.0
     */
    static GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr

        lpCharTypeMarshal := lpCharType is VarRef ? "ushort*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeW", "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, lpCharTypeMarshal, lpCharType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Maps a character string to a UTF-16 (wide character) string.
     * @remarks
     * The default behavior of this function is to translate to a precomposed form of the input character string. If a precomposed form does not exist, the function attempts to translate to a composite form.
     * 
     * The use of the MB_PRECOMPOSED flag has very little effect on most code pages because most input data is composed already. Consider calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a> after converting with <b>MultiByteToWideChar</b>. <b>NormalizeString</b> provides more accurate, standard, and consistent data, and can also be faster. Note that for the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> enumeration being passed to <b>NormalizeString</b>, NormalizationC corresponds to MB_PRECOMPOSED and NormalizationD corresponds to MB_COMPOSITE.
     * 
     * As mentioned in the caution above, the output buffer can easily be overrun if this function is not first called with <i>cchWideChar</i> set to 0 in order to obtain the required size. If the MB_COMPOSITE flag is used, the output can be three or more characters long for each input character.
     * 
     * The <i>lpMultiByteStr</i> and <i>lpWideCharStr</i> pointers must not be the same. If they are the same, the function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the value ERROR_INVALID_PARAMETER.
     * 
     * <b>MultiByteToWideChar</b> does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should pass in -1 or explicitly count the terminating null character for the input string.
     * 
     * The function fails if MB_ERR_INVALID_CHARS is set and an invalid character is encountered in the source string. An invalid character is one of the following:
     * 
     * <ul>
     * <li>A character that is not the default character in the source string, but translates to the default character when MB_ERR_INVALID_CHARS is not set</li>
     * <li>For DBCS strings, a character that has a lead byte but no valid trail byte</li>
     * </ul>
     * Starting with WindowsVista, this function fully conforms with the Unicode 4.1 specification for UTF-8 and UTF-16. The function used on earlier operating systems encodes or decodes lone <a href="https://docs.microsoft.com/windows/desktop/Intl/surrogates-and-supplementary-characters">surrogate</a> halves or mismatched surrogate pairs. Code written in earlier versions of Windows that rely on this behavior to encode random non-text binary data might run into problems. However, code that uses this function on valid UTF-8 strings will behave the same way as on earlier Windows operating systems.
     * 
     * <b>WindowsXP:</b> To prevent the security problem of the non-shortest-form versions of UTF-8 characters, <b>MultiByteToWideChar</b> deletes these characters.
     * 
     * <b>Starting with Windows8: </b><b>MultiByteToWideChar</b>  is declared in Stringapiset.h. Before Windows8, it was declared in Winnls.h.
     * @param {Integer} CodePage Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system default Windows ANSI code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system Macintosh code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * <div class="alert"><b>Note</b> This value is used primarily in legacy code and should not generally be needed since modern Macintosh computers use Unicode for encoding.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system OEM code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_SYMBOL"></a><a id="cp_symbol"></a><dl>
     * <dt><b>CP_SYMBOL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Symbol code page (42).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows ANSI code page for the current thread. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF7"></a><a id="cp_utf7"></a><dl>
     * <dt><b>CP_UTF7</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-7. Use this value only when forced by a 7-bit transport mechanism. Use of UTF-8 is preferred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF8"></a><a id="cp_utf8"></a><dl>
     * <dt><b>CP_UTF8</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-8.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @param {PSTR} lpMultiByteStr Pointer to the character string to convert.
     * @param {Integer} cbMultiByte Size, in bytes, of the string indicated by the <i>lpMultiByteStr</i> parameter. Alternatively, this parameter can be set to -1 if the string is null-terminated. Note that, if <i>cbMultiByte</i> is 0, the function fails.
     * 
     * If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting Unicode string has a terminating null character, and the length returned by the function includes this character.
     * 
     * If this parameter is set to a positive integer, the function processes exactly the specified number of bytes. If the provided size does not include a terminating null character, the resulting Unicode string is not null-terminated, and the returned length does not include this character.
     * @param {PWSTR} lpWideCharStr Pointer to a buffer that receives the converted string.
     * @param {Integer} cchWideChar Size, in characters, of the buffer indicated by <i>lpWideCharStr</i>. If this value is 0, the function returns the required buffer size, in characters, including any terminating null character, and makes no use of the <i>lpWideCharStr</i> buffer.
     * @returns {Integer} Returns the number of characters written to the buffer indicated by <i>lpWideCharStr</i> if successful. If the function succeeds and <i>cchWideChar</i> is 0, the return value is the required size, in characters, for the buffer indicated by <i>lpWideCharStr</i>. Also see <i>dwFlags</i> for info about how the MB_ERR_INVALID_CHARS flag affects the return value when invalid sequences are input.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. </li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar
     * @since windows5.0
     */
    static MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar) {
        lpMultiByteStr := lpMultiByteStr is String ? StrPtr(lpMultiByteStr) : lpMultiByteStr
        lpWideCharStr := lpWideCharStr is String ? StrPtr(lpWideCharStr) : lpWideCharStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MultiByteToWideChar", "uint", CodePage, "uint", dwFlags, "ptr", lpMultiByteStr, "int", cbMultiByte, "ptr", lpWideCharStr, "int", cchWideChar, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Maps a UTF-16 (wide character) string to a new character string.
     * @remarks
     * The <i>lpMultiByteStr</i> and <i>lpWideCharStr</i> pointers must not be the same. If they are the same, the function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_INVALID_PARAMETER.
     * 
     * <b>WideCharToMultiByte</b> does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should pass in -1 or explicitly count the terminating null character for the input string.
     * 
     * If <i>cbMultiByte</i> is less than <i>cchWideChar</i>, this function writes the number of characters specified by <i>cbMultiByte</i> to the buffer indicated by <i>lpMultiByteStr</i>. However, if <i>CodePage</i> is set to CP_SYMBOL and <i>cbMultiByte</i> is less than <i>cchWideChar,</i> the function writes no characters to <i>lpMultiByteStr</i>.
     * 
     * The <b>WideCharToMultiByte</b> function operates most efficiently when both <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> are set to <b>NULL</b>. The following table shows the behavior of the function for the four possible combinations of these parameters.
     * 
     * <table>
     * <tr>
     * <th><i>lpDefaultChar</i></th>
     * <th><i>lpUsedDefaultChar</i></th>
     * <th>Result</th>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td><b>NULL</b></td>
     * <td>No default checking. These parameter settings are the most efficient ones for use with this function.</td>
     * </tr>
     * <tr>
     * <td>Non-null character</td>
     * <td><b>NULL</b></td>
     * <td>Uses the specified default character, but does not set <i>lpUsedDefaultChar</i>.</td>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td>Non-null character</td>
     * <td>Uses the system default character and sets <i>lpUsedDefaultChar</i> if necessary.</td>
     * </tr>
     * <tr>
     * <td>Non-null character</td>
     * <td>Non-null character</td>
     * <td>Uses the specified default character and sets <i>lpUsedDefaultChar</i> if necessary.</td>
     * </tr>
     * </table>
     * 
     * 
     * Starting with WindowsVista, this function fully conforms with the Unicode 4.1 specification for UTF-8 and UTF-16. The function used on earlier operating systems encodes or decodes lone <a href="https://docs.microsoft.com/windows/desktop/Intl/surrogates-and-supplementary-characters">surrogate</a> halves or mismatched surrogate pairs. Code written in earlier versions of Windows that rely on this behavior to encode random non-text binary data might run into problems. However, code that uses this function to produce valid UTF-8 strings will behave the same way as on earlier Windows operating systems.
     * 
     * <b>Starting with Windows8: </b><b>WideCharToMultiByte</b>  is declared in Stringapiset.h. Before Windows8, it was declared in Winnls.h.
     * 
     * <h3><a id="wc_compositecheck_and_related_flags"></a><a id="WC_COMPOSITECHECK_AND_RELATED_FLAGS"></a>WC_COMPOSITECHECK and related flags</h3>
     * As discussed in <a href="https://docs.microsoft.com/windows/desktop/Intl/using-unicode-normalization-to-represent-strings">Using Unicode Normalization to Represent Strings</a>, Unicode allows multiple representations of the same string (interpreted linguistically). For example, Capital A with dieresis (umlaut) can be represented either precomposed as a single Unicode code point "" (U+00C4) or decomposed as the combination of Capital A and the combining dieresis character ("A" + "", that is U+0041 U+0308). However, most code pages provide only composed characters.
     * 
     * The WC_COMPOSITECHECK flag causes the <b>WideCharToMultiByte</b> function to test for decomposed Unicode characters and attempts to compose them before converting them to the requested code page. This flag is only available for conversion to <a href="https://docs.microsoft.com/windows/desktop/Intl/single-byte-character-sets">single byte (SBCS)</a> or <a href="https://docs.microsoft.com/windows/desktop/Intl/double-byte-character-sets">double byte (DBCS)</a> code pages (code pages &lt; 50000, excluding code page 42). If your application needs to convert decomposed Unicode data to single byte or double byte code pages, this flag might be useful. However, not all characters can be converted this way and it is more reliable to save and store such data as Unicode.
     * 
     * When an application is using WC_COMPOSITECHECK, some character combinations might remain incomplete or might have additional nonspacing characters left over. For example, A +  +  combines to  + . Using the WC_DISCARDNS flag causes the function to discard additional nonspacing characters. Using the WC_DEFAULTCHAR flag causes the function to use the default replacement character (typically "?") instead. Using the WC_SEPCHARS flag causes the function to attempt to convert each additional nonspacing character to the target code page. Usually this flag also causes the use of the replacement character ("?"). However, for code page 1258 (Vietnamese) and 20269, nonspacing characters exist and can be used. The conversions for these code pages are not perfect. Some combinations do not convert correctly to code page 1258, and WC_COMPOSITECHECK corrupts data in code page 20269. As mentioned earlier, it is more reliable to design your application to save and store such data as Unicode.
     * @param {Integer} CodePage Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system default Windows ANSI code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system Macintosh code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * <div class="alert"><b>Note</b> This value is used primarily in legacy code and should not generally be needed since modern Macintosh computers use Unicode for encoding.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system OEM code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_SYMBOL"></a><a id="cp_symbol"></a><dl>
     * <dt><b>CP_SYMBOL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows2000:</b> Symbol code page (42).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows2000:</b> The Windows ANSI code page for the current thread. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF7"></a><a id="cp_utf7"></a><dl>
     * <dt><b>CP_UTF7</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-7. Use this value only when forced by a 7-bit transport mechanism. Use of UTF-8 is preferred. With this value set, <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> must be set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF8"></a><a id="cp_utf8"></a><dl>
     * <dt><b>CP_UTF8</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-8. With this value set, <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> must be set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @param {PWSTR} lpWideCharStr Pointer to the Unicode string to convert.
     * @param {Integer} cchWideChar Size, in characters, of the string indicated by <i>lpWideCharStr</i>. Alternatively, this parameter can be set to -1 if the string is null-terminated. If <i>cchWideChar</i> is set to 0, the function fails.
     * 
     * If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting character string has a terminating null character, and the length returned by the function includes this character.
     * 
     * If this parameter is set to a positive integer, the function processes exactly the specified number of characters. If the provided size does not include a terminating null character, the resulting character string is not null-terminated, and the returned length does not include this character.
     * @param {Pointer} lpMultiByteStr Pointer to a buffer that receives the converted string.
     * @param {Integer} cbMultiByte Size, in bytes, of the buffer indicated by <i>lpMultiByteStr</i>. If this value is 0, the function returns the required buffer size, in bytes, including any terminating null character, and makes no use of the <i>lpMultiByteStr</i> buffer.
     * @param {PSTR} lpDefaultChar Pointer to the character to use if a character cannot be represented in the specified code page. The application sets this parameter to <b>NULL</b> if the function is to use a system default value. To obtain the system default character, the application can call the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfo">GetCPInfo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a> function.
     * 
     * For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.
     * @param {Pointer<BOOL>} lpUsedDefaultChar Pointer to a flag that indicates if the function has used a default character in the conversion. The flag is set to <b>TRUE</b> if one or more characters in the source string cannot be represented in the specified code page. Otherwise, the flag is set to <b>FALSE</b>. This parameter can be set to <b>NULL</b>.
     * 
     * For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.
     * @returns {Integer} If successful, returns the number of bytes written to the buffer pointed to by <i>lpMultiByteStr</i>. If the function succeeds and <i>cbMultiByte</i> is 0, the return value is the required size, in bytes, for the buffer indicated by <i>lpMultiByteStr</i>. Also see <i>dwFlags</i> for info about how the WC_ERR_INVALID_CHARS flag affects the return value when invalid sequences are input.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. </li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte
     * @since windows5.0
     */
    static WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar) {
        lpWideCharStr := lpWideCharStr is String ? StrPtr(lpWideCharStr) : lpWideCharStr
        lpDefaultChar := lpDefaultChar is String ? StrPtr(lpDefaultChar) : lpDefaultChar

        lpUsedDefaultCharMarshal := lpUsedDefaultChar is VarRef ? "int*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\WideCharToMultiByte", "uint", CodePage, "uint", dwFlags, "ptr", lpWideCharStr, "int", cchWideChar, "ptr", lpMultiByteStr, "int", cbMultiByte, "ptr", lpDefaultChar, lpUsedDefaultCharMarshal, lpUsedDefaultChar, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if a specified code page is valid.
     * @remarks
     * A code page is considered valid only if it is installed on the operating system. Unicode is preferred.
     * 
     * Starting with WindowsVista, all code pages that can be installed are loaded by default.
     * @param {Integer} CodePage <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code page identifier</a> for the code page to check.
     * @returns {BOOL} Returns a nonzero value if the code page is valid, or 0 if the code page is invalid.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidcodepage
     * @since windows5.0
     */
    static IsValidCodePage(CodePage) {
        result := DllCall("KERNEL32.dll\IsValidCodePage", "uint", CodePage, "int")
        return result
    }

    /**
     * Retrieves the current Windows ANSI code page identifier for the operating system.CautionThe ANSI API functions, for example, the ANSI version of TextOut, implicitly use GetACP to translate text to or from Unicode.
     * @remarks
     * The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, applications should use UTF-8 or UTF-16 when possible.
     * @returns {Integer} Returns the current Windows ANSI code page (ACP) identifier for the operating system. See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for Windows ANSI code pages and other code pages.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getacp
     * @since windows5.0
     */
    static GetACP() {
        result := DllCall("KERNEL32.dll\GetACP", "uint")
        return result
    }

    /**
     * Returns the current original equipment manufacturer (OEM) code page identifier for the operating system.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of OEM and other code pages.
     * @returns {Integer} Returns the current OEM code page identifier for the operating system.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getoemcp
     * @since windows5.0
     */
    static GetOEMCP() {
        result := DllCall("KERNEL32.dll\GetOEMCP", "uint")
        return result
    }

    /**
     * Retrieves information about any valid installed or available code page. (GetCPInfo)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a>.
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. For details, see the <i>CodePage</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a>.
     * @param {Pointer<CPINFO>} lpCPInfo Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfo">CPINFO</a> structure that receives information about the code page. See the Remarks section.
     * @returns {BOOL} Returns 1 if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 				
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcpinfo
     * @since windows5.0
     */
    static GetCPInfo(CodePage, lpCPInfo) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfo", "uint", CodePage, "ptr", lpCPInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about any valid installed or available code page. (GetCPInfoExA)
     * @remarks
     * The information retrieved in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure is not always useful for all code pages. To determine buffer sizes, for example, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> or <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-widechartomultibyte">WideCharToMultiByte</a> to request an accurate buffer size. If <b>CPINFOEX</b> settings indicate that a lead byte exists, the conversion function does not necessarily handle lead bytes differently, for example, in the case of a missing or illegal trail byte.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCPInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. The application can specify the code page identifier for any installed or available code page, or one of the following predefined values. See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for ANSI and other code pages.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the current thread's ANSI code page.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer<CPINFOEXA>} lpCPInfoEx Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure that receives information about the code page.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcpinfoexa
     * @since windows5.0
     */
    static GetCPInfoExA(CodePage, dwFlags, lpCPInfoEx) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfoExA", "uint", CodePage, "uint", dwFlags, "ptr", lpCPInfoEx, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about any valid installed or available code page. (GetCPInfoExW)
     * @remarks
     * The information retrieved in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure is not always useful for all code pages. To determine buffer sizes, for example, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> or <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-widechartomultibyte">WideCharToMultiByte</a> to request an accurate buffer size. If <b>CPINFOEX</b> settings indicate that a lead byte exists, the conversion function does not necessarily handle lead bytes differently, for example, in the case of a missing or illegal trail byte.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCPInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. The application can specify the code page identifier for any installed or available code page, or one of the following predefined values. See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for ANSI and other code pages.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the current thread's ANSI code page.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer<CPINFOEXW>} lpCPInfoEx Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure that receives information about the code page.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcpinfoexw
     * @since windows5.0
     */
    static GetCPInfoExW(CodePage, dwFlags, lpCPInfoEx) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfoExW", "uint", CodePage, "uint", dwFlags, "ptr", lpCPInfoEx, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Compares two character strings, for a locale specified by identifier.CautionUsing CompareString incorrectly can compromise the security of your application. (CompareStringA)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * 
     * If your application is calling the ANSI version of <b>CompareString</b>, the function converts parameters via the default code page of the supplied locale. Thus, an application can never use <b>CompareString</b> to handle UTF-8 text.
     * 
     * Normally, for case-insensitive comparisons, <b>CompareString</b> maps the lowercase "i" to the uppercase "I", even when the locale is Turkish or Azerbaijani. The  NORM_LINGUISTIC_CASING flag overrides this behavior for Turkish or Azerbaijani. If this flag is specified in conjunction with Turkish or Azerbaijani, LATIN SMALL LETTER DOTLESS I (U+0131) is the lowercase form of LATIN CAPITAL LETTER I (U+0049) and LATIN SMALL LETTER I (U+0069) is the lowercase form of LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130).
     * 
     * <b>Starting with Windows8: </b>The ANSI version of the function is declared in Winnls.h, and the Unicode version is declared in Stringapiset.h. Before Windows8, both versions were declared in Winnls.h.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines CompareString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale used for the comparison. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags Flags that indicate how the function compares the two strings. For detailed definitions, see the <i>dwCmpFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @param {Pointer<Integer>} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {Pointer<Integer>} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns the values described for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-comparestringa
     * @since windows5.0
     */
    static CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        lpString1Marshal := lpString1 is VarRef ? "char*" : "ptr"
        lpString2Marshal := lpString2 is VarRef ? "char*" : "ptr"

        result := DllCall("KERNEL32.dll\CompareStringA", "uint", Locale, "uint", dwCmpFlags, lpString1Marshal, lpString1, "int", cchCount1, lpString2Marshal, lpString2, "int", cchCount2, "int")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by identifier.CautionBecause strings with very different binary representations can compare as identical, this function can raise certain security concerns. For more information, see the discussion of comparison functions in Security Considerations:\_International Features.NoteFor interoperability reasons, the application should prefer the FindNLSStringEx function because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Although FindNLSString supports custom locales, most applications should use FindNLSStringEx for this type of support.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFindNLSStringFlags Flags specifying details of the find operation. For detailed definitions, see the <i>dwFindNLSStringFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.
     * @param {PWSTR} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {PWSTR} lpStringValue Pointer to the search string, for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<Integer>} pcchFound Pointer to a buffer containing the length of the string that the function finds. For details, see the <i>pcchFound</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.
     * @returns {Integer} Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. In combination with the value in <i>pcchFound</i>, this index provides the exact location of the entire found string in the source string. A return value of 0 is an error-free index into the source string, and the matching string is in the source string at offset 0.
     * 
     * The function returns -1 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-findnlsstring
     * @since windows6.0.6000
     */
    static FindNLSString(Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound) {
        lpStringSource := lpStringSource is String ? StrPtr(lpStringSource) : lpStringSource
        lpStringValue := lpStringValue is String ? StrPtr(lpStringValue) : lpStringValue

        pcchFoundMarshal := pcchFound is VarRef ? "int*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNLSString", "uint", Locale, "uint", dwFindNLSStringFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, pcchFoundMarshal, pcchFound, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string. (Unicode)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * 
     * The ANSI version of <b>LCMapString</b> maps strings to and from Unicode based on the default Windows (ANSI) code page associated with the specified locale. When the ANSI version of this function is used with a Unicode-only locale, the function can succeed because the operating system uses the CP_ACP value, representing the system default Windows ANSI code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines LCMapString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flags specifying the type of transformation to use during string mapping or the type of sort key to generate. For detailed definitions, see the <i>dwMapFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * @param {PWSTR} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapString</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {PWSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @returns {Integer} If the function succeeds when used for string mapping, it returns the number of characters in the translated string (see *cchSrc* and *cchDest* for more details).
     * 
     * If the function succeeds when used for string mapping it returns the number of bytes in the sort key.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-lcmapstringw
     * @since windows5.0
     */
    static LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LCMapStringW", "uint", Locale, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string. (ANSI)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * 
     * The ANSI version of <b>LCMapString</b> maps strings to and from Unicode based on the default Windows (ANSI) code page associated with the specified locale. When the ANSI version of this function is used with a Unicode-only locale, the function can succeed because the operating system uses the CP_ACP value, representing the system default Windows ANSI code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines LCMapString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flags specifying the type of transformation to use during string mapping or the type of sort key to generate. For detailed definitions, see the <i>dwMapFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * @param {PSTR} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapString</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {PSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @returns {Integer} If the function succeeds when used for string mapping, it returns the number of characters in the translated string (see *cchSrc* and *cchDest* for more details).
     * 
     * If the function succeeds when used for string mapping it returns the number of bytes in the sort key.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-lcmapstringa
     * @since windows5.0
     */
    static LCMapStringA(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LCMapStringA", "uint", Locale, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about a locale specified by identifier. (Unicode)
     * @remarks
     * For the operation of this function, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b> Even when the <i>LCType</i> parameter is specified as LOCALE_FONTSIGNATURE, <i>cchData</i> and the function return are still TCHAR counts. The count is different for the ANSI and Unicode versions of the function. When an application calls the generic version of <b>GetLocaleInfo</b> with LOCALE_FONTSIGNATURE, <i>cchData</i> can be safely specified as sizeof(LOCALESIGNATURE) / sizeof(TCHAR).</div>
     * <div></div>
     * The following examples deal correctly with the buffer size for non-text values:
     * 
     * 
     * ```cpp
     * int   ret;
     * CALID calid;
     * DWORD value;
     * 
     * ret = GetLocaleInfo(LOCALE_USER_DEFAULT,
     *                     LOCALE_ICALENDARTYPE | LOCALE_RETURN_NUMBER,
     *                     (LPTSTR)&value,
     *                     sizeof(value) / sizeof(TCHAR) );
     * calid = value;
     * 
     * LOCALESIGNATURE LocSig;
     * 
     * ret = GetLocaleInfo(LOCALE_USER_DEFAULT,
     *                     LOCALE_FONTSIGNATURE,
     *                     (LPWSTR)&LocSig,
     *                     sizeof(LocSig) / sizeof(TCHAR) );
     * 
     * ```
     * 
     * 
     * The ANSI string retrieved by the ANSI version of this function is translated from Unicode to ANSI based on the default ANSI code page for the locale identifier. However, if <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> is specified, the translation is based on the system default ANSI code page.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetLocaleInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> for which to retrieve information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For detailed definitions, see the <i>LCType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b>For <b>GetLocaleInfo</b>, the value LOCALE_USE_CP_ACP is relevant only for the ANSI version.</div>
     * <div></div>
     * @param {PWSTR} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0. For more information, see the Remarks section.
     * @param {Integer} cchData Size, in TCHAR values, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {Integer} Returns the number of characters retrieved in the locale data buffer if successful and <i>cchData</i> is a nonzero value. If the function succeeds, <i>cchData</i> is nonzero, and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> is specified, the return value is the size of the integer retrieved in the data buffer; that is, 2 for the Unicode version of the function or 4 for the ANSI version. If the function succeeds and the value of <i>cchData</i> is 0, the return value is the required size, in characters including a null character, for the locale data buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getlocaleinfow
     * @since windows5.0
     */
    static GetLocaleInfoW(Locale, LCType, lpLCData, cchData) {
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLocaleInfoW", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int", cchData, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about a locale specified by identifier. (ANSI)
     * @remarks
     * For the operation of this function, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b> Even when the <i>LCType</i> parameter is specified as LOCALE_FONTSIGNATURE, <i>cchData</i> and the function return are still TCHAR counts. The count is different for the ANSI and Unicode versions of the function. When an application calls the generic version of <b>GetLocaleInfo</b> with LOCALE_FONTSIGNATURE, <i>cchData</i> can be safely specified as sizeof(LOCALESIGNATURE) / sizeof(TCHAR).</div>
     * <div></div>
     * The following examples deal correctly with the buffer size for non-text values:
     * 
     * 
     * ```cpp
     * int   ret;
     * CALID calid;
     * DWORD value;
     * 
     * ret = GetLocaleInfo(LOCALE_USER_DEFAULT,
     *                     LOCALE_ICALENDARTYPE | LOCALE_RETURN_NUMBER,
     *                     (LPTSTR)&value,
     *                     sizeof(value) / sizeof(TCHAR) );
     * calid = value;
     * 
     * LOCALESIGNATURE LocSig;
     * 
     * ret = GetLocaleInfo(LOCALE_USER_DEFAULT,
     *                     LOCALE_FONTSIGNATURE,
     *                     (LPWSTR)&LocSig,
     *                     sizeof(LocSig) / sizeof(TCHAR) );
     * 
     * ```
     * 
     * 
     * The ANSI string retrieved by the ANSI version of this function is translated from Unicode to ANSI based on the default ANSI code page for the locale identifier. However, if <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> is specified, the translation is based on the system default ANSI code page.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetLocaleInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> for which to retrieve information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For detailed definitions, see the <i>LCType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b>For <b>GetLocaleInfo</b>, the value LOCALE_USE_CP_ACP is relevant only for the ANSI version.</div>
     * <div></div>
     * @param {PSTR} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0. For more information, see the Remarks section.
     * @param {Integer} cchData Size, in TCHAR values, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {Integer} Returns the number of characters retrieved in the locale data buffer if successful and <i>cchData</i> is a nonzero value. If the function succeeds, <i>cchData</i> is nonzero, and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> is specified, the return value is the size of the integer retrieved in the data buffer; that is, 2 for the Unicode version of the function or 4 for the ANSI version. If the function succeeds and the value of <i>cchData</i> is 0, the return value is the required size, in characters including a null character, for the locale data buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getlocaleinfoa
     * @since windows5.0
     */
    static GetLocaleInfoA(Locale, LCType, lpLCData, cchData) {
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLocaleInfoA", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int", cchData, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets an item of information in the user override portion of the current locale. This function does not set the system defaults. (ANSI)
     * @remarks
     * This function writes to the registry, where it sets values that are associated with a particular user instead of a particular application. These registry values affect the behavior of other applications run by the user. As a rule, an application should call this function only when the user has explicitly requested the changes. The registry settings should not be changed for the convenience of a single application.
     * 
     * For the <i>LCType</i> parameter, the application should set <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> to use the operating system ANSI code page instead of the locale code page for string translation.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * As of WindowsVista, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sdate">LOCALE_SDATE</a> and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIME</a> constants are obsolete. Do not use these constants. Use <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sshortdate">LOCALE_SSHORTDATE</a> and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIMEFORMAT</a> instead. A custom locale might not have a single, uniform separator character within the date or time format: for example, a format such as "12/31, 2006" or "03:56'23" might be valid.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines SetLocaleInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale For the ANSI version of the function, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale with the code page used when interpreting the <i>lpLCData</i> information. For the Unicode version, this parameter is ignored.
     * 
     * You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} LCType Type of locale information to set. For valid constants see "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. The application can specify only one value per call, but it can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> with any other constant.
     * @param {PSTR} lpLCData Pointer to a null-terminated string containing the locale information to set. The information must be in the format specific to the specified constant. The application uses a Unicode string for the Unicode version of the function, and an ANSI string for the ANSI version.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INVALID_ACCESS. The access code was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setlocaleinfoa
     * @since windows5.0
     */
    static SetLocaleInfoA(Locale, LCType, lpLCData) {
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetLocaleInfoA", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets an item of information in the user override portion of the current locale. This function does not set the system defaults. (Unicode)
     * @remarks
     * This function writes to the registry, where it sets values that are associated with a particular user instead of a particular application. These registry values affect the behavior of other applications run by the user. As a rule, an application should call this function only when the user has explicitly requested the changes. The registry settings should not be changed for the convenience of a single application.
     * 
     * For the <i>LCType</i> parameter, the application should set <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> to use the operating system ANSI code page instead of the locale code page for string translation.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * As of WindowsVista, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sdate">LOCALE_SDATE</a> and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIME</a> constants are obsolete. Do not use these constants. Use <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sshortdate">LOCALE_SSHORTDATE</a> and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-stime-constants">LOCALE_STIMEFORMAT</a> instead. A custom locale might not have a single, uniform separator character within the date or time format: for example, a format such as "12/31, 2006" or "03:56'23" might be valid.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines SetLocaleInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale For the ANSI version of the function, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale with the code page used when interpreting the <i>lpLCData</i> information. For the Unicode version, this parameter is ignored.
     * 
     * You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} LCType Type of locale information to set. For valid constants see "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. The application can specify only one value per call, but it can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> with any other constant.
     * @param {PWSTR} lpLCData Pointer to a null-terminated string containing the locale information to set. The information must be in the format specific to the specified constant. The application uses a Unicode string for the Unicode version of the function, and an ANSI string for the ANSI version.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INVALID_ACCESS. The access code was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setlocaleinfow
     * @since windows5.0
     */
    static SetLocaleInfoW(Locale, LCType, lpLCData) {
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetLocaleInfoW", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about a calendar for a locale specified by identifier. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 
     * <div class="alert"><b>Note</b><b>GetCalendarInfo</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div></div>
     * CAL_USE_CP_ACP is relevant only for the ANSI version of this function.
     * 
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {PSTR} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<Integer>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {Integer} Returns the number of characters retrieved in the <i>lpCalData</i> buffer, with <i>cchData</i> set to a nonzero value, if successful. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the calendar information. If the function succeeds, <i>cchData</i> is set 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value retrieved in <i>lpValue</i>, that is, 2 for the Unicode version of the function or 4 for the ANSI version.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcalendarinfoa
     * @since windows5.0
     */
    static GetCalendarInfoA(Locale, Calendar, CalType, lpCalData, cchData, lpValue) {
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        lpValueMarshal := lpValue is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCalendarInfoA", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int", cchData, lpValueMarshal, lpValue, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about a calendar for a locale specified by identifier. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 
     * <div class="alert"><b>Note</b><b>GetCalendarInfo</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div></div>
     * CAL_USE_CP_ACP is relevant only for the ANSI version of this function.
     * 
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {PWSTR} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<Integer>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {Integer} Returns the number of characters retrieved in the <i>lpCalData</i> buffer, with <i>cchData</i> set to a nonzero value, if successful. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the calendar information. If the function succeeds, <i>cchData</i> is set 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value retrieved in <i>lpValue</i>, that is, 2 for the Unicode version of the function or 4 for the ANSI version.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcalendarinfow
     * @since windows5.0
     */
    static GetCalendarInfoW(Locale, Calendar, CalType, lpCalData, cchData, lpValue) {
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        lpValueMarshal := lpValue is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCalendarInfoW", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int", cchData, lpValueMarshal, lpValue, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets an item of locale information for a calendar. For more information, see Date and Calendar. (ANSI)
     * @remarks
     * This function only affects the user override portion of the calendar settings. It does not set the system defaults.
     * 
     * Calendar information is always passed as a null-terminated Unicode string in the Unicode version of this function, and as a null-terminated ANSI string in the ANSI version. No integers are allowed by this function. Any numeric values must be specified as either Unicode or ANSI text.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * CAL_ITWODIGITYEARMAX can be used with any calendar, even if the calendar is not supported for the specified locale. To avoid complications, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoa">EnumCalendarInfo</a> to ensure that the calendar is supported for the locale of interest.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines SetCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> for the calendar for which to set information.
     * @param {Integer} CalType Type of calendar information to set. Only the following CALTYPE values are valid for this function. The CAL_USE_CP_ACP constant is only meaningful for the ANSI version of the function.
     * 
     * <ul>
     * <li>CAL_USE_CP_ACP</li>
     * <li>CAL_ITWODIGITYEARMAX</li>
     * </ul>
     * The application can specify only one calendar identifier per call to this function. An exception can be made if the application uses the binary OR operator to combine CAL_USE_CP_ACP with any valid CALTYPE value defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>.
     * @param {PSTR} lpCalData Pointer to a null-terminated calendar information string. The information must be in the format of the specified calendar type.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setcalendarinfoa
     * @since windows5.0
     */
    static SetCalendarInfoA(Locale, Calendar, CalType, lpCalData) {
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetCalendarInfoA", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets an item of locale information for a calendar. For more information, see Date and Calendar. (Unicode)
     * @remarks
     * This function only affects the user override portion of the calendar settings. It does not set the system defaults.
     * 
     * Calendar information is always passed as a null-terminated Unicode string in the Unicode version of this function, and as a null-terminated ANSI string in the ANSI version. No integers are allowed by this function. Any numeric values must be specified as either Unicode or ANSI text.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * CAL_ITWODIGITYEARMAX can be used with any calendar, even if the calendar is not supported for the specified locale. To avoid complications, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoa">EnumCalendarInfo</a> to ensure that the calendar is supported for the locale of interest.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines SetCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> for the calendar for which to set information.
     * @param {Integer} CalType Type of calendar information to set. Only the following CALTYPE values are valid for this function. The CAL_USE_CP_ACP constant is only meaningful for the ANSI version of the function.
     * 
     * <ul>
     * <li>CAL_USE_CP_ACP</li>
     * <li>CAL_ITWODIGITYEARMAX</li>
     * </ul>
     * The application can specify only one calendar identifier per call to this function. An exception can be made if the application uses the binary OR operator to combine CAL_USE_CP_ACP with any valid CALTYPE value defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>.
     * @param {PWSTR} lpCalData Pointer to a null-terminated calendar information string. The information must be in the format of the specified calendar type.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setcalendarinfow
     * @since windows5.0
     */
    static SetCalendarInfoW(Locale, Calendar, CalType, lpCalData) {
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetCalendarInfoW", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if a specified character is a lead byte for the system default Windows ANSI code page (CP_ACP). A lead byte is the first byte of a two-byte character in a double-byte character set (DBCS) for the code page.
     * @remarks
     * <div class="alert"><b>Note</b>This function does not validate the presence or validity of a trail byte. Therefore, 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> might not recognize a 
     *      sequence that the application using <b>IsDBCSLeadByte</b> 
     *      reports as a lead byte. The application can easily become unsynchronized with the results of 
     *      <b>MultiByteToWideChar</b>, potentially leading to 
     *      unexpected errors or buffer size mismatches.</div>
     * <div></div>
     * In general, instead of attempting low-level manipulation of code page data, applications should use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> to convert the 
     *     data to UTF-16 and work with it in that encoding.
     * 
     * Lead byte values are specific to each distinct DBCS. Some byte values can appear in a single code page as both 
     *     the lead and trail byte of a DBCS character.
     * 
     * To make sense of a DBCS string, an application normally starts at the beginning of a string and scans forward, 
     *     keeping track when it encounters a lead byte, and treating the next byte as the trailing part of the same 
     *     character. If the application must back up, it should use 
     *     <a href="https://docs.microsoft.com/windows/desktop/menurc/v">CharPrev</a> instead of attempting to develop its own 
     *     algorithm.
     * @param {Integer} TestChar The character to test.
     * @returns {BOOL} Returns a nonzero value if the test character is potentially a lead byte. The function returns 0 if the test 
     *        character is not a lead byte or if it is a single-byte character. To get extended error information, the 
     *        application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isdbcsleadbyte
     * @since windows5.0
     */
    static IsDBCSLeadByte(TestChar) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsDBCSLeadByte", "char", TestChar, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if a specified character is potentially a lead byte. A lead byte is the first byte of a two-byte character in a double-byte character set (DBCS) for the code page.
     * @remarks
     * <div class="alert"><b>Note</b> This function does not validate the presence or validity of a trail byte. Therefore, <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> might not recognize a sequence that the application using <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-isdbcsleadbyte">IsDBCSLeadByte</a> reports as a lead byte. The application can easily become unsynchronized with the results of <b>MultiByteToWideChar</b>, potentially leading to unexpected errors or buffer size mismatches.</div>
     * <div></div>
     * In general, instead of attempting low-level manipulation of code page data, applications should use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a> to convert the data to UTF-16 and work with it in that encoding.
     * 
     * Lead byte values are specific to each distinct DBCS. Some byte values can appear in a single code page as both the lead and trail byte of a DBCS character. Thus, <b>IsDBCSLeadByteEx</b> can only indicate a potential lead byte value.
     * 
     * To make sense of a DBCS string, an application normally starts at the beginning of the string and scans forward, keeping track when it encounters a lead byte, and treating the next byte as the trailing part of the same character. To back up, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-charprevexa">CharPrevExA</a> instead of attempting to develop its own algorithm.
     * @param {Integer} CodePage Identifier of the code page used to check lead byte ranges. This parameter can be one of the code page identifiers defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/unicode-and-character-set-constants">Unicode and Character Set Constants</a> or one of the following predefined values. This function validates lead byte values only in code pages 932, 936, 949, 950, and 1361.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the Windows ANSI code page for the current thread.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} TestChar The character to test.
     * @returns {BOOL} Returns a nonzero value if the byte is a lead byte. The function returns 0 if the byte is not a lead byte or if the character is a single-byte character. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isdbcsleadbyteex
     * @since windows5.0
     */
    static IsDBCSLeadByteEx(CodePage, TestChar) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsDBCSLeadByteEx", "uint", CodePage, "char", TestChar, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a locale name to a locale identifier.
     * @remarks
     * For custom locales, including those created by Microsoft, your applications should prefer locale names over locale identifiers. See [The deprecation of LCIDs](/globalization/locale/locale-names#the-deprecation-of-lcids) for more info.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {PWSTR} lpName Pointer to a null-terminated string representing a locale name, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags <b>Prior to Windows7:</b>Reserved; should always be 0.
     * 
     * <b>Beginning in Windows7:</b> Can be set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-allow-neutral-names">LOCALE_ALLOW_NEUTRAL_NAMES</a> to allow the return of a neutral LCID.
     * @returns {Integer} If successful, returns the locale identifier corresponding to the locale name.
     * 
     * If the supplied locale name corresponds to a custom locale that is the user default, this function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>.
     * 
     * If the locale name corresponds to a custom locale that is not the user default, is a transient locale, or is a CLDR (Unicode Common Locale Data Repository) locale, the function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return ERROR_INVALID_PARAMETER if any of the parameter values are invalid.
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-localenametolcid
     * @since windows6.0.6000
     */
    static LocaleNameToLCID(lpName, dwFlags) {
        lpName := lpName is String ? StrPtr(lpName) : lpName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LocaleNameToLCID", "ptr", lpName, "uint", dwFlags, "uint")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a locale identifier to a locale name.
     * @param {Integer} Locale Locale identifier to translate. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {PWSTR} lpName Pointer to a buffer in which this function retrieves the locale name, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} cchName Size, in characters, of the locale name buffer. The maximum possible length of a locale name, including a terminating null character, is <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply for this parameter.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the locale name buffer.
     * @param {Integer} dwFlags <b>BeforeWindows7:</b> Reserved; should always be 0.
     * 
     * <b>Starting withWindows7:</b> Can be set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-allow-neutral-names">LOCALE_ALLOW_NEUTRAL_NAMES</a> to allow the return of a neutral name.
     * @returns {Integer} Returns the count of characters, including the terminating null character, in the locale name if successful. If the function succeeds and the value of <i>cchName</i> is 0, the return value is the required size, in characters (including nulls), for the locale name buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-lcidtolocalename
     * @since windows6.0.6000
     */
    static LCIDToLocaleName(Locale, lpName, cchName, dwFlags) {
        lpName := lpName is String ? StrPtr(lpName) : lpName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LCIDToLocaleName", "uint", Locale, "ptr", lpName, "int", cchName, "uint", dwFlags, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a duration of time as a time string for a locale specified by identifier.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getdurationformatex">GetDurationFormatEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the duration. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying function options. If <i>lpFormat</i> is not set to <b>NULL</b>, this parameter must be set to 0. If <i>lpFormat</i> is set to <b>NULL</b>, your application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default duration format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {Pointer<SYSTEMTIME>} lpDuration Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time duration information to format. If this pointer is <b>NULL</b>, the function ignores this parameter and uses <i>ullDuration</i>.
     * @param {Integer} ullDuration 64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both <i>lpDuration</i> and <i>ullDuration</i> are present, <i>lpDuration</i> takes precedence. If <i>lpDuration</i> is set to <b>NULL</b> and <i>ullDuration</i> is set to 0, the duration is zero.
     * @param {PWSTR} lpFormat Pointer to the format string. For details, see the <i>lpFormat</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getdurationformatex">GetDurationFormatEx</a>.
     * @param {PWSTR} lpDurationStr Pointer to the buffer in which the function retrieves the duration string.
     * 
     * Alternatively, this parameter can contain <b>NULL</b> if <i>cchDuration</i> is set to 0. In this case, the function returns the required size for the duration string buffer.
     * @param {Integer} cchDuration Size, in characters, of the buffer indicated by <i>lpDurationStr</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpDurationStr</i> and returns the required size for the duration string buffer.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpDurationStr</i> if successful. If <i>lpDurationStr</i> is set to <b>NULL</b> and <i>cchDuration</i> is set to 0, the function returns the required size for the duration string buffer, including the null terminating character. For example, if 10 characters are written to the buffer, the function returns 11 to include the terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getdurationformat
     * @since windows6.0.6000
     */
    static GetDurationFormat(Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDurationStr := lpDurationStr is String ? StrPtr(lpDurationStr) : lpDurationStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDurationFormat", "uint", Locale, "uint", dwFlags, "ptr", lpDuration, "uint", ullDuration, "ptr", lpFormat, "ptr", lpDurationStr, "int", cchDuration, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a number string as a number string customized for a locale specified by identifier. (ANSI)
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetNumberFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PSTR} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTA>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If this parameter does is not set to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale-specific string value for the negative sign.
     * @param {PSTR} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string.
     * @param {Integer} cchNumber Size, in TCHAR values, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer, and does not use the <i>lpNumberStr</i> parameter.
     * @returns {Integer} Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpNumberStr</i> if successful. If the <i>cchNumber</i> parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnumberformata
     * @since windows5.0
     */
    static GetNumberFormatA(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpNumberStr := lpNumberStr is String ? StrPtr(lpNumberStr) : lpNumberStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNumberFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a number string as a number string customized for a locale specified by identifier. (Unicode)
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetNumberFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PWSTR} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If this parameter does is not set to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale-specific string value for the negative sign.
     * @param {PWSTR} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string.
     * @param {Integer} cchNumber Size, in TCHAR values, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer, and does not use the <i>lpNumberStr</i> parameter.
     * @returns {Integer} Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpNumberStr</i> if successful. If the <i>cchNumber</i> parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnumberformatw
     * @since windows5.0
     */
    static GetNumberFormatW(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpNumberStr := lpNumberStr is String ? StrPtr(lpNumberStr) : lpNumberStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNumberFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a number string as a currency string for a locale specified by identifier. (ANSI)
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCurrencyFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the currency string. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling currency format. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PSTR} lpValue For details, see the <i>lpValue</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcurrencyformatex">GetCurrencyFormatEx</a>.
     * @param {Pointer<CURRENCYFMTA>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure, for example, the string value for the negative sign used by the locale.
     * @param {PSTR} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application sets this parameter to 0 if the function is to return the size of the buffer required to hold the formatted currency string. In this case, the <i>lpCurrencyStr</i> parameter is not used.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpCurrencyStr</i> if successful. If the <i>cchCurrency</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcurrencyformata
     * @since windows5.0
     */
    static GetCurrencyFormatA(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpCurrencyStr := lpCurrencyStr is String ? StrPtr(lpCurrencyStr) : lpCurrencyStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCurrencyFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a number string as a currency string for a locale specified by identifier. (Unicode)
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetCurrencyFormat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the currency string. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling currency format. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PWSTR} lpValue For details, see the <i>lpValue</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcurrencyformatex">GetCurrencyFormatEx</a>.
     * @param {Pointer<CURRENCYFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure, for example, the string value for the negative sign used by the locale.
     * @param {PWSTR} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application sets this parameter to 0 if the function is to return the size of the buffer required to hold the formatted currency string. In this case, the <i>lpCurrencyStr</i> parameter is not used.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpCurrencyStr</i> if successful. If the <i>cchCurrency</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcurrencyformatw
     * @since windows5.0
     */
    static GetCurrencyFormatW(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpCurrencyStr := lpCurrencyStr is String ? StrPtr(lpCurrencyStr) : lpCurrencyStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCurrencyFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates calendar information for a specified locale.NoteTo receive a calendar identifier in addition to calendar information, the application should use the EnumCalendarInfoEx function. (ANSI)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CALINFO_ENUMPROCA>} lpCalInfoEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317806(v=vs.85)">EnumCalendarInfoProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfoa
     * @since windows5.0
     */
    static EnumCalendarInfoA(lpCalInfoEnumProc, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoA", "ptr", lpCalInfoEnumProc, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates calendar information for a specified locale.NoteTo receive a calendar identifier in addition to calendar information, the application should use the EnumCalendarInfoEx function. (Unicode)
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumCalendarInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CALINFO_ENUMPROCW>} lpCalInfoEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317806(v=vs.85)">EnumCalendarInfoProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfow
     * @since windows5.0
     */
    static EnumCalendarInfoW(lpCalInfoEnumProc, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoW", "ptr", lpCalInfoEnumProc, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates calendar information for a locale specified by identifier.NoteAny application that runs only on WindowsVista and later should use EnumCalendarInfoExEx in preference to this function. (ANSI)
     * @remarks
     * This function enumerates calendar information for all applicable calendars for the specified locale, or for a single requested calendar, depending on the value of the <i>Calendar</i> parameter. The function enumerates the calendar information by calling the specified application-defined callback function. It passes the callback function a pointer to a buffer containing the requested calendar information. This process continues until <b>EnumCalendarInfoEx</b> finds the last applicable calendar or the callback function returns <b>FALSE</b>.
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumCalendarInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CALINFO_ENUMPROCEXA>} lpCalInfoEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317807(v=vs.85)">EnumCalendarInfoProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfoexa
     * @since windows5.0
     */
    static EnumCalendarInfoExA(lpCalInfoEnumProcEx, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExA", "ptr", lpCalInfoEnumProcEx, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates calendar information for a locale specified by identifier.NoteAny application that runs only on WindowsVista and later should use EnumCalendarInfoExEx in preference to this function. (Unicode)
     * @remarks
     * This function enumerates calendar information for all applicable calendars for the specified locale, or for a single requested calendar, depending on the value of the <i>Calendar</i> parameter. The function enumerates the calendar information by calling the specified application-defined callback function. It passes the callback function a pointer to a buffer containing the requested calendar information. This process continues until <b>EnumCalendarInfoEx</b> finds the last applicable calendar or the callback function returns <b>FALSE</b>.
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumCalendarInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CALINFO_ENUMPROCEXW>} lpCalInfoEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317807(v=vs.85)">EnumCalendarInfoProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfoexw
     * @since windows5.0
     */
    static EnumCalendarInfoExW(lpCalInfoEnumProcEx, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExW", "ptr", lpCalInfoEnumProcEx, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by identifier.NoteFor interoperability reasons, the application should prefer the EnumTimeFormatsEx function to EnumTimeFormats because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that runs only on WindowsVista and later should use EnumTimeFormatsEx. (ANSI)
     * @remarks
     * The function enumerates the time formats by passing a pointer to a buffer containing a time format to an application-defined callback function. The first value in the enumeration is always the user default (override) value. The function continues enumeration until the last time format is found or the callback function returns <b>FALSE</b>. 
     * 
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark ("?"). 
     * Note that any new values for <i>dwFlags</i> introduced in the future will not work with the ANSI version.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumTimeFormats as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<TIMEFMT_ENUMPROCA>} lpTimeFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317832(v=vs.85)">EnumTimeFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve time format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumtimeformatsa
     * @since windows5.0
     */
    static EnumTimeFormatsA(lpTimeFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsA", "ptr", lpTimeFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by identifier.NoteFor interoperability reasons, the application should prefer the EnumTimeFormatsEx function to EnumTimeFormats because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that runs only on WindowsVista and later should use EnumTimeFormatsEx. (Unicode)
     * @remarks
     * The function enumerates the time formats by passing a pointer to a buffer containing a time format to an application-defined callback function. The first value in the enumeration is always the user default (override) value. The function continues enumeration until the last time format is found or the callback function returns <b>FALSE</b>. 
     * 
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the call can succeed because the system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark ("?"). 
     * Note that any new values for <i>dwFlags</i> introduced in the future will not work with the ANSI version.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumTimeFormats as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<TIMEFMT_ENUMPROCW>} lpTimeFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317832(v=vs.85)">EnumTimeFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve time format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumtimeformatsw
     * @since windows5.0
     */
    static EnumTimeFormatsW(lpTimeFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsW", "ptr", lpTimeFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * For details of operation of this function, see Remarks in <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a>.
     * 
     * <div class="alert"><b>Note</b>To enumerate the date formats for locales with alternate calendars, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a>.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumDateFormats as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DATEFMT_ENUMPROCA>} lpDateFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317813(v=vs.85)">EnumDateFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsa
     * @since windows5.0
     */
    static EnumDateFormatsA(lpDateFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsA", "ptr", lpDateFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * For details of operation of this function, see Remarks in <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a>.
     * 
     * <div class="alert"><b>Note</b>To enumerate the date formats for locales with alternate calendars, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexa">EnumDateFormatsEx</a>.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumDateFormats as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DATEFMT_ENUMPROCW>} lpDateFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317813(v=vs.85)">EnumDateFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsw
     * @since windows5.0
     */
    static EnumDateFormatsW(lpDateFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsW", "ptr", lpDateFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale.NoteAny application that runs only on WindowsVista and later should use EnumDateFormatsExEx in preference to this function. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * The function enumerates the date formats by passing date format string pointers, one at a time, to the specified application-defined callback function. This process continues until <b>EnumDateFormatsEx</b> finds the last date format or the callback function returns <b>FALSE</b>.
     * 
     * This function enumerates all date formats for the specified locale, including alternate calendars, if any. However, the calendar identifier is not enumerated along with the date format, making formats for locales with alternate calendars difficult to use.
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * The application should use <b>EnumDateFormatsEx</b> (instead of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsa">EnumDateFormats</a>) to enumerate date formats for locales with alternate calendars.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumDateFormatsEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DATEFMT_ENUMPROCEXA>} lpDateFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317814(v=vs.85)">EnumDateFormatsProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsexa
     * @since windows5.0
     */
    static EnumDateFormatsExA(lpDateFmtEnumProcEx, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExA", "ptr", lpDateFmtEnumProcEx, "uint", Locale, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale.NoteAny application that runs only on WindowsVista and later should use EnumDateFormatsExEx in preference to this function. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * The function enumerates the date formats by passing date format string pointers, one at a time, to the specified application-defined callback function. This process continues until <b>EnumDateFormatsEx</b> finds the last date format or the callback function returns <b>FALSE</b>.
     * 
     * This function enumerates all date formats for the specified locale, including alternate calendars, if any. However, the calendar identifier is not enumerated along with the date format, making formats for locales with alternate calendars difficult to use.
     * 
     * This function can enumerate data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?).
     * 
     * The application should use <b>EnumDateFormatsEx</b> (instead of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsa">EnumDateFormats</a>) to enumerate date formats for locales with alternate calendars.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumDateFormatsEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DATEFMT_ENUMPROCEXW>} lpDateFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317814(v=vs.85)">EnumDateFormatsProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsexw
     * @since windows5.0
     */
    static EnumDateFormatsExW(lpDateFmtEnumProcEx, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExW", "ptr", lpDateFmtEnumProcEx, "uint", Locale, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if a language group is installed or supported on the operating system. For more information, see NLS Terminology.
     * @remarks
     * If the LGRPID_INSTALLED flag is specified and this function returns <b>TRUE</b>, the language group identifier is both supported and installed on the operating system.
     * 
     * If the LGRPID_SUPPORTED flag is specified and this function returns <b>TRUE</b>, the language group identifier is supported in the release, but not necessarily installed on the operating system.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns <b>TRUE</b> if the language group identifier passes the specified validity test, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidlanguagegroup
     * @since windows5.0
     */
    static IsValidLanguageGroup(LanguageGroup, dwFlags) {
        result := DllCall("KERNEL32.dll\IsValidLanguageGroup", "uint", LanguageGroup, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves information about the current version of a specified NLS capability for a locale specified by identifier.NoteFor interoperability reasons, the application should prefer the GetNLSVersionEx function to GetNLSVersion because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. This recommendation applies especially to custom locales, for which GetNLSVersionEx retrieves enough information to determine if sort behavior has changed. Any application that runs only on WindowsVista and later should use GetNLSVersionEx or at least pass the NLSVERSIONINFOEX structure when calling GetNLSVersion to obtain additional sorting versioning data.
     * @remarks
     * This function allows an application such as Active Directory to determine if an NLS change affects the locale identifier used for a particular index table. If it does not, there is no need to re-index the table. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * @param {Integer} Function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c>sizeof(NLSVERSIONINFO)</c>.
     * 
     * <div class="alert"><b>Note</b>On WindowsVista and later, the function can alternatively provide version information in an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure.</div>
     * <div></div>
     * @returns {BOOL} Returns <b>TRUE</b> if and only if the application has supplied valid values in <i>lpVersionInformation</i>, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnlsversion
     * @since windows6.0.6000
     */
    static GetNLSVersion(Function, Locale, lpVersionInformation) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNLSVersion", "uint", Function, "uint", Locale, "ptr", lpVersionInformation, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if the specified locale is installed or supported on the operating system. For more information, see Locales and Languages.
     * @remarks
     * If the LCID_INSTALLED flag is specified and this function returns a nonzero value, the locale identifier is both supported and installed on the operating system. Having an identifier installed implies that the full level of language support is available for the indicated locale. Full support includes code page translation tables, keyboard layouts, fonts, and sorting and locale data.
     * 
     * If LCID_SUPPORTED is specified and this function returns 0, the locale identifier is supported in the release, but not necessarily installed on the operating system.
     * 
     * This function can handle data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale to validate. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * <b>Windows Server2003, WindowsXP and Windows2000:</b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * <b>Windows Server2003, WindowsXP and Windows2000:</b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * <b>Windows Server2003, WindowsXP and Windows2000:</b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if the locale identifier passes the specified validity test. The function returns 0 if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidlocale
     * @since windows5.0
     */
    static IsValidLocale(Locale, dwFlags) {
        result := DllCall("KERNEL32.dll\IsValidLocale", "uint", Locale, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves information about a specified geographical location. (ANSI)
     * @remarks
     * If the application specifies GEO_RFC1766 for <i>GeoType</i>, it should specify a language identifier for <i>LangId</i> that is appropriate to the specified geographical location identifier. The appropriate language is either a locale-neutral language or one with a locale corresponding to the specified identifier. The resulting string, compliant with RFC 4646 (WindowsVista), constitutes a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>.
     * 
     * For example, if <i>Location</i> is specified as 0xF4 for United States, <i>GeoType</i> is specified as GEO_RFC1766, and <i>LangId</i> is specified as either 0x09 for locale-neutral English or 0x409 for English (United States), the function retrieves "en-US" on successful return. In fact, the function ignores the locale-specific portion of the language. Thus, if the application specifies <i>LangId</i> as 0x809 for English (United Kingdom), the function also writes "en-US" to <i>lpGeoData</i>.
     * 
     * Consider another example. If <i>Location</i> is specified as 0xF4 for United States, <i>GeoType</i> is specified as GEO_RFC1766, and <i>LangId</i> is specified as 0x04 for Chinese, the function retrieves "zh-US" on successful return. This is not the name of a supported locale.
     * 
     * If the application specifies GEO_LCID for <i>GeoType</i>, the function treats the language identifier as a locale identifier (LCID). It attempts to return the locale identifier if it is associated with the provided geographical identifier in some way. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetGeoInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Location Identifier for the geographical location for which to get information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/table-of-geographical-locations">Table of Geographical Locations</a>. You can obtain the available values by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeoid">EnumSystemGeoID</a>.
     * @param {Integer} GeoType Type of information to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. If the value of <i>GeoType</i> is GEO_LCID, the function retrieves a locale identifier. If the value of <i>GeoType</i> is GEO_RFC1766, the function retrieves a string name that is compliant with RFC 4646 (WindowsVista). For more information, see the Remarks section.
     * 
     * <b>WindowsXP:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is an 8-digit hexadecimal value.
     * 
     * <b>WindowsMe:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is a decimal value.
     * @param {PSTR} lpGeoData Pointer to the buffer in which this function retrieves the information.
     * @param {Integer} cchData Size of the buffer indicated by <i>lpGeoData</i>. The size is the number of bytes for the ANSI version of the function, or the number of words for the Unicode version. The application can set this parameter to 0 if the function is to return the required size of the buffer.
     * @param {Integer} LangId Identifier for the language, used with the value of <i>Location</i>. The application can set this parameter to 0, with GEO_RFC1766 or GEO_LCID specified for <i>GeoType</i>. This setting causes the function to retrieve the language identifier by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlangid">GetUserDefaultLangID</a>.
     * 
     * <div class="alert"><b>Note</b> The application must set this parameter to 0 if <i>GeoType</i> has any value other than GEO_RFC1766 or GEO_LCID.</div>
     * <div></div>
     * @returns {Integer} Returns the number of bytes (ANSI) or words (Unicode) of geographical location information retrieved in the output buffer. If <i>cchData</i> is set to 0, the function returns the required size for the buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getgeoinfoa
     * @since windows5.1.2600
     */
    static GetGeoInfoA(Location, GeoType, lpGeoData, cchData, LangId) {
        lpGeoData := lpGeoData is String ? StrPtr(lpGeoData) : lpGeoData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetGeoInfoA", "int", Location, "int", GeoType, "ptr", lpGeoData, "int", cchData, "ushort", LangId, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about a specified geographical location. (Unicode)
     * @remarks
     * If the application specifies GEO_RFC1766 for <i>GeoType</i>, it should specify a language identifier for <i>LangId</i> that is appropriate to the specified geographical location identifier. The appropriate language is either a locale-neutral language or one with a locale corresponding to the specified identifier. The resulting string, compliant with RFC 4646 (WindowsVista), constitutes a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>.
     * 
     * For example, if <i>Location</i> is specified as 0xF4 for United States, <i>GeoType</i> is specified as GEO_RFC1766, and <i>LangId</i> is specified as either 0x09 for locale-neutral English or 0x409 for English (United States), the function retrieves "en-US" on successful return. In fact, the function ignores the locale-specific portion of the language. Thus, if the application specifies <i>LangId</i> as 0x809 for English (United Kingdom), the function also writes "en-US" to <i>lpGeoData</i>.
     * 
     * Consider another example. If <i>Location</i> is specified as 0xF4 for United States, <i>GeoType</i> is specified as GEO_RFC1766, and <i>LangId</i> is specified as 0x04 for Chinese, the function retrieves "zh-US" on successful return. This is not the name of a supported locale.
     * 
     * If the application specifies GEO_LCID for <i>GeoType</i>, the function treats the language identifier as a locale identifier (LCID). It attempts to return the locale identifier if it is associated with the provided geographical identifier in some way. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines GetGeoInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} Location Identifier for the geographical location for which to get information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/table-of-geographical-locations">Table of Geographical Locations</a>. You can obtain the available values by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeoid">EnumSystemGeoID</a>.
     * @param {Integer} GeoType Type of information to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. If the value of <i>GeoType</i> is GEO_LCID, the function retrieves a locale identifier. If the value of <i>GeoType</i> is GEO_RFC1766, the function retrieves a string name that is compliant with RFC 4646 (WindowsVista). For more information, see the Remarks section.
     * 
     * <b>WindowsXP:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is an 8-digit hexadecimal value.
     * 
     * <b>WindowsMe:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is a decimal value.
     * @param {PWSTR} lpGeoData Pointer to the buffer in which this function retrieves the information.
     * @param {Integer} cchData Size of the buffer indicated by <i>lpGeoData</i>. The size is the number of bytes for the ANSI version of the function, or the number of words for the Unicode version. The application can set this parameter to 0 if the function is to return the required size of the buffer.
     * @param {Integer} LangId Identifier for the language, used with the value of <i>Location</i>. The application can set this parameter to 0, with GEO_RFC1766 or GEO_LCID specified for <i>GeoType</i>. This setting causes the function to retrieve the language identifier by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlangid">GetUserDefaultLangID</a>.
     * 
     * <div class="alert"><b>Note</b> The application must set this parameter to 0 if <i>GeoType</i> has any value other than GEO_RFC1766 or GEO_LCID.</div>
     * <div></div>
     * @returns {Integer} Returns the number of bytes (ANSI) or words (Unicode) of geographical location information retrieved in the output buffer. If <i>cchData</i> is set to 0, the function returns the required size for the buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getgeoinfow
     * @since windows5.1.2600
     */
    static GetGeoInfoW(Location, GeoType, lpGeoData, cchData, LangId) {
        lpGeoData := lpGeoData is String ? StrPtr(lpGeoData) : lpGeoData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetGeoInfoW", "int", Location, "int", GeoType, "ptr", lpGeoData, "int", cchData, "ushort", LangId, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about a geographic location that you specify by using a two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code.
     * @remarks
     * For information about two-letter ISO 3166-1 codes, see <a href="https://www.iso.org/iso-3166-country-codes.html">Country Codes - ISO 3166</a>.  For information about numeric UN M.49 codes, see <a href="https://unstats.un.org/unsd/methodology/m49/">Standard country or area codes for statistical use (M49)</a>.
     * @param {PWSTR} location The two-letter ISO 3166-1 or numeric UN M.49 code for the geographic location for which to get information.  To get the codes that are available on the operating system, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeonames">EnumSystemGeoNames</a>.
     * @param {Integer} geoType The type of information you want to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. The following values of the <b>SYSGEOTYPE</b> enumeration should not be used with <b>GetGeoInfoEx</b>:
     * 
     * <ul>
     * <li>
     * <b>GEO_ID</b>
     * 
     * This value is provided for backward compatibility.  Do not use this value in new applications, but use <b>GEO_NAME</b> instead.
     * 
     * </li>
     * <li>
     * <b>GEO_LCID</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * <li>
     * <b>GEO_NATION</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * <li>
     * <b>GEO_RFC1766</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * </ul>
     * @param {PWSTR} geoData A pointer to the buffer in which <b>GetGeoInfoEx</b> should write the  requested information.
     * @param {Integer} geoDataCount The size of the buffer to which the <i>GeoData</i> parameter points, in characters. Set this parameter to 0 to specify that the function should only return the size of the buffer required to store the requested information without writing the requested information to the buffer.
     * @returns {Integer} The number of bytes of geographical location information that the function wrote the output buffer. If <i>geoDataCount</i> is  0, the function returns the size of the buffer required to hold the information without writing the information to the buffer.
     * 
     * 0 indicates that the function did not succeed. To get extended error information,  call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The values supplied for flags were not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getgeoinfoex
     * @since windows10.0.16299
     */
    static GetGeoInfoEx(location, geoType, geoData, geoDataCount) {
        location := location is String ? StrPtr(location) : location
        geoData := geoData is String ? StrPtr(geoData) : geoData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetGeoInfoEx", "ptr", location, "int", geoType, "ptr", geoData, "int", geoDataCount, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the geographical location identifiers (type GEOID) that are available on the operating system.
     * @param {Integer} GeoClass Geographical location class for which to enumerate the identifiers. At present, only GEOCLASS_NATION is supported. This type causes the function to enumerate all geographical identifiers for nations on the operating system.
     * @param {Integer} ParentGeoId Reserved. This parameter must be 0.
     * @param {Pointer<GEO_ENUMPROC>} lpGeoEnumProc Pointer to the application-defined callback function <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317817(v=vs.85)">EnumGeoInfoProc</a>. The <b>EnumSystemGeoID</b> function makes repeated calls to this callback function until it returns <b>FALSE</b>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemgeoid
     * @since windows5.1.2600
     */
    static EnumSystemGeoID(GeoClass, ParentGeoId, lpGeoEnumProc) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemGeoID", "uint", GeoClass, "int", ParentGeoId, "ptr", lpGeoEnumProc, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the two-letter International Organization for Standardization (ISO) 3166-1 codes or numeric United Nations (UN) Series M, Number 49 (M.49) codes for geographical locations that are available on the operating system.
     * @remarks
     * For information about two-letter ISO 3166-1 codes, see <a href="https://www.iso.org/iso-3166-country-codes.html">Country Codes - ISO 3166</a>.  For information about numeric UN M.49 codes, see <a href="https://unstats.un.org/unsd/methodology/m49/">Standard country or area codes for statistical use (M49)</a>.
     * @param {Integer} geoClass The geographical location class for which to enumerate the available two-letter ISO 3166-1 or numeric UN M.49 codes.
     * @param {Pointer<GEO_ENUMNAMEPROC>} geoEnumProc Pointer to the application-defined callback function <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-geo_enumnameproc">Geo_EnumNameProc</a>. The <b>EnumSystemGeoNames</b> function calls this callback function for each of the two-letter ISO 3166-1 or numeric UN M.49 codes for geographical locations that are available on the operating system until callback function returns <b>FALSE</b>.
     * @param {LPARAM} data Application-specific information to pass to the callback function that the <i>genEnumProc</i> parameter specifies.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The values supplied for flags were not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was not valid. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemgeonames
     * @since windows10.0.16299
     */
    static EnumSystemGeoNames(geoClass, geoEnumProc, data) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemGeoNames", "uint", geoClass, "ptr", geoEnumProc, "ptr", data, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about the geographical location of the user. For more information, see Table of Geographical Locations.
     * @param {Integer} GeoClass Geographical location class to return. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeoclass">SYSGEOCLASS</a> enumeration.
     * @returns {Integer} Returns the geographical location identifier of the user if <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setusergeoid">SetUserGeoID</a> has been called before to set the identifier.
     * 
     * If no geographical location identifier has been set for the user, the function returns GEOID_NOT_AVAILABLE.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getusergeoid
     * @since windows5.1.2600
     */
    static GetUserGeoID(GeoClass) {
        result := DllCall("KERNEL32.dll\GetUserGeoID", "int", GeoClass, "int")
        return result
    }

    /**
     * Retrieves the two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code for the default geographical location of the user.
     * @remarks
     * For information about two-letter ISO 3166-1 codes, see <a href="https://www.iso.org/iso-3166-country-codes.html">Country Codes - ISO 3166</a>.  For information about numeric UN M.49 codes, see <a href="https://unstats.un.org/unsd/methodology/m49/">Standard country or area codes for statistical use (M49)</a>.
     * @param {PWSTR} geoName Pointer to a buffer in which this function should write the null-terminated two-letter ISO 3166-1 or numeric UN M.49 code for the default geographic location of the user.
     * @param {Integer} geoNameCount The size of the buffer that the <i>geoName</i> parameter specifies. If this value is zero, the function only returns the number of characters that function would copy to the output buffer, but does not write the name of the default geographic location of the user to the buffer.
     * @returns {Integer} The number of characters
     *   the function  would copy to the output buffer, if the value of the <i>geoNameCount</i> parameter is zero. Otherwise, the  number of characters that the function copied to the buffer that the <i>geoName</i> parameter specifies.
     * 
     * Zero indicates that the function failed. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BADDB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not read information from the registry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer that the  <i>geoName</i> parameter specifies is too small for the string. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultgeoname
     * @since windows10.0.16299
     */
    static GetUserDefaultGeoName(geoName, geoNameCount) {
        geoName := geoName is String ? StrPtr(geoName) : geoName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUserDefaultGeoName", "ptr", geoName, "int", geoNameCount, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets the geographical location identifier for the user. This identifier should have one of the values described in Table of Geographical Locations.
     * @remarks
     * This function writes to the registry the geographical location for a particular user instead of a particular application. This action affects the behavior of other applications run by the user. As a rule, the application should call this function only when the user has explicitly requested changes, but not for purely application-specific reasons.
     * 
     * <b>SetUserGeoID</b> is intended for use by applications that are designed to change user settings, such as the Windows Settings app. Other applications should not call this function.
     * @param {Integer} GeoId Identifier for the geographical location of the user.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.
     * 
     * <b>WindowsXP, Windows Server2003</b>: This function does not supply extended error information. Thus it is not appropriate for an application to call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> after this function. If the application does call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, it can return a value set by some previously called function.
     * 
     * If this function does not succeed, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setusergeoid
     * @since windows5.1.2600
     */
    static SetUserGeoID(GeoId) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetUserGeoID", "int", GeoId, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets the geographic location for the current user to the specified two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code.
     * @remarks
     * This function writes to the registry the geographical location for a particular user instead of a particular application. This action affects the behavior of other applications that the user runs. As a rule, call this function only when the user has explicitly requested changes, but not for purely application-specific reasons.
     * 
     * For information about two-letter ISO 3166-1 codes, see <a href="https://www.iso.org/iso-3166-country-codes.html">Country Codes - ISO 3166</a>.  For information about numeric UN M.49 codes, see <a href="https://unstats.un.org/unsd/methodology/m49/">Standard country or area codes for statistical use (M49)</a>.
     * 
     * <b>SetUserGeoName</b> is intended for use by applications that are designed to change user settings, such as the Windows Settings app. Other applications should not call this function.
     * @param {PWSTR} geoName The two-letter ISO 3166-1 or numeric UN M.49 code for the geographic location to set for the current user. To get the codes that are available on the operating system, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeonames">EnumSystemGeoNames</a>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.
     * 
     * If this function does not succeed, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DISABLED_BY_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The group policy of the computer or the user has forbidden this operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INTERNAL_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unexpected error occurred in the function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setusergeoname
     * @since windows10.0.16299
     */
    static SetUserGeoName(geoName) {
        geoName := geoName is String ? StrPtr(geoName) : geoName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetUserGeoName", "ptr", geoName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a default locale value to an actual locale identifier.
     * @remarks
     * A call to <b>ConvertDefaultLocale</b> specifying LOCALE_SYSTEM_DEFAULT is equivalent to a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getsystemdefaultlcid">GetSystemDefaultLCID</a>. A call to <b>ConvertDefaultLocale</b> specifying LOCALE_USER_DEFAULT is equivalent to a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlcid">GetUserDefaultLCID</a>.
     * @param {Integer} Locale Default locale identifier value to convert. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @returns {Integer} Returns the appropriate locale identifier if successful.
     * 
     * This function returns the value of the <i>Locale</i> parameter if it does not succeed. The function fails when the <i>Locale</i> value is not one of the default values listed above.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-convertdefaultlocale
     * @since windows5.0
     */
    static ConvertDefaultLocale(Locale) {
        result := DllCall("KERNEL32.dll\ConvertDefaultLocale", "uint", Locale, "uint")
        return result
    }

    /**
     * Retrieves the language identifier for the system default UI language of the operating system, also known as the &quot;install language&quot; on WindowsVista and later. For more information, see User Interface Language Management.
     * @remarks
     * This function never returns a language identifier for a Language Interface Pack (LIP). It also never returns a language identifier corresponding to the locale identifier [LOCALE_CUSTOM_UNSPECIFIED](/windows/desktop/Intl/locale-custom-constants) or [LOCALE_CUSTOM_UI_DEFAULT](/windows/desktop/Intl/locale-custom-constants).
     * 
     * Note that this function does not necessarily return the identifier for the first language in the system preferred UI languages list. Therefore the return might not match the first element retrieved by [GetSystemPreferredUILanguages](/windows/desktop/api/winnls/nf-winnls-getsystempreferreduilanguages).
     * @returns {Integer} Returns the language identifier for the system default UI language of the operating system. For more information, see the Remarks section.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystemdefaultuilanguage
     * @since windows5.0
     */
    static GetSystemDefaultUILanguage() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultUILanguage", "ushort")
        return result
    }

    /**
     * Returns the locale identifier of the current locale for the calling thread.NoteThis function can retrieve data that changes between releases, for example, due to a custom locale.
     * @remarks
     * When an application process launches, it uses the Standards and Formats variable for the locale. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/nls-terminology">NLS Terminology</a>.
     * 
     * When a new thread is created in a process, it inherits the locale of the creating thread. This locale can be either the default Standards and Formats locale or a different locale set for the creating thread in a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadlocale">SetThreadLocale</a>. <b>GetThreadLocale</b> and <b>SetThreadLocale</b> can be used to modify the locale of the new thread.
     * @returns {Integer} Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale associated with the current thread.
     * 
     * <b>WindowsVista</b>: This function can return the identifier of a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locale</a>. If the current thread locale is a custom locale, the function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>. If the current thread locale is a supplemental custom locale, the function can return <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. All supplemental locales share this locale identifier.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getthreadlocale
     * @since windows5.0
     */
    static GetThreadLocale() {
        result := DllCall("KERNEL32.dll\GetThreadLocale", "uint")
        return result
    }

    /**
     * Sets the current locale of the calling thread.
     * @remarks
     * When a thread is created, it uses the user locale. This value is returned by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlcid">GetUserDefaultLCID</a>. The user locale can be modified for future processes and thread creation using the regional and language options portion of the Control Panel. The thread locale can also be changed using <b>SetThreadLocale</b>.
     * 
     * <b>SetThreadLocale</b> affects the selection of resources with a <a href="https://docs.microsoft.com/windows/desktop/menurc/language-statement">LANGUAGE</a> statement. The statement affects such functions as <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createdialoga">CreateDialog</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dialogboxa">DialogBox</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadmenua">LoadMenu</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadstringa">LoadString</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a>. It sets the code page implied by CP_THREAD_ACP, but does not affect <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>.
     * 
     * <b>WindowsVista and later: </b> Do not use <b>SetThreadLocale</b> to select a user interface language. The resource loader selects the resource that is defined in the .rc file with a <a href="https://docs.microsoft.com/windows/desktop/menurc/language-statement">LANGUAGE</a> statement, or the application can use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a>. Additionally, the application can use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a>.
     *       
     * 
     * <b>Windows2000, WindowsXP:</b> Do not use <b>SetThreadLocale</b> to select a user interface language. To select the resource that is defined in the .rc file with a <a href="https://docs.microsoft.com/windows/desktop/menurc/language-statement">LANGUAGE</a> statement, the application must use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a> function.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @returns {BOOL} The function should return an LCID on success. This is the LCID of the previous thread locale.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setthreadlocale
     * @since windows5.0
     */
    static SetThreadLocale(Locale) {
        result := DllCall("KERNEL32.dll\SetThreadLocale", "uint", Locale, "int")
        return result
    }

    /**
     * Returns the language identifier for the user UI language for the current user.
     * @remarks
     * This function returns only a language identifier. An application can retrieve the language name using the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserpreferreduilanguages">GetUserPreferredUILanguages</a> function.
     * 
     * If the user UI language is part of a Language Interface Pack (LIP) and corresponds to a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>, this function returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>.
     * 
     * <b>WindowsMe, Windows2000, WindowsXP, Windows Server2003:</b> The <b>GetUserDefaultUILanguage</b> function retrieves the language identifier for the current user language. If MUI is not installed on the operating system, the function retrieves the default computer user interface language.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.UInt16 GetUserDefaultUILanguage();
     * 
     * ```
     * @returns {Integer} Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> for the user UI language for the current user.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultuilanguage
     * @since windows5.0
     */
    static GetUserDefaultUILanguage() {
        result := DllCall("KERNEL32.dll\GetUserDefaultUILanguage", "ushort")
        return result
    }

    /**
     * Returns the language identifier of the Region Format setting for the current user.
     * @remarks
     * The return value is not necessarily the same as that returned by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getsystemdefaultlangid">GetSystemDefaultLangID</a>, even for a single-user computer.
     * @returns {Integer} Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> for the current user as set under <b>Control Panel</b> &gt; <b>Clock, Language, and Region</b> &gt; <b>Change date, time, or number formats</b> &gt; <b>Formats</b> tab &gt; <b>Format</b> dropdown.
     * 
     * For more information on language identifiers, see <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultlangid
     * @since windows5.0
     */
    static GetUserDefaultLangID() {
        result := DllCall("KERNEL32.dll\GetUserDefaultLangID", "ushort")
        return result
    }

    /**
     * Returns the language identifier for the system locale.
     * @returns {Integer} Returns the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> for the system locale. This is  the language used when displaying text in programs that do not support Unicode. It is set by the Administrator under <b>Control Panel</b> &gt; <b>Clock, Language, and Region</b> &gt; <b>Change date, time, or number formats</b> &gt; <b>Administrative</b> tab.
     * 
     * For more information on language identifiers, see <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystemdefaultlangid
     * @since windows5.0
     */
    static GetSystemDefaultLangID() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultLangID", "ushort")
        return result
    }

    /**
     * Returns the locale identifier for the system locale.NoteAny application that runs only on WindowsVista and later should use GetSystemDefaultLocaleName in preference to this function.
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @returns {Integer} Returns the locale identifier for the system default locale, identified by <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystemdefaultlcid
     * @since windows5.0
     */
    static GetSystemDefaultLCID() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultLCID", "uint")
        return result
    }

    /**
     * Returns the locale identifier for the user default locale.CautionIf the user default locale is a custom locale, an application cannot accurately tag data with the value or exchange it.
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @returns {Integer} Returns the locale identifier for the user default locale, represented as <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>. If the user default locale is a custom locale, this function always returns <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>, regardless of the custom locale that is selected. For example, whether the user locale is Hawaiian (US), haw-US, or Fijiian (Fiji), fj-FJ, the function returns the same value.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultlcid
     * @since windows5.0
     */
    static GetUserDefaultLCID() {
        result := DllCall("KERNEL32.dll\GetUserDefaultLCID", "uint")
        return result
    }

    /**
     * Sets the user interface language for the current thread.
     * @remarks
     * When a thread is created, the thread user interface language setting is empty and the user interface for the thread is displayed in the user-selected language. This function enables the application to change the user interface language for the current running thread.
     * 
     * <b>WindowsVista and later:</b> Calling this function and specifying 0 for the language identifier is identical to calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a> with the MUI_CONSOLE_FILTER flag set. If the application specifies a valid nonzero language identifier, the function sets a particular user interface language for the thread. After specifying 0 for the language identifier, the application cannot use any of the following constants to correspond to a language identifier:
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * <b>WindowsXP:</b> When the application calls this function with a language identifier of 0, the function first verifies that the current user interface does not require Uniscribe, and that it is supported by the console <a href="https://docs.microsoft.com/windows/desktop/Intl/code-pages">code page</a>. If the user interface passes these tests, the function uses the supplied value. If not, the function changes the thread user interface language to a language that the Windows console can display. WindowsXP does not support a concept of thread user interface language separate from thread locale. Therefore, this function changes the thread locale on WindowsXP. It is easy for your application to set a thread to use the most appropriate language for console display, based on user and system preferred UI languages, the language for non-Unicode applications, and the capabilities of the console.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.UInt16 SetThreadUILanguage(
     *             System.UInt16 LangId
     *             );
     * 
     * ```
     * @param {Integer} LangId <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language identifier</a> for the user interface language for the thread.
     * 
     * <b>WindowsVista and later:</b> The application can specify a language identifier of 0 or a nonzero identifier. For more information, see the Remarks section.
     * 
     * <b>WindowsXP:</b> The application can only set this parameter to 0. This setting causes the function to select the language that best supports the console display. For more information, see the Remarks section.
     * @returns {Integer} Returns the input language identifier if successful. If the input identifier is nonzero, the function returns that value. If the language identifier is 0, the function always succeeds and returns the identifier of the language that best supports the Windows console. See the Remarks section.
     * 
     * If the input language identifier is nonzero and the function fails, the return value differs from the input language identifier. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setthreaduilanguage
     * @since windows5.1.2600
     */
    static SetThreadUILanguage(LangId) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetThreadUILanguage", "ushort", LangId, "ushort")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns the language identifier of the first user interface language for the current thread.
     * @remarks
     * Calling this function is identical to calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> with <i>dwFlags</i> set to MUI_MERGE_SYSTEM_FALLBACK | MUI_MERGE_USER_FALLBACK | MUI_LANGUAGE_ID and using the first language in the retrieved list.
     * 
     * The return value for this function does not provide useful information about a Language Interface Pack (LIP) language if that language corresponds to a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>. For such a language, the function returns the hexadecimal value "1400", which corresponds to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a> if that language is specified in the user preferred UI languages list. If the language is not specified in the user preferred UI languages list, the function returns the value "1000", corresponding to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.UInt16 GetThreadUILanguage();
     * 
     * ```
     * @returns {Integer} Returns the identifier for a language explicitly associated with the thread by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a>. Alternatively, if no language has been explicitly associated with the current thread, the identifier can indicate a user or system user interface language.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getthreaduilanguage
     * @since windows6.0.6000
     */
    static GetThreadUILanguage() {
        result := DllCall("KERNEL32.dll\GetThreadUILanguage", "ushort")
        return result
    }

    /**
     * Retrieves the process preferred UI languages. For more information, see User Interface Language Management.
     * @remarks
     * Depending on the flags specified by the application, this function can retrieve a list consisting of the process preferred UI languages. If it encounters a duplicate language, the function only retrieves the first instance of the duplicated language.
     * 
     * When MUI_LANGUAGE_ID is specified, the language strings retrieved will be hexadecimal language identifiers 
     * 
     * that do not include the leading 0x, and will be 4 characters in length. For example, en-US will be returned 
     * 
     * as "0409" and en as "0009".
     * 
     * <div class="alert"><b>Note</b>Use of MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID.</div>
     * <div></div>
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetProcessPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             ref System.UInt32 pulNumLanguages,
     *             System.IntPtr pwszLanguagesBuffer,
     *             ref System.UInt32 pcchLanguagesBuffer
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying the language format to use for the process preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Integer>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {PWSTR} pwszLanguagesBuffer Optional. Pointer to a double null-terminated multi-string buffer in which the function retrieves an ordered, null-delimited list in preference order, starting with the most preferable. 
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<Integer>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * If the process preferred UI language list is empty or if the languages specified for the process are not valid, the function succeeds and returns an empty multistring in <i>pwszLanguagesBuffer</i> and 2 in the <i>pcchLanguagesBuffer</i> parameter.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getprocesspreferreduilanguages
     * @since windows6.1
     */
    static GetProcessPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        pulNumLanguagesMarshal := pulNumLanguages is VarRef ? "uint*" : "ptr"
        pcchLanguagesBufferMarshal := pcchLanguagesBuffer is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetProcessPreferredUILanguages", "uint", dwFlags, pulNumLanguagesMarshal, pulNumLanguages, "ptr", pwszLanguagesBuffer, pcchLanguagesBufferMarshal, pcchLanguagesBuffer, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets the process preferred UI languages for the application process. For more information, see User Interface Language Management.
     * @remarks
     * Ideally, applications will call <b>SetProcessPreferredUILanguages</b> as soon as possible after launching.
     * 
     * After this function returns, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getprocesspreferreduilanguages">GetProcessPreferredUILanguages</a> to verify and examine the resulting language list.
     * 
     * When MUI_LANGUAGE_ID is specified, the input parameter language strings must use hexadecimal language 
     * 
     * identifiers that do not include the leading 0x, and are 4 characters in length. For example, en-US should be 
     * 
     * passed as "0409" and en as "0009".
     * 
     * <div class="alert"><b>Note</b>Use of MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID.</div>
     * <div></div>
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean SetProcessPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             System.String pwszLanguagesBuffer,
     *             ref System.UInt32 pulNumLanguages
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying the language format to use for the process preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * We recommend that you use MUI_LANGUAGE_NAME instead of MUI_LANGUAGE_ID.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwszLanguagesBuffer Pointer to a double null-terminated multi-string buffer that contains an ordered, null-delimited list in decreasing order of preference. If there are more than five languages in the buffer, the function only sets the first five valid languages.
     * 
     * Alternatively, this parameter can contain <b>NULL</b> if no language list is required. In this case, the function clears the preferred UI languages for the process.
     * @param {Pointer<Integer>} pulNumLanguages Pointer to the number of languages that has been set in the process language list from the input buffer, up to a maximum of five.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error code:
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. An invalid parameter is specified.</li>
     * </ul>
     * If the process preferred UI languages list is empty or if the languages specified for the process are not valid, the function succeeds and sets 0 in the <i>pulNumLanguages</i> parameter.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setprocesspreferreduilanguages
     * @since windows6.1
     */
    static SetProcessPreferredUILanguages(dwFlags, pwszLanguagesBuffer, pulNumLanguages) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        pulNumLanguagesMarshal := pulNumLanguages is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetProcessPreferredUILanguages", "uint", dwFlags, "ptr", pwszLanguagesBuffer, pulNumLanguagesMarshal, pulNumLanguages, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about the user preferred UI languages. For more information, see User Interface Language Management.
     * @remarks
     * When MUI_LANGUAGE_ID is specified, the language strings retrieved will be hexadecimal language identifiers that do not include the leading 0x, and will be 4 characters in length. For example, en-US will be returned as "0409" and en as "0009".
     * 
     * The display language cannot include more than one Language Interface Pack (LIP) language that corresponds to a [supplemental locale](/windows/desktop/Intl/custom-locales). If the list includes more than one of these languages, and if the application specifies MUI_LANGUAGE_ID in the call to the function, the language buffer contains "1400" for that language. This string corresponds to the hexadecimal value of [LOCALE_CUSTOM_UI_DEFAULT](/windows/desktop/Intl/locale-custom-constants).
     * 
     * The language list retrieved by this function has the following characteristics:
     * 
     * - Each language represents a valid NLS locale.
     * - Each language is installed on the operating system.
     * - The list contains one entry for each language, with no duplicate entries.
     * - If the list is empty or does not meet these validation criteria, the system preferred UI languages list is used instead.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the language format to use for the display language list. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * | Value | Meaning |
     * | --- | --- |
     * | **MUI_LANGUAGE_ID** | Retrieve the language strings in [language identifier](/windows/desktop/Intl/language-identifiers) |
     * | **MUI_LANGUAGE_NAME** | Retrieve the language strings in [language name](/windows/desktop/Intl/language-names) format. |
     * @param {Pointer<Integer>} pulNumLanguages Pointer to the number of languages retrieved in *pwszLanguagesBuffer*.
     * @param {PWSTR} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited display language list, in the format specified by *dwflags*. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to **NULL** and *pcchLanguagesBuffer* is set to 0, the function retrieves the required size of the language buffer in *pcchLanguagesBuffer*. The required size includes the two null characters.
     * @param {Pointer<Integer>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by *pwszLanguagesBuffer*. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and *pwszLanguagesBuffer* is set to **NULL**, the function retrieves the required size of the language buffer in *pcchLanguagesBuffer*.
     * @returns {BOOL} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [GetLastError function](../errhandlingapi/nf-errhandlingapi-getlasterror.md), which can return one of the following error codes:
     * 
     * - ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to **NULL**.
     * 
     * If the function fails for any other reason, the values of *pulNumLanguages* and *pcchLanguagesBuffer* are undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserpreferreduilanguages
     * @since windows6.0.6000
     */
    static GetUserPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        pulNumLanguagesMarshal := pulNumLanguages is VarRef ? "uint*" : "ptr"
        pcchLanguagesBufferMarshal := pcchLanguagesBuffer is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUserPreferredUILanguages", "uint", dwFlags, pulNumLanguagesMarshal, pulNumLanguages, "ptr", pwszLanguagesBuffer, pcchLanguagesBufferMarshal, pcchLanguagesBuffer, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the system preferred UI languages. For more information, see User Interface Language Management.
     * @remarks
     * When MUI_LANGUAGE_ID is specified, the language strings retrieved will be hexadecimal language identifiers 
     * 
     * that do not include the leading 0x, and will be 4 characters in length. For example, en-US will be returned 
     * 
     * as "0409" and en as "0009".
     * 
     * The system preferred UI languages cannot include more than one Language Interface Pack (LIP) language that corresponds to a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>. If the list includes more than one of these languages, and if the application specifies MUI_LANGUAGE_ID in the call to the function, the language buffer contains "1400" for that language. This string corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>.
     * 
     * If the MUI_MACHINE_LANGUAGE_SETTINGS flag is set, this function checks each language in the list that represents a valid NLS locale. The retrieved list can contain the following items:
     * 
     * <ul>
     * <li>Languages not installed on the system</li>
     * <li>Duplicate language entries</li>
     * <li>An empty string</li>
     * </ul>
     * If the MUI_MACHINE_LANGUAGE_SETTINGS flag is set and the system preferred UI languages list is empty, the function retrieves an empty string in the language buffer (two null characters, because it is a multistring buffer), 0 for the number of languages, and 2 for the buffer size.
     * 
     * If the MUI_MACHINE_LANGUAGE_SETTINGS flag is not set, the retrieved language list has the following characteristics:
     * 
     * <ul>
     * <li>Each language represents a valid NLS locale.</li>
     * <li>Each language is installed on the operating system.</li>
     * <li>The list contains one entry for each language, with no duplicate entries.</li>
     * </ul>
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetSystemPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             ref System.UInt32 pulNumLanguages,
     *             System.IntPtr pwszLanguagesBuffer,
     *             ref System.UInt32 pcchLanguagesBuffer
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format to use for the system preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flag specifies whether the function is to validate the list of languages (default) or retrieve the system preferred UI languages list exactly as it is stored in the registry.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MACHINE_LANGUAGE_SETTINGS"></a><a id="mui_machine_language_settings"></a><dl>
     * <dt><b>MUI_MACHINE_LANGUAGE_SETTINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the stored system preferred UI languages list, checking only to ensure that each language name corresponds to a valid NLS locale. If this flag is not set, the function retrieves the system preferred UI languages in <i>pwszLanguagesBuffer</i>, as long as the list is non-empty and meets the validation criteria. Otherwise, the function retrieves the system default user interface language in the language buffer.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Integer>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {PWSTR} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited system preferred UI languages list, in the format specified by <i>dwFlags</i>. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters
     * @param {Pointer<Integer>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.
     * </li>
     * </ul>
     * 
     * 
     * If the function fails for any other reason, the parameters <i>pulNumLanguages</i> and <i>pcchLanguagesBuffer</i> are undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystempreferreduilanguages
     * @since windows6.0.6000
     */
    static GetSystemPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        pulNumLanguagesMarshal := pulNumLanguages is VarRef ? "uint*" : "ptr"
        pcchLanguagesBufferMarshal := pcchLanguagesBuffer is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetSystemPreferredUILanguages", "uint", dwFlags, pulNumLanguagesMarshal, pulNumLanguages, "ptr", pwszLanguagesBuffer, pcchLanguagesBufferMarshal, pcchLanguagesBuffer, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the thread preferred UI languages for the current thread. For more information, see User Interface Language Management.
     * @remarks
     * Depending on the flags specified by the application, this function can retrieve a composite list consisting of the thread preferred UI languages, process preferred UI languages, user preferred UI languages or system preferred UI languages, and the system default UI language. If it encounters a duplicate language, the function only retrieves the first language.
     * 
     * If the application has called <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a> with the MUI_CONSOLE_FILTER or MUI_COMPLEX_SCRIPT_FILTER flag, <b>GetThreadPreferredUILanguages</b> filters the languages in the result list. The function replaces the languages the console cannot display with a substitute language. The substitution for a language is determined from the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sconsolefallbackname">LOCALE_SCONSOLEFALLBACKNAME</a> for the language. For more console information, see the description of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a>.
     * 
     * Use of MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID because the MUI_LANGUAGE_NAME flag can do a better job of handling Language Interface Pack (LIP) languages that correspond to <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locales</a>.
     * 
     * When MUI_LANGUAGE_ID is specified, the language strings retrieved will be hexadecimal language identifiers 
     * 
     * that do not include the leading 0x, and will be 4 characters in length. For example, en-US will be returned 
     * 
     * as "0409" and en as "0009".
     * 
     * If the application sets the MUI_LANGUAGE_ID flag, the thread preferred UI languages can include one or more languages that correspond to supplemental locales. On successful return from the function, the language buffer contains "1400" for any language corresponding to a supplemental locale. There can be only one such language in this list. The string "1400" corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>. Also on successful return from the function, the <i>pwszLanguagesBuffer</i> contains "1000" for any other language that corresponds to a supplemental locale. The string "1000" corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>, which is not useful as an input to any function, because it cannot distinguish among supplemental locales.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetThreadPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             ref System.UInt32 pulNumLanguages,
     *             System.IntPtr pwszLanguagesBuffer,
     *             ref System.UInt32 pcchLanguagesBuffer
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the language format to use for the thread preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags specify filtering for the function to use in retrieving the thread preferred UI languages. The default flag is MUI_MERGE_USER_FALLBACK.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MERGE_SYSTEM_FALLBACK"></a><a id="mui_merge_system_fallback"></a><dl>
     * <dt><b>MUI_MERGE_SYSTEM_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system fallback to retrieve a list that corresponds exactly to the language list used by the resource loader. This flag can be used only in combination with MUI_MERGE_USER_FALLBACK. Using the flags in combination alters the usual effect of MUI_MERGE_USER_FALLBACK by including fallback and neutral languages in the list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MERGE_USER_FALLBACK"></a><a id="mui_merge_user_fallback"></a><dl>
     * <dt><b>MUI_MERGE_USER_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve a composite list consisting of the thread preferred UI languages, followed by process preferred UI languages, followed by any user preferred UI languages that are distinct from these, followed by the system default UI language, if it is not already in the list. If the user preferred UI languages list is empty, the function retrieves the system preferred UI languages. This flag cannot be combined with MUI_THREAD_LANGUAGES.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_THREAD_LANGUAGES"></a><a id="mui_thread_languages"></a><dl>
     * <dt><b>MUI_THREAD_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the thread preferred UI languages for the current thread, or an empty list if no preferred languages are set for the current thread. This flag cannot be combined with MUI_MERGE_USER_FALLBACK or MUI_MERGE_SYSTEM_FALLBACK.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_UI_FALLBACK"></a><a id="mui_ui_fallback"></a><dl>
     * <dt><b>MUI_UI_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve a complete thread preferred UI languages list along with associated fallback and neutral languages. Use of this flag is equivalent to combining MUI_MERGE_SYSTEM_FALLBACK and MUI_MERGE_USER_FALLBACK. (Applicable only for Windows7 and later).
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Integer>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {PWSTR} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited thread preferred UI languages list, in the format specified by <i>dwFlags</i>. This list ends with two null characters. 
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<Integer>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns one of the following error codes:
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * </ul>
     * 
     * 
     * If the function fails for any other reason, the parameters <i>pulNumLanguages</i> and <i>pcchLanguagesBuffer</i> are undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getthreadpreferreduilanguages
     * @since windows6.0.6000
     */
    static GetThreadPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        pulNumLanguagesMarshal := pulNumLanguages is VarRef ? "uint*" : "ptr"
        pcchLanguagesBufferMarshal := pcchLanguagesBuffer is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetThreadPreferredUILanguages", "uint", dwFlags, pulNumLanguagesMarshal, pulNumLanguages, "ptr", pwszLanguagesBuffer, pcchLanguagesBufferMarshal, pcchLanguagesBuffer, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets the thread preferred UI languages for the current thread. For more information, see User Interface Language Management.
     * @remarks
     * When the application loads resources after a call to this function, the thread-specific preferences take priority over the languages preferred by the user.
     * 
     * This function can set up to five preferred languages for the thread, in order of preference. If the language buffer contains more than five valid languages, the function sets the first five valid languages and ignores the rest.
     * 
     * If the application calls this function with the MUI_LANGUAGE_ID flag set, the strings in the language list must use hexadecimal language 
     * 
     * identifiers that do not include the leading 0x, and are 4 characters in length. For example, en-US should be 
     * 
     * passed as "0409" and en as "0009".
     * 
     * When MUI_LANGUAGE_ID is specified, the hexadecimal values in the language list must each represent an actual language identifier. In particular, the following locale identifier values cannot be used to correspond to the language identifier: 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * Calling this function with an empty language list and setting the MUI_CONSOLE_FILTER flag has the same effect as calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a> with the language identifier set to 0. The language is set appropriately for use in a console window.
     * 
     * After this function returns, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> to verify and examine the resulting language list. When MUI_CONSOLE_FILTER or MUI_COMPLEX_FILTER has been set by <b>SetThreadPreferredUILanguages</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> function replaces with the fallback the languages the console cannot display using the current operating system language setting. The fallback for a language is determined based on the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sconsolefallbackname">LOCALE_SCONSOLEFALLBACKNAME</a> for the language.
     * 
     * Setting the MUI_COMPLEX_SCRIPT_FILTER flag in the call to <b>SetThreadPreferredUILanguages</b> causes <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a>  to remove languages that the console cannot display with languages that can only be rendered using <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe">Uniscribe</a>, and insert the fallback language as the ultimate fallback. Examples of such languages are Arabic or the various Indic languages.
     * 
     * Setting the MUI_CONSOLE_FILTER flag in the call to <b>SetThreadPreferredUILanguages</b> causes <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> to remove languages the console cannot display with the current system setting and insert the fallback language as the ultimate fallback, because the console is limited to displaying characters from a single <a href="https://docs.microsoft.com/windows/desktop/Intl/code-pages">code page</a>. For example, if the user language is Japanese (Japan), but the current console code page is the code page for Russian (Russia), the console displays Japanese-language text mostly as a series of character-not-found symbols. <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> chooses a language from the fallback list that will be legible in the console.
     * 
     * <div class="alert"><b>Note</b>Resource-loading functions, such as <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadstringa">LoadString</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a>, also make calls to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a>.</div>
     * <div></div>
     * To change the code page, the application uses the <b>setlocale</b> function, or equivalent.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean SetThreadPreferredUILanguages(
     *             System.UInt32 dwFlags,
     *             System.String pwszLanguagesBuffer,
     *             ref System.UInt32 pulNumLanguages
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying format and filtering for the languages to set. 
     * 
     * The following <i>format flags</i> specify the language format to use for the thread preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * We recommend that you use MUI_LANGUAGE_NAME instead of MUI_LANGUAGE_ID.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following <i>filtering flags</i> specify filtering for the language list. The flags are mutually exclusive. By default, neither MUI_COMPLEX_SCRIPT_FILTER nor MUI_CONSOLE_FILTER is set. For more information about the filtering flags, see the Remarks section.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_COMPLEX_SCRIPT_FILTER"></a><a id="mui_complex_script_filter"></a><dl>
     * <dt><b>MUI_COMPLEX_SCRIPT_FILTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> should replace with the appropriate fallback all languages having <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">complex scripts</a>. When this flag is specified, <b>NULL</b> must be passed for all other parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_CONSOLE_FILTER"></a><a id="mui_console_filter"></a><dl>
     * <dt><b>MUI_CONSOLE_FILTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> should replace with the appropriate fallback all languages that cannot display properly in a console window with the current operating system settings. When this flag is specified, <b>NULL</b> must be passed for all other parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_RESET_FILTERS"></a><a id="mui_reset_filters"></a><dl>
     * <dt><b>MUI_RESET_FILTERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reset the filtering for the language list by removing any other filter settings. When this flag is specified, <b>NULL</b> must be passed for all other parameters. After setting this flag, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> to retrieve the complete unfiltered list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwszLanguagesBuffer Pointer to a double null-terminated multi-string buffer that contains an ordered, null-delimited list, in the format specified by <i>dwFlags</i>.
     * 
     * To clear the thread preferred UI languages list, an application sets this parameter to a null string or an empty double null-terminated string. 
     * If an application clears a language list, it should specify either a format flag or 0 for the <i>dwFlags</i> parameter.
     * 
     * When the application specifies one of the filtering flags, it must set this parameter to <b>NULL</b>. In this case, the function succeeds, but does not reset the thread preferred languages.
     * @param {Pointer<Integer>} pulNumLanguages Pointer to the number of languages that the function has set in the thread preferred UI languages list. When the application specifies one of the filtering flags, the function must set this parameter to <b>NULL</b>.
     * @returns {BOOL} Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-setthreadpreferreduilanguages
     * @since windows6.0.6000
     */
    static SetThreadPreferredUILanguages(dwFlags, pwszLanguagesBuffer, pulNumLanguages) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        pulNumLanguagesMarshal := pulNumLanguages is VarRef ? "uint*" : "ptr"

        result := DllCall("KERNEL32.dll\SetThreadPreferredUILanguages", "uint", dwFlags, "ptr", pwszLanguagesBuffer, pulNumLanguagesMarshal, pulNumLanguages, "int")
        return result
    }

    /**
     * Retrieves resource-related information about a file.
     * @remarks
     * For the MUI_QUERY_LANGUAGE_NAME flag, this function retrieves an offset, in bytes, from the beginning of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> in the <b>dwLanguageNameOffset</b> member.
     * 
     * The following is sample code that accesses the language name associated with the input file:
     * 
     * 
     * ```cpp
     * LPWSTR lpszLang = reinterpret_cast<LPWSTR>(
     *         reinterpret_cast<BYTE*>(pFileMUIInfo) +
     *         pFileMUIInfo->dwLanguageNameOffset);
     * 
     * ```
     * 
     * 
     * For the MUI_QUERY_RESOURCE_TYPES flag, this function retrieves language-specific resource file information in the following <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> members:
     * 
     * <ul>
     * <li>The <b>dwTypeIDMUIOffset</b> member contains the offset to an array of identifiers of resources contained in the language-specific resource file.</li>
     * <li>The <b>dwTypeIDMUISize</b> member contains the size of the array of resource identifiers for the language-specific resource file.</li>
     * <li>The <b>dwTypeNameMUIOffset</b> member contains the offset to an array of names of resources contained in the language-specific resource file.</li>
     * </ul>
     * If the input file is an LN file, the function fills in all the above structure members. In addition, it fills in the following members:
     * 
     * <ul>
     * <li>The <b>dwTypeIDMainOffset</b> member contains the offset to an array of identifiers of resources contained in the LN file.</li>
     * <li>The <b>dwTypeIDMainSize</b> member contains the size of the array of resource identifiers for the LN file.</li>
     * <li>The <b>dwTypeNameMainOffset</b> member contains the offset to an array of names of resources contained in the file.</li>
     * </ul>
     * The following is sample code that accesses the array of resource identifiers in the LN file.
     * 
     * 
     * ```cpp
     * DWORD *pdwTypeID = reinterpret_cast<DWORD *>(
     *         reinterpret_cast<BYTE*>(pFileMUIInfo) +
     *         pFileMUIInfo->dwTypeIDMainOffset);
     * 
     * ```
     * 
     * 
     * <div class="alert"><b>Note</b>The lists of language-specific resources are accessed in the same way.</div>
     * <div></div>
     * The following is sample code to access the multistring array of resource names in the LN file.
     * 
     * 
     * ```cpp
     * LPWSTR lpszNames = reinterpret_cast<LPWSTR>(
     *         reinterpret_cast<BYTE*>(pFileMUIInfo) +
     *         pFileMUIInfo->dwTypeNameMainOffset);
     * 
     * ```
     * 
     * 
     * <div class="alert"><b>Note</b>The lists of language-specific resources are accessed in the same way.</div>
     * <div></div>
     * Each of the code samples uses two reinterpret casts. First the code casts to BYTE* so that the pointer arithmetic for the offset is done in bytes. Then the code casts the resulting pointer to the desired type.
     * 
     * Another approach is to write the following instead of the code shown in the samples. The effect is the same and the choice is strictly one of style.
     * 
     * 
     * ```cpp
     * DWORD ix = pFileMUIInfo->dwLanguageNameOffset - 
     *         offsetof(struct _FILEMUIINFO, abBuffer);
     * LPWSTR lpszLang = reinterpret_cast<LPWSTR>(&(pFileMUIInfo->abBuffer[ix]));
     * 
     * ```
     * 
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetFileMUIInfo(
     *             System.UInt32 dwFlags,
     *             System.String pcwszFilePath,
     *             ref FILEMUIINFO pFileMUIInfo,
     *             ref System.UInt32 pcbFileMUIInfo
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags specifying the information to retrieve. Any combination of the following flags is allowed. The default value of the flags is MUI_QUERY_TYPE | MUI_QUERY_CHECKSUM.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_QUERY_TYPE"></a><a id="mui_query_type"></a><dl>
     * <dt><b>MUI_QUERY_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * @param {PWSTR} pcwszFilePath Pointer to a null-terminated string indicating the path to the file. Typically the file is either an LN file or a language-specific resource file. If it is not one of these types, the only significant value that the function retrieves is MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL. The function only retrieves this value if the MUI_QUERY_RESOURCE_TYPES flag is set.
     * @param {Pointer} pFileMUIInfo Pointer to a buffer containing file information in a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure and possibly in data following that structure. The information buffer might have to be much larger than the size of the structure itself. Depending on flag settings, the function can store considerable information following the structure, at offsets retrieved in the structure. For more information, see the Remarks section.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if <i>pcbFileMUIInfo</i> is set to 0. In this case, the function retrieves the required size for the information buffer in <i>pcbFileMUIInfo</i>.
     * 
     * <div class="alert"><b>Note</b>If the value of <i>pFileMUIInfo</i> is not <b>NULL</b>, the <b>dwSize</b> member must be set to the size of the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure (including the information buffer), and the <b>dwVersion</b> member must be set to the current version of 0x001.</div>
     * <div></div>
     * @param {Pointer<Integer>} pcbFileMUIInfo Pointer to the buffer size, in bytes, for the file information indicated by <i>pFileMUIInfo</i>. On successful return from the function, this parameter contains the size of the retrieved file information buffer and the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure that contains it.
     * 
     * Alternatively, the application can set this parameter to 0 if it sets <b>NULL</b> in <i>pFileMUIInfo</i>. In this case, the function retrieves the required file information buffer size in <i>pcbFileMUIInfo</i>. To allocate the correct amount of memory, this value should be added to the size of the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure itself.
     * 
     * <div class="alert"><b>Note</b>The value of this parameter must match the value of the <b>dwSize</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> if the value of <i>pFileMUIInfo</i> is not <b>NULL</b>.</div>
     * <div></div>
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getfilemuiinfo
     * @since windows6.0.6000
     */
    static GetFileMUIInfo(dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo) {
        pcwszFilePath := pcwszFilePath is String ? StrPtr(pcwszFilePath) : pcwszFilePath

        pcbFileMUIInfoMarshal := pcbFileMUIInfo is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileMUIInfo", "uint", dwFlags, "ptr", pcwszFilePath, "ptr", pFileMUIInfo, pcbFileMUIInfoMarshal, pcbFileMUIInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to all language-specific resource files associated with the supplied LN file. The application must call this function repeatedly to get the path for each resource file.
     * @remarks
     * This function verifies that language-specific resource files exist, but it does not verify that they are correct. It requires the resource files to be stored according to the storage convention explained in <a href="https://docs.microsoft.com/windows/desktop/Intl/application-deployment">Application Deployment</a>.
     * 
     * If the call to this function specifies the MUI_LANGUAGE_ID flag, the supplied language string must 
     * 
     * use a hexadecimal language identifier that does not include the leading 0x, and is 4 characters in length. 
     * 
     * For example, en-US should be passed as "0409" and en as "0009". The returned language string will be in the 
     * 
     * same format.
     * 
     * When MUI_LANGUAGE_ID is specified, each hexadecimal value in the supplied language string must represent an actual language identifier. In particular, the values corresponding to the following locales cannot be specified: 
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * To receive enumerated information, the application should call this function repeatedly until it returns <b>FALSE</b>, leaving the contents of <i>pululEnumerator</i> unchanged between calls. Since each call retrieves the path to a different language-specific resource file, the application must clear the language buffer to an empty string between calls. If the application does not do this, the input value of <i>pwszLanguage</i> takes precedence over the setting of <i>dwFlags</i>.
     * 
     * Typically the resource loader is used to find resource files. However, your application can also use this function to find the files. If the input file path is for an LN file, the function attaches a suffix of ".mui" when looking for the corresponding language-specific resource files.
     * 
     * For example, the function retrieves the following files when the application passes the string "C:\mydir\Example1.dll" in <i>pcwszFilePath</i> as the root file path, with <i>dwFlags</i> set to MUI_LANGUAGE_NAME | MUI_USE_SEARCH_ALL_LANGUAGES:
     * 
     * <ul>
     * <li>C:\mydir\Example1.dll<ul>
     * <li>C:\mydir\en-US\Example1.dll.mui</li>
     * <li>C:\mydir\ja-JP\Example1.dll.mui</li>
     * </ul>
     * </li>
     * </ul>
     * The first call to the function sets <i>pwszFileMUIPath</i>  to "C:\mydir\en-US\Example1.dll.mui". The second call sets the file path to "C:\mydir\ja-JP\Example1.dll.mui". The function returns <b>FALSE</b> when called a third time and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_NO_MORE_FILES.
     * 
     * If the file indicated by <i>pcwszFilePath</i> does not have resource configuration data, or if the file does not exist, the function leaves the file name as it is when looking for the corresponding language-specific resource files.
     * 
     * For example, the application passes the string "C:\mydir\Example2.txt" in <i>pcwszFilePath</i> as the root file path, with <i>dwFlags</i> set to MUI_LANGUAGE_NAME | MUI_USER_PREFERRED_UI_LANGUAGES. Let's consider the case in which the user preferred UI languages (in order) are Catalan, "ca-ES", and Spanish (Spain), "es-ES", and where the following files exist:
     * 
     * <ul>
     * <li>(no corresponding file in C:\mydir)
     *             <ul>
     * <li>C:\mydir\en-US\Example2.txt</li>
     * <li>C:\mydir\en\Example2.txt</li>
     * <li>C:\mydir\es-ES\Example2.txt</li>
     * <li>C:\mydir\es\Example2.txt</li>
     * <li>C:\mydir\ja-JP\Example2.txt</li>
     * </ul>
     * </li>
     * </ul>
     * The first call to the function determines that there are no resources for "ca-ES" or for the neutral language "ca". The function then tries the next option, "es-ES", for which it succeeds in finding a match. Before returning, the function sets <i>pwszFileMUIPath</i>  to "C:\mydir\es-ES\Example2.txt". A second application call to the function continues the enumeration by setting <i>pwszFileMUIPath</i> to "C:\mydir\es\Example2.txt".
     * 
     * If the target file and its associated resource files are actually <a href="https://docs.microsoft.com/windows/desktop/SbsCs/isolated-applications-and-side-by-side-assemblies-portal">Side-by-side enabled assemblies</a>, GetFileMUIPath cannot be used to retrieve the path to the resource file. Please refer to <a href="https://docs.microsoft.com/windows/desktop/SbsCs/using-assemblies-with-a-multilanguage-user-interface">Using Assemblies with a Multilanguage User Interface</a> for details on how to use Side-by-side assemblies with MUI support.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetFileMUIPath(
     *             System.UInt32 dwFlags,
     *             System.String pcwszFilePath,
     *             System.Text.StringBuilder pwszLanguage,
     *             ref System.UInt32 pcchLanguage,
     *             System.Text.StringBuilder pwszFileMUIPath,
     *             ref System.UInt32 pcchFileMUIPath,
     *             ref System.UInt64 pululEnumerator
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language indicated by <i>pwszLanguage</i>. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language string in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language string in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags specify the filtering for the function to use in locating language-specific resource files if <i>pwszLanguage</i> is set to <b>NULL</b>. The filtering flags are mutually exclusive, and the default is MUI_USER_PREFERRED_UI_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USE_SEARCH_ALL_LANGUAGES"></a><a id="mui_use_search_all_languages"></a><dl>
     * <dt><b>MUI_USE_SEARCH_ALL_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve all language-specific resource files for the path indicated by <i>pcwszFilePath</i>, without considering file licensing. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USER_PREFERRED_UI_LANGUAGES"></a><a id="mui_user_preferred_ui_languages"></a><dl>
     * <dt><b>MUI_USER_PREFERRED_UI_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the files that implement languages in the fallback list. Successive calls enumerate the successive fallbacks, in the appropriate order. The first file indicated by the output value of <i>pcchFileMUIPath</i> should be the best fit. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USE_INSTALLED_LANGUAGES"></a><a id="mui_use_installed_languages"></a><dl>
     * <dt><b>MUI_USE_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the files for the languages installed on the computer. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags allow the user to indicate the type of file that is specified by <i>pcwszFilePath</i> so that the function can determine if it must add ".mui" to the file name. The flags are mutually exclusive. If the application passes both flags, the function fails. If the application passes neither flag, the function checks the file in the root folder to verify the file type and decide on file naming.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANG_NEUTRAL_PE_FILE"></a><a id="mui_lang_neutral_pe_file"></a><dl>
     * <dt><b>MUI_LANG_NEUTRAL_PE_FILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not verify the file passed in <i>pcwszFilePath</i> and append ".mui" to the file name before processing. For example, change Abc.exe to Abc.exe.mui.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_NON_LANG_NEUTRAL_FILE"></a><a id="mui_non_lang_neutral_file"></a><dl>
     * <dt><b>MUI_NON_LANG_NEUTRAL_FILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not verify the file passed in <i>pcwszFilePath</i> and do not append ".mui" to the file name before processing. For example, use Abc.txt or Abc.chm.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pcwszFilePath Pointer to a null-terminated string specifying a file path. The path is either for an existing LN file or for a file such as a .txt, .inf, or .msc file. If the file is an LN file, the function looks for files containing the associated language-specific resources. For all other types of files, the function seeks files that correspond exactly to the file name and path indicated. Your application can overwrite the behavior of the file type check by using the MUI_LANG_NEUTRAL_PE_FILE or MUI_NON_LANG_NEUTRAL_FILE flag. For more information, see the Remarks section.
     * 
     * <div class="alert"><b>Note</b>The supplied file path can be a network path: for example, "\\machinename\c$\windows\system32\notepad.exe".</div>
     * <div></div>
     * @param {PWSTR} pwszLanguage Pointer to a buffer containing a language string. On input, this buffer contains the language identifier or language name for which the application should find language-specific resource files, depending on the settings of <i>dwFlags</i>. On successful return from the function, this parameter contains the language of the language-specific resource file that the function has found.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b>, with the value referenced by  <i>pcchLanguage</i> set to 0. In this case, the function retrieves the required buffer size in <i>pcchLanguage</i>.
     * @param {Pointer<Integer>} pcchLanguage Pointer to the buffer size, in characters, for the language string indicated by <i>pwszLanguage</i>. If the application sets the value referenced by this parameter to 0 and  passes <b>NULL</b> for <i>pwszLanguage</i>, then the required buffer size will be returned in <i>pcchLanguage</i> and the returned buffer size is always <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>, because the function is typically called multiple times in succession. The function cannot determine the exact size of the language name for all successive calls, and cannot extend the buffer on subsequent calls. Thus LOCALE_NAME_MAX_LENGTH is the only safe maximum.
     * @param {PWSTR} pwszFileMUIPath Pointer to a buffer containing the path to the language-specific resource file. It is strongly recommended to allocate this buffer to be of size MAX_PATH.
     * 
     * Alternatively, this parameter can retrieve <b>NULL</b> if the value referenced by <i>pcchFileMUIPath</i> is set to 0. In this case, the function retrieves the required size for the file path buffer in <i>pcchFileMUIPath</i>.
     * @param {Pointer<Integer>} pcchFileMUIPath Pointer to the buffer size, in characters, for the file path indicated by <i>pwszFileMUIPath</i>. On successful return from the function, this parameter indicates the size of the retrieved file path. If the application sets the value referenced by this parameter to 0, the function retrieves <b>NULL</b> for <i>pwszFileMUIPath</i>, the required buffer size will be returned in <i>pcchFileMUIPath</i> and the returned buffer size is always MAX_PATH, because the function is typically called multiple times in succession. The function cannot determine the exact size of the path for all successive calls, and cannot extend the buffer on subsequent calls. Thus MAX_PATH is the only safe maximum.
     * @param {Pointer<Integer>} pululEnumerator Pointer to an enumeration variable. The first time this function is called, the value of the variable should be 0. Between subsequent calls, the application should not change the value of this parameter. After the function retrieves all possible language-specific resource file paths, it returns <b>FALSE</b>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. If the function fails, the output parameters do not change.
     * 
     * To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_NO_MORE_FILES. There were no more files to process.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getfilemuipath
     * @since windows6.0.6000
     */
    static GetFileMUIPath(dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator) {
        pcwszFilePath := pcwszFilePath is String ? StrPtr(pcwszFilePath) : pcwszFilePath
        pwszLanguage := pwszLanguage is String ? StrPtr(pwszLanguage) : pwszLanguage
        pwszFileMUIPath := pwszFileMUIPath is String ? StrPtr(pwszFileMUIPath) : pwszFileMUIPath

        pcchLanguageMarshal := pcchLanguage is VarRef ? "uint*" : "ptr"
        pcchFileMUIPathMarshal := pcchFileMUIPath is VarRef ? "uint*" : "ptr"
        pululEnumeratorMarshal := pululEnumerator is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileMUIPath", "uint", dwFlags, "ptr", pcwszFilePath, "ptr", pwszLanguage, pcchLanguageMarshal, pcchLanguage, "ptr", pwszFileMUIPath, pcchFileMUIPathMarshal, pcchFileMUIPath, pululEnumeratorMarshal, pululEnumerator, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a variety of information about an installed UI language
     * @remarks
     * MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID because it allows the function to do a better job of handling LIP languages that do not correspond to predefined locales, but instead correspond to a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>. LIP languages that correspond to predefined locales are handled just like non-LIP languages.
     * 
     * If the MUI_LANGUAGE_ID flag is specified, the supplied language strings must 
     * 
     * use hexadecimal language identifiers that do not include the leading 0x, and are 4 characters in length. 
     * 
     * For example, en-US should be passed as "0409" and en as "0009". The returned language strings will be in the 
     * 
     * same format.
     * 
     * When MUI_LANGUAGE_ID is specified, and if there is such a language in the user preferred UI languages list, there can be only one such language in the list. That language can be specified in <i>pwmszLanguage</i> as "1400", which corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>. No other such language can be specified using MUI_LANGUAGE_ID. Using "1000", which corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>, in the string indicated by <i>pwmszLanguage</i> will result in an ERROR_INVALID_PARAMETER code.
     * 
     * A partially localized language can have a fallback language that is partially localized, requiring repeated calls to <b>GetUILanguageInfo</b> to obtain full information. Consider the case of a partially localized language Lang1 that offers a choice of three fallback languages. The Lang3 fallback language is partially localized, and offers a choice of two fallback languages. The dependencies are as follows, with the default fallback listed first:
     * 
     * <ul>
     * <li>Lang1<ul>
     * <li>Lang2</li>
     * <li>Lang3<ul>
     * <li>Lang5</li>
     * <li>Lang6</li>
     * </ul>
     * </li>
     * <li>Lang4</li>
     * </ul>
     * </li>
     * </ul>
     * To get the fallback language(s) of Lang1, the application passes in <i>pwmszLanguage</i> as "Lang1\0\0". On return from the function, <i>pwszFallbackLanguages</i> is set to "Lang2\0Lang3\0Lang4\0\0". Note that the ordering of this list indicates that Lang2 is the default fallback language.
     * 
     * To get the fallback language(s) of Lang3 in relation to Lang1, the application passes in <i>pwmszLanguage</i> as "lang1\0\lang3\0\0". On return from the function, <i>pwszFallbackLanguages</i> is set to "Lang5\0Lang6\0\0".
     * 
     * This function returns ERROR_INVALID_PARAMETER for any of the following:
     * 
     * <ul>
     * <li><i>pwmszLanguage</i> is <b>NULL</b> or empty.</li>
     * <li>Both MUI_LANGUAGE_ID and MUI_LANGUAGE_NAME are set.</li>
     * <li>Any flags other than MUI_LANGUAGE_ID or MUI_LANGUAGE_NAME are set.</li>
     * <li><i>pcchFallbackLanguages</i> is greater than 0 but <i>pwszFallbackLanguages</i> is <b>NULL</b>.</li>
     * <li><i>pwmszLanguage</i> cannot be parsed as a multi-string buffer of language identifiers or language names, depending on the flag setting.</li>
     * </ul>
     * The ERROR_OBJECT_NAME_NOT_FOUND error code occurs if <i>pwmszLanguage</i> can be parsed, but is not valid. The code might also be returned for an invalid locale identifier, or if the first language in the input list is not an installed language, or if a fully localized language has defined a fallback language.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean GetUILanguageInfo(
     *             System.UInt32 dwFlags,
     *             System.String pwmszLanguage,
     *             System.IntPtr pwszFallbackLanguages,
     *             ref System.UInt32 pcchFallbackLanguages,
     *             ref System.UInt32 pdwAttributes
     *             );
     * 
     * ```
     * @param {Integer} dwFlags Flags defining the format of the specified language. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwmszLanguage Pointer to languages for which the function is to retrieve information. This parameter indicates an ordered, null-delimited list of language identifiers or language names, depending on the flag setting. For information on the use of this parameter, see the Remarks section.
     * @param {PWSTR} pwszFallbackLanguages Pointer to a buffer in which this function retrieves an ordered, null-delimited list of fallback languages, formatted as defined by the setting for <i>dwFlags</i>. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<Integer>} pcchFallbackLanguages Pointer to the size, in characters, for the language buffer indicated by <i>pwszFallbackLanguages</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer </i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @param {Pointer<Integer>} pAttributes Pointer to flags indicating attributes of the input language list. The function always retrieves the flag characterizing the last language listed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_FULL_LANGUAGE"></a><a id="mui_full_language"></a><dl>
     * <dt><b>MUI_FULL_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is fully localized.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_PARTIAL_LANGUAGE"></a><a id="mui_partial_language"></a><dl>
     * <dt><b>MUI_PARTIAL_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is partially localized.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LIP_LANGUAGE"></a><a id="mui_lip_language"></a><dl>
     * <dt><b>MUI_LIP_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is an LIP language.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * In addition, <i>pdwAttributes</i> includes one or both of the following flags, as appropriate.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_INSTALLED"></a><a id="mui_language_installed"></a><dl>
     * <dt><b>MUI_LANGUAGE_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is installed on this computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_LICENSED"></a><a id="mui_language_licensed"></a><dl>
     * <dt><b>MUI_LANGUAGE_LICENSED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is appropriately licensed for the current user.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. For more information, see Remarks.</li>
     * <li>ERROR_OBJECT_NAME_NOT_FOUND. The specified object name was not found, or it was not valid, or the first language in the input list is not an installed language. For more information, see Remarks.
     * </li>
     * </ul>
     * If <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns any other error code, the parameters <i>pcchFallbackLanguages</i> and <i>pdwAttributes</i> are undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuilanguageinfo
     * @since windows6.0.6000
     */
    static GetUILanguageInfo(dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes) {
        pwmszLanguage := pwmszLanguage is String ? StrPtr(pwmszLanguage) : pwmszLanguage
        pwszFallbackLanguages := pwszFallbackLanguages is String ? StrPtr(pwszFallbackLanguages) : pwszFallbackLanguages

        pcchFallbackLanguagesMarshal := pcchFallbackLanguages is VarRef ? "uint*" : "ptr"
        pAttributesMarshal := pAttributes is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUILanguageInfo", "uint", dwFlags, "ptr", pwmszLanguage, "ptr", pwszFallbackLanguages, pcchFallbackLanguagesMarshal, pcchFallbackLanguages, pAttributesMarshal, pAttributes, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Integer} flags 
     * @param {PWSTR} languages 
     * @param {Pointer<Integer>} numLanguagesSet 
     * @param {Pointer<HSAVEDUILANGUAGES>} snapshot 
     * @returns {BOOL} 
     */
    static SetThreadPreferredUILanguages2(flags, languages, numLanguagesSet, snapshot) {
        languages := languages is String ? StrPtr(languages) : languages

        numLanguagesSetMarshal := numLanguagesSet is VarRef ? "uint*" : "ptr"

        result := DllCall("KERNEL32.dll\SetThreadPreferredUILanguages2", "uint", flags, "ptr", languages, numLanguagesSetMarshal, numLanguagesSet, "ptr", snapshot, "int")
        return result
    }

    /**
     * 
     * @param {HSAVEDUILANGUAGES} snapshot 
     * @returns {String} Nothing - always returns an empty string
     */
    static RestoreThreadPreferredUILanguages(snapshot) {
        snapshot := snapshot is Win32Handle ? NumGet(snapshot, "ptr") : snapshot

        DllCall("KERNEL32.dll\RestoreThreadPreferredUILanguages", "ptr", snapshot)
    }

    /**
     * Unsupported. NotifyUILanguageChange may be altered or unavailable.
     * @remarks
     * <b>NotifyUILanguageChange</b> is not supported and may be altered or unavailable in the future.
     * @param {Integer} dwFlags Reserved.
     * @param {PWSTR} pcwstrNewLanguage The new language.
     * @param {PWSTR} pcwstrPreviousLanguage The previous language.
     * @param {Pointer<Integer>} pdwStatusRtrn A pointer to a <b>DWORD</b> return status.
     * @returns {BOOL} A <b>BOOL</b> datatype.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-notifyuilanguagechange
     * @since windows6.1
     */
    static NotifyUILanguageChange(dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, pdwStatusRtrn) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        pcwstrNewLanguage := pcwstrNewLanguage is String ? StrPtr(pcwstrNewLanguage) : pcwstrNewLanguage
        pcwstrPreviousLanguage := pcwstrPreviousLanguage is String ? StrPtr(pcwstrPreviousLanguage) : pcwstrPreviousLanguage

        pdwStatusRtrnMarshal := pdwStatusRtrn is VarRef ? "uint*" : "ptr"

        result := DllCall("KERNEL32.dll\NotifyUILanguageChange", "uint", dwFlags, "ptr", pcwstrNewLanguage, "ptr", pcwstrPreviousLanguage, "uint", dwReserved, pdwStatusRtrnMarshal, pdwStatusRtrn, "int")
        return result
    }

    /**
     * Retrieves character type information for the characters in the specified source string.
     * @remarks
     * For an overview of the use of the string functions, see <a href="https://docs.microsoft.com/windows/desktop/menurc/strings">Strings</a>.
     * 
     * Using the ANSI code page for the supplied locale, this function translates the source string from ANSI to Unicode. It then analyzes each Unicode character for character type information.
     * 
     * The ANSI version of this function converts the source string to Unicode and calls the 
     * corresponding <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a> function. Thus the words in the output buffer correspond not to the original ANSI string but to its Unicode equivalent. The conversion from ANSI to Unicode can result in a change in string length, for example, a pair of ANSI characters can map to a single 
     * Unicode character. Therefore, the correspondence between the words in the output buffer and the characters in the original ANSI string is not one-to-one in all cases, for example, multibyte strings. Thus, the ANSI version of this function is of limited use for multi-character strings. The Unicode version of the function is recommended instead.
     * 
     * This function circumvents a limitation caused by the difference in parameters between <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringtypea">GetStringTypeA</a> and <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a <b>GetStringType*</b> function through the use of the #define UNICODE switch. On the other hand, <b>GetStringTypeEx</b>, behaves properly with regard to that switch. Thus it is the recommended function.
     * 
     *     
     * When the ANSI version of this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * The values of the <i>lpSrcStr</i> and <i>lpCharType</i> parameters must not be the same. If they are the same, the function fails with <b>ERROR_INVALID_PARAMETER</b>.
     * 
     * The <i>Locale</i> parameter is only used to perform string conversion to Unicode. It has nothing to do with the CTYPE* values supplied by the application. These values are solely determined by Unicode code points, and do not vary on a locale basis. For example, Greek letters are specified as C1_ALPHA for any value of <i>Locale</i>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. This value uniquely defines the ANSI code page. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.
     * @param {PSTR} lpSrcStr Pointer to the string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. The size refers to bytes for the ANSI version of the function or wide characters for the Unicode version. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<Integer>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li><b>ERROR_INVALID_FLAGS</b>. The values supplied for flags were not valid.</li>
     * <li><b>ERROR_INVALID_PARAMETER</b>. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw
     */
    static GetStringTypeExA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr

        lpCharTypeMarshal := lpCharType is VarRef ? "ushort*" : "ptr"

        result := DllCall("KERNEL32.dll\GetStringTypeExA", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, lpCharTypeMarshal, lpCharType, "int")
        return result
    }

    /**
     * Deprecated. (GetStringTypeA)
     * @remarks
     * For an overview of the use of the string functions, see <a href="https://docs.microsoft.com/windows/desktop/menurc/strings">Strings</a>.
     * 
     * This function converts the source string to Unicode and calls the 
     * corresponding <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a> function. Thus the words in the output buffer correspond not to the original ANSI string but to its Unicode equivalent. The conversion from ANSI to Unicode can result in a change in string length, for example, a pair of ANSI characters can map to a single 
     * Unicode character. Therefore, the correspondence between the words in the output buffer and the characters in the original ANSI string is not one-to-one in all cases, for example, multibyte strings. Thus <b>GetStringTypeA</b> is of limited use for multi-character strings. [GetStringTypeW function](../stringapiset/nf-stringapiset-getstringtypew.md) and [GetStringTypeEx](../stringapiset/nf-stringapiset-getstringtypeexw.md) are recommended instead.
     * 
     * 			 
     * When this function is used with a Unicode-only locale identifier, the function can succeed because the operating system uses the system code page. However, characters that are undefined in the system code page appear in the string as a question mark (?). 
     * 
     * The values of the <i>lpSrcStr</i> and <i>lpCharType</i> parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER.
     * 
     * The <i>Locale</i> parameter is only used to perform string conversion to Unicode. It has nothing to do with the CTYPE* values supplied by the application. These values are solely determined by Unicode code points, and do not vary on a locale basis. For example, Greek letters are specified as C1_ALPHA for any value of <i>Locale</i>.
     * 
     * The <i>Locale</i> parameter is not used by the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a> function. Because of the parameter difference, an application cannot automatically invoke the proper ANSI or Unicode version of a <b>GetStringType*</b> function through the use of the #define UNICODE switch. An application can circumvent this limitation by using <a href="https://docs.microsoft.com/previous-versions/ms960831(v%3dmsdn.10)">GetStringTypeEx</a>, which is the recommended function.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.
     * @param {PSTR} lpSrcStr Pointer to the ANSI string for which to retrieve the character types. The string can be a double-byte character set (DBCS) string if the supplied locale is appropriate for DBCS. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<Integer>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getstringtypea
     * @since windows5.0
     */
    static GetStringTypeA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr

        lpCharTypeMarshal := lpCharType is VarRef ? "ushort*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeA", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, lpCharTypeMarshal, lpCharType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Maps one Unicode string to another, performing the specified transformation. (FoldStringA)
     * @remarks
     * The values of the <i>lpSrcStr</i> and  and <i>lpDestStr</i> parameters must not be the same. If they are the same, the function fails with ERROR_INVALID_PARAMETER.
     * 
     * The compatibility zone in Unicode consists of characters in the range 0xF900 through 0xFFEF that are assigned to characters from other encoding standards for characters but are actually variants of characters already in Unicode. The compatibility zone is used to support round-trip mapping to these standards. Applications can use the MAP_FOLDCZONE flag to avoid supporting the duplication of characters in the compatibility zone.
     * 
     * <b>Starting with WindowsVista:</b> This function supports Unicode normalization. All Unicode compatibility characters are mapped.
     * 
     * <b>Starting with WindowsVista:</b> The transformations indicated by the MAP_FOLDCZONE, MAP_PRECOMPOSED, and MAP_COMPOSITE flags use Unicode normalization forms KC, C, and D (through the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a> function) to do the mappings.
     * 
     * <b>Starting with Windows8: </b>The ANSI version of the function is declared in Winnls.h and the Unicode version is declared in Stringapiset.h. Before Windows8, both versions were declared in Winnls.h.
     * @param {Integer} dwMapFlags 
     * @param {PSTR} lpSrcStr Pointer to a source string that the function maps.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>, excluding the terminating null character. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, the function calculates the string length automatically, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * @param {PSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string. If the MAP_FOLDDIGITS flag is specified, the return value is the maximum size required, even if the actual number of characters needed is smaller than the maximum size. If the maximum size is not passed, the function fails with ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} Returns the number of characters in the translated string, including a terminating null character, if successful. If the function succeeds and the value of <i>cchDest</i> is 0, the return value is the size of the buffer required to hold the translated string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_DATA. The data was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_MOD_NOT_FOUND. The module was not found. </li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation. </li>
     * <li>ERROR_PROC_NOT_FOUND. The required procedure was not found.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-foldstringa
     * @since windows5.0
     */
    static FoldStringA(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FoldStringA", "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.NoteFor interoperability reasons, the application should prefer the EnumSystemLocalesEx function to EnumSystemLocales because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that will be run only on WindowsVista and later should use EnumSystemLocalesEx. (ANSI)
     * @remarks
     * The function enumerates locales by passing locale identifiers, one at a time, to the specified application-defined callback function. This continues until all of the installed or supported locale identifiers have been passed to the callback function or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemLocales as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LOCALE_ENUMPROCA>} lpLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317822(v=vs.85)">EnumLocalesProc</a>.
     * @param {Integer} dwFlags Flags specifying the locale identifiers to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LCID_SUPPORTED.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_INSTALLED"></a><a id="lcid_installed"></a><dl>
     * <dt><b>LCID_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only installed locale identifiers. This value cannot be used with LCID_SUPPORTED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_SUPPORTED"></a><a id="lcid_supported"></a><dl>
     * <dt><b>LCID_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all supported locale identifiers. This value cannot be used with LCID_INSTALLED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_ALTERNATE_SORTS"></a><a id="lcid_alternate_sorts"></a><dl>
     * <dt><b>LCID_ALTERNATE_SORTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only the alternate sort locale identifiers. If this value is used with either LCID_INSTALLED or LCID_SUPPORTED, the installed or supported locales are retrieved, as well as the alternate sort locale identifiers.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlocalesa
     * @since windows5.0
     */
    static EnumSystemLocalesA(lpLocaleEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesA", "ptr", lpLocaleEnumProc, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.NoteFor interoperability reasons, the application should prefer the EnumSystemLocalesEx function to EnumSystemLocales because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that will be run only on WindowsVista and later should use EnumSystemLocalesEx. (Unicode)
     * @remarks
     * The function enumerates locales by passing locale identifiers, one at a time, to the specified application-defined callback function. This continues until all of the installed or supported locale identifiers have been passed to the callback function or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemLocales as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LOCALE_ENUMPROCW>} lpLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317822(v=vs.85)">EnumLocalesProc</a>.
     * @param {Integer} dwFlags Flags specifying the locale identifiers to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LCID_SUPPORTED.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_INSTALLED"></a><a id="lcid_installed"></a><dl>
     * <dt><b>LCID_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only installed locale identifiers. This value cannot be used with LCID_SUPPORTED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_SUPPORTED"></a><a id="lcid_supported"></a><dl>
     * <dt><b>LCID_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all supported locale identifiers. This value cannot be used with LCID_INSTALLED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_ALTERNATE_SORTS"></a><a id="lcid_alternate_sorts"></a><dl>
     * <dt><b>LCID_ALTERNATE_SORTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only the alternate sort locale identifiers. If this value is used with either LCID_INSTALLED or LCID_SUPPORTED, the installed or supported locales are retrieved, as well as the alternate sort locale identifiers.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlocalesw
     * @since windows5.0
     */
    static EnumSystemLocalesW(lpLocaleEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesW", "ptr", lpLocaleEnumProc, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the language groups that are either installed on or supported by an operating system. (ANSI)
     * @remarks
     * This function enumerates language groups by passing language group identifiers, one at a time, to the specified application-defined callback function. This process continues until the last language group identifier is found or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemLanguageGroups as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LANGUAGEGROUP_ENUMPROCA>} lpLanguageGroupEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317821(v=vs.85)">EnumLanguageGroupsProc</a>.
     * @param {Integer} dwFlags 
     * @param {Pointer} lParam Application-defined value to pass to the callback function. This parameter can be used in error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlanguagegroupsa
     * @since windows5.0
     */
    static EnumSystemLanguageGroupsA(lpLanguageGroupEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLanguageGroupsA", "ptr", lpLanguageGroupEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the language groups that are either installed on or supported by an operating system. (Unicode)
     * @remarks
     * This function enumerates language groups by passing language group identifiers, one at a time, to the specified application-defined callback function. This process continues until the last language group identifier is found or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemLanguageGroups as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LANGUAGEGROUP_ENUMPROCW>} lpLanguageGroupEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317821(v=vs.85)">EnumLanguageGroupsProc</a>.
     * @param {Integer} dwFlags 
     * @param {Pointer} lParam Application-defined value to pass to the callback function. This parameter can be used in error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlanguagegroupsw
     * @since windows5.0
     */
    static EnumSystemLanguageGroupsW(lpLanguageGroupEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLanguageGroupsW", "ptr", lpLanguageGroupEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the locales in a specified language group. (ANSI)
     * @remarks
     * This function enumerates locales in the specified language group by passing locale identifiers, one at a time, to the application-defined callback function. This process continues until <b>EnumLanguageGroupLocales</b> finds the last locale identifier or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumLanguageGroupLocales as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LANGGROUPLOCALE_ENUMPROCA>} lpLangGroupLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-langgrouplocale_enumproca">EnumLanguageGroupLocalesProc</a>.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer} lParam An application-defined value to pass to the callback function. This value can be used for error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumlanguagegrouplocalesa
     * @since windows5.0
     */
    static EnumLanguageGroupLocalesA(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumLanguageGroupLocalesA", "ptr", lpLangGroupLocaleEnumProc, "uint", LanguageGroup, "uint", dwFlags, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the locales in a specified language group. (Unicode)
     * @remarks
     * This function enumerates locales in the specified language group by passing locale identifiers, one at a time, to the application-defined callback function. This process continues until <b>EnumLanguageGroupLocales</b> finds the last locale identifier or the callback function returns <b>FALSE</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumLanguageGroupLocales as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<LANGGROUPLOCALE_ENUMPROCW>} lpLangGroupLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-langgrouplocale_enumproca">EnumLanguageGroupLocalesProc</a>.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer} lParam An application-defined value to pass to the callback function. This value can be used for error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumlanguagegrouplocalesw
     * @since windows5.0
     */
    static EnumLanguageGroupLocalesW(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumLanguageGroupLocalesW", "ptr", lpLangGroupLocaleEnumProc, "uint", LanguageGroup, "uint", dwFlags, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the user interface languages that are available on the operating system and calls the callback function with every language in the list. (ANSI)
     * @remarks
     * This function enumerates the user interface languages that are available and, depending on the flag specified, licensed for use on the operating system. It passes language identifiers or language names, one at a time, to the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. The <b>EnumUILanguages</b> function continues to pass language identifiers or names to the callback function until the last language is found or the callback function returns <b>FALSE</b>.
     * 
     * For applications that run only on WindowsVista and later, MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID. MUI_LANGUAGE_NAME allows differentiation between languages that are associated with a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>.
     * 
     * If the MUI_LANGUAGE_ID flag is specified in the call to this function, the strings passed to the callback 
     * 
     * function will be hexadecimal language identifiers that do not include the leading 0x, and will be 4 
     * 
     * characters in length. For example, en-US will be passed as "0409" and en as "0009". The value "1000" is passed to the callback function for any language associated with a supplemental locale. This value corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. It does not distinguish among supplemental locales, even if the selected language is in the user preferred UI languages list or the system preferred UI languages list.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean EnumUILanguages(
     *             EnumUILanguagesProc lpUILanguageEnumProc,
     *             System.UInt32 dwFlags,
     *             System.IntPtr lParam
     *             );
     * 
     * ```
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumUILanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UILANGUAGE_ENUMPROCA>} lpUILanguageEnumProc Pointer to an application-defined <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. <b>EnumUILanguages</b> calls this function repeatedly to enumerate the languages in the list.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language to pass to the callback function. The format flags are mutually exclusive, and MUI_LANGUAGE_ID is the default. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags specify the filtering for the function to use in enumerating the languages. The filtering flags are mutually exclusive, and the default is MUI_LICENSED_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_ALL_INSTALLED_LANGUAGES"></a><a id="mui_all_installed_languages"></a><dl>
     * <dt><b>MUI_ALL_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages available to the operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LICENSED_LANGUAGES"></a><a id="mui_licensed_languages"></a><dl>
     * <dt><b>MUI_LICENSED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed for use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_GROUP_POLICY"></a><a id="mui_group_policy"></a><dl>
     * <dt><b>MUI_GROUP_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed, and that are allowed by 
     * 
     * the group policy.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <b>WindowsVista and later:</b> The application can set <i>dwFlags</i> to 0, or to one or more of the specified flags. A setting of 0 causes the parameter value to default to MUI_LANGUAGE_ID | MUI_LICENSED_LANGUAGES.
     * 
     * <b>Windows2000, WindowsXP, Windows Server2003:</b> The application must set <i>dwFlags</i> to 0.
     * @param {Pointer} lParam Application-defined value.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumuilanguagesa
     * @since windows5.0
     */
    static EnumUILanguagesA(lpUILanguageEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumUILanguagesA", "ptr", lpUILanguageEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the user interface languages that are available on the operating system and calls the callback function with every language in the list. (Unicode)
     * @remarks
     * This function enumerates the user interface languages that are available and, depending on the flag specified, licensed for use on the operating system. It passes language identifiers or language names, one at a time, to the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. The <b>EnumUILanguages</b> function continues to pass language identifiers or names to the callback function until the last language is found or the callback function returns <b>FALSE</b>.
     * 
     * For applications that run only on WindowsVista and later, MUI_LANGUAGE_NAME is recommended over MUI_LANGUAGE_ID. MUI_LANGUAGE_NAME allows differentiation between languages that are associated with a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">supplemental locale</a>.
     * 
     * If the MUI_LANGUAGE_ID flag is specified in the call to this function, the strings passed to the callback 
     * 
     * function will be hexadecimal language identifiers that do not include the leading 0x, and will be 4 
     * 
     * characters in length. For example, en-US will be passed as "0409" and en as "0009". The value "1000" is passed to the callback function for any language associated with a supplemental locale. This value corresponds to the hexadecimal value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. It does not distinguish among supplemental locales, even if the selected language is in the user preferred UI languages list or the system preferred UI languages list.
     * 
     * <h3><a id="C__Signature"></a><a id="c__signature"></a><a id="C__SIGNATURE"></a>C# Signature</h3>
     * 
     * ```cpp
     * [DllImport("Kernel32.dll", CharSet = CharSet.Auto)]
     *         static extern System.Boolean EnumUILanguages(
     *             EnumUILanguagesProc lpUILanguageEnumProc,
     *             System.UInt32 dwFlags,
     *             System.IntPtr lParam
     *             );
     * 
     * ```
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumUILanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UILANGUAGE_ENUMPROCW>} lpUILanguageEnumProc Pointer to an application-defined <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. <b>EnumUILanguages</b> calls this function repeatedly to enumerate the languages in the list.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language to pass to the callback function. The format flags are mutually exclusive, and MUI_LANGUAGE_ID is the default. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags specify the filtering for the function to use in enumerating the languages. The filtering flags are mutually exclusive, and the default is MUI_LICENSED_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_ALL_INSTALLED_LANGUAGES"></a><a id="mui_all_installed_languages"></a><dl>
     * <dt><b>MUI_ALL_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages available to the operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LICENSED_LANGUAGES"></a><a id="mui_licensed_languages"></a><dl>
     * <dt><b>MUI_LICENSED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed for use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_GROUP_POLICY"></a><a id="mui_group_policy"></a><dl>
     * <dt><b>MUI_GROUP_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed, and that are allowed by 
     * 
     * the group policy.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <b>WindowsVista and later:</b> The application can set <i>dwFlags</i> to 0, or to one or more of the specified flags. A setting of 0 causes the parameter value to default to MUI_LANGUAGE_ID | MUI_LICENSED_LANGUAGES.
     * 
     * <b>Windows2000, WindowsXP, Windows Server2003:</b> The application must set <i>dwFlags</i> to 0.
     * @param {Pointer} lParam Application-defined value.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumuilanguagesw
     * @since windows5.0
     */
    static EnumUILanguagesW(lpUILanguageEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumUILanguagesW", "ptr", lpUILanguageEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the code pages that are either installed on or supported by an operating system. (ANSI)
     * @remarks
     * This function enumerates the code pages by passing code page identifiers, one at a time, to the specified application-defined callback function. This process continues until all installed or supported code page identifiers have been passed to the callback function, or the callback function returns <b>FALSE</b>.
     * 
     * When an application is using this function to determine an appropriate code page for saving data, it should use Unicode when possible. Other code pages are not as portable as Unicode between vendors or operating systems, due to different implementations of the associated standards.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemCodePages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CODEPAGE_ENUMPROCA>} lpCodePageEnumProc Pointer to an application-defined callback function. The <b>EnumSystemCodePages</b> function enumerates code pages by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317809(v=vs.85)">EnumCodePagesProc</a>.
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemcodepagesa
     * @since windows5.0
     */
    static EnumSystemCodePagesA(lpCodePageEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemCodePagesA", "ptr", lpCodePageEnumProc, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the code pages that are either installed on or supported by an operating system. (Unicode)
     * @remarks
     * This function enumerates the code pages by passing code page identifiers, one at a time, to the specified application-defined callback function. This process continues until all installed or supported code page identifiers have been passed to the callback function, or the callback function returns <b>FALSE</b>.
     * 
     * When an application is using this function to determine an appropriate code page for saving data, it should use Unicode when possible. Other code pages are not as portable as Unicode between vendors or operating systems, due to different implementations of the associated standards.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winnls.h header defines EnumSystemCodePages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CODEPAGE_ENUMPROCW>} lpCodePageEnumProc Pointer to an application-defined callback function. The <b>EnumSystemCodePages</b> function enumerates code pages by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317809(v=vs.85)">EnumCodePagesProc</a>.
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemcodepagesw
     * @since windows5.0
     */
    static EnumSystemCodePagesW(lpCodePageEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemCodePagesW", "ptr", lpCodePageEnumProc, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts an internationalized domain name (IDN) or another internationalized label to a Unicode (wide character) representation of the ASCII string that represents the name in the Punycode transfer encoding syntax.
     * @remarks
     * The function does not null-terminate an output string if the input string length is explicitly specified without a terminating null character. To null-terminate an output string for this function, the application should supply -1 for the <i>cchUnicodeChar</i> parameter or explicitly count the terminating null character for the input string.
     * 
     * Note that the function always fails if the input string contains control characters (U+0001 through U+0020) or the "delete" character (U+007F). Since the character U+0000 can appear only as a terminating null character, the function always fails if U+0000 appears anywhere else in the input string.
     * 
     * <b>WindowsXP, Windows Server2003</b>: 
     * 
     * No longer supported.
     * 
     * The required header file and DLL are part of the Microsoft Internationalized Domain Name (IDN) Mitigation APIs, which are no longer available for download.
     * @param {Integer} dwFlags Flags specifying conversion options. The following table lists the possible values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_ALLOW_UNASSIGNED"></a><a id="idn_allow_unassigned"></a><dl>
     * <dt><b>IDN_ALLOW_UNASSIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <div class="alert"><b>Note</b>An application can set this value if it is just using a query string for normal lookup, as in a compare operation. However, the application should not set this value for a stored string, which is a string being prepared for storage.</div>
     * <div></div>
     * Allow unassigned code points to be included in the input string. The default is to not allow unassigned code points, and fail with an extended error code of ERROR_INVALID_NAME.
     * 
     * This flag allows the function to process characters that are not currently legal in IDNs, but might be legal in later versions of the IDNA standard. If your application encodes unassigned code points as Punycode, the resulting domain names should be illegal. Security can be compromised if a later version of IDNA makes these names legal or if an application filters out the illegal characters to try to create a legal domain name. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-internationalized-domain-names--idns">Handling Internationalized Domain Names (IDNs)</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_USE_STD3_ASCII_RULES"></a><a id="idn_use_std3_ascii_rules"></a><dl>
     * <dt><b>IDN_USE_STD3_ASCII_RULES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Filter out ASCII characters that are not allowed in STD3 names. The only ASCII characters allowed in the input Unicode string are letters, digits, and the hyphen-minus. The string cannot begin or end with the hyphen-minus. The function fails if the input Unicode string contains ASCII characters, such as "[", "]", or "/", that cannot occur in domain names.<div class="alert"><b>Note</b>Some local networks can allow some of these characters in computer names.</div>
     * <div></div>
     * 
     * 
     * The function fails if the input Unicode string contains control characters (U+0001 through U+0020) or the "delete" character (U+007F). In either case, this flag has no effect on the non-ASCII characters that are allowed in the Unicode string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_EMAIL_ADDRESS"></a><a id="idn_email_address"></a><dl>
     * <dt><b>IDN_EMAIL_ADDRESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Enable EAI algorithmic fallback for the local parts of email addresses (such as <i>&lt;local&gt;</i>@microsoft.com). The default is for this function to fail when an email address has an invalid address or syntax.
     * 
     * An application can set this flag to enable Email Address Internationalization (EAI) to return a discoverable fallback address, if possible. For more information, see the IETF <a href="https://datatracker.ietf.org/wg/eai/charter/">Email Address Internationalization (eai) Charter</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_RAW_PUNYCODE"></a><a id="idn_raw_punycode"></a><dl>
     * <dt><b>IDN_RAW_PUNYCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Disable the validation and mapping of Punycode.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpUnicodeCharStr Pointer to a Unicode string representing an IDN or another internationalized label.
     * @param {Integer} cchUnicodeChar Count of characters in the input Unicode string indicated by <i>lpUnicodeCharStr</i>.
     * @param {PWSTR} lpASCIICharStr Pointer to a buffer that receives a Unicode string consisting only of characters in the ASCII character set. On return from this function, the buffer contains the ASCII string equivalent of the string provided in <i>lpUnicodeCharStr</i> under Punycode. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchASCIIChar</i> is set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchASCIIChar Size of the buffer indicated by <i>lpASCIICharStr</i>. The application can set the parameter to 0 to retrieve <b>NULL</b> in <i>lpASCIICharStr</i>.
     * @returns {Integer} Returns the number of characters retrieved in <i>lpASCIICharStr</i> if successful. The retrieved string is null-terminated only if the input Unicode string is null-terminated.
     * 
     * If the function succeeds and the value of <i>cchASCIIChar</i> is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_NAME. An invalid name was supplied to the function. Note that this error code catches all syntax errors. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-idntoascii
     * @since windows6.0.6000
     */
    static IdnToAscii(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar) {
        lpUnicodeCharStr := lpUnicodeCharStr is String ? StrPtr(lpUnicodeCharStr) : lpUnicodeCharStr
        lpASCIICharStr := lpASCIICharStr is String ? StrPtr(lpASCIICharStr) : lpASCIICharStr

        A_LastError := 0

        result := DllCall("NORMALIZ.dll\IdnToAscii", "uint", dwFlags, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar, "ptr", lpASCIICharStr, "int", cchASCIIChar, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts the Punycode form of an internationalized domain name (IDN) or another internationalized label to the normal Unicode UTF-16 encoding syntax.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {Integer} dwFlags Flags specifying conversion options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {PWSTR} lpASCIICharStr Pointer to a string representing the Punycode encoding of an IDN or another internationalized label. This string must consist only of ASCII characters, and can include Punycode-encoded Unicode. The function decodes Punycode values to their UTF-16 values.
     * @param {Integer} cchASCIIChar Count of characters in the input string indicated by <i>lpASCIICharStr</i>.
     * @param {PWSTR} lpUnicodeCharStr Pointer to a buffer that receives a normal Unicode UTF-16 encoding equivalent to the Punycode value of the input string. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchUnicodeChar</i> set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchUnicodeChar Size, in characters, of the buffer indicated by <i>lpUnicodeCharStr</i>. The application can set the size to 0 to retrieve <b>NULL</b> in <i>lpUnicodeCharStr</i> and have the function return the required buffer size.
     * @returns {Integer} Returns the number of characters retrieved in <i>lpUnicodeCharStr</i> if successful. The retrieved string is null-terminated only if the input string is null-terminated.
     * 
     * If the function succeeds and the value of <i>cchUnicodeChar</i> is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_NAME. An invalid name was supplied to the function. Note that this error code catches all syntax errors. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-idntounicode
     * @since windows6.0.6000
     */
    static IdnToUnicode(dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar) {
        lpASCIICharStr := lpASCIICharStr is String ? StrPtr(lpASCIICharStr) : lpASCIICharStr
        lpUnicodeCharStr := lpUnicodeCharStr is String ? StrPtr(lpUnicodeCharStr) : lpUnicodeCharStr

        A_LastError := 0

        result := DllCall("NORMALIZ.dll\IdnToUnicode", "uint", dwFlags, "ptr", lpASCIICharStr, "int", cchASCIIChar, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts an internationalized domain name (IDN) or another internationalized label to the NamePrep form specified by Network Working Group RFC 3491, but does not perform the additional conversion to Punycode.
     * @remarks
     * See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {Integer} dwFlags Flags specifying conversion options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {PWSTR} lpUnicodeCharStr Pointer to a Unicode string representing an IDN or another internationalized label.
     * @param {Integer} cchUnicodeChar Count of Unicode characters in the input Unicode string indicated by <i>lpUnicodeCharStr</i>.
     * @param {PWSTR} lpNameprepCharStr Pointer to a buffer that receives a version of the input Unicode string converted through NamePrep processing. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchNameprepChar</i> is set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchNameprepChar Size, in characters, of the buffer indicated by <i>lpNameprepCharStr</i>. The application can set the size to 0 to retrieve <b>NULL</b> in <i>lpNameprepCharStr</i> and have the function return the required buffer size.
     * @returns {Integer} Returns the number of characters retrieved in <i>lpNameprepCharStr</i> if successful. The retrieved string is null-terminated only if the input Unicode string is null-terminated.
     * 
     * If the function succeeds and the value of <i>cchNameprepChar</i> is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_NAME. An invalid name was supplied to the function. Note that this error code catches all syntax errors. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-idntonameprepunicode
     * @since windows6.0.6000
     */
    static IdnToNameprepUnicode(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar) {
        lpUnicodeCharStr := lpUnicodeCharStr is String ? StrPtr(lpUnicodeCharStr) : lpUnicodeCharStr
        lpNameprepCharStr := lpNameprepCharStr is String ? StrPtr(lpNameprepCharStr) : lpNameprepCharStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\IdnToNameprepUnicode", "uint", dwFlags, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar, "ptr", lpNameprepCharStr, "int", cchNameprepChar, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Normalizes characters of a text string according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.
     * @remarks
     * Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules, as described in <a href="https://docs.microsoft.com/windows/desktop/Intl/using-unicode-normalization-to-represent-strings">Using Unicode Normalization to Represent Strings</a>. The Win32 and the .NET Framework currently support normalization forms C, D, KC, and KD, as defined in <a href="https://www.unicode.org/reports/tr15">Unicode Standard Annex #15: Unicode Normalization Forms</a>. Normalized strings are typically evaluated with an ordinal comparison.
     * 
     * The following code demonstrates the use of the buffer length estimate:
     * 
     * 
     * ```cpp
     * const int maxIterations = 10;
     * LPWSTR strResult = NULL;
     * HANDLE hHeap = GetProcessHeap();
     * 
     * int iSizeEstimated = NormalizeString(form, strInput, -1, NULL, 0);
     * for (int i = 0; i < maxIterations; i++)
     * {
     *     if (strResult)
     *         HeapFree(hHeap, 0, strResult);
     *     strResult = (LPWSTR)HeapAlloc(hHeap, 0, iSizeEstimated * sizeof (WCHAR));
     *     iSizeEstimated = NormalizeString(form, strInput, -1, strResult, iSizeEstimated);
     *  
     *     if (iSizeEstimated > 0)
     *         break; // success 
     *  
     *     if (iSizeEstimated <= 0)
     *     {
     *         DWORD dwError = GetLastError();
     *         if (dwError != ERROR_INSUFFICIENT_BUFFER) break; // Real error, not buffer error 
     *  
     *         // New guess is negative of the return value. 
     *         iSizeEstimated = -iSizeEstimated;
     *     }
     * }
     * 
     * ```
     * 
     * <b>WindowsXP, Windows Server2003</b>: 
     * 
     * No longer supported.
     * 
     * The required header file and DLL are part of the Microsoft Internationalized Domain Name (IDN) Mitigation APIs, which are no longer available for download.
     * @param {Integer} NormForm Normalization form to use. <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> specifies the standard Unicode normalization forms.
     * @param {PWSTR} lpSrcString Pointer to the non-normalized source string.
     * @param {Integer} cwSrcLength Length, in characters, of the buffer containing the source string. The application can set this parameter to -1 if the function should assume the string to be null-terminated and calculate the length automatically.
     * @param {PWSTR} lpDstString Pointer to a buffer in which the function retrieves the destination string. Alternatively, this parameter contains <b>NULL</b> if <i>cwDstLength</i> is set to 0.
     * 
     * <div class="alert"><b>Note</b>The function does not null-terminate the string if the input string length is explicitly specified without a terminating null character. To null-terminate the output string, the application should specify -1 or explicitly count the terminating null character for the input string.</div>
     * <div></div>
     * @param {Integer} cwDstLength Length, in characters, of the buffer containing the destination string. Alternatively, the application can set this parameter to 0 to request the function to return the required size for the destination buffer.
     * @returns {Integer} Returns the length of the normalized string in the destination buffer. If <i>cwDstLength</i> is set to 0, the function returns the estimated buffer length required to do the actual conversion.
     * 
     * If the string in the input buffer is null-terminated or if <i>cwSrcLength</i> is -1, the string written to the destination buffer is null-terminated and the returned string length includes the terminating null character.
     * 
     * The function returns a value that is less than or equal to 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string. The return value is the negative of the index of the location of the error in the input string.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-normalizestring
     * @since windows6.0.6000
     */
    static NormalizeString(NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength) {
        lpSrcString := lpSrcString is String ? StrPtr(lpSrcString) : lpSrcString
        lpDstString := lpDstString is String ? StrPtr(lpDstString) : lpDstString

        A_LastError := 0

        result := DllCall("KERNEL32.dll\NormalizeString", "int", NormForm, "ptr", lpSrcString, "int", cwSrcLength, "ptr", lpDstString, "int", cwDstLength, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies that a string is normalized according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.
     * @remarks
     * <b>WindowsXP, Windows Server2003</b>: 
     * 
     * No longer supported.
     * 
     * The required header file and DLL are part of the Microsoft Internationalized Domain Name (IDN) Mitigation APIs, which are no longer available for download.
     * @param {Integer} NormForm Normalization form to use. <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> specifies the standard Unicode normalization forms.
     * @param {PWSTR} lpString Pointer to the string to test.
     * @param {Integer} cwLength Length, in characters, of the input string, including a null terminating character. If this value is -1, the function assumes the string to be null-terminated and calculates the length automatically.
     * @returns {BOOL} Returns <b>TRUE</b> if the input string is already normalized to the appropriate form, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in string.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * If you need to reliably determine <b>FALSE</b> from an error condition, then it must call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a>(ERROR_SUCCESS).
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isnormalizedstring
     * @since windows6.0.6000
     */
    static IsNormalizedString(NormForm, lpString, cwLength) {
        lpString := lpString is String ? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsNormalizedString", "int", NormForm, "ptr", lpString, "int", cwLength, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Compares two enumerated lists of scripts.
     * @remarks
     * This function compares strings, such as "Latn;Cyrl;", that consist of a series of 4-character script names, with each script name followed by a semicolon. It also has a special case to account for the fact that the Latin script is often used in languages and locales for which it is not native.
     * 
     * This function is useful as part of a strategy to mitigate security issues related to <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-internationalized-domain-names--idns">internationalized domain names (IDNs)</a>.
     * 
     * The following are examples of the return of this function and a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> in various scenarios. The last two examples illustrate, respectively, a case in which the test list lacks a terminating semicolon (malformed string) and a case in which the test list is empty.
     * 
     * <table>
     * <tr>
     * <th>Locale string</th>
     * <th>Test string</th>
     * <th><i>dwFlags</i></th>
     * <th>Return value</th>
     * <th><b>GetLastError</b> return</th>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Hani;</td>
     * <td>*</td>
     * <td><b>TRUE</b></td>
     * <td>(unchanged)</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Hani;Latn;</td>
     * <td>0</td>
     * <td><b>FALSE</b></td>
     * <td>ERROR_SUCCESS</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Hani;Latn;</td>
     * <td>VS_ALLOW_LATIN</td>
     * <td><b>TRUE</b></td>
     * <td>(unchanged)</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Cyrl;</td>
     * <td>*</td>
     * <td><b>FALSE</b></td>
     * <td>ERROR_SUCCESS</td>
     * </tr>
     * <tr>
     * <td>Hani;</td>
     * <td>Hani;Hira;Kana;</td>
     * <td>*</td>
     * <td>FALSE</td>
     * <td>ERROR_SUCCESS</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td>Cyrl</td>
     * <td>*</td>
     * <td><b>FALSE</b></td>
     * <td>ERROR_INVALID_PARAMETER</td>
     * </tr>
     * <tr>
     * <td>Hani;Hira;Kana;</td>
     * <td></td>
     * <td>*</td>
     * <td>TRUE</td>
     * <td>(unchanged)</td>
     * </tr>
     * </table>
     * 
     * 
     * * Results are the same whether VS_ALLOW_LATIN is passed in the <i>dwFlags</i> parameter or no flags are supplied.
     * @param {Integer} dwFlags Flags specifying script verification options.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="VS_ALLOW_LATIN"></a><a id="vs_allow_latin"></a><dl>
     * <dt><b>VS_ALLOW_LATIN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow "Latn" (Latin script) in the test list even if it is not in the locale list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpLocaleScripts Pointer to the locale list, the enumerated list of scripts for a given locale. This list is typically populated by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> with <i>LCType</i> set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sscripts">LOCALE_SSCRIPTS</a>.
     * @param {Integer} cchLocaleScripts Size, in characters, of the string indicated by <i>lpLocaleScripts</i>. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails.
     * @param {PWSTR} lpTestScripts Pointer to the test list, a second enumerated list of scripts. This list is typically populated by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringscripts">GetStringScripts</a>.
     * @param {Integer} cchTestScripts Size, in characters, of the string indicated by <i>lpTestScripts</i>. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails.
     * @returns {BOOL} Returns <b>TRUE</b> if the test list is non-empty and all items in the list are also included in the locale list. The function still returns <b>TRUE</b> if the locale list contains more scripts than the test list, but all the test list scripts must be contained in the locale list. If VS_ALLOW_LATIN is specified in <i>dwFlags</i>, the function behaves as if "Latn;" is always in the locale list.
     * 
     * In all other cases, the function returns <b>FALSE</b>. This return can indicate that the test list contains an item that is not in the locale list, or it can indicate an error. To distinguish between these two cases, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-verifyscripts
     * @since windows6.0.6000
     */
    static VerifyScripts(dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts) {
        lpLocaleScripts := lpLocaleScripts is String ? StrPtr(lpLocaleScripts) : lpLocaleScripts
        lpTestScripts := lpTestScripts is String ? StrPtr(lpTestScripts) : lpTestScripts

        A_LastError := 0

        result := DllCall("KERNEL32.dll\VerifyScripts", "uint", dwFlags, "ptr", lpLocaleScripts, "int", cchLocaleScripts, "ptr", lpTestScripts, "int", cchTestScripts, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Provides a list of scripts used in the specified Unicode string.
     * @remarks
     * This function is useful as part of a strategy to mitigate security issues related to <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-internationalized-domain-names--idns">internationalized domain names (IDNs)</a>.
     * 
     * The script determination is based on the script values published by the Unicode Consortium in <a href="http://www.unicode.org/Public/4.1.0/ucd/Scripts.txt">http://www.unicode.org/Public/4.1.0/ucd/Scripts.txt</a>, except that the unassigned characters have the value "Zzzz" (UNASSIGNED) instead of "Zyyy" (COMMON).
     * 
     * Here are some examples of the behavior of this function:
     * 
     * <table>
     * <tr>
     * <th colspan="2">Input string</th>
     * <th><i>dwFlags</i></th>
     * <th><i>lpScripts</i></th>
     * <th>Scripts</th>
     * </tr>
     * <tr>
     * <td colspan="2">Microsoft.com</td>
     * <td>0</td>
     * <td>Latn;</td>
     * <td>Latin</td>
     * </tr>
     * <tr>
     * <td colspan="2">Microsoft.com</td>
     * <td>GSS_ALLOW_INHERITED_COMMON</td>
     * <td>Latn;Zyyy;</td>
     * <td>Latin + Common</td>
     * </tr>
     * <tr>
     * <td rowspan="2">Nio</td>
     * <td>004E 0069 0241 006F</td>
     * <td rowspan="2">GSS_ALLOW_INHERITED_COMMON</td>
     * <td rowspan="2">Latn;</td>
     * <td rowspan="2">Latin</td>
     * </tr>
     * <tr>
     * <td>Uses LATIN SMALL LETTER N WITH TILDE</td>
     * </tr>
     * <tr>
     * <td rowspan="2">Nino</td>
     * <td>004E 0069 006E 0303 006F</td>
     * <td rowspan="2">GSS_ALLOW_INHERITED_COMMON</td>
     * <td rowspan="2">Latn;Qaii;</td>
     * <td rowspan="2">Latin + Inherited</td>
     * </tr>
     * <tr>
     * <td>Uses COMBINING TILDE</td>
     * </tr>
     * <tr>
     * <td rowspan="2">Spf</td>
     * <td>0053 0070 043e 043e 0066</td>
     * <td rowspan="2">0</td>
     * <td rowspan="2">Latn;Cyrl;</td>
     * <td rowspan="2">Latin + Cyrillic</td>
     * </tr>
     * <tr>
     * <td>Uses CYRILLIC SMALL LETTER O</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>U+f000</td>
     * <td>0</td>
     * <td>Zzzz;</td>
     * <td>Unassigned</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>U+f000</td>
     * <td>GSS_ALLOW_INHERITED_COMMON</td>
     * <td>Zzzz;</td>
     * <td>Unassigned</td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Flags specifying options for script retrieval.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GSS_ALLOW_INHERITED_COMMON"></a><a id="gss_allow_inherited_common"></a><dl>
     * <dt><b>GSS_ALLOW_INHERITED_COMMON</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve "Qaii" (INHERITED) and "Zyyy" (COMMON) script information. This flag does not affect the processing of unassigned characters. These characters in the input string always cause a "Zzzz" (UNASSIGNED script) to appear in the script string.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b> By default, <b>GetStringScripts</b> ignores any inherited or common characters in the input string indicated by <i>lpString</i>. If GSS_ALLOW_INHERITED_COMMON is not set, neither "Qaii" nor "Zyyy" appears in the script string, even if the input string contains such characters. If GSS_ALLOW_INHERITED_COMMON is set, and if the input string contains inherited and/or common characters, "Qaii" and/or "Zyyy", respectively, appear in the script string. See the Remarks section.</div>
     * <div></div>
     * @param {PWSTR} lpString Pointer to the Unicode string to analyze.
     * @param {Integer} cchString Size, in characters, of the Unicode string indicated by <i>lpString</i>. The application sets this parameter to -1 if the Unicode string is null-terminated. If the application sets this parameter to 0, the function retrieves a null Unicode string (L"\0") in <i>lpScripts</i> and returns 1.
     * @param {PWSTR} lpScripts Pointer to a buffer in which this function retrieves a null-terminated string representing a list of scripts, using the 4-character notation used in <a href="http://www.unicode.org/iso15924/iso15924-codes.html">ISO 15924</a>. Each script name consists of four Latin characters, and the names are retrieved in alphabetical order. Each name, including the last, is followed by a semicolon.
     * 
     * Alternatively, this parameter contains <b>NULL</b> if <i>cchScripts</i> is set to 0. In this case, the function returns the required size for the script buffer.
     * @param {Integer} cchScripts Size, in characters, of the script buffer indicated by <i>lpScripts</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpScripts</i> and returns the required size for the script buffer.
     * @returns {Integer} Returns the number of characters retrieved in the output buffer, including a terminating null character, if successful and <i>cchScripts</i> is set to a nonzero value. The function returns 1 to indicate that no script has been found, for example, when the input string only contains COMMON or INHERITED characters and GSS_ALLOW_INHERITED_COMMON is not set. Given that each found script adds five characters (four characters + delimiter), a simple mathematical operation provides the script count as (return_code - 1) / 5.
     * 
     * If the function succeeds and the value of <i>cchScripts</i> is 0, the function returns the required size, in characters including a terminating null character, for the script buffer. The script count is as described above.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getstringscripts
     * @since windows6.0.6000
     */
    static GetStringScripts(dwFlags, lpString, cchString, lpScripts, cchScripts) {
        lpString := lpString is String ? StrPtr(lpString) : lpString
        lpScripts := lpScripts is String ? StrPtr(lpScripts) : lpScripts

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringScripts", "uint", dwFlags, "ptr", lpString, "int", cchString, "ptr", lpScripts, "int", cchScripts, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about a locale specified by name.NoteThe application should call this function in preference to GetLocaleInfo if designed to run only on WindowsVista and later.NoteThis function can retrieve data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * This function normally retrieves information in text format. If the information is a numeric value and the value of <i>LCType</i> is <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ilanguage">LOCALE_ILANGUAGE</a> or <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-idefault-constants">LOCALE_IDEFAULTLANGUAGE</a>, this function retrieves strings containing hexadecimal numbers. Otherwise, the retrieved text for numeric information is a decimal number.
     * 
     * There are two exceptions to this rule. First, the application can retrieve numeric values as integers by specifying <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> in the <i>LCType</i> parameter. The second exception is that <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-fontsignature">LOCALE_FONTSIGNATURE</a> behaves differently from all other locale information constants. The application must provide a data buffer of at least sizeof(LOCALESIGNATURE) bytes. On successful return from the function, the buffer is filled in as a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-localesignature">LOCALESIGNATURE</a> structure.
     * 
     * <div class="alert"><b>Note</b>Even when the <i>LCType</i> parameter is specified as LOCALE_FONTSIGNATURE, <i>cchData</i> and the function return are still character counts. When an application calls <b>GetLocaleInfoEx</b> with <i>LCType</i> specified as LOCALE_FONTSIGNATURE, <i>cchData</i> can be safely specified as sizeof(LOCALESIGNATURE) / sizeof(WCHAR).</div>
     * <div></div>
     * The following examples deal correctly with the buffer size for non-text values:
     * 
     * 
     * ```cpp
     * int   ret;
     * CALID calid;
     * DWORD value;
     * 
     * ret = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT,
     *                       LOCALE_ICALENDARTYPE | LOCALE_RETURN_NUMBER,
     *                       (LPWSTR)&value,
     *                       sizeof(value) / sizeof(WCHAR) );
     * calid = value;
     * 
     * LOCALESIGNATURE LocSig;
     * 
     * ret = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT,
     *                       LOCALE_FONTSIGNATURE,
     *                       (LPWSTR)&LocSig,
     *                       sizeof(LocSig) / sizeof(WCHAR) );
     * 
     * ```
     * 
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For possible values, see the "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section in <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. Note that only one piece of locale information can be specified per call. 
     * 
     * The application can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> with any other allowed constant. In this case, the function retrieves the value as a number instead of a string. The buffer that receives the value must be at least the length of a DWORD value, which is 2.
     * 
     * <div class="alert"><b>Caution</b>It is also possible to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> with any other constant. However, use of this constant is strongly discouraged. (Even without using the current user override, the data can differ from computer to computer, and custom locales can change the data. For example, even month or day names are subject to spelling reforms.)</div>
     * <div></div>
     * If <i>LCType</i> is set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ioptionalcalendar">LOCALE_IOPTIONALCALENDAR</a>, the function retrieves only the first alternate calendar. 
     * 
     * <div class="alert"><b>Note</b>To get all alternate calendars, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a>.</div>
     * <div></div>
     * Starting with WindowsVista, your applications should not use <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ilanguage">LOCALE_ILANGUAGE</a> in the <i>LCType</i> parameter to avoid failure or retrieval of unexpected data. Instead, it is recommended for your applications to call <b>GetLocaleInfoEx</b>.
     * @param {PWSTR} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0.
     * @param {Integer} cchData Size, in characters, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {Integer} Returns the number of characters retrieved in the locale data buffer if successful and <i>cchData</i> is a nonzero value. If the function succeeds, <i>cchData</i> is nonzero, and <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> is specified, the return value is the size of the integer retrieved in the data buffer, that is, 2. If the function succeeds and the value of <i>cchData</i> is 0, the return value is the required size, in characters including a null character, for the locale data buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getlocaleinfoex
     * @since windows6.0.6000
     */
    static GetLocaleInfoEx(lpLocaleName, LCType, lpLCData, cchData) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLocaleInfoEx", "ptr", lpLocaleName, "uint", LCType, "ptr", lpLCData, "int", cchData, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about a calendar for a locale specified by name.NoteThe application should call this function in preference to GetCalendarInfo if designed to run only on WindowsVista and later.NoteThis function can retrieve data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 			 
     * 
     * <div class="alert"><b>Note</b><b>GetCalendarInfoEx</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div></div>
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {PWSTR} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<Integer>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {Integer} Returns the number of characters retrieved in the <i>lpCalData</i> buffer if successful. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the locale information. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value written to the <i>lpValue</i> parameter. This size is always 2.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcalendarinfoex
     * @since windows6.0.6000
     */
    static GetCalendarInfoEx(lpLocaleName, Calendar, CalType, lpCalData, cchData, lpValue) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        lpValueMarshal := lpValue is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCalendarInfoEx", "ptr", lpLocaleName, "uint", Calendar, "ptr", lpReserved, "uint", CalType, "ptr", lpCalData, "int", cchData, lpValueMarshal, lpValue, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a number string as a number string customized for a locale specified by name.NoteThe application should call this function in preference to GetNumberFormat if designed to run only on WindowsVista and later.NoteThis function can format data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PWSTR} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If the application does not set this parameter to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale string value for the negative sign.
     * @param {PWSTR} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string. Alternatively, this parameter contains <b>NULL</b> if <i>cchNumber</i> is set to 0. In this case, the function returns the required size for the number string buffer.
     * @param {Integer} cchNumber Size, in characters, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer and does not use the <i>lpNumberStr</i> parameter.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpNumberStr</i> if successful. If the <i>cchNumber</i> parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnumberformatex
     * @since windows6.0.6000
     */
    static GetNumberFormatEx(lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpNumberStr := lpNumberStr is String ? StrPtr(lpNumberStr) : lpNumberStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNumberFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Formats a number string as a currency string for a locale specified by name.NoteThe application should call this function in preference to GetCurrencyFormat if designed to run only on WindowsVista and later.NoteThis function can format data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a> or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PWSTR} lpValue Pointer to a null-terminated string containing the number string to format. This string can contain only the following characters. All other characters are invalid. The function returns an error if the string deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9"</li>
     * <li>One decimal point (dot) if the number is a floating-point value</li>
     * <li>A minus sign in the first character position if the number is a negative value</li>
     * </ul>
     * @param {Pointer<CURRENCYFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <b>CURRENCYFMT</b> structure, for example, the string value for the negative sign used by the locale.
     * @param {PWSTR} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application can set this parameter to 0 to return the size of the buffer required to hold the formatted currency string. In this case, the buffer indicated by <i>lpCurrencyStr</i> is not used.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpCurrencyStr</i> if successful. If the <i>cchCurrency</i> parameter is 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getcurrencyformatex
     * @since windows5.0
     */
    static GetCurrencyFormatEx(lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpCurrencyStr := lpCurrencyStr is String ? StrPtr(lpCurrencyStr) : lpCurrencyStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCurrencyFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the user default locale name.NoteThe application should call this function in preference to GetUserDefaultLCID if designed to run only on WindowsVista and later.
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @param {PWSTR} lpLocaleName Pointer to a buffer in which this function retrieves the locale name.
     * @param {Integer} cchLocaleName Size, in characters, of the buffer indicated by <i>lpLocaleName</i>. The maximum possible length of a locale name, including a terminating null character, is <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply in this parameter.
     * @returns {Integer} Returns the size of the buffer containing the locale name, including the terminating null character, if successful.<div class="alert"><b>Note</b>On single-user systems, the return value is the same as that returned by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getsystemdefaultlocalename">GetSystemDefaultLocaleName</a>.</div>
     * <div></div>
     * 
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getuserdefaultlocalename
     * @since windows6.0.6000
     */
    static GetUserDefaultLocaleName(lpLocaleName, cchLocaleName) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUserDefaultLocaleName", "ptr", lpLocaleName, "int", cchLocaleName, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the system default locale name.NoteIt is recommended that applications call GetUserDefaultLocaleName in preference over this function.
     * @remarks
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * @param {PWSTR} lpLocaleName Pointer to a buffer in which this function retrieves the locale name.
     * @param {Integer} cchLocaleName Size, in characters, of the output buffer indicated by <i>lpLocaleName</i>. The maximum possible character length of a locale name (including a terminating null character) is the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size.
     * @returns {Integer} Returns a value greater than 0 that indicates the length of the locale name, including the terminating null character, if successful.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getsystemdefaultlocalename
     * @since windows6.0.6000
     */
    static GetSystemDefaultLocaleName(lpLocaleName, cchLocaleName) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetSystemDefaultLocaleName", "ptr", lpLocaleName, "int", cchLocaleName, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if each character in a string has a defined result for a specified NLS capability.
     * @remarks
     * This function differentiates between defined and undefined strings, so that an application such as Active Directory can reject strings with undefined code points. Use of the function can minimize the necessity for the application to re-index its database. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * 
     * For example, if <i>Function</i> is set to COMPARE_STRING, <b>IsNLSDefinedString</b> checks for undefined code points, <a href="https://docs.microsoft.com/windows/desktop/Intl/surrogates-and-supplementary-characters">surrogate pairs</a> that represent undefined Unicode characters, or ill-formed surrogate pairs. If the function returns <b>TRUE</b> for a particular string, the results, as retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a> with LCMAP_SORTKEY set, are guaranteed to be identical as long as the corresponding NLS version does not change.
     * @param {Integer} Function NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {Integer} dwFlags Flags defining the function. Must be 0.
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure containing version information. Typically, the information is obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversion">GetNLSVersion</a>. The application sets this parameter to <b>NULL</b> if the function is to use the current version.
     * @param {PWSTR} lpString Pointer to the UTF-16 string to examine.
     * @param {Integer} cchStr Number of UTF-16 characters in the string indicated by <i>lpString</i>. This count can include a terminating null character. If the terminating null character is included in the character count, it does not affect the checking behavior because the terminating null character is always defined.
     * 
     * The application should supply -1 to indicate that the string is null-terminated. In this case, the function itself calculates the string length.
     * @returns {BOOL} Returns <b>TRUE</b> if successful, only if the input string is valid, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isnlsdefinedstring
     * @since windows6.0.6000
     */
    static IsNLSDefinedString(Function, dwFlags, lpVersionInformation, lpString, cchStr) {
        lpString := lpString is String ? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsNLSDefinedString", "uint", Function, "uint", dwFlags, "ptr", lpVersionInformation, "ptr", lpString, "int", cchStr, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about the current version of a specified NLS capability for a locale specified by name.NoteThe application should call this function in preference to GetNLSVersion if designed to run only on WindowsVista and later.
     * @remarks
     * This function allows an application such as Active Directory to determine if an NLS change affects the locale used for a particular index table. If it does not, there is no need to re-index the table. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. In particular, to tell if a sort version changed and you need to reindex:
     * 
     * <ol>
     * <li>Use <b>GetNLSVersionEx</b> to retrieve an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure when doing the original indexing of your data.</li>
     * <li>Store the following properties with your index to identify the version:<ul>
     * <li><b>NLSVERSIONINFOEX.dwNLSVersion</b>. This specifies the version of the sorting table you're using.</li>
     * <li><b>NLSVERSIONINFOEX.dwEffectiveId</b>. This specifies the effective locale of your sort. A custom locale will point to an in-box locale's sort.</li>
     * <li><b>NLSVERSIONINFOEX.guidCustomVersion</b>. This is a GUID specifying a specific custom sort for custom locales that have them.</li>
     * </ul>
     * </li>
     * <li>When using the index use <b>GetNLSVersionEx</b> to discover the version of your data.</li>
     * <li>If any of the three properties has changed, the sorting data you're using could return different results and any indexing you have may fail to find records.</li>
     * <li>If you <u>know</u> that your data doesn't contain invalid Unicode code points (that is, all of your strings passed a call to <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-isnlsdefinedstring">IsNLSDefinedString</a>) then you may consider them the same if <u>only</u> the low byte of <b>dwNLSVersion</b> changed (the minor version described above).</li>
     * </ol>
     * This is covered in more detail in the blog entry <a href="https://docs.microsoft.com/archive/blogs/shawnste/">"How to tell if the collation version changed"</a> (http://blogs.msdn.com/shawnste/archive/2007/06/01/how-to-tell-if-the-collation-version-changed.aspx).
     * 
     * This function supports <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. If <i>lpLocaleName</i> specifies a supplemental locale, the data retrieved is the correct data for the sort order associated with that supplemental locale.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Integer} function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFOEX>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c> sizeof(NLSVERSIONINFOEX)</c>. 
     * 
     * <div class="alert"><b>Note</b>On WindowsVista and later, the function can alternatively provide version information in an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure.</div>
     * <div></div>
     * @returns {BOOL} Returns <b>TRUE</b> if and only if the application has supplied valid values in <i>lpVersionInformation</i>, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-getnlsversionex
     * @since windows6.0.6000
     */
    static GetNLSVersionEx(function, lpLocaleName, lpVersionInformation) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNLSVersionEx", "uint", function, "ptr", lpLocaleName, "ptr", lpVersionInformation, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if the NLS version is valid for a given NLS function.
     * @remarks
     * Initialize the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNLSVersionEx</a>. See the Remarks for <b>GetNLSVersionEx</b> for a discussion on how the members of <b>NLSVERSIONINFOEX</b> can be used to determine if a sort version has changed and you need to reindex data.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Integer} function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFOEX>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c> sizeof(NLSVERSIONINFOEX)</c>.
     * @returns {Integer} Returns a nonzero value if the NLS version is valid, or zero if the version is invalid.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidnlsversion
     * @since windows8.0
     */
    static IsValidNLSVersion(function, lpLocaleName, lpVersionInformation) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        result := DllCall("KERNEL32.dll\IsValidNLSVersion", "uint", function, "ptr", lpLocaleName, "ptr", lpVersionInformation, "uint")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by name.CautionBecause strings with very different binary representations can compare as identical, this function can raise certain security concerns. For more information, see the discussion of comparison functions in Security Considerations:\_International Features.
     * @remarks
     * This function provides a variety of search options, including search direction, character equivalence filtering, and locale-specific filtering. Note that equivalence depends on the locale and flags specified in the call to the function. The filtering flags can alter the results of the search. For example, the potential matches increase when the function ignores case or diacritic marks when performing the search.
     * 
     * By default, this function maps the lowercase "i" to the uppercase "I", even when the <i>Locale</i> parameter specifies Turkish (Turkey) or Azerbaijani (Azerbaijan). To override this behavior for Turkish or Azerbaijani, the application should specify NORM_LINGUISTIC_CASING. If this flag is specified for the correct locale, "" (lowercase dotless I) is the lowercase form of "I" (uppercase dotless I) and "i" (lowercase dotted I) is the lowercase form of "" (uppercase dotted I).
     * 
     * 
     * For many scripts (notably Latin scripts), NORM_IGNORENONSPACE coincides with LINGUISTIC_IGNOREDIACRITIC and NORM_IGNORECASE coincides with LINGUISTIC_IGNORECASE, with the following exceptions:
     * 
     * <ul>
     * <li>NORM_IGNORENONSPACE ignores any secondary distinction, whether or not it is a diacritic. Scripts for Korean, Japanese, Chinese, Indic languages, and others use this distinction for purposes other than diacritics. LINGUISTIC_IGNOREDIACRITIC ignores only actual diacritics, instead of simply ignoring the second sorting weight.</li>
     * <li>NORM_IGNORECASE ignores any tertiary distinction, whether or not it is actually linguistic case. For example, in Arabic and Indic scripts, this flag distinguishes alternate forms of a character. However, the differences do not correspond to linguistic case. LINGUISTIC_IGNORECASE ignores only actual linguistic casing, instead of ignoring the third sorting weight.</li>
     * </ul>
     * In contrast to other NLS API functions, which return 0 for failure, this function returns -1 if it fails. On success, it returns a 0-based index. Use of this index helps the function avoid off-by-one errors and one-character buffer overruns.
     * 
     * This function is one of the few NLS functions that calls <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> even when it succeeds. It makes this call to clear the last error in a thread when it fails to match the search string. This clears the value returned by <b>GetLastError</b>.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFindNLSStringFlags Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags with any of the filtering flags defined in the next table. If the application does not specify a flag, the function uses the default comparison for the specified locale. As discussed in <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>, there is no binary comparison mode.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMSTART"></a><a id="find_fromstart"></a><dl>
     * <dt><b>FIND_FROMSTART</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string, starting with the first character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMEND"></a><a id="find_fromend"></a><dl>
     * <dt><b>FIND_FROMEND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string in the reverse direction, starting with the last character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_STARTSWITH"></a><a id="find_startswith"></a><dl>
     * <dt><b>FIND_STARTSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the first value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_ENDSWITH"></a><a id="find_endswith"></a><dl>
     * <dt><b>FIND_ENDSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the last value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The application can use the filtering flags defined below in combination with a find flag.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNORECASE"></a><a id="linguistic_ignorecase"></a><dl>
     * <dt><b>LINGUISTIC_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case in the search, as linguistically appropriate. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNOREDIACRITIC"></a><a id="linguistic_ignorediacritic"></a><dl>
     * <dt><b>LINGUISTIC_IGNOREDIACRITIC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore diacritics, as linguistically appropriate. For more information, see the Remarks section.
     * 
     * <div class="alert"><b>Note</b>This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORECASE"></a><a id="norm_ignorecase"></a><dl>
     * <dt><b>NORM_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case in the search. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREKANATYPE"></a><a id="norm_ignorekanatype"></a><dl>
     * <dt><b>NORM_IGNOREKANATYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORENONSPACE"></a><a id="norm_ignorenonspace"></a><dl>
     * <dt><b>NORM_IGNORENONSPACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORESYMBOLS"></a><a id="norm_ignoresymbols"></a><dl>
     * <dt><b>NORM_IGNORESYMBOLS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore symbols and punctuation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREWIDTH"></a><a id="norm_ignorewidth"></a><dl>
     * <dt><b>NORM_IGNOREWIDTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_LINGUISTIC_CASING"></a><a id="norm_linguistic_casing"></a><dl>
     * <dt><b>NORM_LINGUISTIC_CASING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use linguistic rules for casing, instead of file system rules (default). For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {PWSTR} lpStringValue Pointer to the search string, for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<Integer>} pcchFound Pointer to a buffer containing the length of the string that the function finds. The string can be either longer or shorter than the search string. If the function fails to find the search string, this parameter is not modified.
     * 
     * The function can retrieve <b>NULL</b> in this parameter. In this case, the function makes no indication if the length of the found string differs from the length of the source string. 
     * 
     * Note that the value of <i>pcchFound</i> is often identical to the value provided in <i>cchValue</i>, but can differ in the following cases:
     * 
     * <ul>
     * <li>The value provided in <i>cchValue</i> is negative.</li>
     * <li>The strings are equivalent, but have different lengths. For example, "A" plus "Combining Ring" (U+0041 U+030A) is equivalent to the "A Ring" (U+00c5).</li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Reserved; must be <b>NULL</b>.
     * @param {LPARAM} sortHandle Reserved; must be 0.
     * @returns {Integer} Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. In combination with the value in <i>pcchFound</i>, this index provides the exact location of the entire found string in the source string. A return value of 0 is an error-free index into the source string, and the matching string is in the source string at offset 0.
     * 
     * The function returns -1 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-findnlsstringex
     * @since windows6.0.6000
     */
    static FindNLSStringEx(lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, sortHandle) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpStringSource := lpStringSource is String ? StrPtr(lpStringSource) : lpStringSource
        lpStringValue := lpStringValue is String ? StrPtr(lpStringValue) : lpStringValue

        pcchFoundMarshal := pcchFound is VarRef ? "int*" : "ptr"

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNLSStringEx", "ptr", lpLocaleName, "uint", dwFindNLSStringFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, pcchFoundMarshal, pcchFound, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", sortHandle, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * For a locale specified by name, maps an input character string to another using a specified transformation, or generates a sort key for the input string.NoteThe application should call this function in preference to LCMapString if designed to run only on WindowsVista and later.
     * @remarks
     * The application can use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a> or <b>LCMapStringEx</b> to generate a sort key. To do this, the application specifies  LCMAP_SORTKEY for the <i>dwMapFlags</i> parameter. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * 
     * > [!NOTE]
     * > Sort keys are opaque byte streams. Callers should treat them as a byte array of the length returned by the API and not rely on any internal structure that may appear to be present. Zero, one or more of the bytes in the returned sort key could be 0. Absence or presence of a zero byte should not be expected.
     * 
     * Another way for your application to use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a> or <b>LCMapStringEx</b> is in mapping strings. In this case, the application does not specify LCMAP_SORTKEY for the <i>dwMapFlags</i> parameter, but supplies some other combination of flags. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.
     * 
     * <b>Beginning in WindowsVista:</b> This function can handle data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flag specifying the type of transformation to use during string mapping or the type of sort key to generate. This parameter can have the following values.
     * 
     * | Flag | Meaning |
     * | --- | --- |
     * | **LCMAP_BYTEREV**| Use byte reversal. For example, if the application passes in 0x3450 0x4822, the result is 0x5034 0x2248. |
     * | **LCMAP_FULLWIDTH** | Use Unicode (wide) characters where applicable. This flag and LCMAP_HALFWIDTH are mutually exclusive. With this flag, the mapping may use Normalization Form C even if an input character is already full-width. For example, the string "" (which is already full-width) is normalized to "". See [Unicode normalization forms](http://www.unicode.org/reports/tr15/). |
     * |**LCMAP_HALFWIDTH** | Use narrow characters where applicable. This flag and LCMAP_FULLWIDTH are mutually exclusive. |
     * | **LCMAP_HIRAGANA** | Map all katakana characters to hiragana. This flag and LCMAP_KATAKANA are mutually exclusive. |
     * | **LCMAP_KATAKANA** | Map all hiragana characters to katakana. This flag and LCMAP_HIRAGANA are mutually exclusive. |
     * | **LCMAP_LINGUISTIC_CASING** | Use linguistic rules for casing, instead of file system rules (default). This flag is valid with LCMAP_LOWERCASE or LCMAP_UPPERCASE only. |
     * | **LCMAP_LOWERCASE** | For locales and scripts capable of handling uppercase and lowercase, map all characters to lowercase.
     * | **LCMAP_HASH** | Return a hash of the raw sort weights of a string.<br> <br>Strings that appear equivalent typically return the same hash (for example, "hello" and "HELLO" with LCMAP_IGNORECASE). However, some complex cases, such as East Asian languages, can have similar strings with identical weights that compare as equal but do not return the same hash.<br> <br>LCMAP_HASH requires that the output buffer be of size sizeof(int) |
     * | **LCMAP_SIMPLIFIED_CHINESE** | Map traditional Chinese characters to simplified Chinese characters. This flag and LCMAP_TRADITIONAL_CHINESE are mutually exclusive. |
     * | **LCMAP_SORTHANDLE** <br> **The use of a sort handle results in minimal performance improvements and is discouraged.** | Return a token representing the resolved sort parameters for the locale (like locale name), so future calls can pass <c>NULL</c> for the sort name and pass the previously queried sort handle as the last parameter (sortHandle) in subsequent calls to [CompareStringEx](../stringapiset/nf-stringapiset-comparestringex.md) or [LCMapStringEx](nf-winnls-lcmapstringex.md).<br> <br>LCMAP_SORTHANDLE requires that the output buffer be of size sizeof(lparam) |
     * | **LCMAP_SORTKEY** | Produce a normalized sort key. If the LCMAP_SORTKEY flag is not specified, the function performs string mapping. For details of sort key generation and string mapping, see the Remarks section. |
     * | **LCMAP_TITLECASE** | Windows7:</b> Map all characters to title case, in which the first letter of each major word is capitalized. |
     * | **LCMAP_TRADITIONAL_CHINESE** | Map simplified Chinese characters to traditional Chinese characters. This flag and LCMAP_SIMPLIFIED_CHINESE are mutually exclusive. |
     * | **LCMAP_UPPERCASE** | For locales and scripts capable of handling uppercase and lowercase, map all characters to uppercase. |
     * 
     * The following flags can be used alone, with one another, or with the LCMAP_SORTKEY and/or LCMAP_BYTEREV flags. However, they cannot be combined with the other flags listed above.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORENONSPACE"></a><a id="norm_ignorenonspace"></a><dl>
     * <dt><b>NORM_IGNORENONSPACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters. For many scripts (notably Latin scripts), NORM_IGNORENONSPACE coincides with LINGUISTIC_IGNOREDIACRITIC.
     * 
     * <div class="alert"><b>Note</b>NORM_IGNORENONSPACE ignores any secondary distinction, whether it is a diacritic or not. Scripts for Korean, Japanese, Chinese, and Indic languages, among others, use this distinction for purposes other than diacritics. LINGUISTIC_IGNOREDIACRITIC causes the function to ignore only actual diacritics, instead of ignoring the second sorting weight.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORESYMBOLS"></a><a id="norm_ignoresymbols"></a><dl>
     * <dt><b>NORM_IGNORESYMBOLS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore symbols and punctuation.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The flags listed below are used only with the LCMAP_SORTKEY flag.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNORECASE"></a><a id="linguistic_ignorecase"></a><dl>
     * <dt><b>LINGUISTIC_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case, as linguistically appropriate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNOREDIACRITIC"></a><a id="linguistic_ignorediacritic"></a><dl>
     * <dt><b>LINGUISTIC_IGNOREDIACRITIC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters, as linguistically appropriate.
     * 
     * <div class="alert"><b>Note</b>This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORECASE"></a><a id="norm_ignorecase"></a><dl>
     * <dt><b>NORM_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case. For many scripts (notably Latin scripts), NORM_IGNORECASE coincides with LINGUISTIC_IGNORECASE.
     * 
     * <div class="alert"><b>Note</b>NORM_IGNORECASE ignores any tertiary distinction, whether it is actually linguistic case or not. For example, in Arabic and Indic scripts, this flag distinguishes alternate forms of a character, but the differences do not correspond to linguistic case. LINGUISTIC_IGNORECASE causes the function to ignore only actual linguistic casing, instead of ignoring the third sorting weight.</div>
     * <div></div>
     * <div class="alert"><b>Note</b>For double-byte character set (DBCS) locales, NORM_IGNORECASE has an effect on all Unicode characters as well as narrow (one-byte) characters, including Greek and Cyrillic characters.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREKANATYPE"></a><a id="norm_ignorekanatype"></a><dl>
     * <dt><b>NORM_IGNOREKANATYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREWIDTH"></a><a id="norm_ignorewidth"></a><dl>
     * <dt><b>NORM_IGNOREWIDTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_LINGUISTIC_CASING"></a><a id="norm_linguistic_casing"></a><dl>
     * <dt><b>NORM_LINGUISTIC_CASING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use linguistic rules for casing, instead of file system rules (default).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SORT_DIGITSASNUMBERS"></a><a id="sort_digitsasnumbers"></a><dl>
     * <dt><b>SORT_DIGITSASNUMBERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows7:</b> Treat digits as numbers during sorting, for example, sort "2" before "10".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SORT_STRINGSORT"></a><a id="sort_stringsort"></a><dl>
     * <dt><b>SORT_STRINGSORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Treat punctuation the same as symbols.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set this parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapStringEx</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {PWSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure that contains the version information about the relevant NLS capability; usually retrieved from <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNLSVersionEx</a>.
     * 
     * **WindowsVista, Windows7:** Reserved; must set to NULL.
     * @param {LPARAM} sortHandle Reserved; must be 0.
     * 
     * > [!NOTE]
     * > [CompareStringEx](../stringapiset/nf-stringapiset-comparestringex.md) and [LCMapStringEx](nf-winnls-lcmapstringex.md) can specify a sort handle (if the locale name is null).  This use is discouraged for most apps.
     * @returns {Integer} If the function succeeds when used for string mapping, it returns the number of characters in the translated string (see *cchSrc* and *cchDest* for more details).
     * 
     * If the function succeeds when used for string mapping it returns the number of bytes in the sort key.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-lcmapstringex
     * @since windows6.0.6000
     */
    static LCMapStringEx(lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, sortHandle) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LCMapStringEx", "ptr", lpLocaleName, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", sortHandle, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if the specified locale name is valid for a locale that is installed or supported on the operating system.NoteAn application running only on WindowsVista and later should call this function in preference to IsValidLocale to determine the validity of a supplemental locale.
     * @remarks
     * On WindowsVista and later, all supported locales should be installed on all operating systems.
     * 
     * This function can handle the name of a <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locale</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {PWSTR} lpLocaleName Pointer to the locale name to validate.
     * @returns {BOOL} Returns a nonzero value if the locale name is valid, or returns 0 for an invalid name.
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-isvalidlocalename
     * @since windows6.0.6000
     */
    static IsValidLocaleName(lpLocaleName) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        result := DllCall("KERNEL32.dll\IsValidLocaleName", "ptr", lpLocaleName, "int")
        return result
    }

    /**
     * Enumerates calendar information for a locale specified by name.NoteThe application should call this function in preference to EnumCalendarInfo or EnumCalendarInfoEx if designed to run only on WindowsVista and later.NoteThis function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * This function enumerates calendar information for all applicable calendars for the specified locale, or for a single requested calendar, depending on the value of the <i>Calendar</i> parameter. The function enumerates the calendar information by calling the specified application-defined callback function. It passes the callback function a pointer to a buffer containing the requested calendar information, a calendar identifier, and an application-defined parameter that is useful for multi-threaded applications. This process continues until <b>EnumCalendarInfoExEx</b> finds the last applicable calendar or the callback function returns <b>FALSE</b>.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<CALINFO_ENUMPROCEXEX>} pCalInfoEnumProcExEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317808(v=vs.85)">EnumCalendarInfoProcExEx</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @param {LPARAM} lParam Application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumcalendarinfoexex
     * @since windows6.0.6000
     */
    static EnumCalendarInfoExEx(pCalInfoEnumProcExEx, lpLocaleName, Calendar, CalType, lParam) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExEx", "ptr", pCalInfoEnumProcExEx, "ptr", lpLocaleName, "uint", Calendar, "ptr", lpReserved, "uint", CalType, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a locale specified by name.NoteThe application should call this function in preference to EnumDateFormats or EnumDateFormatsEx if designed to run only on WindowsVista and later.NoteThis function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * <div class="alert"><b>Note</b>This API is being updated to support the May 2019 Japanese era change. If your application supports the Japanese calendar, you should validate that it properly handles the new era. See <a href="https://docs.microsoft.com/windows/uwp/design/globalizing/japanese-era-change">Prepare your application for the Japanese era change</a> for more information.</div>
     * <div></div>
     * The function enumerates the date formats by passing date format string pointers, one at a time, to the specified application-defined callback function, along with an application-defined constant that is useful for multi-threaded applications. This process continues until <b>EnumDateFormatsExEx</b> finds the last date format or the callback function returns <b>FALSE</b>.
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<DATEFMT_ENUMPROCEXEX>} lpDateFmtEnumProcExEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317815(v=vs.85)">EnumDateFormatsProcExEx</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {LPARAM} lParam An application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumdateformatsexex
     * @since windows6.0.6000
     */
    static EnumDateFormatsExEx(lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExEx", "ptr", lpDateFmtEnumProcExEx, "ptr", lpLocaleName, "uint", dwFlags, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by name.NoteThe application should call this function in preference to EnumTimeFormats if designed to run only on WindowsVista and later.NoteThis function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @remarks
     * This function enumerates the time formats by passing time format string pointers, one at a time, to the specified application-defined callback function, along with an application-defined constant that is useful for multi-threaded applications. The first value in the enumeration is always the user default (override) value. The function continues enumeration until the last time format is found or the callback function returns <b>FALSE</b>. 
     * 
     * <b>Beginning in Windows8:</b> If your app passes language tags to this function from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace, it must first convert the tags by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a>.
     * @param {Pointer<TIMEFMT_ENUMPROCEX>} lpTimeFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317833(v=vs.85)">EnumTimeFormatsProcEx</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags The time format. Set to 0 to use the current user's long time format, or TIME_NOSECONDS (starting withWindows7) to use the short time format.
     * @param {LPARAM} lParam An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumtimeformatsex
     * @since windows6.0.6000
     */
    static EnumTimeFormatsEx(lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsEx", "ptr", lpTimeFmtEnumProcEx, "ptr", lpLocaleName, "uint", dwFlags, "ptr", lParam, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.NoteThe application should call this function in preference to EnumSystemLocales if designed to run only on WindowsVista and later.
     * @remarks
     * This function enumerates locales by passing locale names, one at a time, to the application-defined callback function specified by <i>lpLocaleEnumProcEx</i>. Enumeration continues until all installed or supported names have been passed to the callback function or the callback function returns <b>FALSE</b>.
     * 
     * The choices for the <i>dwFlags</i> parameter are different from those for <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemlocalesa">EnumSystemLocales</a>, which must distinguish between installed and supported locales.
     * 
     * If <i>dwFlags</i> specifies <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-alternate-sorts">LOCALE_ALTERNATE_SORTS</a>, the callback function is called for every locale that represents an alternate sort order. For example, Spanish (Spain) defaults to international sort order, but traditional sort order is available for an alternate sort. German (Germany) defaults to dictionary sort order, but there is an alternate phone book sort order available.
     * @param {Pointer<LOCALE_ENUMPROCEX>} lpLocaleEnumProcEx Pointer to an application-defined callback function. The <b>EnumSystemLocalesEx</b> function enumerates locales by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-locale_enumprocex">EnumLocalesProcEx</a>.
     * @param {Integer} dwFlags Flags identifying the locales to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-all">LOCALE_ALL</a>.
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-all">LOCALE_ALL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-alternate-sorts">LOCALE_ALTERNATE_SORTS</a>; see Remarks</li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-neutraldata">LOCALE_NEUTRALDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-supplemental">LOCALE_SUPPLEMENTAL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-windows">LOCALE_WINDOWS</a>
     * </li>
     * </ul>
     * @param {LPARAM} lParam An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-enumsystemlocalesex
     * @since windows6.0.6000
     */
    static EnumSystemLocalesEx(lpLocaleEnumProcEx, dwFlags, lParam) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesEx", "ptr", lpLocaleEnumProcEx, "uint", dwFlags, "ptr", lParam, "ptr", lpReserved, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Finds a possible locale name match for the supplied name.
     * @remarks
     * The retrieved locale name indicates a specific locale, including language and country/region, even if the input language is neutral. For example, an input of "en" for English (United States) causes the function to retrieve "en-US".
     * 
     * This function can retrieve data from <a href="https://docs.microsoft.com/windows/desktop/Intl/custom-locales">custom locales</a>. Data is not guaranteed to be the same from computer to computer or between runs of an application, nor does the return of a valid locale guarantee that it will be valid on another computer. If your application must persist or transmit data, see <a href="https://docs.microsoft.com/windows/desktop/Intl/using-persistent-locale-data">Using Persistent Locale Data</a>.
     * 
     * <b>Beginning in Windows8:</b> Language tags obtained from the <a href="https://docs.microsoft.com/uwp/api/Windows.Globalization">Windows.Globalization</a> namespace must be converted by  <b>ResolveLocaleName</b> before they can be used with any National Language Support functions.
     * @param {PWSTR} lpNameToResolve Pointer to a name to resolve, for example, "en-XA" for English (Private Use).
     * @param {PWSTR} lpLocaleName Pointer to a buffer in which this function retrieves the locale name that is the match for the input name. For example, the match for the name "en-XA" is "en-US" for English (United States).
     * 
     * <div class="alert"><b>Note</b>If the function fails, the state of the output buffer is not guaranteed to be accurate. In this case, the application should check the return value and error status set by the function to determine the correct course of action.</div>
     * <div></div>
     * @param {Integer} cchLocaleName Size, in characters, of the buffer indicated by <i>lpLocaleName</i>. The maximum possible length of a locale name, including a terminating null character, is the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply in this parameter.
     * @returns {Integer} Returns the size of the buffer containing the locale name, including the terminating null character, if successful.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winnls/nf-winnls-resolvelocalename
     * @since windows6.1
     */
    static ResolveLocaleName(lpNameToResolve, lpLocaleName, cchLocaleName) {
        lpNameToResolve := lpNameToResolve is String ? StrPtr(lpNameToResolve) : lpNameToResolve
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ResolveLocaleName", "ptr", lpNameToResolve, "ptr", lpLocaleName, "int", cchLocaleName, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a list of available ELS platform-supported services, along with associated information, according to application-specified criteria.
     * @remarks
     * The ELS application can either retrieve all services or filter the services according to specified options. For an associated procedure and code sample, see <a href="https://docs.microsoft.com/windows/desktop/Intl/enumerating-and-freeing-services">Enumerating and Freeing Services</a>.
     * 
     * To avoid resource leaks, the application must free the pointer indicated by <i>prgServices</i> with a call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingfreeservices">MappingFreeServices</a>.  
     * 
     * 
     * For performance reasons, it is recommended to retrieve services infrequently. For example, if the application needs a specific service, by GUID, it can be enumerated when needed and cached for future use.
     * @param {Pointer<MAPPING_ENUM_OPTIONS>} pOptions Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_enum_options">MAPPING_ENUM_OPTIONS</a> structure containing criteria to use during enumeration of services. The application specifies <b>NULL</b> for this parameter to retrieve all installed services.
     * @param {Pointer<Pointer<MAPPING_SERVICE_INFO>>} prgServices Address of a pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structures containing service information matching the criteria supplied in the <i>pOptions</i> parameter.
     * @param {Pointer<Integer>} pdwServicesCount Pointer to a DWORD variable in which this function retrieves the number of retrieved services.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.<div class="alert"><b>Note</b>The application must test for any failure before proceeding with further operations.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappinggetservices
     * @since windows6.1
     */
    static MappingGetServices(pOptions, prgServices, pdwServicesCount) {
        prgServicesMarshal := prgServices is VarRef ? "ptr*" : "ptr"
        pdwServicesCountMarshal := pdwServicesCount is VarRef ? "uint*" : "ptr"

        result := DllCall("elscore.dll\MappingGetServices", "ptr", pOptions, prgServicesMarshal, prgServices, pdwServicesCountMarshal, pdwServicesCount, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees memory and resources allocated for the application to interact with one or more ELS services. The memory and resources are allocated in an application call to MappingGetServices.
     * @remarks
     * <div class="alert"><b>Caution</b>Services should not be freed before freeing the property bags produced by those services.</div>
     * <div></div>
     * Since all services currently run in the application process, the ELS platform does not unload the service DLLs when the services are released. The operating system unloads the DLLs automatically when the application terminates.
     * @param {Pointer<MAPPING_SERVICE_INFO>} pServiceInfo Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structures containing service descriptions retrieved by a prior call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappinggetservices">MappingGetServices</a>. This parameter cannot be set to <b>NULL</b>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappingfreeservices
     * @since windows6.1
     */
    static MappingFreeServices(pServiceInfo) {
        result := DllCall("elscore.dll\MappingFreeServices", "ptr", pServiceInfo, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Calls upon an ELS service to recognize text. For example, the Microsoft Language Detection service will attempt to recognize the language in which the input text is written.
     * @remarks
     * The type of text to recognize depends on the service type used by the application. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/requesting-text-recognition">Requesting Text Recognition</a>.
     * 
     * <div class="alert"><b>Warning</b>The data referred to by <i>pszText</i> and <i>pOptions</i> must remain valid until the property bag structure passed by <i>pBag</i> is freed via 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingfreepropertybag">MappingFreePropertyBag</a>. This is because both synchronous and asynchronous calls to 
     * 
     * <b>MappingRecognizeText</b> and <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingdoaction">MappingDoAction</a> will attempt to use the data passed to the initial 
     * 
     * call to <b>MappingRecognizeText</b>.</div>
     * <div></div>
     * @param {Pointer<MAPPING_SERVICE_INFO>} pServiceInfo Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structure containing information about the service to use in text recognition. The structure must be one of the structures retrieved by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappinggetservices">MappingGetServices</a>. This parameter cannot be set to <b>NULL</b>.
     * @param {PWSTR} pszText Pointer to the text to recognize. The text must be UTF-16, but some services have additional requirements for the input format. This parameter cannot be set to <b>NULL</b>.
     * @param {Integer} dwLength Length, in characters, of the text specified in <i>pszText</i>.
     * @param {Integer} dwIndex Index inside the specified text to be used by the service. This value should be between 0 and <i>dwLength</i>-1. If the application wants to process the entire text, it should set this parameter to 0.
     * @param {Pointer<MAPPING_OPTIONS>} pOptions Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_options">MAPPING_OPTIONS</a> structure containing options that affect the result and behavior of text recognition. The application does not have to specify values for all structure members. This parameter can be set to <b>NULL</b> to use the default mapping options.
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pbag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure in which the service stores its results. On input, the application passes a structure with only the size provided, and the other members set to 0. On output, the structure is filled with information produced by the service during text recognition. This parameter cannot be set to <b>NULL</b>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappingrecognizetext
     * @since windows6.1
     */
    static MappingRecognizeText(pServiceInfo, pszText, dwLength, dwIndex, pOptions, pbag) {
        pszText := pszText is String ? StrPtr(pszText) : pszText

        result := DllCall("elscore.dll\MappingRecognizeText", "ptr", pServiceInfo, "ptr", pszText, "uint", dwLength, "uint", dwIndex, "ptr", pOptions, "ptr", pbag, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Causes an ELS service to perform an action after text recognition has occurred. For example, a phone dialer service first must recognize phone numbers and then can perform the &quot;action&quot; of dialing a number.
     * @remarks
     * The application must precede the call to <b>MappingDoAction</b> with a call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a>.
     * 
     * <div class="alert"><b>Warning</b>The data referred to by the <i>pszText</i> and <i>pOptions</i> arguments passed to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a> 
     * 
     * must remain valid until the property bag structure passed by <i>pBag</i> is freed via 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingfreepropertybag">MappingFreePropertyBag</a>. This is because both synchronous and asynchronous calls to 
     * 
     * <b>MappingRecognizeText</b> and <b>MappingDoAction</b> will attempt to use the data passed to the initial 
     * 
     * call to <b>MappingRecognizeText</b>.</div>
     * <div></div>
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pBag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure containing the results of a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a>. This parameter cannot be set to <b>NULL</b>.
     * @param {Integer} dwRangeIndex A starting index inside the text recognition results for a recognized text range. This value should be between 0 and the range count.
     * @param {PWSTR} pszActionId Pointer to the identifier of the action to perform. This parameter cannot be set to <b>NULL</b>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappingdoaction
     * @since windows6.1
     */
    static MappingDoAction(pBag, dwRangeIndex, pszActionId) {
        pszActionId := pszActionId is String ? StrPtr(pszActionId) : pszActionId

        result := DllCall("elscore.dll\MappingDoAction", "ptr", pBag, "uint", dwRangeIndex, "ptr", pszActionId, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees memory and resources allocated during an ELS text recognition operation.
     * @remarks
     * An ELS service allocates memory and resources for data retrieved from application calls to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a>. The <b>MappingFreePropertyBag</b> function releases these resources.
     * 
     * <div class="alert"><b>Caution</b>Services should not be freed before freeing the property bags produced by those services.</div>
     * <div></div>
     * <div class="alert"><b>Caution</b>The application must call this function only once for each call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a> when the property bag is no longer needed. Not calling <b>MappingFreePropertyBag</b> after each call to <b>MappingRecognizeText</b> causes a resource leak. For more information about memory allocation for the property bag, see the remarks for the <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure.</div>
     * <div></div>
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pBag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure containing the properties for which to free resources. This parameter cannot be set to <b>NULL</b>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/elscore/nf-elscore-mappingfreepropertybag
     * @since windows6.1
     */
    static MappingFreePropertyBag(pBag) {
        result := DllCall("elscore.dll\MappingFreePropertyBag", "ptr", pBag, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees a script cache.
     * @remarks
     * An application can free the script cache at any time, with certain limitations if the application is multi-threaded. Uniscribe maintains reference counts in its <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">font and shaper caches</a> and frees font data only when all sizes of the font are free. It frees shaper data only when all supported fonts are freed.
     * 
     * The application should free the script cache for a style when it discards that style.
     * 
     * <b>ScriptFreeCache</b> always sets its parameter to <b>NULL</b> to help avoid misreferencing.
     * 
     * Uniscribe functions are re-entrant. Cache creation is interlocked through a single process-wide semaphore. <b>ScriptFreeCache</b> should not be called at a time when another thread might be accessing the particular cache to free. For performance reasons, the cache is not locked during <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> or <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Pointer<Void>>} psc Pointer to the <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application cant test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptfreecache
     * @since windows5.0
     */
    static ScriptFreeCache(psc) {
        pscMarshal := psc is VarRef ? "ptr*" : "ptr"

        result := DllCall("USP10.dll\ScriptFreeCache", pscMarshal, psc, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Breaks a Unicode string into individually shapeable items.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * The function delimits items by either a change of shaping engine or a change of direction.
     * 
     * The application can create multiple ranges, or runs that fall entirely within a single item, from each <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structure retrieved by <b>ScriptItemize</b>. However, it should not combine multiple items into a single run. Later, when measuring or rendering, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> for each run and must pass the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure retrieved by <b>ScriptItemize</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structure.
     * 
     * If the text handled by an application can include any right-to-left content, the application uses the <i>psControl</i> and <i>psState</i> parameters in calling <b>ScriptItemize</b>. However, the application does not have to do this and can handle bidirectional text itself instead of relying on Uniscribe to do so. The <i>psControl</i> and <i>psState</i> parameters are useful in some strictly left-to-right scenarios, for example, when the <b>fLinkStringBefore</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> is not specific to right-to-left scripts. The application sets <i>psControl</i> and <i>psState</i> to <b>NULL</b> to have <b>ScriptItemize</b> break the Unicode string purely by character code.
     * 
     * The application can set all parameters to non-<b>NULL</b> values to have the function perform a full Unicode bidirectional analysis. To permit a correct Unicode bidirectional analysis, the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure should be initialized according to the reading order at paragraph start, and <b>ScriptItemize</b> should be passed the whole paragraph. In particular, the <b>uBidiLevel</b> member should be initialized to 0 for left-to-right and 1 for right-to-left.
     * 
     * The <b>fRTL</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> is referenced in <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> enabled="1". The <b>fNumeric</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> is retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetproperties">ScriptGetProperties</a>. These members together provide the same classification as the <b>lpClass</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-gcp_resultsa">GCP_RESULTS</a>, referenced by <i>lpResults</i> in <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a>.
     * 
     * European digits U+0030 through U+0039 can be rendered as national digits, as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>SCRIPT_STATE.fDigitSubstitute</th>
     * <th>SCRIPT_CONTROL.fContextDigits</th>
     * <th>Digit shapes displayed for Unicode U+0030 through U+0039</th>
     * </tr>
     * <tr>
     * <td><b>FALSE</b></td>
     * <td>Any</td>
     * <td>European digits</td>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td><b>FALSE</b></td>
     * <td>As specified in <b>uDefaultLanguage</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a>.</td>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td><b>TRUE</b></td>
     * <td>As prior strong text, defaulting to <b>uDefaultLanguage</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a>.</td>
     * </tr>
     * </table>
     * 
     * 
     * In context digit mode, one of the following actions occurs:
     * 
     * <ul>
     * <li>If the script specified by <b>uDefaultLanguage</b> is in the same direction as the output, all digits encountered before the first letters are rendered in the language indicated by <b>uDefaultLanguage</b>.</li>
     * <li>If the script specified by <b>uDefaultLanguage</b> is in the opposite direction from the output, all digits encountered before the first letters are rendered in European digits.</li>
     * </ul>
     * For example, if <b>uDefaultLanguage</b> indicates LANG_ARABIC, initial digits are in Arabic-Indic in a right-to-left embedding. However, they are in European digits in a left-to-right embedding.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/digit-shapes">Digit Shapes</a>.
     * 
     * The Unicode control characters and definitions, and their effects on <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> members, are provided in the following table. For more information on Unicode control characters, see the <a href="https://www.unicode.org/standard/standard.html">The Unicode Standard</a>.
     * 
     * <table>
     * <tr>
     * <th>Unicode control characters</th>
     * <th>Meaning</th>
     * <th>Effect on SCRIPT_STATE</th>
     * </tr>
     * <tr>
     * <td>NADS</td>
     * <td>Override European digits (NODS) with national digit shapes.</td>
     * <td>Set <b>fDigitSubstitute</b>.</td>
     * </tr>
     * <tr>
     * <td>NODS</td>
     * <td>Use nominal digit shapes, otherwise known as European digits. See NADS.</td>
     * <td>Clear <b>fDigitSubstitute</b>.</td>
     * </tr>
     * <tr>
     * <td>ASS</td>
     * <td>Activate swapping of symmetric pairs, for example, parentheses. For these characters, left and right are interpreted as opening and closing. This is the default. See ISS.</td>
     * <td>Clear <b>fInhibitSymSwap</b>.</td>
     * </tr>
     * <tr>
     * <td>ISS</td>
     * <td>Inhibit swapping of symmetric pairs. See ASS.</td>
     * <td>Set <b>fInhibitSymSwap</b>.</td>
     * </tr>
     * <tr>
     * <td>AAFS</td>
     * <td>Activate Arabic form shaping for Arabic presentation forms. See IAFS.</td>
     * <td>Set <b>fCharShape</b>.</td>
     * </tr>
     * <tr>
     * <td>IAFS</td>
     * <td>Inhibit Arabic form shaping, that is, ligatures and cursive connections, for Arabic presentation forms. Nominal Arabic characters are not affected. This is the default. See AAFS.</td>
     * <td>Clear <b>fCharShape</b>.</td>
     * </tr>
     * </table>
     * 
     * 
     * The <b>fArabicNumContext</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> supports the context-sensitive display of numerals in Arabic script text. It indicates if digits are rendered using native Arabic script digit shapes or European digits. At the beginning of a paragraph, this member should normally be initialized to <b>TRUE</b> for an Arabic locale, or <b>FALSE</b> for any other locale. The function updates the script state it as it processes strong text.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {PWSTR} pwcInChars Pointer to a Unicode string to itemize.
     * @param {Integer} cInChars Number of characters in <i>pwcInChars</i> to itemize.
     * @param {Integer} cMaxItems Maximum number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures defining items to process.
     * @param {Pointer<SCRIPT_CONTROL>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure indicating the type of itemization to perform.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if no <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> properties are needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_STATE>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure indicating the initial bidirectional algorithm state.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if the script state is not needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ITEM>} pItems Pointer to a buffer in which the function retrieves <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures representing the items that have been processed. The buffer should be  <c>(cMaxItems + 1) * sizeof(SCRIPT_ITEM)</c> bytes in length. It is invalid to call this function with a buffer to hold less than two <b>SCRIPT_ITEM</b> structures. The function always adds a terminal item to the item analysis array so that the length of the item with zero-based index "i" is always available as:
     * 
     * <c>pItems[i+1].iCharPos - pItems[i].iCharPos;</c>
     * @returns {Integer} Pointer to the number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures processed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptitemize
     * @since windows5.0
     */
    static ScriptItemize(pwcInChars, cInChars, cMaxItems, psControl, psState, pItems) {
        pwcInChars := pwcInChars is String ? StrPtr(pwcInChars) : pwcInChars

        result := DllCall("USP10.dll\ScriptItemize", "ptr", pwcInChars, "int", cInChars, "int", cMaxItems, "ptr", psControl, "ptr", psState, "ptr", pItems, "int*", &pcItems := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcItems
    }

    /**
     * Converts an array of run embedding levels to a map of visual-to-logical position and/or logical-to-visual position.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function handles only data that pertains to a single line of text.
     * 
     * The run embedding levels are defined in the Unicode bidirectional algorithm. They describe the direction of a run, the direction of any runs in which it is embedded, and the direction of the paragraph. No other input is required for the call to this function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/unicode">Unicode</a>.
     * 
     * The following table lists the predefined embedding levels. The application can add levels as needed.
     * 
     * <table>
     * <tr>
     * <th>Level</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>A left-to-right run in a left-to-right paragraph.</td>
     * </tr>
     * <tr>
     * <td>1</td>
     * <td>A right-to-left run embedded in a left-to-right run in a left-to-right paragraph. Alternatively, a right-to-left run, not embedded in another run, in a right-to-left paragraph.</td>
     * </tr>
     * <tr>
     * <td>2</td>
     * <td>A left-to-right run embedded in a right-to-left run of type 1.</td>
     * </tr>
     * <tr>
     * <td>3</td>
     * <td>A right-to-left run embedded in a left-to-right run of type 2.</td>
     * </tr>
     * </table>
     * 
     * 
     * A "logical position" refers to the placement of a run relative to other runs. It is the position in a backing store, and corresponds to the order in which the user reads the text aloud. The "visual position" of a run refers to the way the run is visually displayed on the line, taking into account the possible directions that the run can have.
     * 
     * The application can call this function setting either <i>piLogicalToVisual</i> or <i>piVisualToLogical</i>, or both.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Integer} cRuns Number of runs to process.
     * @param {Pointer<Integer>} pbLevel Pointer to an array, of length indicated by <i>cRuns</i>, containing run embedding levels. Embedding levels for all runs on the line must be included, ordered logically. For more information, see the Remarks section.
     * @param {Pointer<Integer>} piVisualToLogical Pointer to an array, of length indicated by <i>cRuns</i>, in which this function retrieves the run embedding levels reordered to visual order. The first array element represents the run to display at the far left, and subsequent entries should be displayed progressing from left to right. The function sets this parameter to <b>NULL</b> if there is no output.
     * @param {Pointer<Integer>} piLogicalToVisual Pointer to an array, of length indicated by <i>cRuns</i>, in which this function retrieves the visual run positions. The first array element is the relative visual position where the first logical run should be displayed, the leftmost display position being 0. The function sets this parameter to <b>NULL</b> if there is no output.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptlayout
     * @since windows5.0
     */
    static ScriptLayout(cRuns, pbLevel, piVisualToLogical, piLogicalToVisual) {
        pbLevelMarshal := pbLevel is VarRef ? "char*" : "ptr"
        piVisualToLogicalMarshal := piVisualToLogical is VarRef ? "int*" : "ptr"
        piLogicalToVisualMarshal := piLogicalToVisual is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptLayout", "int", cRuns, pbLevelMarshal, pbLevel, piVisualToLogicalMarshal, piVisualToLogical, piLogicalToVisualMarshal, piLogicalToVisual, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * If this function returns E_OUTOFMEMORY, the application might call <b>ScriptShape</b> repeatedly, with successively larger output buffers, until a large enough buffer is provided. The number of glyphs generated by a code point varies according to the script and the font. For a simple script, a Unicode code point might generate a single glyph. However, a complex script font might construct characters from components, and thus generate several times as many glyphs as characters. Also, there are special cases, such as invalid character representations, in which extra glyphs are added to represent the invalid sequence. Therefore, a reasonable guess for the size of the buffer indicated by <i>pwOutGlyphs</i> is 1.5 times the length of the character buffer, plus an additional 16 glyphs for rare cases, for example, invalid sequence representation.
     * 
     * This function can set the <b>fNoGlyphIndex</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure if the font or operating system cannot support glyph indexes.
     * 
     * The application can call <b>ScriptShape</b> to determine if a font supports the characters in a given string. If the function returns S_OK, the application should check the output for missing glyphs. If <b>fLogicalOrder</b> is set to <b>TRUE</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure, the function always generates glyphs in the same order as the original Unicode characters. If <b>fLogicalOrder</b> is set to <b>FALSE</b>, the function generates right-to-left items in reverse order so that <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a> does not have to reverse them before calling <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a>.
     * 
     * If the <b>eScript</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> is set to SCRIPT_UNDEFINED, shaping is disabled. In this case, <b>ScriptShape</b> displays the glyph that is in the font cmap table. If no glyph is in the table, the function indicates that glyphs are missing.
     * 
     * <b>ScriptShape</b> sequences clusters uniformly within the run, and sequences glyphs uniformly within a cluster. It uses the value of the <b>fRTL</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a>, from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>, to identify sequencing as left-to-right or right-to-left.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {PWSTR} pwcChars Pointer to an array of Unicode characters defining the run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Integer} cMaxGlyphs Maximum number of glyphs to generate, and the length of <i>pwOutGlyphs</i>. A reasonable value is <c>(1.5 * cChars + 16)</c>, but this value might be insufficient in some circumstances. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure for the run, containing the results from an earlier call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<Integer>} pwOutGlyphs Pointer to a buffer in which this function retrieves an array of glyphs with size as indicated by <i>cMaxGlyphs</i>.
     * @param {Pointer<Integer>} pwLogClust Pointer to a buffer in which this function retrieves an array of logical cluster information. Each array element corresponds to a character in the array of Unicode characters; therefore this array has the number of elements indicated by cChars. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member is set to <b>TRUE</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure, the elements decrease as the array is read.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures containing visual attribute information. Since each glyph has only one visual attribute, this array has the number of elements indicated by <i>cMaxGlyphs</i>.
     * @param {Pointer<Integer>} pcGlyphs Pointer to the location in which this function retrieves the number of glyphs indicated in <i>pwOutGlyphs</i>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, the content of all output parameters is undefined.
     * 
     * Error returns include:
     * 
     * <ul>
     * <li>E_OUTOFMEMORY. The output buffer length indicated by <i>cMaxGlyphs</i> is insufficient.</li>
     * <li>E_PENDING. The script cache specified by the <i>psc</i> parameter does not contain enough information to shape the string, and the device context has been passed as <b>NULL</b> so that the function is unable to complete the shaping process. The application should set up a correct device context for the run, and call this function again with the appropriate value in <i>hdc</i> and with all other parameters the same.</li>
     * <li>USP_E_SCRIPT_NOT_IN_FONT. The font corresponding to the device context does not support the script required by the run indicated by <i>pwcChars</i>. The application should choose another font, using either <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetcmap">ScriptGetCMap</a> or another function to select the font.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptshape
     * @since windows5.0
     */
    static ScriptShape(hdc, psc, pwcChars, cChars, cMaxGlyphs, psa, pwOutGlyphs, pwLogClust, psva, pcGlyphs) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc
        pwcChars := pwcChars is String ? StrPtr(pwcChars) : pwcChars

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        pwOutGlyphsMarshal := pwOutGlyphs is VarRef ? "ushort*" : "ptr"
        pwLogClustMarshal := pwLogClust is VarRef ? "ushort*" : "ptr"
        pcGlyphsMarshal := pcGlyphs is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptShape", "ptr", hdc, pscMarshal, psc, "ptr", pwcChars, "int", cChars, "int", cMaxGlyphs, "ptr", psa, pwOutGlyphsMarshal, pwOutGlyphs, pwLogClustMarshal, pwLogClust, "ptr", psva, pcGlyphsMarshal, pcGlyphs, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Generates glyph advance width and two-dimensional offset information from the output of ScriptShape.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * The composite ABC width for the whole item identifies how much the glyphs <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">overhang</a> to the left of the start position and to the right of the length implied by the sum of the advance widths. The total advance width of the line is exactly abcA+abcB+abcC. The abcA and abcC values are maintained as proportions of the cell height represented in 8 bits and are thus roughly +/-1 percent. The total width retrieved, which is the sum of the abcA+abcB+abcC values indicated by <i>piAdvance</i>, is accurate to the resolution of the TrueType shaping engine.
     * 
     * All arrays are in visual order unless the <b>fLogicalOrder</b> member is set in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by the <i>psa</i> parameter.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<Integer>} pwGlyphs Pointer to a glyph buffer obtained from an earlier call to the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> function.
     * @param {Integer} cGlyphs Count of glyphs in the glyph buffer.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures indicating visual attributes.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. On input, this structure is obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>. On output, this structure contains values retrieved by <b>ScriptPlace</b>.
     * @param {Pointer<GOFFSET>} pGoffset Optional. Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structures in which this function retrieves the x and y offsets of combining glyphs. This array must be of length indicated by <i>cGlyphs</i>.
     * @param {Pointer<ABC>} pABC Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-abc">ABC</a> structure in which this function retrieves the <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> for the entire <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">run</a>.
     * @returns {Integer} Pointer to an array in which this function retrieves advance width information.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptplace
     * @since windows5.0
     */
    static ScriptPlace(hdc, psc, pwGlyphs, cGlyphs, psva, psa, pGoffset, pABC) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        pwGlyphsMarshal := pwGlyphs is VarRef ? "ushort*" : "ptr"

        result := DllCall("USP10.dll\ScriptPlace", "ptr", hdc, pscMarshal, psc, pwGlyphsMarshal, pwGlyphs, "int", cGlyphs, "ptr", psva, "ptr", psa, "int*", &piAdvance := 0, "ptr", pGoffset, "ptr", pABC, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return piAdvance
    }

    /**
     * Displays text for the specified script shape and place information.
     * @remarks
     * This function calls the operating system <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a> function for text display. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a>.
     * 
     * All arrays are in display order unless the <b>fLogicalOrder</b> member is set in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by <i>psa</i>.
     * 
     * For any run that is rendered right-to-left and was generated in logical order by forcing the <b>fLogicalOrder</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a>, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-settextalign">SetTextAlign</a> (hdc, TA_RIGHT) and give the right-side coordinate before calling <b>ScriptTextOut</b>.
     * 
     * The array indicated by <i>piJustify</i> provides cell widths for each glyph. When the width of a glyph differs from the unjustified width, specified by <i>piAdvance</i>, space is added to or removed from the glyph cell at its trailing edge. The glyph is always aligned with the leading edge of its cell. This rule applies even in visual order.
     * 
     * When a glyph cell is extended, the extra space is usually made up by the addition of white space. However, for Arabic scripts, the extra space is made up by one or more kashida glyphs, unless the extra space is insufficient for the shortest kashida glyph in the font. The width of the shortest kashida is available by calling <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetfontproperties">ScriptGetFontProperties</a>.
     * 
     * The application should pass a value for <i>piJustify</i> only if the string must be justified by <b>ScriptTextOut</b>. Normally, the application should pass <b>NULL</b>.
     * 
     * The application should not use <b>ScriptTextOut</b> to write to a metafile unless the metafile will be played back without any font substitution, for example, immediately on the same system for scalable page preview. <b>ScriptTextOut</b> records glyph numbers in the metafile. Since glyph numbers vary considerably from one font to another, the file is unlikely to play back correctly when different fonts are substituted. For example, when a metafile is played back at a different scale, a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createfonta">CreateFont</a> request recorded in the metafile can resolve to a bitmap instead of a TrueType font. Likewise, if the metafile is played back on a different computer, the requested fonts might not be installed. To write complex scripts in a metafile in a font-independent manner, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a> to write the logical characters directly, so that glyph generation and placement do not occur until the text is played back.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>. Note that, unlike some other related Uniscribe functions, this function defines the handle as mandatory.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Integer} x Value of the x coordinate of the first glyph.
     * @param {Integer} y Value of the y coordinate of the first glyph.
     * @param {Integer} fuOptions Options equivalent to the <i>fuOptions</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a>. This parameter can be set to either ETO_CLIPPED or ETO_OPAQUE, to both values, or to neither value.
     * @param {Pointer<RECT>} lprc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the rectangle used to clip the display. The application can set this parameter to <b>NULL</b>.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<Integer>} pwGlyphs Pointer to an array of glyphs obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>.
     * @param {Integer} cGlyphs Count of the glyphs in the array indicated by <i>pwGlyphs</i>. The maximum number of glyphs is 65,536.
     * @param {Pointer<Integer>} piAdvance Pointer to an array of advance widths obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<Integer>} piJustify Pointer to an array of justified advance widths (cell widths). The application can set this parameter to <b>NULL</b>.
     * @param {Pointer<GOFFSET>} pGoffset Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structure containing the x and y offsets for the combining glyph.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scripttextout
     * @since windows5.0
     */
    static ScriptTextOut(hdc, psc, x, y, fuOptions, lprc, psa, pwGlyphs, cGlyphs, piAdvance, piJustify, pGoffset) {
        static pwcReserved := 0, iReserved := 0 ;Reserved parameters must always be NULL

        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        pwGlyphsMarshal := pwGlyphs is VarRef ? "ushort*" : "ptr"
        piAdvanceMarshal := piAdvance is VarRef ? "int*" : "ptr"
        piJustifyMarshal := piJustify is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptTextOut", "ptr", hdc, pscMarshal, psc, "int", x, "int", y, "uint", fuOptions, "ptr", lprc, "ptr", psa, "ptr", pwcReserved, "int", iReserved, pwGlyphsMarshal, pwGlyphs, "int", cGlyphs, piAdvanceMarshal, piAdvance, piJustifyMarshal, piJustify, "ptr", pGoffset, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates an advance widths table to allow text justification when passed to the ScriptTextOut function.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function provides a simple implementation of multilingual justification. It establishes the amount of adjustment to make at each glyph position on the line. It interprets the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> array generated by a call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>, giving top priority to kashida. The function uses interword spacing if no kashida points are available. It uses intercharacter spacing if no interword points are available.
     * 
     * <div class="alert"><b>Note</b>Sophisticated text formatters might generate their own delta dx array by combining formatter-specific features with the information retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> array.</div>
     * <div></div>
     * The application should pass the justified advance widths generated by <b>ScriptJustify</b> to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a> in the <i>piJustify</i> parameter.
     * 
     * <b>ScriptJustify</b> creates a justified array containing updated advance widths for each glyph. When an advance width for a glyph is increased, the extra width is rendered to the right of the glyph, with a white space or, for Arabic text, a kashida.
     * 
     * <div class="alert"><b>Note</b>Kashida insertion occurs to the right of the glyph to justify visually. Microsoft Word and Microsoft PowerPoint use this concept. Any change in the kashida placement algorithm should accompany a change in the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a> handler for a particular script, for example, the Arabic TextOut justification handler.</div>
     * <div></div>
     * Sometimes the application tries to handle glyphs that cannot be justified, in which case the <b>uJustification</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> is set to SCRIPT_JUSTIFY_NONE. In this case, <b>ScriptJustify</b> copies the input array indicated by <i>piAdvance</i> to the output array indicated by <i>piJustify</i> and returns S_FALSE to the application.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to an array, of length indicated by <i>cGlyphs</i>, containing <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures. Each structure contains visual attributes for a glyph in the line to process.
     * @param {Pointer<Integer>} piAdvance Pointer to an advance widths array, of length indicated by <i>cGlyphs</i>, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Integer} cGlyphs Count of glyphs for the arrays indicated by <i>psva</i> and <i>piAdvance</i>. This parameter also indicates the count of glyphs for the output parameter <i>piJustify</i>.
     * @param {Integer} iDx Width, in pixels, of the desired change, either an increase of decrease.
     * @param {Integer} iMinKashida Minimum width of a kashida glyph to generate.
     * @returns {Integer} Pointer to a buffer in which this function retrieves an array, of length indicated by <i>cGlyphs</i>, containing justified advance widths. The justified widths are sometimes called "cell widths" to distinguish them from unjustified advance widths.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptjustify
     * @since windows5.0
     */
    static ScriptJustify(psva, piAdvance, cGlyphs, iDx, iMinKashida) {
        piAdvanceMarshal := piAdvance is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptJustify", "ptr", psva, piAdvanceMarshal, piAdvance, "int", cGlyphs, "int", iDx, "int", iMinKashida, "int*", &piJustify := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return piJustify
    }

    /**
     * Retrieves information for determining line breaks.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function does not require a device context and does not perform glyph shaping.
     * 
     * This function retrieves cursor movement and formatting break positions for an item in an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structures. To support mixed formatting within a single word correctly, the call to <b>ScriptBreak</b> should pass whole items as retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>, and not the finer formatting runs.
     * 
     * The <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structure identifies valid caret positions and line breaks. The <b>fCharStop</b> member specifies a flag that marks cluster boundaries for scripts that are conventionally restricted from moving inside clusters. The same boundaries can also be inferred by inspecting the logical cluster information retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>. However, <b>ScriptBreak</b> is considerably faster in implementation and does not require a device context to be prepared.
     * 
     * The flags designated by the <b>fWordStop</b>, <b>fSoftBreak</b>, and <b>fWhiteSpace</b> members of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> are only available through <b>ScriptBreak</b>.
     * 
     * Most shaping engines that identify invalid sequences set the flag indicated by the <b>fInvalid</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> in <b>ScriptBreak</b>. The <b>fInvalidLogAttr</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> identifies the applicable scripts.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {PWSTR} pwcChars Pointer to the Unicode characters to process.
     * @param {Integer} cChars Number of Unicode characters to process.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from an earlier call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<SCRIPT_LOGATTR>} psla Pointer to a buffer in which this function retrieves the character attributes as a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structure.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptbreak
     * @since windows5.0
     */
    static ScriptBreak(pwcChars, cChars, psa, psla) {
        pwcChars := pwcChars is String ? StrPtr(pwcChars) : pwcChars

        result := DllCall("USP10.dll\ScriptBreak", "ptr", pwcChars, "int", cChars, "ptr", psa, "ptr", psla, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Generates the x offset from the left end or leading edge of a run to either the leading or trailing edge of a logical character cluster.
     * @remarks
     * The leading or trailing edge of the character and the leading edge of a run depend on the direction of text in the run.
     * 
     * For scripts in which the caret is conventionally placed in the middle of clusters (for example, Arabic and Hebrew), the retrieved x position of the carat can be an interpolated position for any code point in the line.
     * 
     * For scripts in which the caret is conventionally snapped to the boundaries of clusters (for example, Thai and Indian), the x position is snapped to the requested edge of the cluster containing the logical character position indicated by <i>iCP</i>.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Integer} iCP Logical character position in the run. This parameter corresponds to the offset of any logical character in the cluster.
     * @param {BOOL} fTrailing <b>TRUE</b> to use the trailing edge of the logical character cluster to compute the offset. This parameter is set to <b>FALSE</b> to use the leading edge of the logical character cluster.
     * @param {Integer} cChars Number of characters in the run.
     * @param {Integer} cGlyphs Number of glyphs in the run.
     * @param {Pointer<Integer>} pwLogClust Pointer to the logical clusters.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> array of visual attributes.
     * @param {Pointer<Integer>} piAdvance Pointer to an advance widths value.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. The <b>fLogicalOrder</b> member specifies the end of the run from which to measure the offset. If the flag is set, the leading edge of the run is used. If the flag is not set, the left end of the run is used.
     * @param {Pointer<Integer>} piX Pointer to the buffer in which the function retrieves the x position of the caret.
     * @returns {HRESULT} Returns 0 if successful. This function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptcptox
     * @since windows5.0
     */
    static ScriptCPtoX(iCP, fTrailing, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, piX) {
        pwLogClustMarshal := pwLogClust is VarRef ? "ushort*" : "ptr"
        piAdvanceMarshal := piAdvance is VarRef ? "int*" : "ptr"
        piXMarshal := piX is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptCPtoX", "int", iCP, "int", fTrailing, "int", cChars, "int", cGlyphs, pwLogClustMarshal, pwLogClust, "ptr", psva, piAdvanceMarshal, piAdvance, "ptr", psa, piXMarshal, piX, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Generates the leading or trailing edge of a logical character cluster from the x offset of a run.
     * @remarks
     * The values passed to this function normally are the results of earlier calls to other Uniscribe functions. See <a href="https://docs.microsoft.com/windows/desktop/Intl/managing-caret-placement-and-hit-testing">Managing Caret Placement and Hit Testing</a> for details.
     * 
     * The leading and trailing edges of the logical character are determined by the direction of text in the run (left-to-right or right-to-left). For the left-to-right direction, the leading edge is the same as the left edge. For the right-to-left direction, the leading edge is the right edge.
     * 
     * For scripts in which the caret is conventionally placed in the middle of a cluster, for example, Arabic and Hebrew, the retrieved character position can be for any code point in the line. In this case, the <i>piTrailing</i> parameter is set to either 0 or 1.
     * 
     * For scripts in which the caret is conventionally snapped to the boundaries of a cluster, the retrieved character position is always the position of the first code point in a cluster (considered logically). The <i>piTrailing</i> parameter is set to 0 or to the number of code points in the cluster.
     * 
     * The appropriate caret position for a mouse hit is always the retrieved character position plus the distance indicated by <i>piTrailing</i>.
     * 
     * When <i>iX</i> indicates a position outside the run, <b>ScriptXtoCP</b> acts as if there is an extra infinitely large character beyond each end of the run. This results in the behavior shown in the following table.
     * 
     * <table>
     * <tr>
     * <th><i>iX</i> position (outside the run)</th>
     * <th>Result</th>
     * </tr>
     * <tr>
     * <td>Before the run, that is: <i>iX</i> &lt; 0 if run is left-to-right, or <i>iX</i> &gt;= sum of advances if run is right-to-left</td>
     * <td>Value of <i>piCP</i> is -1 and value of <i>piTrailing</i> is 0</td>
     * </tr>
     * <tr>
     * <td>After the run, that is: <i>iX</i> &gt;= sum of advances if run is left-to-right, or <i>iX</i> &lt; 0 if run is right-to-left</td>
     * <td>Value of <i>piCP</i> is value of <i>cChars</i> and value of <i>piTrailing</i> is 1</td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Integer} iX Offset, in logical units, from the end of the run specified by the <b>fLogicalOrder</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by the <i>psa</i> parameter.
     * @param {Integer} cChars Count of logical code points in the run.
     * @param {Integer} cGlyphs Count of glyphs in the run.
     * @param {Pointer<Integer>} pwLogClust Pointer to an array of logical clusters.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures containing the visual attributes for the glyph.
     * @param {Pointer<Integer>} piAdvance Pointer to an array of advance widths.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. The <b>fLogicalOrder</b> member indicates <b>TRUE</b> to use the leading edge of the run, or <b>FALSE</b> to use the trailing edge.
     * @param {Pointer<Integer>} piCP Pointer to a buffer in which this function retrieves the character position corresponding to the x coordinate.
     * @param {Pointer<Integer>} piTrailing Pointer to a buffer in which this function retrieves the distance, in code points, from the leading edge of the logical character to the <i>iX</i> position. If this value is 0, the <i>iX</i> position is at the leading edge of the logical character. For more information, see the Remarks section.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptxtocp
     * @since windows5.0
     */
    static ScriptXtoCP(iX, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, piCP, piTrailing) {
        pwLogClustMarshal := pwLogClust is VarRef ? "ushort*" : "ptr"
        piAdvanceMarshal := piAdvance is VarRef ? "int*" : "ptr"
        piCPMarshal := piCP is VarRef ? "int*" : "ptr"
        piTrailingMarshal := piTrailing is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptXtoCP", "int", iX, "int", cChars, "int", cGlyphs, pwLogClustMarshal, pwLogClust, "ptr", psva, piAdvanceMarshal, piAdvance, "ptr", psa, piCPMarshal, piCP, piTrailingMarshal, piTrailing, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts the glyph advance widths for a specific font into logical widths.
     * @remarks
     * This function is useful for recording widths in a font-independent manner. It converts the glyph advance widths calculated for a specific font into logical widths, one per code point, in the same order as the code points. If the same string is then displayed on a different device using a different font, the logical widths can be applied by using <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptapplylogicalwidth">ScriptApplyLogicalWidth</a> to approximate the original placement. This mechanism is useful when implementing print preview. On the preview screen, it is important to match the layout and placement of the final printed result.
     * 
     * <div class="alert"><b>Note</b>Ligature glyph widths are divided evenly among the characters they represent.</div>
     * <div></div>
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure.
     * @param {Integer} cChars Count of the logical code points in the run.
     * @param {Integer} cGlyphs Count of the glyphs in the run.
     * @param {Pointer<Integer>} piGlyphWidth Pointer to an array of glyph advance widths.
     * @param {Pointer<Integer>} pwLogClust Pointer to an array of logical clusters.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structure defining visual attributes.
     * @param {Pointer<Integer>} piDx Pointer to an array of logical widths.
     * @returns {HRESULT} Currently returns S_OK in all cases.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetlogicalwidths
     * @since windows5.0
     */
    static ScriptGetLogicalWidths(psa, cChars, cGlyphs, piGlyphWidth, pwLogClust, psva, piDx) {
        piGlyphWidthMarshal := piGlyphWidth is VarRef ? "int*" : "ptr"
        pwLogClustMarshal := pwLogClust is VarRef ? "ushort*" : "ptr"
        piDxMarshal := piDx is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetLogicalWidths", "ptr", psa, "int", cChars, "int", cGlyphs, piGlyphWidthMarshal, piGlyphWidth, pwLogClustMarshal, pwLogClust, "ptr", psva, piDxMarshal, piDx, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Takes an array of advance widths for a run and generates an array of adjusted advance glyph widths.
     * @remarks
     * This function can be used to reapply logical widths obtained with <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetlogicalwidths">ScriptGetLogicalWidths</a>. It can be useful in situations such as metafiling, for which advance width information must be recorded and reapplied in a font-independent manner, independent of glyph substitutions, such as ligaturization.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Integer>} piDx Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">advance widths</a> in logical order, one per code point.
     * @param {Integer} cChars Count of the logical code points in the run.
     * @param {Integer} cGlyphs Glyph count.
     * @param {Pointer<Integer>} pwLogClust Pointer to an array of logical clusters from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structure from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> and updated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<Integer>} piAdvance Pointer to an array of glyph advance widths from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a> and updated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> and <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<ABC>} pABC Pointer to the overall <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> of a run. On input, the parameter should contain the run ABC widths retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>. On output, the parameter indicates the ABC width updated to match the new widths.
     * @returns {Integer} Pointer to an array in which the function retrieves the glyph advance widths. This array is suitable for passing to the <i>piJustify</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a>.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptapplylogicalwidth
     * @since windows5.0
     */
    static ScriptApplyLogicalWidth(piDx, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, pABC) {
        piDxMarshal := piDx is VarRef ? "int*" : "ptr"
        pwLogClustMarshal := pwLogClust is VarRef ? "ushort*" : "ptr"
        piAdvanceMarshal := piAdvance is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptApplyLogicalWidth", piDxMarshal, piDx, "int", cChars, "int", cGlyphs, pwLogClustMarshal, pwLogClust, "ptr", psva, piAdvanceMarshal, piAdvance, "ptr", psa, "ptr", pABC, "int*", &piJustify := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return piJustify
    }

    /**
     * Retrieves the glyph indexes of the Unicode characters in a string according to either the TrueType cmap table or the standard cmap table implemented for old-style fonts.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function can be used to determine the characters in a run that are supported by the selected font. The application can scan the retrieved glyph buffer, looking for the default glyph to determine characters that are not available. The application should determine the default glyph index for the selected font by calling <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetfontproperties">ScriptGetFontProperties</a>.
     * 
     * The return value for this function indicates the presence of any missing glyphs.
     * 
     * <div class="alert"><b>Note</b>The function assumes a 1:1 relationship between the elements in the input and output arrays. However, the function does not support this relationship for UTF-16 surrogate pairs. For a surrogate pair, the function does not retrieve the glyph index for the supplementary-plane character. Similarly, the function does not support Unicode Variation-Selector (VS) sequences, each of which consists of a Unicode graphic character followed by one of a set of VARIATION SELECTOR characters to select a particular glyph representation for that graphic character. For a VS sequence, the function retrieves the glyph index for the default glyph mapped by the cmap for the two characters, instead of the glyph index for the particular glyph for the VS sequence.</div>
     * <div></div>
     * Some code points can be rendered by a combination of glyphs, as well as by a single glyph, for example, 00C9; LATIN CAPITAL LETTER E WITH ACUTE. In this case, if the font supports the capital E glyph and the acute glyph, but not a single glyph for 00C9, <b>ScriptGetCMap</b> shows that 00C9 is unsupported. To determine the font support for a string that contains these kinds of code points, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>. If the function returns S_OK, the application should check the output for missing glyphs.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {PWSTR} pwcInChars Pointer to a string of Unicode characters.
     * @param {Integer} cChars Number of Unicode characters in the string indicated by <i>pwcInChars</i>.
     * @param {Integer} dwFlags Flags specifying any special handling of the glyphs. By default, the glyphs are provided in logical order with no special handling. This parameter can have the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SGCM_RTL"></a><a id="sgcm_rtl"></a><dl>
     * <dt><b>SGCM_RTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The glyph array indicated by <i>pwOutGlyphs</i> should contain mirrored glyphs for those glyphs that have a mirrored equivalent.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Pointer to a buffer in which the function retrieves an array of glyph indexes. This buffer should be of the same length as the input buffer indicated by <i>pwcInChars</i>. Each code point maps to a single glyph.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetcmap
     * @since windows5.0
     */
    static ScriptGetCMap(hdc, psc, pwcInChars, cChars, dwFlags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc
        pwcInChars := pwcInChars is String ? StrPtr(pwcInChars) : pwcInChars

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetCMap", "ptr", hdc, pscMarshal, psc, "ptr", pwcInChars, "int", cChars, "uint", dwFlags, "ushort*", &pwOutGlyphs := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pwOutGlyphs
    }

    /**
     * Retrieves the ABC width of a given glyph.
     * @remarks
     * This function is limited in its usefulness. For example, it is useful for drawing glyph charts. It should not be used for ordinary complex script text formatting.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Integer} wGlyph Glyph to analyze.
     * @param {Pointer<ABC>} pABC Pointer to the ABC width of the specified glyph.
     * @returns {HRESULT} Returns S_OK if the ABC width of the glyph is retrieved. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * The function returns E_HANDLE if the font or operating system does not support glyph indexes.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetglyphabcwidth
     * @since windows5.0
     */
    static ScriptGetGlyphABCWidth(hdc, psc, wGlyph, pABC) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetGlyphABCWidth", "ptr", hdc, pscMarshal, psc, "ushort", wGlyph, "ptr", pABC, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about the current scripts.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/determining-if-a-script-requires-glyph-shaping">Determining If a Script Requires Glyph Shaping</a> for an example of the use of this function.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Pointer<Pointer<SCRIPT_PROPERTIES>>>} ppSp Pointer to an array of pointers to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> structures indexed by script.
     * @param {Pointer<Integer>} piNumScripts Pointer to the number of scripts. The valid range for this value is 0 through <i>piNumScripts</i>-1.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetproperties
     * @since windows5.0
     */
    static ScriptGetProperties(ppSp, piNumScripts) {
        ppSpMarshal := ppSp is VarRef ? "ptr*" : "ptr"
        piNumScriptsMarshal := piNumScripts is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetProperties", ppSpMarshal, ppSp, piNumScriptsMarshal, piNumScripts, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information from the font cache on the special glyphs used by a font.
     * @remarks
     * The structure retrieved by this function identifies the glyphs that are used for blanks, missing glyphs, invalid combinations, and the smallest kashida.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_FONTPROPERTIES>} sfp Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_fontproperties">SCRIPT_FONTPROPERTIES</a> structure in which this function retrieves the information from the font cache.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontproperties
     * @since windows5.0
     */
    static ScriptGetFontProperties(hdc, psc, sfp) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetFontProperties", "ptr", hdc, pscMarshal, psc, "ptr", sfp, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the height of the currently cached font.
     * @remarks
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @returns {Integer} Pointer to a buffer in which the function retrieves the font height.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptcachegetheight
     * @since windows5.0
     */
    static ScriptCacheGetHeight(hdc, psc) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"

        result := DllCall("USP10.dll\ScriptCacheGetHeight", "ptr", hdc, pscMarshal, psc, "int*", &tmHeight := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return tmHeight
    }

    /**
     * Analyzes a plain text string.
     * @remarks
     * Use of this function is the first step in handling plain text strings. Such a string has only one font, one style, one size, one color, and so forth. <b>ScriptStringAnalyse</b> allocates temporary buffers for item analyses, glyphs, advance widths, and the like. Then it automatically runs <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>, <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>, <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptbreak">ScriptBreak</a>. The results are available through all the other <b>ScriptString*</b> functions.
     * 
     * On successful return from this function, <i>pssa</i> indicates a dynamically allocated structure that the application can pass successively to the other <b>ScriptString*</b> functions. The application must ultimately free the structure by calling <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringfree">ScriptStringFree</a>.
     * 
     * Although the functionality of <b>ScriptStringAnalyse</b> can be implemented by direct calls to other functions, use of the function itself drastically reduces the amount of code required in the application for plain text handling.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. If <i>dwFlags</i> is set to SSA_GLYPHS, the device context handle is required. If <i>dwFlags</i> is set to SSA_BREAK, the device context handle is optional. If the device context handle is provided, the function inspects the current font in the device context. If the current font is a symbolic font, the function treats the character string as a single neutral SCRIPT_UNDEFINED item.
     * @param {Pointer<Void>} pString Pointer to the string to analyze. The string must have at least one character. It can be a Unicode string or use the character set from a Windows ANSI <a href="https://docs.microsoft.com/windows/desktop/Intl/code-pages">code page</a>, as specified by the <i>iCharset</i> parameter.
     * @param {Integer} cString Length of the string to analyze. The length is measured in characters for an ANSI string or in wide characters for a Unicode string. The length must be at least 1.
     * @param {Integer} cGlyphs Size of the glyph buffer, in WORD values. This size is required. The recommended size is <c>(1.5 * cString + 16)</c>.
     * @param {Integer} iCharset Character set descriptor. If the input string is an ANSI string, this descriptor is set to the character set identifier. If the string is a Unicode string, this descriptor is set to -1.
     * 
     * The following character set identifiers are defined:
     * @param {Integer} dwFlags Flags indicating the analysis that is required. This parameter can have one of the values listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_BREAK"></a><a id="ssa_break"></a><dl>
     * <dt><b>SSA_BREAK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve break flags, that is, character and word stops.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_CLIP"></a><a id="ssa_clip"></a><dl>
     * <dt><b>SSA_CLIP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Clip the string at <i>iReqWidth.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_DZWG"></a><a id="ssa_dzwg"></a><dl>
     * <dt><b>SSA_DZWG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Provide representation glyphs for control characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_FALLBACK"></a><a id="ssa_fallback"></a><dl>
     * <dt><b>SSA_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use fallback fonts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_FIT"></a><a id="ssa_fit"></a><dl>
     * <dt><b>SSA_FIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Justify the string to <i>iReqWidth</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_GCP"></a><a id="ssa_gcp"></a><dl>
     * <dt><b>SSA_GCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve missing glyphs and <i>pwLogClust</i> with <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a> conventions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_GLYPHS"></a><a id="ssa_glyphs"></a><dl>
     * <dt><b>SSA_GLYPHS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Generate glyphs, positions, and attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HIDEHOTKEY"></a><a id="ssa_hidehotkey"></a><dl>
     * <dt><b>SSA_HIDEHOTKEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Remove the first "&amp;" from displayed string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HOTKEY"></a><a id="ssa_hotkey"></a><dl>
     * <dt><b>SSA_HOTKEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Replace "&amp;" with underline on subsequent code point.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HOTKEYONLY"></a><a id="ssa_hotkeyonly"></a><dl>
     * <dt><b>SSA_HOTKEYONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Display underline only. The resulting bit pattern might be displayed, using an XOR mask, to toggle the visibility of the hotkey underline without disturbing the text.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_LINK"></a><a id="ssa_link"></a><dl>
     * <dt><b>SSA_LINK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Apply East Asian font linking and association to noncomplex text.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_METAFILE"></a><a id="ssa_metafile"></a><dl>
     * <dt><b>SSA_METAFILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write items with <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOutW</a> calls, not with glyphs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_PASSWORD"></a><a id="ssa_password"></a><dl>
     * <dt><b>SSA_PASSWORD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Duplicate input string containing a single character <i>cString</i> times.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_RTL"></a><a id="ssa_rtl"></a><dl>
     * <dt><b>SSA_RTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use base embedding level 1.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_TAB"></a><a id="ssa_tab"></a><dl>
     * <dt><b>SSA_TAB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Expand tabs.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} iReqWidth Width required for fitting or clipping.
     * @param {Pointer<SCRIPT_CONTROL>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure. The application can set this parameter to <b>NULL</b> to indicate that all <b>SCRIPT_CONTROL</b> members are set to 0.
     * @param {Pointer<SCRIPT_STATE>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure. The application can set this parameter to <b>NULL</b> to indicate that all <b>SCRIPT_STATE</b> members are set to 0. The <b>uBidiLevel</b> member of <b>SCRIPT_STATE</b> is ignored. The value used is derived from the SSA_RTL flag in combination with the layout of the device context.
     * @param {Pointer<Integer>} piDx Pointer to the requested logical dx array.
     * @param {Pointer<SCRIPT_TABDEF>} pTabdef Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_tabdef">SCRIPT_TABDEF</a> structure. This value is only required if <i>dwFlags</i> is set to SSA_TAB.
     * @param {Pointer<Integer>} pbInClass Pointer to a BYTE value that indicates <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a> character classifications.
     * @returns {Pointer<Void>} Pointer to a buffer in which this function retrieves a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure. This structure is dynamically allocated on successful return from the function.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringanalyse
     * @since windows5.0
     */
    static ScriptStringAnalyse(hdc, pString, cString, cGlyphs, iCharset, dwFlags, iReqWidth, psControl, psState, piDx, pTabdef, pbInClass) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pStringMarshal := pString is VarRef ? "ptr" : "ptr"
        piDxMarshal := piDx is VarRef ? "int*" : "ptr"
        pbInClassMarshal := pbInClass is VarRef ? "char*" : "ptr"

        result := DllCall("USP10.dll\ScriptStringAnalyse", "ptr", hdc, pStringMarshal, pString, "int", cString, "int", cGlyphs, "int", iCharset, "uint", dwFlags, "int", iReqWidth, "ptr", psControl, "ptr", psState, piDxMarshal, piDx, "ptr", pTabdef, pbInClassMarshal, pbInClass, "ptr*", &pssa := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pssa
    }

    /**
     * Frees a SCRIPT_STRING_ANALYSIS structure.
     * @remarks
     * When your application is finished with a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure, it should free the associated memory by calling this function. After this function is called, the pointers retrieved from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>, <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_plogattr">ScriptString_pLogAttr</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_psize">ScriptString_pSize</a> that are associated with the <i>pssa</i> parameter are invalid.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Pointer<Void>>} pssa Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringfree
     * @since windows5.0
     */
    static ScriptStringFree(pssa) {
        pssaMarshal := pssa is VarRef ? "ptr*" : "ptr"

        result := DllCall("USP10.dll\ScriptStringFree", pssaMarshal, pssa, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns a pointer to a SIZE structure for an analyzed string.
     * @remarks
     * The size returned by this function is the size before the effect of the justification requested by setting the SSA_FIT flag in <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>. The difference between the value of <i>iReqWidth</i> in <b>ScriptStringAnalyse</b> and the size returned by <b>ScriptString_pSize</b> is the effect of justification.
     * 
     * The pointer returned by this function is valid only until the application passes the associated <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringfree">ScriptStringFree</a>.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for a string.
     * @returns {Pointer<SIZE>} Returns a pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-size">SIZE</a> structure containing the size (width and height) of the analyzed string if successful. The function returns <b>NULL</b> if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstring_psize
     * @since windows5.0
     */
    static ScriptString_pSize(ssa) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"

        result := DllCall("USP10.dll\ScriptString_pSize", ssaMarshal, ssa, "ptr")
        return result
    }

    /**
     * Returns a pointer to the length of a string after clipping.
     * @remarks
     * To use this function, the application needs to specify SSA_CLIP in its original call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>.
     * 
     * The pointer returned by this function is valid only until the application passes the associated <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringfree">ScriptStringFree</a>.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @returns {Pointer<Integer>} Returns a pointer to the length of the string after clipping if successful. The length is the number of Unicode code points. The function returns <b>NULL</b> if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstring_pcoutchars
     * @since windows5.0
     */
    static ScriptString_pcOutChars(ssa) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"

        result := DllCall("USP10.dll\ScriptString_pcOutChars", ssaMarshal, ssa, "ptr")
        return result
    }

    /**
     * Returns a pointer to a logical attributes buffer for an analyzed string.
     * @remarks
     * The pointer returned by this function is valid only until the application passes the associated <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringfree">ScriptStringFree</a>.
     * 
     * The logical attribute buffer contains at least the number of integers indicated by the <i>ssa</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>.
     * 
     * When scanning the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> array for a word break point, the application should look backward for the values of the <b>fWordStop</b> and <b>fWhiteSpace</b> members. <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a> just calls <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptbreak">ScriptBreak</a> on each run, and <b>ScriptBreak</b> never sets <b>fWordBreak</b> on the first character of a run, because it has no information that the previous run ended in white space.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @returns {Pointer<SCRIPT_LOGATTR>} Returns a pointer to a buffer containing <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structures defining logical attributes if successful. The function returns <b>NULL</b> if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstring_plogattr
     * @since windows5.0
     */
    static ScriptString_pLogAttr(ssa) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"

        result := DllCall("USP10.dll\ScriptString_pLogAttr", ssaMarshal, ssa, "ptr")
        return result
    }

    /**
     * Creates an array that maps an original character position to a glyph position.
     * @remarks
     * When the number of glyphs and the number of characters are equal, the function retrieves an array that references every glyph. This is the same treatment that occurs in <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a>.
     * 
     * To use this function, the application needs to specify SSA_GLYPHS in its original call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Pointer<Integer>} puOrder Pointer to a buffer in which this function retrieves an array of glyph positions, indexed by the original character position. The array should have room for at least the number of integers indicated by the <i>ssa</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringgetorder
     * @since windows5.0
     */
    static ScriptStringGetOrder(ssa, puOrder) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"
        puOrderMarshal := puOrder is VarRef ? "uint*" : "ptr"

        result := DllCall("USP10.dll\ScriptStringGetOrder", ssaMarshal, ssa, puOrderMarshal, puOrder, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the x coordinate for the leading or trailing edge of a character position.
     * @remarks
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} icp Character position in the string.
     * @param {BOOL} fTrailing <b>TRUE</b> to indicate the trailing edge of the character position (<i>icp</i>) that corresponds to the x coordinate. This parameter is set to <b>FALSE</b> to indicate the leading edge of the character position.
     * @returns {Integer} Pointer to a buffer in which this function retrieves the x coordinate corresponding to the character position.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringcptox
     * @since windows5.0
     */
    static ScriptStringCPtoX(ssa, icp, fTrailing) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"

        result := DllCall("USP10.dll\ScriptStringCPtoX", ssaMarshal, ssa, "int", icp, "int", fTrailing, "int*", &pX := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pX
    }

    /**
     * Converts an x coordinate to a character position.
     * @remarks
     * If the x coordinate corresponds to the leading edge of the character, the value of <i>piTrailing</i> is 0. If the x coordinate corresponds to the trailing edge of the character, the value of <i>piTrailing</i> is a positive integer. As for <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptxtocp">ScriptXtoCP</a>, the value is 1 for a character that can be rendered on its own. The value is greater than 1 if the character is part of a cluster in a script for which cursors are not placed within a cluster, to indicate the offset to the next legitimate logical cursor position.
     * 
     * If the x coordinate is before the beginning of the line, the function retrieves -1 for <i>piCh</i> and 1 for <i>piTrailing</i>, indicating the trailing edge of the nonexistent character before the line. If the x coordinate is after the end of the line, the function retrieves for <i>piCh</i> the first index beyond the length of the line and 0 for <i>piTrailing</i>. The 0 value indicates the leading edge of the nonexistent character after the line.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} iX The x coordinate.
     * @param {Pointer<Integer>} piCh Pointer to a variable in which this function retrieves the character position corresponding to the x coordinate.
     * @param {Pointer<Integer>} piTrailing Pointer to a variable in which this function retrieves a value indicating if the x coordinate is for the leading edge or the trailing edge of the character position. For more information, see the Remarks section.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringxtocp
     * @since windows5.0
     */
    static ScriptStringXtoCP(ssa, iX, piCh, piTrailing) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"
        piChMarshal := piCh is VarRef ? "int*" : "ptr"
        piTrailingMarshal := piTrailing is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptStringXtoCP", ssaMarshal, ssa, "int", iX, piChMarshal, piCh, piTrailingMarshal, piTrailing, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts visual widths into logical widths.
     * @remarks
     * This function converts the visual widths generated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a> into logical widths, one per original character, in logical order.
     * 
     * To use this function, the application needs to specify SSA_GLYPHS in its original call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Pointer<Integer>} piDx Pointer to a buffer in which this function retrieves logical widths. The buffer should have room for at least the number of integers indicated by the <i>ssa</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringgetlogicalwidths
     * @since windows5.0
     */
    static ScriptStringGetLogicalWidths(ssa, piDx) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"
        piDxMarshal := piDx is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptStringGetLogicalWidths", ssaMarshal, ssa, piDxMarshal, piDx, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Checks a SCRIPT_STRING_ANALYSIS structure for invalid sequences.
     * @remarks
     * This function is intended for use in editors that reject the input of invalid sequences.
     * 
     * Invalid sequences are only checked for scripts with the <b>fRejectInvalid</b> member set in the associated <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> structure. For example, it is conventional for Notepad to reject invalid Thai character sequences. However, invalid Indian sequences are not conventionally rejected, but instead are displayed in composition with a missing base character symbol.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for a string.
     * @returns {HRESULT} Returns S_OK if no invalid sequences are found. The function returns S_FALSE if one or more invalid sequences are found. The function returns a nonzero HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringvalidate
     * @since windows5.0
     */
    static ScriptStringValidate(ssa) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"

        result := DllCall("USP10.dll\ScriptStringValidate", ssaMarshal, ssa, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Displays a string generated by a prior call to ScriptStringAnalyse and optionally adds highlighting.
     * @remarks
     * To use this function, the application needs to specify SSA_GLYPHS in its original call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a>.
     * 
     * The application should not use <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-settextalign">SetTextAlign</a> with TA_UPDATECP when using <b>ScriptStringOut</b> because selected text cannot be rendered correctly. If the application must use this flag, it can unset and reset the flag as necessary to avoid the problem.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} iX The x-coordinate of the reference point used to position the string.
     * @param {Integer} iY The y-coordinate of the reference point used to position the string.
     * @param {Integer} uOptions 
     * @param {Pointer<RECT>} prc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that defines the rectangle to use. If <i>uOptions</i> is set to ETO_OPAQUE and <b>NULL</b> is provided for <i>prc</i>, the function succeeds and returns S_OK. However, if the application sets <i>uOptions</i> to ETO_CLIPPING and provides <b>NULL</b> for <i>prc</i>, the function returns E_INVALIDARG. The application can set this parameter to <b>NULL</b> to indicate that no option is needed.
     * @param {Integer} iMinSel Zero-based index specifying the starting position in the string. For no selection, the application should set <i>iMinSel</i> &gt;= <i>iMaxSel</i>.
     * @param {Integer} iMaxSel Zero-based index specifying the ending position in the string.
     * @param {BOOL} fDisabled <b>TRUE</b> if the operating system applies disabled-text highlighting by setting the background color to COLOR_HIGHLIGHT behind all selected characters. The application can set this parameter to <b>FALSE</b> if the operating system applies enabled-text highlighting by setting the background color to COLOR_HIGHLIGHT and the text color to COLOR_HIGHLIGHTTEXT for each selected character.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero <b>HRESULT</b> value if it does not succeed. The application can't test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptstringout
     * @since windows5.0
     */
    static ScriptStringOut(ssa, iX, iY, uOptions, prc, iMinSel, iMaxSel, fDisabled) {
        ssaMarshal := ssa is VarRef ? "ptr" : "ptr"

        result := DllCall("USP10.dll\ScriptStringOut", ssaMarshal, ssa, "int", iX, "int", iY, "uint", uOptions, "ptr", prc, "int", iMinSel, "int", iMaxSel, "int", fDisabled, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines whether a Unicode string requires complex script processing.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {PWSTR} pwcInChars Pointer to the string to test.
     * @param {Integer} cInChars Length of the input string, in characters.
     * @param {Integer} dwFlags 
     * @returns {HRESULT} Returns S_OK if the string requires complex script processing. The function returns S_FALSE if the string can be handled by standard API function calls, that is, it contains only characters laid out side-by-side and left-to-right. The function returns a nonzero HRESULT value if it does not succeed.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptiscomplex
     * @since windows5.0
     */
    static ScriptIsComplex(pwcInChars, cInChars, dwFlags) {
        pwcInChars := pwcInChars is String ? StrPtr(pwcInChars) : pwcInChars

        result := DllCall("USP10.dll\ScriptIsComplex", "ptr", pwcInChars, "int", cInChars, "uint", dwFlags, "int")
        return result
    }

    /**
     * Reads the National Language Support (NLS) native digit and digit substitution settings and records them in a SCRIPT_DIGITSUBSTITUTE structure. For more information, see Digit Shapes.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * This function supports context digit substitution only for Arabic and Persian locales. For other locales, context digit substitution is mapped to no substitution.
     * 
     * The following example shows the typical way to call this function.
     * 
     * 
     * ```cpp
     * SCRIPT_DIGITSUBSTITUTE sds;
     * ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
     * 
     * ```
     * 
     * 
     * At every itemization, the application can use the results as shown in the next example.
     * 
     * 
     * ```cpp
     * SCRIPT_CONTROL sc = {0};
     * SCRIPT_STATE   ss = {0};
     * ScriptApplyDigitSubstitution(&sds, &sc, &ss);
     * 
     * ```
     * 
     * 
     * For performance reasons, your application should not call <b>ScriptRecordDigitSubstitution</b> frequently. The function requires considerable overhead to call it every time <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstringanalyse">ScriptStringAnalyse</a> is called. Instead, the application can save the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a> structure and update it only when a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message is received. Alternatively, the application can update the structure when a <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regnotifychangekeyvalue">RegNotifyChangeKeyValue</a> call in a dedicated thread indicates a change in the registry under HKCU\Control Panel\International.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale to query. Typically, the application should set this parameter to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>. Alternatively, the setting can indicate a specific locale combined with <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to obtain the default settings.
     * @param {Pointer<SCRIPT_DIGITSUBSTITUTE>} psds Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a> structure. This structure can be passed later to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptapplydigitsubstitution">ScriptApplyDigitSubstitution</a>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * Error returns include:    
     * <ul>
     * <li>E_INVALIDARG. The <i>Locale</i> parameter indicates a locale that is invalid or not installed.</li>
     * <li>E_POINTER. The <i>psds</i> parameter is set to <b>NULL</b>.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptrecorddigitsubstitution
     * @since windows5.0
     */
    static ScriptRecordDigitSubstitution(Locale, psds) {
        result := DllCall("USP10.dll\ScriptRecordDigitSubstitution", "uint", Locale, "ptr", psds, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Applies the specified digit substitution settings to the specified script control and script state structures.
     * @remarks
     * This function does not actually substitute digits. It just fills in the structures that describe the digit substitution policy. See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {Pointer<SCRIPT_DIGITSUBSTITUTE>} psds Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a> structure. The application sets this parameter to <b>NULL</b> if the function is to call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptrecorddigitsubstitution">ScriptRecordDigitSubstitution</a> with LOCALE_USER_DEFAULT.
     * @param {Pointer<SCRIPT_CONTROL>} psc Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure with the <b>fContextDigits</b> and <b>uDefaultLanguage</b> members updated.
     * @param {Pointer<SCRIPT_STATE>} pss Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure with the <b>fDigitSubstitute</b> member updated.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * The function returns E_INVALIDARG if it does not recognize the <b>DigitSubstitute</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a>.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptapplydigitsubstitution
     * @since windows5.0
     */
    static ScriptApplyDigitSubstitution(psds, psc, pss) {
        result := DllCall("USP10.dll\ScriptApplyDigitSubstitution", "ptr", psds, "ptr", psc, "ptr", pss, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run with OpenType information. Each run consists of one call to this function.
     * @remarks
     * <b>ScriptShapeOpenType</b> is preferred over the older <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> function. Some advantages of the <b>ScriptShapeOpenType</b> include the following:
     * 
     * <ul>
     * <li>Parameters directly correspond to OpenType tags in font layout tables.</li>
     * <li>Parameters define features applied to each character.</li>
     * <li>Input is divided into runs. Each run has OpenType properties and consists of a single call to <b>ScriptShapeOpenType</b>.</li>
     * </ul>
     * If this function returns E_OUTOFMEMORY, the application might call <b>ScriptShapeOpenType</b> repeatedly, with successively larger output buffers, until a large enough buffer is provided. The number of glyphs generated by a code point varies according to the script and the font. For a simple script, a Unicode code point might generate a single glyph. However, a complex script font might construct characters from components, and thus generate several times as many glyphs as characters. Also, there are special cases, such as invalid character representations, in which extra glyphs are added to represent the invalid sequence. Therefore, a reasonable guess for the size of the buffer indicated by <i>pwOutGlyphs</i> is 1.5 times the length of the character buffer, plus an additional 16 glyphs for rare cases, for example, invalid sequence representation.
     * 
     * This function can set the <b>fNoGlyphIndex</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure if the font or operating system cannot support glyph indexes.
     * 
     * The application can call <b>ScriptShapeOpenType</b> to determine if a font supports the characters in a given string. If the function returns S_OK, the application should check the output for missing glyphs. If <b>fLogicalOrder</b> is set to <b>TRUE</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure, the function always generates glyphs in the same order as the original Unicode characters. If <b>fLogicalOrder</b> is set to <b>FALSE</b>, the function generates right-to-left items in reverse order so that <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a> does not have to reverse them before calling <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a>.
     * 
     * If the <b>eScript</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> is set to SCRIPT_UNDEFINED, shaping is disabled. In this case, <b>ScriptShapeOpenType</b> displays the glyph that is in the font cmap table. If no glyph is in the table, the function indicates that glyphs are missing.
     * 
     * <b>ScriptShapeOpenType</b> sequences clusters uniformly within the run, and sequences glyphs uniformly within a cluster. It uses the value of the <b>fRTL</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a>, from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>, to identify if sequencing is left-to-right or right-to-left.
     * 
     * For the <i>rpRangeProperties</i> parameter, the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-textrange_properties">TEXTRANGE_PROPERTIES</a> structure points to an array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> structures. This array is used as follows:
     * 
     * <ul>
     * <li>Each element of the array indicated for <i>rpRangeProperties</i> describes a range.</li>
     * <li>Spans of text sharing particular properties tend to "nest," and nested spans can share <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> information. For example, in the illustration below:<ul>
     * <li>The rows of numbers at the top represent ranges, items, and runs, respectively.</li>
     * <li>Each span labeled here with a letter represents a single OpenType feature. The features that fall into each range are stored in the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> array of that range.</li>
     * <li>For each range, the array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> structures corresponds to the letters for the spans that contain that range.</li>
     * <li>In this illustration, range 2 is indirectly associated with the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a> structures for spans A, B, and C. Range 4 is associated only with the structures for spans A and D.</li>
     * </ul>
     * </li>
     * </ul>
     * <img alt="Illustration showing the range, item, run, and feature of each word in a line of text that uses six properties to present eight words" border="" src="./images/Nested_Properties.GIF"/>
     * <div class="alert"><b>Note</b>The illustration makes use of many calls to <b>ScriptShapeOpenType</b>, each representing one run.</div>
     * <div></div>
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. The structure identifies the shaping engine, so that glyphs can be formed correctly.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the OpenType script tag for the writing system.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType language tag for the writing system.
     * @param {Pointer<Integer>} rcRangeChars Array of characters in each <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">range</a>. The number of array elements is indicated by <i>cRanges</i>. The values of the elements of this array add up to the value of <i>cChars</i>.
     * @param {Pointer<Pointer<TEXTRANGE_PROPERTIES>>} rpRangeProperties Array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-textrange_properties">TEXTRANGE_PROPERTIES</a> structures, each representing one OpenType feature range. The number of structures is indicated by the <i>cRanges</i> parameter. For more information on <i>rpRangeProperties</i>, see the Remarks section.
     * @param {Integer} cRanges The number of OpenType feature ranges.
     * @param {PWSTR} pwcChars Pointer to an array of Unicode characters containing the run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Integer} cMaxGlyphs Maximum number of glyphs to generate.
     * @param {Pointer<Integer>} pwLogClust Pointer to a buffer in which this function retrieves an array of logical <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">cluster</a> information. Each array element corresponds to a character in the array of Unicode characters. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure is <b>TRUE</b>, the elements decrease as the array is read.
     * @param {Pointer<SCRIPT_CHARPROP>} pCharProps Pointer to a buffer in which this function retrieves an array of character property values, of length indicated by <i>cChars</i>.
     * @param {Pointer<Integer>} pwOutGlyphs Pointer to a buffer in which this function retrieves an array of glyphs.
     * @param {Pointer<SCRIPT_GLYPHPROP>} pOutGlyphProps Pointer to a buffer in which this function retrieves an array of attributes for each of the retrieved glyphs. The length of the values equals the value of <i>pcGlyphs</i>. Since one glyph property is indicated per glyph, the value of this parameter indicates the number of elements specified by <i>cMaxGlyphs</i>.
     * @param {Pointer<Integer>} pcGlyphs Pointer to the location in which this function retrieves the number of glyphs indicated in <i>pwOutGlyphs</i>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, the content of all output array values is undefined.
     * 
     * Error returns include:
     * 
     * <ul>
     * <li>E_OUTOFMEMORY. The output buffer length indicated by <i>cMaxGlyphs</i> is insufficient.</li>
     * <li>E_PENDING. The script cache specified by the <i>psc</i> parameter does not contain enough information to shape the string, and the device context has been passed as <b>NULL</b> so that the function is unable to complete the shaping process. The application should set up a correct device context for the run and call this function again with the appropriate context value in <i>hdc</i> and with all other parameters the same.</li>
     * <li>USP_E_SCRIPT_NOT_IN_FONT. The font corresponding to the device context does not support the required script. The application should choose another font, using either <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetcmap">ScriptGetCMap</a> or another method to select the font.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptshapeopentype
     * @since windows6.0.6000
     */
    static ScriptShapeOpenType(hdc, psc, psa, tagScript, tagLangSys, rcRangeChars, rpRangeProperties, cRanges, pwcChars, cChars, cMaxGlyphs, pwLogClust, pCharProps, pwOutGlyphs, pOutGlyphProps, pcGlyphs) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc
        pwcChars := pwcChars is String ? StrPtr(pwcChars) : pwcChars

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        rcRangeCharsMarshal := rcRangeChars is VarRef ? "int*" : "ptr"
        rpRangePropertiesMarshal := rpRangeProperties is VarRef ? "ptr*" : "ptr"
        pwLogClustMarshal := pwLogClust is VarRef ? "ushort*" : "ptr"
        pwOutGlyphsMarshal := pwOutGlyphs is VarRef ? "ushort*" : "ptr"
        pcGlyphsMarshal := pcGlyphs is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptShapeOpenType", "ptr", hdc, pscMarshal, psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, rcRangeCharsMarshal, rcRangeChars, rpRangePropertiesMarshal, rpRangeProperties, "int", cRanges, "ptr", pwcChars, "int", cChars, "int", cMaxGlyphs, pwLogClustMarshal, pwLogClust, "ptr", pCharProps, pwOutGlyphsMarshal, pwOutGlyphs, "ptr", pOutGlyphProps, pcGlyphsMarshal, pcGlyphs, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run with OpenType information from the output of ScriptShapeOpenType.
     * @remarks
     * This function is preferred over the older <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a> function. Some advantages of <b>ScriptPlaceOpenType</b> include the following:
     * 
     * <ul>
     * <li>Parameters directly correspond to OpenType tags in font layout tables.</li>
     * <li>Parameters define features applied to each character. Input is divided into ranges, and each range has OpenType properties associated with it.</li>
     * </ul>
     * The composite ABC width for the whole item identifies how much the glyphs <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">overhang</a> to the left of the start position and to the right of the length implied by the sum of the advance widths. The total advance width of the line is exactly abcA+abcB+abcC. The abcA and abcC values are maintained as proportions of the cell height represented in 8 bits and are thus roughly +/-1 percent. The total width retrieved, which is the sum of the abcA+abcB+abcC values indicated by <i>piAdvance</i>, is accurate to the resolution of the TrueType shaping engine.
     * 
     * All arrays are in visual order unless the <b>fLogicalOrder</b> member is set in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by the <i>psa</i> parameter.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This structures identifies the shaping engine that governs the generated list of glyphs and their associated widths, and x and y placement offsets.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType script tag for the writing system to use.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType language tag for the writing system.
     * @param {Pointer<Integer>} rcRangeChars Array of the number of characters in each range. The number of members is indicated in the <i>cRanges</i> parameter. The total of values should equal the value of <i>cChars</i>.
     * @param {Pointer<Pointer<TEXTRANGE_PROPERTIES>>} rpRangeProperties Array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-textrange_properties">TEXTRANGE_PROPERTIES</a> structures defining properties for each range. The number of elements is defined by the <i>cRanges</i> parameter.
     * @param {Integer} cRanges The number of OpenType feature ranges.
     * @param {PWSTR} pwcChars Pointer to an array of Unicode characters containing the run. The number of elements is defined by the <i>cRanges</i> parameter.
     * @param {Pointer<Integer>} pwLogClust Pointer to an array of logical cluster information. Each element in the array corresponds to a character in the array defined by <i>pwcChars</i>. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure is set to <b>TRUE</b>, the elements in <i>pwLogClust</i> decrease as the array is read.
     * @param {Pointer<SCRIPT_CHARPROP>} pCharProps Pointer to an array of character property values in the Unicode run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Pointer<Integer>} pwGlyphs Pointer to a glyph buffer obtained from an earlier call to the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshapeopentype">ScriptShapeOpenType</a> function.
     * @param {Pointer<SCRIPT_GLYPHPROP>} pGlyphProps Pointer to an array of attributes for each of the glyphs to retrieve. The number of values equals the value of 
     * <i>cGlyphs</i>. Since there is one glyph property per glyph, this parameter has the number of elements indicated by <i>cGlyphs</i>.
     * @param {Integer} cGlyphs Count of glyphs in a glyph array buffer.
     * @param {Pointer<GOFFSET>} pGoffset Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structures in which this structure retrieves the x and y offsets of combining glyphs. This array must be of length indicated by <i>cGlyphs</i>.
     * @param {Pointer<ABC>} pABC Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-abc">ABC</a> structure in which this function retrieves the <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> for the entire <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">run</a>.
     * @returns {Integer} Pointer to an array, of length indicated by <i>cGlyphs</i>, in which this function retrieves <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">advance width</a> information.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptplaceopentype
     * @since windows6.0.6000
     */
    static ScriptPlaceOpenType(hdc, psc, psa, tagScript, tagLangSys, rcRangeChars, rpRangeProperties, cRanges, pwcChars, pwLogClust, pCharProps, cChars, pwGlyphs, pGlyphProps, cGlyphs, pGoffset, pABC) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc
        pwcChars := pwcChars is String ? StrPtr(pwcChars) : pwcChars

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        rcRangeCharsMarshal := rcRangeChars is VarRef ? "int*" : "ptr"
        rpRangePropertiesMarshal := rpRangeProperties is VarRef ? "ptr*" : "ptr"
        pwLogClustMarshal := pwLogClust is VarRef ? "ushort*" : "ptr"
        pwGlyphsMarshal := pwGlyphs is VarRef ? "ushort*" : "ptr"

        result := DllCall("USP10.dll\ScriptPlaceOpenType", "ptr", hdc, pscMarshal, psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, rcRangeCharsMarshal, rcRangeChars, rpRangePropertiesMarshal, rpRangeProperties, "int", cRanges, "ptr", pwcChars, pwLogClustMarshal, pwLogClust, "ptr", pCharProps, "int", cChars, pwGlyphsMarshal, pwGlyphs, "ptr", pGlyphProps, "int", cGlyphs, "int*", &piAdvance := 0, "ptr", pGoffset, "ptr", pABC, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return piAdvance
    }

    /**
     * Breaks a Unicode string into individually shapeable items and provides an array of feature tags for each shapeable item for OpenType processing.
     * @remarks
     * <b>ScriptItemizeOpenType</b> is preferred over the older <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a> function. One advantage of <b>ScriptItemizeOpenType</b> is the availability of feature tags for each shapeable item.
     * 
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/displaying-text-with-uniscribe">Displaying Text with Uniscribe</a> for a discussion of the context in which this function is normally called.
     * 
     * The function delimits items by either a change of shaping engine or a change of direction.
     * 
     * The application can create multiple ranges, or runs that fall entirely within a single item, from each <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structure retrieved by <b>ScriptItemizeOpenType</b>. However, it should not combine multiple items into a single run. When measuring or rendering, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshapeopentype">ScriptShapeOpenType</a> for each run and must pass the corresponding <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structure retrieved by <b>ScriptItemizeOpenType</b>.
     * 
     * If the text handled by an application can include any right-to-left content, the application uses the <i>psControl</i> and <i>psState</i> parameters in calling <b>ScriptItemizeOpenType</b>. However, the application does not have to do this and can handle bidirectional text itself instead of relying on Uniscribe to do so. The <i>psControl</i> and <i>psState</i> parameters are useful in some strictly left-to-right scenarios, for example, when the <b>fLinkStringBefore</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> is not specific to right-to-left scripts. The application sets <i>psControl</i> and <i>psState</i> to <b>NULL</b> to have <b>ScriptItemizeOpenType</b> break the Unicode string purely by character code.
     * 
     * The application can set all parameters to non-<b>NULL</b> values to have the function perform a full Unicode bidirectional analysis. To permit a correct Unicode bidirectional analysis, the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure should be initialized according to the reading order at paragraph start, and <b>ScriptItemizeOpenType</b> should be passed the whole paragraph. In particular, the <b>uBidiLevel</b> member should be initialized to 0 for left-to-right and 1 for right-to-left.
     * 
     * The <b>fRTL</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> is referenced in <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a>. The <b>fNumeric</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> is retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetproperties">ScriptGetProperties</a>. These members together provide the same classification as the <b>lpClass</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-gcp_resultsa">GCP_RESULTS</a>, referenced by <i>lpResults</i> in <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a>.
     * 
     * European digits U+0030 through U+0039 can be rendered as national digits, as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>SCRIPT_STATE.fDigitSubstitute</th>
     * <th>SCRIPT_CONTROL.fContextDigits</th>
     * <th>Digit shapes displayed for Unicode U+0030 through U+0039</th>
     * </tr>
     * <tr>
     * <td><b>FALSE</b></td>
     * <td>Any</td>
     * <td>European digits</td>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td><b>FALSE</b></td>
     * <td>As specified in <b>uDefaultLanguage</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a>.</td>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td><b>TRUE</b></td>
     * <td>As prior strong text, defaulting to <b>uDefaultLanguage</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a>.</td>
     * </tr>
     * </table>
     * 
     * 
     * In context digit mode, one of the following actions occurs:
     * 
     * <ul>
     * <li>If the script specified by <b>uDefaultLanguage</b> is in the same direction as the output, all digits encountered before the first letters are rendered in the language indicated by <b>uDefaultLanguage</b>.</li>
     * <li>If the script specified by <b>uDefaultLanguage</b> is in the opposite direction from the output, all digits encountered before the first letters are rendered in European digits.</li>
     * </ul>
     * For example, if <b>uDefaultLanguage</b> indicates LANG_ARABIC, initial digits are in Arabic-Indic in a right-to-left embedding. However they are in European digits in a left-to-right embedding.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/digit-shapes">Digit Shapes</a>.
     * 
     * The Unicode control characters and definitions, and their effects on <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> members, are provided in the following table. For more information on Unicode control characters, see the <a href="https://www.unicode.org/standard/standard.html">The Unicode Standard</a>.
     * 
     * <table>
     * <tr>
     * <th>Unicode control characters</th>
     * <th>Meaning</th>
     * <th>Effect on SCRIPT_STATE</th>
     * </tr>
     * <tr>
     * <td>NADS</td>
     * <td>Override European digits (NODS) with national digit shapes.</td>
     * <td>Set <b>fDigitSubstitute</b>.</td>
     * </tr>
     * <tr>
     * <td>NODS</td>
     * <td>Use nominal digit shapes, otherwise known as European digits. See NADS.</td>
     * <td>Clear <b>fDigitSubstitute</b>.</td>
     * </tr>
     * <tr>
     * <td>ASS</td>
     * <td>Activate swapping of symmetric pairs, for example, parentheses. For these characters, left and right are interpreted as opening and closing. This is the default. See ISS.</td>
     * <td>Clear <b>fInhibitSymSwap</b>.</td>
     * </tr>
     * <tr>
     * <td>ISS</td>
     * <td>Inhibit swapping of symmetric pairs. See ASS.</td>
     * <td>Set <b>fInhibitSymSwap</b>.</td>
     * </tr>
     * <tr>
     * <td>AAFS</td>
     * <td>Activate Arabic form shaping for Arabic presentation forms. See IAFS.</td>
     * <td>Set <b>fCharShape</b>.</td>
     * </tr>
     * <tr>
     * <td>IAFS</td>
     * <td>Inhibit Arabic form shaping, that is, ligatures and cursive connections, for Arabic presentation forms. Nominal Arabic characters are not affected. This is the default. See AAFS.</td>
     * <td>Clear <b>fCharShape</b>.</td>
     * </tr>
     * </table>
     * 
     * 
     * The <b>fArabicNumContext</b> member of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> supports the context-sensitive display of numerals in Arabic script text. It indicates if digits are rendered using native Arabic script digit shapes or European digits. At the beginning of a paragraph, this member should normally be initialized to <b>TRUE</b> for an Arabic locale, or <b>FALSE</b> for any other locale. The function updates the script state it as it processes strong text.
     * 
     * The output parameter <i>pScriptTags</i> indicates an array with entries parallel to items. For each item, this function retrieves a script tag that should be used for shaping in all subsequent operations.
     * 
     * A script tag is usually determined by <b>ScriptItemizeOpenType</b> from input characters. If the function retrieves a specific script tag, the application should pass it to other functions without change. However, when characters are neutral (for example, digits) and the script cannot be determined, the application should choose an appropriate script tag, for example, based on font and language associated with text.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {PWSTR} pwcInChars Pointer to a Unicode string to itemize.
     * @param {Integer} cInChars Number of characters in <i>pwcInChars</i> to itemize.
     * @param {Integer} cMaxItems Maximum number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures defining items to process.
     * @param {Pointer<SCRIPT_CONTROL>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure indicating the type of itemization to perform.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if no <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> properties are needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_STATE>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure indicating the initial bidirectional algorithm state.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if the script state is not needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ITEM>} pItems Pointer to a buffer in which the function retrieves <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures representing the items that have been processed. The buffer should be  <c>(cMaxItems + 1) * sizeof(SCRIPT_ITEM)</c> bytes in length. It is invalid to call this function with a buffer that handles less than two <b>SCRIPT_ITEM</b> structures. The function always adds a terminal item to the item analysis array so that the length of the item with zero-based index "i" is always available as:
     * 
     * <c>pItems[i+1].iCharPos - pItems[i].iCharPos;</c>
     * @param {Pointer<Integer>} pScriptTags Pointer to a buffer in which the function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures representing script tags. The buffer should be  <c>cMaxItems * sizeof(OPENTYPE_TAG)</c> bytes in length.
     * 
     * <div class="alert"><b>Note</b>When all characters in an item are neutral, the value of this parameter is SCRIPT_TAG_UNKNOWN (0x00000000). This can happen, for example, if an item consists entirely of punctuation.</div>
     * <div></div>
     * @param {Pointer<Integer>} pcItems Pointer to the number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures processed.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, no items are fully processed and no part of the output contains defined values. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * The function returns E_OUTOFMEMORY if the size indicated by <i>cMaxItems</i> is too small. The application can try calling the function again with a larger buffer.
     * 
     * The function returns E_INVALIDARG if one or more of the following conditions occur:
     * 
     * <ul>
     * <li><i>pwcInChars</i> is set to <b>NULL</b></li>
     * <li><i>cInChars</i> is 0</li>
     * <li><i>pItems</i> is set to <b>NULL</b></li>
     * <li><i>pScriptTags</i> is set to <b>NULL</b></li>
     * <li><i>cMaxItems</i> &lt; 2</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptitemizeopentype
     * @since windows6.0.6000
     */
    static ScriptItemizeOpenType(pwcInChars, cInChars, cMaxItems, psControl, psState, pItems, pScriptTags, pcItems) {
        pwcInChars := pwcInChars is String ? StrPtr(pwcInChars) : pwcInChars

        pScriptTagsMarshal := pScriptTags is VarRef ? "uint*" : "ptr"
        pcItemsMarshal := pcItems is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptItemizeOpenType", "ptr", pwcInChars, "int", cInChars, "int", cMaxItems, "ptr", psControl, "ptr", psState, "ptr", pItems, pScriptTagsMarshal, pScriptTags, pcItemsMarshal, pcItems, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a list of scripts available in the font for OpenType processing. Scripts comprising the list are retrieved from the font located in the supplied device context or from the script shaping engine that processes the font of the current run.
     * @remarks
     * While formally declared as a ULONG type, <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> defines a 4-byte array that contains four 8-bit ASCII values of space, A-Z or a-z. For example, the script tags for Latin and Arabic scripts are "latn" and "arab", respectively.
     * 
     * This function retrieves a single tag from a font in the following cases:
     * 
     * <ul>
     * <li>The <i>psa</i> value is associated with text for a single complex script.</li>
     * <li>The <i>psa</i> parameter indicates <b>NULL</b> and the font supports a single script.</li>
     * </ul>
     * If <b>ScriptGetFontScriptTags</b> retrieves all tags from a font, the tags are usually for neutral items, such as digits. Note that more than one tag might be applicable because some text runs of neutral items are not script-specific.
     * 
     * If a tag corresponding to a particular script is present, a shaping engine might be unable to use the font to shape the given item because the engine lacks a needed item, such as a specific language system or a specific feature.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the appropriate font script tags can be retrieved. The application supplies a non-<b>NULL</b> value for this parameter to retrieve script tags appropriate for the current run.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} cMaxTags The length of the array specified by <i>pScriptTags</i>.
     * @param {Pointer<Integer>} pScriptTags Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures defining script tags from the device context or the scripting engine associated with the current run. If the value of the <b>eScript</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure provided in the <i>psa</i> parameter has a definite script tag associated with it and the tag is present in the font, <i>pScriptTags</i> contains only this tag.
     * @param {Pointer<Integer>} pcTags Pointer to the number of elements in the script tag array indicated by <i>pScriptTags</i>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds the value of <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontscripttags
     * @since windows6.0.6000
     */
    static ScriptGetFontScriptTags(hdc, psc, psa, cMaxTags, pScriptTags, pcTags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        pScriptTagsMarshal := pScriptTags is VarRef ? "uint*" : "ptr"
        pcTagsMarshal := pcTags is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetFontScriptTags", "ptr", hdc, pscMarshal, psc, "ptr", psa, "int", cMaxTags, pScriptTagsMarshal, pScriptTags, pcTagsMarshal, pcTags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a list of language tags that are available for the specified item and are supported by a specified script tag for OpenType processing. The tags comprising the list are retrieved from the font in the specified device context or cache.
     * @remarks
     * While formally declared as a ULONG type, the <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure contains a 4-byte array that contains four 8-bit ASCII values of space, A-Z, or a-z. For example, the language tags for Romanian, Urdu, and Persian are "ROM ", "URD ", and "FAR ", respectively. Note that each tag ends with a space.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the font language tags for the appropriate font and scripts can be retrieved.
     * 
     * Alternately, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for which the list of associated language tags is requested.
     * @param {Integer} cMaxTags The length of the array specified by <i>pLangSysTags</i>.
     * @param {Pointer<Integer>} pLangsysTags Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures identifying the language tags matching input criteria.
     * @param {Pointer<Integer>} pcTags Pointer to the number of elements in the language tag array.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontlanguagetags
     * @since windows6.0.6000
     */
    static ScriptGetFontLanguageTags(hdc, psc, psa, tagScript, cMaxTags, pLangsysTags, pcTags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        pLangsysTagsMarshal := pLangsysTags is VarRef ? "uint*" : "ptr"
        pcTagsMarshal := pcTags is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetFontLanguageTags", "ptr", hdc, pscMarshal, psc, "ptr", psa, "uint", tagScript, "int", cMaxTags, pLangsysTagsMarshal, pLangsysTags, pcTagsMarshal, pcTags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a list of typographic features for the defined writing system for OpenType processing. The typographic feature tags comprising the list are retrieved from the font in the supplied device context or cache.
     * @remarks
     * While formally declared as a ULONG type, an <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure contains a 4-byte array that contains four 8-bit ASCII values of space, A-Z, or a-z. For example, the feature tag for the Ligature feature is "liga".
     * 
     * This function hides script-required or language-required features because the shaping engine controls these features. The application has no control over the shaping engine handling for language-required features. For example, <b>ScriptGetFontFeatureTags</b> hides the Arabic script features for initial, medial, and final forms.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the font feature tags for the appropriate font and scripts can be retrieved.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag associated with the specified feature tags.
     * @param {Integer} tagLangSys An <b>OPENTYPE_TAG</b> structure defining the language tag associated with the specified feature tags.
     * @param {Integer} cMaxTags The length of the array specified by <i>pFeatureTags</i>.
     * @param {Pointer<Integer>} pFeatureTags Pointer to a buffer in which this function retrieves an array of <b>OPENTYPE_TAG</b> structures defining the typographic feature tags supported by the font in the device context or cache for the defined writing system.
     * @param {Pointer<Integer>} pcTags Pointer to the number of elements in the feature tag array.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds the value of <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontfeaturetags
     * @since windows6.0.6000
     */
    static ScriptGetFontFeatureTags(hdc, psc, psa, tagScript, tagLangSys, cMaxTags, pFeatureTags, pcTags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        pFeatureTagsMarshal := pFeatureTags is VarRef ? "uint*" : "ptr"
        pcTagsMarshal := pcTags is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetFontFeatureTags", "ptr", hdc, pscMarshal, psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "int", cMaxTags, pFeatureTagsMarshal, pFeatureTags, pcTagsMarshal, pcTags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a list of alternate glyphs for a specified character that can be accessed through a specified OpenType feature.
     * @remarks
     * When using alternate glyphs, the application first reshapes the original glyph without applying any feature tag, then selects an alternate. The original glyph is established as the base glyph. If another alternate is required, the original glyph provides information to match with the corresponding alternates list.
     * 
     * If an alternate glyph is used as the base glyph, no matching output list is found. The user interface uses the selected final form without providing the capability to choose another alternate.
     * 
     * The operations of <b>ScriptGetFontAlternateGlyphs</b> can be emulated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptsubstitutesingleglyph">ScriptSubstituteSingleGlyph</a>. The application should try parameters one by one while glyphs are substituted.
     * 
     * For shaping fonts with Uniscribe, <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshapeopentype">ScriptShapeOpenType</a> is preferred over the older <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> function.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure defining the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the array of alternate glyphs can be created with the correct scope.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag associated with alternate glyphs.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag associated with alternate glyphs.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag associated with alternate glyphs.
     * @param {Integer} wGlyphId The identifier of the original glyph mapped from the character map table.
     * @param {Integer} cMaxAlternates Length of the array specified by <i>pAlternateGlyphs</i>.
     * @param {Pointer<Integer>} pAlternateGlyphs Pointer to buffer in which this function retrieves an array of glyph identifiers. The array includes the original glyph, followed by alternate glyphs. The first element is always the original glyph. Alternate forms are identified by an index into the array. The index is a value greater than one and less than the value of <i>pcAlternates</i>.
     * 
     * When the user chooses an alternate form from the user interface, the alternate glyph is applied to the corresponding character and the rendering is reformatted.
     * @param {Pointer<Integer>} pcAlternates Pointer to the number of elements in the array specified by <i>pAlternateGlyphs</i>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of alternate glyphs exceeds the value of <i>cMaxAlternates</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptgetfontalternateglyphs
     * @since windows6.0.6000
     */
    static ScriptGetFontAlternateGlyphs(hdc, psc, psa, tagScript, tagLangSys, tagFeature, wGlyphId, cMaxAlternates, pAlternateGlyphs, pcAlternates) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"
        pAlternateGlyphsMarshal := pAlternateGlyphs is VarRef ? "ushort*" : "ptr"
        pcAlternatesMarshal := pcAlternates is VarRef ? "int*" : "ptr"

        result := DllCall("USP10.dll\ScriptGetFontAlternateGlyphs", "ptr", hdc, pscMarshal, psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "ushort", wGlyphId, "int", cMaxAlternates, pAlternateGlyphsMarshal, pAlternateGlyphs, pcAlternatesMarshal, pcAlternates, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enables substitution of a single glyph with one alternate form of the same glyph for OpenType processing.
     * @remarks
     * This function uses one-to-one substitution in which the application can substitute one glyph with one alternate form. Most often, applications use this function to set a bullet or an alternate glyph at the beginning or end of a line.
     * 
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure indicating the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine so that the correct substitute glyph is used.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for shaping.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag for shaping.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag to use for shaping the alternate glyph.
     * @param {Integer} lParameter Reference to the alternate glyph to substitute. This reference is an index to an array that contains all the alternate glyphs defined in the feature, as illustrated for <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a>. The alternate glyph array is one of the items retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetfontalternateglyphs">ScriptGetFontAlternateGlyphs</a>.
     * @param {Integer} wGlyphId Identifier of the original glyph.
     * @returns {Integer} Pointer to the location in which this function retrieves the identifier of the alternate glyph.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptsubstitutesingleglyph
     * @since windows6.0.6000
     */
    static ScriptSubstituteSingleGlyph(hdc, psc, psa, tagScript, tagLangSys, tagFeature, lParameter, wGlyphId) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"

        result := DllCall("USP10.dll\ScriptSubstituteSingleGlyph", "ptr", hdc, pscMarshal, psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "int", lParameter, "ushort", wGlyphId, "ushort*", &pwOutGlyphId := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pwOutGlyphId
    }

    /**
     * Positions a single glyph with a single adjustment using a specified feature provided in the font for OpenType processing. Most often, applications use this function to align a glyph optically at the beginning or end of a line.
     * @remarks
     * This function positions an individual glyph by adjusting the advance width and/or the offset of the given glyph. The function assumes that the font requires only one adjustment.
     * 
     * A typical use of this function is the slight adjustment of the margin to account for the visual impression made by certain characters. In Latin script, for example, at the beginning of a line it is common to make a slight adjustment to the left for an initial capital (such as "T" or "O") that does not have a vertical line on the left part of the glyph. Although doing this breaks the strict linear margin, the eye perceives the margin as more even.
     * 
     * The following examples demonstrate this effect. The first example shows strict alignment; the next two examples show an adjustment of the initial "T" to the left. The adjustments are by one pixel and two pixels, respectively. The magnified images to the right show how the "T" pushes slightly farther into the left margin in each successive case.
     * 
     * <img alt="Illustration showing the same block of text three times, with enlargements of each showing slightly different alignment" border="" src="./images/HAlign.gif"/>
     * <div class="alert"><b>Important</b>Starting with Windows8: To maintain the ability to run on Windows7, a module that uses Uniscribe must specify Usp10.lib before gdi32.lib in its library list.</div>
     * <div></div>
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Pointer<Void>>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This structure identifies the shaping engine, so that the advance widths can be retrieved.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for shaping.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag for shaping.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag to use for shaping the alternate glyph.
     * @param {Integer} lParameter A flag specifying if single substitution should be applied to the identifier specified in <i>wGlyphId</i>. The application sets this parameter to 1 to apply the single substitution feature to the identifier. The application sets the parameter to 0 if the function should not apply the feature.
     * @param {Integer} wGlyphId The identifier of the original glyph being shaped.
     * @param {Integer} iAdvance The original glyph advance width.
     * @param {GOFFSET} GOffset The original glyph offset. Typically, this value is an output of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplaceopentype">ScriptPlaceOpenType</a> or <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<GOFFSET>} pOutGoffset Pointer to the location in which this function retrieves the new glyph offset adjusted for the alternate glyph.
     * @returns {Integer} Pointer to the location in which this function retrieves the new advance width adjusted for the alternate glyph.
     * @see https://learn.microsoft.com/windows/win32/api/usp10/nf-usp10-scriptpositionsingleglyph
     * @since windows6.0.6000
     */
    static ScriptPositionSingleGlyph(hdc, psc, psa, tagScript, tagLangSys, tagFeature, lParameter, wGlyphId, iAdvance, GOffset, pOutGoffset) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        pscMarshal := psc is VarRef ? "ptr*" : "ptr"

        result := DllCall("USP10.dll\ScriptPositionSingleGlyph", "ptr", hdc, pscMarshal, psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "int", lParameter, "ushort", wGlyphId, "int", iAdvance, "ptr", GOffset, "int*", &piOutAdvance := 0, "ptr", pOutGoffset, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return piOutAdvance
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Pointer<Integer>} pi 
     * @param {Integer} length 
     * @param {Integer} c 
     * @param {Integer} strict 
     * @returns {Integer} 
     */
    static utf8_nextCharSafeBody(s, pi, length, c, strict) {
        sMarshal := s is VarRef ? "char*" : "ptr"
        piMarshal := pi is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\utf8_nextCharSafeBody", sMarshal, s, piMarshal, pi, "int", length, "int", c, "char", strict, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} i 
     * @param {Integer} length 
     * @param {Integer} c 
     * @param {Pointer<Integer>} pIsError 
     * @returns {Integer} 
     */
    static utf8_appendCharSafeBody(s, i, length, c, pIsError) {
        sMarshal := s is VarRef ? "char*" : "ptr"
        pIsErrorMarshal := pIsError is VarRef ? "char*" : "ptr"

        result := DllCall("icuuc.dll\utf8_appendCharSafeBody", sMarshal, s, "int", i, "int", length, "int", c, pIsErrorMarshal, pIsError, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} start 
     * @param {Pointer<Integer>} pi 
     * @param {Integer} c 
     * @param {Integer} strict 
     * @returns {Integer} 
     */
    static utf8_prevCharSafeBody(s, start, pi, c, strict) {
        sMarshal := s is VarRef ? "char*" : "ptr"
        piMarshal := pi is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\utf8_prevCharSafeBody", sMarshal, s, "int", start, piMarshal, pi, "int", c, "char", strict, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} start 
     * @param {Integer} i 
     * @returns {Integer} 
     */
    static utf8_back1SafeBody(s, start, i) {
        sMarshal := s is VarRef ? "char*" : "ptr"

        result := DllCall("icuuc.dll\utf8_back1SafeBody", sMarshal, s, "int", start, "int", i, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} versionArray 
     * @param {PSTR} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionFromString(versionArray, versionString) {
        versionString := versionString is String ? StrPtr(versionString) : versionString

        versionArrayMarshal := versionArray is VarRef ? "char*" : "ptr"

        DllCall("icuuc.dll\u_versionFromString", versionArrayMarshal, versionArray, "ptr", versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} versionArray 
     * @param {Pointer<Integer>} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionFromUString(versionArray, versionString) {
        versionArrayMarshal := versionArray is VarRef ? "char*" : "ptr"
        versionStringMarshal := versionString is VarRef ? "ushort*" : "ptr"

        DllCall("icuuc.dll\u_versionFromUString", versionArrayMarshal, versionArray, versionStringMarshal, versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} versionArray 
     * @param {PSTR} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionToString(versionArray, versionString) {
        versionString := versionString is String ? StrPtr(versionString) : versionString

        versionArrayMarshal := versionArray is VarRef ? "char*" : "ptr"

        DllCall("icuuc.dll\u_versionToString", versionArrayMarshal, versionArray, "ptr", versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getVersion(versionArray) {
        versionArrayMarshal := versionArray is VarRef ? "char*" : "ptr"

        DllCall("icuuc.dll\u_getVersion", versionArrayMarshal, versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Integer} code 
     * @returns {PSTR} 
     */
    static u_errorName(code) {
        result := DllCall("icuuc.dll\u_errorName", "int", code, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} traceLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_setLevel(traceLevel) {
        DllCall("icuuc.dll\utrace_setLevel", "int", traceLevel, "CDecl ")
    }

    /**
     * 
     * @returns {Integer} 
     */
    static utrace_getLevel() {
        result := DllCall("icuuc.dll\utrace_getLevel", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UTraceEntry>} e 
     * @param {Pointer<UTraceExit>} x 
     * @param {Pointer<UTraceData>} d 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_setFunctions(context, e, x, d) {
        contextMarshal := context is VarRef ? "ptr" : "ptr"

        DllCall("icuuc.dll\utrace_setFunctions", contextMarshal, context, "ptr", e, "ptr", x, "ptr", d, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} context 
     * @param {Pointer<Pointer<UTraceEntry>>} e 
     * @param {Pointer<Pointer<UTraceExit>>} x 
     * @param {Pointer<Pointer<UTraceData>>} d 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_getFunctions(context, e, x, d) {
        contextMarshal := context is VarRef ? "ptr*" : "ptr"
        eMarshal := e is VarRef ? "ptr*" : "ptr"
        xMarshal := x is VarRef ? "ptr*" : "ptr"
        dMarshal := d is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\utrace_getFunctions", contextMarshal, context, eMarshal, e, xMarshal, x, dMarshal, d, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} outBuf 
     * @param {Integer} capacity 
     * @param {Integer} indent 
     * @param {PSTR} fmt 
     * @param {Pointer<Integer>} args 
     * @returns {Integer} 
     */
    static utrace_vformat(outBuf, capacity, indent, fmt, args) {
        outBuf := outBuf is String ? StrPtr(outBuf) : outBuf
        fmt := fmt is String ? StrPtr(fmt) : fmt

        argsMarshal := args is VarRef ? "char*" : "ptr"

        result := DllCall("icuuc.dll\utrace_vformat", "ptr", outBuf, "int", capacity, "int", indent, "ptr", fmt, argsMarshal, args, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} outBuf 
     * @param {Integer} capacity 
     * @param {Integer} indent 
     * @param {PSTR} fmt 
     * @returns {Integer} 
     */
    static utrace_format(outBuf, capacity, indent, fmt) {
        outBuf := outBuf is String ? StrPtr(outBuf) : outBuf
        fmt := fmt is String ? StrPtr(fmt) : fmt

        result := DllCall("icuuc.dll\utrace_format", "ptr", outBuf, "int", capacity, "int", indent, "ptr", fmt, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} fnNumber 
     * @returns {PSTR} 
     */
    static utrace_functionName(fnNumber) {
        result := DllCall("icuuc.dll\utrace_functionName", "int", fnNumber, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_shapeArabic(source, sourceLength, dest, destSize, options, pErrorCode) {
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_shapeArabic", sourceMarshal, source, "int", sourceLength, destMarshal, dest, "int", destSize, "uint", options, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} nameOrAbbrOrLocale 
     * @param {Pointer<Integer>} fillIn 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uscript_getCode(nameOrAbbrOrLocale, fillIn, capacity, err) {
        nameOrAbbrOrLocale := nameOrAbbrOrLocale is String ? StrPtr(nameOrAbbrOrLocale) : nameOrAbbrOrLocale

        fillInMarshal := fillIn is VarRef ? "int*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uscript_getCode", "ptr", nameOrAbbrOrLocale, fillInMarshal, fillIn, "int", capacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} scriptCode 
     * @returns {PSTR} 
     */
    static uscript_getName(scriptCode) {
        result := DllCall("icuuc.dll\uscript_getName", "int", scriptCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} scriptCode 
     * @returns {PSTR} 
     */
    static uscript_getShortName(scriptCode) {
        result := DllCall("icuuc.dll\uscript_getShortName", "int", scriptCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} codepoint 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uscript_getScript(codepoint, err) {
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uscript_getScript", "int", codepoint, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} sc 
     * @returns {Integer} 
     */
    static uscript_hasScript(c, sc) {
        result := DllCall("icuuc.dll\uscript_hasScript", "int", c, "int", sc, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<Integer>} scripts 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} errorCode 
     * @returns {Integer} 
     */
    static uscript_getScriptExtensions(c, scripts, capacity, errorCode) {
        scriptsMarshal := scripts is VarRef ? "int*" : "ptr"
        errorCodeMarshal := errorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uscript_getScriptExtensions", "int", c, scriptsMarshal, scripts, "int", capacity, errorCodeMarshal, errorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uscript_getSampleString(script, dest, capacity, pErrorCode) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uscript_getSampleString", "int", script, destMarshal, dest, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_getUsage(script) {
        result := DllCall("icuuc.dll\uscript_getUsage", "int", script, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_isRightToLeft(script) {
        result := DllCall("icuuc.dll\uscript_isRightToLeft", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_breaksBetweenLetters(script) {
        result := DllCall("icuuc.dll\uscript_breaksBetweenLetters", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_isCased(script) {
        result := DllCall("icuuc.dll\uscript_isCased", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_current32(iter) {
        result := DllCall("icuuc.dll\uiter_current32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_next32(iter) {
        result := DllCall("icuuc.dll\uiter_next32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_previous32(iter) {
        result := DllCall("icuuc.dll\uiter_previous32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_getState(iter) {
        result := DllCall("icuuc.dll\uiter_getState", "ptr", iter, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Integer} state 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setState(iter, state, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\uiter_setState", "ptr", iter, "uint", state, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setString(iter, s, length) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        DllCall("icuuc.dll\uiter_setString", "ptr", iter, sMarshal, s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setUTF16BE(iter, s, length) {
        s := s is String ? StrPtr(s) : s

        DllCall("icuuc.dll\uiter_setUTF16BE", "ptr", iter, "ptr", s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setUTF8(iter, s, length) {
        s := s is String ? StrPtr(s) : s

        DllCall("icuuc.dll\uiter_setUTF8", "ptr", iter, "ptr", s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @returns {String} Nothing - always returns an empty string
     */
    static uenum_close(en) {
        enMarshal := en is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uenum_close", enMarshal, en, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uenum_count(en, status) {
        enMarshal := en is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uenum_count", enMarshal, en, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @param {Pointer<Integer>} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static uenum_unext(en, resultLength, status) {
        enMarshal := en is VarRef ? "ptr*" : "ptr"
        resultLengthMarshal := resultLength is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uenum_unext", enMarshal, en, resultLengthMarshal, resultLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @param {Pointer<Integer>} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static uenum_next(en, resultLength, status) {
        enMarshal := en is VarRef ? "ptr*" : "ptr"
        resultLengthMarshal := resultLength is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uenum_next", enMarshal, en, resultLengthMarshal, resultLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uenum_reset(en, status) {
        enMarshal := en is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\uenum_reset", enMarshal, en, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Integer>>} strings 
     * @param {Integer} count 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static uenum_openUCharStringsEnumeration(strings, count, ec) {
        stringsMarshal := strings is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uenum_openUCharStringsEnumeration", stringsMarshal, strings, "int", count, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Integer>>} strings 
     * @param {Integer} count 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static uenum_openCharStringsEnumeration(strings, count, ec) {
        stringsMarshal := strings is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uenum_openCharStringsEnumeration", stringsMarshal, strings, "int", count, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {PSTR} 
     */
    static uloc_getDefault() {
        result := DllCall("icuuc.dll\uloc_getDefault", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uloc_setDefault(localeID, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\uloc_setDefault", "ptr", localeID, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} language 
     * @param {Integer} languageCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_getLanguage(localeID, language, languageCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        language := language is String ? StrPtr(language) : language

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getLanguage", "ptr", localeID, "ptr", language, "int", languageCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} script 
     * @param {Integer} scriptCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_getScript(localeID, script, scriptCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        script := script is String ? StrPtr(script) : script

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getScript", "ptr", localeID, "ptr", script, "int", scriptCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} country 
     * @param {Integer} countryCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_getCountry(localeID, country, countryCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        country := country is String ? StrPtr(country) : country

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getCountry", "ptr", localeID, "ptr", country, "int", countryCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} variant 
     * @param {Integer} variantCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_getVariant(localeID, variant, variantCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        variant := variant is String ? StrPtr(variant) : variant

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getVariant", "ptr", localeID, "ptr", variant, "int", variantCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_getName(localeID, name, nameCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        name := name is String ? StrPtr(name) : name

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getName", "ptr", localeID, "ptr", name, "int", nameCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_canonicalize(localeID, name, nameCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        name := name is String ? StrPtr(name) : name

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_canonicalize", "ptr", localeID, "ptr", name, "int", nameCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @returns {PSTR} 
     */
    static uloc_getISO3Language(localeID) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuuc.dll\uloc_getISO3Language", "ptr", localeID, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @returns {PSTR} 
     */
    static uloc_getISO3Country(localeID) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuuc.dll\uloc_getISO3Country", "ptr", localeID, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @returns {Integer} 
     */
    static uloc_getLCID(localeID) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuuc.dll\uloc_getLCID", "ptr", localeID, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} displayLocale 
     * @param {Pointer<Integer>} language 
     * @param {Integer} languageCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayLanguage(locale, displayLocale, language, languageCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        languageMarshal := language is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getDisplayLanguage", "ptr", locale, "ptr", displayLocale, languageMarshal, language, "int", languageCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} displayLocale 
     * @param {Pointer<Integer>} script 
     * @param {Integer} scriptCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayScript(locale, displayLocale, script, scriptCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        scriptMarshal := script is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getDisplayScript", "ptr", locale, "ptr", displayLocale, scriptMarshal, script, "int", scriptCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} displayLocale 
     * @param {Pointer<Integer>} country 
     * @param {Integer} countryCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayCountry(locale, displayLocale, country, countryCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        countryMarshal := country is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getDisplayCountry", "ptr", locale, "ptr", displayLocale, countryMarshal, country, "int", countryCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} displayLocale 
     * @param {Pointer<Integer>} variant 
     * @param {Integer} variantCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayVariant(locale, displayLocale, variant, variantCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        variantMarshal := variant is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getDisplayVariant", "ptr", locale, "ptr", displayLocale, variantMarshal, variant, "int", variantCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @param {PSTR} displayLocale 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayKeyword(keyword, displayLocale, dest, destCapacity, status) {
        keyword := keyword is String ? StrPtr(keyword) : keyword
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getDisplayKeyword", "ptr", keyword, "ptr", displayLocale, destMarshal, dest, "int", destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} keyword 
     * @param {PSTR} displayLocale 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayKeywordValue(locale, keyword, displayLocale, dest, destCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        keyword := keyword is String ? StrPtr(keyword) : keyword
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getDisplayKeywordValue", "ptr", locale, "ptr", keyword, "ptr", displayLocale, destMarshal, dest, "int", destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} inLocaleID 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_getDisplayName(localeID, inLocaleID, result, maxResultSize, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        inLocaleID := inLocaleID is String ? StrPtr(inLocaleID) : inLocaleID

        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getDisplayName", "ptr", localeID, "ptr", inLocaleID, resultMarshal, result, "int", maxResultSize, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @returns {PSTR} 
     */
    static uloc_getAvailable(n) {
        result := DllCall("icuuc.dll\uloc_getAvailable", "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static uloc_countAvailable() {
        result := DllCall("icuuc.dll\uloc_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uloc_openAvailableByType(type, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\uloc_openAvailableByType", "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Pointer<Pointer<Integer>>} 
     */
    static uloc_getISOLanguages() {
        result := DllCall("icuuc.dll\uloc_getISOLanguages", "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Pointer<Pointer<Integer>>} 
     */
    static uloc_getISOCountries() {
        result := DllCall("icuuc.dll\uloc_getISOCountries", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} parent 
     * @param {Integer} parentCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_getParent(localeID, parent, parentCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        parent := parent is String ? StrPtr(parent) : parent

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getParent", "ptr", localeID, "ptr", parent, "int", parentCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_getBaseName(localeID, name, nameCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        name := name is String ? StrPtr(name) : name

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getBaseName", "ptr", localeID, "ptr", name, "int", nameCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uloc_openKeywords(localeID, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_openKeywords", "ptr", localeID, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} keywordName 
     * @param {PSTR} buffer_R 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getKeywordValue(localeID, keywordName, buffer_R, bufferCapacity, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        keywordName := keywordName is String ? StrPtr(keywordName) : keywordName
        buffer_R := buffer_R is String ? StrPtr(buffer_R) : buffer_R

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getKeywordValue", "ptr", localeID, "ptr", keywordName, "ptr", buffer_R, "int", bufferCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} keywordName 
     * @param {PSTR} keywordValue 
     * @param {PSTR} buffer_R 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_setKeywordValue(keywordName, keywordValue, buffer_R, bufferCapacity, status) {
        keywordName := keywordName is String ? StrPtr(keywordName) : keywordName
        keywordValue := keywordValue is String ? StrPtr(keywordValue) : keywordValue
        buffer_R := buffer_R is String ? StrPtr(buffer_R) : buffer_R

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_setKeywordValue", "ptr", keywordName, "ptr", keywordValue, "ptr", buffer_R, "int", bufferCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @returns {Integer} 
     */
    static uloc_isRightToLeft(locale) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\uloc_isRightToLeft", "ptr", locale, "CDecl char")
        return result
    }

    /**
     * 
     * @param {PSTR} localeId 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getCharacterOrientation(localeId, status) {
        localeId := localeId is String ? StrPtr(localeId) : localeId

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getCharacterOrientation", "ptr", localeId, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeId 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getLineOrientation(localeId, status) {
        localeId := localeId is String ? StrPtr(localeId) : localeId

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getLineOrientation", "ptr", localeId, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} result 
     * @param {Integer} resultAvailable 
     * @param {Pointer<Integer>} outResult 
     * @param {PSTR} httpAcceptLanguage 
     * @param {Pointer<UEnumeration>} availableLocales 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_acceptLanguageFromHTTP(result, resultAvailable, outResult, httpAcceptLanguage, availableLocales, status) {
        result := result is String ? StrPtr(result) : result
        httpAcceptLanguage := httpAcceptLanguage is String ? StrPtr(httpAcceptLanguage) : httpAcceptLanguage

        outResultMarshal := outResult is VarRef ? "int*" : "ptr"
        availableLocalesMarshal := availableLocales is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_acceptLanguageFromHTTP", "ptr", result, "int", resultAvailable, outResultMarshal, outResult, "ptr", httpAcceptLanguage, availableLocalesMarshal, availableLocales, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} result 
     * @param {Integer} resultAvailable 
     * @param {Pointer<Integer>} outResult 
     * @param {Pointer<Pointer<Integer>>} acceptList 
     * @param {Integer} acceptListCount 
     * @param {Pointer<UEnumeration>} availableLocales 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_acceptLanguage(result, resultAvailable, outResult, acceptList, acceptListCount, availableLocales, status) {
        result := result is String ? StrPtr(result) : result

        outResultMarshal := outResult is VarRef ? "int*" : "ptr"
        acceptListMarshal := acceptList is VarRef ? "ptr*" : "ptr"
        availableLocalesMarshal := availableLocales is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_acceptLanguage", "ptr", result, "int", resultAvailable, outResultMarshal, outResult, acceptListMarshal, acceptList, "int", acceptListCount, availableLocalesMarshal, availableLocales, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} hostID 
     * @param {PSTR} locale 
     * @param {Integer} localeCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uloc_getLocaleForLCID(hostID, locale, localeCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_getLocaleForLCID", "uint", hostID, "ptr", locale, "int", localeCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} maximizedLocaleID 
     * @param {Integer} maximizedLocaleIDCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_addLikelySubtags(localeID, maximizedLocaleID, maximizedLocaleIDCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        maximizedLocaleID := maximizedLocaleID is String ? StrPtr(maximizedLocaleID) : maximizedLocaleID

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_addLikelySubtags", "ptr", localeID, "ptr", maximizedLocaleID, "int", maximizedLocaleIDCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} minimizedLocaleID 
     * @param {Integer} minimizedLocaleIDCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_minimizeSubtags(localeID, minimizedLocaleID, minimizedLocaleIDCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        minimizedLocaleID := minimizedLocaleID is String ? StrPtr(minimizedLocaleID) : minimizedLocaleID

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_minimizeSubtags", "ptr", localeID, "ptr", minimizedLocaleID, "int", minimizedLocaleIDCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} langtag 
     * @param {PSTR} localeID 
     * @param {Integer} localeIDCapacity 
     * @param {Pointer<Integer>} parsedLength 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_forLanguageTag(langtag, localeID, localeIDCapacity, parsedLength, err) {
        langtag := langtag is String ? StrPtr(langtag) : langtag
        localeID := localeID is String ? StrPtr(localeID) : localeID

        parsedLengthMarshal := parsedLength is VarRef ? "int*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_forLanguageTag", "ptr", langtag, "ptr", localeID, "int", localeIDCapacity, parsedLengthMarshal, parsedLength, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} langtag 
     * @param {Integer} langtagCapacity 
     * @param {Integer} strict 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static uloc_toLanguageTag(localeID, langtag, langtagCapacity, strict, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        langtag := langtag is String ? StrPtr(langtag) : langtag

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uloc_toLanguageTag", "ptr", localeID, "ptr", langtag, "int", langtagCapacity, "char", strict, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @returns {PSTR} 
     */
    static uloc_toUnicodeLocaleKey(keyword) {
        keyword := keyword is String ? StrPtr(keyword) : keyword

        result := DllCall("icuuc.dll\uloc_toUnicodeLocaleKey", "ptr", keyword, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @param {PSTR} value 
     * @returns {PSTR} 
     */
    static uloc_toUnicodeLocaleType(keyword, value) {
        keyword := keyword is String ? StrPtr(keyword) : keyword
        value := value is String ? StrPtr(value) : value

        result := DllCall("icuuc.dll\uloc_toUnicodeLocaleType", "ptr", keyword, "ptr", value, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @returns {PSTR} 
     */
    static uloc_toLegacyKey(keyword) {
        keyword := keyword is String ? StrPtr(keyword) : keyword

        result := DllCall("icuuc.dll\uloc_toLegacyKey", "ptr", keyword, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @param {PSTR} value 
     * @returns {PSTR} 
     */
    static uloc_toLegacyType(keyword, value) {
        keyword := keyword is String ? StrPtr(keyword) : keyword
        value := value is String ? StrPtr(value) : value

        result := DllCall("icuuc.dll\uloc_toLegacyType", "ptr", keyword, "ptr", value, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_open(packageName, locale, status) {
        packageName := packageName is String ? StrPtr(packageName) : packageName
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_open", "ptr", packageName, "ptr", locale, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_openDirect(packageName, locale, status) {
        packageName := packageName is String ? StrPtr(packageName) : packageName
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_openDirect", "ptr", packageName, "ptr", locale, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} packageName 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_openU(packageName, locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        packageNameMarshal := packageName is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_openU", packageNameMarshal, packageName, "ptr", locale, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_close(resourceBundle) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ures_close", resourceBundleMarshal, resourceBundle, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {Pointer<Integer>} versionInfo 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_getVersion(resB, versionInfo) {
        resBMarshal := resB is VarRef ? "ptr*" : "ptr"
        versionInfoMarshal := versionInfo is VarRef ? "char*" : "ptr"

        DllCall("icuuc.dll\ures_getVersion", resBMarshal, resB, versionInfoMarshal, versionInfo, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ures_getLocaleByType(resourceBundle, type, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getLocaleByType", resourceBundleMarshal, resourceBundle, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static ures_getString(resourceBundle, len, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getString", resourceBundleMarshal, resourceBundle, lenMarshal, len, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {PSTR} dest 
     * @param {Pointer<Integer>} length 
     * @param {Integer} forceCopy 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ures_getUTF8String(resB, dest, length, forceCopy, status) {
        dest := dest is String ? StrPtr(dest) : dest

        resBMarshal := resB is VarRef ? "ptr*" : "ptr"
        lengthMarshal := length is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getUTF8String", resBMarshal, resB, "ptr", dest, lengthMarshal, length, "char", forceCopy, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static ures_getBinary(resourceBundle, len, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getBinary", resourceBundleMarshal, resourceBundle, lenMarshal, len, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static ures_getIntVector(resourceBundle, len, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getIntVector", resourceBundleMarshal, resourceBundle, lenMarshal, len, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ures_getUInt(resourceBundle, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getUInt", resourceBundleMarshal, resourceBundle, statusMarshal, status, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ures_getInt(resourceBundle, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getInt", resourceBundleMarshal, resourceBundle, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {Integer} 
     */
    static ures_getSize(resourceBundle) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ures_getSize", resourceBundleMarshal, resourceBundle, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {Integer} 
     */
    static ures_getType(resourceBundle) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ures_getType", resourceBundleMarshal, resourceBundle, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {PSTR} 
     */
    static ures_getKey(resourceBundle) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ures_getKey", resourceBundleMarshal, resourceBundle, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_resetIterator(resourceBundle) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ures_resetIterator", resourceBundleMarshal, resourceBundle, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {Integer} 
     */
    static ures_hasNext(resourceBundle) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ures_hasNext", resourceBundleMarshal, resourceBundle, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<UResourceBundle>} fillIn 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_getNextResource(resourceBundle, fillIn, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        fillInMarshal := fillIn is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getNextResource", resourceBundleMarshal, resourceBundle, fillInMarshal, fillIn, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Pointer<Integer>>} key 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static ures_getNextString(resourceBundle, len, key, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        keyMarshal := key is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getNextString", resourceBundleMarshal, resourceBundle, lenMarshal, len, keyMarshal, key, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Integer} indexR 
     * @param {Pointer<UResourceBundle>} fillIn 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_getByIndex(resourceBundle, indexR, fillIn, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        fillInMarshal := fillIn is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getByIndex", resourceBundleMarshal, resourceBundle, "int", indexR, fillInMarshal, fillIn, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Integer} indexS 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static ures_getStringByIndex(resourceBundle, indexS, len, status) {
        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getStringByIndex", resourceBundleMarshal, resourceBundle, "int", indexS, lenMarshal, len, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {Integer} stringIndex 
     * @param {PSTR} dest 
     * @param {Pointer<Integer>} pLength 
     * @param {Integer} forceCopy 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ures_getUTF8StringByIndex(resB, stringIndex, dest, pLength, forceCopy, status) {
        dest := dest is String ? StrPtr(dest) : dest

        resBMarshal := resB is VarRef ? "ptr*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getUTF8StringByIndex", resBMarshal, resB, "int", stringIndex, "ptr", dest, pLengthMarshal, pLength, "char", forceCopy, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {PSTR} key 
     * @param {Pointer<UResourceBundle>} fillIn 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_getByKey(resourceBundle, key, fillIn, status) {
        key := key is String ? StrPtr(key) : key

        resourceBundleMarshal := resourceBundle is VarRef ? "ptr*" : "ptr"
        fillInMarshal := fillIn is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getByKey", resourceBundleMarshal, resourceBundle, "ptr", key, fillInMarshal, fillIn, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {PSTR} key 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static ures_getStringByKey(resB, key, len, status) {
        key := key is String ? StrPtr(key) : key

        resBMarshal := resB is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getStringByKey", resBMarshal, resB, "ptr", key, lenMarshal, len, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {PSTR} key 
     * @param {PSTR} dest 
     * @param {Pointer<Integer>} pLength 
     * @param {Integer} forceCopy 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ures_getUTF8StringByKey(resB, key, dest, pLength, forceCopy, status) {
        key := key is String ? StrPtr(key) : key
        dest := dest is String ? StrPtr(dest) : dest

        resBMarshal := resB is VarRef ? "ptr*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_getUTF8StringByKey", resBMarshal, resB, "ptr", key, "ptr", dest, pLengthMarshal, pLength, "char", forceCopy, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ures_openAvailableLocales(packageName, status) {
        packageName := packageName is String ? StrPtr(packageName) : packageName

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ures_openAvailableLocales", "ptr", packageName, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Integer} dialectHandling 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<ULocaleDisplayNames>} 
     */
    static uldn_open(locale, dialectHandling, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_open", "ptr", locale, "int", dialectHandling, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @returns {String} Nothing - always returns an empty string
     */
    static uldn_close(ldn) {
        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uldn_close", ldnMarshal, ldn, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @returns {PSTR} 
     */
    static uldn_getLocale(ldn) {
        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uldn_getLocale", ldnMarshal, ldn, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @returns {Integer} 
     */
    static uldn_getDialectHandling(ldn) {
        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uldn_getDialectHandling", ldnMarshal, ldn, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_localeDisplayName(ldn, locale, result, maxResultSize, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_localeDisplayName", ldnMarshal, ldn, "ptr", locale, resultMarshal, result, "int", maxResultSize, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} lang 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_languageDisplayName(ldn, lang, result, maxResultSize, pErrorCode) {
        lang := lang is String ? StrPtr(lang) : lang

        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_languageDisplayName", ldnMarshal, ldn, "ptr", lang, resultMarshal, result, "int", maxResultSize, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} script 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_scriptDisplayName(ldn, script, result, maxResultSize, pErrorCode) {
        script := script is String ? StrPtr(script) : script

        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_scriptDisplayName", ldnMarshal, ldn, "ptr", script, resultMarshal, result, "int", maxResultSize, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {Integer} scriptCode 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_scriptCodeDisplayName(ldn, scriptCode, result, maxResultSize, pErrorCode) {
        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_scriptCodeDisplayName", ldnMarshal, ldn, "int", scriptCode, resultMarshal, result, "int", maxResultSize, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} region 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_regionDisplayName(ldn, region, result, maxResultSize, pErrorCode) {
        region := region is String ? StrPtr(region) : region

        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_regionDisplayName", ldnMarshal, ldn, "ptr", region, resultMarshal, result, "int", maxResultSize, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} variant 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_variantDisplayName(ldn, variant, result, maxResultSize, pErrorCode) {
        variant := variant is String ? StrPtr(variant) : variant

        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_variantDisplayName", ldnMarshal, ldn, "ptr", variant, resultMarshal, result, "int", maxResultSize, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} key 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_keyDisplayName(ldn, key, result, maxResultSize, pErrorCode) {
        key := key is String ? StrPtr(key) : key

        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_keyDisplayName", ldnMarshal, ldn, "ptr", key, resultMarshal, result, "int", maxResultSize, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} key 
     * @param {PSTR} value 
     * @param {Pointer<Integer>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_keyValueDisplayName(ldn, key, value, result, maxResultSize, pErrorCode) {
        key := key is String ? StrPtr(key) : key
        value := value is String ? StrPtr(value) : value

        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_keyValueDisplayName", ldnMarshal, ldn, "ptr", key, "ptr", value, resultMarshal, result, "int", maxResultSize, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} contexts 
     * @param {Integer} length 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<ULocaleDisplayNames>} 
     */
    static uldn_openForContext(locale, contexts, length, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        contextsMarshal := contexts is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_openForContext", "ptr", locale, contextsMarshal, contexts, "int", length, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {Integer} type 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_getContext(ldn, type, pErrorCode) {
        ldnMarshal := ldn is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uldn_getContext", ldnMarshal, ldn, "int", type, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} buff 
     * @param {Integer} buffCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucurr_forLocale(locale, buff, buffCapacity, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        buffMarshal := buff is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_forLocale", "ptr", locale, buffMarshal, buff, "int", buffCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} isoCode 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Void>} 
     */
    static ucurr_register(isoCode, locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        isoCodeMarshal := isoCode is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_register", isoCodeMarshal, isoCode, "ptr", locale, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} key 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucurr_unregister(key, status) {
        keyMarshal := key is VarRef ? "ptr" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_unregister", keyMarshal, key, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} currency 
     * @param {PSTR} locale 
     * @param {Integer} nameStyle 
     * @param {Pointer<Integer>} isChoiceFormat 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<Integer>} 
     */
    static ucurr_getName(currency, locale, nameStyle, isChoiceFormat, len, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"
        isChoiceFormatMarshal := isChoiceFormat is VarRef ? "char*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_getName", currencyMarshal, currency, "ptr", locale, "int", nameStyle, isChoiceFormatMarshal, isChoiceFormat, lenMarshal, len, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} currency 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} isChoiceFormat 
     * @param {PSTR} pluralCount 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<Integer>} 
     */
    static ucurr_getPluralName(currency, locale, isChoiceFormat, pluralCount, len, ec) {
        locale := locale is String ? StrPtr(locale) : locale
        pluralCount := pluralCount is String ? StrPtr(pluralCount) : pluralCount

        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"
        isChoiceFormatMarshal := isChoiceFormat is VarRef ? "char*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_getPluralName", currencyMarshal, currency, "ptr", locale, isChoiceFormatMarshal, isChoiceFormat, "ptr", pluralCount, lenMarshal, len, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} currency 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucurr_getDefaultFractionDigits(currency, ec) {
        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_getDefaultFractionDigits", currencyMarshal, currency, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} currency 
     * @param {Integer} usage 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucurr_getDefaultFractionDigitsForUsage(currency, usage, ec) {
        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_getDefaultFractionDigitsForUsage", currencyMarshal, currency, "int", usage, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} currency 
     * @param {Pointer<Integer>} ec 
     * @returns {Float} 
     */
    static ucurr_getRoundingIncrement(currency, ec) {
        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_getRoundingIncrement", currencyMarshal, currency, ecMarshal, ec, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} currency 
     * @param {Integer} usage 
     * @param {Pointer<Integer>} ec 
     * @returns {Float} 
     */
    static ucurr_getRoundingIncrementForUsage(currency, usage, ec) {
        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_getRoundingIncrementForUsage", currencyMarshal, currency, "int", usage, ecMarshal, ec, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Integer} currType 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucurr_openISOCurrencies(currType, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_openISOCurrencies", "uint", currType, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} isoCode 
     * @param {Float} from 
     * @param {Float} to 
     * @param {Pointer<Integer>} errorCode 
     * @returns {Integer} 
     */
    static ucurr_isAvailable(isoCode, from, to, errorCode) {
        isoCodeMarshal := isoCode is VarRef ? "ushort*" : "ptr"
        errorCodeMarshal := errorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_isAvailable", isoCodeMarshal, isoCode, "double", from, "double", to, errorCodeMarshal, errorCode, "CDecl char")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Float} date 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucurr_countCurrencies(locale, date, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_countCurrencies", "ptr", locale, "double", date, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Float} date 
     * @param {Integer} index 
     * @param {Pointer<Integer>} buff 
     * @param {Integer} buffCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucurr_forLocaleAndDate(locale, date, index, buff, buffCapacity, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        buffMarshal := buff is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_forLocaleAndDate", "ptr", locale, "double", date, "int", index, buffMarshal, buff, "int", buffCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} key 
     * @param {PSTR} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucurr_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        key := key is String ? StrPtr(key) : key
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} currency 
     * @returns {Integer} 
     */
    static ucurr_getNumericCode(currency) {
        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\ucurr_getNumericCode", currencyMarshal, currency, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPMap>} map 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucpmap_get(map, c) {
        mapMarshal := map is VarRef ? "ptr*" : "ptr"

        result := DllCall("icu.dll\ucpmap_get", mapMarshal, map, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPMap>} map 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<Pointer<UCPMapValueFilter>>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Integer>} pValue 
     * @returns {Integer} 
     */
    static ucpmap_getRange(map, start, option, surrogateValue, filter, context, pValue) {
        mapMarshal := map is VarRef ? "ptr*" : "ptr"
        filterMarshal := filter is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        pValueMarshal := pValue is VarRef ? "uint*" : "ptr"

        result := DllCall("icu.dll\ucpmap_getRange", mapMarshal, map, "int", start, "int", option, "uint", surrogateValue, filterMarshal, filter, contextMarshal, context, pValueMarshal, pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Integer} valueWidth 
     * @param {Pointer<Void>} data 
     * @param {Integer} length 
     * @param {Pointer<Integer>} pActualLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UCPTrie>} 
     */
    static ucptrie_openFromBinary(type, valueWidth, data, length, pActualLength, pErrorCode) {
        dataMarshal := data is VarRef ? "ptr" : "ptr"
        pActualLengthMarshal := pActualLength is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucptrie_openFromBinary", "int", type, "int", valueWidth, dataMarshal, data, "int", length, pActualLengthMarshal, pActualLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucptrie_close(trie) {
        DllCall("icu.dll\ucptrie_close", "ptr", trie, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {Integer} 
     */
    static ucptrie_getType(trie) {
        result := DllCall("icu.dll\ucptrie_getType", "ptr", trie, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {Integer} 
     */
    static ucptrie_getValueWidth(trie) {
        result := DllCall("icu.dll\ucptrie_getValueWidth", "ptr", trie, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucptrie_get(trie, c) {
        result := DllCall("icu.dll\ucptrie_get", "ptr", trie, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<Pointer<UCPMapValueFilter>>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Integer>} pValue 
     * @returns {Integer} 
     */
    static ucptrie_getRange(trie, start, option, surrogateValue, filter, context, pValue) {
        filterMarshal := filter is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        pValueMarshal := pValue is VarRef ? "uint*" : "ptr"

        result := DllCall("icu.dll\ucptrie_getRange", "ptr", trie, "int", start, "int", option, "uint", surrogateValue, filterMarshal, filter, contextMarshal, context, pValueMarshal, pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Pointer<Void>} data 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucptrie_toBinary(trie, data, capacity, pErrorCode) {
        dataMarshal := data is VarRef ? "ptr" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucptrie_toBinary", "ptr", trie, dataMarshal, data, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucptrie_internalSmallIndex(trie, c) {
        result := DllCall("icu.dll\ucptrie_internalSmallIndex", "ptr", trie, "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} lt1 
     * @param {Integer} t2 
     * @param {Integer} t3 
     * @returns {Integer} 
     */
    static ucptrie_internalSmallU8Index(trie, lt1, t2, t3) {
        result := DllCall("icu.dll\ucptrie_internalSmallU8Index", "ptr", trie, "int", lt1, "char", t2, "char", t3, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @param {Pointer<Integer>} start 
     * @param {Pointer<Integer>} src 
     * @returns {Integer} 
     */
    static ucptrie_internalU8PrevIndex(trie, c, start, src) {
        startMarshal := start is VarRef ? "char*" : "ptr"
        srcMarshal := src is VarRef ? "char*" : "ptr"

        result := DllCall("icu.dll\ucptrie_internalU8PrevIndex", "ptr", trie, "int", c, startMarshal, start, srcMarshal, src, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} initialValue 
     * @param {Integer} errorValue 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UMutableCPTrie>} 
     */
    static umutablecptrie_open(initialValue, errorValue, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\umutablecptrie_open", "uint", initialValue, "uint", errorValue, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} other 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UMutableCPTrie>} 
     */
    static umutablecptrie_clone(other, pErrorCode) {
        otherMarshal := other is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\umutablecptrie_clone", otherMarshal, other, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_close(trie) {
        trieMarshal := trie is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\umutablecptrie_close", trieMarshal, trie, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPMap>} map 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UMutableCPTrie>} 
     */
    static umutablecptrie_fromUCPMap(map, pErrorCode) {
        mapMarshal := map is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\umutablecptrie_fromUCPMap", mapMarshal, map, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UMutableCPTrie>} 
     */
    static umutablecptrie_fromUCPTrie(trie, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\umutablecptrie_fromUCPTrie", "ptr", trie, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static umutablecptrie_get(trie, c) {
        trieMarshal := trie is VarRef ? "ptr*" : "ptr"

        result := DllCall("icu.dll\umutablecptrie_get", trieMarshal, trie, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<Pointer<UCPMapValueFilter>>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Integer>} pValue 
     * @returns {Integer} 
     */
    static umutablecptrie_getRange(trie, start, option, surrogateValue, filter, context, pValue) {
        trieMarshal := trie is VarRef ? "ptr*" : "ptr"
        filterMarshal := filter is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        pValueMarshal := pValue is VarRef ? "uint*" : "ptr"

        result := DllCall("icu.dll\umutablecptrie_getRange", trieMarshal, trie, "int", start, "int", option, "uint", surrogateValue, filterMarshal, filter, contextMarshal, context, pValueMarshal, pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} c 
     * @param {Integer} value 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_set(trie, c, value, pErrorCode) {
        trieMarshal := trie is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\umutablecptrie_set", trieMarshal, trie, "int", c, "uint", value, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} start 
     * @param {Integer} end 
     * @param {Integer} value 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_setRange(trie, start, end, value, pErrorCode) {
        trieMarshal := trie is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\umutablecptrie_setRange", trieMarshal, trie, "int", start, "int", end, "uint", value, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} type 
     * @param {Integer} valueWidth 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UCPTrie>} 
     */
    static umutablecptrie_buildImmutable(trie, type, valueWidth, pErrorCode) {
        trieMarshal := trie is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\umutablecptrie_buildImmutable", trieMarshal, trie, "int", type, "int", valueWidth, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<Integer>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_STOP(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        codeUnitsMarshal := codeUnits is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_STOP", contextMarshal, context, "ptr", fromUArgs, codeUnitsMarshal, codeUnits, "int", length, "int", codePoint, "int", reason, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {PSTR} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_STOP(context, toUArgs, codeUnits, length, reason, err) {
        codeUnits := codeUnits is String ? StrPtr(codeUnits) : codeUnits

        contextMarshal := context is VarRef ? "ptr" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_STOP", contextMarshal, context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<Integer>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_SKIP(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        codeUnitsMarshal := codeUnits is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_SKIP", contextMarshal, context, "ptr", fromUArgs, codeUnitsMarshal, codeUnits, "int", length, "int", codePoint, "int", reason, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<Integer>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_SUBSTITUTE(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        codeUnitsMarshal := codeUnits is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_SUBSTITUTE", contextMarshal, context, "ptr", fromUArgs, codeUnitsMarshal, codeUnits, "int", length, "int", codePoint, "int", reason, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<Integer>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_ESCAPE(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        codeUnitsMarshal := codeUnits is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_ESCAPE", contextMarshal, context, "ptr", fromUArgs, codeUnitsMarshal, codeUnits, "int", length, "int", codePoint, "int", reason, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {PSTR} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_SKIP(context, toUArgs, codeUnits, length, reason, err) {
        codeUnits := codeUnits is String ? StrPtr(codeUnits) : codeUnits

        contextMarshal := context is VarRef ? "ptr" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_SKIP", contextMarshal, context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {PSTR} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_SUBSTITUTE(context, toUArgs, codeUnits, length, reason, err) {
        codeUnits := codeUnits is String ? StrPtr(codeUnits) : codeUnits

        contextMarshal := context is VarRef ? "ptr" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_SUBSTITUTE", contextMarshal, context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {PSTR} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_ESCAPE(context, toUArgs, codeUnits, length, reason, err) {
        codeUnits := codeUnits is String ? StrPtr(codeUnits) : codeUnits

        contextMarshal := context is VarRef ? "ptr" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_ESCAPE", contextMarshal, context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} name1 
     * @param {PSTR} name2 
     * @returns {Integer} 
     */
    static ucnv_compareNames(name1, name2) {
        name1 := name1 is String ? StrPtr(name1) : name1
        name2 := name2 is String ? StrPtr(name2) : name2

        result := DllCall("icuuc.dll\ucnv_compareNames", "ptr", name1, "ptr", name2, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} converterName 
     * @param {Pointer<Integer>} err 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_open(converterName, err) {
        converterName := converterName is String ? StrPtr(converterName) : converterName

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_open", "ptr", converterName, errMarshal, err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} name 
     * @param {Pointer<Integer>} err 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_openU(name, err) {
        nameMarshal := name is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_openU", nameMarshal, name, errMarshal, err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} codepage 
     * @param {Integer} platform 
     * @param {Pointer<Integer>} err 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_openCCSID(codepage, platform, err) {
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_openCCSID", "int", codepage, "int", platform, errMarshal, err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {PSTR} converterName 
     * @param {Pointer<Integer>} err 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_openPackage(packageName, converterName, err) {
        packageName := packageName is String ? StrPtr(packageName) : packageName
        converterName := converterName is String ? StrPtr(converterName) : converterName

        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_openPackage", "ptr", packageName, "ptr", converterName, errMarshal, err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Integer>} pBufferSize 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_safeClone(cnv, stackBuffer, pBufferSize, status) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        stackBufferMarshal := stackBuffer is VarRef ? "ptr" : "ptr"
        pBufferSizeMarshal := pBufferSize is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_safeClone", cnvMarshal, cnv, stackBufferMarshal, stackBuffer, pBufferSizeMarshal, pBufferSize, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_clone(cnv, status) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucnv_clone", cnvMarshal, cnv, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_close(converter) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucnv_close", converterMarshal, converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {PSTR} subChars 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getSubstChars(converter, subChars, len, err) {
        subChars := subChars is String ? StrPtr(subChars) : subChars

        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "char*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_getSubstChars", converterMarshal, converter, "ptr", subChars, lenMarshal, len, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {PSTR} subChars 
     * @param {Integer} len 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setSubstChars(converter, subChars, len, err) {
        subChars := subChars is String ? StrPtr(subChars) : subChars

        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_setSubstChars", converterMarshal, converter, "ptr", subChars, "char", len, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setSubstString(cnv, s, length, err) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_setSubstString", cnvMarshal, cnv, sMarshal, s, "int", length, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {PSTR} errBytes 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getInvalidChars(converter, errBytes, len, err) {
        errBytes := errBytes is String ? StrPtr(errBytes) : errBytes

        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "char*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_getInvalidChars", converterMarshal, converter, "ptr", errBytes, lenMarshal, len, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Integer>} errUChars 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getInvalidUChars(converter, errUChars, len, err) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        errUCharsMarshal := errUChars is VarRef ? "ushort*" : "ptr"
        lenMarshal := len is VarRef ? "char*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_getInvalidUChars", converterMarshal, converter, errUCharsMarshal, errUChars, lenMarshal, len, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_reset(converter) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucnv_reset", converterMarshal, converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_resetToUnicode(converter) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucnv_resetToUnicode", converterMarshal, converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_resetFromUnicode(converter) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucnv_resetFromUnicode", converterMarshal, converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {Integer} 
     */
    static ucnv_getMaxCharSize(converter) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getMaxCharSize", converterMarshal, converter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {Integer} 
     */
    static ucnv_getMinCharSize(converter) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getMinCharSize", converterMarshal, converter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {PSTR} displayLocale 
     * @param {Pointer<Integer>} displayName 
     * @param {Integer} displayNameCapacity 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static ucnv_getDisplayName(converter, displayLocale, displayName, displayNameCapacity, err) {
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        displayNameMarshal := displayName is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getDisplayName", converterMarshal, converter, "ptr", displayLocale, displayNameMarshal, displayName, "int", displayNameCapacity, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Integer>} err 
     * @returns {PSTR} 
     */
    static ucnv_getName(converter, err) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getName", converterMarshal, converter, errMarshal, err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static ucnv_getCCSID(converter, err) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getCCSID", converterMarshal, converter, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static ucnv_getPlatform(converter, err) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getPlatform", converterMarshal, converter, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {Integer} 
     */
    static ucnv_getType(converter) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getType", converterMarshal, converter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Integer>} starters 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getStarters(converter, starters, err) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        startersMarshal := starters is VarRef ? "char*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_getStarters", converterMarshal, converter, startersMarshal, starters, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<USet>} setFillIn 
     * @param {Integer} whichSet 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getUnicodeSet(cnv, setFillIn, whichSet, pErrorCode) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        setFillInMarshal := setFillIn is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_getUnicodeSet", cnvMarshal, cnv, setFillInMarshal, setFillIn, "int", whichSet, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Pointer<UConverterToUCallback>>} action 
     * @param {Pointer<Pointer<Void>>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getToUCallBack(converter, action, context) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        actionMarshal := action is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucnv_getToUCallBack", converterMarshal, converter, actionMarshal, action, contextMarshal, context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Pointer<UConverterFromUCallback>>} action 
     * @param {Pointer<Pointer<Void>>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getFromUCallBack(converter, action, context) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        actionMarshal := action is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucnv_getFromUCallBack", converterMarshal, converter, actionMarshal, action, contextMarshal, context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<UConverterToUCallback>} newAction 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<Pointer<UConverterToUCallback>>} oldAction 
     * @param {Pointer<Pointer<Void>>} oldContext 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setToUCallBack(converter, newAction, newContext, oldAction, oldContext, err) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        newContextMarshal := newContext is VarRef ? "ptr" : "ptr"
        oldActionMarshal := oldAction is VarRef ? "ptr*" : "ptr"
        oldContextMarshal := oldContext is VarRef ? "ptr*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_setToUCallBack", converterMarshal, converter, "ptr", newAction, newContextMarshal, newContext, oldActionMarshal, oldAction, oldContextMarshal, oldContext, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<UConverterFromUCallback>} newAction 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<Pointer<UConverterFromUCallback>>} oldAction 
     * @param {Pointer<Pointer<Void>>} oldContext 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setFromUCallBack(converter, newAction, newContext, oldAction, oldContext, err) {
        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        newContextMarshal := newContext is VarRef ? "ptr" : "ptr"
        oldActionMarshal := oldAction is VarRef ? "ptr*" : "ptr"
        oldContextMarshal := oldContext is VarRef ? "ptr*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_setFromUCallBack", converterMarshal, converter, "ptr", newAction, newContextMarshal, newContext, oldActionMarshal, oldAction, oldContextMarshal, oldContext, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Pointer<Integer>>} target 
     * @param {PSTR} targetLimit 
     * @param {Pointer<Pointer<Integer>>} source 
     * @param {Pointer<Integer>} sourceLimit 
     * @param {Pointer<Integer>} offsets 
     * @param {Integer} flush 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_fromUnicode(converter, target, targetLimit, source, sourceLimit, offsets, flush, err) {
        targetLimit := targetLimit is String ? StrPtr(targetLimit) : targetLimit

        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        targetMarshal := target is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ptr*" : "ptr"
        sourceLimitMarshal := sourceLimit is VarRef ? "ushort*" : "ptr"
        offsetsMarshal := offsets is VarRef ? "int*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_fromUnicode", converterMarshal, converter, targetMarshal, target, "ptr", targetLimit, sourceMarshal, source, sourceLimitMarshal, sourceLimit, offsetsMarshal, offsets, "char", flush, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Pointer<Integer>>} target 
     * @param {Pointer<Integer>} targetLimit 
     * @param {Pointer<Pointer<Integer>>} source 
     * @param {PSTR} sourceLimit 
     * @param {Pointer<Integer>} offsets 
     * @param {Integer} flush 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_toUnicode(converter, target, targetLimit, source, sourceLimit, offsets, flush, err) {
        sourceLimit := sourceLimit is String ? StrPtr(sourceLimit) : sourceLimit

        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        targetMarshal := target is VarRef ? "ptr*" : "ptr"
        targetLimitMarshal := targetLimit is VarRef ? "ushort*" : "ptr"
        sourceMarshal := source is VarRef ? "ptr*" : "ptr"
        offsetsMarshal := offsets is VarRef ? "int*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_toUnicode", converterMarshal, converter, targetMarshal, target, targetLimitMarshal, targetLimit, sourceMarshal, source, "ptr", sourceLimit, offsetsMarshal, offsets, "char", flush, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_fromUChars(cnv, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_fromUChars", cnvMarshal, cnv, "ptr", dest, "int", destCapacity, srcMarshal, src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_toUChars(cnv, dest, destCapacity, src, srcLength, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_toUChars", cnvMarshal, cnv, destMarshal, dest, "int", destCapacity, "ptr", src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Pointer<Integer>>} source 
     * @param {PSTR} sourceLimit 
     * @param {Pointer<Integer>} err 
     * @returns {Integer} 
     */
    static ucnv_getNextUChar(converter, source, sourceLimit, err) {
        sourceLimit := sourceLimit is String ? StrPtr(sourceLimit) : sourceLimit

        converterMarshal := converter is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ptr*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getNextUChar", converterMarshal, converter, sourceMarshal, source, "ptr", sourceLimit, errMarshal, err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} targetCnv 
     * @param {Pointer<UConverter>} sourceCnv 
     * @param {Pointer<Pointer<Integer>>} target 
     * @param {PSTR} targetLimit 
     * @param {Pointer<Pointer<Integer>>} source 
     * @param {PSTR} sourceLimit 
     * @param {Pointer<Integer>} pivotStart 
     * @param {Pointer<Pointer<Integer>>} pivotSource 
     * @param {Pointer<Pointer<Integer>>} pivotTarget 
     * @param {Pointer<Integer>} pivotLimit 
     * @param {Integer} reset 
     * @param {Integer} flush 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_convertEx(targetCnv, sourceCnv, target, targetLimit, source, sourceLimit, pivotStart, pivotSource, pivotTarget, pivotLimit, reset, flush, pErrorCode) {
        targetLimit := targetLimit is String ? StrPtr(targetLimit) : targetLimit
        sourceLimit := sourceLimit is String ? StrPtr(sourceLimit) : sourceLimit

        targetCnvMarshal := targetCnv is VarRef ? "ptr*" : "ptr"
        sourceCnvMarshal := sourceCnv is VarRef ? "ptr*" : "ptr"
        targetMarshal := target is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ptr*" : "ptr"
        pivotStartMarshal := pivotStart is VarRef ? "ushort*" : "ptr"
        pivotSourceMarshal := pivotSource is VarRef ? "ptr*" : "ptr"
        pivotTargetMarshal := pivotTarget is VarRef ? "ptr*" : "ptr"
        pivotLimitMarshal := pivotLimit is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_convertEx", targetCnvMarshal, targetCnv, sourceCnvMarshal, sourceCnv, targetMarshal, target, "ptr", targetLimit, sourceMarshal, source, "ptr", sourceLimit, pivotStartMarshal, pivotStart, pivotSourceMarshal, pivotSource, pivotTargetMarshal, pivotTarget, pivotLimitMarshal, pivotLimit, "char", reset, "char", flush, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} toConverterName 
     * @param {PSTR} fromConverterName 
     * @param {PSTR} target 
     * @param {Integer} targetCapacity 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_convert(toConverterName, fromConverterName, target, targetCapacity, source, sourceLength, pErrorCode) {
        toConverterName := toConverterName is String ? StrPtr(toConverterName) : toConverterName
        fromConverterName := fromConverterName is String ? StrPtr(fromConverterName) : fromConverterName
        target := target is String ? StrPtr(target) : target
        source := source is String ? StrPtr(source) : source

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_convert", "ptr", toConverterName, "ptr", fromConverterName, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} algorithmicType 
     * @param {Pointer<UConverter>} cnv 
     * @param {PSTR} target 
     * @param {Integer} targetCapacity 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_toAlgorithmic(algorithmicType, cnv, target, targetCapacity, source, sourceLength, pErrorCode) {
        target := target is String ? StrPtr(target) : target
        source := source is String ? StrPtr(source) : source

        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_toAlgorithmic", "int", algorithmicType, cnvMarshal, cnv, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Integer} algorithmicType 
     * @param {PSTR} target 
     * @param {Integer} targetCapacity 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_fromAlgorithmic(cnv, algorithmicType, target, targetCapacity, source, sourceLength, pErrorCode) {
        target := target is String ? StrPtr(target) : target
        source := source is String ? StrPtr(source) : source

        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_fromAlgorithmic", cnvMarshal, cnv, "int", algorithmicType, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_flushCache() {
        result := DllCall("icuuc.dll\ucnv_flushCache", "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_countAvailable() {
        result := DllCall("icuuc.dll\ucnv_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @returns {PSTR} 
     */
    static ucnv_getAvailableName(n) {
        result := DllCall("icuuc.dll\ucnv_getAvailableName", "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucnv_openAllNames(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_openAllNames", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_countAliases(alias, pErrorCode) {
        alias := alias is String ? StrPtr(alias) : alias

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_countAliases", "ptr", alias, pErrorCodeMarshal, pErrorCode, "CDecl ushort")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @param {Integer} n 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_getAlias(alias, n, pErrorCode) {
        alias := alias is String ? StrPtr(alias) : alias

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getAlias", "ptr", alias, "ushort", n, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @param {Pointer<Pointer<Integer>>} aliases 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getAliases(alias, aliases, pErrorCode) {
        alias := alias is String ? StrPtr(alias) : alias

        aliasesMarshal := aliases is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_getAliases", "ptr", alias, aliasesMarshal, aliases, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} convName 
     * @param {PSTR} standard 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucnv_openStandardNames(convName, standard, pErrorCode) {
        convName := convName is String ? StrPtr(convName) : convName
        standard := standard is String ? StrPtr(standard) : standard

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_openStandardNames", "ptr", convName, "ptr", standard, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_countStandards() {
        result := DllCall("icuuc.dll\ucnv_countStandards", "CDecl ushort")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_getStandard(n, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getStandard", "ushort", n, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} name 
     * @param {PSTR} standard 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_getStandardName(name, standard, pErrorCode) {
        name := name is String ? StrPtr(name) : name
        standard := standard is String ? StrPtr(standard) : standard

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getStandardName", "ptr", name, "ptr", standard, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @param {PSTR} standard 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_getCanonicalName(alias, standard, pErrorCode) {
        alias := alias is String ? StrPtr(alias) : alias
        standard := standard is String ? StrPtr(standard) : standard

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_getCanonicalName", "ptr", alias, "ptr", standard, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {PSTR} 
     */
    static ucnv_getDefaultName() {
        result := DllCall("icuuc.dll\ucnv_getDefaultName", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} name 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setDefaultName(name) {
        name := name is String ? StrPtr(name) : name

        DllCall("icuuc.dll\ucnv_setDefaultName", "ptr", name, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_fixFileSeparator(cnv, source, sourceLen) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"

        DllCall("icuuc.dll\ucnv_fixFileSeparator", cnvMarshal, cnv, sourceMarshal, source, "int", sourceLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @returns {Integer} 
     */
    static ucnv_isAmbiguous(cnv) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_isAmbiguous", cnvMarshal, cnv, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Integer} usesFallback 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setFallback(cnv, usesFallback) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucnv_setFallback", cnvMarshal, cnv, "char", usesFallback, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @returns {Integer} 
     */
    static ucnv_usesFallback(cnv) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_usesFallback", cnvMarshal, cnv, "CDecl char")
        return result
    }

    /**
     * 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} signatureLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_detectUnicodeSignature(source, sourceLength, signatureLength, pErrorCode) {
        source := source is String ? StrPtr(source) : source

        signatureLengthMarshal := signatureLength is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_detectUnicodeSignature", "ptr", source, "int", sourceLength, signatureLengthMarshal, signatureLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucnv_fromUCountPending(cnv, status) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_fromUCountPending", cnvMarshal, cnv, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucnv_toUCountPending(cnv, status) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_toUCountPending", cnvMarshal, cnv, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucnv_isFixedWidth(cnv, status) {
        cnvMarshal := cnv is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnv_isFixedWidth", cnvMarshal, cnv, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {PSTR} source 
     * @param {Integer} length 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteBytes(args, source, length, offsetIndex, err) {
        source := source is String ? StrPtr(source) : source

        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_cbFromUWriteBytes", "ptr", args, "ptr", source, "int", length, "int", offsetIndex, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteSub(args, offsetIndex, err) {
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_cbFromUWriteSub", "ptr", args, "int", offsetIndex, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {Pointer<Pointer<Integer>>} source 
     * @param {Pointer<Integer>} sourceLimit 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteUChars(args, source, sourceLimit, offsetIndex, err) {
        sourceMarshal := source is VarRef ? "ptr*" : "ptr"
        sourceLimitMarshal := sourceLimit is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_cbFromUWriteUChars", "ptr", args, sourceMarshal, source, sourceLimitMarshal, sourceLimit, "int", offsetIndex, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterToUnicodeArgs>} args 
     * @param {Pointer<Integer>} source 
     * @param {Integer} length 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbToUWriteUChars(args, source, length, offsetIndex, err) {
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_cbToUWriteUChars", "ptr", args, sourceMarshal, source, "int", length, "int", offsetIndex, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterToUnicodeArgs>} args 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Integer>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbToUWriteSub(args, offsetIndex, err) {
        errMarshal := err is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucnv_cbToUWriteSub", "ptr", args, "int", offsetIndex, errMarshal, err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_init(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\u_init", statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_cleanup() {
        DllCall("icuuc.dll\u_cleanup", "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Pointer<UMemAllocFn>>} a 
     * @param {Pointer<Pointer<UMemReallocFn>>} r 
     * @param {Pointer<Pointer<UMemFreeFn>>} f 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_setMemoryFunctions(context, a, r, f, status) {
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        aMarshal := a is VarRef ? "ptr*" : "ptr"
        rMarshal := r is VarRef ? "ptr*" : "ptr"
        fMarshal := f is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\u_setMemoryFunctions", contextMarshal, context, aMarshal, a, rMarshal, r, fMarshal, f, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} name 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UResourceBundle>} 
     */
    static u_catopen(name, locale, ec) {
        name := name is String ? StrPtr(name) : name
        locale := locale is String ? StrPtr(locale) : locale

        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_catopen", "ptr", name, "ptr", locale, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} catd 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_catclose(catd) {
        catdMarshal := catd is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\u_catclose", catdMarshal, catd, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} catd 
     * @param {Integer} set_num 
     * @param {Integer} msg_num 
     * @param {Pointer<Integer>} s 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<Integer>} 
     */
    static u_catgets(catd, set_num, msg_num, s, len, ec) {
        catdMarshal := catd is VarRef ? "ptr*" : "ptr"
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_catgets", catdMarshal, catd, "int", set_num, "int", msg_num, sMarshal, s, lenMarshal, len, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_hasBinaryProperty(c, which) {
        result := DllCall("icuuc.dll\u_hasBinaryProperty", "int", c, "int", which, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_stringHasBinaryProperty(s, length, which) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icu.dll\u_stringHasBinaryProperty", sMarshal, s, "int", length, "int", which, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<USet>} 
     */
    static u_getBinaryPropertySet(property, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\u_getBinaryPropertySet", "int", property, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUAlphabetic(c) {
        result := DllCall("icuuc.dll\u_isUAlphabetic", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isULowercase(c) {
        result := DllCall("icuuc.dll\u_isULowercase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUUppercase(c) {
        result := DllCall("icuuc.dll\u_isUUppercase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUWhiteSpace(c) {
        result := DllCall("icuuc.dll\u_isUWhiteSpace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyValue(c, which) {
        result := DllCall("icuuc.dll\u_getIntPropertyValue", "int", c, "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyMinValue(which) {
        result := DllCall("icuuc.dll\u_getIntPropertyMinValue", "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyMaxValue(which) {
        result := DllCall("icuuc.dll\u_getIntPropertyMaxValue", "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UCPMap>} 
     */
    static u_getIntPropertyMap(property, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\u_getIntPropertyMap", "int", property, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Float} 
     */
    static u_getNumericValue(c) {
        result := DllCall("icuuc.dll\u_getNumericValue", "int", c, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_islower(c) {
        result := DllCall("icuuc.dll\u_islower", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isupper(c) {
        result := DllCall("icuuc.dll\u_isupper", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_istitle(c) {
        result := DllCall("icuuc.dll\u_istitle", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isdigit(c) {
        result := DllCall("icuuc.dll\u_isdigit", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isalpha(c) {
        result := DllCall("icuuc.dll\u_isalpha", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isalnum(c) {
        result := DllCall("icuuc.dll\u_isalnum", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isxdigit(c) {
        result := DllCall("icuuc.dll\u_isxdigit", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_ispunct(c) {
        result := DllCall("icuuc.dll\u_ispunct", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isgraph(c) {
        result := DllCall("icuuc.dll\u_isgraph", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isblank(c) {
        result := DllCall("icuuc.dll\u_isblank", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isdefined(c) {
        result := DllCall("icuuc.dll\u_isdefined", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isspace(c) {
        result := DllCall("icuuc.dll\u_isspace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaSpaceChar(c) {
        result := DllCall("icuuc.dll\u_isJavaSpaceChar", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isWhitespace(c) {
        result := DllCall("icuuc.dll\u_isWhitespace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_iscntrl(c) {
        result := DllCall("icuuc.dll\u_iscntrl", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isISOControl(c) {
        result := DllCall("icuuc.dll\u_isISOControl", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isprint(c) {
        result := DllCall("icuuc.dll\u_isprint", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isbase(c) {
        result := DllCall("icuuc.dll\u_isbase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charDirection(c) {
        result := DllCall("icuuc.dll\u_charDirection", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isMirrored(c) {
        result := DllCall("icuuc.dll\u_isMirrored", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charMirror(c) {
        result := DllCall("icuuc.dll\u_charMirror", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_getBidiPairedBracket(c) {
        result := DllCall("icuuc.dll\u_getBidiPairedBracket", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charType(c) {
        result := DllCall("icuuc.dll\u_charType", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<UCharEnumTypeRange>>} enumRange 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_enumCharTypes(enumRange, context) {
        enumRangeMarshal := enumRange is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr" : "ptr"

        DllCall("icuuc.dll\u_enumCharTypes", enumRangeMarshal, enumRange, contextMarshal, context, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_getCombiningClass(c) {
        result := DllCall("icuuc.dll\u_getCombiningClass", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charDigitValue(c) {
        result := DllCall("icuuc.dll\u_charDigitValue", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ublock_getCode(c) {
        result := DllCall("icuuc.dll\ublock_getCode", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} code 
     * @param {Integer} nameChoice 
     * @param {PSTR} buffer_R 
     * @param {Integer} bufferLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_charName(code, nameChoice, buffer_R, bufferLength, pErrorCode) {
        buffer_R := buffer_R is String ? StrPtr(buffer_R) : buffer_R

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_charName", "int", code, "int", nameChoice, "ptr", buffer_R, "int", bufferLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} nameChoice 
     * @param {PSTR} name 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_charFromName(nameChoice, name, pErrorCode) {
        name := name is String ? StrPtr(name) : name

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_charFromName", "int", nameChoice, "ptr", name, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<Pointer<UEnumCharNamesFn>>} fn 
     * @param {Pointer<Void>} context 
     * @param {Integer} nameChoice 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_enumCharNames(start, limit, fn, context, nameChoice, pErrorCode) {
        fnMarshal := fn is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\u_enumCharNames", "int", start, "int", limit, fnMarshal, fn, contextMarshal, context, "int", nameChoice, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Integer} nameChoice 
     * @returns {PSTR} 
     */
    static u_getPropertyName(property, nameChoice) {
        result := DllCall("icuuc.dll\u_getPropertyName", "int", property, "int", nameChoice, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @returns {Integer} 
     */
    static u_getPropertyEnum(alias) {
        alias := alias is String ? StrPtr(alias) : alias

        result := DllCall("icuuc.dll\u_getPropertyEnum", "ptr", alias, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Integer} value 
     * @param {Integer} nameChoice 
     * @returns {PSTR} 
     */
    static u_getPropertyValueName(property, value, nameChoice) {
        result := DllCall("icuuc.dll\u_getPropertyValueName", "int", property, "int", value, "int", nameChoice, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {PSTR} alias 
     * @returns {Integer} 
     */
    static u_getPropertyValueEnum(property, alias) {
        alias := alias is String ? StrPtr(alias) : alias

        result := DllCall("icuuc.dll\u_getPropertyValueEnum", "int", property, "ptr", alias, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDStart(c) {
        result := DllCall("icuuc.dll\u_isIDStart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDPart(c) {
        result := DllCall("icuuc.dll\u_isIDPart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDIgnorable(c) {
        result := DllCall("icuuc.dll\u_isIDIgnorable", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaIDStart(c) {
        result := DllCall("icuuc.dll\u_isJavaIDStart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaIDPart(c) {
        result := DllCall("icuuc.dll\u_isJavaIDPart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_tolower(c) {
        result := DllCall("icuuc.dll\u_tolower", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_toupper(c) {
        result := DllCall("icuuc.dll\u_toupper", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_totitle(c) {
        result := DllCall("icuuc.dll\u_totitle", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_foldCase(c, options) {
        result := DllCall("icuuc.dll\u_foldCase", "int", c, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} ch 
     * @param {Integer} radix 
     * @returns {Integer} 
     */
    static u_digit(ch, radix) {
        result := DllCall("icuuc.dll\u_digit", "int", ch, "char", radix, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} digit 
     * @param {Integer} radix 
     * @returns {Integer} 
     */
    static u_forDigit(digit, radix) {
        result := DllCall("icuuc.dll\u_forDigit", "int", digit, "char", radix, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<Integer>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_charAge(c, versionArray) {
        versionArrayMarshal := versionArray is VarRef ? "char*" : "ptr"

        DllCall("icuuc.dll\u_charAge", "int", c, versionArrayMarshal, versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getUnicodeVersion(versionArray) {
        versionArrayMarshal := versionArray is VarRef ? "char*" : "ptr"

        DllCall("icuuc.dll\u_getUnicodeVersion", versionArrayMarshal, versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_getFC_NFKC_Closure(c, dest, destCapacity, pErrorCode) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_getFC_NFKC_Closure", "int", c, destMarshal, dest, "int", destCapacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Pointer<UBiDi>} 
     */
    static ubidi_open() {
        result := DllCall("icuuc.dll\ubidi_open", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} maxLength 
     * @param {Integer} maxRunCount 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UBiDi>} 
     */
    static ubidi_openSized(maxLength, maxRunCount, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_openSized", "int", maxLength, "int", maxRunCount, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_close(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ubidi_close", pBiDiMarshal, pBiDi, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} isInverse 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setInverse(pBiDi, isInverse) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ubidi_setInverse", pBiDiMarshal, pBiDi, "char", isInverse, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_isInverse(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_isInverse", pBiDiMarshal, pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} orderParagraphsLTR 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_orderParagraphsLTR(pBiDi, orderParagraphsLTR) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ubidi_orderParagraphsLTR", pBiDiMarshal, pBiDi, "char", orderParagraphsLTR, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_isOrderParagraphsLTR(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_isOrderParagraphsLTR", pBiDiMarshal, pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} reorderingMode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setReorderingMode(pBiDi, reorderingMode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ubidi_setReorderingMode", pBiDiMarshal, pBiDi, "int", reorderingMode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getReorderingMode(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getReorderingMode", pBiDiMarshal, pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} reorderingOptions 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setReorderingOptions(pBiDi, reorderingOptions) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ubidi_setReorderingOptions", pBiDiMarshal, pBiDi, "uint", reorderingOptions, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getReorderingOptions(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getReorderingOptions", pBiDiMarshal, pBiDi, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Integer>} prologue 
     * @param {Integer} proLength 
     * @param {Pointer<Integer>} epilogue 
     * @param {Integer} epiLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setContext(pBiDi, prologue, proLength, epilogue, epiLength, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        prologueMarshal := prologue is VarRef ? "ushort*" : "ptr"
        epilogueMarshal := epilogue is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_setContext", pBiDiMarshal, pBiDi, prologueMarshal, prologue, "int", proLength, epilogueMarshal, epilogue, "int", epiLength, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Integer>} text 
     * @param {Integer} length 
     * @param {Integer} paraLevel 
     * @param {Pointer<Integer>} embeddingLevels 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setPara(pBiDi, text, length, paraLevel, embeddingLevels, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        embeddingLevelsMarshal := embeddingLevels is VarRef ? "char*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_setPara", pBiDiMarshal, pBiDi, textMarshal, text, "int", length, "char", paraLevel, embeddingLevelsMarshal, embeddingLevels, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pParaBiDi 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<UBiDi>} pLineBiDi 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setLine(pParaBiDi, start, limit, pLineBiDi, pErrorCode) {
        pParaBiDiMarshal := pParaBiDi is VarRef ? "ptr*" : "ptr"
        pLineBiDiMarshal := pLineBiDi is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_setLine", pParaBiDiMarshal, pParaBiDi, "int", start, "int", limit, pLineBiDiMarshal, pLineBiDi, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getDirection(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getDirection", pBiDiMarshal, pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} text 
     * @param {Integer} length 
     * @returns {Integer} 
     */
    static ubidi_getBaseDirection(text, length) {
        textMarshal := text is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getBaseDirection", textMarshal, text, "int", length, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Pointer<Integer>} 
     */
    static ubidi_getText(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getText", pBiDiMarshal, pBiDi, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getLength(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getLength", pBiDiMarshal, pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getParaLevel(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getParaLevel", pBiDiMarshal, pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_countParagraphs(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_countParagraphs", pBiDiMarshal, pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} charIndex 
     * @param {Pointer<Integer>} pParaStart 
     * @param {Pointer<Integer>} pParaLimit 
     * @param {Pointer<Integer>} pParaLevel 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getParagraph(pBiDi, charIndex, pParaStart, pParaLimit, pParaLevel, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        pParaStartMarshal := pParaStart is VarRef ? "int*" : "ptr"
        pParaLimitMarshal := pParaLimit is VarRef ? "int*" : "ptr"
        pParaLevelMarshal := pParaLevel is VarRef ? "char*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getParagraph", pBiDiMarshal, pBiDi, "int", charIndex, pParaStartMarshal, pParaStart, pParaLimitMarshal, pParaLimit, pParaLevelMarshal, pParaLevel, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} paraIndex 
     * @param {Pointer<Integer>} pParaStart 
     * @param {Pointer<Integer>} pParaLimit 
     * @param {Pointer<Integer>} pParaLevel 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getParagraphByIndex(pBiDi, paraIndex, pParaStart, pParaLimit, pParaLevel, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        pParaStartMarshal := pParaStart is VarRef ? "int*" : "ptr"
        pParaLimitMarshal := pParaLimit is VarRef ? "int*" : "ptr"
        pParaLevelMarshal := pParaLevel is VarRef ? "char*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_getParagraphByIndex", pBiDiMarshal, pBiDi, "int", paraIndex, pParaStartMarshal, pParaStart, pParaLimitMarshal, pParaLimit, pParaLevelMarshal, pParaLevel, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} charIndex 
     * @returns {Integer} 
     */
    static ubidi_getLevelAt(pBiDi, charIndex) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getLevelAt", pBiDiMarshal, pBiDi, "int", charIndex, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static ubidi_getLevels(pBiDi, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getLevels", pBiDiMarshal, pBiDi, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} logicalPosition 
     * @param {Pointer<Integer>} pLogicalLimit 
     * @param {Pointer<Integer>} pLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getLogicalRun(pBiDi, logicalPosition, pLogicalLimit, pLevel) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        pLogicalLimitMarshal := pLogicalLimit is VarRef ? "int*" : "ptr"
        pLevelMarshal := pLevel is VarRef ? "char*" : "ptr"

        DllCall("icuuc.dll\ubidi_getLogicalRun", pBiDiMarshal, pBiDi, "int", logicalPosition, pLogicalLimitMarshal, pLogicalLimit, pLevelMarshal, pLevel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_countRuns(pBiDi, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_countRuns", pBiDiMarshal, pBiDi, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} runIndex 
     * @param {Pointer<Integer>} pLogicalStart 
     * @param {Pointer<Integer>} pLength 
     * @returns {Integer} 
     */
    static ubidi_getVisualRun(pBiDi, runIndex, pLogicalStart, pLength) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        pLogicalStartMarshal := pLogicalStart is VarRef ? "int*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getVisualRun", pBiDiMarshal, pBiDi, "int", runIndex, pLogicalStartMarshal, pLogicalStart, pLengthMarshal, pLength, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} logicalIndex 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getVisualIndex(pBiDi, logicalIndex, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getVisualIndex", pBiDiMarshal, pBiDi, "int", logicalIndex, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} visualIndex 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getLogicalIndex(pBiDi, visualIndex, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getLogicalIndex", pBiDiMarshal, pBiDi, "int", visualIndex, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Integer>} indexMap 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getLogicalMap(pBiDi, indexMap, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        indexMapMarshal := indexMap is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_getLogicalMap", pBiDiMarshal, pBiDi, indexMapMarshal, indexMap, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Integer>} indexMap 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getVisualMap(pBiDi, indexMap, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        indexMapMarshal := indexMap is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_getVisualMap", pBiDiMarshal, pBiDi, indexMapMarshal, indexMap, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} levels 
     * @param {Integer} length 
     * @param {Pointer<Integer>} indexMap 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_reorderLogical(levels, length, indexMap) {
        levelsMarshal := levels is VarRef ? "char*" : "ptr"
        indexMapMarshal := indexMap is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_reorderLogical", levelsMarshal, levels, "int", length, indexMapMarshal, indexMap, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} levels 
     * @param {Integer} length 
     * @param {Pointer<Integer>} indexMap 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_reorderVisual(levels, length, indexMap) {
        levelsMarshal := levels is VarRef ? "char*" : "ptr"
        indexMapMarshal := indexMap is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_reorderVisual", levelsMarshal, levels, "int", length, indexMapMarshal, indexMap, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} srcMap 
     * @param {Pointer<Integer>} destMap 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_invertMap(srcMap, destMap, length) {
        srcMapMarshal := srcMap is VarRef ? "int*" : "ptr"
        destMapMarshal := destMap is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_invertMap", srcMapMarshal, srcMap, destMapMarshal, destMap, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getProcessedLength(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getProcessedLength", pBiDiMarshal, pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getResultLength(pBiDi) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getResultLength", pBiDiMarshal, pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ubidi_getCustomizedClass(pBiDi, c) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_getCustomizedClass", pBiDiMarshal, pBiDi, "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<UBiDiClassCallback>} newFn 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<Pointer<UBiDiClassCallback>>} oldFn 
     * @param {Pointer<Pointer<Void>>} oldContext 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setClassCallback(pBiDi, newFn, newContext, oldFn, oldContext, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        newContextMarshal := newContext is VarRef ? "ptr" : "ptr"
        oldFnMarshal := oldFn is VarRef ? "ptr*" : "ptr"
        oldContextMarshal := oldContext is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubidi_setClassCallback", pBiDiMarshal, pBiDi, "ptr", newFn, newContextMarshal, newContext, oldFnMarshal, oldFn, oldContextMarshal, oldContext, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Pointer<UBiDiClassCallback>>} fn 
     * @param {Pointer<Pointer<Void>>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getClassCallback(pBiDi, fn, context) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        fnMarshal := fn is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ubidi_getClassCallback", pBiDiMarshal, pBiDi, fnMarshal, fn, contextMarshal, context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_writeReordered(pBiDi, dest, destSize, options, pErrorCode) {
        pBiDiMarshal := pBiDi is VarRef ? "ptr*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_writeReordered", pBiDiMarshal, pBiDi, destMarshal, dest, "int", destSize, "ushort", options, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_writeReverse(src, srcLength, dest, destSize, options, pErrorCode) {
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubidi_writeReverse", srcMarshal, src, "int", srcLength, destMarshal, dest, "int", destSize, "ushort", options, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDiTransform>} pBiDiTransform 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destSize 
     * @param {Integer} inParaLevel 
     * @param {Integer} inOrder 
     * @param {Integer} outParaLevel 
     * @param {Integer} outOrder 
     * @param {Integer} doMirroring 
     * @param {Integer} shapingOptions 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ubiditransform_transform(pBiDiTransform, src, srcLength, dest, destSize, inParaLevel, inOrder, outParaLevel, outOrder, doMirroring, shapingOptions, pErrorCode) {
        pBiDiTransformMarshal := pBiDiTransform is VarRef ? "ptr*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubiditransform_transform", pBiDiTransformMarshal, pBiDiTransform, srcMarshal, src, "int", srcLength, destMarshal, dest, "int", destSize, "char", inParaLevel, "int", inOrder, "char", outParaLevel, "int", outOrder, "int", doMirroring, "uint", shapingOptions, pErrorCodeMarshal, pErrorCode, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UBiDiTransform>} 
     */
    static ubiditransform_open(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubiditransform_open", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDiTransform>} pBidiTransform 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubiditransform_close(pBidiTransform) {
        pBidiTransformMarshal := pBidiTransform is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ubiditransform_close", pBidiTransformMarshal, pBidiTransform, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Pointer<UText>} 
     */
    static utext_close(ut) {
        result := DllCall("icuuc.dll\utext_close", "ptr", ut, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static utext_openUTF8(ut, s, length, status) {
        s := s is String ? StrPtr(s) : s

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\utext_openUTF8", "ptr", ut, "ptr", s, "int64", length, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static utext_openUChars(ut, s, length, status) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\utext_openUChars", "ptr", ut, sMarshal, s, "int64", length, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<UText>} src 
     * @param {Integer} deep 
     * @param {Integer} readOnly 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static utext_clone(dest, src, deep, readOnly, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\utext_clone", "ptr", dest, "ptr", src, "char", deep, "char", readOnly, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} a 
     * @param {Pointer<UText>} b 
     * @returns {Integer} 
     */
    static utext_equals(a, b) {
        result := DllCall("icuuc.dll\utext_equals", "ptr", a, "ptr", b, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_nativeLength(ut) {
        result := DllCall("icuuc.dll\utext_nativeLength", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_isLengthExpensive(ut) {
        result := DllCall("icuuc.dll\utext_isLengthExpensive", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_char32At(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_char32At", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_current32(ut) {
        result := DllCall("icuuc.dll\utext_current32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_next32(ut) {
        result := DllCall("icuuc.dll\utext_next32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_previous32(ut) {
        result := DllCall("icuuc.dll\utext_previous32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_next32From(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_next32From", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_previous32From(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_previous32From", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_getNativeIndex(ut) {
        result := DllCall("icuuc.dll\utext_getNativeIndex", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_setNativeIndex(ut, nativeIndex) {
        DllCall("icuuc.dll\utext_setNativeIndex", "ptr", ut, "int64", nativeIndex, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} delta 
     * @returns {Integer} 
     */
    static utext_moveIndex32(ut, delta) {
        result := DllCall("icuuc.dll\utext_moveIndex32", "ptr", ut, "int", delta, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_getPreviousNativeIndex(ut) {
        result := DllCall("icuuc.dll\utext_getPreviousNativeIndex", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static utext_extract(ut, nativeStart, nativeLimit, dest, destCapacity, status) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\utext_extract", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, destMarshal, dest, "int", destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_isWritable(ut) {
        result := DllCall("icuuc.dll\utext_isWritable", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_hasMetaData(ut) {
        result := DllCall("icuuc.dll\utext_hasMetaData", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Pointer<Integer>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static utext_replace(ut, nativeStart, nativeLimit, replacementText, replacementLength, status) {
        replacementTextMarshal := replacementText is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\utext_replace", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, replacementTextMarshal, replacementText, "int", replacementLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Integer} destIndex 
     * @param {Integer} move 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_copy(ut, nativeStart, nativeLimit, destIndex, move, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\utext_copy", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, "int64", destIndex, "char", move, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_freeze(ut) {
        DllCall("icuuc.dll\utext_freeze", "ptr", ut, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} extraSpace 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static utext_setup(ut, extraSpace, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\utext_setup", "ptr", ut, "int", extraSpace, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Pointer<USet>} 
     */
    static uset_openEmpty() {
        result := DllCall("icuuc.dll\uset_openEmpty", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {Pointer<USet>} 
     */
    static uset_open(start, end) {
        result := DllCall("icuuc.dll\uset_open", "int", start, "int", end, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<USet>} 
     */
    static uset_openPattern(pattern, patternLength, ec) {
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uset_openPattern", patternMarshal, pattern, "int", patternLength, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} options 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<USet>} 
     */
    static uset_openPatternOptions(pattern, patternLength, options, ec) {
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uset_openPatternOptions", patternMarshal, pattern, "int", patternLength, "uint", options, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_close(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_close", setMarshal, set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Pointer<USet>} 
     */
    static uset_clone(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_clone", setMarshal, set, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_isFrozen(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_isFrozen", setMarshal, set, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_freeze(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_freeze", setMarshal, set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Pointer<USet>} 
     */
    static uset_cloneAsThawed(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_cloneAsThawed", setMarshal, set, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_set(set, start, end) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_set", setMarshal, set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} options 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uset_applyPattern(set, pattern, patternLength, options, status) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uset_applyPattern", setMarshal, set, patternMarshal, pattern, "int", patternLength, "uint", options, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} prop 
     * @param {Integer} value 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_applyIntPropertyValue(set, prop, value, ec) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\uset_applyIntPropertyValue", setMarshal, set, "int", prop, "int", value, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} prop 
     * @param {Integer} propLength 
     * @param {Pointer<Integer>} value 
     * @param {Integer} valueLength 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_applyPropertyAlias(set, prop, propLength, value, valueLength, ec) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        propMarshal := prop is VarRef ? "ushort*" : "ptr"
        valueMarshal := value is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\uset_applyPropertyAlias", setMarshal, set, propMarshal, prop, "int", propLength, valueMarshal, value, "int", valueLength, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} pos 
     * @returns {Integer} 
     */
    static uset_resemblesPattern(pattern, patternLength, pos) {
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\uset_resemblesPattern", patternMarshal, pattern, "int", patternLength, "int", pos, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Integer} escapeUnprintable 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static uset_toPattern(set, result, resultCapacity, escapeUnprintable, ec) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uset_toPattern", setMarshal, set, resultMarshal, result, "int", resultCapacity, "char", escapeUnprintable, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_add(set, c) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_add", setMarshal, set, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<USet>} additionalSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addAll(set, additionalSet) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        additionalSetMarshal := additionalSet is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_addAll", setMarshal, set, additionalSetMarshal, additionalSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addRange(set, start, end) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_addRange", setMarshal, set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addString(set, str, strLen) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        DllCall("icuuc.dll\uset_addString", setMarshal, set, strMarshal, str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addAllCodePoints(set, str, strLen) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        DllCall("icuuc.dll\uset_addAllCodePoints", setMarshal, set, strMarshal, str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_remove(set, c) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_remove", setMarshal, set, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeRange(set, start, end) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_removeRange", setMarshal, set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeString(set, str, strLen) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        DllCall("icuuc.dll\uset_removeString", setMarshal, set, strMarshal, str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeAllCodePoints(set, str, length) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        DllCall("icu.dll\uset_removeAllCodePoints", setMarshal, set, strMarshal, str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<USet>} removeSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeAll(set, removeSet) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        removeSetMarshal := removeSet is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_removeAll", setMarshal, set, removeSetMarshal, removeSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retain(set, start, end) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_retain", setMarshal, set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retainString(set, str, length) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        DllCall("icu.dll\uset_retainString", setMarshal, set, strMarshal, str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retainAllCodePoints(set, str, length) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        DllCall("icu.dll\uset_retainAllCodePoints", setMarshal, set, strMarshal, str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<USet>} retain 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retainAll(set, retain) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        retainMarshal := retain is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_retainAll", setMarshal, set, retainMarshal, retain, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_compact(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_compact", setMarshal, set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complement(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_complement", setMarshal, set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementRange(set, start, end) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\uset_complementRange", setMarshal, set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementString(set, str, length) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        DllCall("icu.dll\uset_complementString", setMarshal, set, strMarshal, str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementAllCodePoints(set, str, length) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        DllCall("icu.dll\uset_complementAllCodePoints", setMarshal, set, strMarshal, str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<USet>} complement 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementAll(set, complement) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        complementMarshal := complement is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_complementAll", setMarshal, set, complementMarshal, complement, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_clear(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_clear", setMarshal, set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} attributes 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_closeOver(set, attributes) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_closeOver", setMarshal, set, "int", attributes, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeAllStrings(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uset_removeAllStrings", setMarshal, set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_isEmpty(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_isEmpty", setMarshal, set, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_hasStrings(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icu.dll\uset_hasStrings", setMarshal, set, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_contains(set, c) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_contains", setMarshal, set, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {Integer} 
     */
    static uset_containsRange(set, start, end) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_containsRange", setMarshal, set, "int", start, "int", end, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} strLen 
     * @returns {Integer} 
     */
    static uset_containsString(set, str, strLen) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\uset_containsString", setMarshal, set, strMarshal, str, "int", strLen, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_indexOf(set, c) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_indexOf", setMarshal, set, "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} charIndex 
     * @returns {Integer} 
     */
    static uset_charAt(set, charIndex) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_charAt", setMarshal, set, "int", charIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_size(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_size", setMarshal, set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_getRangeCount(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icu.dll\uset_getRangeCount", setMarshal, set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_getItemCount(set) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_getItemCount", setMarshal, set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} itemIndex 
     * @param {Pointer<Integer>} start 
     * @param {Pointer<Integer>} end 
     * @param {Pointer<Integer>} str 
     * @param {Integer} strCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static uset_getItem(set, itemIndex, start, end, str, strCapacity, ec) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        startMarshal := start is VarRef ? "int*" : "ptr"
        endMarshal := end is VarRef ? "int*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uset_getItem", setMarshal, set, "int", itemIndex, startMarshal, start, endMarshal, end, strMarshal, str, "int", strCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set1 
     * @param {Pointer<USet>} set2 
     * @returns {Integer} 
     */
    static uset_containsAll(set1, set2) {
        set1Marshal := set1 is VarRef ? "ptr*" : "ptr"
        set2Marshal := set2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_containsAll", set1Marshal, set1, set2Marshal, set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} str 
     * @param {Integer} strLen 
     * @returns {Integer} 
     */
    static uset_containsAllCodePoints(set, str, strLen) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        strMarshal := str is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\uset_containsAllCodePoints", setMarshal, set, strMarshal, str, "int", strLen, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set1 
     * @param {Pointer<USet>} set2 
     * @returns {Integer} 
     */
    static uset_containsNone(set1, set2) {
        set1Marshal := set1 is VarRef ? "ptr*" : "ptr"
        set2Marshal := set2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_containsNone", set1Marshal, set1, set2Marshal, set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set1 
     * @param {Pointer<USet>} set2 
     * @returns {Integer} 
     */
    static uset_containsSome(set1, set2) {
        set1Marshal := set1 is VarRef ? "ptr*" : "ptr"
        set2Marshal := set2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_containsSome", set1Marshal, set1, set2Marshal, set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_span(set, s, length, spanCondition) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\uset_span", setMarshal, set, sMarshal, s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanBack(set, s, length, spanCondition) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\uset_spanBack", setMarshal, set, sMarshal, s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanUTF8(set, s, length, spanCondition) {
        s := s is String ? StrPtr(s) : s

        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_spanUTF8", setMarshal, set, "ptr", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanBackUTF8(set, s, length, spanCondition) {
        s := s is String ? StrPtr(s) : s

        setMarshal := set is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_spanBackUTF8", setMarshal, set, "ptr", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set1 
     * @param {Pointer<USet>} set2 
     * @returns {Integer} 
     */
    static uset_equals(set1, set2) {
        set1Marshal := set1 is VarRef ? "ptr*" : "ptr"
        set2Marshal := set2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\uset_equals", set1Marshal, set1, set2Marshal, set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uset_serialize(set, dest, destCapacity, pErrorCode) {
        setMarshal := set is VarRef ? "ptr*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uset_serialize", setMarshal, set, destMarshal, dest, "int", destCapacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} fillSet 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @returns {Integer} 
     */
    static uset_getSerializedSet(fillSet, src, srcLength) {
        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\uset_getSerializedSet", "ptr", fillSet, srcMarshal, src, "int", srcLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} fillSet 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_setSerializedToOne(fillSet, c) {
        DllCall("icuuc.dll\uset_setSerializedToOne", "ptr", fillSet, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_serializedContains(set, c) {
        result := DllCall("icuuc.dll\uset_serializedContains", "ptr", set, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @returns {Integer} 
     */
    static uset_getSerializedRangeCount(set) {
        result := DllCall("icuuc.dll\uset_getSerializedRangeCount", "ptr", set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @param {Integer} rangeIndex 
     * @param {Pointer<Integer>} pStart 
     * @param {Pointer<Integer>} pEnd 
     * @returns {Integer} 
     */
    static uset_getSerializedRange(set, rangeIndex, pStart, pEnd) {
        pStartMarshal := pStart is VarRef ? "int*" : "ptr"
        pEndMarshal := pEnd is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uset_getSerializedRange", "ptr", set, "int", rangeIndex, pStartMarshal, pStart, pEndMarshal, pEnd, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFCInstance(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getNFCInstance", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFDInstance(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getNFDInstance", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFKCInstance(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getNFKCInstance", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFKDInstance(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getNFKDInstance", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFKCCasefoldInstance(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getNFKCCasefoldInstance", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {PSTR} name 
     * @param {Integer} mode 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getInstance(packageName, name, mode, pErrorCode) {
        packageName := packageName is String ? StrPtr(packageName) : packageName
        name := name is String ? StrPtr(name) : name

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getInstance", "ptr", packageName, "ptr", name, "int", mode, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<USet>} filterSet 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_openFiltered(norm2, filterSet, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        filterSetMarshal := filterSet is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_openFiltered", norm2Marshal, norm2, filterSetMarshal, filterSet, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @returns {String} Nothing - always returns an empty string
     */
    static unorm2_close(norm2) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\unorm2_close", norm2Marshal, norm2, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<Integer>} src 
     * @param {Integer} length 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_normalize(norm2, src, length, dest, capacity, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_normalize", norm2Marshal, norm2, srcMarshal, src, "int", length, destMarshal, dest, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<Integer>} first 
     * @param {Integer} firstLength 
     * @param {Integer} firstCapacity 
     * @param {Pointer<Integer>} second 
     * @param {Integer} secondLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_normalizeSecondAndAppend(norm2, first, firstLength, firstCapacity, second, secondLength, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        firstMarshal := first is VarRef ? "ushort*" : "ptr"
        secondMarshal := second is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_normalizeSecondAndAppend", norm2Marshal, norm2, firstMarshal, first, "int", firstLength, "int", firstCapacity, secondMarshal, second, "int", secondLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<Integer>} first 
     * @param {Integer} firstLength 
     * @param {Integer} firstCapacity 
     * @param {Pointer<Integer>} second 
     * @param {Integer} secondLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_append(norm2, first, firstLength, firstCapacity, second, secondLength, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        firstMarshal := first is VarRef ? "ushort*" : "ptr"
        secondMarshal := second is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_append", norm2Marshal, norm2, firstMarshal, first, "int", firstLength, "int", firstCapacity, secondMarshal, second, "int", secondLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @param {Pointer<Integer>} decomposition 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_getDecomposition(norm2, c, decomposition, capacity, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        decompositionMarshal := decomposition is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getDecomposition", norm2Marshal, norm2, "int", c, decompositionMarshal, decomposition, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @param {Pointer<Integer>} decomposition 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_getRawDecomposition(norm2, c, decomposition, capacity, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        decompositionMarshal := decomposition is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getRawDecomposition", norm2Marshal, norm2, "int", c, decompositionMarshal, decomposition, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} a 
     * @param {Integer} b 
     * @returns {Integer} 
     */
    static unorm2_composePair(norm2, a, b) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_composePair", norm2Marshal, norm2, "int", a, "int", b, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_getCombiningClass(norm2, c) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_getCombiningClass", norm2Marshal, norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_isNormalized(norm2, s, length, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_isNormalized", norm2Marshal, norm2, sMarshal, s, "int", length, pErrorCodeMarshal, pErrorCode, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_quickCheck(norm2, s, length, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_quickCheck", norm2Marshal, norm2, sMarshal, s, "int", length, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_spanQuickCheckYes(norm2, s, length, pErrorCode) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_spanQuickCheckYes", norm2Marshal, norm2, sMarshal, s, "int", length, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_hasBoundaryBefore(norm2, c) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_hasBoundaryBefore", norm2Marshal, norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_hasBoundaryAfter(norm2, c) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_hasBoundaryAfter", norm2Marshal, norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_isInert(norm2, c) {
        norm2Marshal := norm2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\unorm2_isInert", norm2Marshal, norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Integer} length1 
     * @param {Pointer<Integer>} s2 
     * @param {Integer} length2 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm_compare(s1, length1, s2, length2, options, pErrorCode) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\unorm_compare", s1Marshal, s1, "int", length1, s2Marshal, s2, "int", length2, "uint", options, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Integer>>} converterList 
     * @param {Integer} converterListSize 
     * @param {Pointer<USet>} excludedCodePoints 
     * @param {Integer} whichSet 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UConverterSelector>} 
     */
    static ucnvsel_open(converterList, converterListSize, excludedCodePoints, whichSet, status) {
        converterListMarshal := converterList is VarRef ? "ptr*" : "ptr"
        excludedCodePointsMarshal := excludedCodePoints is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnvsel_open", converterListMarshal, converterList, "int", converterListSize, excludedCodePointsMarshal, excludedCodePoints, "int", whichSet, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterSelector>} sel 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnvsel_close(sel) {
        selMarshal := sel is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucnvsel_close", selMarshal, sel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} buffer_R 
     * @param {Integer} length 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UConverterSelector>} 
     */
    static ucnvsel_openFromSerialized(buffer_R, length, status) {
        buffer_RMarshal := buffer_R is VarRef ? "ptr" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnvsel_openFromSerialized", buffer_RMarshal, buffer_R, "int", length, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterSelector>} sel 
     * @param {Pointer<Void>} buffer_R 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucnvsel_serialize(sel, buffer_R, bufferCapacity, status) {
        selMarshal := sel is VarRef ? "ptr*" : "ptr"
        buffer_RMarshal := buffer_R is VarRef ? "ptr" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnvsel_serialize", selMarshal, sel, buffer_RMarshal, buffer_R, "int", bufferCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterSelector>} sel 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucnvsel_selectForString(sel, s, length, status) {
        selMarshal := sel is VarRef ? "ptr*" : "ptr"
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnvsel_selectForString", selMarshal, sel, sMarshal, s, "int", length, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterSelector>} sel 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucnvsel_selectForUTF8(sel, s, length, status) {
        s := s is String ? StrPtr(s) : s

        selMarshal := sel is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucnvsel_selectForUTF8", selMarshal, sel, "ptr", s, "int", length, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} cs 
     * @param {Pointer<Integer>} us 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_charsToUChars(cs, us, length) {
        cs := cs is String ? StrPtr(cs) : cs

        usMarshal := us is VarRef ? "ushort*" : "ptr"

        DllCall("icuuc.dll\u_charsToUChars", "ptr", cs, usMarshal, us, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} us 
     * @param {PSTR} cs 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_UCharsToChars(us, cs, length) {
        cs := cs is String ? StrPtr(cs) : cs

        usMarshal := us is VarRef ? "ushort*" : "ptr"

        DllCall("icuuc.dll\u_UCharsToChars", usMarshal, us, "ptr", cs, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @returns {Integer} 
     */
    static u_strlen(s) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strlen", sMarshal, s, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @returns {Integer} 
     */
    static u_countChar32(s, length) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_countChar32", sMarshal, s, "int", length, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Integer} number_R 
     * @returns {Integer} 
     */
    static u_strHasMoreChar32Than(s, length, number_R) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strHasMoreChar32Than", sMarshal, s, "int", length, "int", number_R, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dst 
     * @param {Pointer<Integer>} src 
     * @returns {Pointer<Integer>} 
     */
    static u_strcat(dst, src) {
        dstMarshal := dst is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strcat", dstMarshal, dst, srcMarshal, src, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dst 
     * @param {Pointer<Integer>} src 
     * @param {Integer} n 
     * @returns {Pointer<Integer>} 
     */
    static u_strncat(dst, src, n) {
        dstMarshal := dst is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strncat", dstMarshal, dst, srcMarshal, src, "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Pointer<Integer>} substring 
     * @returns {Pointer<Integer>} 
     */
    static u_strstr(s, substring) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        substringMarshal := substring is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strstr", sMarshal, s, substringMarshal, substring, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} substring 
     * @param {Integer} subLength 
     * @returns {Pointer<Integer>} 
     */
    static u_strFindFirst(s, length, substring, subLength) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        substringMarshal := substring is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strFindFirst", sMarshal, s, "int", length, substringMarshal, substring, "int", subLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} c 
     * @returns {Pointer<Integer>} 
     */
    static u_strchr(s, c) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strchr", sMarshal, s, "ushort", c, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} c 
     * @returns {Pointer<Integer>} 
     */
    static u_strchr32(s, c) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strchr32", sMarshal, s, "int", c, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Pointer<Integer>} substring 
     * @returns {Pointer<Integer>} 
     */
    static u_strrstr(s, substring) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        substringMarshal := substring is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strrstr", sMarshal, s, substringMarshal, substring, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} length 
     * @param {Pointer<Integer>} substring 
     * @param {Integer} subLength 
     * @returns {Pointer<Integer>} 
     */
    static u_strFindLast(s, length, substring, subLength) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"
        substringMarshal := substring is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strFindLast", sMarshal, s, "int", length, substringMarshal, substring, "int", subLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} c 
     * @returns {Pointer<Integer>} 
     */
    static u_strrchr(s, c) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strrchr", sMarshal, s, "ushort", c, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} c 
     * @returns {Pointer<Integer>} 
     */
    static u_strrchr32(s, c) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strrchr32", sMarshal, s, "int", c, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} string_R 
     * @param {Pointer<Integer>} matchSet 
     * @returns {Pointer<Integer>} 
     */
    static u_strpbrk(string_R, matchSet) {
        string_RMarshal := string_R is VarRef ? "ushort*" : "ptr"
        matchSetMarshal := matchSet is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strpbrk", string_RMarshal, string_R, matchSetMarshal, matchSet, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} string_R 
     * @param {Pointer<Integer>} matchSet 
     * @returns {Integer} 
     */
    static u_strcspn(string_R, matchSet) {
        string_RMarshal := string_R is VarRef ? "ushort*" : "ptr"
        matchSetMarshal := matchSet is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strcspn", string_RMarshal, string_R, matchSetMarshal, matchSet, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} string_R 
     * @param {Pointer<Integer>} matchSet 
     * @returns {Integer} 
     */
    static u_strspn(string_R, matchSet) {
        string_RMarshal := string_R is VarRef ? "ushort*" : "ptr"
        matchSetMarshal := matchSet is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strspn", string_RMarshal, string_R, matchSetMarshal, matchSet, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} src 
     * @param {Pointer<Integer>} delim 
     * @param {Pointer<Pointer<Integer>>} saveState 
     * @returns {Pointer<Integer>} 
     */
    static u_strtok_r(src, delim, saveState) {
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        delimMarshal := delim is VarRef ? "ushort*" : "ptr"
        saveStateMarshal := saveState is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\u_strtok_r", srcMarshal, src, delimMarshal, delim, saveStateMarshal, saveState, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Pointer<Integer>} s2 
     * @returns {Integer} 
     */
    static u_strcmp(s1, s2) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strcmp", s1Marshal, s1, s2Marshal, s2, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Pointer<Integer>} s2 
     * @returns {Integer} 
     */
    static u_strcmpCodePointOrder(s1, s2) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strcmpCodePointOrder", s1Marshal, s1, s2Marshal, s2, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Integer} length1 
     * @param {Pointer<Integer>} s2 
     * @param {Integer} length2 
     * @param {Integer} codePointOrder 
     * @returns {Integer} 
     */
    static u_strCompare(s1, length1, s2, length2, codePointOrder) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strCompare", s1Marshal, s1, "int", length1, s2Marshal, s2, "int", length2, "char", codePointOrder, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter1 
     * @param {Pointer<UCharIterator>} iter2 
     * @param {Integer} codePointOrder 
     * @returns {Integer} 
     */
    static u_strCompareIter(iter1, iter2, codePointOrder) {
        result := DllCall("icuuc.dll\u_strCompareIter", "ptr", iter1, "ptr", iter2, "char", codePointOrder, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Integer} length1 
     * @param {Pointer<Integer>} s2 
     * @param {Integer} length2 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strCaseCompare(s1, length1, s2, length2, options, pErrorCode) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strCaseCompare", s1Marshal, s1, "int", length1, s2Marshal, s2, "int", length2, "uint", options, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} ucs1 
     * @param {Pointer<Integer>} ucs2 
     * @param {Integer} n 
     * @returns {Integer} 
     */
    static u_strncmp(ucs1, ucs2, n) {
        ucs1Marshal := ucs1 is VarRef ? "ushort*" : "ptr"
        ucs2Marshal := ucs2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strncmp", ucs1Marshal, ucs1, ucs2Marshal, ucs2, "int", n, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Pointer<Integer>} s2 
     * @param {Integer} n 
     * @returns {Integer} 
     */
    static u_strncmpCodePointOrder(s1, s2, n) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strncmpCodePointOrder", s1Marshal, s1, s2Marshal, s2, "int", n, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Pointer<Integer>} s2 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_strcasecmp(s1, s2, options) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strcasecmp", s1Marshal, s1, s2Marshal, s2, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Pointer<Integer>} s2 
     * @param {Integer} n 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_strncasecmp(s1, s2, n, options) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strncasecmp", s1Marshal, s1, s2Marshal, s2, "int", n, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Pointer<Integer>} s2 
     * @param {Integer} length 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_memcasecmp(s1, s2, length, options) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memcasecmp", s1Marshal, s1, s2Marshal, s2, "int", length, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dst 
     * @param {Pointer<Integer>} src 
     * @returns {Pointer<Integer>} 
     */
    static u_strcpy(dst, src) {
        dstMarshal := dst is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strcpy", dstMarshal, dst, srcMarshal, src, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dst 
     * @param {Pointer<Integer>} src 
     * @param {Integer} n 
     * @returns {Pointer<Integer>} 
     */
    static u_strncpy(dst, src, n) {
        dstMarshal := dst is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_strncpy", dstMarshal, dst, srcMarshal, src, "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dst 
     * @param {PSTR} src 
     * @returns {Pointer<Integer>} 
     */
    static u_uastrcpy(dst, src) {
        src := src is String ? StrPtr(src) : src

        dstMarshal := dst is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_uastrcpy", dstMarshal, dst, "ptr", src, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dst 
     * @param {PSTR} src 
     * @param {Integer} n 
     * @returns {Pointer<Integer>} 
     */
    static u_uastrncpy(dst, src, n) {
        src := src is String ? StrPtr(src) : src

        dstMarshal := dst is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_uastrncpy", dstMarshal, dst, "ptr", src, "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} dst 
     * @param {Pointer<Integer>} src 
     * @returns {PSTR} 
     */
    static u_austrcpy(dst, src) {
        dst := dst is String ? StrPtr(dst) : dst

        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_austrcpy", "ptr", dst, srcMarshal, src, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} dst 
     * @param {Pointer<Integer>} src 
     * @param {Integer} n 
     * @returns {PSTR} 
     */
    static u_austrncpy(dst, src, n) {
        dst := dst is String ? StrPtr(dst) : dst

        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_austrncpy", "ptr", dst, srcMarshal, src, "int", n, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Pointer<Integer>} src 
     * @param {Integer} count 
     * @returns {Pointer<Integer>} 
     */
    static u_memcpy(dest, src, count) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memcpy", destMarshal, dest, srcMarshal, src, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Pointer<Integer>} src 
     * @param {Integer} count 
     * @returns {Pointer<Integer>} 
     */
    static u_memmove(dest, src, count) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memmove", destMarshal, dest, srcMarshal, src, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<Integer>} 
     */
    static u_memset(dest, c, count) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memset", destMarshal, dest, "ushort", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} buf1 
     * @param {Pointer<Integer>} buf2 
     * @param {Integer} count 
     * @returns {Integer} 
     */
    static u_memcmp(buf1, buf2, count) {
        buf1Marshal := buf1 is VarRef ? "ushort*" : "ptr"
        buf2Marshal := buf2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memcmp", buf1Marshal, buf1, buf2Marshal, buf2, "int", count, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s1 
     * @param {Pointer<Integer>} s2 
     * @param {Integer} count 
     * @returns {Integer} 
     */
    static u_memcmpCodePointOrder(s1, s2, count) {
        s1Marshal := s1 is VarRef ? "ushort*" : "ptr"
        s2Marshal := s2 is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memcmpCodePointOrder", s1Marshal, s1, s2Marshal, s2, "int", count, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<Integer>} 
     */
    static u_memchr(s, c, count) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memchr", sMarshal, s, "ushort", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<Integer>} 
     */
    static u_memchr32(s, c, count) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memchr32", sMarshal, s, "int", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<Integer>} 
     */
    static u_memrchr(s, c, count) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memrchr", sMarshal, s, "ushort", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<Integer>} 
     */
    static u_memrchr32(s, c, count) {
        sMarshal := s is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_memrchr32", sMarshal, s, "int", c, "int", count, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} src 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @returns {Integer} 
     */
    static u_unescape(src, dest, destCapacity) {
        src := src is String ? StrPtr(src) : src

        destMarshal := dest is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuuc.dll\u_unescape", "ptr", src, destMarshal, dest, "int", destCapacity, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNESCAPE_CHAR_AT>} charAt 
     * @param {Pointer<Integer>} offset 
     * @param {Integer} length 
     * @param {Pointer<Void>} context 
     * @returns {Integer} 
     */
    static u_unescapeAt(charAt, offset, length, context) {
        offsetMarshal := offset is VarRef ? "int*" : "ptr"
        contextMarshal := context is VarRef ? "ptr" : "ptr"

        result := DllCall("icuuc.dll\u_unescapeAt", "ptr", charAt, offsetMarshal, offset, "int", length, contextMarshal, context, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToUpper(dest, destCapacity, src, srcLength, locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToUpper", destMarshal, dest, "int", destCapacity, srcMarshal, src, "int", srcLength, "ptr", locale, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToLower(dest, destCapacity, src, srcLength, locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToLower", destMarshal, dest, "int", destCapacity, srcMarshal, src, "int", srcLength, "ptr", locale, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<UBreakIterator>} titleIter 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToTitle(dest, destCapacity, src, srcLength, titleIter, locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        titleIterMarshal := titleIter is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToTitle", destMarshal, dest, "int", destCapacity, srcMarshal, src, "int", srcLength, titleIterMarshal, titleIter, "ptr", locale, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strFoldCase(dest, destCapacity, src, srcLength, options, pErrorCode) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strFoldCase", destMarshal, dest, "int", destCapacity, srcMarshal, src, "int", srcLength, "uint", options, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PWSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PWSTR} 
     */
    static u_strToWCS(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToWCS", "ptr", dest, "int", destCapacity, pDestLengthMarshal, pDestLength, srcMarshal, src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {PWSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strFromWCS(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strFromWCS", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, "ptr", src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PSTR} 
     */
    static u_strToUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToUTF8", "ptr", dest, "int", destCapacity, pDestLengthMarshal, pDestLength, srcMarshal, src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strFromUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strFromUTF8", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, "ptr", src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Integer>} pNumSubstitutions 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PSTR} 
     */
    static u_strToUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pNumSubstitutionsMarshal := pNumSubstitutions is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToUTF8WithSub", "ptr", dest, "int", destCapacity, pDestLengthMarshal, pDestLength, srcMarshal, src, "int", srcLength, "int", subchar, pNumSubstitutionsMarshal, pNumSubstitutions, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Integer>} pNumSubstitutions 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strFromUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        pNumSubstitutionsMarshal := pNumSubstitutions is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strFromUTF8WithSub", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, "ptr", src, "int", srcLength, "int", subchar, pNumSubstitutionsMarshal, pNumSubstitutions, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strFromUTF8Lenient(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strFromUTF8Lenient", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, "ptr", src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strToUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        destMarshal := dest is VarRef ? "int*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToUTF32", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, srcMarshal, src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strFromUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        srcMarshal := src is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strFromUTF32", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, srcMarshal, src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Integer>} pNumSubstitutions 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strToUTF32WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        destMarshal := dest is VarRef ? "int*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pNumSubstitutionsMarshal := pNumSubstitutions is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToUTF32WithSub", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, srcMarshal, src, "int", srcLength, "int", subchar, pNumSubstitutionsMarshal, pNumSubstitutions, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Integer>} pNumSubstitutions 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strFromUTF32WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        srcMarshal := src is VarRef ? "int*" : "ptr"
        pNumSubstitutionsMarshal := pNumSubstitutions is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strFromUTF32WithSub", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, srcMarshal, src, "int", srcLength, "int", subchar, pNumSubstitutionsMarshal, pNumSubstitutions, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {PSTR} 
     */
    static u_strToJavaModifiedUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strToJavaModifiedUTF8", "ptr", dest, "int", destCapacity, pDestLengthMarshal, pDestLength, srcMarshal, src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pDestLength 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Integer>} pNumSubstitutions 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Integer>} 
     */
    static u_strFromJavaModifiedUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pDestLengthMarshal := pDestLength is VarRef ? "int*" : "ptr"
        pNumSubstitutionsMarshal := pNumSubstitutions is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\u_strFromJavaModifiedUTF8WithSub", destMarshal, dest, "int", destCapacity, pDestLengthMarshal, pDestLength, "ptr", src, "int", srcLength, "int", subchar, pNumSubstitutionsMarshal, pNumSubstitutions, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UCaseMap>} 
     */
    static ucasemap_open(locale, options, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_open", "ptr", locale, "uint", options, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_close(csm) {
        csmMarshal := csm is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ucasemap_close", csmMarshal, csm, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @returns {PSTR} 
     */
    static ucasemap_getLocale(csm) {
        csmMarshal := csm is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_getLocale", csmMarshal, csm, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @returns {Integer} 
     */
    static ucasemap_getOptions(csm) {
        csmMarshal := csm is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_getOptions", csmMarshal, csm, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setLocale(csm, locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        csmMarshal := csm is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucasemap_setLocale", csmMarshal, csm, "ptr", locale, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setOptions(csm, options, pErrorCode) {
        csmMarshal := csm is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucasemap_setOptions", csmMarshal, csm, "uint", options, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ucasemap_getBreakIterator(csm) {
        csmMarshal := csm is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_getBreakIterator", csmMarshal, csm, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {Pointer<UBreakIterator>} iterToAdopt 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setBreakIterator(csm, iterToAdopt, pErrorCode) {
        csmMarshal := csm is VarRef ? "ptr*" : "ptr"
        iterToAdoptMarshal := iterToAdopt is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ucasemap_setBreakIterator", csmMarshal, csm, iterToAdoptMarshal, iterToAdopt, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_toTitle(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        csmMarshal := csm is VarRef ? "ptr*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_toTitle", csmMarshal, csm, destMarshal, dest, "int", destCapacity, srcMarshal, src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToLower(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest
        src := src is String ? StrPtr(src) : src

        csmMarshal := csm is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_utf8ToLower", csmMarshal, csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToUpper(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest
        src := src is String ? StrPtr(src) : src

        csmMarshal := csm is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_utf8ToUpper", csmMarshal, csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToTitle(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest
        src := src is String ? StrPtr(src) : src

        csmMarshal := csm is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_utf8ToTitle", csmMarshal, csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8FoldCase(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest
        src := src is String ? StrPtr(src) : src

        csmMarshal := csm is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ucasemap_utf8FoldCase", csmMarshal, csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} path 
     * @param {PSTR} fileName 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UStringPrepProfile>} 
     */
    static usprep_open(path, fileName, status) {
        path := path is String ? StrPtr(path) : path
        fileName := fileName is String ? StrPtr(fileName) : fileName

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\usprep_open", "ptr", path, "ptr", fileName, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UStringPrepProfile>} 
     */
    static usprep_openByType(type, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\usprep_openByType", "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringPrepProfile>} profile 
     * @returns {String} Nothing - always returns an empty string
     */
    static usprep_close(profile) {
        profileMarshal := profile is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\usprep_close", profileMarshal, profile, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringPrepProfile>} prep 
     * @param {Pointer<Integer>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Integer} options 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static usprep_prepare(prep, src, srcLength, dest, destCapacity, options, parseError, status) {
        prepMarshal := prep is VarRef ? "ptr*" : "ptr"
        srcMarshal := src is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\usprep_prepare", prepMarshal, prep, srcMarshal, src, "int", srcLength, destMarshal, dest, "int", destCapacity, "int", options, "ptr", parseError, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} options 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UIDNA>} 
     */
    static uidna_openUTS46(options, pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_openUTS46", "uint", options, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @returns {String} Nothing - always returns an empty string
     */
    static uidna_close(idna) {
        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\uidna_close", idnaMarshal, idna, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {Pointer<Integer>} label 
     * @param {Integer} length 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToASCII(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"
        labelMarshal := label is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_labelToASCII", idnaMarshal, idna, labelMarshal, label, "int", length, destMarshal, dest, "int", capacity, "ptr", pInfo, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {Pointer<Integer>} label 
     * @param {Integer} length 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToUnicode(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"
        labelMarshal := label is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_labelToUnicode", idnaMarshal, idna, labelMarshal, label, "int", length, destMarshal, dest, "int", capacity, "ptr", pInfo, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {Pointer<Integer>} name 
     * @param {Integer} length 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToASCII(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"
        nameMarshal := name is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_nameToASCII", idnaMarshal, idna, nameMarshal, name, "int", length, destMarshal, dest, "int", capacity, "ptr", pInfo, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {Pointer<Integer>} name 
     * @param {Integer} length 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToUnicode(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"
        nameMarshal := name is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_nameToUnicode", idnaMarshal, idna, nameMarshal, name, "int", length, destMarshal, dest, "int", capacity, "ptr", pInfo, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {PSTR} label 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToASCII_UTF8(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        label := label is String ? StrPtr(label) : label
        dest := dest is String ? StrPtr(dest) : dest

        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_labelToASCII_UTF8", idnaMarshal, idna, "ptr", label, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {PSTR} label 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToUnicodeUTF8(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        label := label is String ? StrPtr(label) : label
        dest := dest is String ? StrPtr(dest) : dest

        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_labelToUnicodeUTF8", idnaMarshal, idna, "ptr", label, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {PSTR} name 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToASCII_UTF8(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        name := name is String ? StrPtr(name) : name
        dest := dest is String ? StrPtr(dest) : dest

        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_nameToASCII_UTF8", idnaMarshal, idna, "ptr", name, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {PSTR} name 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToUnicodeUTF8(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        name := name is String ? StrPtr(name) : name
        dest := dest is String ? StrPtr(dest) : dest

        idnaMarshal := idna is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\uidna_nameToUnicodeUTF8", idnaMarshal, idna, "ptr", name, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_open(type, locale, text, textLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        textMarshal := text is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_open", "int", type, "ptr", locale, textMarshal, text, "int", textLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} rules 
     * @param {Integer} rulesLength 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<UParseError>} parseErr 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_openRules(rules, rulesLength, text, textLength, parseErr, status) {
        rulesMarshal := rules is VarRef ? "ushort*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_openRules", rulesMarshal, rules, "int", rulesLength, textMarshal, text, "int", textLength, "ptr", parseErr, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} binaryRules 
     * @param {Integer} rulesLength 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_openBinaryRules(binaryRules, rulesLength, text, textLength, status) {
        binaryRulesMarshal := binaryRules is VarRef ? "char*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_openBinaryRules", binaryRulesMarshal, binaryRules, "int", rulesLength, textMarshal, text, "int", textLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Integer>} pBufferSize 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_safeClone(bi, stackBuffer, pBufferSize, status) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"
        stackBufferMarshal := stackBuffer is VarRef ? "ptr" : "ptr"
        pBufferSizeMarshal := pBufferSize is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_safeClone", biMarshal, bi, stackBufferMarshal, stackBuffer, pBufferSizeMarshal, pBufferSize, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_clone(bi, status) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ubrk_clone", biMarshal, bi, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_close(bi) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ubrk_close", biMarshal, bi, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_setText(bi, text, textLength, status) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubrk_setText", biMarshal, bi, textMarshal, text, "int", textLength, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_setUText(bi, text, status) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubrk_setUText", biMarshal, bi, "ptr", text, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_current(bi) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_current", biMarshal, bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_next(bi) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_next", biMarshal, bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_previous(bi) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_previous", biMarshal, bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_first(bi) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_first", biMarshal, bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_last(bi) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_last", biMarshal, bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_preceding(bi, offset) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_preceding", biMarshal, bi, "int", offset, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_following(bi, offset) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_following", biMarshal, bi, "int", offset, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} index 
     * @returns {PSTR} 
     */
    static ubrk_getAvailable(index) {
        result := DllCall("icuuc.dll\ubrk_getAvailable", "int", index, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ubrk_countAvailable() {
        result := DllCall("icuuc.dll\ubrk_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_isBoundary(bi, offset) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_isBoundary", biMarshal, bi, "int", offset, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_getRuleStatus(bi) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_getRuleStatus", biMarshal, bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Integer>} fillInVec 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ubrk_getRuleStatusVec(bi, fillInVec, capacity, status) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"
        fillInVecMarshal := fillInVec is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_getRuleStatusVec", biMarshal, bi, fillInVecMarshal, fillInVec, "int", capacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ubrk_getLocaleByType(bi, type, status) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_getLocaleByType", biMarshal, bi, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_refreshUText(bi, text, status) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\ubrk_refreshUText", biMarshal, bi, "ptr", text, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Integer>} binaryRules 
     * @param {Integer} rulesCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ubrk_getBinaryRules(bi, binaryRules, rulesCapacity, status) {
        biMarshal := bi is VarRef ? "ptr*" : "ptr"
        binaryRulesMarshal := binaryRules is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ubrk_getBinaryRules", biMarshal, bi, binaryRulesMarshal, binaryRules, "int", rulesCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} dataVersionFillin 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getDataVersion(dataVersionFillin, status) {
        dataVersionFillinMarshal := dataVersionFillin is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuuc.dll\u_getDataVersion", dataVersionFillinMarshal, dataVersionFillin, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} zoneType 
     * @param {PSTR} region 
     * @param {Pointer<Integer>} rawOffset 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucal_openTimeZoneIDEnumeration(zoneType, region, rawOffset, ec) {
        region := region is String ? StrPtr(region) : region

        rawOffsetMarshal := rawOffset is VarRef ? "int*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_openTimeZoneIDEnumeration", "int", zoneType, "ptr", region, rawOffsetMarshal, rawOffset, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucal_openTimeZones(ec) {
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_openTimeZones", ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} country 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucal_openCountryTimeZones(country, ec) {
        country := country is String ? StrPtr(country) : country

        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_openCountryTimeZones", "ptr", country, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucal_getDefaultTimeZone(result, resultCapacity, ec) {
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getDefaultTimeZone", resultMarshal, result, "int", resultCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} zoneID 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDefaultTimeZone(zoneID, ec) {
        zoneIDMarshal := zoneID is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucal_setDefaultTimeZone", zoneIDMarshal, zoneID, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucal_getHostTimeZone(result, resultCapacity, ec) {
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucal_getHostTimeZone", resultMarshal, result, "int", resultCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} zoneID 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucal_getDSTSavings(zoneID, ec) {
        zoneIDMarshal := zoneID is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getDSTSavings", zoneIDMarshal, zoneID, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Float} 
     */
    static ucal_getNow() {
        result := DllCall("icuin.dll\ucal_getNow", "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} zoneID 
     * @param {Integer} len 
     * @param {PSTR} locale 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static ucal_open(zoneID, len, locale, type, status) {
        locale := locale is String ? StrPtr(locale) : locale

        zoneIDMarshal := zoneID is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_open", zoneIDMarshal, zoneID, "int", len, "ptr", locale, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_close(cal) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucal_close", calMarshal, cal, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static ucal_clone(cal, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_clone", calMarshal, cal, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Pointer<Integer>} zoneID 
     * @param {Integer} len 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setTimeZone(cal, zoneID, len, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        zoneIDMarshal := zoneID is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucal_setTimeZone", calMarshal, cal, zoneIDMarshal, zoneID, "int", len, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneID(cal, result, resultLength, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getTimeZoneID", calMarshal, cal, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} type 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneDisplayName(cal, type, locale, result, resultLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getTimeZoneDisplayName", calMarshal, cal, "int", type, "ptr", locale, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_inDaylightTime(cal, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_inDaylightTime", calMarshal, cal, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Float} date 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setGregorianChange(cal, date, pErrorCode) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucal_setGregorianChange", calMarshal, cal, "double", date, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Float} 
     */
    static ucal_getGregorianChange(cal, pErrorCode) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getGregorianChange", calMarshal, cal, pErrorCodeMarshal, pErrorCode, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} attr 
     * @returns {Integer} 
     */
    static ucal_getAttribute(cal, attr) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucal_getAttribute", calMarshal, cal, "int", attr, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setAttribute(cal, attr, newValue) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucal_setAttribute", calMarshal, cal, "int", attr, "int", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {PSTR} 
     */
    static ucal_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\ucal_getAvailable", "int", localeIndex, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucal_countAvailable() {
        result := DllCall("icuin.dll\ucal_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Pointer<Integer>} status 
     * @returns {Float} 
     */
    static ucal_getMillis(cal, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getMillis", calMarshal, cal, statusMarshal, status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Float} dateTime 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setMillis(cal, dateTime, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucal_setMillis", calMarshal, cal, "double", dateTime, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} year 
     * @param {Integer} month 
     * @param {Integer} date 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDate(cal, year, month, date, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucal_setDate", calMarshal, cal, "int", year, "int", month, "int", date, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} year 
     * @param {Integer} month 
     * @param {Integer} date 
     * @param {Integer} hour 
     * @param {Integer} minute 
     * @param {Integer} second 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDateTime(cal, year, month, date, hour, minute, second, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucal_setDateTime", calMarshal, cal, "int", year, "int", month, "int", date, "int", hour, "int", minute, "int", second, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal1 
     * @param {Pointer<Pointer<Void>>} cal2 
     * @returns {Integer} 
     */
    static ucal_equivalentTo(cal1, cal2) {
        cal1Marshal := cal1 is VarRef ? "ptr*" : "ptr"
        cal2Marshal := cal2 is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucal_equivalentTo", cal1Marshal, cal1, cal2Marshal, cal2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} field 
     * @param {Integer} amount 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_add(cal, field, amount, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucal_add", calMarshal, cal, "int", field, "int", amount, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} field 
     * @param {Integer} amount 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_roll(cal, field, amount, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucal_roll", calMarshal, cal, "int", field, "int", amount, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} field 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_get(cal, field, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_get", calMarshal, cal, "int", field, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} field 
     * @param {Integer} value 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_set(cal, field, value) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucal_set", calMarshal, cal, "int", field, "int", value, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} field 
     * @returns {Integer} 
     */
    static ucal_isSet(cal, field) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucal_isSet", calMarshal, cal, "int", field, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} field 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_clearField(cal, field) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucal_clearField", calMarshal, cal, "int", field, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} calendar 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_clear(calendar) {
        calendarMarshal := calendar is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucal_clear", calendarMarshal, calendar, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} field 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getLimit(cal, field, type, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getLimit", calMarshal, cal, "int", field, "int", type, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ucal_getLocaleByType(cal, type, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getLocaleByType", calMarshal, cal, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ucal_getTZDataVersion(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getTZDataVersion", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} id 
     * @param {Integer} len 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Integer>} isSystemID 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getCanonicalTimeZoneID(id, len, result, resultCapacity, isSystemID, status) {
        idMarshal := id is VarRef ? "ushort*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        isSystemIDMarshal := isSystemID is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getCanonicalTimeZoneID", idMarshal, id, "int", len, resultMarshal, result, "int", resultCapacity, isSystemIDMarshal, isSystemID, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ucal_getType(cal, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getType", calMarshal, cal, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} key 
     * @param {PSTR} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucal_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        key := key is String ? StrPtr(key) : key
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} dayOfWeek 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getDayOfWeekType(cal, dayOfWeek, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getDayOfWeekType", calMarshal, cal, "int", dayOfWeek, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} dayOfWeek 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getWeekendTransition(cal, dayOfWeek, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getWeekendTransition", calMarshal, cal, "int", dayOfWeek, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Float} date 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_isWeekend(cal, date, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_isWeekend", calMarshal, cal, "double", date, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Float} target 
     * @param {Integer} field 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getFieldDifference(cal, target, field, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getFieldDifference", calMarshal, cal, "double", target, "int", field, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} type 
     * @param {Pointer<Float>} transition 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneTransitionDate(cal, type, transition, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        transitionMarshal := transition is VarRef ? "double*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getTimeZoneTransitionDate", calMarshal, cal, "int", type, transitionMarshal, transition, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} id 
     * @param {Integer} len 
     * @param {Pointer<Integer>} winid 
     * @param {Integer} winidCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getWindowsTimeZoneID(id, len, winid, winidCapacity, status) {
        idMarshal := id is VarRef ? "ushort*" : "ptr"
        winidMarshal := winid is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getWindowsTimeZoneID", idMarshal, id, "int", len, winidMarshal, winid, "int", winidCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} winid 
     * @param {Integer} len 
     * @param {PSTR} region 
     * @param {Pointer<Integer>} id 
     * @param {Integer} idCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneIDForWindowsID(winid, len, region, id, idCapacity, status) {
        region := region is String ? StrPtr(region) : region

        winidMarshal := winid is VarRef ? "ushort*" : "ptr"
        idMarshal := id is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucal_getTimeZoneIDForWindowsID", winidMarshal, winid, "int", len, "ptr", region, idMarshal, id, "int", idCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} cal 
     * @param {Integer} nonExistingTimeOpt 
     * @param {Integer} duplicatedTimeOpt 
     * @param {Pointer<Integer>} rawOffset 
     * @param {Pointer<Integer>} dstOffset 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_getTimeZoneOffsetFromLocal(cal, nonExistingTimeOpt, duplicatedTimeOpt, rawOffset, dstOffset, status) {
        calMarshal := cal is VarRef ? "ptr*" : "ptr"
        rawOffsetMarshal := rawOffset is VarRef ? "int*" : "ptr"
        dstOffsetMarshal := dstOffset is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ucal_getTimeZoneOffsetFromLocal", calMarshal, cal, "int", nonExistingTimeOpt, "int", duplicatedTimeOpt, rawOffsetMarshal, rawOffset, dstOffsetMarshal, dstOffset, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} loc 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_open(loc, status) {
        loc := loc is String ? StrPtr(loc) : loc

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_open", "ptr", loc, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} rules 
     * @param {Integer} rulesLength 
     * @param {Integer} normalizationMode 
     * @param {Integer} strength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_openRules(rules, rulesLength, normalizationMode, strength, parseError, status) {
        rulesMarshal := rules is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_openRules", rulesMarshal, rules, "int", rulesLength, "int", normalizationMode, "int", strength, "ptr", parseError, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<USet>} contractions 
     * @param {Pointer<USet>} expansions 
     * @param {Integer} addPrefixes 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getContractionsAndExpansions(coll, contractions, expansions, addPrefixes, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        contractionsMarshal := contractions is VarRef ? "ptr*" : "ptr"
        expansionsMarshal := expansions is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucol_getContractionsAndExpansions", collMarshal, coll, contractionsMarshal, contractions, expansionsMarshal, expansions, "char", addPrefixes, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_close(coll) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucol_close", collMarshal, coll, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_strcoll(coll, source, sourceLength, target, targetLength) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        targetMarshal := target is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuin.dll\ucol_strcoll", collMarshal, coll, sourceMarshal, source, "int", sourceLength, targetMarshal, target, "int", targetLength, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {PSTR} target 
     * @param {Integer} targetLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_strcollUTF8(coll, source, sourceLength, target, targetLength, status) {
        source := source is String ? StrPtr(source) : source
        target := target is String ? StrPtr(target) : target

        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_strcollUTF8", collMarshal, coll, "ptr", source, "int", sourceLength, "ptr", target, "int", targetLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_greater(coll, source, sourceLength, target, targetLength) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        targetMarshal := target is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuin.dll\ucol_greater", collMarshal, coll, sourceMarshal, source, "int", sourceLength, targetMarshal, target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_greaterOrEqual(coll, source, sourceLength, target, targetLength) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        targetMarshal := target is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuin.dll\ucol_greaterOrEqual", collMarshal, coll, sourceMarshal, source, "int", sourceLength, targetMarshal, target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_equal(coll, source, sourceLength, target, targetLength) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        targetMarshal := target is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuin.dll\ucol_equal", collMarshal, coll, sourceMarshal, source, "int", sourceLength, targetMarshal, target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UCharIterator>} sIter 
     * @param {Pointer<UCharIterator>} tIter 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_strcollIter(coll, sIter, tIter, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_strcollIter", collMarshal, coll, "ptr", sIter, "ptr", tIter, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @returns {Integer} 
     */
    static ucol_getStrength(coll) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucol_getStrength", collMarshal, coll, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} strength 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setStrength(coll, strength) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucol_setStrength", collMarshal, coll, "int", strength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucol_getReorderCodes(coll, dest, destCapacity, pErrorCode) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        destMarshal := dest is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getReorderCodes", collMarshal, coll, destMarshal, dest, "int", destCapacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} reorderCodes 
     * @param {Integer} reorderCodesLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setReorderCodes(coll, reorderCodes, reorderCodesLength, pErrorCode) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        reorderCodesMarshal := reorderCodes is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucol_setReorderCodes", collMarshal, coll, reorderCodesMarshal, reorderCodes, "int", reorderCodesLength, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Integer} reorderCode 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static ucol_getEquivalentReorderCodes(reorderCode, dest, destCapacity, pErrorCode) {
        destMarshal := dest is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getEquivalentReorderCodes", "int", reorderCode, destMarshal, dest, "int", destCapacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} objLoc 
     * @param {PSTR} dispLoc 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_getDisplayName(objLoc, dispLoc, result, resultLength, status) {
        objLoc := objLoc is String ? StrPtr(objLoc) : objLoc
        dispLoc := dispLoc is String ? StrPtr(dispLoc) : dispLoc

        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getDisplayName", "ptr", objLoc, "ptr", dispLoc, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {PSTR} 
     */
    static ucol_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\ucol_getAvailable", "int", localeIndex, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucol_countAvailable() {
        result := DllCall("icuin.dll\ucol_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucol_openAvailableLocales(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_openAvailableLocales", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucol_getKeywords(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getKeywords", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucol_getKeywordValues(keyword, status) {
        keyword := keyword is String ? StrPtr(keyword) : keyword

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getKeywordValues", "ptr", keyword, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} key 
     * @param {PSTR} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucol_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        key := key is String ? StrPtr(key) : key
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} result 
     * @param {Integer} resultCapacity 
     * @param {PSTR} keyword 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} isAvailable 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_getFunctionalEquivalent(result, resultCapacity, keyword, locale, isAvailable, status) {
        result := result is String ? StrPtr(result) : result
        keyword := keyword is String ? StrPtr(keyword) : keyword
        locale := locale is String ? StrPtr(locale) : locale

        isAvailableMarshal := isAvailable is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getFunctionalEquivalent", "ptr", result, "int", resultCapacity, "ptr", keyword, "ptr", locale, isAvailableMarshal, isAvailable, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} length 
     * @returns {Pointer<Integer>} 
     */
    static ucol_getRules(coll, length) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        lengthMarshal := length is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getRules", collMarshal, coll, lengthMarshal, length, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @returns {Integer} 
     */
    static ucol_getSortKey(coll, source, sourceLength, result, resultLength) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        resultMarshal := result is VarRef ? "char*" : "ptr"

        result := DllCall("icuin.dll\ucol_getSortKey", collMarshal, coll, sourceMarshal, source, "int", sourceLength, resultMarshal, result, "int", resultLength, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Pointer<Integer>} state 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} count 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_nextSortKeyPart(coll, iter, state, dest, count, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        stateMarshal := state is VarRef ? "uint*" : "ptr"
        destMarshal := dest is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_nextSortKeyPart", collMarshal, coll, "ptr", iter, stateMarshal, state, destMarshal, dest, "int", count, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Integer} boundType 
     * @param {Integer} noOfLevels 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_getBound(source, sourceLength, boundType, noOfLevels, result, resultLength, status) {
        sourceMarshal := source is VarRef ? "char*" : "ptr"
        resultMarshal := result is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getBound", sourceMarshal, source, "int", sourceLength, "int", boundType, "uint", noOfLevels, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} info 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getVersion(coll, info) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        infoMarshal := info is VarRef ? "char*" : "ptr"

        DllCall("icuin.dll\ucol_getVersion", collMarshal, coll, infoMarshal, info, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} info 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getUCAVersion(coll, info) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        infoMarshal := info is VarRef ? "char*" : "ptr"

        DllCall("icuin.dll\ucol_getUCAVersion", collMarshal, coll, infoMarshal, info, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} src1 
     * @param {Integer} src1Length 
     * @param {Pointer<Integer>} src2 
     * @param {Integer} src2Length 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @returns {Integer} 
     */
    static ucol_mergeSortkeys(src1, src1Length, src2, src2Length, dest, destCapacity) {
        src1Marshal := src1 is VarRef ? "char*" : "ptr"
        src2Marshal := src2 is VarRef ? "char*" : "ptr"
        destMarshal := dest is VarRef ? "char*" : "ptr"

        result := DllCall("icuin.dll\ucol_mergeSortkeys", src1Marshal, src1, "int", src1Length, src2Marshal, src2, "int", src2Length, destMarshal, dest, "int", destCapacity, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} attr 
     * @param {Integer} value 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setAttribute(coll, attr, value, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucol_setAttribute", collMarshal, coll, "int", attr, "int", value, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} attr 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_getAttribute(coll, attr, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getAttribute", collMarshal, coll, "int", attr, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} group 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setMaxVariable(coll, group, pErrorCode) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucol_setMaxVariable", collMarshal, coll, "int", group, pErrorCodeMarshal, pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @returns {Integer} 
     */
    static ucol_getMaxVariable(coll) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucol_getMaxVariable", collMarshal, coll, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_getVariableTop(coll, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getVariableTop", collMarshal, coll, statusMarshal, status, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Integer>} pBufferSize 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_safeClone(coll, stackBuffer, pBufferSize, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        stackBufferMarshal := stackBuffer is VarRef ? "ptr" : "ptr"
        pBufferSizeMarshal := pBufferSize is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_safeClone", collMarshal, coll, stackBufferMarshal, stackBuffer, pBufferSizeMarshal, pBufferSize, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_clone(coll, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucol_clone", collMarshal, coll, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} delta 
     * @param {Pointer<Integer>} buffer_R 
     * @param {Integer} bufferLen 
     * @returns {Integer} 
     */
    static ucol_getRulesEx(coll, delta, buffer_R, bufferLen) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        buffer_RMarshal := buffer_R is VarRef ? "ushort*" : "ptr"

        result := DllCall("icuin.dll\ucol_getRulesEx", collMarshal, coll, "int", delta, buffer_RMarshal, buffer_R, "int", bufferLen, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ucol_getLocaleByType(coll, type, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getLocaleByType", collMarshal, coll, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USet>} 
     */
    static ucol_getTailoredSet(coll, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_getTailoredSet", collMarshal, coll, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} buffer_R 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_cloneBinary(coll, buffer_R, capacity, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        buffer_RMarshal := buffer_R is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_cloneBinary", collMarshal, coll, buffer_RMarshal, buffer_R, "int", capacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} bin 
     * @param {Integer} length 
     * @param {Pointer<UCollator>} base 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_openBinary(bin, length, base, status) {
        binMarshal := bin is VarRef ? "char*" : "ptr"
        baseMarshal := base is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_openBinary", binMarshal, bin, "int", length, baseMarshal, base, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UCollationElements>} 
     */
    static ucol_openElements(coll, text, textLength, status) {
        collMarshal := coll is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_openElements", collMarshal, coll, textMarshal, text, "int", textLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} key 
     * @param {Integer} length 
     * @returns {Integer} 
     */
    static ucol_keyHashCode(key, length) {
        keyMarshal := key is VarRef ? "char*" : "ptr"

        result := DllCall("icuin.dll\ucol_keyHashCode", keyMarshal, key, "int", length, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_closeElements(elems) {
        elemsMarshal := elems is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucol_closeElements", elemsMarshal, elems, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_reset(elems) {
        elemsMarshal := elems is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucol_reset", elemsMarshal, elems, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_next(elems, status) {
        elemsMarshal := elems is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_next", elemsMarshal, elems, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucol_previous(elems, status) {
        elemsMarshal := elems is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucol_previous", elemsMarshal, elems, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_getMaxExpansion(elems, order) {
        elemsMarshal := elems is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucol_getMaxExpansion", elemsMarshal, elems, "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setText(elems, text, textLength, status) {
        elemsMarshal := elems is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucol_setText", elemsMarshal, elems, textMarshal, text, "int", textLength, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @returns {Integer} 
     */
    static ucol_getOffset(elems) {
        elemsMarshal := elems is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucol_getOffset", elemsMarshal, elems, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Integer} offset 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setOffset(elems, offset, status) {
        elemsMarshal := elems is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucol_setOffset", elemsMarshal, elems, "int", offset, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_primaryOrder(order) {
        result := DllCall("icuin.dll\ucol_primaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_secondaryOrder(order) {
        result := DllCall("icuin.dll\ucol_secondaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_tertiaryOrder(order) {
        result := DllCall("icuin.dll\ucol_tertiaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UCharsetDetector>} 
     */
    static ucsdet_open(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_open", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_close(ucsd) {
        ucsdMarshal := ucsd is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ucsdet_close", ucsdMarshal, ucsd, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {PSTR} textIn 
     * @param {Integer} len 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_setText(ucsd, textIn, len, status) {
        textIn := textIn is String ? StrPtr(textIn) : textIn

        ucsdMarshal := ucsd is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucsdet_setText", ucsdMarshal, ucsd, "ptr", textIn, "int", len, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {PSTR} encoding 
     * @param {Integer} length 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_setDeclaredEncoding(ucsd, encoding, length, status) {
        encoding := encoding is String ? StrPtr(encoding) : encoding

        ucsdMarshal := ucsd is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ucsdet_setDeclaredEncoding", ucsdMarshal, ucsd, "ptr", encoding, "int", length, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UCharsetMatch>} 
     */
    static ucsdet_detect(ucsd, status) {
        ucsdMarshal := ucsd is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_detect", ucsdMarshal, ucsd, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {Pointer<Integer>} matchesFound 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<UCharsetMatch>>} 
     */
    static ucsdet_detectAll(ucsd, matchesFound, status) {
        ucsdMarshal := ucsd is VarRef ? "ptr*" : "ptr"
        matchesFoundMarshal := matchesFound is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_detectAll", ucsdMarshal, ucsd, matchesFoundMarshal, matchesFound, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetMatch>} ucsm 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ucsdet_getName(ucsm, status) {
        ucsmMarshal := ucsm is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_getName", ucsmMarshal, ucsm, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetMatch>} ucsm 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucsdet_getConfidence(ucsm, status) {
        ucsmMarshal := ucsm is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_getConfidence", ucsmMarshal, ucsm, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetMatch>} ucsm 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ucsdet_getLanguage(ucsm, status) {
        ucsmMarshal := ucsm is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_getLanguage", ucsmMarshal, ucsm, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetMatch>} ucsm 
     * @param {Pointer<Integer>} buf 
     * @param {Integer} cap 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ucsdet_getUChars(ucsm, buf, cap, status) {
        ucsmMarshal := ucsm is VarRef ? "ptr*" : "ptr"
        bufMarshal := buf is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_getUChars", ucsmMarshal, ucsm, bufMarshal, buf, "int", cap, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucsdet_getAllDetectableCharsets(ucsd, status) {
        ucsdMarshal := ucsd is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_getAllDetectableCharsets", ucsdMarshal, ucsd, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @returns {Integer} 
     */
    static ucsdet_isInputFilterEnabled(ucsd) {
        ucsdMarshal := ucsd is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_isInputFilterEnabled", ucsdMarshal, ucsd, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {Integer} filter 
     * @returns {Integer} 
     */
    static ucsdet_enableInputFilter(ucsd, filter) {
        ucsdMarshal := ucsd is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ucsdet_enableInputFilter", ucsdMarshal, ucsd, "char", filter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UFieldPositionIterator>} 
     */
    static ufieldpositer_open(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufieldpositer_open", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufieldpositer_close(fpositer) {
        fpositerMarshal := fpositer is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ufieldpositer_close", fpositerMarshal, fpositer, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @param {Pointer<Integer>} beginIndex 
     * @param {Pointer<Integer>} endIndex 
     * @returns {Integer} 
     */
    static ufieldpositer_next(fpositer, beginIndex, endIndex) {
        fpositerMarshal := fpositer is VarRef ? "ptr*" : "ptr"
        beginIndexMarshal := beginIndex is VarRef ? "int*" : "ptr"
        endIndexMarshal := endIndex is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufieldpositer_next", fpositerMarshal, fpositer, beginIndexMarshal, beginIndex, endIndexMarshal, endIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static ufmt_open(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_open", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufmt_close(fmt) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ufmt_close", fmtMarshal, fmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ufmt_getType(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getType", fmtMarshal, fmt, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @returns {Integer} 
     */
    static ufmt_isNumeric(fmt) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ufmt_isNumeric", fmtMarshal, fmt, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Float} 
     */
    static ufmt_getDate(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getDate", fmtMarshal, fmt, statusMarshal, status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Float} 
     */
    static ufmt_getDouble(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getDouble", fmtMarshal, fmt, statusMarshal, status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ufmt_getLong(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getLong", fmtMarshal, fmt, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ufmt_getInt64(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getInt64", fmtMarshal, fmt, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Void>} 
     */
    static ufmt_getObject(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getObject", fmtMarshal, fmt, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static ufmt_getUChars(fmt, len, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getUChars", fmtMarshal, fmt, lenMarshal, len, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ufmt_getArrayLength(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getArrayLength", fmtMarshal, fmt, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} n 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static ufmt_getArrayItemByIndex(fmt, n, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getArrayItemByIndex", fmtMarshal, fmt, "int", n, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} len 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static ufmt_getDecNumChars(fmt, len, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        lenMarshal := len is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ufmt_getDecNumChars", fmtMarshal, fmt, lenMarshal, len, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UConstrainedFieldPosition>} 
     */
    static ucfpos_open(ec) {
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucfpos_open", ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_reset(ucfpos, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ucfpos_reset", ucfposMarshal, ucfpos, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_close(ucfpos) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\ucfpos_close", ucfposMarshal, ucfpos, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} category 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_constrainCategory(ucfpos, category, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ucfpos_constrainCategory", ucfposMarshal, ucfpos, "int", category, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_constrainField(ucfpos, category, field, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ucfpos_constrainField", ucfposMarshal, ucfpos, "int", category, "int", field, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getCategory(ucfpos, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucfpos_getCategory", ucfposMarshal, ucfpos, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getField(ucfpos, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucfpos_getField", ucfposMarshal, ucfpos, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Integer>} pStart 
     * @param {Pointer<Integer>} pLimit 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_getIndexes(ucfpos, pStart, pLimit, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        pStartMarshal := pStart is VarRef ? "int*" : "ptr"
        pLimitMarshal := pLimit is VarRef ? "int*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ucfpos_getIndexes", ucfposMarshal, ucfpos, pStartMarshal, pStart, pLimitMarshal, pLimit, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getInt64IterationContext(ucfpos, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucfpos_getInt64IterationContext", ucfposMarshal, ucfpos, ecMarshal, ec, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} context 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_setInt64IterationContext(ucfpos, context, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ucfpos_setInt64IterationContext", ucfposMarshal, ucfpos, "int64", context, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ucfpos_matchesField(ucfpos, category, field, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ucfpos_matchesField", ucfposMarshal, ucfpos, "int", category, "int", field, ecMarshal, ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_setState(ucfpos, category, field, start, limit, ec) {
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ucfpos_setState", ucfposMarshal, ucfpos, "int", category, "int", field, "int", start, "int", limit, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedValue>} ufmtval 
     * @param {Pointer<Integer>} pLength 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<Integer>} 
     */
    static ufmtval_getString(ufmtval, pLength, ec) {
        ufmtvalMarshal := ufmtval is VarRef ? "ptr*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ufmtval_getString", ufmtvalMarshal, ufmtval, pLengthMarshal, pLength, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedValue>} ufmtval 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static ufmtval_nextPosition(ufmtval, ucfpos, ec) {
        ufmtvalMarshal := ufmtval is VarRef ? "ptr*" : "ptr"
        ucfposMarshal := ucfpos is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ufmtval_nextPosition", ufmtvalMarshal, ufmtval, ucfposMarshal, ucfpos, ecMarshal, ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<Integer>} tzID 
     * @param {Integer} tzIDLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UDateIntervalFormat>} 
     */
    static udtitvfmt_open(locale, skeleton, skeletonLength, tzID, tzIDLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        tzIDMarshal := tzID is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udtitvfmt_open", "ptr", locale, skeletonMarshal, skeleton, "int", skeletonLength, tzIDMarshal, tzID, "int", tzIDLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_close(formatter) {
        formatterMarshal := formatter is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\udtitvfmt_close", formatterMarshal, formatter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedDateInterval>} 
     */
    static udtitvfmt_openResult(ec) {
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\udtitvfmt_openResult", ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedDateInterval>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static udtitvfmt_resultAsValue(uresult, ec) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\udtitvfmt_resultAsValue", uresultMarshal, uresult, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedDateInterval>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_closeResult(uresult) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\udtitvfmt_closeResult", uresultMarshal, uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @param {Float} fromDate 
     * @param {Float} toDate 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udtitvfmt_format(formatter, fromDate, toDate, result, resultCapacity, position, status) {
        formatterMarshal := formatter is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udtitvfmt_format", formatterMarshal, formatter, "double", fromDate, "double", toDate, resultMarshal, result, "int", resultCapacity, "ptr", position, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @param {Float} fromDate 
     * @param {Float} toDate 
     * @param {Pointer<UFormattedDateInterval>} result 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_formatToResult(formatter, fromDate, toDate, result, status) {
        formatterMarshal := formatter is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\udtitvfmt_formatToResult", formatterMarshal, formatter, "double", fromDate, "double", toDate, resultMarshal, result, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @param {Integer} value 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_setContext(formatter, value, status) {
        formatterMarshal := formatter is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\udtitvfmt_setContext", formatterMarshal, formatter, "int", value, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udtitvfmt_getContext(formatter, type, status) {
        formatterMarshal := formatter is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\udtitvfmt_getContext", formatterMarshal, formatter, "int", type, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UGenderInfo>} 
     */
    static ugender_getInstance(locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ugender_getInstance", "ptr", locale, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UGenderInfo>} genderInfo 
     * @param {Pointer<Integer>} genders 
     * @param {Integer} size 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ugender_getListGender(genderInfo, genders, size, status) {
        genderInfoMarshal := genderInfo is VarRef ? "ptr*" : "ptr"
        gendersMarshal := genders is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ugender_getListGender", genderInfoMarshal, genderInfo, gendersMarshal, genders, "int", size, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UListFormatter>} 
     */
    static ulistfmt_open(locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ulistfmt_open", "ptr", locale, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Integer} type 
     * @param {Integer} width 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UListFormatter>} 
     */
    static ulistfmt_openForType(locale, type, width, status) {
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ulistfmt_openForType", "ptr", locale, "int", type, "int", width, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UListFormatter>} listfmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_close(listfmt) {
        listfmtMarshal := listfmt is VarRef ? "ptr*" : "ptr"

        DllCall("icuuc.dll\ulistfmt_close", listfmtMarshal, listfmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedList>} 
     */
    static ulistfmt_openResult(ec) {
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ulistfmt_openResult", ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedList>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static ulistfmt_resultAsValue(uresult, ec) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ulistfmt_resultAsValue", uresultMarshal, uresult, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedList>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_closeResult(uresult) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\ulistfmt_closeResult", uresultMarshal, uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UListFormatter>} listfmt 
     * @param {Pointer<Pointer<Integer>>} strings 
     * @param {Pointer<Integer>} stringLengths 
     * @param {Integer} stringCount 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ulistfmt_format(listfmt, strings, stringLengths, stringCount, result, resultCapacity, status) {
        listfmtMarshal := listfmt is VarRef ? "ptr*" : "ptr"
        stringsMarshal := strings is VarRef ? "ptr*" : "ptr"
        stringLengthsMarshal := stringLengths is VarRef ? "int*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuuc.dll\ulistfmt_format", listfmtMarshal, listfmt, stringsMarshal, strings, stringLengthsMarshal, stringLengths, "int", stringCount, resultMarshal, result, "int", resultCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UListFormatter>} listfmt 
     * @param {Pointer<Pointer<Integer>>} strings 
     * @param {Pointer<Integer>} stringLengths 
     * @param {Integer} stringCount 
     * @param {Pointer<UFormattedList>} uresult 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_formatStringsToResult(listfmt, strings, stringLengths, stringCount, uresult, status) {
        listfmtMarshal := listfmt is VarRef ? "ptr*" : "ptr"
        stringsMarshal := strings is VarRef ? "ptr*" : "ptr"
        stringLengthsMarshal := stringLengths is VarRef ? "int*" : "ptr"
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ulistfmt_formatStringsToResult", listfmtMarshal, listfmt, stringsMarshal, strings, stringLengthsMarshal, stringLengths, "int", stringCount, uresultMarshal, uresult, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<ULocaleData>} 
     */
    static ulocdata_open(localeID, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ulocdata_open", "ptr", localeID, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_close(uld) {
        uldMarshal := uld is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ulocdata_close", uldMarshal, uld, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Integer} setting 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_setNoSubstitute(uld, setting) {
        uldMarshal := uld is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ulocdata_setNoSubstitute", uldMarshal, uld, "char", setting, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @returns {Integer} 
     */
    static ulocdata_getNoSubstitute(uld) {
        uldMarshal := uld is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\ulocdata_getNoSubstitute", uldMarshal, uld, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Pointer<USet>} fillIn 
     * @param {Integer} options 
     * @param {Integer} extype 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USet>} 
     */
    static ulocdata_getExemplarSet(uld, fillIn, options, extype, status) {
        uldMarshal := uld is VarRef ? "ptr*" : "ptr"
        fillInMarshal := fillIn is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ulocdata_getExemplarSet", uldMarshal, uld, fillInMarshal, fillIn, "uint", options, "int", extype, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Integer} type 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ulocdata_getDelimiter(uld, type, result, resultLength, status) {
        uldMarshal := uld is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ulocdata_getDelimiter", uldMarshal, uld, "int", type, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ulocdata_getMeasurementSystem(localeID, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ulocdata_getMeasurementSystem", "ptr", localeID, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Integer>} height 
     * @param {Pointer<Integer>} width 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_getPaperSize(localeID, height, width, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        heightMarshal := height is VarRef ? "int*" : "ptr"
        widthMarshal := width is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ulocdata_getPaperSize", "ptr", localeID, heightMarshal, height, widthMarshal, width, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} versionArray 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_getCLDRVersion(versionArray, status) {
        versionArrayMarshal := versionArray is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\ulocdata_getCLDRVersion", versionArrayMarshal, versionArray, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ulocdata_getLocaleDisplayPattern(uld, pattern, patternCapacity, status) {
        uldMarshal := uld is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ulocdata_getLocaleDisplayPattern", uldMarshal, uld, patternMarshal, pattern, "int", patternCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Pointer<Integer>} separator 
     * @param {Integer} separatorCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ulocdata_getLocaleSeparator(uld, separator, separatorCapacity, status) {
        uldMarshal := uld is VarRef ? "ptr*" : "ptr"
        separatorMarshal := separator is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ulocdata_getLocaleSeparator", uldMarshal, uld, separatorMarshal, separator, "int", separatorCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static u_formatMessage(locale, pattern, patternLength, result, resultLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\u_formatMessage", "ptr", locale, patternMarshal, pattern, "int", patternLength, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} ap 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static u_vformatMessage(locale, pattern, patternLength, result, resultLength, ap, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        apMarshal := ap is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\u_vformatMessage", "ptr", locale, patternMarshal, pattern, "int", patternLength, resultMarshal, result, "int", resultLength, apMarshal, ap, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_parseMessage(locale, pattern, patternLength, source, sourceLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\u_parseMessage", "ptr", locale, patternMarshal, pattern, "int", patternLength, sourceMarshal, source, "int", sourceLength, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} ap 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_vparseMessage(locale, pattern, patternLength, source, sourceLength, ap, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        apMarshal := ap is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\u_vparseMessage", "ptr", locale, patternMarshal, pattern, "int", patternLength, sourceMarshal, source, "int", sourceLength, apMarshal, ap, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static u_formatMessageWithError(locale, pattern, patternLength, result, resultLength, parseError, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\u_formatMessageWithError", "ptr", locale, patternMarshal, pattern, "int", patternLength, resultMarshal, result, "int", resultLength, "ptr", parseError, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} ap 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static u_vformatMessageWithError(locale, pattern, patternLength, result, resultLength, parseError, ap, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        apMarshal := ap is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\u_vformatMessageWithError", "ptr", locale, patternMarshal, pattern, "int", patternLength, resultMarshal, result, "int", resultLength, "ptr", parseError, apMarshal, ap, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_parseMessageWithError(locale, pattern, patternLength, source, sourceLength, parseError, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\u_parseMessageWithError", "ptr", locale, patternMarshal, pattern, "int", patternLength, sourceMarshal, source, "int", sourceLength, "ptr", parseError, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} ap 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_vparseMessageWithError(locale, pattern, patternLength, source, sourceLength, ap, parseError, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        apMarshal := ap is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\u_vparseMessageWithError", "ptr", locale, patternMarshal, pattern, "int", patternLength, sourceMarshal, source, "int", sourceLength, apMarshal, ap, "ptr", parseError, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {PSTR} locale 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static umsg_open(pattern, patternLength, locale, parseError, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\umsg_open", patternMarshal, pattern, "int", patternLength, "ptr", locale, "ptr", parseError, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_close(format) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\umsg_close", formatMarshal, format, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Void>} 
     */
    static umsg_clone(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\umsg_clone", fmtMarshal, fmt, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {PSTR} locale 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_setLocale(fmt, locale) {
        locale := locale is String ? StrPtr(locale) : locale

        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\umsg_setLocale", fmtMarshal, fmt, "ptr", locale, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @returns {PSTR} 
     */
    static umsg_getLocale(fmt) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\umsg_getLocale", fmtMarshal, fmt, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_applyPattern(fmt, pattern, patternLength, parseError, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\umsg_applyPattern", fmtMarshal, fmt, patternMarshal, pattern, "int", patternLength, "ptr", parseError, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static umsg_toPattern(fmt, result, resultLength, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\umsg_toPattern", fmtMarshal, fmt, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static umsg_format(fmt, result, resultLength, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\umsg_format", fmtMarshal, fmt, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} ap 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static umsg_vformat(fmt, result, resultLength, ap, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        apMarshal := ap is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\umsg_vformat", fmtMarshal, fmt, resultMarshal, result, "int", resultLength, apMarshal, ap, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} count 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_parse(fmt, source, sourceLength, count, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        countMarshal := count is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\umsg_parse", fmtMarshal, fmt, sourceMarshal, source, "int", sourceLength, countMarshal, count, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Integer>} count 
     * @param {Pointer<Integer>} ap 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_vparse(fmt, source, sourceLength, count, ap, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        sourceMarshal := source is VarRef ? "ushort*" : "ptr"
        countMarshal := count is VarRef ? "int*" : "ptr"
        apMarshal := ap is VarRef ? "char*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\umsg_vparse", fmtMarshal, fmt, sourceMarshal, source, "int", sourceLength, countMarshal, count, apMarshal, ap, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static umsg_autoQuoteApostrophe(pattern, patternLength, dest, destCapacity, ec) {
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\umsg_autoQuoteApostrophe", patternMarshal, pattern, "int", patternLength, destMarshal, dest, "int", destCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} style 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {PSTR} locale 
     * @param {Pointer<UParseError>} parseErr 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static unum_open(style, pattern, patternLength, locale, parseErr, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_open", "int", style, patternMarshal, pattern, "int", patternLength, "ptr", locale, "ptr", parseErr, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_close(fmt) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\unum_close", fmtMarshal, fmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static unum_clone(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_clone", fmtMarshal, fmt, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} number_R 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_format(fmt, number_R, result, resultLength, pos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_format", fmtMarshal, fmt, "int", number_R, resultMarshal, result, "int", resultLength, "ptr", pos, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} number_R 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_formatInt64(fmt, number_R, result, resultLength, pos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_formatInt64", fmtMarshal, fmt, "int64", number_R, resultMarshal, result, "int", resultLength, "ptr", pos, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Float} number_R 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_formatDouble(fmt, number_R, result, resultLength, pos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_formatDouble", fmtMarshal, fmt, "double", number_R, resultMarshal, result, "int", resultLength, "ptr", pos, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Float} number_R 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_formatDoubleForFields(format, number_R, result, resultLength, fpositer, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        fpositerMarshal := fpositer is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_formatDoubleForFields", formatMarshal, format, "double", number_R, resultMarshal, result, "int", resultLength, fpositerMarshal, fpositer, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {PSTR} number_R 
     * @param {Integer} length 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_formatDecimal(fmt, number_R, length, result, resultLength, pos, status) {
        number_R := number_R is String ? StrPtr(number_R) : number_R

        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_formatDecimal", fmtMarshal, fmt, "ptr", number_R, "int", length, resultMarshal, result, "int", resultLength, "ptr", pos, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Float} number_R 
     * @param {Pointer<Integer>} currency 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_formatDoubleCurrency(fmt, number_R, currency, result, resultLength, pos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_formatDoubleCurrency", fmtMarshal, fmt, "double", number_R, currencyMarshal, currency, resultMarshal, result, "int", resultLength, "ptr", pos, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Pointer<Void>>} number_R 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_formatUFormattable(fmt, number_R, result, resultLength, pos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        number_RMarshal := number_R is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_formatUFormattable", fmtMarshal, fmt, number_RMarshal, number_R, resultMarshal, result, "int", resultLength, "ptr", pos, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} parsePos 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_parse(fmt, text, textLength, parsePos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        parsePosMarshal := parsePos is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_parse", fmtMarshal, fmt, textMarshal, text, "int", textLength, parsePosMarshal, parsePos, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} parsePos 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_parseInt64(fmt, text, textLength, parsePos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        parsePosMarshal := parsePos is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_parseInt64", fmtMarshal, fmt, textMarshal, text, "int", textLength, parsePosMarshal, parsePos, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} parsePos 
     * @param {Pointer<Integer>} status 
     * @returns {Float} 
     */
    static unum_parseDouble(fmt, text, textLength, parsePos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        parsePosMarshal := parsePos is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_parseDouble", fmtMarshal, fmt, textMarshal, text, "int", textLength, parsePosMarshal, parsePos, statusMarshal, status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} parsePos 
     * @param {PSTR} outBuf 
     * @param {Integer} outBufLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_parseDecimal(fmt, text, textLength, parsePos, outBuf, outBufLength, status) {
        outBuf := outBuf is String ? StrPtr(outBuf) : outBuf

        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        parsePosMarshal := parsePos is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_parseDecimal", fmtMarshal, fmt, textMarshal, text, "int", textLength, parsePosMarshal, parsePos, "ptr", outBuf, "int", outBufLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} parsePos 
     * @param {Pointer<Integer>} currency 
     * @param {Pointer<Integer>} status 
     * @returns {Float} 
     */
    static unum_parseDoubleCurrency(fmt, text, textLength, parsePos, currency, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        parsePosMarshal := parsePos is VarRef ? "int*" : "ptr"
        currencyMarshal := currency is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_parseDoubleCurrency", fmtMarshal, fmt, textMarshal, text, "int", textLength, parsePosMarshal, parsePos, currencyMarshal, currency, statusMarshal, status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Pointer<Void>>} result 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} parsePos 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static unum_parseToUFormattable(fmt, result, text, textLength, parsePos, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        parsePosMarshal := parsePos is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_parseToUFormattable", fmtMarshal, fmt, resultMarshal, result, textMarshal, text, "int", textLength, parsePosMarshal, parsePos, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Integer} localized 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_applyPattern(format, localized, pattern, patternLength, parseError, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\unum_applyPattern", formatMarshal, format, "char", localized, patternMarshal, pattern, "int", patternLength, "ptr", parseError, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {PSTR} 
     */
    static unum_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\unum_getAvailable", "int", localeIndex, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static unum_countAvailable() {
        result := DllCall("icuin.dll\unum_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} attr 
     * @returns {Integer} 
     */
    static unum_getAttribute(fmt, attr) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\unum_getAttribute", fmtMarshal, fmt, "int", attr, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setAttribute(fmt, attr, newValue) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\unum_setAttribute", fmtMarshal, fmt, "int", attr, "int", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} attr 
     * @returns {Float} 
     */
    static unum_getDoubleAttribute(fmt, attr) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\unum_getDoubleAttribute", fmtMarshal, fmt, "int", attr, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} attr 
     * @param {Float} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setDoubleAttribute(fmt, attr, newValue) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\unum_setDoubleAttribute", fmtMarshal, fmt, "int", attr, "double", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} tag 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_getTextAttribute(fmt, tag, result, resultLength, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_getTextAttribute", fmtMarshal, fmt, "int", tag, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} tag 
     * @param {Pointer<Integer>} newValue 
     * @param {Integer} newValueLength 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setTextAttribute(fmt, tag, newValue, newValueLength, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        newValueMarshal := newValue is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\unum_setTextAttribute", fmtMarshal, fmt, "int", tag, newValueMarshal, newValue, "int", newValueLength, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} isPatternLocalized 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_toPattern(fmt, isPatternLocalized, result, resultLength, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_toPattern", fmtMarshal, fmt, "char", isPatternLocalized, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} symbol 
     * @param {Pointer<Integer>} buffer_R 
     * @param {Integer} size 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_getSymbol(fmt, symbol, buffer_R, size, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        buffer_RMarshal := buffer_R is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_getSymbol", fmtMarshal, fmt, "int", symbol, buffer_RMarshal, buffer_R, "int", size, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} symbol 
     * @param {Pointer<Integer>} value 
     * @param {Integer} length 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setSymbol(fmt, symbol, value, length, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        valueMarshal := value is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\unum_setSymbol", fmtMarshal, fmt, "int", symbol, valueMarshal, value, "int", length, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static unum_getLocaleByType(fmt, type, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_getLocaleByType", fmtMarshal, fmt, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} value 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setContext(fmt, value, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\unum_setContext", fmtMarshal, fmt, "int", value, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unum_getContext(fmt, type, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unum_getContext", fmtMarshal, fmt, "int", type, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} field 
     * @returns {Integer} 
     */
    static udat_toCalendarDateField(field) {
        result := DllCall("icuin.dll\udat_toCalendarDateField", "int", field, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} timeStyle 
     * @param {Integer} dateStyle 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} tzID 
     * @param {Integer} tzIDLength 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static udat_open(timeStyle, dateStyle, locale, tzID, tzIDLength, pattern, patternLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        tzIDMarshal := tzID is VarRef ? "ushort*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_open", "int", timeStyle, "int", dateStyle, "ptr", locale, tzIDMarshal, tzID, "int", tzIDLength, patternMarshal, pattern, "int", patternLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_close(format) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\udat_close", formatMarshal, format, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} attr 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udat_getBooleanAttribute(fmt, attr, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_getBooleanAttribute", fmtMarshal, fmt, "int", attr, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setBooleanAttribute(fmt, attr, newValue, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\udat_setBooleanAttribute", fmtMarshal, fmt, "int", attr, "char", newValue, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static udat_clone(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_clone", fmtMarshal, fmt, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Float} dateToFormat 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udat_format(format, dateToFormat, result, resultLength, position, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_format", formatMarshal, format, "double", dateToFormat, resultMarshal, result, "int", resultLength, "ptr", position, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Pointer<Pointer<Void>>} calendar 
     * @param {Pointer<Integer>} result 
     * @param {Integer} capacity 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udat_formatCalendar(format, calendar, result, capacity, position, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        calendarMarshal := calendar is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_formatCalendar", formatMarshal, format, calendarMarshal, calendar, resultMarshal, result, "int", capacity, "ptr", position, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Float} dateToFormat 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udat_formatForFields(format, dateToFormat, result, resultLength, fpositer, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        fpositerMarshal := fpositer is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_formatForFields", formatMarshal, format, "double", dateToFormat, resultMarshal, result, "int", resultLength, fpositerMarshal, fpositer, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Pointer<Pointer<Void>>} calendar 
     * @param {Pointer<Integer>} result 
     * @param {Integer} capacity 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udat_formatCalendarForFields(format, calendar, result, capacity, fpositer, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        calendarMarshal := calendar is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        fpositerMarshal := fpositer is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_formatCalendarForFields", formatMarshal, format, calendarMarshal, calendar, resultMarshal, result, "int", capacity, fpositerMarshal, fpositer, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} parsePos 
     * @param {Pointer<Integer>} status 
     * @returns {Float} 
     */
    static udat_parse(format, text, textLength, parsePos, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        parsePosMarshal := parsePos is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_parse", formatMarshal, format, textMarshal, text, "int", textLength, parsePosMarshal, parsePos, statusMarshal, status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Pointer<Pointer<Void>>} calendar 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} parsePos 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_parseCalendar(format, calendar, text, textLength, parsePos, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        calendarMarshal := calendar is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        parsePosMarshal := parsePos is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\udat_parseCalendar", formatMarshal, format, calendarMarshal, calendar, textMarshal, text, "int", textLength, parsePosMarshal, parsePos, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @returns {Integer} 
     */
    static udat_isLenient(fmt) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\udat_isLenient", fmtMarshal, fmt, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} isLenient 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setLenient(fmt, isLenient) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\udat_setLenient", fmtMarshal, fmt, "char", isLenient, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static udat_getCalendar(fmt) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\udat_getCalendar", fmtMarshal, fmt, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Pointer<Void>>} calendarToSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setCalendar(fmt, calendarToSet) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        calendarToSetMarshal := calendarToSet is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\udat_setCalendar", fmtMarshal, fmt, calendarToSetMarshal, calendarToSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static udat_getNumberFormat(fmt) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\udat_getNumberFormat", fmtMarshal, fmt, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} field 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static udat_getNumberFormatForField(fmt, field) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\udat_getNumberFormatForField", fmtMarshal, fmt, "ushort", field, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} fields 
     * @param {Pointer<Pointer<Void>>} numberFormatToSet 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_adoptNumberFormatForFields(fmt, fields, numberFormatToSet, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        fieldsMarshal := fields is VarRef ? "ushort*" : "ptr"
        numberFormatToSetMarshal := numberFormatToSet is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\udat_adoptNumberFormatForFields", fmtMarshal, fmt, fieldsMarshal, fields, numberFormatToSetMarshal, numberFormatToSet, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Pointer<Void>>} numberFormatToSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setNumberFormat(fmt, numberFormatToSet) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        numberFormatToSetMarshal := numberFormatToSet is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\udat_setNumberFormat", fmtMarshal, fmt, numberFormatToSetMarshal, numberFormatToSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Pointer<Void>>} numberFormatToAdopt 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_adoptNumberFormat(fmt, numberFormatToAdopt) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        numberFormatToAdoptMarshal := numberFormatToAdopt is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\udat_adoptNumberFormat", fmtMarshal, fmt, numberFormatToAdoptMarshal, numberFormatToAdopt, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {PSTR} 
     */
    static udat_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\udat_getAvailable", "int", localeIndex, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static udat_countAvailable() {
        result := DllCall("icuin.dll\udat_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Pointer<Integer>} status 
     * @returns {Float} 
     */
    static udat_get2DigitYearStart(fmt, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_get2DigitYearStart", fmtMarshal, fmt, statusMarshal, status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Float} d 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_set2DigitYearStart(fmt, d, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\udat_set2DigitYearStart", fmtMarshal, fmt, "double", d, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} localized 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udat_toPattern(fmt, localized, result, resultLength, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_toPattern", fmtMarshal, fmt, "char", localized, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Integer} localized 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_applyPattern(format, localized, pattern, patternLength) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"

        DllCall("icuin.dll\udat_applyPattern", formatMarshal, format, "char", localized, patternMarshal, pattern, "int", patternLength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} type 
     * @param {Integer} symbolIndex 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udat_getSymbols(fmt, type, symbolIndex, result, resultLength, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_getSymbols", fmtMarshal, fmt, "int", type, "int", symbolIndex, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} type 
     * @returns {Integer} 
     */
    static udat_countSymbols(fmt, type) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\udat_countSymbols", fmtMarshal, fmt, "int", type, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} format 
     * @param {Integer} type 
     * @param {Integer} symbolIndex 
     * @param {Pointer<Integer>} value 
     * @param {Integer} valueLength 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setSymbols(format, type, symbolIndex, value, valueLength, status) {
        formatMarshal := format is VarRef ? "ptr*" : "ptr"
        valueMarshal := value is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\udat_setSymbols", formatMarshal, format, "int", type, "int", symbolIndex, valueMarshal, value, "int", valueLength, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static udat_getLocaleByType(fmt, type, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_getLocaleByType", fmtMarshal, fmt, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} value 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setContext(fmt, value, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\udat_setContext", fmtMarshal, fmt, "int", value, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static udat_getContext(fmt, type, status) {
        fmtMarshal := fmt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udat_getContext", fmtMarshal, fmt, "int", type, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static udatpg_open(locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_open", "ptr", locale, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static udatpg_openEmpty(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_openEmpty", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_close(dtpg) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\udatpg_close", dtpgMarshal, dtpg, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static udatpg_clone(dtpg, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_clone", dtpgMarshal, dtpg, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} length 
     * @param {Pointer<Integer>} bestPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBestPattern(dtpg, skeleton, length, bestPattern, capacity, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        bestPatternMarshal := bestPattern is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getBestPattern", dtpgMarshal, dtpg, skeletonMarshal, skeleton, "int", length, bestPatternMarshal, bestPattern, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} length 
     * @param {Integer} options 
     * @param {Pointer<Integer>} bestPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBestPatternWithOptions(dtpg, skeleton, length, options, bestPattern, capacity, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        bestPatternMarshal := bestPattern is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getBestPatternWithOptions", dtpgMarshal, dtpg, skeletonMarshal, skeleton, "int", length, "int", options, bestPatternMarshal, bestPattern, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} unusedDtpg 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} length 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getSkeleton(unusedDtpg, pattern, length, skeleton, capacity, pErrorCode) {
        unusedDtpgMarshal := unusedDtpg is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getSkeleton", unusedDtpgMarshal, unusedDtpg, patternMarshal, pattern, "int", length, skeletonMarshal, skeleton, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} unusedDtpg 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} length 
     * @param {Pointer<Integer>} baseSkeleton 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBaseSkeleton(unusedDtpg, pattern, length, baseSkeleton, capacity, pErrorCode) {
        unusedDtpgMarshal := unusedDtpg is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        baseSkeletonMarshal := baseSkeleton is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getBaseSkeleton", unusedDtpgMarshal, unusedDtpg, patternMarshal, pattern, "int", length, baseSkeletonMarshal, baseSkeleton, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} override 
     * @param {Pointer<Integer>} conflictingPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_addPattern(dtpg, pattern, patternLength, override, conflictingPattern, capacity, pLength, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        conflictingPatternMarshal := conflictingPattern is VarRef ? "ushort*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_addPattern", dtpgMarshal, dtpg, patternMarshal, pattern, "int", patternLength, "char", override, conflictingPatternMarshal, conflictingPattern, "int", capacity, pLengthMarshal, pLength, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<Integer>} value 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setAppendItemFormat(dtpg, field, value, length) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        valueMarshal := value is VarRef ? "ushort*" : "ptr"

        DllCall("icuin.dll\udatpg_setAppendItemFormat", dtpgMarshal, dtpg, "int", field, valueMarshal, value, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<Integer>} pLength 
     * @returns {Pointer<Integer>} 
     */
    static udatpg_getAppendItemFormat(dtpg, field, pLength) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getAppendItemFormat", dtpgMarshal, dtpg, "int", field, pLengthMarshal, pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<Integer>} value 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setAppendItemName(dtpg, field, value, length) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        valueMarshal := value is VarRef ? "ushort*" : "ptr"

        DllCall("icuin.dll\udatpg_setAppendItemName", dtpgMarshal, dtpg, "int", field, valueMarshal, value, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<Integer>} pLength 
     * @returns {Pointer<Integer>} 
     */
    static udatpg_getAppendItemName(dtpg, field, pLength) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getAppendItemName", dtpgMarshal, dtpg, "int", field, pLengthMarshal, pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Integer} field 
     * @param {Integer} width 
     * @param {Pointer<Integer>} fieldName 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getFieldDisplayName(dtpg, field, width, fieldName, capacity, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        fieldNameMarshal := fieldName is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\udatpg_getFieldDisplayName", dtpgMarshal, dtpg, "int", field, "int", width, fieldNameMarshal, fieldName, "int", capacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} dtFormat 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setDateTimeFormat(dtpg, dtFormat, length) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        dtFormatMarshal := dtFormat is VarRef ? "ushort*" : "ptr"

        DllCall("icuin.dll\udatpg_setDateTimeFormat", dtpgMarshal, dtpg, dtFormatMarshal, dtFormat, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pLength 
     * @returns {Pointer<Integer>} 
     */
    static udatpg_getDateTimeFormat(dtpg, pLength) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getDateTimeFormat", dtpgMarshal, dtpg, pLengthMarshal, pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} decimal 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setDecimal(dtpg, decimal, length) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        decimalMarshal := decimal is VarRef ? "ushort*" : "ptr"

        DllCall("icuin.dll\udatpg_setDecimal", dtpgMarshal, dtpg, decimalMarshal, decimal, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pLength 
     * @returns {Pointer<Integer>} 
     */
    static udatpg_getDecimal(dtpg, pLength) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getDecimal", dtpgMarshal, dtpg, pLengthMarshal, pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_replaceFieldTypes(dtpg, pattern, patternLength, skeleton, skeletonLength, dest, destCapacity, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_replaceFieldTypes", dtpgMarshal, dtpg, patternMarshal, pattern, "int", patternLength, skeletonMarshal, skeleton, "int", skeletonLength, destMarshal, dest, "int", destCapacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Integer} options 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_replaceFieldTypesWithOptions(dtpg, pattern, patternLength, skeleton, skeletonLength, options, dest, destCapacity, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_replaceFieldTypesWithOptions", dtpgMarshal, dtpg, patternMarshal, pattern, "int", patternLength, skeletonMarshal, skeleton, "int", skeletonLength, "int", options, destMarshal, dest, "int", destCapacity, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static udatpg_openSkeletons(dtpg, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_openSkeletons", dtpgMarshal, dtpg, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static udatpg_openBaseSkeletons(dtpg, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_openBaseSkeletons", dtpgMarshal, dtpg, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<Integer>} pLength 
     * @returns {Pointer<Integer>} 
     */
    static udatpg_getPatternForSkeleton(dtpg, skeleton, skeletonLength, pLength) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        pLengthMarshal := pLength is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\udatpg_getPatternForSkeleton", dtpgMarshal, dtpg, skeletonMarshal, skeleton, "int", skeletonLength, pLengthMarshal, pLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} dtpg 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getDefaultHourCycle(dtpg, pErrorCode) {
        dtpgMarshal := dtpg is VarRef ? "ptr*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\udatpg_getDefaultHourCycle", dtpgMarshal, dtpg, pErrorCodeMarshal, pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} skeletonLen 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UNumberFormatter>} 
     */
    static unumf_openForSkeletonAndLocale(skeleton, skeletonLen, locale, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumf_openForSkeletonAndLocale", skeletonMarshal, skeleton, "int", skeletonLen, "ptr", locale, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} skeletonLen 
     * @param {PSTR} locale 
     * @param {Pointer<UParseError>} perror 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UNumberFormatter>} 
     */
    static unumf_openForSkeletonAndLocaleWithError(skeleton, skeletonLen, locale, perror, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumf_openForSkeletonAndLocaleWithError", skeletonMarshal, skeleton, "int", skeletonLen, "ptr", locale, "ptr", perror, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedNumber>} 
     */
    static unumf_openResult(ec) {
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumf_openResult", ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberFormatter>} uformatter 
     * @param {Integer} value 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatInt(uformatter, value, uresult, ec) {
        uformatterMarshal := uformatter is VarRef ? "ptr*" : "ptr"
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\unumf_formatInt", uformatterMarshal, uformatter, "int64", value, uresultMarshal, uresult, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UNumberFormatter>} uformatter 
     * @param {Float} value 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatDouble(uformatter, value, uresult, ec) {
        uformatterMarshal := uformatter is VarRef ? "ptr*" : "ptr"
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\unumf_formatDouble", uformatterMarshal, uformatter, "double", value, uresultMarshal, uresult, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UNumberFormatter>} uformatter 
     * @param {PSTR} value 
     * @param {Integer} valueLen 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatDecimal(uformatter, value, valueLen, uresult, ec) {
        value := value is String ? StrPtr(value) : value

        uformatterMarshal := uformatter is VarRef ? "ptr*" : "ptr"
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\unumf_formatDecimal", uformatterMarshal, uformatter, "ptr", value, "int", valueLen, uresultMarshal, uresult, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static unumf_resultAsValue(uresult, ec) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumf_resultAsValue", uresultMarshal, uresult, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Integer>} buffer_R 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static unumf_resultToString(uresult, buffer_R, bufferCapacity, ec) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        buffer_RMarshal := buffer_R is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumf_resultToString", uresultMarshal, uresult, buffer_RMarshal, buffer_R, "int", bufferCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<UFieldPosition>} ufpos 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static unumf_resultNextFieldPosition(uresult, ufpos, ec) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumf_resultNextFieldPosition", uresultMarshal, uresult, "ptr", ufpos, ecMarshal, ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<UFieldPositionIterator>} ufpositer 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_resultGetAllFieldPositions(uresult, ufpositer, ec) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ufpositerMarshal := ufpositer is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\unumf_resultGetAllFieldPositions", uresultMarshal, uresult, ufpositerMarshal, ufpositer, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static unumf_resultToDecimalNumber(uresult, dest, destCapacity, ec) {
        dest := dest is String ? StrPtr(dest) : dest

        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumf_resultToDecimalNumber", uresultMarshal, uresult, "ptr", dest, "int", destCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberFormatter>} uformatter 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_close(uformatter) {
        uformatterMarshal := uformatter is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\unumf_close", uformatterMarshal, uformatter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_closeResult(uresult) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\unumf_closeResult", uresultMarshal, uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} skeleton 
     * @param {Integer} skeletonLen 
     * @param {Integer} collapse 
     * @param {Integer} identityFallback 
     * @param {PSTR} locale 
     * @param {Pointer<UParseError>} perror 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UNumberRangeFormatter>} 
     */
    static unumrf_openForSkeletonWithCollapseAndIdentityFallback(skeleton, skeletonLen, collapse, identityFallback, locale, perror, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        skeletonMarshal := skeleton is VarRef ? "ushort*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumrf_openForSkeletonWithCollapseAndIdentityFallback", skeletonMarshal, skeleton, "int", skeletonLen, "int", collapse, "int", identityFallback, "ptr", locale, "ptr", perror, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedNumberRange>} 
     */
    static unumrf_openResult(ec) {
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumrf_openResult", ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberRangeFormatter>} uformatter 
     * @param {Float} first 
     * @param {Float} second 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumrf_formatDoubleRange(uformatter, first, second, uresult, ec) {
        uformatterMarshal := uformatter is VarRef ? "ptr*" : "ptr"
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\unumrf_formatDoubleRange", uformatterMarshal, uformatter, "double", first, "double", second, uresultMarshal, uresult, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UNumberRangeFormatter>} uformatter 
     * @param {PSTR} first 
     * @param {Integer} firstLen 
     * @param {PSTR} second 
     * @param {Integer} secondLen 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumrf_formatDecimalRange(uformatter, first, firstLen, second, secondLen, uresult, ec) {
        first := first is String ? StrPtr(first) : first
        second := second is String ? StrPtr(second) : second

        uformatterMarshal := uformatter is VarRef ? "ptr*" : "ptr"
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\unumrf_formatDecimalRange", uformatterMarshal, uformatter, "ptr", first, "int", firstLen, "ptr", second, "int", secondLen, uresultMarshal, uresult, ecMarshal, ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static unumrf_resultAsValue(uresult, ec) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumrf_resultAsValue", uresultMarshal, uresult, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static unumrf_resultGetIdentityResult(uresult, ec) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumrf_resultGetIdentityResult", uresultMarshal, uresult, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static unumrf_resultGetFirstDecimalNumber(uresult, dest, destCapacity, ec) {
        dest := dest is String ? StrPtr(dest) : dest

        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumrf_resultGetFirstDecimalNumber", uresultMarshal, uresult, "ptr", dest, "int", destCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} ec 
     * @returns {Integer} 
     */
    static unumrf_resultGetSecondDecimalNumber(uresult, dest, destCapacity, ec) {
        dest := dest is String ? StrPtr(dest) : dest

        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\unumrf_resultGetSecondDecimalNumber", uresultMarshal, uresult, "ptr", dest, "int", destCapacity, ecMarshal, ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberRangeFormatter>} uformatter 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumrf_close(uformatter) {
        uformatterMarshal := uformatter is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\unumrf_close", uformatterMarshal, uformatter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumrf_closeResult(uresult) {
        uresultMarshal := uresult is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\unumrf_closeResult", uresultMarshal, uresult, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UNumberingSystem>} 
     */
    static unumsys_open(locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unumsys_open", "ptr", locale, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} name 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UNumberingSystem>} 
     */
    static unumsys_openByName(name, status) {
        name := name is String ? StrPtr(name) : name

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unumsys_openByName", "ptr", name, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumsys_close(unumsys) {
        unumsysMarshal := unumsys is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\unumsys_close", unumsysMarshal, unumsys, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static unumsys_openAvailableNames(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unumsys_openAvailableNames", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @returns {PSTR} 
     */
    static unumsys_getName(unumsys) {
        unumsysMarshal := unumsys is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\unumsys_getName", unumsysMarshal, unumsys, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @returns {Integer} 
     */
    static unumsys_isAlgorithmic(unumsys) {
        unumsysMarshal := unumsys is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\unumsys_isAlgorithmic", unumsysMarshal, unumsys, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @returns {Integer} 
     */
    static unumsys_getRadix(unumsys) {
        unumsysMarshal := unumsys is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\unumsys_getRadix", unumsysMarshal, unumsys, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static unumsys_getDescription(unumsys, result, resultLength, status) {
        unumsysMarshal := unumsys is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\unumsys_getDescription", unumsysMarshal, unumsys, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UPluralRules>} 
     */
    static uplrules_open(locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uplrules_open", "ptr", locale, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UPluralRules>} 
     */
    static uplrules_openForType(locale, type, status) {
        locale := locale is String ? StrPtr(locale) : locale

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uplrules_openForType", "ptr", locale, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UPluralRules>} uplrules 
     * @returns {String} Nothing - always returns an empty string
     */
    static uplrules_close(uplrules) {
        uplrulesMarshal := uplrules is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\uplrules_close", uplrulesMarshal, uplrules, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UPluralRules>} uplrules 
     * @param {Float} number_R 
     * @param {Pointer<Integer>} keyword 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uplrules_select(uplrules, number_R, keyword, capacity, status) {
        uplrulesMarshal := uplrules is VarRef ? "ptr*" : "ptr"
        keywordMarshal := keyword is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uplrules_select", uplrulesMarshal, uplrules, "double", number_R, keywordMarshal, keyword, "int", capacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UPluralRules>} uplrules 
     * @param {Pointer<UFormattedNumber>} number_R 
     * @param {Pointer<Integer>} keyword 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uplrules_selectFormatted(uplrules, number_R, keyword, capacity, status) {
        uplrulesMarshal := uplrules is VarRef ? "ptr*" : "ptr"
        number_RMarshal := number_R is VarRef ? "ptr*" : "ptr"
        keywordMarshal := keyword is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\uplrules_selectFormatted", uplrulesMarshal, uplrules, number_RMarshal, number_R, keywordMarshal, keyword, "int", capacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UPluralRules>} uplrules 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uplrules_getKeywords(uplrules, status) {
        uplrulesMarshal := uplrules is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uplrules_getKeywords", uplrulesMarshal, uplrules, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<URegularExpression>} 
     */
    static uregex_open(pattern, patternLength, flags, pe, status) {
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_open", patternMarshal, pattern, "int", patternLength, "uint", flags, "ptr", pe, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} pattern 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<URegularExpression>} 
     */
    static uregex_openUText(pattern, flags, pe, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_openUText", "ptr", pattern, "uint", flags, "ptr", pe, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} pattern 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<URegularExpression>} 
     */
    static uregex_openC(pattern, flags, pe, status) {
        pattern := pattern is String ? StrPtr(pattern) : pattern

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_openC", "ptr", pattern, "uint", flags, "ptr", pe, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_close(regexp) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\uregex_close", regexpMarshal, regexp, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<URegularExpression>} 
     */
    static uregex_clone(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_clone", regexpMarshal, regexp, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} patLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static uregex_pattern(regexp, patLength, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        patLengthMarshal := patLength is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_pattern", regexpMarshal, regexp, patLengthMarshal, patLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_patternUText(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_patternUText", regexpMarshal, regexp, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_flags(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_flags", regexpMarshal, regexp, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setText(regexp, text, textLength, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setText", regexpMarshal, regexp, textMarshal, text, "int", textLength, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setUText(regexp, text, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setUText", regexpMarshal, regexp, "ptr", text, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} textLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Integer>} 
     */
    static uregex_getText(regexp, textLength, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        textLengthMarshal := textLength is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_getText", regexpMarshal, regexp, textLengthMarshal, textLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_getUText(regexp, dest, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_getUText", regexpMarshal, regexp, "ptr", dest, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_refreshUText(regexp, text, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_refreshUText", regexpMarshal, regexp, "ptr", text, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_matches(regexp, startIndex, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_matches", regexpMarshal, regexp, "int", startIndex, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_matches64(regexp, startIndex, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_matches64", regexpMarshal, regexp, "int64", startIndex, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_lookingAt(regexp, startIndex, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_lookingAt", regexpMarshal, regexp, "int", startIndex, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_lookingAt64(regexp, startIndex, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_lookingAt64", regexpMarshal, regexp, "int64", startIndex, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_find(regexp, startIndex, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_find", regexpMarshal, regexp, "int", startIndex, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_find64(regexp, startIndex, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_find64", regexpMarshal, regexp, "int64", startIndex, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_findNext(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_findNext", regexpMarshal, regexp, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_groupCount(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_groupCount", regexpMarshal, regexp, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} groupName 
     * @param {Integer} nameLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_groupNumberFromName(regexp, groupName, nameLength, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        groupNameMarshal := groupName is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_groupNumberFromName", regexpMarshal, regexp, groupNameMarshal, groupName, "int", nameLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {PSTR} groupName 
     * @param {Integer} nameLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_groupNumberFromCName(regexp, groupName, nameLength, status) {
        groupName := groupName is String ? StrPtr(groupName) : groupName

        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_groupNumberFromCName", regexpMarshal, regexp, "ptr", groupName, "int", nameLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_group(regexp, groupNum, dest, destCapacity, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_group", regexpMarshal, regexp, "int", groupNum, destMarshal, dest, "int", destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Integer>} groupLength 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_groupUText(regexp, groupNum, dest, groupLength, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        groupLengthMarshal := groupLength is VarRef ? "int64*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_groupUText", regexpMarshal, regexp, "int", groupNum, "ptr", dest, groupLengthMarshal, groupLength, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_start(regexp, groupNum, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_start", regexpMarshal, regexp, "int", groupNum, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_start64(regexp, groupNum, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_start64", regexpMarshal, regexp, "int", groupNum, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_end(regexp, groupNum, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_end", regexpMarshal, regexp, "int", groupNum, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_end64(regexp, groupNum, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_end64", regexpMarshal, regexp, "int", groupNum, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} index 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_reset(regexp, index, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_reset", regexpMarshal, regexp, "int", index, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} index 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_reset64(regexp, index, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_reset64", regexpMarshal, regexp, "int64", index, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegion(regexp, regionStart, regionLimit, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setRegion", regexpMarshal, regexp, "int", regionStart, "int", regionLimit, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegion64(regexp, regionStart, regionLimit, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setRegion64", regexpMarshal, regexp, "int64", regionStart, "int64", regionLimit, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Integer} startIndex 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegionAndStart(regexp, regionStart, regionLimit, startIndex, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setRegionAndStart", regexpMarshal, regexp, "int64", regionStart, "int64", regionLimit, "int64", startIndex, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_regionStart(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_regionStart", regexpMarshal, regexp, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_regionStart64(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_regionStart64", regexpMarshal, regexp, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_regionEnd(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_regionEnd", regexpMarshal, regexp, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_regionEnd64(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_regionEnd64", regexpMarshal, regexp, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_hasTransparentBounds(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_hasTransparentBounds", regexpMarshal, regexp, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} b 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_useTransparentBounds(regexp, b, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_useTransparentBounds", regexpMarshal, regexp, "char", b, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_hasAnchoringBounds(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_hasAnchoringBounds", regexpMarshal, regexp, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} b 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_useAnchoringBounds(regexp, b, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_useAnchoringBounds", regexpMarshal, regexp, "char", b, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_hitEnd(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_hitEnd", regexpMarshal, regexp, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_requireEnd(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_requireEnd", regexpMarshal, regexp, statusMarshal, status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<Integer>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_replaceAll(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        replacementTextMarshal := replacementText is VarRef ? "ushort*" : "ptr"
        destBufMarshal := destBuf is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_replaceAll", regexpMarshal, regexp, replacementTextMarshal, replacementText, "int", replacementLength, destBufMarshal, destBuf, "int", destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} replacement 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_replaceAllUText(regexp, replacement, dest, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_replaceAllUText", regexpMarshal, regexp, "ptr", replacement, "ptr", dest, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<Integer>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_replaceFirst(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        replacementTextMarshal := replacementText is VarRef ? "ushort*" : "ptr"
        destBufMarshal := destBuf is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_replaceFirst", regexpMarshal, regexp, replacementTextMarshal, replacementText, "int", replacementLength, destBufMarshal, destBuf, "int", destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} replacement 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_replaceFirstUText(regexp, replacement, dest, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_replaceFirstUText", regexpMarshal, regexp, "ptr", replacement, "ptr", dest, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<Pointer<Integer>>} destBuf 
     * @param {Pointer<Integer>} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_appendReplacement(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        replacementTextMarshal := replacementText is VarRef ? "ushort*" : "ptr"
        destBufMarshal := destBuf is VarRef ? "ptr*" : "ptr"
        destCapacityMarshal := destCapacity is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_appendReplacement", regexpMarshal, regexp, replacementTextMarshal, replacementText, "int", replacementLength, destBufMarshal, destBuf, destCapacityMarshal, destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} replacementText 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_appendReplacementUText(regexp, replacementText, dest, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_appendReplacementUText", regexpMarshal, regexp, "ptr", replacementText, "ptr", dest, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Pointer<Integer>>} destBuf 
     * @param {Pointer<Integer>} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_appendTail(regexp, destBuf, destCapacity, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        destBufMarshal := destBuf is VarRef ? "ptr*" : "ptr"
        destCapacityMarshal := destCapacity is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_appendTail", regexpMarshal, regexp, destBufMarshal, destBuf, destCapacityMarshal, destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_appendTailUText(regexp, dest, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_appendTailUText", regexpMarshal, regexp, "ptr", dest, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} requiredCapacity 
     * @param {Pointer<Pointer<Integer>>} destFields 
     * @param {Integer} destFieldsCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_split(regexp, destBuf, destCapacity, requiredCapacity, destFields, destFieldsCapacity, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        destBufMarshal := destBuf is VarRef ? "ushort*" : "ptr"
        requiredCapacityMarshal := requiredCapacity is VarRef ? "int*" : "ptr"
        destFieldsMarshal := destFields is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_split", regexpMarshal, regexp, destBufMarshal, destBuf, "int", destCapacity, requiredCapacityMarshal, requiredCapacity, destFieldsMarshal, destFields, "int", destFieldsCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Pointer<UText>>} destFields 
     * @param {Integer} destFieldsCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_splitUText(regexp, destFields, destFieldsCapacity, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        destFieldsMarshal := destFields is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_splitUText", regexpMarshal, regexp, destFieldsMarshal, destFields, "int", destFieldsCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} limit 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setTimeLimit(regexp, limit, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setTimeLimit", regexpMarshal, regexp, "int", limit, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_getTimeLimit(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_getTimeLimit", regexpMarshal, regexp, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} limit 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setStackLimit(regexp, limit, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setStackLimit", regexpMarshal, regexp, "int", limit, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uregex_getStackLimit(regexp, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregex_getStackLimit", regexpMarshal, regexp, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<URegexMatchCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setMatchCallback(regexp, callback, context, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setMatchCallback", regexpMarshal, regexp, "ptr", callback, contextMarshal, context, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Pointer<URegexMatchCallback>>} callback 
     * @param {Pointer<Pointer<Void>>} context 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_getMatchCallback(regexp, callback, context, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        callbackMarshal := callback is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_getMatchCallback", regexpMarshal, regexp, callbackMarshal, callback, contextMarshal, context, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<URegexFindProgressCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setFindProgressCallback(regexp, callback, context, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_setFindProgressCallback", regexpMarshal, regexp, "ptr", callback, contextMarshal, context, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Pointer<URegexFindProgressCallback>>} callback 
     * @param {Pointer<Pointer<Void>>} context 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_getFindProgressCallback(regexp, callback, context, status) {
        regexpMarshal := regexp is VarRef ? "ptr*" : "ptr"
        callbackMarshal := callback is VarRef ? "ptr*" : "ptr"
        contextMarshal := context is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uregex_getFindProgressCallback", regexpMarshal, regexp, callbackMarshal, callback, contextMarshal, context, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} regionCode 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<URegion>} 
     */
    static uregion_getRegionFromCode(regionCode, status) {
        regionCode := regionCode is String ? StrPtr(regionCode) : regionCode

        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregion_getRegionFromCode", "ptr", regionCode, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} code 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<URegion>} 
     */
    static uregion_getRegionFromNumericCode(code, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregion_getRegionFromNumericCode", "int", code, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uregion_getAvailable(type, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregion_getAvailable", "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Pointer<URegion>} otherRegion 
     * @returns {Integer} 
     */
    static uregion_areEqual(uregion, otherRegion) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"
        otherRegionMarshal := otherRegion is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\uregion_areEqual", uregionMarshal, uregion, otherRegionMarshal, otherRegion, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @returns {Pointer<URegion>} 
     */
    static uregion_getContainingRegion(uregion) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\uregion_getContainingRegion", uregionMarshal, uregion, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Integer} type 
     * @returns {Pointer<URegion>} 
     */
    static uregion_getContainingRegionOfType(uregion, type) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\uregion_getContainingRegionOfType", uregionMarshal, uregion, "int", type, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uregion_getContainedRegions(uregion, status) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregion_getContainedRegions", uregionMarshal, uregion, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Integer} type 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uregion_getContainedRegionsOfType(uregion, type, status) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregion_getContainedRegionsOfType", uregionMarshal, uregion, "int", type, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Pointer<URegion>} otherRegion 
     * @returns {Integer} 
     */
    static uregion_contains(uregion, otherRegion) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"
        otherRegionMarshal := otherRegion is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\uregion_contains", uregionMarshal, uregion, otherRegionMarshal, otherRegion, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uregion_getPreferredValues(uregion, status) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uregion_getPreferredValues", uregionMarshal, uregion, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @returns {PSTR} 
     */
    static uregion_getRegionCode(uregion) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\uregion_getRegionCode", uregionMarshal, uregion, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @returns {Integer} 
     */
    static uregion_getNumericCode(uregion) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\uregion_getNumericCode", uregionMarshal, uregion, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @returns {Integer} 
     */
    static uregion_getType(uregion) {
        uregionMarshal := uregion is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\uregion_getType", uregionMarshal, uregion, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Pointer<Void>>} nfToAdopt 
     * @param {Integer} width 
     * @param {Integer} capitalizationContext 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<URelativeDateTimeFormatter>} 
     */
    static ureldatefmt_open(locale, nfToAdopt, width, capitalizationContext, status) {
        locale := locale is String ? StrPtr(locale) : locale

        nfToAdoptMarshal := nfToAdopt is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ureldatefmt_open", "ptr", locale, nfToAdoptMarshal, nfToAdopt, "int", width, "int", capitalizationContext, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_close(reldatefmt) {
        reldatefmtMarshal := reldatefmt is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\ureldatefmt_close", reldatefmtMarshal, reldatefmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedRelativeDateTime>} 
     */
    static ureldatefmt_openResult(ec) {
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ureldatefmt_openResult", ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedRelativeDateTime>} ufrdt 
     * @param {Pointer<Integer>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static ureldatefmt_resultAsValue(ufrdt, ec) {
        ufrdtMarshal := ufrdt is VarRef ? "ptr*" : "ptr"
        ecMarshal := ec is VarRef ? "int*" : "ptr"

        result := DllCall("icu.dll\ureldatefmt_resultAsValue", ufrdtMarshal, ufrdt, ecMarshal, ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedRelativeDateTime>} ufrdt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_closeResult(ufrdt) {
        ufrdtMarshal := ufrdt is VarRef ? "ptr*" : "ptr"

        DllCall("icu.dll\ureldatefmt_closeResult", ufrdtMarshal, ufrdt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_formatNumeric(reldatefmt, offset, unit, result, resultCapacity, status) {
        reldatefmtMarshal := reldatefmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ureldatefmt_formatNumeric", reldatefmtMarshal, reldatefmt, "double", offset, "int", unit, resultMarshal, result, "int", resultCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<UFormattedRelativeDateTime>} result 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_formatNumericToResult(reldatefmt, offset, unit, result, status) {
        reldatefmtMarshal := reldatefmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ureldatefmt_formatNumericToResult", reldatefmtMarshal, reldatefmt, "double", offset, "int", unit, resultMarshal, result, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_format(reldatefmt, offset, unit, result, resultCapacity, status) {
        reldatefmtMarshal := reldatefmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ureldatefmt_format", reldatefmtMarshal, reldatefmt, "double", offset, "int", unit, resultMarshal, result, "int", resultCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<UFormattedRelativeDateTime>} result 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_formatToResult(reldatefmt, offset, unit, result, status) {
        reldatefmtMarshal := reldatefmt is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icu.dll\ureldatefmt_formatToResult", reldatefmtMarshal, reldatefmt, "double", offset, "int", unit, resultMarshal, result, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Pointer<Integer>} relativeDateString 
     * @param {Integer} relativeDateStringLen 
     * @param {Pointer<Integer>} timeString 
     * @param {Integer} timeStringLen 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_combineDateAndTime(reldatefmt, relativeDateString, relativeDateStringLen, timeString, timeStringLen, result, resultCapacity, status) {
        reldatefmtMarshal := reldatefmt is VarRef ? "ptr*" : "ptr"
        relativeDateStringMarshal := relativeDateString is VarRef ? "ushort*" : "ptr"
        timeStringMarshal := timeString is VarRef ? "ushort*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\ureldatefmt_combineDateAndTime", reldatefmtMarshal, reldatefmt, relativeDateStringMarshal, relativeDateString, "int", relativeDateStringLen, timeStringMarshal, timeString, "int", timeStringLen, resultMarshal, result, "int", resultCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textlength 
     * @param {PSTR} locale 
     * @param {Pointer<UBreakIterator>} breakiter 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UStringSearch>} 
     */
    static usearch_open(pattern, patternlength, text, textlength, locale, breakiter, status) {
        locale := locale is String ? StrPtr(locale) : locale

        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        breakiterMarshal := breakiter is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_open", patternMarshal, pattern, "int", patternlength, textMarshal, text, "int", textlength, "ptr", locale, breakiterMarshal, breakiter, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textlength 
     * @param {Pointer<UCollator>} collator 
     * @param {Pointer<UBreakIterator>} breakiter 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<UStringSearch>} 
     */
    static usearch_openFromCollator(pattern, patternlength, text, textlength, collator, breakiter, status) {
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        collatorMarshal := collator is VarRef ? "ptr*" : "ptr"
        breakiterMarshal := breakiter is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_openFromCollator", patternMarshal, pattern, "int", patternlength, textMarshal, text, "int", textlength, collatorMarshal, collator, breakiterMarshal, breakiter, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} searchiter 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_close(searchiter) {
        searchiterMarshal := searchiter is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\usearch_close", searchiterMarshal, searchiter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setOffset(strsrch, position, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\usearch_setOffset", strsrchMarshal, strsrch, "int", position, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getOffset(strsrch) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\usearch_getOffset", strsrchMarshal, strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} attribute 
     * @param {Integer} value 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setAttribute(strsrch, attribute, value, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\usearch_setAttribute", strsrchMarshal, strsrch, "int", attribute, "int", value, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} attribute 
     * @returns {Integer} 
     */
    static usearch_getAttribute(strsrch, attribute) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\usearch_getAttribute", strsrchMarshal, strsrch, "int", attribute, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getMatchedStart(strsrch) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\usearch_getMatchedStart", strsrchMarshal, strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getMatchedLength(strsrch) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\usearch_getMatchedLength", strsrchMarshal, strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static usearch_getMatchedText(strsrch, result, resultCapacity, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_getMatchedText", strsrchMarshal, strsrch, resultMarshal, result, "int", resultCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<UBreakIterator>} breakiter 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setBreakIterator(strsrch, breakiter, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        breakiterMarshal := breakiter is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\usearch_setBreakIterator", strsrchMarshal, strsrch, breakiterMarshal, breakiter, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Pointer<UBreakIterator>} 
     */
    static usearch_getBreakIterator(strsrch) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\usearch_getBreakIterator", strsrchMarshal, strsrch, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} text 
     * @param {Integer} textlength 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setText(strsrch, text, textlength, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\usearch_setText", strsrchMarshal, strsrch, textMarshal, text, "int", textlength, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} length 
     * @returns {Pointer<Integer>} 
     */
    static usearch_getText(strsrch, length) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        lengthMarshal := length is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_getText", strsrchMarshal, strsrch, lengthMarshal, length, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Pointer<UCollator>} 
     */
    static usearch_getCollator(strsrch) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\usearch_getCollator", strsrchMarshal, strsrch, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<UCollator>} collator 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setCollator(strsrch, collator, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        collatorMarshal := collator is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\usearch_setCollator", strsrchMarshal, strsrch, collatorMarshal, collator, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setPattern(strsrch, pattern, patternlength, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        patternMarshal := pattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\usearch_setPattern", strsrchMarshal, strsrch, patternMarshal, pattern, "int", patternlength, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} length 
     * @returns {Pointer<Integer>} 
     */
    static usearch_getPattern(strsrch, length) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        lengthMarshal := length is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_getPattern", strsrchMarshal, strsrch, lengthMarshal, length, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static usearch_first(strsrch, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_first", strsrchMarshal, strsrch, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static usearch_following(strsrch, position, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_following", strsrchMarshal, strsrch, "int", position, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static usearch_last(strsrch, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_last", strsrchMarshal, strsrch, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static usearch_preceding(strsrch, position, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_preceding", strsrchMarshal, strsrch, "int", position, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static usearch_next(strsrch, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_next", strsrchMarshal, strsrch, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static usearch_previous(strsrch, status) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\usearch_previous", strsrchMarshal, strsrch, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_reset(strsrch) {
        strsrchMarshal := strsrch is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\usearch_reset", strsrchMarshal, strsrch, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USpoofChecker>} 
     */
    static uspoof_open(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_open", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} data 
     * @param {Integer} length 
     * @param {Pointer<Integer>} pActualLength 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<USpoofChecker>} 
     */
    static uspoof_openFromSerialized(data, length, pActualLength, pErrorCode) {
        dataMarshal := data is VarRef ? "ptr" : "ptr"
        pActualLengthMarshal := pActualLength is VarRef ? "int*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_openFromSerialized", dataMarshal, data, "int", length, pActualLengthMarshal, pActualLength, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} confusables 
     * @param {Integer} confusablesLen 
     * @param {PSTR} confusablesWholeScript 
     * @param {Integer} confusablesWholeScriptLen 
     * @param {Pointer<Integer>} errType 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USpoofChecker>} 
     */
    static uspoof_openFromSource(confusables, confusablesLen, confusablesWholeScript, confusablesWholeScriptLen, errType, pe, status) {
        confusables := confusables is String ? StrPtr(confusables) : confusables
        confusablesWholeScript := confusablesWholeScript is String ? StrPtr(confusablesWholeScript) : confusablesWholeScript

        errTypeMarshal := errType is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_openFromSource", "ptr", confusables, "int", confusablesLen, "ptr", confusablesWholeScript, "int", confusablesWholeScriptLen, errTypeMarshal, errType, "ptr", pe, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_close(sc) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\uspoof_close", scMarshal, sc, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USpoofChecker>} 
     */
    static uspoof_clone(sc, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_clone", scMarshal, sc, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Integer} checks 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setChecks(sc, checks, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uspoof_setChecks", scMarshal, sc, "int", checks, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_getChecks(sc, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getChecks", scMarshal, sc, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Integer} restrictionLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setRestrictionLevel(sc, restrictionLevel) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\uspoof_setRestrictionLevel", scMarshal, sc, "int", restrictionLevel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @returns {Integer} 
     */
    static uspoof_getRestrictionLevel(sc) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getRestrictionLevel", scMarshal, sc, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {PSTR} localesList 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setAllowedLocales(sc, localesList, status) {
        localesList := localesList is String ? StrPtr(localesList) : localesList

        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uspoof_setAllowedLocales", scMarshal, sc, "ptr", localesList, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Integer>} status 
     * @returns {PSTR} 
     */
    static uspoof_getAllowedLocales(sc, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getAllowedLocales", scMarshal, sc, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<USet>} chars 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setAllowedChars(sc, chars, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        charsMarshal := chars is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\uspoof_setAllowedChars", scMarshal, sc, charsMarshal, chars, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USet>} 
     */
    static uspoof_getAllowedChars(sc, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getAllowedChars", scMarshal, sc, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Integer>} id 
     * @param {Integer} length 
     * @param {Pointer<Integer>} position 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_check(sc, id, length, position, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        idMarshal := id is VarRef ? "ushort*" : "ptr"
        positionMarshal := position is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_check", scMarshal, sc, idMarshal, id, "int", length, positionMarshal, position, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {PSTR} id 
     * @param {Integer} length 
     * @param {Pointer<Integer>} position 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_checkUTF8(sc, id, length, position, status) {
        id := id is String ? StrPtr(id) : id

        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        positionMarshal := position is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_checkUTF8", scMarshal, sc, "ptr", id, "int", length, positionMarshal, position, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Integer>} id 
     * @param {Integer} length 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_check2(sc, id, length, checkResult, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        idMarshal := id is VarRef ? "ushort*" : "ptr"
        checkResultMarshal := checkResult is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_check2", scMarshal, sc, idMarshal, id, "int", length, checkResultMarshal, checkResult, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {PSTR} id 
     * @param {Integer} length 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_check2UTF8(sc, id, length, checkResult, status) {
        id := id is String ? StrPtr(id) : id

        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        checkResultMarshal := checkResult is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_check2UTF8", scMarshal, sc, "ptr", id, "int", length, checkResultMarshal, checkResult, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USpoofCheckResult>} 
     */
    static uspoof_openCheckResult(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_openCheckResult", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_closeCheckResult(checkResult) {
        checkResultMarshal := checkResult is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\uspoof_closeCheckResult", checkResultMarshal, checkResult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_getCheckResultChecks(checkResult, status) {
        checkResultMarshal := checkResult is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getCheckResultChecks", checkResultMarshal, checkResult, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_getCheckResultRestrictionLevel(checkResult, status) {
        checkResultMarshal := checkResult is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getCheckResultRestrictionLevel", checkResultMarshal, checkResult, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USet>} 
     */
    static uspoof_getCheckResultNumerics(checkResult, status) {
        checkResultMarshal := checkResult is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getCheckResultNumerics", checkResultMarshal, checkResult, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Integer>} id1 
     * @param {Integer} length1 
     * @param {Pointer<Integer>} id2 
     * @param {Integer} length2 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_areConfusable(sc, id1, length1, id2, length2, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        id1Marshal := id1 is VarRef ? "ushort*" : "ptr"
        id2Marshal := id2 is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_areConfusable", scMarshal, sc, id1Marshal, id1, "int", length1, id2Marshal, id2, "int", length2, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {PSTR} id1 
     * @param {Integer} length1 
     * @param {PSTR} id2 
     * @param {Integer} length2 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_areConfusableUTF8(sc, id1, length1, id2, length2, status) {
        id1 := id1 is String ? StrPtr(id1) : id1
        id2 := id2 is String ? StrPtr(id2) : id2

        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_areConfusableUTF8", scMarshal, sc, "ptr", id1, "int", length1, "ptr", id2, "int", length2, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Integer} type 
     * @param {Pointer<Integer>} id 
     * @param {Integer} length 
     * @param {Pointer<Integer>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_getSkeleton(sc, type, id, length, dest, destCapacity, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        idMarshal := id is VarRef ? "ushort*" : "ptr"
        destMarshal := dest is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getSkeleton", scMarshal, sc, "uint", type, idMarshal, id, "int", length, destMarshal, dest, "int", destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Integer} type 
     * @param {PSTR} id 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_getSkeletonUTF8(sc, type, id, length, dest, destCapacity, status) {
        id := id is String ? StrPtr(id) : id
        dest := dest is String ? StrPtr(dest) : dest

        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getSkeletonUTF8", scMarshal, sc, "uint", type, "ptr", id, "int", length, "ptr", dest, "int", destCapacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USet>} 
     */
    static uspoof_getInclusionSet(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getInclusionSet", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USet>} 
     */
    static uspoof_getRecommendedSet(status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_getRecommendedSet", statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Void>} data 
     * @param {Integer} capacity 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static uspoof_serialize(sc, data, capacity, status) {
        scMarshal := sc is VarRef ? "ptr*" : "ptr"
        dataMarshal := data is VarRef ? "ptr" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\uspoof_serialize", scMarshal, sc, dataMarshal, data, "int", capacity, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} timeScale 
     * @param {Integer} value 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static utmscale_getTimeScaleValue(timeScale, value, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utmscale_getTimeScaleValue", "int", timeScale, "int", value, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Integer} otherTime 
     * @param {Integer} timeScale 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static utmscale_fromInt64(otherTime, timeScale, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utmscale_fromInt64", "int64", otherTime, "int", timeScale, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Integer} universalTime 
     * @param {Integer} timeScale 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static utmscale_toInt64(universalTime, timeScale, status) {
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utmscale_toInt64", "int64", universalTime, "int", timeScale, statusMarshal, status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} id 
     * @param {Integer} idLength 
     * @param {Integer} dir 
     * @param {Pointer<Integer>} rules 
     * @param {Integer} rulesLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static utrans_openU(id, idLength, dir, rules, rulesLength, parseError, pErrorCode) {
        idMarshal := id is VarRef ? "ushort*" : "ptr"
        rulesMarshal := rules is VarRef ? "ushort*" : "ptr"
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utrans_openU", idMarshal, id, "int", idLength, "int", dir, rulesMarshal, rules, "int", rulesLength, "ptr", parseError, pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static utrans_openInverse(trans, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utrans_openInverse", transMarshal, trans, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<Pointer<Void>>} 
     */
    static utrans_clone(trans, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utrans_clone", transMarshal, trans, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_close(trans) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"

        DllCall("icuin.dll\utrans_close", transMarshal, trans, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Pointer<Integer>} resultLength 
     * @returns {Pointer<Integer>} 
     */
    static utrans_getUnicodeID(trans, resultLength) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        resultLengthMarshal := resultLength is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utrans_getUnicodeID", transMarshal, trans, resultLengthMarshal, resultLength, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} adoptedTrans 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_register(adoptedTrans, status) {
        adoptedTransMarshal := adoptedTrans is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\utrans_register", adoptedTransMarshal, adoptedTrans, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Integer>} id 
     * @param {Integer} idLength 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_unregisterID(id, idLength) {
        idMarshal := id is VarRef ? "ushort*" : "ptr"

        DllCall("icuin.dll\utrans_unregisterID", idMarshal, id, "int", idLength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Pointer<Integer>} filterPattern 
     * @param {Integer} filterPatternLen 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_setFilter(trans, filterPattern, filterPatternLen, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        filterPatternMarshal := filterPattern is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\utrans_setFilter", transMarshal, trans, filterPatternMarshal, filterPattern, "int", filterPatternLen, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @returns {Integer} 
     */
    static utrans_countAvailableIDs() {
        result := DllCall("icuin.dll\utrans_countAvailableIDs", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static utrans_openIDs(pErrorCode) {
        pErrorCodeMarshal := pErrorCode is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utrans_openIDs", pErrorCodeMarshal, pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Pointer<Pointer<Void>>} rep 
     * @param {Pointer<UReplaceableCallbacks>} repFunc 
     * @param {Integer} start 
     * @param {Pointer<Integer>} limit 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_trans(trans, rep, repFunc, start, limit, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        repMarshal := rep is VarRef ? "ptr*" : "ptr"
        limitMarshal := limit is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\utrans_trans", transMarshal, trans, repMarshal, rep, "ptr", repFunc, "int", start, limitMarshal, limit, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Pointer<Pointer<Void>>} rep 
     * @param {Pointer<UReplaceableCallbacks>} repFunc 
     * @param {Pointer<UTransPosition>} pos 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transIncremental(trans, rep, repFunc, pos, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        repMarshal := rep is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\utrans_transIncremental", transMarshal, trans, repMarshal, rep, "ptr", repFunc, "ptr", pos, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Pointer<Integer>} text 
     * @param {Pointer<Integer>} textLength 
     * @param {Integer} textCapacity 
     * @param {Integer} start 
     * @param {Pointer<Integer>} limit 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transUChars(trans, text, textLength, textCapacity, start, limit, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        textLengthMarshal := textLength is VarRef ? "int*" : "ptr"
        limitMarshal := limit is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\utrans_transUChars", transMarshal, trans, textMarshal, text, textLengthMarshal, textLength, "int", textCapacity, "int", start, limitMarshal, limit, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Pointer<Integer>} text 
     * @param {Pointer<Integer>} textLength 
     * @param {Integer} textCapacity 
     * @param {Pointer<UTransPosition>} pos 
     * @param {Pointer<Integer>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transIncrementalUChars(trans, text, textLength, textCapacity, pos, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        textMarshal := text is VarRef ? "ushort*" : "ptr"
        textLengthMarshal := textLength is VarRef ? "int*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        DllCall("icuin.dll\utrans_transIncrementalUChars", transMarshal, trans, textMarshal, text, textLengthMarshal, textLength, "int", textCapacity, "ptr", pos, statusMarshal, status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Integer} escapeUnprintable 
     * @param {Pointer<Integer>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Integer>} status 
     * @returns {Integer} 
     */
    static utrans_toRules(trans, escapeUnprintable, result, resultLength, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        resultMarshal := result is VarRef ? "ushort*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utrans_toRules", transMarshal, trans, "char", escapeUnprintable, resultMarshal, result, "int", resultLength, statusMarshal, status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Pointer<Void>>} trans 
     * @param {Integer} ignoreFilter 
     * @param {Pointer<USet>} fillIn 
     * @param {Pointer<Integer>} status 
     * @returns {Pointer<USet>} 
     */
    static utrans_getSourceSet(trans, ignoreFilter, fillIn, status) {
        transMarshal := trans is VarRef ? "ptr*" : "ptr"
        fillInMarshal := fillIn is VarRef ? "ptr*" : "ptr"
        statusMarshal := status is VarRef ? "int*" : "ptr"

        result := DllCall("icuin.dll\utrans_getSourceSet", transMarshal, trans, "char", ignoreFilter, fillInMarshal, fillIn, statusMarshal, status, "CDecl ptr")
        return result
    }

    /**
     * Determines the distance between the specified language code and the closest match in a list of languages.
     * @remarks
     * You can use this function for localization to find the closest match to a candidate language in the list of user languages.
     * @param {PWSTR} pszLanguage Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A [BCP-47](https://tools.ietf.org/html/bcp47) language tag that represents the candidate language.
     * @param {PWSTR} pszLanguagesList Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A character delimited list of [BCP-47](https://tools.ietf.org/html/bcp47) language tags to compare to the candidate language. This is typically the list of user languages.
     * 
     * If the *wchListDelimiter* parameter is `L'\0'`, then the *pszLanguagesList* is a double null-terminated list of language tags.
     * Otherwise, the *pszLanguagesList* is a null-terminated string in which the language tags are separated by the provided delimiter.
     * @param {Integer} wchListDelimiter Type: **[wchar_t](/windows/win32/midl/wchar-t)**
     * 
     * The character used as a delimiter in the language list, or `L'\0'` to indicate that the language list is a double null-terminated list.
     * The function is slightly more efficient if this parameter is `L'\0'`.
     * @returns {Float} Type: **[double](/windows/win32/midl/double)**
     * 
     * Receives the distance between the candidate language and the closest language in the list.
     * The value is in the range 0.0 to 1.0, where 1.0 is an exact match.
     * @see https://learn.microsoft.com/windows/win32/api/bcp47mrm/nf-bcp47mrm-getdistanceofclosestlanguageinlist
     */
    static GetDistanceOfClosestLanguageInList(pszLanguage, pszLanguagesList, wchListDelimiter) {
        pszLanguage := pszLanguage is String ? StrPtr(pszLanguage) : pszLanguage
        pszLanguagesList := pszLanguagesList is String ? StrPtr(pszLanguagesList) : pszLanguagesList

        result := DllCall("bcp47mrm.dll\GetDistanceOfClosestLanguageInList", "ptr", pszLanguage, "ptr", pszLanguagesList, "char", wchListDelimiter, "double*", &pClosestDistance := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pClosestDistance
    }

    /**
     * Determines whether a BCP-47 language tag is well-formed.
     * @remarks
     * If this function returns `true`, an application can safely construct a Windows Runtime [Language](https://docs.microsoft.com/uwp/api/Windows.Globalization.Language) by using this tag. If it returns `false`, attempting to construct a Language for the given tag will throw an exception.
     * @param {PWSTR} pszTag Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A [BCP-47](https://tools.ietf.org/html/bcp47) language tag.
     * @returns {Integer} `true` if the language tag is well-formed as defined by [BCP-47](https://tools.ietf.org/html/bcp47), except when the language tag can never be valid according to BCP-47. Otherwise it returns `false`.
     * @see https://learn.microsoft.com/windows/win32/api/bcp47mrm/nf-bcp47mrm-iswellformedtag
     */
    static IsWellFormedTag(pszTag) {
        pszTag := pszTag is String ? StrPtr(pszTag) : pszTag

        result := DllCall("bcp47mrm.dll\IsWellFormedTag", "ptr", pszTag, "char")
        return result
    }

    /**
     * Deprecated. Gets the supported date range for a specified calendar.
     * @remarks
     * The earliest date supported by this function is January 1, 1601.
     * 
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * @param {Integer} Calendar [Calendar identifier](calendar-identifiers.md) for which to get the supported date range.
     * @param {Pointer<CALDATETIME>} lpCalMinDateTime Pointer to a [**CALDATETIME**](caldatetime.md) structure defining the minimum supported date.
     * @param {Pointer<CALDATETIME>} lpCalMaxDateTime Pointer to a [**CALDATETIME**](caldatetime.md) structure defining the maximum supported date.
     * @returns {BOOL} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/getcalendarsupporteddaterange
     */
    static GetCalendarSupportedDateRange(Calendar, lpCalMinDateTime, lpCalMaxDateTime) {
        result := DllCall("KERNEL32.dll\GetCalendarSupportedDateRange", "uint", Calendar, "ptr", lpCalMinDateTime, "ptr", lpCalMaxDateTime, "int")
        return result
    }

    /**
     * Deprecated.
     * @remarks
     * The earliest date supported by this function is January 1, 1601.
     * 
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with that module handle and the name of this function to get the function address.
     * @param {PWSTR} lpszLocale Pointer to a locale name, or one of the following predefined values.
     * 
     * -   [LOCALE\_NAME\_INVARIANT](locale-name-constants.md)
     * -   [LOCALE\_NAME\_SYSTEM\_DEFAULT](locale-name-constants.md)
     * -   [LOCALE\_NAME\_USER\_DEFAULT](locale-name-constants.md)
     * @param {Integer} dwFlags Flags specifying date format options. If *lpFormat* is not set to **NULL**, this parameter must be set to 0. If *lpFormat* is set to **NULL**, the application can specify a combination of the following values and [LOCALE\_NOUSEROVERRIDE](locale-nouseroverride.md).
     * 
     * 
     * 
     * | Value                                                                                                                                                               | Meaning                                                                                                                       |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="DATE_SHORTDATE"></span><span id="date_shortdate"></span><dl> <dt>**DATE\_SHORTDATE**</dt> </dl>    | Use the short date format. This is the default. This value cannot be used with DATE\_LONGDATE or DATE\_YEARMONTH. <br/> |
     * | <span id="DATE_LONGDATE"></span><span id="date_longdate"></span><dl> <dt>**DATE\_LONGDATE**</dt> </dl>       | Use the long date format. This value cannot be used with DATE\_SHORTDATE or DATE\_YEARMONTH. <br/>                      |
     * | <span id="DATE_YEARMONTH"></span><span id="date_yearmonth"></span><dl> <dt>**DATE\_YEARMONTH**</dt> </dl>    | Use the year/month format. This value cannot be used with DATE\_SHORTDATE or DATE\_LONGDATE.<br/>                       |
     * | <span id="DATE_LTRREADING"></span><span id="date_ltrreading"></span><dl> <dt>**DATE\_LTRREADING**</dt> </dl> | Add marks for left-to-right reading layout. This value cannot be used with DATE\_RTLREADING.<br/>                       |
     * | <span id="DATE_RTLREADING"></span><span id="date_rtlreading"></span><dl> <dt>**DATE\_RTLREADING**</dt> </dl> | Add marks for right-to-left reading layout. This value cannot be used with DATE\_LTRREADING<br/>                        |
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to a [**CALDATETIME**](caldatetime.md) structure that contains the date and calendar information to format.
     * @param {PWSTR} lpFormat Pointer to a format picture string that is used to form the date string. Possible values for the format picture string are defined in [Day, Month, Year, and Era Format Pictures](day--month--year--and-era-format-pictures.md).
     * 
     * The format picture string must be null-terminated. The function uses the locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application sets this parameter to **NULL** if the function is to use the date format of the specified locale.
     * @param {PWSTR} lpDateStr Pointer to a buffer in which this function receives the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the *lpDateStr* buffer. Alternatively, the application can set this parameter to 0. In this case, the function returns the number of characters required to hold the formatted date string, and the *lpDateStr* parameter is not used.
     * @returns {BOOL} Returns the number of characters written to the *lpDateStr* buffer if successful. If the *cchDate* parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_DATE\_OUT\_OF\_RANGE. The specified date was out of range.
     * -   ERROR\_INSUFFICIENT\_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to **NULL**.
     * -   ERROR\_INVALID\_FLAGS. The values supplied for flags were not valid.
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/getcalendardateformatex
     */
    static GetCalendarDateFormatEx(lpszLocale, dwFlags, lpCalDateTime, lpFormat, lpDateStr, cchDate) {
        lpszLocale := lpszLocale is String ? StrPtr(lpszLocale) : lpszLocale
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDateStr := lpDateStr is String ? StrPtr(lpDateStr) : lpDateStr

        result := DllCall("KERNEL32.dll\GetCalendarDateFormatEx", "ptr", lpszLocale, "uint", dwFlags, "ptr", lpCalDateTime, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "int")
        return result
    }

    /**
     * Deprecated. Converts a specified SYSTEMTIME structure to a CALDATETIME structure.
     * @remarks
     * The earliest date supported by this function is January 1, 1601.
     * 
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * @param {Pointer<SYSTEMTIME>} lpSysTime Pointer to the [**SYSTEMTIME**](/windows/win32/api/minwinbase/ns-minwinbase-systemtime) structure to convert.
     * @param {Integer} calId The system [calendar identifier](calendar-identifiers.md) to use in the conversion.
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to the equivalent [**CALDATETIME**](caldatetime.md) structure.
     * @returns {BOOL} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/convertsystemtimetocaldatetime
     */
    static ConvertSystemTimeToCalDateTime(lpSysTime, calId, lpCalDateTime) {
        result := DllCall("KERNEL32.dll\ConvertSystemTimeToCalDateTime", "ptr", lpSysTime, "uint", calId, "ptr", lpCalDateTime, "int")
        return result
    }

    /**
     * Deprecated. Gets the day of the week that corresponds to a specified day and populates the DayOfWeek member in the specified CALDATETIME structure with that value.
     * @remarks
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with that module handle and the name of this function to get the function address.
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to the [**CALDATETIME**](caldatetime.md) structure containing the date for which to set the day of the week.
     * @returns {BOOL} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_DATE\_OUT\_OF\_RANGE. The specified date was out of range.
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/updatecalendardayofweek
     */
    static UpdateCalendarDayOfWeek(lpCalDateTime) {
        result := DllCall("KERNEL32.dll\UpdateCalendarDayOfWeek", "ptr", lpCalDateTime, "int")
        return result
    }

    /**
     * Deprecated. Adjusts a date by a specified number of years, months, weeks, or days.
     * @remarks
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to a [**CALDATETIME**](caldatetime.md) structure that contains the date and calendar information to adjust.
     * @param {Integer} calUnit The [**CALDATETIME\_DATEUNIT**](caldatetime-dateunit.md) enumeration value indicating the date unit, for example, DayUnit.
     * @param {Integer} amount The amount by which to adjust the specified date.
     * @returns {BOOL} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_DATE\_OUT\_OF\_RANGE. The specified date was out of range.
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/adjustcalendardate
     */
    static AdjustCalendarDate(lpCalDateTime, calUnit, amount) {
        result := DllCall("KERNEL32.dll\AdjustCalendarDate", "ptr", lpCalDateTime, "int", calUnit, "int", amount, "int")
        return result
    }

    /**
     * Deprecated. Converts a specified CALDATETIME structure to a SYSTEMTIME structure.
     * @remarks
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * @param {Pointer<CALDATETIME>} lpCalDateTime Pointer to the [**CALDATETIME**](caldatetime.md) structure to convert.
     * @param {Pointer<SYSTEMTIME>} lpSysTime Pointer to the equivalent [**SYSTEMTIME**](/windows/win32/api/minwinbase/ns-minwinbase-systemtime) structure.
     * @returns {BOOL} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_DATE\_OUT\_OF\_RANGE. The specified date was out of range.
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/convertcaldatetimetosystemtime
     */
    static ConvertCalDateTimeToSystemTime(lpCalDateTime, lpSysTime) {
        result := DllCall("KERNEL32.dll\ConvertCalDateTimeToSystemTime", "ptr", lpCalDateTime, "ptr", lpSysTime, "int")
        return result
    }

    /**
     * Deprecated. Identifies whether the specified year is a leap year within the given era for the specific calendar.
     * @remarks
     * This function does not have an associated header file or library file. The application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (Kernel32.dll) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with that module handle and the name of this function to get the function address.
     * @param {Integer} calId The [calendar identifier](calendar-identifiers.md) to use for checking leap year.
     * @param {Integer} year The year to check.
     * @param {Integer} era The era to check.
     * @returns {BOOL} Returns **TRUE** if the specified year is a leap year, or **FALSE** otherwise. To get extended error information, the application can call [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror), which can return one of the following error codes:
     * 
     * -   ERROR\_INVALID\_PARAMETER. Any of the parameter values was invalid.
     * @see https://learn.microsoft.com/windows/win32/Intl/iscalendarleapyear
     */
    static IsCalendarLeapYear(calId, year, era) {
        result := DllCall("KERNEL32.dll\IsCalendarLeapYear", "uint", calId, "uint", year, "uint", era, "int")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) in another Unicode string for a non-linguistic comparison.
     * @remarks
     * Since <b>FindStringOrdinal</b> provides a binary comparison, it does not return linguistically appropriate results. The ordinal comparison might be mistaken for English sorting behavior. However, it does not find matches when characters vary by linguistically insignificant amounts. See <a href="https://docs.microsoft.com/windows/desktop/Intl/sorting">Sorting</a> for information about choosing an appropriate sorting function.
     * 
     * In contrast to NLS functions that return 0 for failure, this function returns -1 if it fails. On success, it returns a 0-based index. Use of this index helps the function avoid off-by-one errors and one-character buffer overruns.
     * 
     * This function is one of the few NLS functions that calls <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> even when it succeeds. It makes this call to clear the last error in a thread when it fails to match the search string. This clears the value returned by <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <b>Starting with Windows8: </b><b>FindStringOrdinal</b>  is declared in Libloaderapi.h. Before Windows8, it was declared in Winnls.h.
     * @param {Integer} dwFindStringOrdinalFlags Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMSTART"></a><a id="find_fromstart"></a><dl>
     * <dt><b>FIND_FROMSTART</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string, starting with the first character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMEND"></a><a id="find_fromend"></a><dl>
     * <dt><b>FIND_FROMEND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string in the reverse direction, starting with the last character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_STARTSWITH"></a><a id="find_startswith"></a><dl>
     * <dt><b>FIND_STARTSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the first value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_ENDSWITH"></a><a id="find_endswith"></a><dl>
     * <dt><b>FIND_ENDSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the last value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {PWSTR} lpStringValue Pointer to the search string for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the string is null-terminated and the function should calculate the size automatically.
     * @param {BOOL} bIgnoreCase <b>TRUE</b> if the function is to perform a case-insensitive comparison, and <b>FALSE</b> otherwise. The comparison is not a linguistic operation and is not appropriate for all locales and languages. Its behavior is similar to that for English.
     * @returns {Integer} Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. If the function succeeds, the found string is the same size as the value of <i>lpStringValue</i>. A return value of 0 indicates that the function found a match at the beginning of the source string.
     * 
     * The function returns -1 if it does not succeed or if it does not find the search string. To get extended error information, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-findstringordinal
     * @since windows6.1
     */
    static FindStringOrdinal(dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase) {
        lpStringSource := lpStringSource is String ? StrPtr(lpStringSource) : lpStringSource
        lpStringValue := lpStringValue is String ? StrPtr(lpStringValue) : lpStringValue

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindStringOrdinal", "uint", dwFindStringOrdinalFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, "int", bIgnoreCase, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Compares two character strings. The comparison is case-sensitive. (ANSI)
     * @remarks
     * The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings. 
     * 
     *  Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect. 
     * 
     * The function calls <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings. 
     * 
     * The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.
     * 
     * With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings. 
     * 
     * The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {PSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the string pointed to by 
     * 						<i>lpString1</i> is less than the string pointed to by 
     * 						<i>lpString2</i>, the return value is negative. If the string pointed to by 
     * 						<i>lpString1</i> is greater than the string pointed to by 
     * 						<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcmpa
     * @since windows5.0
     */
    static lstrcmpA(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcmpA", "ptr", lpString1, "ptr", lpString2, "int")
        return result
    }

    /**
     * Compares two character strings. The comparison is case-sensitive. (Unicode)
     * @remarks
     * The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings. 
     * 
     *  Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect. 
     * 
     * The function calls <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings. 
     * 
     * The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.
     * 
     * With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings. 
     * 
     * The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PWSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {PWSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the string pointed to by 
     * 						<i>lpString1</i> is less than the string pointed to by 
     * 						<i>lpString2</i>, the return value is negative. If the string pointed to by 
     * 						<i>lpString1</i> is greater than the string pointed to by 
     * 						<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcmpw
     * @since windows5.0
     */
    static lstrcmpW(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcmpW", "ptr", lpString1, "ptr", lpString2, "int")
        return result
    }

    /**
     * Compares two character strings. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings. 
     * 
     *  Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect. 
     * 
     * The function calls <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.
     * 
     * For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.
     * 
     * With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings. 
     * 
     * The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {PSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the string pointed to by 
     * 						<i>lpString1</i> is less than the string pointed to by 
     * 						<i>lpString2</i>, the return value is negative. If the string pointed to by 
     * 						<i>lpString1</i> is greater than the string pointed to by 
     * 						<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcmpia
     * @since windows5.0
     */
    static lstrcmpiA(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcmpiA", "ptr", lpString1, "ptr", lpString2, "int")
        return result
    }

    /**
     * Compares two character strings. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings. 
     * 
     *  Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect. 
     * 
     * The function calls <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.
     * 
     * For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.
     * 
     * With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings. 
     * 
     * The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * See <a href="https://docs.microsoft.com/windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PWSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {PWSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the string pointed to by 
     * 						<i>lpString1</i> is less than the string pointed to by 
     * 						<i>lpString2</i>, the return value is negative. If the string pointed to by 
     * 						<i>lpString1</i> is greater than the string pointed to by 
     * 						<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcmpiw
     * @since windows5.0
     */
    static lstrcmpiW(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcmpiW", "ptr", lpString1, "ptr", lpString2, "int")
        return result
    }

    /**
     * Copies a specified number of characters from a source string into a buffer.WarningDo not use. (ANSI)
     * @remarks
     * The buffer pointed to by <i>lpString1</i> must 
     * 			be large enough to include a terminating null character, and the string length 
     * 			value specified by <i>iMaxLength</i> includes room 
     * 			for a terminating null character. 
     * 
     * The <b>lstrcpyn</b> function has an undefined behavior if source 
     *     and destination buffers overlap.
     * 
     * <h3><a id="Security_Warning"></a><a id="security_warning"></a><a id="SECURITY_WARNING"></a>Security Warning</h3>
     * Using this function incorrectly can compromise the security 
     * 			of your application. This function uses structured exception handling (SEH) to catch 
     * 			access violations and other errors. When this function catches SEH errors, it returns 
     * 			<b>NULL</b> without null-terminating the string and without notifying the 
     * 			caller of the error. The caller is not safe to assume that insufficient space is 
     * 			the error condition.
     * 
     * If the buffer pointed to by <i>lpString1</i> is not large 
     * 			enough to contain the copied string, a buffer overrun can occur. When copying an entire 
     * 			string, note that <b>sizeof</b> returns the number of bytes. 
     * 			For example, if <i>lpString1</i> points to a buffer 
     * 			<i>szString1</i> which is declared as 
     * 			<c>TCHAR szString[100]</c>, then sizeof(szString1) gives the size of 
     * 			the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer 
     * 			overflow for the Unicode version of the function. 
     * 
     * Buffer overflow situations are the cause 
     * 			of many security problems in applications and can cause a denial of service attack against 
     * 			the application if an access violation occurs. In the worst case, a buffer overrun may 
     * 			allow an attacker to inject executable code into your process, especially if 
     * 			<i>lpString1</i> is a stack-based buffer.
     * 
     * Using <c>sizeof(szString1)/sizeof(szString1[0])</c> 
     * 				gives the proper size of the buffer. 
     * 
     * Consider using <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a> instead; use either 
     * 				<c>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</c>, 
     * 				being aware that <c>buffer</c> must not be a pointer or 
     * 				use <c>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</c>, 
     * 				being aware that, when copying to a pointer, the caller is responsible for 
     * 				passing in the size of the pointed-to memory in characters. 
     * 
     * Review <a href="https://docs.microsoft.com/windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the copied characters. The buffer 
     * 				must be large enough to contain the number of <b>TCHAR</b> values 
     * 				specified by <i>iMaxLength</i>, including room 
     * 				for a terminating null character.
     * @param {PSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The source string from which the function is to copy characters.
     * @param {Integer} iMaxLength Type: <b>int</b>
     * 
     * The number of <b>TCHAR</b> values to be copied from the 
     * 				string pointed to by <i>lpString2</i> into the 
     * 				buffer pointed to by <i>lpString1</i>, including 
     * 				a terminating null character.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer. 
     * 				The function can succeed even if the source string is greater than 
     * 				<i>iMaxLength</i> characters.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcpyna
     * @since windows5.0
     */
    static lstrcpynA(lpString1, lpString2, iMaxLength) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcpynA", "ptr", lpString1, "ptr", lpString2, "int", iMaxLength, "ptr")
        return result
    }

    /**
     * Copies a specified number of characters from a source string into a buffer.WarningDo not use. (Unicode)
     * @remarks
     * The buffer pointed to by <i>lpString1</i> must 
     * 			be large enough to include a terminating null character, and the string length 
     * 			value specified by <i>iMaxLength</i> includes room 
     * 			for a terminating null character. 
     * 
     * The <b>lstrcpyn</b> function has an undefined behavior if source 
     *     and destination buffers overlap.
     * 
     * <h3><a id="Security_Warning"></a><a id="security_warning"></a><a id="SECURITY_WARNING"></a>Security Warning</h3>
     * Using this function incorrectly can compromise the security 
     * 			of your application. This function uses structured exception handling (SEH) to catch 
     * 			access violations and other errors. When this function catches SEH errors, it returns 
     * 			<b>NULL</b> without null-terminating the string and without notifying the 
     * 			caller of the error. The caller is not safe to assume that insufficient space is 
     * 			the error condition.
     * 
     * If the buffer pointed to by <i>lpString1</i> is not large 
     * 			enough to contain the copied string, a buffer overrun can occur. When copying an entire 
     * 			string, note that <b>sizeof</b> returns the number of bytes. 
     * 			For example, if <i>lpString1</i> points to a buffer 
     * 			<i>szString1</i> which is declared as 
     * 			<c>TCHAR szString[100]</c>, then sizeof(szString1) gives the size of 
     * 			the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer 
     * 			overflow for the Unicode version of the function. 
     * 
     * Buffer overflow situations are the cause 
     * 			of many security problems in applications and can cause a denial of service attack against 
     * 			the application if an access violation occurs. In the worst case, a buffer overrun may 
     * 			allow an attacker to inject executable code into your process, especially if 
     * 			<i>lpString1</i> is a stack-based buffer.
     * 
     * Using <c>sizeof(szString1)/sizeof(szString1[0])</c> 
     * 				gives the proper size of the buffer. 
     * 
     * Consider using <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a> instead; use either 
     * 				<c>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</c>, 
     * 				being aware that <c>buffer</c> must not be a pointer or 
     * 				use <c>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</c>, 
     * 				being aware that, when copying to a pointer, the caller is responsible for 
     * 				passing in the size of the pointed-to memory in characters. 
     * 
     * Review <a href="https://docs.microsoft.com/windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PWSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the copied characters. The buffer 
     * 				must be large enough to contain the number of <b>TCHAR</b> values 
     * 				specified by <i>iMaxLength</i>, including room 
     * 				for a terminating null character.
     * @param {PWSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The source string from which the function is to copy characters.
     * @param {Integer} iMaxLength Type: <b>int</b>
     * 
     * The number of <b>TCHAR</b> values to be copied from the 
     * 				string pointed to by <i>lpString2</i> into the 
     * 				buffer pointed to by <i>lpString1</i>, including 
     * 				a terminating null character.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer. 
     * 				The function can succeed even if the source string is greater than 
     * 				<i>iMaxLength</i> characters.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcpynw
     * @since windows5.0
     */
    static lstrcpynW(lpString1, lpString2, iMaxLength) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcpynW", "ptr", lpString1, "ptr", lpString2, "int", iMaxLength, "ptr")
        return result
    }

    /**
     * Copies a string to a buffer. (ANSI)
     * @remarks
     * With a double-byte character set (DBCS) version of the system, this function can be used 
     * 			to copy a DBCS string. 
     * 
     * The <b>lstrcpy</b> function has an 
     * 			undefined behavior if source and destination buffers overlap.
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * Using this function incorrectly can compromise the security 
     * 			of your application. This function uses structured exception handling (SEH) to catch 
     * 			access violations and other errors. When this function catches SEH errors, it returns 
     * 			<b>NULL</b> without null-terminating the string and without notifying the 
     * 			caller of the error. The caller is not safe to assume that insufficient space is 
     * 			the error condition.
     * 
     * <i>lpString1</i> must be large enough to hold <i>lpString2</i> 
     * 			and the closing '\0', otherwise a buffer overrun may occur.
     * 
     * Buffer overflow situations are the cause of many security problems in applications and 
     * 			can cause a denial of service attack against the application if an access violation occurs. 
     * 			In the worst case, a buffer overrun may allow an attacker to inject executable code into 
     * 			your process, especially if <i>lpString1</i> is a stack-based buffer.
     * 
     * Consider using <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a> instead; use either 
     * 				<c>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</c>, 
     * 				being aware that <c>buffer</c> must not be a pointer or 
     * 				use <c>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</c>, 
     * 				being aware that, when copying to a pointer, the caller is responsible for 
     * 				passing in the size of the pointed-to memory in characters. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * A buffer to receive the contents of the string pointed to by the 
     * 					<i>lpString2</i> parameter. 
     * 					The buffer must be large enough to contain the string, including the 
     * 					terminating null character.
     * @param {PSTR} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be copied.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcpya
     * @since windows5.0
     */
    static lstrcpyA(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcpyA", "ptr", lpString1, "ptr", lpString2, "ptr")
        return result
    }

    /**
     * Copies a string to a buffer. (Unicode)
     * @remarks
     * With a double-byte character set (DBCS) version of the system, this function can be used 
     * 			to copy a DBCS string. 
     * 
     * The <b>lstrcpy</b> function has an 
     * 			undefined behavior if source and destination buffers overlap.
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * Using this function incorrectly can compromise the security 
     * 			of your application. This function uses structured exception handling (SEH) to catch 
     * 			access violations and other errors. When this function catches SEH errors, it returns 
     * 			<b>NULL</b> without null-terminating the string and without notifying the 
     * 			caller of the error. The caller is not safe to assume that insufficient space is 
     * 			the error condition.
     * 
     * <i>lpString1</i> must be large enough to hold <i>lpString2</i> 
     * 			and the closing '\0', otherwise a buffer overrun may occur.
     * 
     * Buffer overflow situations are the cause of many security problems in applications and 
     * 			can cause a denial of service attack against the application if an access violation occurs. 
     * 			In the worst case, a buffer overrun may allow an attacker to inject executable code into 
     * 			your process, especially if <i>lpString1</i> is a stack-based buffer.
     * 
     * Consider using <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a> instead; use either 
     * 				<c>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</c>, 
     * 				being aware that <c>buffer</c> must not be a pointer or 
     * 				use <c>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</c>, 
     * 				being aware that, when copying to a pointer, the caller is responsible for 
     * 				passing in the size of the pointed-to memory in characters. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PWSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * A buffer to receive the contents of the string pointed to by the 
     * 					<i>lpString2</i> parameter. 
     * 					The buffer must be large enough to contain the string, including the 
     * 					terminating null character.
     * @param {PWSTR} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be copied.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcpyw
     * @since windows5.0
     */
    static lstrcpyW(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcpyW", "ptr", lpString1, "ptr", lpString2, "ptr")
        return result
    }

    /**
     * Appends one string to another.WarningDo not use. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * The first null-terminated string. This buffer must be large enough 
     * 				to contain both strings.
     * @param {PSTR} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be appended to the string 
     * 				specified in the <i>lpString1</i> parameter.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcata
     * @since windows5.0
     */
    static lstrcatA(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcatA", "ptr", lpString1, "ptr", lpString2, "ptr")
        return result
    }

    /**
     * Appends one string to another.WarningDo not use. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PWSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * The first null-terminated string. This buffer must be large enough 
     * 				to contain both strings.
     * @param {PWSTR} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be appended to the string 
     * 				specified in the <i>lpString1</i> parameter.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrcatw
     * @since windows5.0
     */
    static lstrcatW(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcatW", "ptr", lpString1, "ptr", lpString2, "ptr")
        return result
    }

    /**
     * Determines the length of the specified string (not including the terminating null character). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PSTR} lpString Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be checked.
     * @returns {Integer} Type: <b>int</b>
     * 
     * The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrlena
     * @since windows5.0
     */
    static lstrlenA(lpString) {
        lpString := lpString is String ? StrPtr(lpString) : lpString

        result := DllCall("KERNEL32.dll\lstrlenA", "ptr", lpString, "int")
        return result
    }

    /**
     * Determines the length of the specified string (not including the terminating null character). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {PWSTR} lpString Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be checked.
     * @returns {Integer} Type: <b>int</b>
     * 
     * The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-lstrlenw
     * @since windows5.0
     */
    static lstrlenW(lpString) {
        lpString := lpString is String ? StrPtr(lpString) : lpString

        result := DllCall("KERNEL32.dll\lstrlenW", "ptr", lpString, "int")
        return result
    }

    /**
     * Determines if a buffer is likely to contain a form of Unicode text.
     * @remarks
     * This function uses various statistical and deterministic methods to make its determination, under the control of flags passed in the <i>lpiResult</i> parameter. When the function returns, the results of such tests are reported using the same parameter.
     * 
     * The IS_TEXT_UNICODE_STATISTICS and IS_TEXT_UNICODE_REVERSE_STATISTICS tests use statistical analysis. These tests are not foolproof. The statistical tests assume certain amounts of variation between low and high bytes in a string, and some ASCII strings can slip through. For example, if <i>lpv</i> indicates the ASCII string 0x41, 0x0A, 0x0D, 0x1D (A\n\r^Z), the string passes the IS_TEXT_UNICODE_STATISTICS test, although failure would be preferable.
     * @param {Pointer} lpv Pointer to the input buffer to examine.
     * @param {Integer} iSize Size, in bytes, of the input buffer indicated by <i>lpv</i>.
     * @param {Pointer<Integer>} lpiResult On input, pointer to the tests to apply to the input buffer text. On output, this parameter receives the results of the specified tests: 1 if the contents of the buffer pass a test, 0 for failure. Only flags that are set upon input to the function are significant upon output.
     * 
     * If <i>lpiResult</i> is <b>NULL</b>, the function uses all available tests to determine if the data in the buffer is likely to be Unicode text.
     * @returns {BOOL} Returns a nonzero value if the data in the buffer passes the specified tests. The function returns 0 if the data in the buffer does not pass the specified tests.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-istextunicode
     * @since windows5.0
     */
    static IsTextUnicode(lpv, iSize, lpiResult) {
        lpiResultMarshal := lpiResult is VarRef ? "uint*" : "ptr"

        result := DllCall("ADVAPI32.dll\IsTextUnicode", "ptr", lpv, "int", iSize, lpiResultMarshal, lpiResult, "int")
        return result
    }

;@endregion Methods
}
