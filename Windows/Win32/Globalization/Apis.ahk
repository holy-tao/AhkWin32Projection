#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\Win32Handle.ahk
/**
 * @namespace Windows.Win32.Globalization
 * @version v4.0.30319
 */
class Globalization {

;@region Constants

    /**
     * @type {Integer (Int32)}
     */
    static LANG_SYSTEM_DEFAULT => 2048

    /**
     * @type {Integer (Int32)}
     */
    static LANG_USER_DEFAULT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SYSTEM_DEFAULT => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_USER_DEFAULT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static ALL_SERVICE_TYPES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static HIGHLEVEL_SERVICE_TYPES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOWLEVEL_SERVICE_TYPES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALL_SERVICES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ONLINE_SERVICES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_SERVICES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LEADBYTES => 12

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_DEFAULTCHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static HIGH_SURROGATE_START => 55296

    /**
     * @type {Integer (UInt32)}
     */
    static HIGH_SURROGATE_END => 56319

    /**
     * @type {Integer (UInt32)}
     */
    static LOW_SURROGATE_START => 56320

    /**
     * @type {Integer (UInt32)}
     */
    static LOW_SURROGATE_END => 57343

    /**
     * @type {Integer (UInt32)}
     */
    static WC_COMPOSITECHECK => 512

    /**
     * @type {Integer (UInt32)}
     */
    static WC_DISCARDNS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static WC_SEPCHARS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static WC_DEFAULTCHAR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static WC_ERR_INVALID_CHARS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static WC_NO_BEST_FIT_CHARS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CT_CTYPE3 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C1_UPPER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C1_LOWER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C1_DIGIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C1_SPACE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C1_PUNCT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static C1_CNTRL => 32

    /**
     * @type {Integer (UInt32)}
     */
    static C1_BLANK => 64

    /**
     * @type {Integer (UInt32)}
     */
    static C1_XDIGIT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static C1_ALPHA => 256

    /**
     * @type {Integer (UInt32)}
     */
    static C1_DEFINED => 512

    /**
     * @type {Integer (UInt32)}
     */
    static C2_LEFTTORIGHT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C2_RIGHTTOLEFT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPENUMBER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPESEPARATOR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C2_EUROPETERMINATOR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static C2_ARABICNUMBER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static C2_COMMONSEPARATOR => 7

    /**
     * @type {Integer (UInt32)}
     */
    static C2_BLOCKSEPARATOR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C2_SEGMENTSEPARATOR => 9

    /**
     * @type {Integer (UInt32)}
     */
    static C2_WHITESPACE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static C2_OTHERNEUTRAL => 11

    /**
     * @type {Integer (UInt32)}
     */
    static C2_NOTAPPLICABLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static C3_NONSPACING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static C3_DIACRITIC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static C3_VOWELMARK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static C3_SYMBOL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static C3_KATAKANA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HIRAGANA => 32

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HALFWIDTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static C3_FULLWIDTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static C3_IDEOGRAPH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static C3_KASHIDA => 512

    /**
     * @type {Integer (UInt32)}
     */
    static C3_LEXICAL => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static C3_HIGHSURROGATE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static C3_LOWSURROGATE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static C3_ALPHA => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static C3_NOTAPPLICABLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_LOWERCASE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_UPPERCASE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_TITLECASE => 768

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SORTKEY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_BYTEREV => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HIRAGANA => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_KATAKANA => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HALFWIDTH => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_FULLWIDTH => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_LINGUISTIC_CASING => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SIMPLIFIED_CHINESE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_TRADITIONAL_CHINESE => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_SORTHANDLE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static LCMAP_HASH => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_STARTSWITH => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_ENDSWITH => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_FROMSTART => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static FIND_FROMEND => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static LCID_ALTERNATE_SORTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_WINDOWS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SUPPLEMENTAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALTERNATE_SORTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_REPLACEMENT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_NEUTRALDATA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPECIFICDATA => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CP_ACP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CP_OEMCP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CP_MACCP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CP_THREAD_ACP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CP_SYMBOL => 42

    /**
     * @type {Integer (UInt32)}
     */
    static CP_UTF7 => 65000

    /**
     * @type {Integer (UInt32)}
     */
    static CP_UTF8 => 65001

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ALBANIA => 355

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ALGERIA => 213

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ARGENTINA => 54

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ARMENIA => 374

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AUSTRALIA => 61

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AUSTRIA => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_AZERBAIJAN => 994

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BAHRAIN => 973

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELARUS => 375

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELGIUM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BELIZE => 501

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BOLIVIA => 591

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BRAZIL => 55

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BRUNEI_DARUSSALAM => 673

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_BULGARIA => 359

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CANADA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CARIBBEAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CHILE => 56

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_COLOMBIA => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_COSTA_RICA => 506

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CROATIA => 385

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_CZECH => 420

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DENMARK => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_DOMINICAN_REPUBLIC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ECUADOR => 593

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_EGYPT => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_EL_SALVADOR => 503

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ESTONIA => 372

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FAEROE_ISLANDS => 298

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FINLAND => 358

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_FRANCE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GEORGIA => 995

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GERMANY => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GREECE => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_GUATEMALA => 502

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HONDURAS => 504

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HONG_KONG => 852

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_HUNGARY => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ICELAND => 354

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_INDIA => 91

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_INDONESIA => 62

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRAN => 981

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRAQ => 964

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_IRELAND => 353

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ISRAEL => 972

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ITALY => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JAMAICA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JAPAN => 81

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_JORDAN => 962

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KAZAKSTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KENYA => 254

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KUWAIT => 965

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_KYRGYZSTAN => 996

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LATVIA => 371

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LEBANON => 961

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LIBYA => 218

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LIECHTENSTEIN => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LITHUANIA => 370

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_LUXEMBOURG => 352

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MACAU => 853

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MACEDONIA => 389

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MALAYSIA => 60

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MALDIVES => 960

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MEXICO => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MONACO => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MONGOLIA => 976

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_MOROCCO => 212

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NETHERLANDS => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NEW_ZEALAND => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NICARAGUA => 505

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_NORWAY => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_OMAN => 968

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PAKISTAN => 92

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PANAMA => 507

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PARAGUAY => 595

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PERU => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PHILIPPINES => 63

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_POLAND => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PORTUGAL => 351

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PRCHINA => 86

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_PUERTO_RICO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_QATAR => 974

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ROMANIA => 40

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_RUSSIA => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SAUDI_ARABIA => 966

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SERBIA => 381

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SINGAPORE => 65

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SLOVAK => 421

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SLOVENIA => 386

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SOUTH_AFRICA => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SOUTH_KOREA => 82

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SPAIN => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SWEDEN => 46

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SWITZERLAND => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_SYRIA => 963

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TAIWAN => 886

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TATARSTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_THAILAND => 66

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TRINIDAD_Y_TOBAGO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TUNISIA => 216

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_TURKEY => 90

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UAE => 971

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UKRAINE => 380

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UNITED_KINGDOM => 44

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UNITED_STATES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_URUGUAY => 598

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_UZBEKISTAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_VENEZUELA => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_VIET_NAM => 84

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_YEMEN => 967

    /**
     * @type {Integer (UInt32)}
     */
    static CTRY_ZIMBABWE => 263

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_NOUSEROVERRIDE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_USE_CP_ACP => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_RETURN_NUMBER => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_RETURN_GENITIVE_NAMES => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ALLOW_NEUTRAL_NAMES => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDDISPLAYNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHDISPLAYNAME => 114

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVEDISPLAYNAME => 115

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDLANGUAGENAME => 111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHLANGUAGENAME => 4097

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVELANGUAGENAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLOCALIZEDCOUNTRYNAME => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLISHCOUNTRYNAME => 4098

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECOUNTRYNAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIALINGCODE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLIST => 12

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IMEASURE => 13

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDECIMAL => 14

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STHOUSAND => 15

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SGROUPING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIGITS => 17

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILZERO => 18

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGNUMBER => 4112

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVEDIGITS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCURRENCY => 20

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SINTLSYMBOL => 21

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONDECIMALSEP => 22

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHOUSANDSEP => 23

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONGROUPING => 24

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICURRDIGITS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICURRENCY => 27

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGCURR => 28

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTDATE => 31

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLONGDATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STIMEFORMAT => 4099

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SAM => 40

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPM => 41

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICALENDARTYPE => 4105

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IOPTIONALCALENDAR => 4107

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IFIRSTDAYOFWEEK => 4108

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IFIRSTWEEKOFYEAR => 4109

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME1 => 42

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME2 => 43

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME3 => 44

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME4 => 45

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME5 => 46

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME6 => 47

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDAYNAME7 => 48

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME1 => 49

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME2 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME3 => 51

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME4 => 52

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME5 => 53

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME6 => 54

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVDAYNAME7 => 55

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME1 => 56

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME2 => 57

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME3 => 58

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME4 => 59

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME5 => 60

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME6 => 61

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME7 => 62

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME8 => 63

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME9 => 64

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME10 => 65

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME11 => 66

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME12 => 67

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHNAME13 => 4110

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME1 => 68

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME2 => 69

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME3 => 70

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME4 => 71

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME5 => 72

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME6 => 73

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME7 => 74

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME8 => 75

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME9 => 76

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME10 => 77

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME11 => 78

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME12 => 79

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVMONTHNAME13 => 4111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPOSITIVESIGN => 80

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNEGATIVESIGN => 81

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSIGNPOSN => 82

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSIGNPOSN => 83

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSYMPRECEDES => 84

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSSEPBYSPACE => 85

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSYMPRECEDES => 86

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGSEPBYSPACE => 87

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_FONTSIGNATURE => 88

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO639LANGNAME => 89

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO3166CTRYNAME => 90

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPAPERSIZE => 4106

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGCURRNAME => 4103

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECURRNAME => 4104

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SYEARMONTH => 4102

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSORTNAME => 4115

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDIGITSUBSTITUTION => 4116

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNAME => 92

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDURATION => 93

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME1 => 96

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME2 => 97

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME3 => 98

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME4 => 99

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME5 => 100

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME6 => 101

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTDAYNAME7 => 102

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO639LANGNAME2 => 103

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SISO3166CTRYNAME2 => 104

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNAN => 105

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPOSINFINITY => 106

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNEGINFINITY => 107

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSCRIPTS => 108

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPARENT => 109

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCONSOLEFALLBACKNAME => 110

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IREADINGLAYOUT => 112

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEUTRAL => 113

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_INEGATIVEPERCENT => 116

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IPOSITIVEPERCENT => 117

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPERCENT => 118

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SPERMILLE => 119

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SMONTHDAY => 120

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTTIME => 121

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SOPENTYPELANGUAGETAG => 122

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSORTLOCALE => 123

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SRELATIVELONGDATE => 124

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICONSTRUCTEDLOCALE => 125

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTAM => 126

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SSHORTESTPM => 127

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IUSEUTF8LEGACYACP => 1638

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IUSEUTF8LEGACYOEMCP => 2457

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTCODEPAGE => 11

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTANSICODEPAGE => 4100

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTMACCODEPAGE => 4113

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTEBCDICCODEPAGE => 4114

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILANGUAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVLANGNAME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SABBREVCTRYNAME => 7

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IGEOID => 91

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTLANGUAGE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDEFAULTCOUNTRY => 10

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IINTLCURRDIGITS => 26

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SDATE => 29

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_STIME => 30

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDATE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ILDATE => 34

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITIME => 35

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITIMEMARKPOSN => 4101

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICENTURY => 36

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ITLZERO => 37

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IDAYLZERO => 38

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_IMONLZERO => 39

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SKEYBOARDSTOINSTALL => 94

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLANGUAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SLANGDISPLAYNAME => 111

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGLANGUAGE => 4097

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVELANGNAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SCOUNTRY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SENGCOUNTRY => 4098

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_SNATIVECTRYNAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_ICOUNTRY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_S1159 => 40

    /**
     * @type {Integer (UInt32)}
     */
    static LOCALE_S2359 => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_NOUSEROVERRIDE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_USE_CP_ACP => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_RETURN_NUMBER => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_RETURN_GENITIVE_NAMES => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_ICALINTVALUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SCALNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_IYEAROFFSETRANGE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SERASTRING => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTDATE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SLONGDATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME1 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME2 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME3 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME4 => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME5 => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME6 => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SDAYNAME7 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME1 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME2 => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME3 => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME4 => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME5 => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME6 => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVDAYNAME7 => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME1 => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME2 => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME3 => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME4 => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME5 => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME6 => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME7 => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME8 => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME9 => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME10 => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME11 => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME12 => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHNAME13 => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME1 => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME2 => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME3 => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME4 => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME5 => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME6 => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME7 => 40

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME8 => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME9 => 42

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME10 => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME11 => 44

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME12 => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVMONTHNAME13 => 46

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SYEARMONTH => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_ITWODIGITYEARMAX => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME1 => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME2 => 50

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME3 => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME4 => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME5 => 53

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME6 => 54

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SSHORTESTDAYNAME7 => 55

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SMONTHDAY => 56

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SABBREVERASTRING => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SRELATIVELONGDATE => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SENGLISHERANAME => 59

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SENGLISHABBREVERANAME => 60

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_SJAPANESEERAFIRSTYEAR => 61

    /**
     * @type {Integer (UInt32)}
     */
    static ENUM_ALL_CALENDARS => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_US => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_JAPAN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_TAIWAN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_KOREA => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_HIJRI => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_THAI => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_HEBREW => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_ME_FRENCH => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_ARABIC => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_XLIT_ENGLISH => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_GREGORIAN_XLIT_FRENCH => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_PERSIAN => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CAL_UMALQURA => 23

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_WESTERN_EUROPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_CENTRAL_EUROPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_BALTIC => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_GREEK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_CYRILLIC => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TURKIC => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TURKISH => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_JAPANESE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_KOREAN => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_TRADITIONAL_CHINESE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_SIMPLIFIED_CHINESE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_THAI => 11

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_HEBREW => 12

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_ARABIC => 13

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_VIETNAMESE => 14

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_INDIC => 15

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_GEORGIAN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LGRPID_ARMENIAN => 17

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_NAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MERGE_SYSTEM_FALLBACK => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MERGE_USER_FALLBACK => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_THREAD_LANGUAGES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_CONSOLE_FILTER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_COMPLEX_SCRIPT_FILTER => 512

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_RESET_FILTERS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USER_PREFERRED_UI_LANGUAGES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USE_INSTALLED_LANGUAGES => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_USE_SEARCH_ALL_LANGUAGES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANG_NEUTRAL_PE_FILE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_NON_LANG_NEUTRAL_FILE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_MACHINE_LANGUAGE_SETTINGS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_CHECKSUM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_LANGUAGE_NAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_QUERY_RESOURCE_TYPES => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FILEINFO_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FULL_LANGUAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_PARTIAL_LANGUAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LIP_LANGUAGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_INSTALLED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_LICENSED => 64

    /**
     * @type {Integer (Int32)}
     */
    static GEOID_NOT_AVAILABLE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static SORTING_PARADIGM_NLS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SORTING_PARADIGM_ICU => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_ALLOW_UNASSIGNED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_USE_STD3_ASCII_RULES => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_EMAIL_ADDRESS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IDN_RAW_PUNYCODE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static VS_ALLOW_LATIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GSS_ALLOW_INHERITED_COMMON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FORMAT_REG_COMPAT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_FORMAT_INF_COMPAT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_VERIFY_FILE_EXISTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_SKIP_STRING_CACHE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_IMMUTABLE_LOOKUP => 16

    /**
     * @type {String}
     */
    static LOCALE_NAME_INVARIANT => ""

    /**
     * @type {String}
     */
    static LOCALE_NAME_SYSTEM_DEFAULT => "!x-sys-default-locale"

    /**
     * @type {Integer (UInt32)}
     */
    static MIN_SPELLING_NTDDI => 100794368

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_UNDEFINED => 0

    /**
     * @type {Integer (Int32)}
     */
    static USP_E_SCRIPT_NOT_IN_FONT => -2147220992

    /**
     * @type {Integer (UInt32)}
     */
    static SGCM_RTL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_PASSWORD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_TAB => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_CLIP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_DZWG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FALLBACK => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_BREAK => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_GLYPHS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_RTL => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_GCP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HOTKEY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_METAFILE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LINK => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HIDEHOTKEY => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_HOTKEYONLY => 9216

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_FULLMEASURE => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LPKANSIFALLBACK => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_PIDX => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_LAYOUTRTL => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_DONTGLYPH => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static SSA_NOKASHIDA => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_CONTEXT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_NONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_NATIONAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_DIGITSUBSTITUTE_TRADITIONAL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static UNISCRIBE_OPENTYPE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SCRIPT_TAG_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MUI_LANGUAGE_EXACT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_CPINFO => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_MBTOWC => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static NLS_CP_WCTOMB => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static U_DISABLE_RENAMING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHOW_CPLUSPLUS_API => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEFAULT_SHOW_DRAFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_DRAFT_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_DEPRECATED_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_OBSOLETE_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_INTERNAL_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_NO_DEFAULT_INCLUDE_UTF_HEADERS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEBUG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCLN_NO_AUTO_CLEANUP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_OVERRIDE_CXX_ALLOCATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_ENABLE_TRACING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ENABLE_PLUGINS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_ENABLE_DYLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHECK_DYLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_LIB_SUFFIX => 1

    /**
     * @type {String}
     */
    static U_LIB_SUFFIX_C_NAME_STRING => ""

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ONLY_COLLATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_BREAK_ITERATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_IDNA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FORMATTING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_TRANSLITERATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_REGULAR_EXPRESSIONS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FILE_IO => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_CONVERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_LEGACY_CONVERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_ONLY_HTML_CONVERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_NORMALIZATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_COLLATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_SERVICE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_HAVE_PARSEALLINPUT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_NO_FILTERED_BREAK_ITERATION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_WINDOWS => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_MINGW => 1800

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_CYGWIN => 1900

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_HPUX => 2100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_SOLARIS => 2600

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_BSD => 3000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_AIX => 3100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_IRIX => 3200

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_DARWIN => 3500

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_IPHONE => 3550

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_QNX => 3700

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_LINUX => 4000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_BROWSER_NATIVE_CLIENT => 4020

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_ANDROID => 4050

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_FUCHSIA => 4100

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_EMSCRIPTEN => 5010

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_OS390 => 9000

    /**
     * @type {Integer (UInt32)}
     */
    static U_PF_OS400 => 9400

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM => 1800

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_USES_ONLY_WIN32_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_HAS_WIN32_API => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IMPLEMENTS_POSIX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IS_LINUX_BASED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_IS_DARWIN_BASED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_STDINT_H => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_INTTYPES_H => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_GCC_MAJOR_MINOR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_IS_BIG_ENDIAN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_PLACEMENT_NEW => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_DEBUG_LOCATION_NEW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CPLUSPLUS_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_ASCII_FAMILY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_EBCDIC_FAMILY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHARSET_FAMILY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHARSET_IS_UTF8 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_WCHAR_H => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SIZEOF_WCHAR_T => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_WCSCPY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_CHAR16_T => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_DEFINE_FALSE_AND_TRUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SIZEOF_UCHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_CHAR16_IS_TYPEDEF => 1

    /**
     * @type {Integer (Int32)}
     */
    static U_SENTINEL => -1

    /**
     * @type {String}
     */
    static U8_LEAD3_T1_BITS => " 000000000000\u001000"

    /**
     * @type {String}
     */
    static U8_LEAD4_T1_BITS => "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001e\u000f\u000f\u000f\u0000\u0000\u0000\u0000"

    /**
     * @type {Integer (UInt32)}
     */
    static U8_MAX_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U16_MAX_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_HIDE_OBSOLETE_UTF_OLD_H => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_SIZE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_ERROR_VALUE_1 => 21

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_ERROR_VALUE_2 => 159

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_ERROR_VALUE => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static UTF8_MAX_CHAR_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static UTF16_MAX_CHAR_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static UTF32_MAX_CHAR_LENGTH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UTF_MAX_CHAR_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_COPYRIGHT_STRING_LENGTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static U_MAX_VERSION_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_MAX_VERSION_STRING_LENGTH => 20

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_SECOND => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_MINUTE => 60000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_HOUR => 3600000

    /**
     * @type {Integer (UInt32)}
     */
    static U_MILLIS_PER_DAY => 86400000

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMBINED_IMPLEMENTATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_GROW_SHRINK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_RESIZE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_NEAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_NEAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_AT_END => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_END => 2

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_FIXED_SPACES_AT_BEGINNING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_BEGIN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_AUTO => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LENGTH_MASK => 65539

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LAMALEF_MASK => 65539

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_LOGICAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_VISUAL_RTL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_VISUAL_LTR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TEXT_DIRECTION_MASK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_SHAPE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_UNSHAPE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_SHAPE_TASHKEEL_ISOLATED => 24

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_LETTERS_MASK => 24

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_EN2AN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_AN2EN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_ALEN2AN_INIT_LR => 96

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_ALEN2AN_INIT_AL => 128

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_RESERVED => 160

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGITS_MASK => 224

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_AN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_AN_EXTENDED => 256

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_RESERVED => 512

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_DIGIT_TYPE_MASK => 768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_AGGREGATE_TASHKEEL_MASK => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION_NOOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_PRESERVE_PRESENTATION_MASK => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SEEN_TWOCELL_NEAR => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SEEN_MASK => 7340032

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_YEHHAMZA_TWOCELL_NEAR => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_YEHHAMZA_MASK => 58720256

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_BEGIN => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_END => 393216

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_RESIZE => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_REPLACE_BY_TATWEEL => 786432

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TASHKEEL_MASK => 917504

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SPACES_RELATIVE_TO_TEXT_BEGIN_END => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_SPACES_RELATIVE_TO_TEXT_MASK => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TAIL_NEW_UNICODE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static U_SHAPE_TAIL_TYPE_MASK => 134217728

    /**
     * @type {String}
     */
    static ULOC_CHINESE => "zh"

    /**
     * @type {String}
     */
    static ULOC_ENGLISH => "en"

    /**
     * @type {String}
     */
    static ULOC_FRENCH => "fr"

    /**
     * @type {String}
     */
    static ULOC_GERMAN => "de"

    /**
     * @type {String}
     */
    static ULOC_ITALIAN => "it"

    /**
     * @type {String}
     */
    static ULOC_JAPANESE => "ja"

    /**
     * @type {String}
     */
    static ULOC_KOREAN => "ko"

    /**
     * @type {String}
     */
    static ULOC_SIMPLIFIED_CHINESE => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_TRADITIONAL_CHINESE => "zh_TW"

    /**
     * @type {String}
     */
    static ULOC_CANADA => "en_CA"

    /**
     * @type {String}
     */
    static ULOC_CANADA_FRENCH => "fr_CA"

    /**
     * @type {String}
     */
    static ULOC_CHINA => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_PRC => "zh_CN"

    /**
     * @type {String}
     */
    static ULOC_FRANCE => "fr_FR"

    /**
     * @type {String}
     */
    static ULOC_GERMANY => "de_DE"

    /**
     * @type {String}
     */
    static ULOC_ITALY => "it_IT"

    /**
     * @type {String}
     */
    static ULOC_JAPAN => "ja_JP"

    /**
     * @type {String}
     */
    static ULOC_KOREA => "ko_KR"

    /**
     * @type {String}
     */
    static ULOC_TAIWAN => "zh_TW"

    /**
     * @type {String}
     */
    static ULOC_UK => "en_GB"

    /**
     * @type {String}
     */
    static ULOC_US => "en_US"

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_LANG_CAPACITY => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_COUNTRY_CAPACITY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_FULLNAME_CAPACITY => 157

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_SCRIPT_CAPACITY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORDS_CAPACITY => 96

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_AND_VALUES_CAPACITY => 100

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_SEPARATOR_UNICODE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_ASSIGN_UNICODE => 61

    /**
     * @type {Integer (UInt32)}
     */
    static ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE => 59

    /**
     * @type {String}
     */
    static UCNV_SUB_STOP_ON_ILLEGAL => "i"

    /**
     * @type {String}
     */
    static UCNV_SKIP_STOP_ON_ILLEGAL => "i"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_JAVA => "J"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_C => "C"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_XML_DEC => "D"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_XML_HEX => "X"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_UNICODE => "U"

    /**
     * @type {String}
     */
    static UCNV_ESCAPE_CSS2 => "S"

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_MAX_CONVERTER_NAME_LENGTH => 60

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_SI => 15

    /**
     * @type {Integer (UInt32)}
     */
    static UCNV_SO => 14

    /**
     * @type {String}
     */
    static UCNV_OPTION_SEP_STRING => ","

    /**
     * @type {String}
     */
    static UCNV_VALUE_SEP_STRING => "="

    /**
     * @type {String}
     */
    static UCNV_LOCALE_OPTION_STRING => ",locale="

    /**
     * @type {String}
     */
    static UCNV_VERSION_OPTION_STRING => ",version="

    /**
     * @type {String}
     */
    static UCNV_SWAP_LFNL_OPTION_STRING => ",swaplfnl"

    /**
     * @type {Integer (UInt32)}
     */
    static U_FOLD_CASE_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_FOLD_CASE_EXCLUDE_SPECIAL_I => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_WHOLE_STRING => 32

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_SENTENCES => 64

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_NO_LOWERCASE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_NO_BREAK_ADJUSTMENT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static U_TITLECASE_ADJUST_TO_CASED => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static U_EDITS_NO_RESET => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static U_OMIT_UNCHANGED_TEXT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMPARE_CODE_POINT_ORDER => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static U_COMPARE_IGNORE_CASE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static UNORM_INPUT_IS_FCD => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static UCHAR_MIN_VALUE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCHAR_MAX_VALUE => 1114111

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DEFAULT_LTR => 254

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DEFAULT_RTL => 255

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_MAX_EXPLICIT_LEVEL => 125

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_LEVEL_OVERRIDE => 128

    /**
     * @type {Integer (Int32)}
     */
    static UBIDI_MAP_NOWHERE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_KEEP_BASE_COMBINING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_DO_MIRRORING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_INSERT_LRM_FOR_NUMERIC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_REMOVE_BIDI_CONTROLS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static UBIDI_OUTPUT_REVERSE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static USPREP_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static USPREP_ALLOW_UNASSIGNED => 1

    /**
     * @type {String}
     */
    static U_ICU_VERSION_BUNDLE => "icuver"

    /**
     * @type {String}
     */
    static U_ICU_DATA_KEY => "DataVersion"

    /**
     * @type {String}
     */
    static UCAL_UNKNOWN_ZONE_ID => "Etc/Unknown"

    /**
     * @type {String}
     */
    static UDAT_YEAR => "y"

    /**
     * @type {String}
     */
    static UDAT_QUARTER => "QQQQ"

    /**
     * @type {String}
     */
    static UDAT_ABBR_QUARTER => "QQQ"

    /**
     * @type {String}
     */
    static UDAT_YEAR_QUARTER => "yQQQQ"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_QUARTER => "yQQQ"

    /**
     * @type {String}
     */
    static UDAT_MONTH => "MMMM"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH => "MMM"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH => "M"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH => "yMMMM"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH => "yMMM"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH => "yM"

    /**
     * @type {String}
     */
    static UDAT_DAY => "d"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH_DAY => "yMMMMd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH_DAY => "yMMMd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH_DAY => "yMd"

    /**
     * @type {String}
     */
    static UDAT_WEEKDAY => "EEEE"

    /**
     * @type {String}
     */
    static UDAT_ABBR_WEEKDAY => "E"

    /**
     * @type {String}
     */
    static UDAT_YEAR_MONTH_WEEKDAY_DAY => "yMMMMEEEEd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_ABBR_MONTH_WEEKDAY_DAY => "yMMMEd"

    /**
     * @type {String}
     */
    static UDAT_YEAR_NUM_MONTH_WEEKDAY_DAY => "yMEd"

    /**
     * @type {String}
     */
    static UDAT_MONTH_DAY => "MMMMd"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH_DAY => "MMMd"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH_DAY => "Md"

    /**
     * @type {String}
     */
    static UDAT_MONTH_WEEKDAY_DAY => "MMMMEEEEd"

    /**
     * @type {String}
     */
    static UDAT_ABBR_MONTH_WEEKDAY_DAY => "MMMEd"

    /**
     * @type {String}
     */
    static UDAT_NUM_MONTH_WEEKDAY_DAY => "MEd"

    /**
     * @type {String}
     */
    static UDAT_HOUR => "j"

    /**
     * @type {String}
     */
    static UDAT_HOUR24 => "H"

    /**
     * @type {String}
     */
    static UDAT_MINUTE => "m"

    /**
     * @type {String}
     */
    static UDAT_HOUR_MINUTE => "jm"

    /**
     * @type {String}
     */
    static UDAT_HOUR24_MINUTE => "Hm"

    /**
     * @type {String}
     */
    static UDAT_SECOND => "s"

    /**
     * @type {String}
     */
    static UDAT_HOUR_MINUTE_SECOND => "jms"

    /**
     * @type {String}
     */
    static UDAT_HOUR24_MINUTE_SECOND => "Hms"

    /**
     * @type {String}
     */
    static UDAT_MINUTE_SECOND => "ms"

    /**
     * @type {String}
     */
    static UDAT_LOCATION_TZ => "VVVV"

    /**
     * @type {String}
     */
    static UDAT_GENERIC_TZ => "vvvv"

    /**
     * @type {String}
     */
    static UDAT_ABBR_GENERIC_TZ => "v"

    /**
     * @type {String}
     */
    static UDAT_SPECIFIC_TZ => "zzzz"

    /**
     * @type {String}
     */
    static UDAT_ABBR_SPECIFIC_TZ => "z"

    /**
     * @type {String}
     */
    static UDAT_ABBR_UTC_TZ => "ZZZZ"

    /**
     * @type {Integer (Int32)}
     */
    static USEARCH_DONE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_STD_STRING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UCONFIG_FORMAT_FASTPATHS_49 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_PLATFORM_HAS_WINUWP_API => 0

    /**
     * @type {Integer (UInt32)}
     */
    static U_IOSTREAM_SOURCE => 199711

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_RVALUE_REFERENCES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static U_USING_ICU_NAMESPACE => 1

    /**
     * @type {String}
     */
    static U_ICUDATA_TYPE_LETTER => "e"

    /**
     * @type {String}
     */
    static U_UNICODE_VERSION => "8.0"

    /**
     * @type {Integer (UInt32)}
     */
    static CANITER_SKIP_ZEROES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NUMSYS_NAME_CAPACITY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static U_HAVE_RBNF => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMECP_NAME => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMECSET_NAME => 50

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MIMEFACE_NAME => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_RFC1766_NAME => 6

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LOCALE_NAME => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SCRIPT_NAME => 48

    /**
     * @type {Integer (Int32)}
     */
    static CPIOD_PEEK => 1073741824

    /**
     * @type {Integer (Int32)}
     */
    static CPIOD_FORCE_PROMPT => -2147483648

    /**
     * @type {Integer (Int32)}
     */
    static UITER_UNKNOWN_INDEX => -2

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_SHIFT => 6

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_DATA_BLOCK_LENGTH => 64

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_FAST_DATA_MASK => 63

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_SMALL_MAX => 4095

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET => 1

    /**
     * @type {Integer (Int32)}
     */
    static UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET => 2

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE => 1

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_STABLE_CHUNKS => 2

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_WRITABLE => 3

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_HAS_META_DATA => 4

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_PROVIDER_OWNS_TEXT => 5

    /**
     * @type {Integer (Int32)}
     */
    static UTEXT_MAGIC => 878368812

    /**
     * @type {Integer (Int32)}
     */
    static USET_IGNORE_SPACE => 1

    /**
     * @type {Integer (Int32)}
     */
    static USET_CASE_INSENSITIVE => 2

    /**
     * @type {Integer (Int32)}
     */
    static USET_ADD_CASE_MAPPINGS => 4

    /**
     * @type {Integer (Int32)}
     */
    static USET_SERIALIZED_STATIC_ARRAY_CAPACITY => 8

    /**
     * @type {Integer (Int32)}
     */
    static U_PARSE_CONTEXT_LEN => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_DEFAULT => 0

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_USE_STD3_RULES => 2

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_BIDI => 4

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_CONTEXTJ => 8

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_NONTRANSITIONAL_TO_ASCII => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_NONTRANSITIONAL_TO_UNICODE => 32

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_CHECK_CONTEXTO => 64

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_EMPTY_LABEL => 1

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LABEL_TOO_LONG => 2

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_DOMAIN_NAME_TOO_LONG => 4

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LEADING_HYPHEN => 8

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_TRAILING_HYPHEN => 16

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_HYPHEN_3_4 => 32

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LEADING_COMBINING_MARK => 64

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_DISALLOWED => 128

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_PUNYCODE => 256

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_LABEL_HAS_DOT => 512

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_INVALID_ACE_LABEL => 1024

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_BIDI => 2048

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTJ => 4096

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTO_PUNCTUATION => 8192

    /**
     * @type {Integer (Int32)}
     */
    static UIDNA_ERROR_CONTEXTO_DIGITS => 16384

    /**
     * @type {String}
     */
    static ELS_GUID_LANGUAGE_DETECTION => "{cf7e00b1-909b-4d95-a8f4-611f7c377702}"

    /**
     * @type {String}
     */
    static ELS_GUID_SCRIPT_DETECTION => "{2d64b439-6caf-4f6b-b688-e5d0f4faa7d7}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_HANT_TO_HANS => "{a3a8333b-f4fc-42f6-a0c4-0462fe7317cb}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_HANS_TO_HANT => "{3caccdc8-5590-42dc-9a7b-b5a6b5b3b63b}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_MALAYALAM_TO_LATIN => "{d8b983b1-f8bf-4a2b-bcd5-5b5ea20613e1}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_DEVANAGARI_TO_LATIN => "{c4a4dcfe-2661-4d02-9835-f48187109803}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_CYRILLIC_TO_LATIN => "{3dd12a98-5afd-4903-a13f-e17e6c0bfe01}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_BENGALI_TO_LATIN => "{f4dfd825-91a4-489f-855e-9ad9bee55727}"

    /**
     * @type {String}
     */
    static ELS_GUID_TRANSLITERATION_HANGUL_DECOMPOSITION => "{4ba2a721-e43d-41b7-b330-536ae1e48863}"

    /**
     * @type {Integer (Int32)}
     */
    static UMSGPAT_ARG_NAME_NOT_NUMBER => -1

    /**
     * @type {Integer (Int32)}
     */
    static UMSGPAT_ARG_NAME_NOT_VALID => -2
;@endregion Constants

;@region Methods
    /**
     * Retrieves a character set identifier for the font that is currently selected into a specified device context.
     * @param {HDC} hdc Handle to a device context. The function obtains a character set identifier for the font that is selected into this device context.
     * @returns {Integer} If successful, returns a value identifying the character set of the font that is currently selected into the specified device context. The following character set identifiers are defined:
     * 
     * If the function fails, it returns DEFAULT_CHARSET.
     * @see https://docs.microsoft.com/windows/win32/api//wingdi/nf-wingdi-gettextcharset
     * @since windows5.0
     */
    static GetTextCharset(hdc) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("GDI32.dll\GetTextCharset", "ptr", hdc, "int")
        return result
    }

    /**
     * Retrieves information about the character set of the font that is currently selected into a specified device context.
     * @param {HDC} hdc Handle to a device context. The function obtains information about the font that is selected into this device context.
     * @param {Pointer<FONTSIGNATURE>} lpSig Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> data structure that receives font-signature information.
     * 
     * If a TrueType font is currently selected into the device context, the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure receives information that identifies the code page and Unicode subranges for which the font provides glyphs.
     * 
     * If a font other than TrueType is currently selected into the device context, the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure receives zeros. In this case, the application should use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-translatecharsetinfo">TranslateCharsetInfo</a> function to obtain generic font-signature information for the character set.
     * 
     * The <i>lpSig</i> parameter specifies <b>NULL</b> if the application does not require the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> information. In this case, the application can also call the       <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gettextcharset">GetTextCharset</a> function, which is equivalent to calling       <b>GetTextCharsetInfo</b> with <i>lpSig</i> set to <b>NULL</b>.
     * @param {Integer} dwFlags Reserved; must be set to 0.
     * @returns {Integer} If successful, returns a value identifying the character set of the font currently selected into the specified device context. The following character set identifiers are defined:
     * 
     * If the function fails, the return value is DEFAULT_CHARSET.
     * @see https://docs.microsoft.com/windows/win32/api//wingdi/nf-wingdi-gettextcharsetinfo
     * @since windows5.0
     */
    static GetTextCharsetInfo(hdc, lpSig, dwFlags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("GDI32.dll\GetTextCharsetInfo", "ptr", hdc, "ptr", lpSig, "uint", dwFlags, "int")
        return result
    }

    /**
     * Translates character set information and sets all members of a destination structure to appropriate values.
     * @param {Pointer<UInt32>} lpSrc Pointer to the <b>fsCsb</b> member of a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-fontsignature">FONTSIGNATURE</a> structure if <i>dwFlags</i> is set to TCI_SRCFONTSIG. Otherwise, this parameter is set to a DWORD value indicating the source.
     * @param {Pointer<CHARSETINFO>} lpCs Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-charsetinfo">CHARSETINFO</a> structure that receives the translated character set information.
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wingdi/nf-wingdi-translatecharsetinfo
     * @since windows5.0
     */
    static TranslateCharsetInfo(lpSrc, lpCs, dwFlags) {
        A_LastError := 0

        result := DllCall("GDI32.dll\TranslateCharsetInfo", "uint*", lpSrc, "ptr", lpCs, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a date as a date string for a locale specified by the locale identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale this function formats the date string for. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying date format options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application sets this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {PSTR} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {PSTR} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @returns {Integer} Returns the number of characters written to the <i>lpDateStr</i> buffer if successful. If the <i>cchDate</i> parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformata
     * @since windows5.0
     */
    static GetDateFormatA(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDateStr := lpDateStr is String ? StrPtr(lpDateStr) : lpDateStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDateFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a date as a date string for a locale specified by the locale identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale this function formats the date string for. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying date format options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-getdateformatex">GetDateFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application sets this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {PWSTR} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {PWSTR} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @returns {Integer} Returns the number of characters written to the <i>lpDateStr</i> buffer if successful. If the <i>cchDate</i> parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformatw
     * @since windows5.0
     */
    static GetDateFormatW(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDateStr := lpDateStr is String ? StrPtr(lpDateStr) : lpDateStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDateFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats time as a time string for a locale specified by identifier. The function formats either a specified time or the local system time.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying time format options. For detailed definitions see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {PSTR} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {PSTR} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in TCHAR values, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {Integer} Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpTimeStr</i>. If the <i>cchTime</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-gettimeformata
     * @since windows5.0
     */
    static GetTimeFormatA(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpTimeStr := lpTimeStr is String ? StrPtr(lpTimeStr) : lpTimeStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTimeFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats time as a time string for a locale specified by identifier. The function formats either a specified time or the local system time.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying time format options. For detailed definitions see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/datetimeapi/nf-datetimeapi-gettimeformatex">GetTimeFormatEx</a>.
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {PWSTR} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {PWSTR} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in TCHAR values, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {Integer} Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpTimeStr</i>. If the <i>cchTime</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-gettimeformatw
     * @since windows5.0
     */
    static GetTimeFormatW(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpTimeStr := lpTimeStr is String ? StrPtr(lpTimeStr) : lpTimeStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTimeFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats time as a time string for a locale specified by name.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {Pointer<SYSTEMTIME>} lpTime Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system time.
     * @param {PWSTR} lpFormat Pointer to a format picture to use to format the time string. If the application sets this parameter to <b>NULL</b>, the function formats the string according to the time format of the specified locale. If the application does not set the parameter to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string, for example, the locale-specific time markers. For information about the format picture string, see the Remarks section.
     * @param {PWSTR} lpTimeStr Pointer to a buffer in which this function retrieves the formatted time string.
     * @param {Integer} cchTime Size, in characters, for the time string buffer indicated by <i>lpTimeStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the time string buffer, and does not use the <i>lpTimeStr</i> parameter.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpTimeStr</i>. If the <i>cchTime</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted time string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-gettimeformatex
     * @since windows6.0.6000
     */
    static GetTimeFormatEx(lpLocaleName, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpTimeStr := lpTimeStr is String ? StrPtr(lpTimeStr) : lpTimeStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTimeFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpTime, "ptr", lpFormat, "ptr", lpTimeStr, "int", cchTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a date as a date string for a locale specified by name.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {Pointer<SYSTEMTIME>} lpDate Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the date information to format. The application can set this parameter to <b>NULL</b> if the function is to use the current local system date.
     * @param {PWSTR} lpFormat Pointer to a format picture string that is used to form the date. Possible values for the format picture string are defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/day--month--year--and-era-format-pictures">Day, Month, Year, and Era Format Pictures</a>.
     * 
     * For example, to get the date string "Wed, Aug 31 94", the application uses the picture string "ddd',' MMM dd yy".
     * 
     * The function uses the specified locale only for information not specified in the format picture string, for example, the day and month names for the locale. The application can set this parameter to <b>NULL</b> to format the string according to the date format for the specified locale.
     * @param {PWSTR} lpDateStr Pointer to a buffer in which this function retrieves the formatted date string.
     * @param {Integer} cchDate Size, in characters, of the <i>lpDateStr</i> buffer. The application can set this parameter to 0 to return the buffer size required to hold the formatted date string. In this case, the buffer indicated by <i>lpDateStr</i> is not used.
     * @param {PWSTR} lpCalendar Reserved; must set to <b>NULL</b>.
     * @returns {Integer} Returns the number of characters written to the <i>lpDateStr</i> buffer if successful. If the <i>cchDate</i> parameter is set to 0, the function returns the number of characters required to hold the formatted date string, including the terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//datetimeapi/nf-datetimeapi-getdateformatex
     * @since windows6.0.6000
     */
    static GetDateFormatEx(lpLocaleName, dwFlags, lpDate, lpFormat, lpDateStr, cchDate, lpCalendar) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDateStr := lpDateStr is String ? StrPtr(lpDateStr) : lpDateStr
        lpCalendar := lpCalendar is String ? StrPtr(lpCalendar) : lpCalendar

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDateFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpDate, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "ptr", lpCalendar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a duration of time as a time string for a locale specified by name.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying function options. If <i>lpFormat</i> is not set to <b>NULL</b>, this parameter must be set to 0. If <i>lpFormat</i> is set to <b>NULL</b>, your application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default duration format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of <b>LOCALE_NOUSEROVERRIDE</b> is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {Pointer<SYSTEMTIME>} lpDuration Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time duration information to format. The application sets this parameter to <b>NULL</b> if the function is to ignore it and use <i>ullDuration</i>.
     * @param {Integer} ullDuration 64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both <i>lpDuration</i> and <i>ullDuration</i> are set, the <i>lpDuration</i> parameter takes precedence. If <i>lpDuration</i> is set to <b>NULL</b> and <i>ullDuration</i> is set to 0, the duration is 0.
     * @param {PWSTR} lpFormat Pointer to the format string with characters as shown below. The application can set this parameter to <b>NULL</b> if the function is to format the string according to the duration format for the specified locale. If <i>lpFormat</i> is not set to <b>NULL</b>, the function uses the locale only for information not specified in the format picture string.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="d"></a><a id="D"></a><dl>
     * <dt><b>d</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * days
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="h_or_H"></a><a id="h_or_h"></a><a id="H_OR_H"></a><dl>
     * <dt><b>h or H</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * hours
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="hh_or_HH"></a><a id="hh_or_hh"></a><a id="HH_OR_HH"></a><dl>
     * <dt><b>hh or HH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * hours; if less than ten,  prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="m"></a><a id="M"></a><dl>
     * <dt><b>m</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * minutes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="mm"></a><a id="MM"></a><dl>
     * <dt><b>mm</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * minutes; if less than ten, prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="s"></a><a id="S"></a><dl>
     * <dt><b>s</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * seconds
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ss"></a><a id="SS"></a><dl>
     * <dt><b>ss</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * seconds; if less than ten, prepend a leading zero
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="f"></a><a id="F"></a><dl>
     * <dt><b>f</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * fractions of a second
     * 
     * 
     * <div class="alert"><b>Note</b>The character "f" can occur up to nine consecutive times (fffffffff), although support for frequency timers is limited to 100 nanoseconds. Thus, if nine characters are present, the last two digits are always 0.</div>
     * <div></div>
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpDurationStr Pointer to the buffer in which the function retrieves the duration string.
     * 
     * Alternatively, this parameter retrieves <b>NULL</b> if <i>cchDuration</i> is set to 0. In this case, the function returns the required size for the duration string buffer.
     * @param {Integer} cchDuration Size, in characters, of the buffer indicated by <i>lpDurationStr</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpDurationStr</i> and returns the required size for the duration string buffer.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpDurationStr</i> if successful. If <i>lpDurationStr</i> is set to <b>NULL</b> and <i>cchDuration</i> is set to 0, the function returns the required size for the duration string buffer, including the terminating null character. For example, if 10 characters are written to the buffer, the function returns 11 to include the terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li><b>ERROR_INSUFFICIENT_BUFFER</b>. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>.</li>
     * <li><b>ERROR_INVALID_PARAMETER</b>. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformatex
     * @since windows6.0.6000
     */
    static GetDurationFormatEx(lpLocaleName, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDurationStr := lpDurationStr is String ? StrPtr(lpDurationStr) : lpDurationStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDurationFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpDuration, "uint", ullDuration, "ptr", lpFormat, "ptr", lpDurationStr, "int", cchDuration, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two Unicode (wide character) strings, for a locale specified by name.CautionUsing CompareStringEx incorrectly can compromise the security of your application.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags 
     * @param {PWSTR} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {PWSTR} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of &lt;0, ==0, and &gt;0 is consistent with the C runtime.
     * 
     * <ul>
     * <li>CSTR_LESS_THAN. The string indicated by <i>lpString1</i> is less in lexical value than the string indicated by <i>lpString2</i>.</li>
     * <li>CSTR_EQUAL. The string indicated by <i>lpString1</i> is equivalent in lexical value to the string indicated by <i>lpString2</i>. The two strings are equivalent for sorting purposes, although not necessarily identical.</li>
     * <li>CSTR_GREATER_THAN. The string indicated by <i>lpString1</i> is greater in lexical value than the string indicated by <i>lpString2</i>.</li>
     * </ul>
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were invalid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. </li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringex
     * @since windows6.0.6000
     */
    static CompareStringEx(lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        static lpVersionInformation := 0, lpReserved := 0, lParam := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CompareStringEx", "ptr", lpLocaleName, "uint", dwCmpFlags, "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two Unicode strings to test binary equivalence.
     * @param {PWSTR} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {PWSTR} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>. The application supplies -1 if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {BOOL} bIgnoreCase <b>TRUE</b> if the function is to perform a case-insensitive comparison, using the operating system uppercase table information. The application sets this parameter to <b>FALSE</b> if the function is to compare the strings exactly as they are passed in. Note that 1 is the only numeric value that can be used to specify a true value for this boolean parameter that does not result an invalid parameter error. Boolean values for this parameter work as expected.
     * @returns {Integer} Returns one of the following values if successful. To maintain the C runtime convention of comparing strings, the value 2 can be subtracted from a nonzero return value. Then, the meaning of &lt;0, ==0, and &gt;0 is consistent with the C runtime.
     * 
     * <ul>
     * <li>CSTR_LESS_THAN. The value indicated by <i>lpString1</i> is less than the value indicated by <i>lpString2</i>.</li>
     * <li>CSTR_EQUAL. The value indicated by <i>lpString1</i> equals the value indicated by <i>lpString2</i>.</li>
     * <li>CSTR_GREATER_THAN. The value indicated by <i>lpString1</i> is greater than the value indicated by <i>lpString2</i>.</li>
     * </ul>
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringordinal
     * @since windows6.0.6000
     */
    static CompareStringOrdinal(lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CompareStringOrdinal", "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "int", bIgnoreCase, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two character strings, for a locale specified by identifier.CautionUsing CompareString incorrectly can compromise the security of your application.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale used for the comparison. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags Flags that indicate how the function compares the two strings. For detailed definitions, see the <i>dwCmpFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @param {PWSTR} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {PWSTR} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns the values described for <a href="/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @see https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-comparestringw
     * @since windows5.0
     */
    static CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\CompareStringW", "uint", Locale, "uint", dwCmpFlags, "ptr", lpString1, "int", cchCount1, "ptr", lpString2, "int", cchCount2, "int")
        return result
    }

    /**
     * Maps one Unicode string to another, performing the specified transformation.
     * @param {Integer} dwMapFlags 
     * @param {PWSTR} lpSrcStr Pointer to a source string that the function maps.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>, excluding the terminating null character. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, the function calculates the string length automatically, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * @param {PWSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string. If the MAP_FOLDDIGITS flag is specified, the return value is the maximum size required, even if the actual number of characters needed is smaller than the maximum size. If the maximum size is not passed, the function fails with ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} Returns the number of characters in the translated string, including a terminating null character, if successful. If the function succeeds and the value of <i>cchDest</i> is 0, the return value is the size of the buffer required to hold the translated string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_DATA. The data was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_MOD_NOT_FOUND. The module was not found. </li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation. </li>
     * <li>ERROR_PROC_NOT_FOUND. The required procedure was not found.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-foldstringw
     * @since windows5.0
     */
    static FoldStringW(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FoldStringW", "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves character type information for the characters in the specified source string.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. This value uniquely defines the ANSI code page. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.
     * @param {PWSTR} lpSrcStr Pointer to the string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. The size refers to bytes for the ANSI version of the function or wide characters for the Unicode version. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<UInt16>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li><b>ERROR_INVALID_FLAGS</b>. The values supplied for flags were not valid.</li>
     * <li><b>ERROR_INVALID_PARAMETER</b>. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-getstringtypeexw
     * @since windows5.0
     */
    static GetStringTypeExW(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeExW", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, "ushort*", lpCharType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves character type information for the characters in the specified Unicode source string.
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. This parameter can have the following values. The character types are divided into different levels as described in the Remarks section.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE1"></a><a id="ct_ctype1"></a><dl>
     * <dt><b>CT_CTYPE1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve character type information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE2"></a><a id="ct_ctype2"></a><dl>
     * <dt><b>CT_CTYPE2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve bidirectional layout information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CT_CTYPE3"></a><a id="ct_ctype3"></a><dl>
     * <dt><b>CT_CTYPE3</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve text processing information.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpSrcStr Pointer to the Unicode string for which to retrieve the character types. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<UInt16>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-getstringtypew
     * @since windows5.0
     */
    static GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeW", "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, "ushort*", lpCharType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Maps a character string to a UTF-16 (wide character) string.
     * @param {Integer} CodePage Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system default Windows ANSI code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system Macintosh code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * <div class="alert"><b>Note</b> This value is used primarily in legacy code and should not generally be needed since modern Macintosh computers use Unicode for encoding.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system OEM code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_SYMBOL"></a><a id="cp_symbol"></a><dl>
     * <dt><b>CP_SYMBOL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Symbol code page (42).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows ANSI code page for the current thread. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF7"></a><a id="cp_utf7"></a><dl>
     * <dt><b>CP_UTF7</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-7. Use this value only when forced by a 7-bit transport mechanism. Use of UTF-8 is preferred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF8"></a><a id="cp_utf8"></a><dl>
     * <dt><b>CP_UTF8</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-8.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @param {PSTR} lpMultiByteStr Pointer to the character string to convert.
     * @param {Integer} cbMultiByte Size, in bytes, of the string indicated by the <i>lpMultiByteStr</i> parameter. Alternatively, this parameter can be set to -1 if the string is null-terminated. Note that, if <i>cbMultiByte</i> is 0, the function fails.
     * 
     * If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting Unicode string has a terminating null character, and the length returned by the function includes this character.
     * 
     * If this parameter is set to a positive integer, the function processes exactly the specified number of bytes. If the provided size does not include a terminating null character, the resulting Unicode string is not null-terminated, and the returned length does not include this character.
     * @param {PWSTR} lpWideCharStr Pointer to a buffer that receives the converted string.
     * @param {Integer} cchWideChar Size, in characters, of the buffer indicated by <i>lpWideCharStr</i>. If this value is 0, the function returns the required buffer size, in characters, including any terminating null character, and makes no use of the <i>lpWideCharStr</i> buffer.
     * @returns {Integer} Returns the number of characters written to the buffer indicated by <i>lpWideCharStr</i> if successful. If the function succeeds and <i>cchWideChar</i> is 0, the return value is the required size, in characters, for the buffer indicated by <i>lpWideCharStr</i>. Also see <i>dwFlags</i> for info about how the MB_ERR_INVALID_CHARS flag affects the return value when invalid sequences are input.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. </li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-multibytetowidechar
     * @since windows5.0
     */
    static MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar) {
        lpMultiByteStr := lpMultiByteStr is String ? StrPtr(lpMultiByteStr) : lpMultiByteStr
        lpWideCharStr := lpWideCharStr is String ? StrPtr(lpWideCharStr) : lpWideCharStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MultiByteToWideChar", "uint", CodePage, "uint", dwFlags, "ptr", lpMultiByteStr, "int", cbMultiByte, "ptr", lpWideCharStr, "int", cchWideChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Maps a UTF-16 (wide character) string to a new character string.
     * @param {Integer} CodePage Code page to use in performing the conversion. This parameter can be set to the value of any code page that is installed or available in the operating system. For a list of code pages, see <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>. Your application can also specify one of the values shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system default Windows ANSI code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system Macintosh code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * <div class="alert"><b>Note</b> This value is used primarily in legacy code and should not generally be needed since modern Macintosh computers use Unicode for encoding.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current system OEM code page. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_SYMBOL"></a><a id="cp_symbol"></a><dl>
     * <dt><b>CP_SYMBOL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows2000:</b> Symbol code page (42).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows2000:</b> The Windows ANSI code page for the current thread. 
     * 
     * <div class="alert"><b>Note</b>This value can be different on different computers, even on the same network. It can be changed on the same computer, leading to stored data becoming irrecoverably corrupted. This value is only intended for temporary use and permanent storage should use UTF-16 or UTF-8 if possible.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF7"></a><a id="cp_utf7"></a><dl>
     * <dt><b>CP_UTF7</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-7. Use this value only when forced by a 7-bit transport mechanism. Use of UTF-8 is preferred. With this value set, <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> must be set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_UTF8"></a><a id="cp_utf8"></a><dl>
     * <dt><b>CP_UTF8</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * UTF-8. With this value set, <i>lpDefaultChar</i> and <i>lpUsedDefaultChar</i> must be set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @param {PWSTR} lpWideCharStr Pointer to the Unicode string to convert.
     * @param {Integer} cchWideChar Size, in characters, of the string indicated by <i>lpWideCharStr</i>. Alternatively, this parameter can be set to -1 if the string is null-terminated. If <i>cchWideChar</i> is set to 0, the function fails.
     * 
     * If this parameter is -1, the function processes the entire input string, including the terminating null character. Therefore, the resulting character string has a terminating null character, and the length returned by the function includes this character.
     * 
     * If this parameter is set to a positive integer, the function processes exactly the specified number of characters. If the provided size does not include a terminating null character, the resulting character string is not null-terminated, and the returned length does not include this character.
     * @param {Pointer} lpMultiByteStr Pointer to a buffer that receives the converted string.
     * @param {Integer} cbMultiByte Size, in bytes, of the buffer indicated by <i>lpMultiByteStr</i>. If this parameter is set to 0, the function returns the required buffer size for <i>lpMultiByteStr</i> and makes no use of the output parameter itself.
     * @param {PSTR} lpDefaultChar Pointer to the character to use if a character cannot be represented in the specified code page. The application sets this parameter to <b>NULL</b> if the function is to use a system default value. To obtain the system default character, the application can call the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfo">GetCPInfo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a> function.
     * 
     * For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.
     * @param {Pointer<BOOL>} lpUsedDefaultChar Pointer to a flag that indicates if the function has used a default character in the conversion. The flag is set to <b>TRUE</b> if one or more characters in the source string cannot be represented in the specified code page. Otherwise, the flag is set to <b>FALSE</b>. This parameter can be set to <b>NULL</b>.
     * 
     * For the CP_UTF7 and CP_UTF8 settings for <i>CodePage</i>, this parameter must be set to <b>NULL</b>. Otherwise, the function fails with ERROR_INVALID_PARAMETER.
     * @returns {Integer} If successful, returns the number of bytes written to the buffer pointed to by <i>lpMultiByteStr</i>. If the function succeeds and <i>cbMultiByte</i> is 0, the return value is the required size, in bytes, for the buffer indicated by <i>lpMultiByteStr</i>. Also see <i>dwFlags</i> for info about how the WC_ERR_INVALID_CHARS flag affects the return value when invalid sequences are input.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. </li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//stringapiset/nf-stringapiset-widechartomultibyte
     * @since windows5.0
     */
    static WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar) {
        lpWideCharStr := lpWideCharStr is String ? StrPtr(lpWideCharStr) : lpWideCharStr
        lpDefaultChar := lpDefaultChar is String ? StrPtr(lpDefaultChar) : lpDefaultChar

        A_LastError := 0

        result := DllCall("KERNEL32.dll\WideCharToMultiByte", "uint", CodePage, "uint", dwFlags, "ptr", lpWideCharStr, "int", cchWideChar, "ptr", lpMultiByteStr, "int", cbMultiByte, "ptr", lpDefaultChar, "ptr", lpUsedDefaultChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if a specified code page is valid.
     * @param {Integer} CodePage <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code page identifier</a> for the code page to check.
     * @returns {BOOL} Returns a nonzero value if the code page is valid, or 0 if the code page is invalid.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidcodepage
     * @since windows5.0
     */
    static IsValidCodePage(CodePage) {
        result := DllCall("KERNEL32.dll\IsValidCodePage", "uint", CodePage, "int")
        return result
    }

    /**
     * Retrieves the current Windows ANSI code page identifier for the operating system.CautionThe ANSI API functions, for example, the ANSI version of TextOut, implicitly use GetACP to translate text to or from Unicode.
     * @returns {Integer} Returns the current Windows ANSI code page (ACP) identifier for the operating system. See <a href="/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for Windows ANSI code pages and other code pages.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getacp
     * @since windows5.0
     */
    static GetACP() {
        result := DllCall("KERNEL32.dll\GetACP", "uint")
        return result
    }

    /**
     * Returns the current original equipment manufacturer (OEM) code page identifier for the operating system.
     * @returns {Integer} Returns the current OEM code page identifier for the operating system.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getoemcp
     * @since windows5.0
     */
    static GetOEMCP() {
        result := DllCall("KERNEL32.dll\GetOEMCP", "uint")
        return result
    }

    /**
     * Retrieves information about any valid installed or available code page.
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. For details, see the <i>CodePage</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcpinfoexa">GetCPInfoEx</a>.
     * @param {Pointer<CPINFO>} lpCPInfo Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfo">CPINFO</a> structure that receives information about the code page. See the Remarks section.
     * @returns {BOOL} Returns 1 if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 				
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcpinfo
     * @since windows5.0
     */
    static GetCPInfo(CodePage, lpCPInfo) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfo", "uint", CodePage, "ptr", lpCPInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about any valid installed or available code page.
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. The application can specify the code page identifier for any installed or available code page, or one of the following predefined values. See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for ANSI and other code pages.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the current thread's ANSI code page.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer<CPINFOEXA>} lpCPInfoEx Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure that receives information about the code page.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcpinfoexa
     * @since windows5.0
     */
    static GetCPInfoExA(CodePage, dwFlags, lpCPInfoEx) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfoExA", "uint", CodePage, "uint", dwFlags, "ptr", lpCPInfoEx, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about any valid installed or available code page.
     * @param {Integer} CodePage Identifier for the code page for which to retrieve information. The application can specify the code page identifier for any installed or available code page, or one of the following predefined values. See <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a> for a list of identifiers for ANSI and other code pages.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the current thread's ANSI code page.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer<CPINFOEXW>} lpCPInfoEx Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-cpinfoexa">CPINFOEX</a> structure that receives information about the code page.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcpinfoexw
     * @since windows5.0
     */
    static GetCPInfoExW(CodePage, dwFlags, lpCPInfoEx) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCPInfoExW", "uint", CodePage, "uint", dwFlags, "ptr", lpCPInfoEx, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two character strings, for a locale specified by identifier.CautionUsing CompareString incorrectly can compromise the security of your application.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale used for the comparison. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwCmpFlags Flags that indicate how the function compares the two strings. For detailed definitions, see the <i>dwCmpFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @param {Pointer<SByte>} lpString1 Pointer to the first string to compare.
     * @param {Integer} cchCount1 Length of the string indicated by <i>lpString1</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @param {Pointer<SByte>} lpString2 Pointer to the second string to compare.
     * @param {Integer} cchCount2 Length of the string indicated by <i>lpString2</i>, excluding the terminating null character. This value represents bytes for the ANSI version of the function and wide characters for the Unicode version. The application can supply a negative value if the string is null-terminated. In this case, the function determines the length automatically.
     * @returns {Integer} Returns the values described for <a href="/windows/desktop/api/stringapiset/nf-stringapiset-comparestringex">CompareStringEx</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-comparestringa
     * @since windows5.0
     */
    static CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2) {
        result := DllCall("KERNEL32.dll\CompareStringA", "uint", Locale, "uint", dwCmpFlags, "char*", lpString1, "int", cchCount1, "char*", lpString2, "int", cchCount2, "int")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by identifier.CautionBecause strings with very different binary representations can compare as identical, this function can raise certain security concerns. For more information, see the discussion of comparison functions in Security Considerations:\_International Features.NoteFor interoperability reasons, the application should prefer the FindNLSStringEx function because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Although FindNLSString supports custom locales, most applications should use FindNLSStringEx for this type of support.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFindNLSStringFlags Flags specifying details of the find operation. For detailed definitions, see the <i>dwFindNLSStringFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.
     * @param {PWSTR} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {PWSTR} lpStringValue Pointer to the search string, for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<Int32>} pcchFound Pointer to a buffer containing the length of the string that the function finds. For details, see the <i>pcchFound</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-findnlsstringex">FindNLSStringEx</a>.
     * @returns {Integer} Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. In combination with the value in <i>pcchFound</i>, this index provides the exact location of the entire found string in the source string. A return value of 0 is an error-free index into the source string, and the matching string is in the source string at offset 0.
     * 
     * The function returns -1 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-findnlsstring
     * @since windows6.0.6000
     */
    static FindNLSString(Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound) {
        lpStringSource := lpStringSource is String ? StrPtr(lpStringSource) : lpStringSource
        lpStringValue := lpStringValue is String ? StrPtr(lpStringValue) : lpStringValue

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNLSString", "uint", Locale, "uint", dwFindNLSStringFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, "int*", pcchFound, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flags specifying the type of transformation to use during string mapping or the type of sort key to generate. For detailed definitions, see the <i>dwMapFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * @param {PWSTR} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapString</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {PWSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @returns {Integer} If the function succeeds when used for string mapping, it returns the number of characters in the translated string (see *cchSrc* and *cchDest* for more details).
     * 
     * If the function succeeds when used for string mapping it returns the number of bytes in the sort key.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringw
     * @since windows5.0
     */
    static LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LCMapStringW", "uint", Locale, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flags specifying the type of transformation to use during string mapping or the type of sort key to generate. For detailed definitions, see the <i>dwMapFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringex">LCMapStringEx</a>.
     * @param {PSTR} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapString</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {PSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @returns {Integer} If the function succeeds when used for string mapping, it returns the number of characters in the translated string (see *cchSrc* and *cchDest* for more details).
     * 
     * If the function succeeds when used for string mapping it returns the number of bytes in the sort key.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringa
     * @since windows5.0
     */
    static LCMapStringA(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LCMapStringA", "uint", Locale, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> for which to retrieve information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For detailed definitions, see the <i>LCType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b>For <b>GetLocaleInfo</b>, the value LOCALE_USE_CP_ACP is relevant only for the ANSI version.</div>
     * <div></div>
     * @param {PWSTR} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0. For more information, see the Remarks section.
     * @param {Integer} cchData Size, in TCHAR values, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {Integer} Returns the number of characters retrieved in the locale data buffer if successful and <i>cchData</i> is a nonzero value. If the function succeeds, <i>cchData</i> is nonzero, and <a href="/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> is specified, the return value is the size of the integer retrieved in the data buffer; that is, 2 for the Unicode version of the function or 4 for the ANSI version. If the function succeeds and the value of <i>cchData</i> is 0, the return value is the required size, in characters including a null character, for the locale data buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfow
     * @since windows5.0
     */
    static GetLocaleInfoW(Locale, LCType, lpLCData, cchData) {
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLocaleInfoW", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int", cchData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> for which to retrieve information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For detailed definitions, see the <i>LCType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a>.
     * 
     * <div class="alert"><b>Note</b>For <b>GetLocaleInfo</b>, the value LOCALE_USE_CP_ACP is relevant only for the ANSI version.</div>
     * <div></div>
     * @param {PSTR} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0. For more information, see the Remarks section.
     * @param {Integer} cchData Size, in TCHAR values, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {Integer} Returns the number of characters retrieved in the locale data buffer if successful and <i>cchData</i> is a nonzero value. If the function succeeds, <i>cchData</i> is nonzero, and <a href="/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> is specified, the return value is the size of the integer retrieved in the data buffer; that is, 2 for the Unicode version of the function or 4 for the ANSI version. If the function succeeds and the value of <i>cchData</i> is 0, the return value is the required size, in characters including a null character, for the locale data buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfoa
     * @since windows5.0
     */
    static GetLocaleInfoA(Locale, LCType, lpLCData, cchData) {
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLocaleInfoA", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int", cchData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets an item of information in the user override portion of the current locale. This function does not set the system defaults.
     * @param {Integer} Locale For the ANSI version of the function, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale with the code page used when interpreting the <i>lpLCData</i> information. For the Unicode version, this parameter is ignored.
     * 
     * You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} LCType Type of locale information to set. For valid constants see "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. The application can specify only one value per call, but it can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> with any other constant.
     * @param {PSTR} lpLCData Pointer to a null-terminated string containing the locale information to set. The information must be in the format specific to the specified constant. The application uses a Unicode string for the Unicode version of the function, and an ANSI string for the ANSI version.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INVALID_ACCESS. The access code was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setlocaleinfoa
     * @since windows5.0
     */
    static SetLocaleInfoA(Locale, LCType, lpLCData) {
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetLocaleInfoA", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets an item of information in the user override portion of the current locale. This function does not set the system defaults.
     * @param {Integer} Locale For the ANSI version of the function, the <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale with the code page used when interpreting the <i>lpLCData</i> information. For the Unicode version, this parameter is ignored.
     * 
     * You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} LCType Type of locale information to set. For valid constants see "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. The application can specify only one value per call, but it can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-use-cp-acp">LOCALE_USE_CP_ACP</a> with any other constant.
     * @param {PWSTR} lpLCData Pointer to a null-terminated string containing the locale information to set. The information must be in the format specific to the specified constant. The application uses a Unicode string for the Unicode version of the function, and an ANSI string for the ANSI version.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INVALID_ACCESS. The access code was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setlocaleinfow
     * @since windows5.0
     */
    static SetLocaleInfoW(Locale, LCType, lpLCData) {
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetLocaleInfoW", "uint", Locale, "uint", LCType, "ptr", lpLCData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a calendar for a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 
     * <div class="alert"><b>Note</b><b>GetCalendarInfo</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div></div>
     * CAL_USE_CP_ACP is relevant only for the ANSI version of this function.
     * 
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {PSTR} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<UInt32>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {Integer} Returns the number of characters retrieved in the <i>lpCalData</i> buffer, with <i>cchData</i> set to a nonzero value, if successful. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the calendar information. If the function succeeds, <i>cchData</i> is set 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value retrieved in <i>lpValue</i>, that is, 2 for the Unicode version of the function or 4 for the ANSI version.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfoa
     * @since windows5.0
     */
    static GetCalendarInfoA(Locale, Calendar, CalType, lpCalData, cchData, lpValue) {
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCalendarInfoA", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int", cchData, "uint*", lpValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a calendar for a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 
     * <div class="alert"><b>Note</b><b>GetCalendarInfo</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div></div>
     * CAL_USE_CP_ACP is relevant only for the ANSI version of this function.
     * 
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {PWSTR} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<UInt32>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {Integer} Returns the number of characters retrieved in the <i>lpCalData</i> buffer, with <i>cchData</i> set to a nonzero value, if successful. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the calendar information. If the function succeeds, <i>cchData</i> is set 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value retrieved in <i>lpValue</i>, that is, 2 for the Unicode version of the function or 4 for the ANSI version.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfow
     * @since windows5.0
     */
    static GetCalendarInfoW(Locale, Calendar, CalType, lpCalData, cchData, lpValue) {
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCalendarInfoW", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int", cchData, "uint*", lpValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets an item of locale information for a calendar. For more information, see Date and Calendar.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> for the calendar for which to set information.
     * @param {Integer} CalType Type of calendar information to set. Only the following CALTYPE values are valid for this function. The CAL_USE_CP_ACP constant is only meaningful for the ANSI version of the function.
     * 
     * <ul>
     * <li>CAL_USE_CP_ACP</li>
     * <li>CAL_ITWODIGITYEARMAX</li>
     * </ul>
     * The application can specify only one calendar identifier per call to this function. An exception can be made if the application uses the binary OR operator to combine CAL_USE_CP_ACP with any valid CALTYPE value defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>.
     * @param {PSTR} lpCalData Pointer to a null-terminated calendar information string. The information must be in the format of the specified calendar type.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setcalendarinfoa
     * @since windows5.0
     */
    static SetCalendarInfoA(Locale, Calendar, CalType, lpCalData) {
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetCalendarInfoA", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets an item of locale information for a calendar. For more information, see Date and Calendar.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> for the calendar for which to set information.
     * @param {Integer} CalType Type of calendar information to set. Only the following CALTYPE values are valid for this function. The CAL_USE_CP_ACP constant is only meaningful for the ANSI version of the function.
     * 
     * <ul>
     * <li>CAL_USE_CP_ACP</li>
     * <li>CAL_ITWODIGITYEARMAX</li>
     * </ul>
     * The application can specify only one calendar identifier per call to this function. An exception can be made if the application uses the binary OR operator to combine CAL_USE_CP_ACP with any valid CALTYPE value defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>.
     * @param {PWSTR} lpCalData Pointer to a null-terminated calendar information string. The information must be in the format of the specified calendar type.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setcalendarinfow
     * @since windows5.0
     */
    static SetCalendarInfoW(Locale, Calendar, CalType, lpCalData) {
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetCalendarInfoW", "uint", Locale, "uint", Calendar, "uint", CalType, "ptr", lpCalData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if a specified character is a lead byte for the system default Windows ANSI code page (CP_ACP). A lead byte is the first byte of a two-byte character in a double-byte character set (DBCS) for the code page.
     * @param {Integer} TestChar The character to test.
     * @returns {BOOL} Returns a nonzero value if the test character is potentially a lead byte. The function returns 0 if the test 
     *        character is not a lead byte or if it is a single-byte character. To get extended error information, the 
     *        application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isdbcsleadbyte
     * @since windows5.0
     */
    static IsDBCSLeadByte(TestChar) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsDBCSLeadByte", "char", TestChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if a specified character is potentially a lead byte. A lead byte is the first byte of a two-byte character in a double-byte character set (DBCS) for the code page.
     * @param {Integer} CodePage Identifier of the code page used to check lead byte ranges. This parameter can be one of the code page identifiers defined in <a href="https://docs.microsoft.com/windows/desktop/Intl/unicode-and-character-set-constants">Unicode and Character Set Constants</a> or one of the following predefined values. This function validates lead byte values only in code pages 932, 936, 949, 950, and 1361.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default Windows ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default OEM code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_THREAD_ACP"></a><a id="cp_thread_acp"></a><dl>
     * <dt><b>CP_THREAD_ACP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the Windows ANSI code page for the current thread.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} TestChar The character to test.
     * @returns {BOOL} Returns a nonzero value if the byte is a lead byte. The function returns 0 if the byte is not a lead byte or if the character is a single-byte character. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isdbcsleadbyteex
     * @since windows5.0
     */
    static IsDBCSLeadByteEx(CodePage, TestChar) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsDBCSLeadByteEx", "uint", CodePage, "char", TestChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a locale name to a locale identifier.
     * @param {PWSTR} lpName Pointer to a null-terminated string representing a locale name, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags <b>Prior to Windows7:</b>Reserved; should always be 0.
     * 
     * <b>Beginning in Windows7:</b> Can be set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-allow-neutral-names">LOCALE_ALLOW_NEUTRAL_NAMES</a> to allow the return of a neutral LCID.
     * @returns {Integer} Returns the locale identifier corresponding to the locale name if successful. If the supplied locale name corresponds to a custom locale that is the user default, this function returns <a href="/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>. If the locale name corresponds to a custom locale that is not the user default, the function returns <a href="/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>.
     * 
     * If the locale provided is a transient locale or a CLDR (Unicode Common Locale Data Repository) locale, then the LCID returned is 0x1000.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-localenametolcid
     * @since windows6.0.6000
     */
    static LocaleNameToLCID(lpName, dwFlags) {
        lpName := lpName is String ? StrPtr(lpName) : lpName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LocaleNameToLCID", "ptr", lpName, "uint", dwFlags, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a locale identifier to a locale name.
     * @param {Integer} Locale Locale identifier to translate. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {PWSTR} lpName Pointer to a buffer in which this function retrieves the locale name, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} cchName Size, in characters, of the locale name buffer. The maximum possible length of a locale name, including a terminating null character, is <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply for this parameter.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the locale name buffer.
     * @param {Integer} dwFlags <b>BeforeWindows7:</b> Reserved; should always be 0.
     * 
     * <b>Starting withWindows7:</b> Can be set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-allow-neutral-names">LOCALE_ALLOW_NEUTRAL_NAMES</a> to allow the return of a neutral name.
     * @returns {Integer} Returns the count of characters, including the terminating null character, in the locale name if successful. If the function succeeds and the value of <i>cchName</i> is 0, the return value is the required size, in characters (including nulls), for the locale name buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcidtolocalename
     * @since windows6.0.6000
     */
    static LCIDToLocaleName(Locale, lpName, cchName, dwFlags) {
        lpName := lpName is String ? StrPtr(lpName) : lpName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LCIDToLocaleName", "uint", Locale, "ptr", lpName, "int", cchName, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a duration of time as a time string for a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the duration. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags specifying function options. If <i>lpFormat</i> is not set to <b>NULL</b>, this parameter must be set to 0. If <i>lpFormat</i> is set to <b>NULL</b>, your application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default duration format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {Pointer<SYSTEMTIME>} lpDuration Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure that contains the time duration information to format. If this pointer is <b>NULL</b>, the function ignores this parameter and uses <i>ullDuration</i>.
     * @param {Integer} ullDuration 64-bit unsigned integer that represents the number of 100-nanosecond intervals in the duration. If both <i>lpDuration</i> and <i>ullDuration</i> are present, <i>lpDuration</i> takes precedence. If <i>lpDuration</i> is set to <b>NULL</b> and <i>ullDuration</i> is set to 0, the duration is zero.
     * @param {PWSTR} lpFormat Pointer to the format string. For details, see the <i>lpFormat</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getdurationformatex">GetDurationFormatEx</a>.
     * @param {PWSTR} lpDurationStr Pointer to the buffer in which the function retrieves the duration string.
     * 
     * Alternatively, this parameter can contain <b>NULL</b> if <i>cchDuration</i> is set to 0. In this case, the function returns the required size for the duration string buffer.
     * @param {Integer} cchDuration Size, in characters, of the buffer indicated by <i>lpDurationStr</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpDurationStr</i> and returns the required size for the duration string buffer.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpDurationStr</i> if successful. If <i>lpDurationStr</i> is set to <b>NULL</b> and <i>cchDuration</i> is set to 0, the function returns the required size for the duration string buffer, including the null terminating character. For example, if 10 characters are written to the buffer, the function returns 11 to include the terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getdurationformat
     * @since windows6.0.6000
     */
    static GetDurationFormat(Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration) {
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDurationStr := lpDurationStr is String ? StrPtr(lpDurationStr) : lpDurationStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDurationFormat", "uint", Locale, "uint", dwFlags, "ptr", lpDuration, "uint", ullDuration, "ptr", lpFormat, "ptr", lpDurationStr, "int", cchDuration, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a number string as a number string customized for a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PSTR} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTA>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If this parameter does is not set to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale-specific string value for the negative sign.
     * @param {PSTR} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string.
     * @param {Integer} cchNumber Size, in TCHAR values, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer, and does not use the <i>lpNumberStr</i> parameter.
     * @returns {Integer} Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpNumberStr</i> if successful. If the <i>cchNumber</i> parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformata
     * @since windows5.0
     */
    static GetNumberFormatA(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpNumberStr := lpNumberStr is String ? StrPtr(lpNumberStr) : lpNumberStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNumberFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a number string as a number string customized for a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PWSTR} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If this parameter does is not set to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale-specific string value for the negative sign.
     * @param {PWSTR} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string.
     * @param {Integer} cchNumber Size, in TCHAR values, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer, and does not use the <i>lpNumberStr</i> parameter.
     * @returns {Integer} Returns the number of TCHAR values retrieved in the buffer indicated by <i>lpNumberStr</i> if successful. If the <i>cchNumber</i> parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatw
     * @since windows5.0
     */
    static GetNumberFormatW(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpNumberStr := lpNumberStr is String ? StrPtr(lpNumberStr) : lpNumberStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNumberFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a number string as a currency string for a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the currency string. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling currency format. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PSTR} lpValue For details, see the <i>lpValue</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcurrencyformatex">GetCurrencyFormatEx</a>.
     * @param {Pointer<CURRENCYFMTA>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure, for example, the string value for the negative sign used by the locale.
     * @param {PSTR} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application sets this parameter to 0 if the function is to return the size of the buffer required to hold the formatted currency string. In this case, the <i>lpCurrencyStr</i> parameter is not used.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpCurrencyStr</i> if successful. If the <i>cchCurrency</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformata
     * @since windows5.0
     */
    static GetCurrencyFormatA(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpCurrencyStr := lpCurrencyStr is String ? StrPtr(lpCurrencyStr) : lpCurrencyStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCurrencyFormatA", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a number string as a currency string for a locale specified by identifier.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which this function formats the currency string. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling currency format. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PWSTR} lpValue For details, see the <i>lpValue</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getcurrencyformatex">GetCurrencyFormatEx</a>.
     * @param {Pointer<CURRENCYFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure, for example, the string value for the negative sign used by the locale.
     * @param {PWSTR} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application sets this parameter to 0 if the function is to return the size of the buffer required to hold the formatted currency string. In this case, the <i>lpCurrencyStr</i> parameter is not used.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpCurrencyStr</i> if successful. If the <i>cchCurrency</i> parameter is set to 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatw
     * @since windows5.0
     */
    static GetCurrencyFormatW(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpCurrencyStr := lpCurrencyStr is String ? StrPtr(lpCurrencyStr) : lpCurrencyStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCurrencyFormatW", "uint", Locale, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates calendar information for a specified locale.NoteTo receive a calendar identifier in addition to calendar information, the application should use the EnumCalendarInfoEx function.
     * @param {Pointer<CALINFO_ENUMPROCA>} lpCalInfoEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317806(v=vs.85)">EnumCalendarInfoProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfoa
     * @since windows5.0
     */
    static EnumCalendarInfoA(lpCalInfoEnumProc, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoA", "ptr", lpCalInfoEnumProc, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates calendar information for a specified locale.NoteTo receive a calendar identifier in addition to calendar information, the application should use the EnumCalendarInfoEx function.
     * @param {Pointer<CALINFO_ENUMPROCW>} lpCalInfoEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317806(v=vs.85)">EnumCalendarInfoProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfow
     * @since windows5.0
     */
    static EnumCalendarInfoW(lpCalInfoEnumProc, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoW", "ptr", lpCalInfoEnumProc, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates calendar information for a locale specified by identifier.NoteAny application that runs only on WindowsVista and later should use EnumCalendarInfoExEx in preference to this function.
     * @param {Pointer<CALINFO_ENUMPROCEXA>} lpCalInfoEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317807(v=vs.85)">EnumCalendarInfoProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfoexa
     * @since windows5.0
     */
    static EnumCalendarInfoExA(lpCalInfoEnumProcEx, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExA", "ptr", lpCalInfoEnumProcEx, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates calendar information for a locale specified by identifier.NoteAny application that runs only on WindowsVista and later should use EnumCalendarInfoExEx in preference to this function.
     * @param {Pointer<CALINFO_ENUMPROCEXW>} lpCalInfoEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317807(v=vs.85)">EnumCalendarInfoProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve calendar information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfoexw
     * @since windows5.0
     */
    static EnumCalendarInfoExW(lpCalInfoEnumProcEx, Locale, Calendar, CalType) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExW", "ptr", lpCalInfoEnumProcEx, "uint", Locale, "uint", Calendar, "uint", CalType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by identifier.NoteFor interoperability reasons, the application should prefer the EnumTimeFormatsEx function to EnumTimeFormats because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that runs only on WindowsVista and later should use EnumTimeFormatsEx.
     * @param {Pointer<TIMEFMT_ENUMPROCA>} lpTimeFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317832(v=vs.85)">EnumTimeFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve time format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumtimeformatsa
     * @since windows5.0
     */
    static EnumTimeFormatsA(lpTimeFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsA", "ptr", lpTimeFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by identifier.NoteFor interoperability reasons, the application should prefer the EnumTimeFormatsEx function to EnumTimeFormats because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that runs only on WindowsVista and later should use EnumTimeFormatsEx.
     * @param {Pointer<TIMEFMT_ENUMPROCW>} lpTimeFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317832(v=vs.85)">EnumTimeFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve time format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumtimeformatsw
     * @since windows5.0
     */
    static EnumTimeFormatsW(lpTimeFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsW", "ptr", lpTimeFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale.
     * @param {Pointer<DATEFMT_ENUMPROCA>} lpDateFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317813(v=vs.85)">EnumDateFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsa
     * @since windows5.0
     */
    static EnumDateFormatsA(lpDateFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsA", "ptr", lpDateFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale.
     * @param {Pointer<DATEFMT_ENUMPROCW>} lpDateFmtEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317813(v=vs.85)">EnumDateFormatsProc</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsw
     * @since windows5.0
     */
    static EnumDateFormatsW(lpDateFmtEnumProc, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsW", "ptr", lpDateFmtEnumProc, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale.NoteAny application that runs only on WindowsVista and later should use EnumDateFormatsExEx in preference to this function.
     * @param {Pointer<DATEFMT_ENUMPROCEXA>} lpDateFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317814(v=vs.85)">EnumDateFormatsProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsexa
     * @since windows5.0
     */
    static EnumDateFormatsExA(lpDateFmtEnumProcEx, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExA", "ptr", lpDateFmtEnumProcEx, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a specified locale.NoteAny application that runs only on WindowsVista and later should use EnumDateFormatsExEx in preference to this function.
     * @param {Pointer<DATEFMT_ENUMPROCEXW>} lpDateFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317814(v=vs.85)">EnumDateFormatsProcEx</a>.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale for which to retrieve date format information. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flag specifying date formats. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumdateformatsexex">EnumDateFormatsExEx</a>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsexw
     * @since windows5.0
     */
    static EnumDateFormatsExW(lpDateFmtEnumProcEx, Locale, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExW", "ptr", lpDateFmtEnumProcEx, "uint", Locale, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if a language group is installed or supported on the operating system. For more information, see NLS Terminology.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns <b>TRUE</b> if the language group identifier passes the specified validity test, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidlanguagegroup
     * @since windows5.0
     */
    static IsValidLanguageGroup(LanguageGroup, dwFlags) {
        result := DllCall("KERNEL32.dll\IsValidLanguageGroup", "uint", LanguageGroup, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves information about the current version of a specified NLS capability for a locale specified by identifier.NoteFor interoperability reasons, the application should prefer the GetNLSVersionEx function to GetNLSVersion because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. This recommendation applies especially to custom locales, for which GetNLSVersionEx retrieves enough information to determine if sort behavior has changed. Any application that runs only on WindowsVista and later should use GetNLSVersionEx or at least pass the NLSVERSIONINFOEX structure when calling GetNLSVersion to obtain additional sorting versioning data.
     * @param {Integer} Function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create an identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c>sizeof(NLSVERSIONINFO)</c>.
     * 
     * <div class="alert"><b>Note</b>On WindowsVista and later, the function can alternatively provide version information in an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure.</div>
     * <div></div>
     * @returns {BOOL} Returns <b>TRUE</b> if and only if the application has supplied valid values in <i>lpVersionInformation</i>, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnlsversion
     * @since windows6.0.6000
     */
    static GetNLSVersion(Function, Locale, lpVersionInformation) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNLSVersion", "uint", Function, "uint", Locale, "ptr", lpVersionInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if the specified locale is installed or supported on the operating system. For more information, see Locales and Languages.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale to validate. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * <b>Windows Server2003, WindowsXP and Windows2000:</b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * <b>Windows Server2003, WindowsXP and Windows2000:</b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * <b>Windows Server2003, WindowsXP and Windows2000:</b>This locale identifier is not supported.
     * 
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if the locale identifier passes the specified validity test. The function returns 0 if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidlocale
     * @since windows5.0
     */
    static IsValidLocale(Locale, dwFlags) {
        result := DllCall("KERNEL32.dll\IsValidLocale", "uint", Locale, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves information about a specified geographical location.
     * @param {Integer} Location Identifier for the geographical location for which to get information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/table-of-geographical-locations">Table of Geographical Locations</a>. You can obtain the available values by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeoid">EnumSystemGeoID</a>.
     * @param {Integer} GeoType Type of information to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. If the value of <i>GeoType</i> is GEO_LCID, the function retrieves a locale identifier. If the value of <i>GeoType</i> is GEO_RFC1766, the function retrieves a string name that is compliant with RFC 4646 (WindowsVista). For more information, see the Remarks section.
     * 
     * <b>WindowsXP:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is an 8-digit hexadecimal value.
     * 
     * <b>WindowsMe:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is a decimal value.
     * @param {PSTR} lpGeoData Pointer to the buffer in which this function retrieves the information.
     * @param {Integer} cchData Size of the buffer indicated by <i>lpGeoData</i>. The size is the number of bytes for the ANSI version of the function, or the number of words for the Unicode version. The application can set this parameter to 0 if the function is to return the required size of the buffer.
     * @param {Integer} LangId Identifier for the language, used with the value of <i>Location</i>. The application can set this parameter to 0, with GEO_RFC1766 or GEO_LCID specified for <i>GeoType</i>. This setting causes the function to retrieve the language identifier by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlangid">GetUserDefaultLangID</a>.
     * 
     * <div class="alert"><b>Note</b> The application must set this parameter to 0 if <i>GeoType</i> has any value other than GEO_RFC1766 or GEO_LCID.</div>
     * <div></div>
     * @returns {Integer} Returns the number of bytes (ANSI) or words (Unicode) of geographical location information retrieved in the output buffer. If <i>cchData</i> is set to 0, the function returns the required size for the buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getgeoinfoa
     * @since windows5.1.2600
     */
    static GetGeoInfoA(Location, GeoType, lpGeoData, cchData, LangId) {
        lpGeoData := lpGeoData is String ? StrPtr(lpGeoData) : lpGeoData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetGeoInfoA", "int", Location, "int", GeoType, "ptr", lpGeoData, "int", cchData, "ushort", LangId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a specified geographical location.
     * @param {Integer} Location Identifier for the geographical location for which to get information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/table-of-geographical-locations">Table of Geographical Locations</a>. You can obtain the available values by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeoid">EnumSystemGeoID</a>.
     * @param {Integer} GeoType Type of information to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. If the value of <i>GeoType</i> is GEO_LCID, the function retrieves a locale identifier. If the value of <i>GeoType</i> is GEO_RFC1766, the function retrieves a string name that is compliant with RFC 4646 (WindowsVista). For more information, see the Remarks section.
     * 
     * <b>WindowsXP:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is an 8-digit hexadecimal value.
     * 
     * <b>WindowsMe:</b> When <i>GeoType</i> is set to GEO_LCID, the retrieved string is a decimal value.
     * @param {PWSTR} lpGeoData Pointer to the buffer in which this function retrieves the information.
     * @param {Integer} cchData Size of the buffer indicated by <i>lpGeoData</i>. The size is the number of bytes for the ANSI version of the function, or the number of words for the Unicode version. The application can set this parameter to 0 if the function is to return the required size of the buffer.
     * @param {Integer} LangId Identifier for the language, used with the value of <i>Location</i>. The application can set this parameter to 0, with GEO_RFC1766 or GEO_LCID specified for <i>GeoType</i>. This setting causes the function to retrieve the language identifier by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getuserdefaultlangid">GetUserDefaultLangID</a>.
     * 
     * <div class="alert"><b>Note</b> The application must set this parameter to 0 if <i>GeoType</i> has any value other than GEO_RFC1766 or GEO_LCID.</div>
     * <div></div>
     * @returns {Integer} Returns the number of bytes (ANSI) or words (Unicode) of geographical location information retrieved in the output buffer. If <i>cchData</i> is set to 0, the function returns the required size for the buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getgeoinfow
     * @since windows5.1.2600
     */
    static GetGeoInfoW(Location, GeoType, lpGeoData, cchData, LangId) {
        lpGeoData := lpGeoData is String ? StrPtr(lpGeoData) : lpGeoData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetGeoInfoW", "int", Location, "int", GeoType, "ptr", lpGeoData, "int", cchData, "ushort", LangId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a geographic location that you specify by using a two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code.
     * @param {PWSTR} location The two-letter ISO 3166-1 or numeric UN M.49 code for the geographic location for which to get information.  To get the codes that are available on the operating system, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeonames">EnumSystemGeoNames</a>.
     * @param {Integer} geoType The type of information you want to retrieve. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeotype">SYSGEOTYPE</a> enumeration. The following values of the <b>SYSGEOTYPE</b> enumeration should not be used with <b>GetGeoInfoEx</b>:
     * 
     * <ul>
     * <li>
     * <b>GEO_ID</b>
     * 
     * This value is provided for backward compatibility.  Do not use this value in new applications, but use <b>GEO_NAME</b> instead.
     * 
     * </li>
     * <li>
     * <b>GEO_LCID</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * <li>
     * <b>GEO_NATION</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * <li>
     * <b>GEO_RFC1766</b>
     * 
     * This value is not supported for the <b>GetGeoInfoEx</b> function.
     * 
     * </li>
     * </ul>
     * @param {PWSTR} geoData A pointer to the buffer in which <b>GetGeoInfoEx</b> should write the  requested information.
     * @param {Integer} geoDataCount The size of the buffer to which the <i>GeoData</i> parameter points, in characters. Set this parameter to 0 to specify that the function should only return the size of the buffer required to store the requested information without writing the requested information to the buffer.
     * @returns {Integer} The number of bytes of geographical location information that the function wrote the output buffer. If <i>geoDataCount</i> is  0, the function returns the size of the buffer required to hold the information without writing the information to the buffer.
     * 
     * 0 indicates that the function did not succeed. To get extended error information,  call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The values supplied for flags were not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getgeoinfoex
     * @since windows10.0.16299
     */
    static GetGeoInfoEx(location, geoType, geoData, geoDataCount) {
        location := location is String ? StrPtr(location) : location
        geoData := geoData is String ? StrPtr(geoData) : geoData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetGeoInfoEx", "ptr", location, "int", geoType, "ptr", geoData, "int", geoDataCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the geographical location identifiers (type GEOID) that are available on the operating system.
     * @param {Integer} GeoClass Geographical location class for which to enumerate the identifiers. At present, only GEOCLASS_NATION is supported. This type causes the function to enumerate all geographical identifiers for nations on the operating system.
     * @param {Integer} ParentGeoId Reserved. This parameter must be 0.
     * @param {Pointer<GEO_ENUMPROC>} lpGeoEnumProc Pointer to the application-defined callback function <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317817(v=vs.85)">EnumGeoInfoProc</a>. The <b>EnumSystemGeoID</b> function makes repeated calls to this callback function until it returns <b>FALSE</b>.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemgeoid
     * @since windows5.1.2600
     */
    static EnumSystemGeoID(GeoClass, ParentGeoId, lpGeoEnumProc) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemGeoID", "uint", GeoClass, "int", ParentGeoId, "ptr", lpGeoEnumProc, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the two-letter International Organization for Standardization (ISO) 3166-1 codes or numeric United Nations (UN) Series M, Number 49 (M.49) codes for geographical locations that are available on the operating system.
     * @param {Integer} geoClass The geographical location class for which to enumerate the available two-letter ISO 3166-1 or numeric UN M.49 codes.
     * @param {Pointer<GEO_ENUMNAMEPROC>} geoEnumProc Pointer to the application-defined callback function <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-geo_enumnameproc">Geo_EnumNameProc</a>. The <b>EnumSystemGeoNames</b> function calls this callback function for each of the two-letter ISO 3166-1 or numeric UN M.49 codes for geographical locations that are available on the operating system until callback function returns <b>FALSE</b>.
     * @param {LPARAM} data Application-specific information to pass to the callback function that the <i>genEnumProc</i> parameter specifies.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The values supplied for flags were not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was not valid. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemgeonames
     * @since windows10.0.16299
     */
    static EnumSystemGeoNames(geoClass, geoEnumProc, data) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemGeoNames", "uint", geoClass, "ptr", geoEnumProc, "ptr", data, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the geographical location of the user. For more information, see Table of Geographical Locations.
     * @param {Integer} GeoClass Geographical location class to return. Possible values are defined by the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysgeoclass">SYSGEOCLASS</a> enumeration.
     * @returns {Integer} Returns the geographical location identifier of the user if <a href="/windows/desktop/api/winnls/nf-winnls-setusergeoid">SetUserGeoID</a> has been called before to set the identifier.
     * 
     * If no geographical location identifier has been set for the user, the function returns GEOID_NOT_AVAILABLE.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getusergeoid
     * @since windows5.1.2600
     */
    static GetUserGeoID(GeoClass) {
        result := DllCall("KERNEL32.dll\GetUserGeoID", "int", GeoClass, "int")
        return result
    }

    /**
     * Retrieves the two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code for the default geographical location of the user.
     * @param {PWSTR} geoName Pointer to a buffer in which this function should write the null-terminated two-letter ISO 3166-1 or numeric UN M.49 code for the default geographic location of the user.
     * @param {Integer} geoNameCount The size of the buffer that the <i>geoName</i> parameter specifies. If this value is zero, the function only returns the number of characters that function would copy to the output buffer, but does not write the name of the default geographic location of the user to the buffer.
     * @returns {Integer} The number of characters
     *   the function  would copy to the output buffer, if the value of the <i>geoNameCount</i> parameter is zero. Otherwise, the  number of characters that the function copied to the buffer that the <i>geoName</i> parameter specifies.
     * 
     * Zero indicates that the function failed. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BADDB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not read information from the registry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer that the  <i>geoName</i> parameter specifies is too small for the string. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultgeoname
     * @since windows10.0.16299
     */
    static GetUserDefaultGeoName(geoName, geoNameCount) {
        geoName := geoName is String ? StrPtr(geoName) : geoName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUserDefaultGeoName", "ptr", geoName, "int", geoNameCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the geographical location identifier for the user. This identifier should have one of the values described in Table of Geographical Locations.
     * @param {Integer} GeoId Identifier for the geographical location of the user.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.
     * 
     * <b>WindowsXP, Windows Server2003</b>: This function does not supply extended error information. Thus it is not appropriate for an application to call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> after this function. If the application does call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, it can return a value set by some previously called function.
     * 
     * If this function does not succeed, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_ACCESS_DISABLED_BY_POLICY. The group policy of the computer or the user has forbidden this operation.</li>
     * <li>ERROR_INTERNAL_ERROR. An unexpected error occurred in the function.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setusergeoid
     * @since windows5.1.2600
     */
    static SetUserGeoID(GeoId) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetUserGeoID", "int", GeoId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the geographic location for the current user to the specified two-letter International Organization for Standardization (ISO) 3166-1 code or numeric United Nations (UN) Series M, Number 49 (M.49) code.
     * @param {PWSTR} geoName The two-letter ISO 3166-1 or numeric UN M.49 code for the geographic location to set for the current user. To get the codes that are available on the operating system, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumsystemgeonames">EnumSystemGeoNames</a>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise.
     * 
     * If this function does not succeed, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DISABLED_BY_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The group policy of the computer or the user has forbidden this operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INTERNAL_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unexpected error occurred in the function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter value was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setusergeoname
     * @since windows10.0.16299
     */
    static SetUserGeoName(geoName) {
        geoName := geoName is String ? StrPtr(geoName) : geoName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetUserGeoName", "ptr", geoName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a default locale value to an actual locale identifier.
     * @param {Integer} Locale Default locale identifier value to convert. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @returns {Integer} Returns the appropriate locale identifier if successful.
     * 
     * This function returns the value of the <i>Locale</i> parameter if it does not succeed. The function fails when the <i>Locale</i> value is not one of the default values listed above.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-convertdefaultlocale
     * @since windows5.0
     */
    static ConvertDefaultLocale(Locale) {
        result := DllCall("KERNEL32.dll\ConvertDefaultLocale", "uint", Locale, "uint")
        return result
    }

    /**
     * Retrieves the language identifier for the system default UI language of the operating system, also known as the &quot;install language&quot; on WindowsVista and later. For more information, see User Interface Language Management.
     * @returns {Integer} Returns the language identifier for the system default UI language of the operating system. For more information, see the Remarks section.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystemdefaultuilanguage
     * @since windows5.0
     */
    static GetSystemDefaultUILanguage() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultUILanguage", "ushort")
        return result
    }

    /**
     * Returns the locale identifier of the current locale for the calling thread.NoteThis function can retrieve data that changes between releases, for example, due to a custom locale.
     * @returns {Integer} Returns the <a href="/windows/desktop/Intl/locale-identifiers">locale identifier</a> of the locale associated with the current thread.
     * 
     * <b>WindowsVista</b>: This function can return the identifier of a <a href="/windows/desktop/Intl/custom-locales">custom locale</a>. If the current thread locale is a custom locale, the function returns <a href="/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>. If the current thread locale is a supplemental custom locale, the function can return <a href="/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>. All supplemental locales share this locale identifier.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreadlocale
     * @since windows5.0
     */
    static GetThreadLocale() {
        result := DllCall("KERNEL32.dll\GetThreadLocale", "uint")
        return result
    }

    /**
     * Sets the current locale of the calling thread.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-invariant">LOCALE_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @returns {BOOL} The function should return an LCID on success. This is the LCID of the previous thread locale.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreadlocale
     * @since windows5.0
     */
    static SetThreadLocale(Locale) {
        result := DllCall("KERNEL32.dll\SetThreadLocale", "uint", Locale, "int")
        return result
    }

    /**
     * Returns the language identifier for the user UI language for the current user.
     * @returns {Integer} Returns the <a href="/windows/desktop/Intl/language-identifiers">language identifier</a> for the user UI language for the current user.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultuilanguage
     * @since windows5.0
     */
    static GetUserDefaultUILanguage() {
        result := DllCall("KERNEL32.dll\GetUserDefaultUILanguage", "ushort")
        return result
    }

    /**
     * Returns the language identifier of the Region Format setting for the current user.
     * @returns {Integer} Returns the <a href="/windows/desktop/Intl/language-identifiers">language identifier</a> for the current user as set under <b>Control Panel</b> &gt; <b>Clock, Language, and Region</b> &gt; <b>Change date, time, or number formats</b> &gt; <b>Formats</b> tab &gt; <b>Format</b> dropdown.
     * 
     * For more information on language identifiers, see <a href="/windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultlangid
     * @since windows5.0
     */
    static GetUserDefaultLangID() {
        result := DllCall("KERNEL32.dll\GetUserDefaultLangID", "ushort")
        return result
    }

    /**
     * Returns the language identifier for the system locale.
     * @returns {Integer} Returns the <a href="/windows/desktop/Intl/language-identifiers">language identifier</a> for the system locale. This is  the language used when displaying text in programs that do not support Unicode. It is set by the Administrator under <b>Control Panel</b> &gt; <b>Clock, Language, and Region</b> &gt; <b>Change date, time, or number formats</b> &gt; <b>Administrative</b> tab.
     * 
     * For more information on language identifiers, see <a href="/windows/desktop/Intl/language-identifier-constants-and-strings">Language Identifier Constants and Strings</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystemdefaultlangid
     * @since windows5.0
     */
    static GetSystemDefaultLangID() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultLangID", "ushort")
        return result
    }

    /**
     * Returns the locale identifier for the system locale.NoteAny application that runs only on WindowsVista and later should use GetSystemDefaultLocaleName in preference to this function.
     * @returns {Integer} Returns the locale identifier for the system default locale, identified by <a href="/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystemdefaultlcid
     * @since windows5.0
     */
    static GetSystemDefaultLCID() {
        result := DllCall("KERNEL32.dll\GetSystemDefaultLCID", "uint")
        return result
    }

    /**
     * Returns the locale identifier for the user default locale.CautionIf the user default locale is a custom locale, an application cannot accurately tag data with the value or exchange it.
     * @returns {Integer} Returns the locale identifier for the user default locale, represented as <a href="/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>. If the user default locale is a custom locale, this function always returns <a href="/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>, regardless of the custom locale that is selected. For example, whether the user locale is Hawaiian (US), haw-US, or Fijiian (Fiji), fj-FJ, the function returns the same value.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultlcid
     * @since windows5.0
     */
    static GetUserDefaultLCID() {
        result := DllCall("KERNEL32.dll\GetUserDefaultLCID", "uint")
        return result
    }

    /**
     * Sets the user interface language for the current thread.
     * @param {Integer} LangId <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language identifier</a> for the user interface language for the thread.
     * 
     * <b>WindowsVista and later:</b> The application can specify a language identifier of 0 or a nonzero identifier. For more information, see the Remarks section.
     * 
     * <b>WindowsXP:</b> The application can only set this parameter to 0. This setting causes the function to select the language that best supports the console display. For more information, see the Remarks section.
     * @returns {Integer} Returns the input language identifier if successful. If the input identifier is nonzero, the function returns that value. If the language identifier is 0, the function always succeeds and returns the identifier of the language that best supports the Windows console. See the Remarks section.
     * 
     * If the input language identifier is nonzero and the function fails, the return value differs from the input language identifier. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreaduilanguage
     * @since windows5.1.2600
     */
    static SetThreadUILanguage(LangId) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetThreadUILanguage", "ushort", LangId, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns the language identifier of the first user interface language for the current thread.
     * @returns {Integer} Returns the identifier for a language explicitly associated with the thread by <a href="/windows/desktop/api/winnls/nf-winnls-setthreaduilanguage">SetThreadUILanguage</a> or <a href="/windows/desktop/api/winnls/nf-winnls-setthreadpreferreduilanguages">SetThreadPreferredUILanguages</a>. Alternatively, if no language has been explicitly associated with the current thread, the identifier can indicate a user or system user interface language.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreaduilanguage
     * @since windows6.0.6000
     */
    static GetThreadUILanguage() {
        result := DllCall("KERNEL32.dll\GetThreadUILanguage", "ushort")
        return result
    }

    /**
     * Retrieves the process preferred UI languages. For more information, see User Interface Language Management.
     * @param {Integer} dwFlags Flags identifying the language format to use for the process preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {PWSTR} pwszLanguagesBuffer Optional. Pointer to a double null-terminated multi-string buffer in which the function retrieves an ordered, null-delimited list in preference order, starting with the most preferable. 
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<UInt32>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * If the process preferred UI language list is empty or if the languages specified for the process are not valid, the function succeeds and returns an empty multistring in <i>pwszLanguagesBuffer</i> and 2 in the <i>pcchLanguagesBuffer</i> parameter.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getprocesspreferreduilanguages
     * @since windows6.1
     */
    static GetProcessPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetProcessPreferredUILanguages", "uint", dwFlags, "uint*", pulNumLanguages, "ptr", pwszLanguagesBuffer, "uint*", pcchLanguagesBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the process preferred UI languages for the application process. For more information, see User Interface Language Management.
     * @param {Integer} dwFlags Flags identifying the language format to use for the process preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * We recommend that you use MUI_LANGUAGE_NAME instead of MUI_LANGUAGE_ID.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwszLanguagesBuffer Pointer to a double null-terminated multi-string buffer that contains an ordered, null-delimited list in decreasing order of preference. If there are more than five languages in the buffer, the function only sets the first five valid languages.
     * 
     * Alternatively, this parameter can contain <b>NULL</b> if no language list is required. In this case, the function clears the preferred UI languages for the process.
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages that has been set in the process language list from the input buffer, up to a maximum of five.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error code:
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. An invalid parameter is specified.</li>
     * </ul>
     * If the process preferred UI languages list is empty or if the languages specified for the process are not valid, the function succeeds and sets 0 in the <i>pulNumLanguages</i> parameter.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setprocesspreferreduilanguages
     * @since windows6.1
     */
    static SetProcessPreferredUILanguages(dwFlags, pwszLanguagesBuffer, pulNumLanguages) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetProcessPreferredUILanguages", "uint", dwFlags, "ptr", pwszLanguagesBuffer, "uint*", pulNumLanguages, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the user preferred UI languages. For more information, see User Interface Language Management.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the language format to use for the display language list. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * | Value | Meaning |
     * | --- | --- |
     * | **MUI_LANGUAGE_ID** | Retrieve the language strings in [language identifier](/windows/desktop/Intl/language-identifiers) |
     * | **MUI_LANGUAGE_NAME** | Retrieve the language strings in [language name](/windows/desktop/Intl/language-names) format. |
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages retrieved in *pwszLanguagesBuffer*.
     * @param {PWSTR} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited display language list, in the format specified by *dwflags*. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to **NULL** and *pcchLanguagesBuffer* is set to 0, the function retrieves the required size of the language buffer in *pcchLanguagesBuffer*. The required size includes the two null characters.
     * @param {Pointer<UInt32>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by *pwszLanguagesBuffer*. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and *pwszLanguagesBuffer* is set to **NULL**, the function retrieves the required size of the language buffer in *pcchLanguagesBuffer*.
     * @returns {BOOL} Returns **TRUE** if successful or **FALSE** otherwise. To get extended error information, the application can call [GetLastError function](../errhandlingapi/nf-errhandlingapi-getlasterror.md), which can return one of the following error codes:
     * 
     * - ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to **NULL**.
     * 
     * If the function fails for any other reason, the values of *pulNumLanguages* and *pcchLanguagesBuffer* are undefined.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserpreferreduilanguages
     * @since windows6.0.6000
     */
    static GetUserPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUserPreferredUILanguages", "uint", dwFlags, "uint*", pulNumLanguages, "ptr", pwszLanguagesBuffer, "uint*", pcchLanguagesBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the system preferred UI languages. For more information, see User Interface Language Management.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format to use for the system preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flag specifies whether the function is to validate the list of languages (default) or retrieve the system preferred UI languages list exactly as it is stored in the registry.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MACHINE_LANGUAGE_SETTINGS"></a><a id="mui_machine_language_settings"></a><dl>
     * <dt><b>MUI_MACHINE_LANGUAGE_SETTINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the stored system preferred UI languages list, checking only to ensure that each language name corresponds to a valid NLS locale. If this flag is not set, the function retrieves the system preferred UI languages in <i>pwszLanguagesBuffer</i>, as long as the list is non-empty and meets the validation criteria. Otherwise, the function retrieves the system default user interface language in the language buffer.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {PWSTR} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited system preferred UI languages list, in the format specified by <i>dwFlags</i>. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters
     * @param {Pointer<UInt32>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.
     * </li>
     * </ul>
     * 
     * 
     * If the function fails for any other reason, the parameters <i>pulNumLanguages</i> and <i>pcchLanguagesBuffer</i> are undefined.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystempreferreduilanguages
     * @since windows6.0.6000
     */
    static GetSystemPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetSystemPreferredUILanguages", "uint", dwFlags, "uint*", pulNumLanguages, "ptr", pwszLanguagesBuffer, "uint*", pcchLanguagesBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the thread preferred UI languages for the current thread. For more information, see User Interface Language Management.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the language format to use for the thread preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags specify filtering for the function to use in retrieving the thread preferred UI languages. The default flag is MUI_MERGE_USER_FALLBACK.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MERGE_SYSTEM_FALLBACK"></a><a id="mui_merge_system_fallback"></a><dl>
     * <dt><b>MUI_MERGE_SYSTEM_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system fallback to retrieve a list that corresponds exactly to the language list used by the resource loader. This flag can be used only in combination with MUI_MERGE_USER_FALLBACK. Using the flags in combination alters the usual effect of MUI_MERGE_USER_FALLBACK by including fallback and neutral languages in the list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_MERGE_USER_FALLBACK"></a><a id="mui_merge_user_fallback"></a><dl>
     * <dt><b>MUI_MERGE_USER_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve a composite list consisting of the thread preferred UI languages, followed by process preferred UI languages, followed by any user preferred UI languages that are distinct from these, followed by the system default UI language, if it is not already in the list. If the user preferred UI languages list is empty, the function retrieves the system preferred UI languages. This flag cannot be combined with MUI_THREAD_LANGUAGES.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_THREAD_LANGUAGES"></a><a id="mui_thread_languages"></a><dl>
     * <dt><b>MUI_THREAD_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the thread preferred UI languages for the current thread, or an empty list if no preferred languages are set for the current thread. This flag cannot be combined with MUI_MERGE_USER_FALLBACK or MUI_MERGE_SYSTEM_FALLBACK.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_UI_FALLBACK"></a><a id="mui_ui_fallback"></a><dl>
     * <dt><b>MUI_UI_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve a complete thread preferred UI languages list along with associated fallback and neutral languages. Use of this flag is equivalent to combining MUI_MERGE_SYSTEM_FALLBACK and MUI_MERGE_USER_FALLBACK. (Applicable only for Windows7 and later).
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages retrieved in <i>pwszLanguagesBuffer</i>.
     * @param {PWSTR} pwszLanguagesBuffer Optional. Pointer to a buffer in which this function retrieves an ordered, null-delimited thread preferred UI languages list, in the format specified by <i>dwFlags</i>. This list ends with two null characters. 
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<UInt32>} pcchLanguagesBuffer Pointer to the size, in characters, for the language buffer indicated by <i>pwszLanguagesBuffer</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer</i> is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns one of the following error codes:
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * </ul>
     * 
     * 
     * If the function fails for any other reason, the parameters <i>pulNumLanguages</i> and <i>pcchLanguagesBuffer</i> are undefined.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getthreadpreferreduilanguages
     * @since windows6.0.6000
     */
    static GetThreadPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetThreadPreferredUILanguages", "uint", dwFlags, "uint*", pulNumLanguages, "ptr", pwszLanguagesBuffer, "uint*", pcchLanguagesBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the thread preferred UI languages for the current thread. For more information, see User Interface Language Management.
     * @param {Integer} dwFlags Flags identifying format and filtering for the languages to set. 
     * 
     * The following <i>format flags</i> specify the language format to use for the thread preferred UI languages. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * We recommend that you use MUI_LANGUAGE_NAME instead of MUI_LANGUAGE_ID.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The input parameter language strings are in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following <i>filtering flags</i> specify filtering for the language list. The flags are mutually exclusive. By default, neither MUI_COMPLEX_SCRIPT_FILTER nor MUI_CONSOLE_FILTER is set. For more information about the filtering flags, see the Remarks section.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_COMPLEX_SCRIPT_FILTER"></a><a id="mui_complex_script_filter"></a><dl>
     * <dt><b>MUI_COMPLEX_SCRIPT_FILTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> should replace with the appropriate fallback all languages having <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">complex scripts</a>. When this flag is specified, <b>NULL</b> must be passed for all other parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_CONSOLE_FILTER"></a><a id="mui_console_filter"></a><dl>
     * <dt><b>MUI_CONSOLE_FILTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> should replace with the appropriate fallback all languages that cannot display properly in a console window with the current operating system settings. When this flag is specified, <b>NULL</b> must be passed for all other parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_RESET_FILTERS"></a><a id="mui_reset_filters"></a><dl>
     * <dt><b>MUI_RESET_FILTERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reset the filtering for the language list by removing any other filter settings. When this flag is specified, <b>NULL</b> must be passed for all other parameters. After setting this flag, the application can call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getthreadpreferreduilanguages">GetThreadPreferredUILanguages</a> to retrieve the complete unfiltered list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwszLanguagesBuffer Pointer to a double null-terminated multi-string buffer that contains an ordered, null-delimited list, in the format specified by <i>dwFlags</i>.
     * 
     * To clear the thread preferred UI languages list, an application sets this parameter to a null string or an empty double null-terminated string. 
     * If an application clears a language list, it should specify either a format flag or 0 for the <i>dwFlags</i> parameter.
     * 
     * When the application specifies one of the filtering flags, it must set this parameter to <b>NULL</b>. In this case, the function succeeds, but does not reset the thread preferred languages.
     * @param {Pointer<UInt32>} pulNumLanguages Pointer to the number of languages that the function has set in the thread preferred UI languages list. When the application specifies one of the filtering flags, the function must set this parameter to <b>NULL</b>.
     * @returns {BOOL} Returns <b>TRUE</b> if the function succeeds or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-setthreadpreferreduilanguages
     * @since windows6.0.6000
     */
    static SetThreadPreferredUILanguages(dwFlags, pwszLanguagesBuffer, pulNumLanguages) {
        pwszLanguagesBuffer := pwszLanguagesBuffer is String ? StrPtr(pwszLanguagesBuffer) : pwszLanguagesBuffer

        result := DllCall("KERNEL32.dll\SetThreadPreferredUILanguages", "uint", dwFlags, "ptr", pwszLanguagesBuffer, "uint*", pulNumLanguages, "int")
        return result
    }

    /**
     * Retrieves resource-related information about a file.
     * @param {Integer} dwFlags Flags specifying the information to retrieve. Any combination of the following flags is allowed. The default value of the flags is MUI_QUERY_TYPE | MUI_QUERY_CHECKSUM.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_QUERY_TYPE"></a><a id="mui_query_type"></a><dl>
     * <dt><b>MUI_QUERY_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * @param {PWSTR} pcwszFilePath Pointer to a null-terminated string indicating the path to the file. Typically the file is either an LN file or a language-specific resource file. If it is not one of these types, the only significant value that the function retrieves is MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL. The function only retrieves this value if the MUI_QUERY_RESOURCE_TYPES flag is set.
     * @param {Pointer} pFileMUIInfo Pointer to a buffer containing file information in a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure and possibly in data following that structure. The information buffer might have to be much larger than the size of the structure itself. Depending on flag settings, the function can store considerable information following the structure, at offsets retrieved in the structure. For more information, see the Remarks section.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if <i>pcbFileMUIInfo</i> is set to 0. In this case, the function retrieves the required size for the information buffer in <i>pcbFileMUIInfo</i>.
     * 
     * <div class="alert"><b>Note</b>If the value of <i>pFileMUIInfo</i> is not <b>NULL</b>, the <b>dwSize</b> member must be set to the size of the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure (including the information buffer), and the <b>dwVersion</b> member must be set to the current version of 0x001.</div>
     * <div></div>
     * @param {Pointer<UInt32>} pcbFileMUIInfo Pointer to the buffer size, in bytes, for the file information indicated by <i>pFileMUIInfo</i>. On successful return from the function, this parameter contains the size of the retrieved file information buffer and the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure that contains it.
     * 
     * Alternatively, the application can set this parameter to 0 if it sets <b>NULL</b> in <i>pFileMUIInfo</i>. In this case, the function retrieves the required file information buffer size in <i>pcbFileMUIInfo</i>. To allocate the correct amount of memory, this value should be added to the size of the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> structure itself.
     * 
     * <div class="alert"><b>Note</b>The value of this parameter must match the value of the <b>dwSize</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-filemuiinfo">FILEMUIINFO</a> if the value of <i>pFileMUIInfo</i> is not <b>NULL</b>.</div>
     * <div></div>
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuiinfo
     * @since windows6.0.6000
     */
    static GetFileMUIInfo(dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo) {
        pcwszFilePath := pcwszFilePath is String ? StrPtr(pcwszFilePath) : pcwszFilePath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileMUIInfo", "uint", dwFlags, "ptr", pcwszFilePath, "ptr", pFileMUIInfo, "uint*", pcbFileMUIInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to all language-specific resource files associated with the supplied LN file. The application must call this function repeatedly to get the path for each resource file.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language indicated by <i>pwszLanguage</i>. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language string in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language string in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags specify the filtering for the function to use in locating language-specific resource files if <i>pwszLanguage</i> is set to <b>NULL</b>. The filtering flags are mutually exclusive, and the default is MUI_USER_PREFERRED_UI_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USE_SEARCH_ALL_LANGUAGES"></a><a id="mui_use_search_all_languages"></a><dl>
     * <dt><b>MUI_USE_SEARCH_ALL_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve all language-specific resource files for the path indicated by <i>pcwszFilePath</i>, without considering file licensing. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USER_PREFERRED_UI_LANGUAGES"></a><a id="mui_user_preferred_ui_languages"></a><dl>
     * <dt><b>MUI_USER_PREFERRED_UI_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the files that implement languages in the fallback list. Successive calls enumerate the successive fallbacks, in the appropriate order. The first file indicated by the output value of <i>pcchFileMUIPath</i> should be the best fit. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_USE_INSTALLED_LANGUAGES"></a><a id="mui_use_installed_languages"></a><dl>
     * <dt><b>MUI_USE_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve only the files for the languages installed on the computer. This flag is relevant only if the application supplies a null string for <i>pwszLanguage</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags allow the user to indicate the type of file that is specified by <i>pcwszFilePath</i> so that the function can determine if it must add ".mui" to the file name. The flags are mutually exclusive. If the application passes both flags, the function fails. If the application passes neither flag, the function checks the file in the root folder to verify the file type and decide on file naming.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANG_NEUTRAL_PE_FILE"></a><a id="mui_lang_neutral_pe_file"></a><dl>
     * <dt><b>MUI_LANG_NEUTRAL_PE_FILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not verify the file passed in <i>pcwszFilePath</i> and append ".mui" to the file name before processing. For example, change Abc.exe to Abc.exe.mui.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_NON_LANG_NEUTRAL_FILE"></a><a id="mui_non_lang_neutral_file"></a><dl>
     * <dt><b>MUI_NON_LANG_NEUTRAL_FILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not verify the file passed in <i>pcwszFilePath</i> and do not append ".mui" to the file name before processing. For example, use Abc.txt or Abc.chm.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pcwszFilePath Pointer to a null-terminated string specifying a file path. The path is either for an existing LN file or for a file such as a .txt, .inf, or .msc file. If the file is an LN file, the function looks for files containing the associated language-specific resources. For all other types of files, the function seeks files that correspond exactly to the file name and path indicated. Your application can overwrite the behavior of the file type check by using the MUI_LANG_NEUTRAL_PE_FILE or MUI_NON_LANG_NEUTRAL_FILE flag. For more information, see the Remarks section.
     * 
     * <div class="alert"><b>Note</b>The supplied file path can be a network path: for example, "\\machinename\c$\windows\system32\notepad.exe".</div>
     * <div></div>
     * @param {PWSTR} pwszLanguage Pointer to a buffer containing a language string. On input, this buffer contains the language identifier or language name for which the application should find language-specific resource files, depending on the settings of <i>dwFlags</i>. On successful return from the function, this parameter contains the language of the language-specific resource file that the function has found.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b>, with the value referenced by  <i>pcchLanguage</i> set to 0. In this case, the function retrieves the required buffer size in <i>pcchLanguage</i>.
     * @param {Pointer<UInt32>} pcchLanguage Pointer to the buffer size, in characters, for the language string indicated by <i>pwszLanguage</i>. If the application sets the value referenced by this parameter to 0 and  passes <b>NULL</b> for <i>pwszLanguage</i>, then the required buffer size will be returned in <i>pcchLanguage</i> and the returned buffer size is always <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>, because the function is typically called multiple times in succession. The function cannot determine the exact size of the language name for all successive calls, and cannot extend the buffer on subsequent calls. Thus LOCALE_NAME_MAX_LENGTH is the only safe maximum.
     * @param {PWSTR} pwszFileMUIPath Pointer to a buffer containing the path to the language-specific resource file. It is strongly recommended to allocate this buffer to be of size MAX_PATH.
     * 
     * Alternatively, this parameter can retrieve <b>NULL</b> if the value referenced by <i>pcchFileMUIPath</i> is set to 0. In this case, the function retrieves the required size for the file path buffer in <i>pcchFileMUIPath</i>.
     * @param {Pointer<UInt32>} pcchFileMUIPath Pointer to the buffer size, in characters, for the file path indicated by <i>pwszFileMUIPath</i>. On successful return from the function, this parameter indicates the size of the retrieved file path. If the application sets the value referenced by this parameter to 0, the function retrieves <b>NULL</b> for <i>pwszFileMUIPath</i>, the required buffer size will be returned in <i>pcchFileMUIPath</i> and the returned buffer size is always MAX_PATH, because the function is typically called multiple times in succession. The function cannot determine the exact size of the path for all successive calls, and cannot extend the buffer on subsequent calls. Thus MAX_PATH is the only safe maximum.
     * @param {Pointer<UInt64>} pululEnumerator Pointer to an enumeration variable. The first time this function is called, the value of the variable should be 0. Between subsequent calls, the application should not change the value of this parameter. After the function retrieves all possible language-specific resource file paths, it returns <b>FALSE</b>.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. If the function fails, the output parameters do not change.
     * 
     * To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_NO_MORE_FILES. There were no more files to process.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getfilemuipath
     * @since windows6.0.6000
     */
    static GetFileMUIPath(dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator) {
        pcwszFilePath := pcwszFilePath is String ? StrPtr(pcwszFilePath) : pcwszFilePath
        pwszLanguage := pwszLanguage is String ? StrPtr(pwszLanguage) : pwszLanguage
        pwszFileMUIPath := pwszFileMUIPath is String ? StrPtr(pwszFileMUIPath) : pwszFileMUIPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileMUIPath", "uint", dwFlags, "ptr", pcwszFilePath, "ptr", pwszLanguage, "uint*", pcchLanguage, "ptr", pwszFileMUIPath, "uint*", pcchFileMUIPath, "uint*", pululEnumerator, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a variety of information about an installed UI language
     * @param {Integer} dwFlags Flags defining the format of the specified language. The flags are mutually exclusive, and the default is MUI_LANGUAGE_NAME.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the language strings in <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwmszLanguage Pointer to languages for which the function is to retrieve information. This parameter indicates an ordered, null-delimited list of language identifiers or language names, depending on the flag setting. For information on the use of this parameter, see the Remarks section.
     * @param {PWSTR} pwszFallbackLanguages Pointer to a buffer in which this function retrieves an ordered, null-delimited list of fallback languages, formatted as defined by the setting for <i>dwFlags</i>. This list ends with two null characters.
     * 
     * Alternatively if this parameter is set to <b>NULL</b> and <i>pcchLanguagesBuffer</i> is set to 0, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>. The required size includes the two null characters.
     * @param {Pointer<UInt32>} pcchFallbackLanguages Pointer to the size, in characters, for the language buffer indicated by <i>pwszFallbackLanguages</i>. On successful return from the function, the parameter contains the size of the retrieved language buffer.
     * 
     * Alternatively if this parameter is set to 0 and <i>pwszLanguagesBuffer </i>is set to <b>NULL</b>, the function retrieves the required size of the language buffer in <i>pcchLanguagesBuffer</i>.
     * @param {Pointer<UInt32>} pAttributes Pointer to flags indicating attributes of the input language list. The function always retrieves the flag characterizing the last language listed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_FULL_LANGUAGE"></a><a id="mui_full_language"></a><dl>
     * <dt><b>MUI_FULL_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is fully localized.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_PARTIAL_LANGUAGE"></a><a id="mui_partial_language"></a><dl>
     * <dt><b>MUI_PARTIAL_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is partially localized.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LIP_LANGUAGE"></a><a id="mui_lip_language"></a><dl>
     * <dt><b>MUI_LIP_LANGUAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is an LIP language.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * In addition, <i>pdwAttributes</i> includes one or both of the following flags, as appropriate.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_INSTALLED"></a><a id="mui_language_installed"></a><dl>
     * <dt><b>MUI_LANGUAGE_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is installed on this computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_LICENSED"></a><a id="mui_language_licensed"></a><dl>
     * <dt><b>MUI_LANGUAGE_LICENSED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The language is appropriately licensed for the current user.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid. For more information, see Remarks.</li>
     * <li>ERROR_OBJECT_NAME_NOT_FOUND. The specified object name was not found, or it was not valid, or the first language in the input list is not an installed language. For more information, see Remarks.
     * </li>
     * </ul>
     * If <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns any other error code, the parameters <i>pcchFallbackLanguages</i> and <i>pdwAttributes</i> are undefined.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuilanguageinfo
     * @since windows6.0.6000
     */
    static GetUILanguageInfo(dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes) {
        pwmszLanguage := pwmszLanguage is String ? StrPtr(pwmszLanguage) : pwmszLanguage
        pwszFallbackLanguages := pwszFallbackLanguages is String ? StrPtr(pwszFallbackLanguages) : pwszFallbackLanguages

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUILanguageInfo", "uint", dwFlags, "ptr", pwmszLanguage, "ptr", pwszFallbackLanguages, "uint*", pcchFallbackLanguages, "uint*", pAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Integer} flags 
     * @param {PWSTR} languages 
     * @param {Pointer<UInt32>} numLanguagesSet 
     * @param {Pointer<HSAVEDUILANGUAGES>} snapshot 
     * @returns {BOOL} 
     */
    static SetThreadPreferredUILanguages2(flags, languages, numLanguagesSet, snapshot) {
        languages := languages is String ? StrPtr(languages) : languages

        result := DllCall("KERNEL32.dll\SetThreadPreferredUILanguages2", "uint", flags, "ptr", languages, "uint*", numLanguagesSet, "ptr", snapshot, "int")
        return result
    }

    /**
     * 
     * @param {HSAVEDUILANGUAGES} snapshot 
     * @returns {String} Nothing - always returns an empty string
     */
    static RestoreThreadPreferredUILanguages(snapshot) {
        snapshot := snapshot is Win32Handle ? NumGet(snapshot, "ptr") : snapshot

        DllCall("KERNEL32.dll\RestoreThreadPreferredUILanguages", "ptr", snapshot)
    }

    /**
     * Unsupported. NotifyUILanguageChange may be altered or unavailable.
     * @param {Integer} dwFlags Reserved.
     * @param {PWSTR} pcwstrNewLanguage The new language.
     * @param {PWSTR} pcwstrPreviousLanguage The previous language.
     * @param {Pointer<UInt32>} pdwStatusRtrn A pointer to a <b>DWORD</b> return status.
     * @returns {BOOL} A <b>BOOL</b> datatype.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-notifyuilanguagechange
     * @since windows6.1
     */
    static NotifyUILanguageChange(dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, pdwStatusRtrn) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        pcwstrNewLanguage := pcwstrNewLanguage is String ? StrPtr(pcwstrNewLanguage) : pcwstrNewLanguage
        pcwstrPreviousLanguage := pcwstrPreviousLanguage is String ? StrPtr(pcwstrPreviousLanguage) : pcwstrPreviousLanguage

        result := DllCall("KERNEL32.dll\NotifyUILanguageChange", "uint", dwFlags, "ptr", pcwstrNewLanguage, "ptr", pcwstrPreviousLanguage, "uint", dwReserved, "uint*", pdwStatusRtrn, "int")
        return result
    }

    /**
     * 
     * @param {Integer} Locale 
     * @param {Integer} dwInfoType 
     * @param {PSTR} lpSrcStr 
     * @param {Integer} cchSrc 
     * @param {Pointer<UInt16>} lpCharType 
     * @returns {BOOL} 
     */
    static GetStringTypeExA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr

        result := DllCall("KERNEL32.dll\GetStringTypeExA", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, "ushort*", lpCharType, "int")
        return result
    }

    /**
     * Deprecated.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> that specifies the locale. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelcid">MAKELCID</a> macro to create a locale identifier or use one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-system-default">LOCALE_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>
     * </li>
     * </ul>
     * <b>WindowsVista and later:</b> The following custom locale identifiers are also supported.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UI_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-custom-constants">LOCALE_CUSTOM_UNSPECIFIED</a>
     * </li>
     * </ul>
     * @param {Integer} dwInfoType Flags specifying the character type information to retrieve. For possible flag values, see the <i>dwInfoType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>. For detailed information about the character type bits, see Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew">GetStringTypeW</a>.
     * @param {PSTR} lpSrcStr Pointer to the ANSI string for which to retrieve the character types. The string can be a double-byte character set (DBCS) string if the supplied locale is appropriate for DBCS. The string is assumed to be null-terminated if <i>cchSrc</i> is set to any negative value.
     * @param {Integer} cchSrc Size, in characters, of the string indicated by <i>lpSrcStr</i>. If the size includes a terminating null character, the function retrieves character type information for that character. If the application sets the size to any negative integer, the source string is assumed to be null-terminated and the function calculates the size automatically with an additional character for the null termination.
     * @param {Pointer<UInt16>} lpCharType Pointer to an array of 16-bit values. The length of this array must be large enough to receive one 16-bit value for each character in the source string. If <i>cchSrc</i> is not a negative number, <i>lpCharType</i> should be an array of words with <i>cchSrc</i> elements. If <i>cchSrc</i> is set to a negative number, <i>lpCharType</i> is an array of words with <i>lpSrcStr</i> + 1 elements. When the function returns, this array contains one word corresponding to each character in the source string.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getstringtypea
     * @since windows5.0
     */
    static GetStringTypeA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringTypeA", "uint", Locale, "uint", dwInfoType, "ptr", lpSrcStr, "int", cchSrc, "ushort*", lpCharType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Maps one Unicode string to another, performing the specified transformation.
     * @param {Integer} dwMapFlags 
     * @param {PSTR} lpSrcStr Pointer to a source string that the function maps.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>, excluding the terminating null character. The application can set the parameter to any negative value to specify that the source string is null-terminated. In this case, the function calculates the string length automatically, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * @param {PSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string. If the MAP_FOLDDIGITS flag is specified, the return value is the maximum size required, even if the actual number of characters needed is smaller than the maximum size. If the maximum size is not passed, the function fails with ERROR_INSUFFICIENT_BUFFER.
     * @returns {Integer} Returns the number of characters in the translated string, including a terminating null character, if successful. If the function succeeds and the value of <i>cchDest</i> is 0, the return value is the size of the buffer required to hold the translated string, including a terminating null character.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_DATA. The data was invalid.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_MOD_NOT_FOUND. The module was not found. </li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation. </li>
     * <li>ERROR_PROC_NOT_FOUND. The required procedure was not found.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-foldstringa
     * @since windows5.0
     */
    static FoldStringA(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest) {
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FoldStringA", "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.NoteFor interoperability reasons, the application should prefer the EnumSystemLocalesEx function to EnumSystemLocales because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that will be run only on WindowsVista and later should use EnumSystemLocalesEx.
     * @param {Pointer<LOCALE_ENUMPROCA>} lpLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317822(v=vs.85)">EnumLocalesProc</a>.
     * @param {Integer} dwFlags Flags specifying the locale identifiers to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LCID_SUPPORTED.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_INSTALLED"></a><a id="lcid_installed"></a><dl>
     * <dt><b>LCID_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only installed locale identifiers. This value cannot be used with LCID_SUPPORTED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_SUPPORTED"></a><a id="lcid_supported"></a><dl>
     * <dt><b>LCID_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all supported locale identifiers. This value cannot be used with LCID_INSTALLED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_ALTERNATE_SORTS"></a><a id="lcid_alternate_sorts"></a><dl>
     * <dt><b>LCID_ALTERNATE_SORTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only the alternate sort locale identifiers. If this value is used with either LCID_INSTALLED or LCID_SUPPORTED, the installed or supported locales are retrieved, as well as the alternate sort locale identifiers.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlocalesa
     * @since windows5.0
     */
    static EnumSystemLocalesA(lpLocaleEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesA", "ptr", lpLocaleEnumProc, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.NoteFor interoperability reasons, the application should prefer the EnumSystemLocalesEx function to EnumSystemLocales because Microsoft is migrating toward the use of locale names instead of locale identifiers for new locales. Any application that will be run only on WindowsVista and later should use EnumSystemLocalesEx.
     * @param {Pointer<LOCALE_ENUMPROCW>} lpLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317822(v=vs.85)">EnumLocalesProc</a>.
     * @param {Integer} dwFlags Flags specifying the locale identifiers to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for LCID_SUPPORTED.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_INSTALLED"></a><a id="lcid_installed"></a><dl>
     * <dt><b>LCID_INSTALLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only installed locale identifiers. This value cannot be used with LCID_SUPPORTED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_SUPPORTED"></a><a id="lcid_supported"></a><dl>
     * <dt><b>LCID_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all supported locale identifiers. This value cannot be used with LCID_INSTALLED.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LCID_ALTERNATE_SORTS"></a><a id="lcid_alternate_sorts"></a><dl>
     * <dt><b>LCID_ALTERNATE_SORTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate only the alternate sort locale identifiers. If this value is used with either LCID_INSTALLED or LCID_SUPPORTED, the installed or supported locales are retrieved, as well as the alternate sort locale identifiers.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlocalesw
     * @since windows5.0
     */
    static EnumSystemLocalesW(lpLocaleEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesW", "ptr", lpLocaleEnumProc, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the language groups that are either installed on or supported by an operating system.
     * @param {Pointer<LANGUAGEGROUP_ENUMPROCA>} lpLanguageGroupEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317821(v=vs.85)">EnumLanguageGroupsProc</a>.
     * @param {Integer} dwFlags 
     * @param {Pointer} lParam Application-defined value to pass to the callback function. This parameter can be used in error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlanguagegroupsa
     * @since windows5.0
     */
    static EnumSystemLanguageGroupsA(lpLanguageGroupEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLanguageGroupsA", "ptr", lpLanguageGroupEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the language groups that are either installed on or supported by an operating system.
     * @param {Pointer<LANGUAGEGROUP_ENUMPROCW>} lpLanguageGroupEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317821(v=vs.85)">EnumLanguageGroupsProc</a>.
     * @param {Integer} dwFlags 
     * @param {Pointer} lParam Application-defined value to pass to the callback function. This parameter can be used in error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlanguagegroupsw
     * @since windows5.0
     */
    static EnumSystemLanguageGroupsW(lpLanguageGroupEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLanguageGroupsW", "ptr", lpLanguageGroupEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales in a specified language group.
     * @param {Pointer<LANGGROUPLOCALE_ENUMPROCA>} lpLangGroupLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-langgrouplocale_enumproca">EnumLanguageGroupLocalesProc</a>.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer} lParam An application-defined value to pass to the callback function. This value can be used for error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumlanguagegrouplocalesa
     * @since windows5.0
     */
    static EnumLanguageGroupLocalesA(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumLanguageGroupLocalesA", "ptr", lpLangGroupLocaleEnumProc, "uint", LanguageGroup, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales in a specified language group.
     * @param {Pointer<LANGGROUPLOCALE_ENUMPROCW>} lpLangGroupLocaleEnumProc Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-langgrouplocale_enumproca">EnumLanguageGroupLocalesProc</a>.
     * @param {Integer} LanguageGroup 
     * @param {Integer} dwFlags Reserved; must be 0.
     * @param {Pointer} lParam An application-defined value to pass to the callback function. This value can be used for error checking. It can also be used to ensure thread safety in the callback function.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumlanguagegrouplocalesw
     * @since windows5.0
     */
    static EnumLanguageGroupLocalesW(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumLanguageGroupLocalesW", "ptr", lpLangGroupLocaleEnumProc, "uint", LanguageGroup, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the user interface languages that are available on the operating system and calls the callback function with every language in the list.
     * @param {Pointer<UILANGUAGE_ENUMPROCA>} lpUILanguageEnumProc Pointer to an application-defined <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. <b>EnumUILanguages</b> calls this function repeatedly to enumerate the languages in the list.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language to pass to the callback function. The format flags are mutually exclusive, and MUI_LANGUAGE_ID is the default. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags specify the filtering for the function to use in enumerating the languages. The filtering flags are mutually exclusive, and the default is MUI_LICENSED_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_ALL_INSTALLED_LANGUAGES"></a><a id="mui_all_installed_languages"></a><dl>
     * <dt><b>MUI_ALL_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages available to the operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LICENSED_LANGUAGES"></a><a id="mui_licensed_languages"></a><dl>
     * <dt><b>MUI_LICENSED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed for use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_GROUP_POLICY"></a><a id="mui_group_policy"></a><dl>
     * <dt><b>MUI_GROUP_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed, and that are allowed by 
     * 
     * the group policy.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <b>WindowsVista and later:</b> The application can set <i>dwFlags</i> to 0, or to one or more of the specified flags. A setting of 0 causes the parameter value to default to MUI_LANGUAGE_ID | MUI_LICENSED_LANGUAGES.
     * 
     * <b>Windows2000, WindowsXP, Windows Server2003:</b> The application must set <i>dwFlags</i> to 0.
     * @param {Pointer} lParam Application-defined value.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumuilanguagesa
     * @since windows5.0
     */
    static EnumUILanguagesA(lpUILanguageEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumUILanguagesA", "ptr", lpUILanguageEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the user interface languages that are available on the operating system and calls the callback function with every language in the list.
     * @param {Pointer<UILANGUAGE_ENUMPROCW>} lpUILanguageEnumProc Pointer to an application-defined <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-uilanguage_enumproca">EnumUILanguagesProc</a> callback function. <b>EnumUILanguages</b> calls this function repeatedly to enumerate the languages in the list.
     * @param {Integer} dwFlags Flags identifying language format and filtering. The following flags specify the format of the language to pass to the callback function. The format flags are mutually exclusive, and MUI_LANGUAGE_ID is the default. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_ID"></a><a id="mui_language_id"></a><dl>
     * <dt><b>MUI_LANGUAGE_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LANGUAGE_NAME"></a><a id="mui_language_name"></a><dl>
     * <dt><b>MUI_LANGUAGE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Pass the <a href="https://docs.microsoft.com/windows/desktop/Intl/language-names">language name</a> in the language string to the callback function.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following flags specify the filtering for the function to use in enumerating the languages. The filtering flags are mutually exclusive, and the default is MUI_LICENSED_LANGUAGES.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_ALL_INSTALLED_LANGUAGES"></a><a id="mui_all_installed_languages"></a><dl>
     * <dt><b>MUI_ALL_INSTALLED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages available to the operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_LICENSED_LANGUAGES"></a><a id="mui_licensed_languages"></a><dl>
     * <dt><b>MUI_LICENSED_LANGUAGES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed for use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MUI_GROUP_POLICY"></a><a id="mui_group_policy"></a><dl>
     * <dt><b>MUI_GROUP_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enumerate all installed languages that are available and licensed, and that are allowed by 
     * 
     * the group policy.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <b>WindowsVista and later:</b> The application can set <i>dwFlags</i> to 0, or to one or more of the specified flags. A setting of 0 causes the parameter value to default to MUI_LANGUAGE_ID | MUI_LICENSED_LANGUAGES.
     * 
     * <b>Windows2000, WindowsXP, Windows Server2003:</b> The application must set <i>dwFlags</i> to 0.
     * @param {Pointer} lParam Application-defined value.
     * @returns {BOOL} Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumuilanguagesw
     * @since windows5.0
     */
    static EnumUILanguagesW(lpUILanguageEnumProc, dwFlags, lParam) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumUILanguagesW", "ptr", lpUILanguageEnumProc, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the code pages that are either installed on or supported by an operating system.
     * @param {Pointer<CODEPAGE_ENUMPROCA>} lpCodePageEnumProc Pointer to an application-defined callback function. The <b>EnumSystemCodePages</b> function enumerates code pages by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317809(v=vs.85)">EnumCodePagesProc</a>.
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemcodepagesa
     * @since windows5.0
     */
    static EnumSystemCodePagesA(lpCodePageEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemCodePagesA", "ptr", lpCodePageEnumProc, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the code pages that are either installed on or supported by an operating system.
     * @param {Pointer<CODEPAGE_ENUMPROCW>} lpCodePageEnumProc Pointer to an application-defined callback function. The <b>EnumSystemCodePages</b> function enumerates code pages by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317809(v=vs.85)">EnumCodePagesProc</a>.
     * @param {Integer} dwFlags 
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemcodepagesw
     * @since windows5.0
     */
    static EnumSystemCodePagesW(lpCodePageEnumProc, dwFlags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemCodePagesW", "ptr", lpCodePageEnumProc, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts an internationalized domain name (IDN) or another internationalized label to a Unicode (wide character) representation of the ASCII string that represents the name in the Punycode transfer encoding syntax.
     * @param {Integer} dwFlags Flags specifying conversion options. The following table lists the possible values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_ALLOW_UNASSIGNED"></a><a id="idn_allow_unassigned"></a><dl>
     * <dt><b>IDN_ALLOW_UNASSIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <div class="alert"><b>Note</b>An application can set this value if it is just using a query string for normal lookup, as in a compare operation. However, the application should not set this value for a stored string, which is a string being prepared for storage.</div>
     * <div></div>
     * Allow unassigned code points to be included in the input string. The default is to not allow unassigned code points, and fail with an extended error code of ERROR_INVALID_NAME.
     * 
     * This flag allows the function to process characters that are not currently legal in IDNs, but might be legal in later versions of the IDNA standard. If your application encodes unassigned code points as Punycode, the resulting domain names should be illegal. Security can be compromised if a later version of IDNA makes these names legal or if an application filters out the illegal characters to try to create a legal domain name. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-internationalized-domain-names--idns">Handling Internationalized Domain Names (IDNs)</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_USE_STD3_ASCII_RULES"></a><a id="idn_use_std3_ascii_rules"></a><dl>
     * <dt><b>IDN_USE_STD3_ASCII_RULES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Filter out ASCII characters that are not allowed in STD3 names. The only ASCII characters allowed in the input Unicode string are letters, digits, and the hyphen-minus. The string cannot begin or end with the hyphen-minus. The function fails if the input Unicode string contains ASCII characters, such as "[", "]", or "/", that cannot occur in domain names.<div class="alert"><b>Note</b>Some local networks can allow some of these characters in computer names.</div>
     * <div></div>
     * 
     * 
     * The function fails if the input Unicode string contains control characters (U+0001 through U+0020) or the "delete" character (U+007F). In either case, this flag has no effect on the non-ASCII characters that are allowed in the Unicode string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_EMAIL_ADDRESS"></a><a id="idn_email_address"></a><dl>
     * <dt><b>IDN_EMAIL_ADDRESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Enable EAI algorithmic fallback for the local parts of email addresses (such as <i>&lt;local&gt;</i>@microsoft.com). The default is for this function to fail when an email address has an invalid address or syntax.
     * 
     * An application can set this flag to enable Email Address Internationalization (EAI) to return a discoverable fallback address, if possible. For more information, see the IETF <a href="https://datatracker.ietf.org/wg/eai/charter/">Email Address Internationalization (eai) Charter</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDN_RAW_PUNYCODE"></a><a id="idn_raw_punycode"></a><dl>
     * <dt><b>IDN_RAW_PUNYCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Disable the validation and mapping of Punycode.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpUnicodeCharStr Pointer to a Unicode string representing an IDN or another internationalized label.
     * @param {Integer} cchUnicodeChar Count of characters in the input Unicode string indicated by <i>lpUnicodeCharStr</i>.
     * @param {PWSTR} lpASCIICharStr Pointer to a buffer that receives a Unicode string consisting only of characters in the ASCII character set. On return from this function, the buffer contains the ASCII string equivalent of the string provided in <i>lpUnicodeCharStr</i> under Punycode. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchASCIIChar</i> is set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchASCIIChar Size of the buffer indicated by <i>lpASCIICharStr</i>. The application can set the parameter to 0 to retrieve <b>NULL</b> in <i>lpASCIICharStr</i>.
     * @returns {Integer} Returns the number of characters retrieved in <i>lpASCIICharStr</i> if successful. The retrieved string is null-terminated only if the input Unicode string is null-terminated.
     * 
     * If the function succeeds and the value of <i>cchASCIIChar</i> is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_NAME. An invalid name was supplied to the function. Note that this error code catches all syntax errors. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-idntoascii
     * @since windows6.0.6000
     */
    static IdnToAscii(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar) {
        lpUnicodeCharStr := lpUnicodeCharStr is String ? StrPtr(lpUnicodeCharStr) : lpUnicodeCharStr
        lpASCIICharStr := lpASCIICharStr is String ? StrPtr(lpASCIICharStr) : lpASCIICharStr

        A_LastError := 0

        result := DllCall("NORMALIZ.dll\IdnToAscii", "uint", dwFlags, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar, "ptr", lpASCIICharStr, "int", cchASCIIChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the Punycode form of an internationalized domain name (IDN) or another internationalized label to the normal Unicode UTF-16 encoding syntax.
     * @param {Integer} dwFlags Flags specifying conversion options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {PWSTR} lpASCIICharStr Pointer to a string representing the Punycode encoding of an IDN or another internationalized label. This string must consist only of ASCII characters, and can include Punycode-encoded Unicode. The function decodes Punycode values to their UTF-16 values.
     * @param {Integer} cchASCIIChar Count of characters in the input string indicated by <i>lpASCIICharStr</i>.
     * @param {PWSTR} lpUnicodeCharStr Pointer to a buffer that receives a normal Unicode UTF-16 encoding equivalent to the Punycode value of the input string. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchUnicodeChar</i> set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchUnicodeChar Size, in characters, of the buffer indicated by <i>lpUnicodeCharStr</i>. The application can set the size to 0 to retrieve <b>NULL</b> in <i>lpUnicodeCharStr</i> and have the function return the required buffer size.
     * @returns {Integer} Returns the number of characters retrieved in <i>lpUnicodeCharStr</i> if successful. The retrieved string is null-terminated only if the input string is null-terminated.
     * 
     * If the function succeeds and the value of <i>cchUnicodeChar</i> is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_NAME. An invalid name was supplied to the function. Note that this error code catches all syntax errors. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-idntounicode
     * @since windows6.0.6000
     */
    static IdnToUnicode(dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar) {
        lpASCIICharStr := lpASCIICharStr is String ? StrPtr(lpASCIICharStr) : lpASCIICharStr
        lpUnicodeCharStr := lpUnicodeCharStr is String ? StrPtr(lpUnicodeCharStr) : lpUnicodeCharStr

        A_LastError := 0

        result := DllCall("NORMALIZ.dll\IdnToUnicode", "uint", dwFlags, "ptr", lpASCIICharStr, "int", cchASCIIChar, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts an internationalized domain name (IDN) or another internationalized label to the NamePrep form specified by Network Working Group RFC 3491, but does not perform the additional conversion to Punycode.
     * @param {Integer} dwFlags Flags specifying conversion options. For detailed definitions, see the <i>dwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-idntoascii">IdnToAscii</a>.
     * @param {PWSTR} lpUnicodeCharStr Pointer to a Unicode string representing an IDN or another internationalized label.
     * @param {Integer} cchUnicodeChar Count of Unicode characters in the input Unicode string indicated by <i>lpUnicodeCharStr</i>.
     * @param {PWSTR} lpNameprepCharStr Pointer to a buffer that receives a version of the input Unicode string converted through NamePrep processing. Alternatively, the function can retrieve <b>NULL</b> for this parameter, if <i>cchNameprepChar</i> is set to 0. In this case, the function returns the size required for this buffer.
     * @param {Integer} cchNameprepChar Size, in characters, of the buffer indicated by <i>lpNameprepCharStr</i>. The application can set the size to 0 to retrieve <b>NULL</b> in <i>lpNameprepCharStr</i> and have the function return the required buffer size.
     * @returns {Integer} Returns the number of characters retrieved in <i>lpNameprepCharStr</i> if successful. The retrieved string is null-terminated only if the input Unicode string is null-terminated.
     * 
     * If the function succeeds and the value of <i>cchNameprepChar</i> is 0, the function returns the required size, in characters including a terminating null character if it was part of the input buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_NAME. An invalid name was supplied to the function. Note that this error code catches all syntax errors. </li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-idntonameprepunicode
     * @since windows6.0.6000
     */
    static IdnToNameprepUnicode(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar) {
        lpUnicodeCharStr := lpUnicodeCharStr is String ? StrPtr(lpUnicodeCharStr) : lpUnicodeCharStr
        lpNameprepCharStr := lpNameprepCharStr is String ? StrPtr(lpNameprepCharStr) : lpNameprepCharStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\IdnToNameprepUnicode", "uint", dwFlags, "ptr", lpUnicodeCharStr, "int", cchUnicodeChar, "ptr", lpNameprepCharStr, "int", cchNameprepChar, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Normalizes characters of a text string according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.
     * @param {Integer} NormForm Normalization form to use. <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> specifies the standard Unicode normalization forms.
     * @param {PWSTR} lpSrcString Pointer to the non-normalized source string.
     * @param {Integer} cwSrcLength Length, in characters, of the buffer containing the source string. The application can set this parameter to -1 if the function should assume the string to be null-terminated and calculate the length automatically.
     * @param {PWSTR} lpDstString Pointer to a buffer in which the function retrieves the destination string. Alternatively, this parameter contains <b>NULL</b> if <i>cwDstLength</i> is set to 0.
     * 
     * <div class="alert"><b>Note</b>The function does not null-terminate the string if the input string length is explicitly specified without a terminating null character. To null-terminate the output string, the application should specify -1 or explicitly count the terminating null character for the input string.</div>
     * <div></div>
     * @param {Integer} cwDstLength Length, in characters, of the buffer containing the destination string. Alternatively, the application can set this parameter to 0 to request the function to return the required size for the destination buffer.
     * @returns {Integer} Returns the length of the normalized string in the destination buffer. If <i>cwDstLength</i> is set to 0, the function returns the estimated buffer length required to do the actual conversion.
     * 
     * If the string in the input buffer is null-terminated or if <i>cwSrcLength</i> is -1, the string written to the destination buffer is null-terminated and the returned string length includes the terminating null character.
     * 
     * The function returns a value that is less than or equal to 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in a string. The return value is the negative of the index of the location of the error in the input string.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-normalizestring
     * @since windows6.0.6000
     */
    static NormalizeString(NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength) {
        lpSrcString := lpSrcString is String ? StrPtr(lpSrcString) : lpSrcString
        lpDstString := lpDstString is String ? StrPtr(lpDstString) : lpDstString

        A_LastError := 0

        result := DllCall("KERNEL32.dll\NormalizeString", "int", NormForm, "ptr", lpSrcString, "int", cwSrcLength, "ptr", lpDstString, "int", cwDstLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies that a string is normalized according to Unicode 4.0 TR#15. For more information, see Using Unicode Normalization to Represent Strings.
     * @param {Integer} NormForm Normalization form to use. <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-norm_form">NORM_FORM</a> specifies the standard Unicode normalization forms.
     * @param {PWSTR} lpString Pointer to the string to test.
     * @param {Integer} cwLength Length, in characters, of the input string, including a null terminating character. If this value is -1, the function assumes the string to be null-terminated and calculates the length automatically.
     * @returns {BOOL} Returns <b>TRUE</b> if the input string is already normalized to the appropriate form, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_NO_UNICODE_TRANSLATION. Invalid Unicode was found in string.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * If you need to reliably determine <b>FALSE</b> from an error condition, then it must call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a>(ERROR_SUCCESS).
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isnormalizedstring
     * @since windows6.0.6000
     */
    static IsNormalizedString(NormForm, lpString, cwLength) {
        lpString := lpString is String ? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsNormalizedString", "int", NormForm, "ptr", lpString, "int", cwLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two enumerated lists of scripts.
     * @param {Integer} dwFlags Flags specifying script verification options.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="VS_ALLOW_LATIN"></a><a id="vs_allow_latin"></a><dl>
     * <dt><b>VS_ALLOW_LATIN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow "Latn" (Latin script) in the test list even if it is not in the locale list.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpLocaleScripts Pointer to the locale list, the enumerated list of scripts for a given locale. This list is typically populated by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getlocaleinfoex">GetLocaleInfoEx</a> with <i>LCType</i> set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-sscripts">LOCALE_SSCRIPTS</a>.
     * @param {Integer} cchLocaleScripts Size, in characters, of the string indicated by <i>lpLocaleScripts</i>. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails.
     * @param {PWSTR} lpTestScripts Pointer to the test list, a second enumerated list of scripts. This list is typically populated by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getstringscripts">GetStringScripts</a>.
     * @param {Integer} cchTestScripts Size, in characters, of the string indicated by <i>lpTestScripts</i>. The application sets this parameter to -1 if the string is null-terminated. If this parameter is set to 0, the function fails.
     * @returns {BOOL} Returns <b>TRUE</b> if the test list is non-empty and all items in the list are also included in the locale list. The function still returns <b>TRUE</b> if the locale list contains more scripts than the test list, but all the test list scripts must be contained in the locale list. If VS_ALLOW_LATIN is specified in <i>dwFlags</i>, the function behaves as if "Latn;" is always in the locale list.
     * 
     * In all other cases, the function returns <b>FALSE</b>. This return can indicate that the test list contains an item that is not in the locale list, or it can indicate an error. To distinguish between these two cases, the application should call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-verifyscripts
     * @since windows6.0.6000
     */
    static VerifyScripts(dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts) {
        lpLocaleScripts := lpLocaleScripts is String ? StrPtr(lpLocaleScripts) : lpLocaleScripts
        lpTestScripts := lpTestScripts is String ? StrPtr(lpTestScripts) : lpTestScripts

        A_LastError := 0

        result := DllCall("KERNEL32.dll\VerifyScripts", "uint", dwFlags, "ptr", lpLocaleScripts, "int", cchLocaleScripts, "ptr", lpTestScripts, "int", cchTestScripts, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Provides a list of scripts used in the specified Unicode string.
     * @param {Integer} dwFlags Flags specifying options for script retrieval.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GSS_ALLOW_INHERITED_COMMON"></a><a id="gss_allow_inherited_common"></a><dl>
     * <dt><b>GSS_ALLOW_INHERITED_COMMON</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve "Qaii" (INHERITED) and "Zyyy" (COMMON) script information. This flag does not affect the processing of unassigned characters. These characters in the input string always cause a "Zzzz" (UNASSIGNED script) to appear in the script string.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b> By default, <b>GetStringScripts</b> ignores any inherited or common characters in the input string indicated by <i>lpString</i>. If GSS_ALLOW_INHERITED_COMMON is not set, neither "Qaii" nor "Zyyy" appears in the script string, even if the input string contains such characters. If GSS_ALLOW_INHERITED_COMMON is set, and if the input string contains inherited and/or common characters, "Qaii" and/or "Zyyy", respectively, appear in the script string. See the Remarks section.</div>
     * <div></div>
     * @param {PWSTR} lpString Pointer to the Unicode string to analyze.
     * @param {Integer} cchString Size, in characters, of the Unicode string indicated by <i>lpString</i>. The application sets this parameter to -1 if the Unicode string is null-terminated. If the application sets this parameter to 0, the function retrieves a null Unicode string (L"\0") in <i>lpScripts</i> and returns 1.
     * @param {PWSTR} lpScripts Pointer to a buffer in which this function retrieves a null-terminated string representing a list of scripts, using the 4-character notation used in <a href="http://www.unicode.org/iso15924/iso15924-codes.html">ISO 15924</a>. Each script name consists of four Latin characters, and the names are retrieved in alphabetical order. Each name, including the last, is followed by a semicolon.
     * 
     * Alternatively, this parameter contains <b>NULL</b> if <i>cchScripts</i> is set to 0. In this case, the function returns the required size for the script buffer.
     * @param {Integer} cchScripts Size, in characters, of the script buffer indicated by <i>lpScripts</i>.
     * 
     * Alternatively, the application can set this parameter to 0. In this case, the function retrieves <b>NULL</b> in <i>lpScripts</i> and returns the required size for the script buffer.
     * @returns {Integer} Returns the number of characters retrieved in the output buffer, including a terminating null character, if successful and <i>cchScripts</i> is set to a nonzero value. The function returns 1 to indicate that no script has been found, for example, when the input string only contains COMMON or INHERITED characters and GSS_ALLOW_INHERITED_COMMON is not set. Given that each found script adds five characters (four characters + delimiter), a simple mathematical operation provides the script count as (return_code - 1) / 5.
     * 
     * If the function succeeds and the value of <i>cchScripts</i> is 0, the function returns the required size, in characters including a terminating null character, for the script buffer. The script count is as described above.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getstringscripts
     * @since windows6.0.6000
     */
    static GetStringScripts(dwFlags, lpString, cchString, lpScripts, cchScripts) {
        lpString := lpString is String ? StrPtr(lpString) : lpString
        lpScripts := lpScripts is String ? StrPtr(lpScripts) : lpScripts

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetStringScripts", "uint", dwFlags, "ptr", lpString, "int", cchString, "ptr", lpScripts, "int", cchScripts, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a locale specified by name.NoteThe application should call this function in preference to GetLocaleInfo if designed to run only on WindowsVista and later.NoteThis function can retrieve data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} LCType The locale information to retrieve. For possible values, see the "Constants Used in the LCType Parameter of GetLocaleInfo, GetLocaleInfoEx, and SetLocaleInfo" section in <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-information-constants">Locale Information Constants</a>. Note that only one piece of locale information can be specified per call. 
     * 
     * The application can use the binary OR operator to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> with any other allowed constant. In this case, the function retrieves the value as a number instead of a string. The buffer that receives the value must be at least the length of a DWORD value, which is 2.
     * 
     * <div class="alert"><b>Caution</b>It is also possible to combine <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> with any other constant. However, use of this constant is strongly discouraged. (Even without using the current user override, the data can differ from computer to computer, and custom locales can change the data. For example, even month or day names are subject to spelling reforms.)</div>
     * <div></div>
     * If <i>LCType</i> is set to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ioptionalcalendar">LOCALE_IOPTIONALCALENDAR</a>, the function retrieves only the first alternate calendar. 
     * 
     * <div class="alert"><b>Note</b>To get all alternate calendars, the application should use <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-enumcalendarinfoexa">EnumCalendarInfoEx</a>.</div>
     * <div></div>
     * Starting with WindowsVista, your applications should not use <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-ilanguage">LOCALE_ILANGUAGE</a> in the <i>LCType</i> parameter to avoid failure or retrieval of unexpected data. Instead, it is recommended for your applications to call <b>GetLocaleInfoEx</b>.
     * @param {PWSTR} lpLCData Pointer to a buffer in which this function retrieves the requested locale information. This pointer is not used if <i>cchData</i> is set to 0.
     * @param {Integer} cchData Size, in characters, of the data buffer indicated by <i>lpLCData</i>. Alternatively, the application can set this parameter to 0. In this case, the function does not use the <i>lpLCData</i> parameter and returns the required buffer size, including the terminating null character.
     * @returns {Integer} Returns the number of characters retrieved in the locale data buffer if successful and <i>cchData</i> is a nonzero value. If the function succeeds, <i>cchData</i> is nonzero, and <a href="/windows/desktop/Intl/locale-return-constants">LOCALE_RETURN_NUMBER</a> is specified, the return value is the size of the integer retrieved in the data buffer, that is, 2. If the function succeeds and the value of <i>cchData</i> is 0, the return value is the required size, in characters including a null character, for the locale data buffer.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getlocaleinfoex
     * @since windows6.0.6000
     */
    static GetLocaleInfoEx(lpLocaleName, LCType, lpLCData, cchData) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpLCData := lpLCData is String ? StrPtr(lpLCData) : lpLCData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLocaleInfoEx", "ptr", lpLocaleName, "uint", LCType, "ptr", lpLCData, "int", cchData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a calendar for a locale specified by name.NoteThe application should call this function in preference to GetCalendarInfo if designed to run only on WindowsVista and later.NoteThis function can retrieve data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a>.
     * @param {Integer} CalType Type of information to retrieve. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. 
     * 			 
     * 
     * <div class="alert"><b>Note</b><b>GetCalendarInfoEx</b> returns only one string if this parameter specifies CAL_IYEAROFFSETRANGE or CAL_SERASTRING. In both cases the current era is returned.</div>
     * <div></div>
     * For CAL_NOUSEROVERRIDE, the function ignores any value set by <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-setcalendarinfoa">SetCalendarInfo</a> and uses the database settings for the current system default locale. This type is relevant only in the combination CAL_NOUSEROVERRIDE | CAL_ITWODIGITYEARMAX. CAL_ITWODIGITYEARMAX is the only value that can be set by <b>SetCalendarInfo</b>.
     * @param {PWSTR} lpCalData Pointer to a buffer in which this function retrieves the requested data as a string. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, this parameter must retrieve <b>NULL</b>.
     * @param {Integer} cchData Size, in characters, of the <i>lpCalData</i> buffer. The application can set this parameter to 0 to return the required size for the calendar data buffer. In this case, the <i>lpCalData</i> parameter is not used. If CAL_RETURN_NUMBER is specified for <i>CalType</i>, the value of <i>cchData</i> must be 0.
     * @param {Pointer<UInt32>} lpValue Pointer to a variable that receives the requested data as a number. If CAL_RETURN_NUMBER is specified in <i>CalType</i>, then <i>lpValue</i> must not be <b>NULL</b>. If CAL_RETURN_NUMBER is not specified in <i>CalType</i>, then <i>lpValue</i> must be <b>NULL</b>.
     * @returns {Integer} Returns the number of characters retrieved in the <i>lpCalData</i> buffer if successful. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is not specified, the return value is the size of the buffer required to hold the locale information. If the function succeeds, <i>cchData</i> is set to 0, and CAL_RETURN_NUMBER is specified, the return value is the size of the value written to the <i>lpValue</i> parameter. This size is always 2.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcalendarinfoex
     * @since windows6.0.6000
     */
    static GetCalendarInfoEx(lpLocaleName, Calendar, CalType, lpCalData, cchData, lpValue) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpReserved := lpReserved is String ? StrPtr(lpReserved) : lpReserved
        lpCalData := lpCalData is String ? StrPtr(lpCalData) : lpCalData

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCalendarInfoEx", "ptr", lpLocaleName, "uint", Calendar, "ptr", lpReserved, "uint", CalType, "ptr", lpCalData, "int", cchData, "uint*", lpValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a number string as a number string customized for a locale specified by name.NoteThe application should call this function in preference to GetNumberFormat if designed to run only on WindowsVista and later.NoteThis function can format data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default number format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default number format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of LOCALE_NOUSEROVERRIDE is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PWSTR} lpValue Pointer to a null-terminated string containing the number string to format. This string can only contain the following characters. All other characters are invalid. The function returns an error if the string indicated by <i>lpValue</i> deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9".</li>
     * <li>One decimal point (dot) if the number is a floating-point value.</li>
     * <li>A minus sign in the first character position if the number is a negative value.</li>
     * </ul>
     * @param {Pointer<NUMBERFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-numberfmta">NUMBERFMT</a> structure that contains number formatting information, with all members set to appropriate values. If the application does not set this parameter to <b>NULL</b>, the function uses the locale only for formatting information not specified in the structure, for example, the locale string value for the negative sign.
     * @param {PWSTR} lpNumberStr Pointer to a buffer in which this function retrieves the formatted number string. Alternatively, this parameter contains <b>NULL</b> if <i>cchNumber</i> is set to 0. In this case, the function returns the required size for the number string buffer.
     * @param {Integer} cchNumber Size, in characters, for the number string buffer indicated by <i>lpNumberStr</i>. Alternatively, the application can set this parameter to 0. In this case, the function returns the required size for the number string buffer and does not use the <i>lpNumberStr</i> parameter.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpNumberStr</i> if successful. If the <i>cchNumber</i> parameter is set to 0, the function returns the number of characters required to hold the formatted number string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_OUTOFMEMORY. Not enough storage was available to complete this operation.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnumberformatex
     * @since windows6.0.6000
     */
    static GetNumberFormatEx(lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpNumberStr := lpNumberStr is String ? StrPtr(lpNumberStr) : lpNumberStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNumberFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpNumberStr, "int", cchNumber, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Formats a number string as a currency string for a locale specified by name.NoteThe application should call this function in preference to GetCurrencyFormat if designed to run only on WindowsVista and later.NoteThis function can format data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a> or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags Flags controlling the operation of the function. The application must set this parameter to 0 if <i>lpFormat</i> is not set to <b>NULL</b>. In this case, the function formats the string using user overrides to the default currency format for the locale. If <i>lpFormat</i> is set to <b>NULL</b>, the application can specify <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to format the string using the system default currency format for the specified locale.
     * 
     * <div class="alert"><b>Caution</b>Use of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> is strongly discouraged as it disables user preferences.</div>
     * <div></div>
     * @param {PWSTR} lpValue Pointer to a null-terminated string containing the number string to format. This string can contain only the following characters. All other characters are invalid. The function returns an error if the string deviates from these rules.
     * 
     * <ul>
     * <li>Characters "0" through "9"</li>
     * <li>One decimal point (dot) if the number is a floating-point value</li>
     * <li>A minus sign in the first character position if the number is a negative value</li>
     * </ul>
     * @param {Pointer<CURRENCYFMTW>} lpFormat Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-currencyfmta">CURRENCYFMT</a> structure that contains currency formatting information. All members of the structure must contain appropriate values. The application can set this parameter to <b>NULL</b> if function is to use the currency format of the specified locale. If this parameter is not set to <b>NULL</b>, the function uses the specified locale only for formatting information not specified in the <b>CURRENCYFMT</b> structure, for example, the string value for the negative sign used by the locale.
     * @param {PWSTR} lpCurrencyStr Pointer to a buffer in which this function retrieves the formatted currency string.
     * @param {Integer} cchCurrency Size, in characters, of the <i>lpCurrencyStr</i> buffer. The application can set this parameter to 0 to return the size of the buffer required to hold the formatted currency string. In this case, the buffer indicated by <i>lpCurrencyStr</i> is not used.
     * @returns {Integer} Returns the number of characters retrieved in the buffer indicated by <i>lpCurrencyStr</i> if successful. If the <i>cchCurrency</i> parameter is 0, the function returns the size of the buffer required to hold the formatted currency string, including a terminating null character.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getcurrencyformatex
     * @since windows5.0
     */
    static GetCurrencyFormatEx(lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpValue := lpValue is String ? StrPtr(lpValue) : lpValue
        lpCurrencyStr := lpCurrencyStr is String ? StrPtr(lpCurrencyStr) : lpCurrencyStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCurrencyFormatEx", "ptr", lpLocaleName, "uint", dwFlags, "ptr", lpValue, "ptr", lpFormat, "ptr", lpCurrencyStr, "int", cchCurrency, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the user default locale name.NoteThe application should call this function in preference to GetUserDefaultLCID if designed to run only on WindowsVista and later.
     * @param {PWSTR} lpLocaleName Pointer to a buffer in which this function retrieves the locale name.
     * @param {Integer} cchLocaleName Size, in characters, of the buffer indicated by <i>lpLocaleName</i>. The maximum possible length of a locale name, including a terminating null character, is <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply in this parameter.
     * @returns {Integer} Returns the size of the buffer containing the locale name, including the terminating null character, if successful.<div class="alert"><b>Note</b>On single-user systems, the return value is the same as that returned by <a href="/windows/desktop/api/winnls/nf-winnls-getsystemdefaultlocalename">GetSystemDefaultLocaleName</a>.</div>
     * <div></div>
     * 
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getuserdefaultlocalename
     * @since windows6.0.6000
     */
    static GetUserDefaultLocaleName(lpLocaleName, cchLocaleName) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetUserDefaultLocaleName", "ptr", lpLocaleName, "int", cchLocaleName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the system default locale name.NoteIt is recommended that applications call GetUserDefaultLocaleName in preference over this function.
     * @param {PWSTR} lpLocaleName Pointer to a buffer in which this function retrieves the locale name.
     * @param {Integer} cchLocaleName Size, in characters, of the output buffer indicated by <i>lpLocaleName</i>. The maximum possible character length of a locale name (including a terminating null character) is the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size.
     * @returns {Integer} Returns a value greater than 0 that indicates the length of the locale name, including the terminating null character, if successful.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getsystemdefaultlocalename
     * @since windows6.0.6000
     */
    static GetSystemDefaultLocaleName(lpLocaleName, cchLocaleName) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetSystemDefaultLocaleName", "ptr", lpLocaleName, "int", cchLocaleName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if each character in a string has a defined result for a specified NLS capability.
     * @param {Integer} Function NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {Integer} dwFlags Flags defining the function. Must be 0.
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure containing version information. Typically, the information is obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversion">GetNLSVersion</a>. The application sets this parameter to <b>NULL</b> if the function is to use the current version.
     * @param {PWSTR} lpString Pointer to the UTF-16 string to examine.
     * @param {Integer} cchStr Number of UTF-16 characters in the string indicated by <i>lpString</i>. This count can include a terminating null character. If the terminating null character is included in the character count, it does not affect the checking behavior because the terminating null character is always defined.
     * 
     * The application should supply -1 to indicate that the string is null-terminated. In this case, the function itself calculates the string length.
     * @returns {BOOL} Returns <b>TRUE</b> if successful, only if the input string is valid, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isnlsdefinedstring
     * @since windows6.0.6000
     */
    static IsNLSDefinedString(Function, dwFlags, lpVersionInformation, lpString, cchStr) {
        lpString := lpString is String ? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("KERNEL32.dll\IsNLSDefinedString", "uint", Function, "uint", dwFlags, "ptr", lpVersionInformation, "ptr", lpString, "int", cchStr, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the current version of a specified NLS capability for a locale specified by name.NoteThe application should call this function in preference to GetNLSVersion if designed to run only on WindowsVista and later.
     * @param {Integer} function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFOEX>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c> sizeof(NLSVERSIONINFOEX)</c>. 
     * 
     * <div class="alert"><b>Note</b>On WindowsVista and later, the function can alternatively provide version information in an <a href="https://docs.microsoft.com/windows/win32/api/winnls/ns-winnls-nlsversioninfo-r1">NLSVERSIONINFO</a> structure.</div>
     * <div></div>
     * @returns {BOOL} Returns <b>TRUE</b> if and only if the application has supplied valid values in <i>lpVersionInformation</i>, or <b>FALSE</b> otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or  it was incorrectly set to <b>NULL</b>. </li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-getnlsversionex
     * @since windows6.0.6000
     */
    static GetNLSVersionEx(function, lpLocaleName, lpVersionInformation) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetNLSVersionEx", "uint", function, "ptr", lpLocaleName, "ptr", lpVersionInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if the NLS version is valid for a given NLS function.
     * @param {Integer} function The NLS capability to query. This value must be COMPARE_STRING. See the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ne-winnls-sysnls_function">SYSNLS_FUNCTION</a> enumeration.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFOEX>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure. The application must initialize the <b>dwNLSVersionInfoSize</b> member to <c> sizeof(NLSVERSIONINFOEX)</c>.
     * @returns {Integer} Returns a nonzero value if the NLS version is valid, or zero if the version is invalid.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidnlsversion
     * @since windows8.0
     */
    static IsValidNLSVersion(function, lpLocaleName, lpVersionInformation) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        result := DllCall("KERNEL32.dll\IsValidNLSVersion", "uint", function, "ptr", lpLocaleName, "ptr", lpVersionInformation, "uint")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) or its equivalent in another Unicode string for a locale specified by name.CautionBecause strings with very different binary representations can compare as identical, this function can raise certain security concerns. For more information, see the discussion of comparison functions in Security Considerations:\_International Features.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFindNLSStringFlags Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags with any of the filtering flags defined in the next table. If the application does not specify a flag, the function uses the default comparison for the specified locale. As discussed in <a href="https://docs.microsoft.com/windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>, there is no binary comparison mode.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMSTART"></a><a id="find_fromstart"></a><dl>
     * <dt><b>FIND_FROMSTART</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string, starting with the first character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMEND"></a><a id="find_fromend"></a><dl>
     * <dt><b>FIND_FROMEND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string in the reverse direction, starting with the last character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_STARTSWITH"></a><a id="find_startswith"></a><dl>
     * <dt><b>FIND_STARTSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the first value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_ENDSWITH"></a><a id="find_endswith"></a><dl>
     * <dt><b>FIND_ENDSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the last value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The application can use the filtering flags defined below in combination with a find flag.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNORECASE"></a><a id="linguistic_ignorecase"></a><dl>
     * <dt><b>LINGUISTIC_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case in the search, as linguistically appropriate. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNOREDIACRITIC"></a><a id="linguistic_ignorediacritic"></a><dl>
     * <dt><b>LINGUISTIC_IGNOREDIACRITIC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore diacritics, as linguistically appropriate. For more information, see the Remarks section.
     * 
     * <div class="alert"><b>Note</b>This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORECASE"></a><a id="norm_ignorecase"></a><dl>
     * <dt><b>NORM_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case in the search. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREKANATYPE"></a><a id="norm_ignorekanatype"></a><dl>
     * <dt><b>NORM_IGNOREKANATYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORENONSPACE"></a><a id="norm_ignorenonspace"></a><dl>
     * <dt><b>NORM_IGNORENONSPACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORESYMBOLS"></a><a id="norm_ignoresymbols"></a><dl>
     * <dt><b>NORM_IGNORESYMBOLS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore symbols and punctuation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREWIDTH"></a><a id="norm_ignorewidth"></a><dl>
     * <dt><b>NORM_IGNOREWIDTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_LINGUISTIC_CASING"></a><a id="norm_linguistic_casing"></a><dl>
     * <dt><b>NORM_LINGUISTIC_CASING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use linguistic rules for casing, instead of file system rules (default). For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {PWSTR} lpStringValue Pointer to the search string, for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application cannot specify 0 or any negative number other than -1 for this parameter. The application specifies -1 if the search string is null-terminated and the function should calculate the size automatically.
     * @param {Pointer<Int32>} pcchFound Pointer to a buffer containing the length of the string that the function finds. The string can be either longer or shorter than the search string. If the function fails to find the search string, this parameter is not modified.
     * 
     * The function can retrieve <b>NULL</b> in this parameter. In this case, the function makes no indication if the length of the found string differs from the length of the source string. 
     * 
     * Note that the value of <i>pcchFound</i> is often identical to the value provided in <i>cchValue</i>, but can differ in the following cases:
     * 
     * <ul>
     * <li>The value provided in <i>cchValue</i> is negative.</li>
     * <li>The strings are equivalent, but have different lengths. For example, "A" plus "Combining Ring" (U+0041 U+030A) is equivalent to the "A Ring" (U+00c5).</li>
     * </ul>
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Reserved; must be <b>NULL</b>.
     * @param {LPARAM} sortHandle Reserved; must be 0.
     * @returns {Integer} Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. In combination with the value in <i>pcchFound</i>, this index provides the exact location of the entire found string in the source string. A return value of 0 is an error-free index into the source string, and the matching string is in the source string at offset 0.
     * 
     * The function returns -1 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-findnlsstringex
     * @since windows6.0.6000
     */
    static FindNLSStringEx(lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, sortHandle) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpStringSource := lpStringSource is String ? StrPtr(lpStringSource) : lpStringSource
        lpStringValue := lpStringValue is String ? StrPtr(lpStringValue) : lpStringValue

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNLSStringEx", "ptr", lpLocaleName, "uint", dwFindNLSStringFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, "int*", pcchFound, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", sortHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * For a locale specified by name, maps an input character string to another using a specified transformation, or generates a sort key for the input string.NoteThe application should call this function in preference to LCMapString if designed to run only on WindowsVista and later.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwMapFlags Flag specifying the type of transformation to use during string mapping or the type of sort key to generate. This parameter can have the following values.
     * 
     * | Flag | Meaning |
     * | --- | --- |
     * | **LCMAP_BYTEREV**| Use byte reversal. For example, if the application passes in 0x3450 0x4822, the result is 0x5034 0x2248. |
     * | **LCMAP_FULLWIDTH** | Use Unicode (wide) characters where applicable. This flag and LCMAP_HALFWIDTH are mutually exclusive. With this flag, the mapping may use Normalization Form C even if an input character is already full-width. For example, the string "" (which is already full-width) is normalized to "". See [Unicode normalization forms](http://www.unicode.org/reports/tr15/). |
     * |**LCMAP_HALFWIDTH** | Use narrow characters where applicable. This flag and LCMAP_FULLWIDTH are mutually exclusive. |
     * | **LCMAP_HIRAGANA** | Map all katakana characters to hiragana. This flag and LCMAP_KATAKANA are mutually exclusive. |
     * | **LCMAP_KATAKANA** | Map all hiragana characters to katakana. This flag and LCMAP_HIRAGANA are mutually exclusive. |
     * | **LCMAP_LINGUISTIC_CASING** | Use linguistic rules for casing, instead of file system rules (default). This flag is valid with LCMAP_LOWERCASE or LCMAP_UPPERCASE only. |
     * | **LCMAP_LOWERCASE** | For locales and scripts capable of handling uppercase and lowercase, map all characters to lowercase.
     * | **LCMAP_HASH** | Return a hash of the raw sort weights of a string.<br> <br>Strings that appear equivalent typically return the same hash (for example, "hello" and "HELLO" with LCMAP_IGNORECASE). However, some complex cases, such as East Asian languages, can have similar strings with identical weights that compare as equal but do not return the same hash.<br> <br>LCMAP_HASH requires that the output buffer be of size sizeof(int) |
     * | **LCMAP_SIMPLIFIED_CHINESE** | Map traditional Chinese characters to simplified Chinese characters. This flag and LCMAP_TRADITIONAL_CHINESE are mutually exclusive. |
     * | **LCMAP_SORTHANDLE** <br> **The use of a sort handle results in minimal performance improvements and is discouraged.** | Return a token representing the resolved sort parameters for the locale (like locale name), so future calls can pass <c>NULL</c> for the sort name and pass the previously queried sort handle as the last parameter (sortHandle) in subsequent calls to [CompareStringEx](../stringapiset/nf-stringapiset-comparestringex.md) or [LCMapStringEx](nf-winnls-lcmapstringex.md).<br> <br>LCMAP_SORTHANDLE requires that the output buffer be of size sizeof(lparam) |
     * | **LCMAP_SORTKEY** | Produce a normalized sort key. If the LCMAP_SORTKEY flag is not specified, the function performs string mapping. For details of sort key generation and string mapping, see the Remarks section. |
     * | **LCMAP_TITLECASE** | Windows7:</b> Map all characters to title case, in which the first letter of each major word is capitalized. |
     * | **LCMAP_TRADITIONAL_CHINESE** | Map simplified Chinese characters to traditional Chinese characters. This flag and LCMAP_SIMPLIFIED_CHINESE are mutually exclusive. |
     * | **LCMAP_UPPERCASE** | For locales and scripts capable of handling uppercase and lowercase, map all characters to uppercase. |
     * 
     * The following flags can be used alone, with one another, or with the LCMAP_SORTKEY and/or LCMAP_BYTEREV flags. However, they cannot be combined with the other flags listed above.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORENONSPACE"></a><a id="norm_ignorenonspace"></a><dl>
     * <dt><b>NORM_IGNORENONSPACE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters. For many scripts (notably Latin scripts), NORM_IGNORENONSPACE coincides with LINGUISTIC_IGNOREDIACRITIC.
     * 
     * <div class="alert"><b>Note</b>NORM_IGNORENONSPACE ignores any secondary distinction, whether it is a diacritic or not. Scripts for Korean, Japanese, Chinese, and Indic languages, among others, use this distinction for purposes other than diacritics. LINGUISTIC_IGNOREDIACRITIC causes the function to ignore only actual diacritics, instead of ignoring the second sorting weight.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORESYMBOLS"></a><a id="norm_ignoresymbols"></a><dl>
     * <dt><b>NORM_IGNORESYMBOLS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore symbols and punctuation.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The flags listed below are used only with the LCMAP_SORTKEY flag.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNORECASE"></a><a id="linguistic_ignorecase"></a><dl>
     * <dt><b>LINGUISTIC_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case, as linguistically appropriate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LINGUISTIC_IGNOREDIACRITIC"></a><a id="linguistic_ignorediacritic"></a><dl>
     * <dt><b>LINGUISTIC_IGNOREDIACRITIC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore nonspacing characters, as linguistically appropriate.
     * 
     * <div class="alert"><b>Note</b>This flag does not always produce predictable results when used with decomposed characters, that is, characters in which a base character and one or more nonspacing characters each have distinct code point values.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNORECASE"></a><a id="norm_ignorecase"></a><dl>
     * <dt><b>NORM_IGNORECASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore case. For many scripts (notably Latin scripts), NORM_IGNORECASE coincides with LINGUISTIC_IGNORECASE.
     * 
     * <div class="alert"><b>Note</b>NORM_IGNORECASE ignores any tertiary distinction, whether it is actually linguistic case or not. For example, in Arabic and Indic scripts, this flag distinguishes alternate forms of a character, but the differences do not correspond to linguistic case. LINGUISTIC_IGNORECASE causes the function to ignore only actual linguistic casing, instead of ignoring the third sorting weight.</div>
     * <div></div>
     * <div class="alert"><b>Note</b>For double-byte character set (DBCS) locales, NORM_IGNORECASE has an effect on all Unicode characters as well as narrow (one-byte) characters, including Greek and Cyrillic characters.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREKANATYPE"></a><a id="norm_ignorekanatype"></a><dl>
     * <dt><b>NORM_IGNOREKANATYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not differentiate between hiragana and katakana characters. Corresponding hiragana and katakana characters compare as equal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_IGNOREWIDTH"></a><a id="norm_ignorewidth"></a><dl>
     * <dt><b>NORM_IGNOREWIDTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore the difference between half-width and full-width characters, for example, C a t == cat. The full-width form is a formatting distinction used in Chinese and Japanese scripts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NORM_LINGUISTIC_CASING"></a><a id="norm_linguistic_casing"></a><dl>
     * <dt><b>NORM_LINGUISTIC_CASING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use linguistic rules for casing, instead of file system rules (default).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SORT_DIGITSASNUMBERS"></a><a id="sort_digitsasnumbers"></a><dl>
     * <dt><b>SORT_DIGITSASNUMBERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Windows7:</b> Treat digits as numbers during sorting, for example, sort "2" before "10".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SORT_STRINGSORT"></a><a id="sort_stringsort"></a><dl>
     * <dt><b>SORT_STRINGSORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Treat punctuation the same as symbols.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpSrcStr Pointer to a source string that the function maps or uses for sort key generation. This string cannot have a size of 0.
     * @param {Integer} cchSrc Size, in characters, of the source string indicated by <i>lpSrcStr</i>. The size of the source string can include the terminating null character, but does not have to. If the terminating null character is included, the mapping behavior of the function is not greatly affected because the terminating null character is considered to be unsortable and always maps to itself.
     * 
     * The application can set this parameter to any negative value to specify that the source string is null-terminated. In this case, if <b>LCMapStringEx</b> is being used in its string-mapping mode, the function calculates the string length itself, and null-terminates the mapped string indicated by <i>lpDestStr</i>.
     * 
     * The application cannot set this parameter to 0.
     * @param {PWSTR} lpDestStr Pointer to a buffer in which this function retrieves the mapped string or a sort key.
     * 
     * If the application is using the function to generate a sort key (LCMAP_SORTKEY):
     * 
     * - The sort key is stored in the buffer and treated as an opaque array of bytes. The stored values can include embedded 0 bytes at any position.
     * - The destination string can contain an odd number of bytes. The LCMAP_BYTEREV flag only reverses an even number of bytes. The last byte (odd-positioned) in the sort key is not reversed.
     * 
     * If the caller explicitly requests a subset of the string, the destination string does not include a terminating null character unless the caller specified it in *cchDest*.
     * 
     * If this function fails, the destination buffer might contain either partial results or no results at all. In this case, all results should be considered invalid.
     * 
     * > [!NOTE]
     * > When setting LCMAP_UPPERCASE or LCMAP_LOWERCASE, the destination string can use the same buffer as the source string. However, this is strongly discouraged, as some conditions may cause the returned cased string to be a different length.
     * @param {Integer} cchDest Size, in characters, of the destination string indicated by <i>lpDestStr</i>. If the application is using the function for string mapping, it supplies a character count for this parameter. If space for a terminating null character is included in <i>cchSrc</i>, <i>cchDest</i> must also include space for a terminating null character.
     * 
     * If the application is using the function to generate a sort key, it supplies a byte count for the size. This byte count must include space for the sort key 0x00 terminator.
     * 
     * The application can set <i>cchDest</i> to 0. In this case, the function does not use the <i>lpDestStr</i> parameter and returns the required buffer size for the mapped string or sort key.
     * @param {Pointer<NLSVERSIONINFO>} lpVersionInformation Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winnls/ns-winnls-nlsversioninfoex">NLSVERSIONINFOEX</a> structure that contains the version information about the relevant NLS capability; usually retrieved from <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-getnlsversionex">GetNLSVersionEx</a>.
     * 
     * **WindowsVista, Windows7:** Reserved; must set to NULL.
     * @param {LPARAM} sortHandle Reserved; must be 0.
     * 
     * > [!NOTE]
     * > [CompareStringEx](../stringapiset/nf-stringapiset-comparestringex.md) and [LCMapStringEx](nf-winnls-lcmapstringex.md) can specify a sort handle (if the locale name is null).  This use is discouraged for most apps.
     * @returns {Integer} If the function succeeds when used for string mapping, it returns the number of characters in the translated string (see *cchSrc* and *cchDest* for more details).
     * 
     * If the function succeeds when used for string mapping it returns the number of bytes in the sort key.
     * 
     * This function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-lcmapstringex
     * @since windows6.0.6000
     */
    static LCMapStringEx(lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, sortHandle) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpSrcStr := lpSrcStr is String ? StrPtr(lpSrcStr) : lpSrcStr
        lpDestStr := lpDestStr is String ? StrPtr(lpDestStr) : lpDestStr

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LCMapStringEx", "ptr", lpLocaleName, "uint", dwMapFlags, "ptr", lpSrcStr, "int", cchSrc, "ptr", lpDestStr, "int", cchDest, "ptr", lpVersionInformation, "ptr", lpReserved, "ptr", sortHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines if the specified locale name is valid for a locale that is installed or supported on the operating system.NoteAn application running only on WindowsVista and later should call this function in preference to IsValidLocale to determine the validity of a supplemental locale.
     * @param {PWSTR} lpLocaleName Pointer to the locale name to validate.
     * @returns {BOOL} Returns a nonzero value if the locale name is valid, or returns 0 for an invalid name.
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-isvalidlocalename
     * @since windows6.0.6000
     */
    static IsValidLocaleName(lpLocaleName) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        result := DllCall("KERNEL32.dll\IsValidLocaleName", "ptr", lpLocaleName, "int")
        return result
    }

    /**
     * Enumerates calendar information for a locale specified by name.NoteThe application should call this function in preference to EnumCalendarInfo or EnumCalendarInfoEx if designed to run only on WindowsVista and later.NoteThis function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @param {Pointer<CALINFO_ENUMPROCEXEX>} pCalInfoEnumProcExEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317808(v=vs.85)">EnumCalendarInfoProcExEx</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} Calendar <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-identifiers">Calendar identifier</a> that specifies the calendar for which information is requested. Note that this identifier can be ENUM_ALL_CALENDARS, to enumerate all calendars that are associated with the locale.
     * @param {Integer} CalType Type of calendar information. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/calendar-type-information">Calendar Type Information</a>. Only one calendar type can be specified per call to this function, except where noted.
     * @param {LPARAM} lParam Application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumcalendarinfoexex
     * @since windows6.0.6000
     */
    static EnumCalendarInfoExEx(pCalInfoEnumProcExEx, lpLocaleName, Calendar, CalType, lParam) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName
        lpReserved := lpReserved is String ? StrPtr(lpReserved) : lpReserved

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumCalendarInfoExEx", "ptr", pCalInfoEnumProcExEx, "ptr", lpLocaleName, "uint", Calendar, "ptr", lpReserved, "uint", CalType, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the long date, short date, or year/month formats that are available for a locale specified by name.NoteThe application should call this function in preference to EnumDateFormats or EnumDateFormatsEx if designed to run only on WindowsVista and later.NoteThis function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @param {Pointer<DATEFMT_ENUMPROCEXEX>} lpDateFmtEnumProcExEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317815(v=vs.85)">EnumDateFormatsProcExEx</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags 
     * @param {LPARAM} lParam An application-provided parameter to pass to the callback function. This value is especially useful for multi-threaded applications.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumdateformatsexex
     * @since windows6.0.6000
     */
    static EnumDateFormatsExEx(lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumDateFormatsExEx", "ptr", lpDateFmtEnumProcExEx, "ptr", lpLocaleName, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the time formats that are available for a locale specified by name.NoteThe application should call this function in preference to EnumTimeFormats if designed to run only on WindowsVista and later.NoteThis function can enumerate data that changes between releases, for example, due to a custom locale. If your application must persist or transmit data, see Using Persistent Locale Data.
     * @param {Pointer<TIMEFMT_ENUMPROCEX>} lpTimeFmtEnumProcEx Pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd317833(v=vs.85)">EnumTimeFormatsProcEx</a>.
     * @param {PWSTR} lpLocaleName Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-names">locale name</a>, or one of the following predefined values. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_INVARIANT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_SYSTEM_DEFAULT</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_USER_DEFAULT</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags The time format. Set to 0 to use the current user's long time format, or TIME_NOSECONDS (starting withWindows7) to use the short time format.
     * @param {LPARAM} lParam An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumtimeformatsex
     * @since windows6.0.6000
     */
    static EnumTimeFormatsEx(lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam) {
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumTimeFormatsEx", "ptr", lpTimeFmtEnumProcEx, "ptr", lpLocaleName, "uint", dwFlags, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the locales that are either installed on or supported by an operating system.NoteThe application should call this function in preference to EnumSystemLocales if designed to run only on WindowsVista and later.
     * @param {Pointer<LOCALE_ENUMPROCEX>} lpLocaleEnumProcEx Pointer to an application-defined callback function. The <b>EnumSystemLocalesEx</b> function enumerates locales by making repeated calls to this callback function. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nc-winnls-locale_enumprocex">EnumLocalesProcEx</a>.
     * @param {Integer} dwFlags Flags identifying the locales to enumerate. The flags can be used singly or combined using a binary OR. If the application specifies 0 for this parameter, the function behaves as for <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-all">LOCALE_ALL</a>.
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-all">LOCALE_ALL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-alternate-sorts">LOCALE_ALTERNATE_SORTS</a>; see Remarks</li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-neutraldata">LOCALE_NEUTRALDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-supplemental">LOCALE_SUPPLEMENTAL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-windows">LOCALE_WINDOWS</a>
     * </li>
     * </ul>
     * @param {LPARAM} lParam An application-provided parameter to be passed to the callback function. This is especially useful for multi-threaded applications.
     * @returns {BOOL} Returns a nonzero value if successful, or 0 otherwise. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_BADDB. The function could not access the data. This situation should not normally occur, and typically indicates a bad installation, a disk problem, or the like.</li>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-enumsystemlocalesex
     * @since windows6.0.6000
     */
    static EnumSystemLocalesEx(lpLocaleEnumProcEx, dwFlags, lParam) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\EnumSystemLocalesEx", "ptr", lpLocaleEnumProcEx, "uint", dwFlags, "ptr", lParam, "ptr", lpReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Finds a possible locale name match for the supplied name.
     * @param {PWSTR} lpNameToResolve Pointer to a name to resolve, for example, "en-XA" for English (Private Use).
     * @param {PWSTR} lpLocaleName Pointer to a buffer in which this function retrieves the locale name that is the match for the input name. For example, the match for the name "en-XA" is "en-US" for English (United States).
     * 
     * <div class="alert"><b>Note</b>If the function fails, the state of the output buffer is not guaranteed to be accurate. In this case, the application should check the return value and error status set by the function to determine the correct course of action.</div>
     * <div></div>
     * @param {Integer} cchLocaleName Size, in characters, of the buffer indicated by <i>lpLocaleName</i>. The maximum possible length of a locale name, including a terminating null character, is the value of <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-name-constants">LOCALE_NAME_MAX_LENGTH</a>. This is the recommended size to supply in this parameter.
     * @returns {Integer} Returns the size of the buffer containing the locale name, including the terminating null character, if successful.
     * 
     * The function returns 0 if it does not succeed. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * <ul>
     * <li>ERROR_INSUFFICIENT_BUFFER. A supplied buffer size was not large enough, or it was incorrectly set to <b>NULL</b>.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//winnls/nf-winnls-resolvelocalename
     * @since windows6.1
     */
    static ResolveLocaleName(lpNameToResolve, lpLocaleName, cchLocaleName) {
        lpNameToResolve := lpNameToResolve is String ? StrPtr(lpNameToResolve) : lpNameToResolve
        lpLocaleName := lpLocaleName is String ? StrPtr(lpLocaleName) : lpLocaleName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ResolveLocaleName", "ptr", lpNameToResolve, "ptr", lpLocaleName, "int", cchLocaleName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a list of available ELS platform-supported services, along with associated information, according to application-specified criteria.
     * @param {Pointer<MAPPING_ENUM_OPTIONS>} pOptions Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_enum_options">MAPPING_ENUM_OPTIONS</a> structure containing criteria to use during enumeration of services. The application specifies <b>NULL</b> for this parameter to retrieve all installed services.
     * @param {Pointer<MAPPING_SERVICE_INFO>} prgServices Address of a pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structures containing service information matching the criteria supplied in the <i>pOptions</i> parameter.
     * @param {Pointer<UInt32>} pdwServicesCount Pointer to a DWORD variable in which this function retrieves the number of retrieved services.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.<div class="alert"><b>Note</b>The application must test for any failure before proceeding with further operations.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//elscore/nf-elscore-mappinggetservices
     * @since windows6.1
     */
    static MappingGetServices(pOptions, prgServices, pdwServicesCount) {
        result := DllCall("elscore.dll\MappingGetServices", "ptr", pOptions, "ptr", prgServices, "uint*", pdwServicesCount, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Frees memory and resources allocated for the application to interact with one or more ELS services. The memory and resources are allocated in an application call to MappingGetServices.
     * @param {Pointer<MAPPING_SERVICE_INFO>} pServiceInfo Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structures containing service descriptions retrieved by a prior call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappinggetservices">MappingGetServices</a>. This parameter cannot be set to <b>NULL</b>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//elscore/nf-elscore-mappingfreeservices
     * @since windows6.1
     */
    static MappingFreeServices(pServiceInfo) {
        result := DllCall("elscore.dll\MappingFreeServices", "ptr", pServiceInfo, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Calls upon an ELS service to recognize text. For example, the Microsoft Language Detection service will attempt to recognize the language in which the input text is written.
     * @param {Pointer<MAPPING_SERVICE_INFO>} pServiceInfo Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_service_info">MAPPING_SERVICE_INFO</a> structure containing information about the service to use in text recognition. The structure must be one of the structures retrieved by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappinggetservices">MappingGetServices</a>. This parameter cannot be set to <b>NULL</b>.
     * @param {PWSTR} pszText Pointer to the text to recognize. The text must be UTF-16, but some services have additional requirements for the input format. This parameter cannot be set to <b>NULL</b>.
     * @param {Integer} dwLength Length, in characters, of the text specified in <i>pszText</i>.
     * @param {Integer} dwIndex Index inside the specified text to be used by the service. This value should be between 0 and <i>dwLength</i>-1. If the application wants to process the entire text, it should set this parameter to 0.
     * @param {Pointer<MAPPING_OPTIONS>} pOptions Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_options">MAPPING_OPTIONS</a> structure containing options that affect the result and behavior of text recognition. The application does not have to specify values for all structure members. This parameter can be set to <b>NULL</b> to use the default mapping options.
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pbag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure in which the service stores its results. On input, the application passes a structure with only the size provided, and the other members set to 0. On output, the structure is filled with information produced by the service during text recognition. This parameter cannot be set to <b>NULL</b>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//elscore/nf-elscore-mappingrecognizetext
     * @since windows6.1
     */
    static MappingRecognizeText(pServiceInfo, pszText, dwLength, dwIndex, pOptions, pbag) {
        pszText := pszText is String ? StrPtr(pszText) : pszText

        result := DllCall("elscore.dll\MappingRecognizeText", "ptr", pServiceInfo, "ptr", pszText, "uint", dwLength, "uint", dwIndex, "ptr", pOptions, "ptr", pbag, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Causes an ELS service to perform an action after text recognition has occurred. For example, a phone dialer service first must recognize phone numbers and then can perform the &quot;action&quot; of dialing a number.
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pBag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure containing the results of a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/elscore/nf-elscore-mappingrecognizetext">MappingRecognizeText</a>. This parameter cannot be set to <b>NULL</b>.
     * @param {Integer} dwRangeIndex A starting index inside the text recognition results for a recognized text range. This value should be between 0 and the range count.
     * @param {PWSTR} pszActionId Pointer to the identifier of the action to perform. This parameter cannot be set to <b>NULL</b>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//elscore/nf-elscore-mappingdoaction
     * @since windows6.1
     */
    static MappingDoAction(pBag, dwRangeIndex, pszActionId) {
        pszActionId := pszActionId is String ? StrPtr(pszActionId) : pszActionId

        result := DllCall("elscore.dll\MappingDoAction", "ptr", pBag, "uint", dwRangeIndex, "ptr", pszActionId, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Frees memory and resources allocated during an ELS text recognition operation.
     * @param {Pointer<MAPPING_PROPERTY_BAG>} pBag Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/elscore/ns-elscore-mapping_property_bag">MAPPING_PROPERTY_BAG</a> structure containing the properties for which to free resources. This parameter cannot be set to <b>NULL</b>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns an error HRESULT value if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//elscore/nf-elscore-mappingfreepropertybag
     * @since windows6.1
     */
    static MappingFreePropertyBag(pBag) {
        result := DllCall("elscore.dll\MappingFreePropertyBag", "ptr", pBag, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Frees a script cache.
     * @param {Pointer<Void>} psc Pointer to the <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application cant test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptfreecache
     * @since windows5.0
     */
    static ScriptFreeCache(psc) {
        result := DllCall("USP10.dll\ScriptFreeCache", "ptr", psc, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Breaks a Unicode string into individually shapeable items.
     * @param {PWSTR} pwcInChars Pointer to a Unicode string to itemize.
     * @param {Integer} cInChars Number of characters in <i>pwcInChars</i> to itemize.
     * @param {Integer} cMaxItems Maximum number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures defining items to process.
     * @param {Pointer<SCRIPT_CONTROL>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure indicating the type of itemization to perform.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if no <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> properties are needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_STATE>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure indicating the initial bidirectional algorithm state.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if the script state is not needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ITEM>} pItems Pointer to a buffer in which the function retrieves <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures representing the items that have been processed. The buffer should be  <c>(cMaxItems + 1) * sizeof(SCRIPT_ITEM)</c> bytes in length. It is invalid to call this function with a buffer to hold less than two <b>SCRIPT_ITEM</b> structures. The function always adds a terminal item to the item analysis array so that the length of the item with zero-based index "i" is always available as:
     * 
     * <c>pItems[i+1].iCharPos - pItems[i].iCharPos;</c>
     * @param {Pointer<Int32>} pcItems Pointer to the number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures processed.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * The function returns E_INVALIDARG if <i>pwcInChars</i> is set to <b>NULL</b>, <i>cInChars</i> is 0, <i>pItems</i> is set to <b>NULL</b>, or <i>cMaxItems</i> &lt; 2.
     * 
     * The function returns E_OUTOFMEMORY if the value of <i>cMaxItems</i> is insufficient. As in all error cases, no items are fully processed and no part of the output array contains defined values. If the function returns E_OUTOFMEMORY, the application can call it again with a larger <i>pItems</i> buffer.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptitemize
     * @since windows5.0
     */
    static ScriptItemize(pwcInChars, cInChars, cMaxItems, psControl, psState, pItems, pcItems) {
        pwcInChars := pwcInChars is String ? StrPtr(pwcInChars) : pwcInChars

        result := DllCall("USP10.dll\ScriptItemize", "ptr", pwcInChars, "int", cInChars, "int", cMaxItems, "ptr", psControl, "ptr", psState, "ptr", pItems, "int*", pcItems, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts an array of run embedding levels to a map of visual-to-logical position and/or logical-to-visual position.
     * @param {Integer} cRuns Number of runs to process.
     * @param {Pointer<Byte>} pbLevel Pointer to an array, of length indicated by <i>cRuns</i>, containing run embedding levels. Embedding levels for all runs on the line must be included, ordered logically. For more information, see the Remarks section.
     * @param {Pointer<Int32>} piVisualToLogical Pointer to an array, of length indicated by <i>cRuns</i>, in which this function retrieves the run embedding levels reordered to visual order. The first array element represents the run to display at the far left, and subsequent entries should be displayed progressing from left to right. The function sets this parameter to <b>NULL</b> if there is no output.
     * @param {Pointer<Int32>} piLogicalToVisual Pointer to an array, of length indicated by <i>cRuns</i>, in which this function retrieves the visual run positions. The first array element is the relative visual position where the first logical run should be displayed, the leftmost display position being 0. The function sets this parameter to <b>NULL</b> if there is no output.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptlayout
     * @since windows5.0
     */
    static ScriptLayout(cRuns, pbLevel, piVisualToLogical, piLogicalToVisual) {
        result := DllCall("USP10.dll\ScriptLayout", "int", cRuns, "char*", pbLevel, "int*", piVisualToLogical, "int*", piLogicalToVisual, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run.
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {PWSTR} pwcChars Pointer to an array of Unicode characters defining the run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Integer} cMaxGlyphs Maximum number of glyphs to generate, and the length of <i>pwOutGlyphs</i>. A reasonable value is <c>(1.5 * cChars + 16)</c>, but this value might be insufficient in some circumstances. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure for the run, containing the results from an earlier call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<UInt16>} pwOutGlyphs Pointer to a buffer in which this function retrieves an array of glyphs with size as indicated by <i>cMaxGlyphs</i>.
     * @param {Pointer<UInt16>} pwLogClust Pointer to a buffer in which this function retrieves an array of logical cluster information. Each array element corresponds to a character in the array of Unicode characters; therefore this array has the number of elements indicated by cChars. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member is set to <b>TRUE</b> in the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure, the elements decrease as the array is read.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures containing visual attribute information. Since each glyph has only one visual attribute, this array has the number of elements indicated by <i>cMaxGlyphs</i>.
     * @param {Pointer<Int32>} pcGlyphs Pointer to the location in which this function retrieves the number of glyphs indicated in <i>pwOutGlyphs</i>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, the content of all output parameters is undefined.
     * 
     * Error returns include:
     * 
     * <ul>
     * <li>E_OUTOFMEMORY. The output buffer length indicated by <i>cMaxGlyphs</i> is insufficient.</li>
     * <li>E_PENDING. The script cache specified by the <i>psc</i> parameter does not contain enough information to shape the string, and the device context has been passed as <b>NULL</b> so that the function is unable to complete the shaping process. The application should set up a correct device context for the run, and call this function again with the appropriate value in <i>hdc</i> and with all other parameters the same.</li>
     * <li>USP_E_SCRIPT_NOT_IN_FONT. The font corresponding to the device context does not support the script required by the run indicated by <i>pwcChars</i>. The application should choose another font, using either <a href="/windows/desktop/api/usp10/nf-usp10-scriptgetcmap">ScriptGetCMap</a> or another function to select the font.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptshape
     * @since windows5.0
     */
    static ScriptShape(hdc, psc, pwcChars, cChars, cMaxGlyphs, psa, pwOutGlyphs, pwLogClust, psva, pcGlyphs) {
        pwcChars := pwcChars is String ? StrPtr(pwcChars) : pwcChars
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptShape", "ptr", hdc, "ptr", psc, "ptr", pwcChars, "int", cChars, "int", cMaxGlyphs, "ptr", psa, "ushort*", pwOutGlyphs, "ushort*", pwLogClust, "ptr", psva, "int*", pcGlyphs, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Generates glyph advance width and two-dimensional offset information from the output of ScriptShape.
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<UInt16>} pwGlyphs Pointer to a glyph buffer obtained from an earlier call to the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> function.
     * @param {Integer} cGlyphs Count of glyphs in the glyph buffer.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures indicating visual attributes.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. On input, this structure is obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>. On output, this structure contains values retrieved by <b>ScriptPlace</b>.
     * @param {Pointer<Int32>} piAdvance Pointer to an array in which this function retrieves advance width information.
     * @param {Pointer<GOFFSET>} pGoffset Optional. Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structures in which this function retrieves the x and y offsets of combining glyphs. This array must be of length indicated by <i>cGlyphs</i>.
     * @param {Pointer<ABC>} pABC Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-abc">ABC</a> structure in which this function retrieves the <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> for the entire <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">run</a>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * The function returns E_PENDING if the script cache specified by the <i>psc</i> parameter does not contain enough information to place the glyphs, and the <i>hdc</i> parameter is set to <b>NULL</b> so that the function cannot complete the placement process. The application should set up a correct device context for the run, and call this function again with the appropriate device context and with all other parameters the same.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptplace
     * @since windows5.0
     */
    static ScriptPlace(hdc, psc, pwGlyphs, cGlyphs, psva, psa, piAdvance, pGoffset, pABC) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptPlace", "ptr", hdc, "ptr", psc, "ushort*", pwGlyphs, "int", cGlyphs, "ptr", psva, "ptr", psa, "int*", piAdvance, "ptr", pGoffset, "ptr", pABC, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Displays text for the specified script shape and place information.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>. Note that, unlike some other related Uniscribe functions, this function defines the handle as mandatory.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Integer} x Value of the x coordinate of the first glyph.
     * @param {Integer} y Value of the y coordinate of the first glyph.
     * @param {Integer} fuOptions Options equivalent to the <i>fuOptions</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOut</a>. This parameter can be set to either ETO_CLIPPED or ETO_OPAQUE, to both values, or to neither value.
     * @param {Pointer<RECT>} lprc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the rectangle used to clip the display. The application can set this parameter to <b>NULL</b>.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<UInt16>} pwGlyphs Pointer to an array of glyphs obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>.
     * @param {Integer} cGlyphs Count of the glyphs in the array indicated by <i>pwGlyphs</i>. The maximum number of glyphs is 65,536.
     * @param {Pointer<Int32>} piAdvance Pointer to an array of advance widths obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<Int32>} piJustify Pointer to an array of justified advance widths (cell widths). The application can set this parameter to <b>NULL</b>.
     * @param {Pointer<GOFFSET>} pGoffset Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structure containing the x and y offsets for the combining glyph.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scripttextout
     * @since windows5.0
     */
    static ScriptTextOut(hdc, psc, x, y, fuOptions, lprc, psa, pwGlyphs, cGlyphs, piAdvance, piJustify, pGoffset) {
        static pwcReserved := 0, iReserved := 0 ;Reserved parameters must always be NULL

        pwcReserved := pwcReserved is String ? StrPtr(pwcReserved) : pwcReserved
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptTextOut", "ptr", hdc, "ptr", psc, "int", x, "int", y, "uint", fuOptions, "ptr", lprc, "ptr", psa, "ptr", pwcReserved, "int", iReserved, "ushort*", pwGlyphs, "int", cGlyphs, "int*", piAdvance, "int*", piJustify, "ptr", pGoffset, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates an advance widths table to allow text justification when passed to the ScriptTextOut function.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to an array, of length indicated by <i>cGlyphs</i>, containing <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures. Each structure contains visual attributes for a glyph in the line to process.
     * @param {Pointer<Int32>} piAdvance Pointer to an advance widths array, of length indicated by <i>cGlyphs</i>, obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Integer} cGlyphs Count of glyphs for the arrays indicated by <i>psva</i> and <i>piAdvance</i>. This parameter also indicates the count of glyphs for the output parameter <i>piJustify</i>.
     * @param {Integer} iDx Width, in pixels, of the desired change, either an increase of decrease.
     * @param {Integer} iMinKashida Minimum width of a kashida glyph to generate.
     * @param {Pointer<Int32>} piJustify Pointer to a buffer in which this function retrieves an array, of length indicated by <i>cGlyphs</i>, containing justified advance widths. The justified widths are sometimes called "cell widths" to distinguish them from unjustified advance widths.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptjustify
     * @since windows5.0
     */
    static ScriptJustify(psva, piAdvance, cGlyphs, iDx, iMinKashida, piJustify) {
        result := DllCall("USP10.dll\ScriptJustify", "ptr", psva, "int*", piAdvance, "int", cGlyphs, "int", iDx, "int", iMinKashida, "int*", piJustify, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves information for determining line breaks.
     * @param {PWSTR} pwcChars Pointer to the Unicode characters to process.
     * @param {Integer} cChars Number of Unicode characters to process.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from an earlier call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a>.
     * @param {Pointer<SCRIPT_LOGATTR>} psla Pointer to a buffer in which this function retrieves the character attributes as a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structure.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptbreak
     * @since windows5.0
     */
    static ScriptBreak(pwcChars, cChars, psa, psla) {
        pwcChars := pwcChars is String ? StrPtr(pwcChars) : pwcChars

        result := DllCall("USP10.dll\ScriptBreak", "ptr", pwcChars, "int", cChars, "ptr", psa, "ptr", psla, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Generates the x offset from the left end or leading edge of a run to either the leading or trailing edge of a logical character cluster.
     * @param {Integer} iCP Logical character position in the run. This parameter corresponds to the offset of any logical character in the cluster.
     * @param {BOOL} fTrailing <b>TRUE</b> to use the trailing edge of the logical character cluster to compute the offset. This parameter is set to <b>FALSE</b> to use the leading edge of the logical character cluster.
     * @param {Integer} cChars Number of characters in the run.
     * @param {Integer} cGlyphs Number of glyphs in the run.
     * @param {Pointer<UInt16>} pwLogClust Pointer to the logical clusters.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> array of visual attributes.
     * @param {Pointer<Int32>} piAdvance Pointer to an advance widths value.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. The <b>fLogicalOrder</b> member specifies the end of the run from which to measure the offset. If the flag is set, the leading edge of the run is used. If the flag is not set, the left end of the run is used.
     * @param {Pointer<Int32>} piX Pointer to the buffer in which the function retrieves the x position of the caret.
     * @returns {HRESULT} Returns 0 if successful. This function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptcptox
     * @since windows5.0
     */
    static ScriptCPtoX(iCP, fTrailing, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, piX) {
        result := DllCall("USP10.dll\ScriptCPtoX", "int", iCP, "int", fTrailing, "int", cChars, "int", cGlyphs, "ushort*", pwLogClust, "ptr", psva, "int*", piAdvance, "ptr", psa, "int*", piX, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Generates the leading or trailing edge of a logical character cluster from the x offset of a run.
     * @param {Integer} iX Offset, in logical units, from the end of the run specified by the <b>fLogicalOrder</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure indicated by the <i>psa</i> parameter.
     * @param {Integer} cChars Count of logical code points in the run.
     * @param {Integer} cGlyphs Count of glyphs in the run.
     * @param {Pointer<UInt16>} pwLogClust Pointer to an array of logical clusters.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to an array of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structures containing the visual attributes for the glyph.
     * @param {Pointer<Int32>} piAdvance Pointer to an array of advance widths.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure. The <b>fLogicalOrder</b> member indicates <b>TRUE</b> to use the leading edge of the run, or <b>FALSE</b> to use the trailing edge.
     * @param {Pointer<Int32>} piCP Pointer to a buffer in which this function retrieves the character position corrresponding to the x coordinate.
     * @param {Pointer<Int32>} piTrailing Pointer to a buffer in which this function retrieves the distance, in code points, from the leading edge of the logical character to the <i>iX</i> position. If this value is 0, the <i>iX</i> position is at the leading edge of the logical character. For more information, see the Remarks section.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptxtocp
     * @since windows5.0
     */
    static ScriptXtoCP(iX, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, piCP, piTrailing) {
        result := DllCall("USP10.dll\ScriptXtoCP", "int", iX, "int", cChars, "int", cGlyphs, "ushort*", pwLogClust, "ptr", psva, "int*", piAdvance, "ptr", psa, "int*", piCP, "int*", piTrailing, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts the glyph advance widths for a specific font into logical widths.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure.
     * @param {Integer} cChars Count of the logical code points in the run.
     * @param {Integer} cGlyphs Count of the glyphs in the run.
     * @param {Pointer<Int32>} piGlyphWidth Pointer to an array of glyph advance widths.
     * @param {Pointer<UInt16>} pwLogClust Pointer to an array of logical clusters.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structure defining visual attributes.
     * @param {Pointer<Int32>} piDx Pointer to an array of logical widths.
     * @returns {HRESULT} Currently returns S_OK in all cases.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetlogicalwidths
     * @since windows5.0
     */
    static ScriptGetLogicalWidths(psa, cChars, cGlyphs, piGlyphWidth, pwLogClust, psva, piDx) {
        result := DllCall("USP10.dll\ScriptGetLogicalWidths", "ptr", psa, "int", cChars, "int", cGlyphs, "int*", piGlyphWidth, "ushort*", pwLogClust, "ptr", psva, "int*", piDx, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Takes an array of advance widths for a run and generates an array of adjusted advance glyph widths.
     * @param {Pointer<Int32>} piDx Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">advance widths</a> in logical order, one per code point.
     * @param {Integer} cChars Count of the logical code points in the run.
     * @param {Integer} cGlyphs Glyph count.
     * @param {Pointer<UInt16>} pwLogClust Pointer to an array of logical clusters from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a>.
     * @param {Pointer<SCRIPT_VISATTR>} psva Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_visattr">SCRIPT_VISATTR</a> structure from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> and updated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<Int32>} piAdvance Pointer to an array of glyph advance widths from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure from <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemize">ScriptItemize</a> and updated by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshape">ScriptShape</a> and <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<ABC>} pABC Pointer to the overall <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> of a run. On input, the parameter should contain the run ABC widths retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>. On output, the parameter indicates the ABC width updated to match the new widths.
     * @param {Pointer<Int32>} piJustify Pointer to an array in which the function retrieves the glyph advance widths. This array is suitable for passing to the <i>piJustify</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scripttextout">ScriptTextOut</a>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptapplylogicalwidth
     * @since windows5.0
     */
    static ScriptApplyLogicalWidth(piDx, cChars, cGlyphs, pwLogClust, psva, piAdvance, psa, pABC, piJustify) {
        result := DllCall("USP10.dll\ScriptApplyLogicalWidth", "int*", piDx, "int", cChars, "int", cGlyphs, "ushort*", pwLogClust, "ptr", psva, "int*", piAdvance, "ptr", psa, "ptr", pABC, "int*", piJustify, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the glyph indexes of the Unicode characters in a string according to either the TrueType cmap table or the standard cmap table implemented for old-style fonts.
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {PWSTR} pwcInChars Pointer to a string of Unicode characters.
     * @param {Integer} cChars Number of Unicode characters in the string indicated by <i>pwcInChars</i>.
     * @param {Integer} dwFlags Flags specifying any special handling of the glyphs. By default, the glyphs are provided in logical order with no special handling. This parameter can have the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SGCM_RTL"></a><a id="sgcm_rtl"></a><dl>
     * <dt><b>SGCM_RTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The glyph array indicated by <i>pwOutGlyphs</i> should contain mirrored glyphs for those glyphs that have a mirrored equivalent.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt16>} pwOutGlyphs Pointer to a buffer in which the function retrieves an array of glyph indexes. This buffer should be of the same length as the input buffer indicated by <i>pwcInChars</i>. Each code point maps to a single glyph.
     * @returns {HRESULT} Returns S_OK if all Unicode code points are present in the font. The function returns one of the nonzero HRESULT values listed below if it does not succeed.
     *             
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>E_HANDLE</td>
     * <td>The font or the operating system does not support glyph indexes.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td>Some of the Unicode code points were mapped to the default glyph.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetcmap
     * @since windows5.0
     */
    static ScriptGetCMap(hdc, psc, pwcInChars, cChars, dwFlags, pwOutGlyphs) {
        pwcInChars := pwcInChars is String ? StrPtr(pwcInChars) : pwcInChars
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptGetCMap", "ptr", hdc, "ptr", psc, "ptr", pwcInChars, "int", cChars, "uint", dwFlags, "ushort*", pwOutGlyphs, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the ABC width of a given glyph.
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Integer} wGlyph Glyph to analyze.
     * @param {Pointer<ABC>} pABC Pointer to the ABC width of the specified glyph.
     * @returns {HRESULT} Returns S_OK if the ABC width of the glyph is retrieved. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * The function returns E_HANDLE if the font or operating system does not support glyph indexes.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetglyphabcwidth
     * @since windows5.0
     */
    static ScriptGetGlyphABCWidth(hdc, psc, wGlyph, pABC) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptGetGlyphABCWidth", "ptr", hdc, "ptr", psc, "ushort", wGlyph, "ptr", pABC, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves information about the current scripts.
     * @param {Pointer<SCRIPT_PROPERTIES>} ppSp Pointer to an array of pointers to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_properties">SCRIPT_PROPERTIES</a> structures indexed by script.
     * @param {Pointer<Int32>} piNumScripts Pointer to the number of scripts. The valid range for this value is 0 through <i>piNumScripts</i>-1.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetproperties
     * @since windows5.0
     */
    static ScriptGetProperties(ppSp, piNumScripts) {
        result := DllCall("USP10.dll\ScriptGetProperties", "ptr", ppSp, "int*", piNumScripts, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves information from the font cache on the special glyphs used by a font.
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_FONTPROPERTIES>} sfp Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-script_fontproperties">SCRIPT_FONTPROPERTIES</a> structure in which this function retrieves the information from the font cache.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetfontproperties
     * @since windows5.0
     */
    static ScriptGetFontProperties(hdc, psc, sfp) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptGetFontProperties", "ptr", hdc, "ptr", psc, "ptr", sfp, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the height of the currently cached font.
     * @param {HDC} hdc Optional. Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<Int32>} tmHeight Pointer to a buffer in which the function retrieves the font height.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptcachegetheight
     * @since windows5.0
     */
    static ScriptCacheGetHeight(hdc, psc, tmHeight) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptCacheGetHeight", "ptr", hdc, "ptr", psc, "int*", tmHeight, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Analyzes a plain text string.
     * @param {HDC} hdc Handle to the device context. If <i>dwFlags</i> is set to SSA_GLYPHS, the device context handle is required. If <i>dwFlags</i> is set to SSA_BREAK, the device context handle is optional. If the device context handle is provided, the function inspects the current font in the device context. If the current font is a symbolic font, the function treats the character string as a single neutral SCRIPT_UNDEFINED item.
     * @param {Pointer<Void>} pString Pointer to the string to analyze. The string must have at least one character. It can be a Unicode string or use the character set from a Windows ANSI <a href="https://docs.microsoft.com/windows/desktop/Intl/code-pages">code page</a>, as specified by the <i>iCharset</i> parameter.
     * @param {Integer} cString Length of the string to analyze. The length is measured in characters for an ANSI string or in wide characters for a Unicode string. The length must be at least 1.
     * @param {Integer} cGlyphs Size of the glyph buffer, in WORD values. This size is required. The recommended size is <c>(1.5 * cString + 16)</c>.
     * @param {Integer} iCharset Character set descriptor. If the input string is an ANSI string, this descriptor is set to the character set identifier. If the string is a Unicode string, this descriptor is set to -1.
     * 
     * The following character set identifiers are defined:
     * @param {Integer} dwFlags Flags indicating the analysis that is required. This parameter can have one of the values listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_BREAK"></a><a id="ssa_break"></a><dl>
     * <dt><b>SSA_BREAK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve break flags, that is, character and word stops.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_CLIP"></a><a id="ssa_clip"></a><dl>
     * <dt><b>SSA_CLIP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Clip the string at <i>iReqWidth.</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_DZWG"></a><a id="ssa_dzwg"></a><dl>
     * <dt><b>SSA_DZWG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Provide representation glyphs for control characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_FALLBACK"></a><a id="ssa_fallback"></a><dl>
     * <dt><b>SSA_FALLBACK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use fallback fonts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_FIT"></a><a id="ssa_fit"></a><dl>
     * <dt><b>SSA_FIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Justify the string to <i>iReqWidth</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_GCP"></a><a id="ssa_gcp"></a><dl>
     * <dt><b>SSA_GCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve missing glyphs and <i>pwLogClust</i> with <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a> conventions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_GLYPHS"></a><a id="ssa_glyphs"></a><dl>
     * <dt><b>SSA_GLYPHS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Generate glyphs, positions, and attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HIDEHOTKEY"></a><a id="ssa_hidehotkey"></a><dl>
     * <dt><b>SSA_HIDEHOTKEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Remove the first "&amp;" from displayed string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HOTKEY"></a><a id="ssa_hotkey"></a><dl>
     * <dt><b>SSA_HOTKEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Replace "&amp;" with underline on subsequent code point.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_HOTKEYONLY"></a><a id="ssa_hotkeyonly"></a><dl>
     * <dt><b>SSA_HOTKEYONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Display underline only. The resulting bit pattern might be displayed, using an XOR mask, to toggle the visibility of the hotkey underline without disturbing the text.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_LINK"></a><a id="ssa_link"></a><dl>
     * <dt><b>SSA_LINK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Apply East Asian font linking and association to noncomplex text.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_METAFILE"></a><a id="ssa_metafile"></a><dl>
     * <dt><b>SSA_METAFILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write items with <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-exttextouta">ExtTextOutW</a> calls, not with glyphs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_PASSWORD"></a><a id="ssa_password"></a><dl>
     * <dt><b>SSA_PASSWORD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Duplicate input string containing a single character <i>cString</i> times.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_RTL"></a><a id="ssa_rtl"></a><dl>
     * <dt><b>SSA_RTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use base embedding level 1.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SSA_TAB"></a><a id="ssa_tab"></a><dl>
     * <dt><b>SSA_TAB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Expand tabs.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} iReqWidth Width required for fitting or clipping.
     * @param {Pointer<SCRIPT_CONTROL>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure. The application can set this parameter to <b>NULL</b> to indicate that all <b>SCRIPT_CONTROL</b> members are set to 0.
     * @param {Pointer<SCRIPT_STATE>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure. The application can set this parameter to <b>NULL</b> to indicate that all <b>SCRIPT_STATE</b> members are set to 0. The <b>uBidiLevel</b> member of <b>SCRIPT_STATE</b> is ignored. The value used is derived from the SSA_RTL flag in combination with the layout of the device context.
     * @param {Pointer<Int32>} piDx Pointer to the requested logical dx array.
     * @param {Pointer<SCRIPT_TABDEF>} pTabdef Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_tabdef">SCRIPT_TABDEF</a> structure. This value is only required if <i>dwFlags</i> is set to SSA_TAB.
     * @param {Pointer<Byte>} pbInClass Pointer to a BYTE value that indicates <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa">GetCharacterPlacement</a> character classifications.
     * @param {Pointer<Void>} pssa Pointer to a buffer in which this function retrieves a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure. This structure is dynamically allocated on successful return from the function.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * Error returns include:
     *     <ul>
     * <li>E_INVALIDARG. An invalid parameter is found.</li>
     * <li>USP_E_SCRIPT_NOT_IN_FONT. SSA_FALLBACK has not been specified, or a standard fallback font is missing.</li>
     * </ul>
     * 
     * 
     * The function can also return a system error converted to an HRESULT type. An example is an error returned due to lack of memory or a GDI call using the device context.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstringanalyse
     * @since windows5.0
     */
    static ScriptStringAnalyse(hdc, pString, cString, cGlyphs, iCharset, dwFlags, iReqWidth, psControl, psState, piDx, pTabdef, pbInClass, pssa) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptStringAnalyse", "ptr", hdc, "ptr", pString, "int", cString, "int", cGlyphs, "int", iCharset, "uint", dwFlags, "int", iReqWidth, "ptr", psControl, "ptr", psState, "int*", piDx, "ptr", pTabdef, "char*", pbInClass, "ptr", pssa, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Frees a SCRIPT_STRING_ANALYSIS structure.
     * @param {Pointer<Void>} pssa Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstringfree
     * @since windows5.0
     */
    static ScriptStringFree(pssa) {
        result := DllCall("USP10.dll\ScriptStringFree", "ptr", pssa, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Returns a pointer to a SIZE structure for an analyzed string.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for a string.
     * @returns {Pointer<SIZE>} Returns a pointer to a <a href="/previous-versions/dd145106(v=vs.85)">SIZE</a> structure containing the size (width and height) of the analyzed string if successful. The function returns <b>NULL</b> if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstring_psize
     * @since windows5.0
     */
    static ScriptString_pSize(ssa) {
        result := DllCall("USP10.dll\ScriptString_pSize", "ptr", ssa, "ptr")
        return result
    }

    /**
     * Returns a pointer to the length of a string after clipping.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @returns {Pointer<Int32>} Returns a pointer to the length of the string after clipping if successful. The length is the number of Unicode code points. The function returns <b>NULL</b> if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstring_pcoutchars
     * @since windows5.0
     */
    static ScriptString_pcOutChars(ssa) {
        result := DllCall("USP10.dll\ScriptString_pcOutChars", "ptr", ssa, "int*")
        return result
    }

    /**
     * Returns a pointer to a logical attributes buffer for an analyzed string.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @returns {Pointer<SCRIPT_LOGATTR>} Returns a pointer to a buffer containing <a href="/windows/win32/api/usp10/ns-usp10-script_logattr">SCRIPT_LOGATTR</a> structures defining logical attributes if successful. The function returns <b>NULL</b> if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstring_plogattr
     * @since windows5.0
     */
    static ScriptString_pLogAttr(ssa) {
        result := DllCall("USP10.dll\ScriptString_pLogAttr", "ptr", ssa, "ptr")
        return result
    }

    /**
     * Creates an array that maps an original character position to a glyph position.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Pointer<UInt32>} puOrder Pointer to a buffer in which this function retrieves an array of glyph positions, indexed by the original character position. The array should have room for at least the number of integers indicated by the <i>ssa</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstringgetorder
     * @since windows5.0
     */
    static ScriptStringGetOrder(ssa, puOrder) {
        result := DllCall("USP10.dll\ScriptStringGetOrder", "ptr", ssa, "uint*", puOrder, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the x coordinate for the leading or trailing edge of a character position.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} icp Character position in the string.
     * @param {BOOL} fTrailing <b>TRUE</b> to indicate the trailing edge of the character position (<i>icp</i>) that corresponds to the x coordinate. This parameter is set to <b>FALSE</b> to indicate the leading edge of the character position.
     * @param {Pointer<Int32>} pX Pointer to a buffer in which this function retrieves the x coordinate corresponding to the character position.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstringcptox
     * @since windows5.0
     */
    static ScriptStringCPtoX(ssa, icp, fTrailing, pX) {
        result := DllCall("USP10.dll\ScriptStringCPtoX", "ptr", ssa, "int", icp, "int", fTrailing, "int*", pX, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts an x coordinate to a character position.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} iX The x coordinate.
     * @param {Pointer<Int32>} piCh Pointer to a variable in which this function retrieves the character position corresponding to the x coordinate.
     * @param {Pointer<Int32>} piTrailing Pointer to a variable in which this function retrieves a value indicating if the x coordinate is for the leading edge or the trailing edge of the character position. For more information, see the Remarks section.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstringxtocp
     * @since windows5.0
     */
    static ScriptStringXtoCP(ssa, iX, piCh, piTrailing) {
        result := DllCall("USP10.dll\ScriptStringXtoCP", "ptr", ssa, "int", iX, "int*", piCh, "int*", piTrailing, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts visual widths into logical widths.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Pointer<Int32>} piDx Pointer to a buffer in which this function retrieves logical widths. The buffer should have room for at least the number of integers indicated by the <i>ssa</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptstring_pcoutchars">ScriptString_pcOutChars</a>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstringgetlogicalwidths
     * @since windows5.0
     */
    static ScriptStringGetLogicalWidths(ssa, piDx) {
        result := DllCall("USP10.dll\ScriptStringGetLogicalWidths", "ptr", ssa, "int*", piDx, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Checks a SCRIPT_STRING_ANALYSIS structure for invalid sequences.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for a string.
     * @returns {HRESULT} Returns S_OK if no invalid sequences are found. The function returns S_FALSE if one or more invalid sequences are found. The function returns a nonzero HRESULT value if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstringvalidate
     * @since windows5.0
     */
    static ScriptStringValidate(ssa) {
        result := DllCall("USP10.dll\ScriptStringValidate", "ptr", ssa, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Displays a string generated by a prior call to ScriptStringAnalyse and optionally adds highlighting.
     * @param {Pointer<Void>} ssa A <a href="https://docs.microsoft.com/windows/desktop/Intl/script-string-analysis">SCRIPT_STRING_ANALYSIS</a> structure for the string.
     * @param {Integer} iX The x-coordinate of the reference point used to position the string.
     * @param {Integer} iY The y-coordinate of the reference point used to position the string.
     * @param {Integer} uOptions 
     * @param {Pointer<RECT>} prc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that defines the rectangle to use. If <i>uOptions</i> is set to ETO_OPAQUE and <b>NULL</b> is provided for <i>prc</i>, the function succeeds and returns S_OK. However, if the application sets <i>uOptions</i> to ETO_CLIPPING and provides <b>NULL</b> for <i>prc</i>, the function returns E_INVALIDARG. The application can set this parameter to <b>NULL</b> to indicate that no option is needed.
     * @param {Integer} iMinSel Zero-based index specifying the starting position in the string. For no selection, the application should set <i>iMinSel</i> &gt;= <i>iMaxSel</i>.
     * @param {Integer} iMaxSel Zero-based index specifying the ending position in the string.
     * @param {BOOL} fDisabled <b>TRUE</b> if the operating system applies disabled-text highlighting by setting the background color to COLOR_HIGHLIGHT behind all selected characters. The application can set this parameter to <b>FALSE</b> if the operating system applies enabled-text highlighting by setting the background color to COLOR_HIGHLIGHT and the text color to COLOR_HIGHLIGHTTEXT for each selected character.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero <b>HRESULT</b> value if it does not succeed. The application can't test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptstringout
     * @since windows5.0
     */
    static ScriptStringOut(ssa, iX, iY, uOptions, prc, iMinSel, iMaxSel, fDisabled) {
        result := DllCall("USP10.dll\ScriptStringOut", "ptr", ssa, "int", iX, "int", iY, "uint", uOptions, "ptr", prc, "int", iMinSel, "int", iMaxSel, "int", fDisabled, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines whether a Unicode string requires complex script processing.
     * @param {PWSTR} pwcInChars Pointer to the string to test.
     * @param {Integer} cInChars Length of the input string, in characters.
     * @param {Integer} dwFlags 
     * @returns {HRESULT} Returns S_OK if the string requires complex script processing. The function returns S_FALSE if the string can be handled by standard API function calls, that is, it contains only characters laid out side-by-side and left-to-right. The function returns a nonzero HRESULT value if it does not succeed.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptiscomplex
     * @since windows5.0
     */
    static ScriptIsComplex(pwcInChars, cInChars, dwFlags) {
        pwcInChars := pwcInChars is String ? StrPtr(pwcInChars) : pwcInChars

        result := DllCall("USP10.dll\ScriptIsComplex", "ptr", pwcInChars, "int", cInChars, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Reads the National Language Support (NLS) native digit and digit substitution settings and records them in a SCRIPT_DIGITSUBSTITUTE structure. For more information, see Digit Shapes.
     * @param {Integer} Locale <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-identifiers">Locale identifier</a> of the locale to query. Typically, the application should set this parameter to <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-user-default">LOCALE_USER_DEFAULT</a>. Alternatively, the setting can indicate a specific locale combined with <a href="https://docs.microsoft.com/windows/desktop/Intl/locale-nouseroverride">LOCALE_NOUSEROVERRIDE</a> to obtain the default settings.
     * @param {Pointer<SCRIPT_DIGITSUBSTITUTE>} psds Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a> structure. This structure can be passed later to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptapplydigitsubstitution">ScriptApplyDigitSubstitution</a>.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * Error returns include:    
     * <ul>
     * <li>E_INVALIDARG. The <i>Locale</i> parameter indicates a locale that is invalid or not installed.</li>
     * <li>E_POINTER. The <i>psds</i> parameter is set to <b>NULL</b>.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptrecorddigitsubstitution
     * @since windows5.0
     */
    static ScriptRecordDigitSubstitution(Locale, psds) {
        result := DllCall("USP10.dll\ScriptRecordDigitSubstitution", "uint", Locale, "ptr", psds, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Applies the specified digit substitution settings to the specified script control and script state structures.
     * @param {Pointer<SCRIPT_DIGITSUBSTITUTE>} psds Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a> structure. The application sets this parameter to <b>NULL</b> if the function is to call <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptrecorddigitsubstitution">ScriptRecordDigitSubstitution</a> with LOCALE_USER_DEFAULT.
     * @param {Pointer<SCRIPT_CONTROL>} psc Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure with the <b>fContextDigits</b> and <b>uDefaultLanguage</b> members updated.
     * @param {Pointer<SCRIPT_STATE>} pss Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure with the <b>fDigitSubstitute</b> member updated.
     * @returns {HRESULT} Returns S_OK if successful. The function returns a nonzero HRESULT value if it does not succeed.
     * 
     * The function returns E_INVALIDARG if it does not recognize the <b>DigitSubstitute</b> member of <a href="/windows/win32/api/usp10/ns-usp10-script_digitsubstitute">SCRIPT_DIGITSUBSTITUTE</a>.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptapplydigitsubstitution
     * @since windows5.0
     */
    static ScriptApplyDigitSubstitution(psds, psc, pss) {
        result := DllCall("USP10.dll\ScriptApplyDigitSubstitution", "ptr", psds, "ptr", psc, "ptr", pss, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run with OpenType information. Each run consists of one call to this function.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. The structure identifies the shaping engine, so that glyphs can be formed correctly.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the OpenType script tag for the writing system.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType language tag for the writing system.
     * @param {Pointer<Int32>} rcRangeChars Array of characters in each <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">range</a>. The number of array elements is indicated by <i>cRanges</i>. The values of the elements of this array add up to the value of <i>cChars</i>.
     * @param {Pointer<TEXTRANGE_PROPERTIES>} rpRangeProperties Array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-textrange_properties">TEXTRANGE_PROPERTIES</a> structures, each representing one OpenType feature range. The number of structures is indicated by the <i>cRanges</i> parameter. For more information on <i>rpRangeProperties</i>, see the Remarks section.
     * @param {Integer} cRanges The number of OpenType feature ranges.
     * @param {PWSTR} pwcChars Pointer to an array of Unicode characters containing the run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Integer} cMaxGlyphs Maximum number of glyphs to generate.
     * @param {Pointer<UInt16>} pwLogClust Pointer to a buffer in which this function retrieves an array of logical <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">cluster</a> information. Each array element corresponds to a character in the array of Unicode characters. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure is <b>TRUE</b>, the elements decrease as the array is read.
     * @param {Pointer<SCRIPT_CHARPROP>} pCharProps Pointer to a buffer in which this function retrieves an array of character property values, of length indicated by <i>cChars</i>.
     * @param {Pointer<UInt16>} pwOutGlyphs Pointer to a buffer in which this function retrieves an array of glyphs.
     * @param {Pointer<SCRIPT_GLYPHPROP>} pOutGlyphProps Pointer to a buffer in which this function retrieves an array of attributes for each of the retrieved glyphs. The length of the values equals the value of <i>pcGlyphs</i>. Since one glyph property is indicated per glyph, the value of this parameter indicates the number of elements specified by <i>cMaxGlyphs</i>.
     * @param {Pointer<Int32>} pcGlyphs Pointer to the location in which this function retrieves the number of glyphs indicated in <i>pwOutGlyphs</i>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, the content of all output array values is undefined.
     * 
     * Error returns include:
     * 
     * <ul>
     * <li>E_OUTOFMEMORY. The output buffer length indicated by <i>cMaxGlyphs</i> is insufficient.</li>
     * <li>E_PENDING. The script cache specified by the <i>psc</i> parameter does not contain enough information to shape the string, and the device context has been passed as <b>NULL</b> so that the function is unable to complete the shaping process. The application should set up a correct device context for the run and call this function again with the appropriate context value in <i>hdc</i> and with all other parameters the same.</li>
     * <li>USP_E_SCRIPT_NOT_IN_FONT. The font corresponding to the device context does not support the required script. The application should choose another font, using either <a href="/windows/desktop/api/usp10/nf-usp10-scriptgetcmap">ScriptGetCMap</a> or another method to select the font.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptshapeopentype
     * @since windows6.0.6000
     */
    static ScriptShapeOpenType(hdc, psc, psa, tagScript, tagLangSys, rcRangeChars, rpRangeProperties, cRanges, pwcChars, cChars, cMaxGlyphs, pwLogClust, pCharProps, pwOutGlyphs, pOutGlyphProps, pcGlyphs) {
        pwcChars := pwcChars is String ? StrPtr(pwcChars) : pwcChars
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptShapeOpenType", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "int*", rcRangeChars, "ptr", rpRangeProperties, "int", cRanges, "ptr", pwcChars, "int", cChars, "int", cMaxGlyphs, "ushort*", pwLogClust, "ptr", pCharProps, "ushort*", pwOutGlyphs, "ptr", pOutGlyphProps, "int*", pcGlyphs, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Generates glyphs and visual attributes for a Unicode run with OpenType information from the output of ScriptShapeOpenType.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This structures identifies the shaping engine that governs the generated list of glyphs and their associated widths, and x and y placement offsets.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType script tag for the writing system to use.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure containing the OpenType language tag for the writing system.
     * @param {Pointer<Int32>} rcRangeChars Array of the number of characters in each range. The number of members is indicated in the <i>cRanges</i> parameter. The total of values should equal the value of <i>cChars</i>.
     * @param {Pointer<TEXTRANGE_PROPERTIES>} rpRangeProperties Array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-textrange_properties">TEXTRANGE_PROPERTIES</a> structures defining properties for each range. The number of elements is defined by the <i>cRanges</i> parameter.
     * @param {Integer} cRanges The number of OpenType feature ranges.
     * @param {PWSTR} pwcChars Pointer to an array of Unicode characters containing the run. The number of elements is defined by the <i>cRanges</i> parameter.
     * @param {Pointer<UInt16>} pwLogClust Pointer to an array of logical cluster information. Each element in the array corresponds to a character in the array defined by <i>pwcChars</i>. The value of each element is the offset from the first glyph in the run to the first glyph in the cluster containing the corresponding character. Note that, when the <b>fRTL</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure is set to <b>TRUE</b>, the elements in <i>pwLogClust</i> decrease as the array is read.
     * @param {Pointer<SCRIPT_CHARPROP>} pCharProps Pointer to an array of character property values in the Unicode run.
     * @param {Integer} cChars Number of characters in the Unicode run.
     * @param {Pointer<UInt16>} pwGlyphs Pointer to a glyph buffer obtained from an earlier call to the <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptshapeopentype">ScriptShapeOpenType</a> function.
     * @param {Pointer<SCRIPT_GLYPHPROP>} pGlyphProps Pointer to an array of attributes for each of the glyphs to retrieve. The number of values equals the value of 
     * <i>cGlyphs</i>. Since there is one glyph property per glyph, this parameter has the number of elements indicated by <i>cGlyphs</i>.
     * @param {Integer} cGlyphs Count of glyphs in a glyph array buffer.
     * @param {Pointer<Int32>} piAdvance Pointer to an array, of length indicated by <i>cGlyphs</i>, in which this function retrieves <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">advance width</a> information.
     * @param {Pointer<GOFFSET>} pGoffset Pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-goffset">GOFFSET</a> structures in which this structure retrieves the x and y offsets of combining glyphs. This array must be of length indicated by <i>cGlyphs</i>.
     * @param {Pointer<ABC>} pABC Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-abc">ABC</a> structure in which this function retrieves the <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">ABC width</a> for the entire <a href="https://docs.microsoft.com/windows/desktop/Intl/uniscribe-glossary">run</a>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, the output values are undefined. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * The function returns E_OUTOFMEMORY if the output buffer length indicated by <i>cGlyphs</i> is too small. The application can try calling again with larger buffers.
     * 
     * The function returns E_PENDING if the script cache specified by the <i>psc</i> parameter does not contain enough information to place the glyphs, and the <i>hdc</i> parameter is passed as <b>NULL</b> so that the function is unable to complete the placement process. The application should set up a correct device context for the run, and call this function again with the appropriate value in <i>hdc</i> and with all other parameters the same.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptplaceopentype
     * @since windows6.0.6000
     */
    static ScriptPlaceOpenType(hdc, psc, psa, tagScript, tagLangSys, rcRangeChars, rpRangeProperties, cRanges, pwcChars, pwLogClust, pCharProps, cChars, pwGlyphs, pGlyphProps, cGlyphs, piAdvance, pGoffset, pABC) {
        pwcChars := pwcChars is String ? StrPtr(pwcChars) : pwcChars
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptPlaceOpenType", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "int*", rcRangeChars, "ptr", rpRangeProperties, "int", cRanges, "ptr", pwcChars, "ushort*", pwLogClust, "ptr", pCharProps, "int", cChars, "ushort*", pwGlyphs, "ptr", pGlyphProps, "int", cGlyphs, "int*", piAdvance, "ptr", pGoffset, "ptr", pABC, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Breaks a Unicode string into individually shapeable items and provides an array of feature tags for each shapeable item for OpenType processing.
     * @param {PWSTR} pwcInChars Pointer to a Unicode string to itemize.
     * @param {Integer} cInChars Number of characters in <i>pwcInChars</i> to itemize.
     * @param {Integer} cMaxItems Maximum number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures defining items to process.
     * @param {Pointer<SCRIPT_CONTROL>} psControl Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> structure indicating the type of itemization to perform.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if no <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_control">SCRIPT_CONTROL</a> properties are needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_STATE>} psState Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_state">SCRIPT_STATE</a> structure indicating the initial bidirectional algorithm state.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> if the script state is not needed. For more information, see the Remarks section.
     * @param {Pointer<SCRIPT_ITEM>} pItems Pointer to a buffer in which the function retrieves <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures representing the items that have been processed. The buffer should be  <c>(cMaxItems + 1) * sizeof(SCRIPT_ITEM)</c> bytes in length. It is invalid to call this function with a buffer that handles less than two <b>SCRIPT_ITEM</b> structures. The function always adds a terminal item to the item analysis array so that the length of the item with zero-based index "i" is always available as:
     * 
     * <c>pItems[i+1].iCharPos - pItems[i].iCharPos;</c>
     * @param {Pointer<UInt32>} pScriptTags Pointer to a buffer in which the function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures representing script tags. The buffer should be  <c>cMaxItems * sizeof(OPENTYPE_TAG)</c> bytes in length.
     * 
     * <div class="alert"><b>Note</b>When all characters in an item are neutral, the value of this parameter is SCRIPT_TAG_UNKNOWN (0x00000000). This can happen, for example, if an item consists entirely of punctuation.</div>
     * <div></div>
     * @param {Pointer<Int32>} pcItems Pointer to the number of <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_item">SCRIPT_ITEM</a> structures processed.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. In all error cases, no items are fully processed and no part of the output contains defined values. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * The function returns E_OUTOFMEMORY if the size indicated by <i>cMaxItems</i> is too small. The application can try calling the function again with a larger buffer.
     * 
     * The function returns E_INVALIDARG if one or more of the following conditions occur:
     * 
     * <ul>
     * <li><i>pwcInChars</i> is set to <b>NULL</b></li>
     * <li><i>cInChars</i> is 0</li>
     * <li><i>pItems</i> is set to <b>NULL</b></li>
     * <li><i>pScriptTags</i> is set to <b>NULL</b></li>
     * <li><i>cMaxItems</i> &lt; 2</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptitemizeopentype
     * @since windows6.0.6000
     */
    static ScriptItemizeOpenType(pwcInChars, cInChars, cMaxItems, psControl, psState, pItems, pScriptTags, pcItems) {
        pwcInChars := pwcInChars is String ? StrPtr(pwcInChars) : pwcInChars

        result := DllCall("USP10.dll\ScriptItemizeOpenType", "ptr", pwcInChars, "int", cInChars, "int", cMaxItems, "ptr", psControl, "ptr", psState, "ptr", pItems, "uint*", pScriptTags, "int*", pcItems, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves a list of scripts available in the font for OpenType processing. Scripts comprising the list are retrieved from the font located in the supplied device context or from the script shaping engine that processes the font of the current run.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the appropriate font script tags can be retrieved. The application supplies a non-<b>NULL</b> value for this parameter to retrieve script tags appropriate for the current run.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} cMaxTags The length of the array specified by <i>pScriptTags</i>.
     * @param {Pointer<UInt32>} pScriptTags Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures defining script tags from the device context or the scripting engine associated with the current run. If the value of the <b>eScript</b> member of the <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure provided in the <i>psa</i> parameter has a definite script tag associated with it and the tag is present in the font, <i>pScriptTags</i> contains only this tag.
     * @param {Pointer<Int32>} pcTags Pointer to the number of elements in the script tag array indicated by <i>pScriptTags</i>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds the value of <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetfontscripttags
     * @since windows6.0.6000
     */
    static ScriptGetFontScriptTags(hdc, psc, psa, cMaxTags, pScriptTags, pcTags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptGetFontScriptTags", "ptr", hdc, "ptr", psc, "ptr", psa, "int", cMaxTags, "uint*", pScriptTags, "int*", pcTags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves a list of language tags that are available for the specified item and are supported by a specified script tag for OpenType processing. The tags comprising the list are retrieved from the font in the specified device context or cache.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the font language tags for the appropriate font and scripts can be retrieved.
     * 
     * Alternately, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for which the list of associated language tags is requested.
     * @param {Integer} cMaxTags The length of the array specified by <i>pLangSysTags</i>.
     * @param {Pointer<UInt32>} pLangsysTags Pointer to a buffer in which this function retrieves an array of <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structures identifying the language tags matching input criteria.
     * @param {Pointer<Int32>} pcTags Pointer to the number of elements in the language tag array.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetfontlanguagetags
     * @since windows6.0.6000
     */
    static ScriptGetFontLanguageTags(hdc, psc, psa, tagScript, cMaxTags, pLangsysTags, pcTags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptGetFontLanguageTags", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "int", cMaxTags, "uint*", pLangsysTags, "int*", pcTags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves a list of typographic features for the defined writing system for OpenType processing. The typographic feature tags comprising the list are retrieved from the font in the supplied device context or cache.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the font feature tags for the appropriate font and scripts can be retrieved.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag associated with the specified feature tags.
     * @param {Integer} tagLangSys An <b>OPENTYPE_TAG</b> structure defining the language tag associated with the specified feature tags.
     * @param {Integer} cMaxTags The length of the array specified by <i>pFeatureTags</i>.
     * @param {Pointer<UInt32>} pFeatureTags Pointer to a buffer in which this function retrieves an array of <b>OPENTYPE_TAG</b> structures defining the typographic feature tags supported by the font in the device context or cache for the defined writing system.
     * @param {Pointer<Int32>} pcTags Pointer to the number of elements in the feature tag array.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of matching tags exceeds the value of <i>cMaxTags</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetfontfeaturetags
     * @since windows6.0.6000
     */
    static ScriptGetFontFeatureTags(hdc, psc, psa, tagScript, tagLangSys, cMaxTags, pFeatureTags, pcTags) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptGetFontFeatureTags", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "int", cMaxTags, "uint*", pFeatureTags, "int*", pcTags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves a list of alternate glyphs for a specified character that can be accessed through a specified OpenType feature.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure defining the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine, so that the array of alternate glyphs can be created with the correct scope.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to receive unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag associated with alternate glyphs.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag associated with alternate glyphs.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag associated with alternate glyphs.
     * @param {Integer} wGlyphId The identifier of the original glyph mapped from the character map table.
     * @param {Integer} cMaxAlternates Length of the array specified by <i>pAlternateGlyphs</i>.
     * @param {Pointer<UInt16>} pAlternateGlyphs Pointer to buffer in which this function retrieves an array of glyph identifiers. The array includes the original glyph, followed by alternate glyphs. The first element is always the original glyph. Alternate forms are identified by an index into the array. The index is a value greater than one and less than the value of <i>pcAlternates</i>.
     * 
     * When the user chooses an alternate form from the user interface, the alternate glyph is applied to the corresponding character and the rendering is reformatted.
     * @param {Pointer<Int32>} pcAlternates Pointer to the number of elements in the array specified by <i>pAlternateGlyphs</i>.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * 
     * If the number of alternate glyphs exceeds the value of <i>cMaxAlternates</i>, the function fails with E_OUTOFMEMORY. The application can try calling again with larger buffers.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptgetfontalternateglyphs
     * @since windows6.0.6000
     */
    static ScriptGetFontAlternateGlyphs(hdc, psc, psa, tagScript, tagLangSys, tagFeature, wGlyphId, cMaxAlternates, pAlternateGlyphs, pcAlternates) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptGetFontAlternateGlyphs", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "ushort", wGlyphId, "int", cMaxAlternates, "ushort*", pAlternateGlyphs, "int*", pcAlternates, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enables substitution of a single glyph with one alternate form of the same glyph for OpenType processing.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure indicating the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This parameter identifies the shaping engine so that the correct substitute glyph is used.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for shaping.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag for shaping.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag to use for shaping the alternate glyph.
     * @param {Integer} lParameter Reference to the alternate glyph to substitute. This reference is an index to an array that contains all the alternate glyphs defined in the feature, as illustrated for <a href="https://docs.microsoft.com/windows/desktop/api/usp10/ns-usp10-opentype_feature_record">OPENTYPE_FEATURE_RECORD</a>. The alternate glyph array is one of the items retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptgetfontalternateglyphs">ScriptGetFontAlternateGlyphs</a>.
     * @param {Integer} wGlyphId Identifier of the original glyph.
     * @param {Pointer<UInt16>} pwOutGlyphId Pointer to the location in which this function retrieves the identifier of the alternate glyph.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptsubstitutesingleglyph
     * @since windows6.0.6000
     */
    static ScriptSubstituteSingleGlyph(hdc, psc, psa, tagScript, tagLangSys, tagFeature, lParameter, wGlyphId, pwOutGlyphId) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptSubstituteSingleGlyph", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "int", lParameter, "ushort", wGlyphId, "ushort*", pwOutGlyphId, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Positions a single glyph with a single adjustment using a specified feature provided in the font for OpenType processing. Most often, applications use this function to align a glyph optically at the beginning or end of a line.
     * @param {HDC} hdc Handle to the device context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/caching">Caching</a>.
     * @param {Pointer<Void>} psc Pointer to a <a href="https://docs.microsoft.com/windows/desktop/Intl/script-cache">SCRIPT_CACHE</a> structure identifying the script cache.
     * @param {Pointer<SCRIPT_ANALYSIS>} psa Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/usp10/ns-usp10-script_analysis">SCRIPT_ANALYSIS</a> structure obtained from a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptitemizeopentype">ScriptItemizeOpenType</a>. This structure identifies the shaping engine, so that the advance widths can be retrieved.
     * 
     * Alternatively, the application can set this parameter to <b>NULL</b> to retrieve unfiltered results.
     * @param {Integer} tagScript An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the script tag for shaping.
     * @param {Integer} tagLangSys An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the language tag for shaping.
     * @param {Integer} tagFeature An <a href="https://docs.microsoft.com/windows/desktop/Intl/opentype-tag">OPENTYPE_TAG</a> structure defining the feature tag to use for shaping the alternate glyph.
     * @param {Integer} lParameter A flag specifying if single substitution should be applied to the identifier specified in <i>wGlyphId</i>. The application sets this parameter to 1 to apply the single substitution feature to the identifier. The application sets the parameter to 0 if the function should not apply the feature.
     * @param {Integer} wGlyphId The identifier of the original glyph being shaped.
     * @param {Integer} iAdvance The original glyph advance width.
     * @param {GOFFSET} GOffset The original glyph offset. Typically, this value is an output of <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplaceopentype">ScriptPlaceOpenType</a> or <a href="https://docs.microsoft.com/windows/desktop/api/usp10/nf-usp10-scriptplace">ScriptPlace</a>.
     * @param {Pointer<Int32>} piOutAdvance Pointer to the location in which this function retrieves the new advance width adjusted for the alternate glyph.
     * @param {Pointer<GOFFSET>} pOutGoffset Pointer to the location in which this function retrieves the new glyph offset adjusted for the alternate glyph.
     * @returns {HRESULT} Returns 0 if successful. The function returns a nonzero HRESULT value if it does not succeed. The application can test the return value with the <b>SUCCEEDED</b> and <b>FAILED</b> macros.
     * @see https://docs.microsoft.com/windows/win32/api//usp10/nf-usp10-scriptpositionsingleglyph
     * @since windows6.0.6000
     */
    static ScriptPositionSingleGlyph(hdc, psc, psa, tagScript, tagLangSys, tagFeature, lParameter, wGlyphId, iAdvance, GOffset, piOutAdvance, pOutGoffset) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("USP10.dll\ScriptPositionSingleGlyph", "ptr", hdc, "ptr", psc, "ptr", psa, "uint", tagScript, "uint", tagLangSys, "uint", tagFeature, "int", lParameter, "ushort", wGlyphId, "int", iAdvance, "ptr", GOffset, "int*", piOutAdvance, "ptr", pOutGoffset, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} s 
     * @param {Pointer<Int32>} pi 
     * @param {Integer} length 
     * @param {Integer} c 
     * @param {Integer} strict 
     * @returns {Integer} 
     */
    static utf8_nextCharSafeBody(s, pi, length, c, strict) {
        result := DllCall("icuuc.dll\utf8_nextCharSafeBody", "char*", s, "int*", pi, "int", length, "int", c, "char", strict, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} s 
     * @param {Integer} i 
     * @param {Integer} length 
     * @param {Integer} c 
     * @param {Pointer<SByte>} pIsError 
     * @returns {Integer} 
     */
    static utf8_appendCharSafeBody(s, i, length, c, pIsError) {
        result := DllCall("icuuc.dll\utf8_appendCharSafeBody", "char*", s, "int", i, "int", length, "int", c, "char*", pIsError, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} s 
     * @param {Integer} start 
     * @param {Pointer<Int32>} pi 
     * @param {Integer} c 
     * @param {Integer} strict 
     * @returns {Integer} 
     */
    static utf8_prevCharSafeBody(s, start, pi, c, strict) {
        result := DllCall("icuuc.dll\utf8_prevCharSafeBody", "char*", s, "int", start, "int*", pi, "int", c, "char", strict, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} s 
     * @param {Integer} start 
     * @param {Integer} i 
     * @returns {Integer} 
     */
    static utf8_back1SafeBody(s, start, i) {
        result := DllCall("icuuc.dll\utf8_back1SafeBody", "char*", s, "int", start, "int", i, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @param {PSTR} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionFromString(versionArray, versionString) {
        versionString := versionString is String ? StrPtr(versionString) : versionString

        DllCall("icuuc.dll\u_versionFromString", "char*", versionArray, "ptr", versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @param {Pointer<UInt16>} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionFromUString(versionArray, versionString) {
        DllCall("icuuc.dll\u_versionFromUString", "char*", versionArray, "ushort*", versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @param {PSTR} versionString 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_versionToString(versionArray, versionString) {
        versionString := versionString is String ? StrPtr(versionString) : versionString

        DllCall("icuuc.dll\u_versionToString", "char*", versionArray, "ptr", versionString, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getVersion(versionArray) {
        DllCall("icuuc.dll\u_getVersion", "char*", versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Integer} code 
     * @returns {PSTR} 
     */
    static u_errorName(code) {
        result := DllCall("icuuc.dll\u_errorName", "int", code, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Integer} traceLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_setLevel(traceLevel) {
        DllCall("icuuc.dll\utrace_setLevel", "int", traceLevel, "CDecl ")
    }

    /**
     * 
     * @returns {Integer} 
     */
    static utrace_getLevel() {
        result := DllCall("icuuc.dll\utrace_getLevel", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UTraceEntry>} e 
     * @param {Pointer<UTraceExit>} x 
     * @param {Pointer<UTraceData>} d 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_setFunctions(context, e, x, d) {
        DllCall("icuuc.dll\utrace_setFunctions", "ptr", context, "ptr", e, "ptr", x, "ptr", d, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UTraceEntry>} e 
     * @param {Pointer<UTraceExit>} x 
     * @param {Pointer<UTraceData>} d 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrace_getFunctions(context, e, x, d) {
        DllCall("icuuc.dll\utrace_getFunctions", "ptr", context, "ptr", e, "ptr", x, "ptr", d, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} outBuf 
     * @param {Integer} capacity 
     * @param {Integer} indent 
     * @param {PSTR} fmt 
     * @param {Pointer<SByte>} args 
     * @returns {Integer} 
     */
    static utrace_vformat(outBuf, capacity, indent, fmt, args) {
        outBuf := outBuf is String ? StrPtr(outBuf) : outBuf
        fmt := fmt is String ? StrPtr(fmt) : fmt

        result := DllCall("icuuc.dll\utrace_vformat", "ptr", outBuf, "int", capacity, "int", indent, "ptr", fmt, "char*", args, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} outBuf 
     * @param {Integer} capacity 
     * @param {Integer} indent 
     * @param {PSTR} fmt 
     * @returns {Integer} 
     */
    static utrace_format(outBuf, capacity, indent, fmt) {
        outBuf := outBuf is String ? StrPtr(outBuf) : outBuf
        fmt := fmt is String ? StrPtr(fmt) : fmt

        result := DllCall("icuuc.dll\utrace_format", "ptr", outBuf, "int", capacity, "int", indent, "ptr", fmt, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} fnNumber 
     * @returns {PSTR} 
     */
    static utrace_functionName(fnNumber) {
        result := DllCall("icuuc.dll\utrace_functionName", "int", fnNumber, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_shapeArabic(source, sourceLength, dest, destSize, options, pErrorCode) {
        result := DllCall("icuuc.dll\u_shapeArabic", "ushort*", source, "int", sourceLength, "ushort*", dest, "int", destSize, "uint", options, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} nameOrAbbrOrLocale 
     * @param {Pointer<Int32>} fillIn 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uscript_getCode(nameOrAbbrOrLocale, fillIn, capacity, err) {
        nameOrAbbrOrLocale := nameOrAbbrOrLocale is String ? StrPtr(nameOrAbbrOrLocale) : nameOrAbbrOrLocale

        result := DllCall("icuuc.dll\uscript_getCode", "ptr", nameOrAbbrOrLocale, "int*", fillIn, "int", capacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} scriptCode 
     * @returns {PSTR} 
     */
    static uscript_getName(scriptCode) {
        result := DllCall("icuuc.dll\uscript_getName", "int", scriptCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Integer} scriptCode 
     * @returns {PSTR} 
     */
    static uscript_getShortName(scriptCode) {
        result := DllCall("icuuc.dll\uscript_getShortName", "int", scriptCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Integer} codepoint 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uscript_getScript(codepoint, err) {
        result := DllCall("icuuc.dll\uscript_getScript", "int", codepoint, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} sc 
     * @returns {Integer} 
     */
    static uscript_hasScript(c, sc) {
        result := DllCall("icuuc.dll\uscript_hasScript", "int", c, "int", sc, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<Int32>} scripts 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} errorCode 
     * @returns {Integer} 
     */
    static uscript_getScriptExtensions(c, scripts, capacity, errorCode) {
        result := DllCall("icuuc.dll\uscript_getScriptExtensions", "int", c, "int*", scripts, "int", capacity, "int*", errorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uscript_getSampleString(script, dest, capacity, pErrorCode) {
        result := DllCall("icuuc.dll\uscript_getSampleString", "int", script, "ushort*", dest, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_getUsage(script) {
        result := DllCall("icuuc.dll\uscript_getUsage", "int", script, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_isRightToLeft(script) {
        result := DllCall("icuuc.dll\uscript_isRightToLeft", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_breaksBetweenLetters(script) {
        result := DllCall("icuuc.dll\uscript_breaksBetweenLetters", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} script 
     * @returns {Integer} 
     */
    static uscript_isCased(script) {
        result := DllCall("icuuc.dll\uscript_isCased", "int", script, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_current32(iter) {
        result := DllCall("icuuc.dll\uiter_current32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_next32(iter) {
        result := DllCall("icuuc.dll\uiter_next32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_previous32(iter) {
        result := DllCall("icuuc.dll\uiter_previous32", "ptr", iter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @returns {Integer} 
     */
    static uiter_getState(iter) {
        result := DllCall("icuuc.dll\uiter_getState", "ptr", iter, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Integer} state 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setState(iter, state, pErrorCode) {
        DllCall("icuuc.dll\uiter_setState", "ptr", iter, "uint", state, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setString(iter, s, length) {
        DllCall("icuuc.dll\uiter_setString", "ptr", iter, "ushort*", s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setUTF16BE(iter, s, length) {
        s := s is String ? StrPtr(s) : s

        DllCall("icuuc.dll\uiter_setUTF16BE", "ptr", iter, "ptr", s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uiter_setUTF8(iter, s, length) {
        s := s is String ? StrPtr(s) : s

        DllCall("icuuc.dll\uiter_setUTF8", "ptr", iter, "ptr", s, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @returns {String} Nothing - always returns an empty string
     */
    static uenum_close(en) {
        DllCall("icuuc.dll\uenum_close", "ptr", en, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uenum_count(en, status) {
        result := DllCall("icuuc.dll\uenum_count", "ptr", en, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @param {Pointer<Int32>} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static uenum_unext(en, resultLength, status) {
        result := DllCall("icuuc.dll\uenum_unext", "ptr", en, "int*", resultLength, "int*", status, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @param {Pointer<Int32>} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static uenum_next(en, resultLength, status) {
        result := DllCall("icuuc.dll\uenum_next", "ptr", en, "int*", resultLength, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UEnumeration>} en 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uenum_reset(en, status) {
        DllCall("icuuc.dll\uenum_reset", "ptr", en, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} strings 
     * @param {Integer} count 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static uenum_openUCharStringsEnumeration(strings, count, ec) {
        result := DllCall("icuuc.dll\uenum_openUCharStringsEnumeration", "ushort*", strings, "int", count, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<SByte>} strings 
     * @param {Integer} count 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static uenum_openCharStringsEnumeration(strings, count, ec) {
        result := DllCall("icuuc.dll\uenum_openCharStringsEnumeration", "char*", strings, "int", count, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {PSTR} 
     */
    static uloc_getDefault() {
        result := DllCall("icuuc.dll\uloc_getDefault", "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uloc_setDefault(localeID, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        DllCall("icuuc.dll\uloc_setDefault", "ptr", localeID, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} language 
     * @param {Integer} languageCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getLanguage(localeID, language, languageCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        language := language is String ? StrPtr(language) : language

        result := DllCall("icuuc.dll\uloc_getLanguage", "ptr", localeID, "ptr", language, "int", languageCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} script 
     * @param {Integer} scriptCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getScript(localeID, script, scriptCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        script := script is String ? StrPtr(script) : script

        result := DllCall("icuuc.dll\uloc_getScript", "ptr", localeID, "ptr", script, "int", scriptCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} country 
     * @param {Integer} countryCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getCountry(localeID, country, countryCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        country := country is String ? StrPtr(country) : country

        result := DllCall("icuuc.dll\uloc_getCountry", "ptr", localeID, "ptr", country, "int", countryCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} variant 
     * @param {Integer} variantCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getVariant(localeID, variant, variantCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        variant := variant is String ? StrPtr(variant) : variant

        result := DllCall("icuuc.dll\uloc_getVariant", "ptr", localeID, "ptr", variant, "int", variantCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getName(localeID, name, nameCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        name := name is String ? StrPtr(name) : name

        result := DllCall("icuuc.dll\uloc_getName", "ptr", localeID, "ptr", name, "int", nameCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_canonicalize(localeID, name, nameCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        name := name is String ? StrPtr(name) : name

        result := DllCall("icuuc.dll\uloc_canonicalize", "ptr", localeID, "ptr", name, "int", nameCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @returns {PSTR} 
     */
    static uloc_getISO3Language(localeID) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuuc.dll\uloc_getISO3Language", "ptr", localeID, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @returns {PSTR} 
     */
    static uloc_getISO3Country(localeID) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuuc.dll\uloc_getISO3Country", "ptr", localeID, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @returns {Integer} 
     */
    static uloc_getLCID(localeID) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuuc.dll\uloc_getLCID", "ptr", localeID, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} displayLocale 
     * @param {Pointer<UInt16>} language 
     * @param {Integer} languageCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayLanguage(locale, displayLocale, language, languageCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        result := DllCall("icuuc.dll\uloc_getDisplayLanguage", "ptr", locale, "ptr", displayLocale, "ushort*", language, "int", languageCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} displayLocale 
     * @param {Pointer<UInt16>} script 
     * @param {Integer} scriptCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayScript(locale, displayLocale, script, scriptCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        result := DllCall("icuuc.dll\uloc_getDisplayScript", "ptr", locale, "ptr", displayLocale, "ushort*", script, "int", scriptCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} displayLocale 
     * @param {Pointer<UInt16>} country 
     * @param {Integer} countryCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayCountry(locale, displayLocale, country, countryCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        result := DllCall("icuuc.dll\uloc_getDisplayCountry", "ptr", locale, "ptr", displayLocale, "ushort*", country, "int", countryCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} displayLocale 
     * @param {Pointer<UInt16>} variant 
     * @param {Integer} variantCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayVariant(locale, displayLocale, variant, variantCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        result := DllCall("icuuc.dll\uloc_getDisplayVariant", "ptr", locale, "ptr", displayLocale, "ushort*", variant, "int", variantCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @param {PSTR} displayLocale 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayKeyword(keyword, displayLocale, dest, destCapacity, status) {
        keyword := keyword is String ? StrPtr(keyword) : keyword
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        result := DllCall("icuuc.dll\uloc_getDisplayKeyword", "ptr", keyword, "ptr", displayLocale, "ushort*", dest, "int", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {PSTR} keyword 
     * @param {PSTR} displayLocale 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getDisplayKeywordValue(locale, keyword, displayLocale, dest, destCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale
        keyword := keyword is String ? StrPtr(keyword) : keyword
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        result := DllCall("icuuc.dll\uloc_getDisplayKeywordValue", "ptr", locale, "ptr", keyword, "ptr", displayLocale, "ushort*", dest, "int", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} inLocaleID 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getDisplayName(localeID, inLocaleID, result, maxResultSize, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        inLocaleID := inLocaleID is String ? StrPtr(inLocaleID) : inLocaleID

        result := DllCall("icuuc.dll\uloc_getDisplayName", "ptr", localeID, "ptr", inLocaleID, "ushort*", result, "int", maxResultSize, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @returns {PSTR} 
     */
    static uloc_getAvailable(n) {
        result := DllCall("icuuc.dll\uloc_getAvailable", "int", n, "CDecl char*")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static uloc_countAvailable() {
        result := DllCall("icuuc.dll\uloc_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uloc_openAvailableByType(type, status) {
        result := DllCall("icu.dll\uloc_openAvailableByType", "int", type, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Pointer<SByte>} 
     */
    static uloc_getISOLanguages() {
        result := DllCall("icuuc.dll\uloc_getISOLanguages", "CDecl char*")
        return result
    }

    /**
     * 
     * @returns {Pointer<SByte>} 
     */
    static uloc_getISOCountries() {
        result := DllCall("icuuc.dll\uloc_getISOCountries", "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} parent 
     * @param {Integer} parentCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getParent(localeID, parent, parentCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        parent := parent is String ? StrPtr(parent) : parent

        result := DllCall("icuuc.dll\uloc_getParent", "ptr", localeID, "ptr", parent, "int", parentCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} name 
     * @param {Integer} nameCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_getBaseName(localeID, name, nameCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        name := name is String ? StrPtr(name) : name

        result := DllCall("icuuc.dll\uloc_getBaseName", "ptr", localeID, "ptr", name, "int", nameCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uloc_openKeywords(localeID, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuuc.dll\uloc_openKeywords", "ptr", localeID, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} keywordName 
     * @param {PSTR} buffer 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getKeywordValue(localeID, keywordName, buffer, bufferCapacity, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        keywordName := keywordName is String ? StrPtr(keywordName) : keywordName
        buffer := buffer is String ? StrPtr(buffer) : buffer

        result := DllCall("icuuc.dll\uloc_getKeywordValue", "ptr", localeID, "ptr", keywordName, "ptr", buffer, "int", bufferCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} keywordName 
     * @param {PSTR} keywordValue 
     * @param {PSTR} buffer 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_setKeywordValue(keywordName, keywordValue, buffer, bufferCapacity, status) {
        keywordName := keywordName is String ? StrPtr(keywordName) : keywordName
        keywordValue := keywordValue is String ? StrPtr(keywordValue) : keywordValue
        buffer := buffer is String ? StrPtr(buffer) : buffer

        result := DllCall("icuuc.dll\uloc_setKeywordValue", "ptr", keywordName, "ptr", keywordValue, "ptr", buffer, "int", bufferCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @returns {Integer} 
     */
    static uloc_isRightToLeft(locale) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\uloc_isRightToLeft", "ptr", locale, "CDecl char")
        return result
    }

    /**
     * 
     * @param {PSTR} localeId 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getCharacterOrientation(localeId, status) {
        localeId := localeId is String ? StrPtr(localeId) : localeId

        result := DllCall("icuuc.dll\uloc_getCharacterOrientation", "ptr", localeId, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeId 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getLineOrientation(localeId, status) {
        localeId := localeId is String ? StrPtr(localeId) : localeId

        result := DllCall("icuuc.dll\uloc_getLineOrientation", "ptr", localeId, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} result 
     * @param {Integer} resultAvailable 
     * @param {Pointer<Int32>} outResult 
     * @param {PSTR} httpAcceptLanguage 
     * @param {Pointer<UEnumeration>} availableLocales 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_acceptLanguageFromHTTP(result, resultAvailable, outResult, httpAcceptLanguage, availableLocales, status) {
        result := result is String ? StrPtr(result) : result
        httpAcceptLanguage := httpAcceptLanguage is String ? StrPtr(httpAcceptLanguage) : httpAcceptLanguage

        result := DllCall("icuuc.dll\uloc_acceptLanguageFromHTTP", "ptr", result, "int", resultAvailable, "int*", outResult, "ptr", httpAcceptLanguage, "ptr", availableLocales, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} result 
     * @param {Integer} resultAvailable 
     * @param {Pointer<Int32>} outResult 
     * @param {Pointer<SByte>} acceptList 
     * @param {Integer} acceptListCount 
     * @param {Pointer<UEnumeration>} availableLocales 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_acceptLanguage(result, resultAvailable, outResult, acceptList, acceptListCount, availableLocales, status) {
        result := result is String ? StrPtr(result) : result

        result := DllCall("icuuc.dll\uloc_acceptLanguage", "ptr", result, "int", resultAvailable, "int*", outResult, "char*", acceptList, "int", acceptListCount, "ptr", availableLocales, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} hostID 
     * @param {PSTR} locale 
     * @param {Integer} localeCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uloc_getLocaleForLCID(hostID, locale, localeCapacity, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\uloc_getLocaleForLCID", "uint", hostID, "ptr", locale, "int", localeCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} maximizedLocaleID 
     * @param {Integer} maximizedLocaleIDCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_addLikelySubtags(localeID, maximizedLocaleID, maximizedLocaleIDCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        maximizedLocaleID := maximizedLocaleID is String ? StrPtr(maximizedLocaleID) : maximizedLocaleID

        result := DllCall("icuuc.dll\uloc_addLikelySubtags", "ptr", localeID, "ptr", maximizedLocaleID, "int", maximizedLocaleIDCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} minimizedLocaleID 
     * @param {Integer} minimizedLocaleIDCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_minimizeSubtags(localeID, minimizedLocaleID, minimizedLocaleIDCapacity, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        minimizedLocaleID := minimizedLocaleID is String ? StrPtr(minimizedLocaleID) : minimizedLocaleID

        result := DllCall("icuuc.dll\uloc_minimizeSubtags", "ptr", localeID, "ptr", minimizedLocaleID, "int", minimizedLocaleIDCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} langtag 
     * @param {PSTR} localeID 
     * @param {Integer} localeIDCapacity 
     * @param {Pointer<Int32>} parsedLength 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_forLanguageTag(langtag, localeID, localeIDCapacity, parsedLength, err) {
        langtag := langtag is String ? StrPtr(langtag) : langtag
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuuc.dll\uloc_forLanguageTag", "ptr", langtag, "ptr", localeID, "int", localeIDCapacity, "int*", parsedLength, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {PSTR} langtag 
     * @param {Integer} langtagCapacity 
     * @param {Integer} strict 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static uloc_toLanguageTag(localeID, langtag, langtagCapacity, strict, err) {
        localeID := localeID is String ? StrPtr(localeID) : localeID
        langtag := langtag is String ? StrPtr(langtag) : langtag

        result := DllCall("icuuc.dll\uloc_toLanguageTag", "ptr", localeID, "ptr", langtag, "int", langtagCapacity, "char", strict, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @returns {PSTR} 
     */
    static uloc_toUnicodeLocaleKey(keyword) {
        keyword := keyword is String ? StrPtr(keyword) : keyword

        result := DllCall("icuuc.dll\uloc_toUnicodeLocaleKey", "ptr", keyword, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @param {PSTR} value 
     * @returns {PSTR} 
     */
    static uloc_toUnicodeLocaleType(keyword, value) {
        keyword := keyword is String ? StrPtr(keyword) : keyword
        value := value is String ? StrPtr(value) : value

        result := DllCall("icuuc.dll\uloc_toUnicodeLocaleType", "ptr", keyword, "ptr", value, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @returns {PSTR} 
     */
    static uloc_toLegacyKey(keyword) {
        keyword := keyword is String ? StrPtr(keyword) : keyword

        result := DllCall("icuuc.dll\uloc_toLegacyKey", "ptr", keyword, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @param {PSTR} value 
     * @returns {PSTR} 
     */
    static uloc_toLegacyType(keyword, value) {
        keyword := keyword is String ? StrPtr(keyword) : keyword
        value := value is String ? StrPtr(value) : value

        result := DllCall("icuuc.dll\uloc_toLegacyType", "ptr", keyword, "ptr", value, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_open(packageName, locale, status) {
        packageName := packageName is String ? StrPtr(packageName) : packageName
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ures_open", "ptr", packageName, "ptr", locale, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_openDirect(packageName, locale, status) {
        packageName := packageName is String ? StrPtr(packageName) : packageName
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ures_openDirect", "ptr", packageName, "ptr", locale, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} packageName 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_openU(packageName, locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ures_openU", "ushort*", packageName, "ptr", locale, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_close(resourceBundle) {
        DllCall("icuuc.dll\ures_close", "ptr", resourceBundle, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {Pointer<Byte>} versionInfo 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_getVersion(resB, versionInfo) {
        DllCall("icuuc.dll\ures_getVersion", "ptr", resB, "char*", versionInfo, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ures_getLocaleByType(resourceBundle, type, status) {
        result := DllCall("icuuc.dll\ures_getLocaleByType", "ptr", resourceBundle, "int", type, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ures_getString(resourceBundle, len, status) {
        result := DllCall("icuuc.dll\ures_getString", "ptr", resourceBundle, "int*", len, "int*", status, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {PSTR} dest 
     * @param {Pointer<Int32>} length 
     * @param {Integer} forceCopy 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ures_getUTF8String(resB, dest, length, forceCopy, status) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\ures_getUTF8String", "ptr", resB, "ptr", dest, "int*", length, "char", forceCopy, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Byte>} 
     */
    static ures_getBinary(resourceBundle, len, status) {
        result := DllCall("icuuc.dll\ures_getBinary", "ptr", resourceBundle, "int*", len, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Int32>} 
     */
    static ures_getIntVector(resourceBundle, len, status) {
        result := DllCall("icuuc.dll\ures_getIntVector", "ptr", resourceBundle, "int*", len, "int*", status, "CDecl int*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ures_getUInt(resourceBundle, status) {
        result := DllCall("icuuc.dll\ures_getUInt", "ptr", resourceBundle, "int*", status, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ures_getInt(resourceBundle, status) {
        result := DllCall("icuuc.dll\ures_getInt", "ptr", resourceBundle, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {Integer} 
     */
    static ures_getSize(resourceBundle) {
        result := DllCall("icuuc.dll\ures_getSize", "ptr", resourceBundle, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {Integer} 
     */
    static ures_getType(resourceBundle) {
        result := DllCall("icuuc.dll\ures_getType", "ptr", resourceBundle, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {PSTR} 
     */
    static ures_getKey(resourceBundle) {
        result := DllCall("icuuc.dll\ures_getKey", "ptr", resourceBundle, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {String} Nothing - always returns an empty string
     */
    static ures_resetIterator(resourceBundle) {
        DllCall("icuuc.dll\ures_resetIterator", "ptr", resourceBundle, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @returns {Integer} 
     */
    static ures_hasNext(resourceBundle) {
        result := DllCall("icuuc.dll\ures_hasNext", "ptr", resourceBundle, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<UResourceBundle>} fillIn 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_getNextResource(resourceBundle, fillIn, status) {
        result := DllCall("icuuc.dll\ures_getNextResource", "ptr", resourceBundle, "ptr", fillIn, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<SByte>} key 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ures_getNextString(resourceBundle, len, key, status) {
        result := DllCall("icuuc.dll\ures_getNextString", "ptr", resourceBundle, "int*", len, "char*", key, "int*", status, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Integer} indexR 
     * @param {Pointer<UResourceBundle>} fillIn 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_getByIndex(resourceBundle, indexR, fillIn, status) {
        result := DllCall("icuuc.dll\ures_getByIndex", "ptr", resourceBundle, "int", indexR, "ptr", fillIn, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {Integer} indexS 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ures_getStringByIndex(resourceBundle, indexS, len, status) {
        result := DllCall("icuuc.dll\ures_getStringByIndex", "ptr", resourceBundle, "int", indexS, "int*", len, "int*", status, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {Integer} stringIndex 
     * @param {PSTR} dest 
     * @param {Pointer<Int32>} pLength 
     * @param {Integer} forceCopy 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ures_getUTF8StringByIndex(resB, stringIndex, dest, pLength, forceCopy, status) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\ures_getUTF8StringByIndex", "ptr", resB, "int", stringIndex, "ptr", dest, "int*", pLength, "char", forceCopy, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resourceBundle 
     * @param {PSTR} key 
     * @param {Pointer<UResourceBundle>} fillIn 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UResourceBundle>} 
     */
    static ures_getByKey(resourceBundle, key, fillIn, status) {
        key := key is String ? StrPtr(key) : key

        result := DllCall("icuuc.dll\ures_getByKey", "ptr", resourceBundle, "ptr", key, "ptr", fillIn, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {PSTR} key 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ures_getStringByKey(resB, key, len, status) {
        key := key is String ? StrPtr(key) : key

        result := DllCall("icuuc.dll\ures_getStringByKey", "ptr", resB, "ptr", key, "int*", len, "int*", status, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} resB 
     * @param {PSTR} key 
     * @param {PSTR} dest 
     * @param {Pointer<Int32>} pLength 
     * @param {Integer} forceCopy 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ures_getUTF8StringByKey(resB, key, dest, pLength, forceCopy, status) {
        key := key is String ? StrPtr(key) : key
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\ures_getUTF8StringByKey", "ptr", resB, "ptr", key, "ptr", dest, "int*", pLength, "char", forceCopy, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ures_openAvailableLocales(packageName, status) {
        packageName := packageName is String ? StrPtr(packageName) : packageName

        result := DllCall("icuuc.dll\ures_openAvailableLocales", "ptr", packageName, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Integer} dialectHandling 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<ULocaleDisplayNames>} 
     */
    static uldn_open(locale, dialectHandling, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\uldn_open", "ptr", locale, "int", dialectHandling, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @returns {String} Nothing - always returns an empty string
     */
    static uldn_close(ldn) {
        DllCall("icuuc.dll\uldn_close", "ptr", ldn, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @returns {PSTR} 
     */
    static uldn_getLocale(ldn) {
        result := DllCall("icuuc.dll\uldn_getLocale", "ptr", ldn, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @returns {Integer} 
     */
    static uldn_getDialectHandling(ldn) {
        result := DllCall("icuuc.dll\uldn_getDialectHandling", "ptr", ldn, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_localeDisplayName(ldn, locale, result, maxResultSize, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\uldn_localeDisplayName", "ptr", ldn, "ptr", locale, "ushort*", result, "int", maxResultSize, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} lang 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_languageDisplayName(ldn, lang, result, maxResultSize, pErrorCode) {
        lang := lang is String ? StrPtr(lang) : lang

        result := DllCall("icuuc.dll\uldn_languageDisplayName", "ptr", ldn, "ptr", lang, "ushort*", result, "int", maxResultSize, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} script 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_scriptDisplayName(ldn, script, result, maxResultSize, pErrorCode) {
        script := script is String ? StrPtr(script) : script

        result := DllCall("icuuc.dll\uldn_scriptDisplayName", "ptr", ldn, "ptr", script, "ushort*", result, "int", maxResultSize, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {Integer} scriptCode 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_scriptCodeDisplayName(ldn, scriptCode, result, maxResultSize, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_scriptCodeDisplayName", "ptr", ldn, "int", scriptCode, "ushort*", result, "int", maxResultSize, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} region 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_regionDisplayName(ldn, region, result, maxResultSize, pErrorCode) {
        region := region is String ? StrPtr(region) : region

        result := DllCall("icuuc.dll\uldn_regionDisplayName", "ptr", ldn, "ptr", region, "ushort*", result, "int", maxResultSize, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} variant 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_variantDisplayName(ldn, variant, result, maxResultSize, pErrorCode) {
        variant := variant is String ? StrPtr(variant) : variant

        result := DllCall("icuuc.dll\uldn_variantDisplayName", "ptr", ldn, "ptr", variant, "ushort*", result, "int", maxResultSize, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} key 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_keyDisplayName(ldn, key, result, maxResultSize, pErrorCode) {
        key := key is String ? StrPtr(key) : key

        result := DllCall("icuuc.dll\uldn_keyDisplayName", "ptr", ldn, "ptr", key, "ushort*", result, "int", maxResultSize, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {PSTR} key 
     * @param {PSTR} value 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} maxResultSize 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_keyValueDisplayName(ldn, key, value, result, maxResultSize, pErrorCode) {
        key := key is String ? StrPtr(key) : key
        value := value is String ? StrPtr(value) : value

        result := DllCall("icuuc.dll\uldn_keyValueDisplayName", "ptr", ldn, "ptr", key, "ptr", value, "ushort*", result, "int", maxResultSize, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} contexts 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<ULocaleDisplayNames>} 
     */
    static uldn_openForContext(locale, contexts, length, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\uldn_openForContext", "ptr", locale, "int*", contexts, "int", length, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleDisplayNames>} ldn 
     * @param {Integer} type 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uldn_getContext(ldn, type, pErrorCode) {
        result := DllCall("icuuc.dll\uldn_getContext", "ptr", ldn, "int", type, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} buff 
     * @param {Integer} buffCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_forLocale(locale, buff, buffCapacity, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ucurr_forLocale", "ptr", locale, "ushort*", buff, "int", buffCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} isoCode 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static ucurr_register(isoCode, locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ucurr_register", "ushort*", isoCode, "ptr", locale, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} key 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucurr_unregister(key, status) {
        result := DllCall("icuuc.dll\ucurr_unregister", "ptr", key, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {PSTR} locale 
     * @param {Integer} nameStyle 
     * @param {Pointer<SByte>} isChoiceFormat 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UInt16>} 
     */
    static ucurr_getName(currency, locale, nameStyle, isChoiceFormat, len, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ucurr_getName", "ushort*", currency, "ptr", locale, "int", nameStyle, "char*", isChoiceFormat, "int*", len, "int*", ec, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {PSTR} locale 
     * @param {Pointer<SByte>} isChoiceFormat 
     * @param {PSTR} pluralCount 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UInt16>} 
     */
    static ucurr_getPluralName(currency, locale, isChoiceFormat, pluralCount, len, ec) {
        locale := locale is String ? StrPtr(locale) : locale
        pluralCount := pluralCount is String ? StrPtr(pluralCount) : pluralCount

        result := DllCall("icuuc.dll\ucurr_getPluralName", "ushort*", currency, "ptr", locale, "char*", isChoiceFormat, "ptr", pluralCount, "int*", len, "int*", ec, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_getDefaultFractionDigits(currency, ec) {
        result := DllCall("icuuc.dll\ucurr_getDefaultFractionDigits", "ushort*", currency, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Integer} usage 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_getDefaultFractionDigitsForUsage(currency, usage, ec) {
        result := DllCall("icuuc.dll\ucurr_getDefaultFractionDigitsForUsage", "ushort*", currency, "int", usage, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<Int32>} ec 
     * @returns {Float} 
     */
    static ucurr_getRoundingIncrement(currency, ec) {
        result := DllCall("icuuc.dll\ucurr_getRoundingIncrement", "ushort*", currency, "int*", ec, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @param {Integer} usage 
     * @param {Pointer<Int32>} ec 
     * @returns {Float} 
     */
    static ucurr_getRoundingIncrementForUsage(currency, usage, ec) {
        result := DllCall("icuuc.dll\ucurr_getRoundingIncrementForUsage", "ushort*", currency, "int", usage, "int*", ec, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Integer} currType 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucurr_openISOCurrencies(currType, pErrorCode) {
        result := DllCall("icuuc.dll\ucurr_openISOCurrencies", "uint", currType, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} isoCode 
     * @param {Float} from 
     * @param {Float} to 
     * @param {Pointer<Int32>} errorCode 
     * @returns {Integer} 
     */
    static ucurr_isAvailable(isoCode, from, to, errorCode) {
        result := DllCall("icuuc.dll\ucurr_isAvailable", "ushort*", isoCode, "double", from, "double", to, "int*", errorCode, "CDecl char")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Float} date 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_countCurrencies(locale, date, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ucurr_countCurrencies", "ptr", locale, "double", date, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Float} date 
     * @param {Integer} index 
     * @param {Pointer<UInt16>} buff 
     * @param {Integer} buffCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucurr_forLocaleAndDate(locale, date, index, buff, buffCapacity, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ucurr_forLocaleAndDate", "ptr", locale, "double", date, "int", index, "ushort*", buff, "int", buffCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} key 
     * @param {PSTR} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucurr_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        key := key is String ? StrPtr(key) : key
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ucurr_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} currency 
     * @returns {Integer} 
     */
    static ucurr_getNumericCode(currency) {
        result := DllCall("icuuc.dll\ucurr_getNumericCode", "ushort*", currency, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPMap>} map 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucpmap_get(map, c) {
        result := DllCall("icu.dll\ucpmap_get", "ptr", map, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPMap>} map 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<UCPMapValueFilter>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UInt32>} pValue 
     * @returns {Integer} 
     */
    static ucpmap_getRange(map, start, option, surrogateValue, filter, context, pValue) {
        result := DllCall("icu.dll\ucpmap_getRange", "ptr", map, "int", start, "int", option, "uint", surrogateValue, "ptr", filter, "ptr", context, "uint*", pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Integer} valueWidth 
     * @param {Pointer<Void>} data 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pActualLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UCPTrie>} 
     */
    static ucptrie_openFromBinary(type, valueWidth, data, length, pActualLength, pErrorCode) {
        result := DllCall("icu.dll\ucptrie_openFromBinary", "int", type, "int", valueWidth, "ptr", data, "int", length, "int*", pActualLength, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucptrie_close(trie) {
        DllCall("icu.dll\ucptrie_close", "ptr", trie, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {Integer} 
     */
    static ucptrie_getType(trie) {
        result := DllCall("icu.dll\ucptrie_getType", "ptr", trie, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @returns {Integer} 
     */
    static ucptrie_getValueWidth(trie) {
        result := DllCall("icu.dll\ucptrie_getValueWidth", "ptr", trie, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucptrie_get(trie, c) {
        result := DllCall("icu.dll\ucptrie_get", "ptr", trie, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<UCPMapValueFilter>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UInt32>} pValue 
     * @returns {Integer} 
     */
    static ucptrie_getRange(trie, start, option, surrogateValue, filter, context, pValue) {
        result := DllCall("icu.dll\ucptrie_getRange", "ptr", trie, "int", start, "int", option, "uint", surrogateValue, "ptr", filter, "ptr", context, "uint*", pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Pointer<Void>} data 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucptrie_toBinary(trie, data, capacity, pErrorCode) {
        result := DllCall("icu.dll\ucptrie_toBinary", "ptr", trie, "ptr", data, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ucptrie_internalSmallIndex(trie, c) {
        result := DllCall("icu.dll\ucptrie_internalSmallIndex", "ptr", trie, "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} lt1 
     * @param {Integer} t2 
     * @param {Integer} t3 
     * @returns {Integer} 
     */
    static ucptrie_internalSmallU8Index(trie, lt1, t2, t3) {
        result := DllCall("icu.dll\ucptrie_internalSmallU8Index", "ptr", trie, "int", lt1, "char", t2, "char", t3, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Integer} c 
     * @param {Pointer<Byte>} start 
     * @param {Pointer<Byte>} src 
     * @returns {Integer} 
     */
    static ucptrie_internalU8PrevIndex(trie, c, start, src) {
        result := DllCall("icu.dll\ucptrie_internalU8PrevIndex", "ptr", trie, "int", c, "char*", start, "char*", src, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} initialValue 
     * @param {Integer} errorValue 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UMutableCPTrie>} 
     */
    static umutablecptrie_open(initialValue, errorValue, pErrorCode) {
        result := DllCall("icu.dll\umutablecptrie_open", "uint", initialValue, "uint", errorValue, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} other 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UMutableCPTrie>} 
     */
    static umutablecptrie_clone(other, pErrorCode) {
        result := DllCall("icu.dll\umutablecptrie_clone", "ptr", other, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_close(trie) {
        DllCall("icu.dll\umutablecptrie_close", "ptr", trie, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCPMap>} map 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UMutableCPTrie>} 
     */
    static umutablecptrie_fromUCPMap(map, pErrorCode) {
        result := DllCall("icu.dll\umutablecptrie_fromUCPMap", "ptr", map, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCPTrie>} trie 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UMutableCPTrie>} 
     */
    static umutablecptrie_fromUCPTrie(trie, pErrorCode) {
        result := DllCall("icu.dll\umutablecptrie_fromUCPTrie", "ptr", trie, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static umutablecptrie_get(trie, c) {
        result := DllCall("icu.dll\umutablecptrie_get", "ptr", trie, "int", c, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} start 
     * @param {Integer} option 
     * @param {Integer} surrogateValue 
     * @param {Pointer<UCPMapValueFilter>} filter 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UInt32>} pValue 
     * @returns {Integer} 
     */
    static umutablecptrie_getRange(trie, start, option, surrogateValue, filter, context, pValue) {
        result := DllCall("icu.dll\umutablecptrie_getRange", "ptr", trie, "int", start, "int", option, "uint", surrogateValue, "ptr", filter, "ptr", context, "uint*", pValue, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} c 
     * @param {Integer} value 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_set(trie, c, value, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_set", "ptr", trie, "int", c, "uint", value, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} start 
     * @param {Integer} end 
     * @param {Integer} value 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static umutablecptrie_setRange(trie, start, end, value, pErrorCode) {
        DllCall("icu.dll\umutablecptrie_setRange", "ptr", trie, "int", start, "int", end, "uint", value, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UMutableCPTrie>} trie 
     * @param {Integer} type 
     * @param {Integer} valueWidth 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UCPTrie>} 
     */
    static umutablecptrie_buildImmutable(trie, type, valueWidth, pErrorCode) {
        result := DllCall("icu.dll\umutablecptrie_buildImmutable", "ptr", trie, "int", type, "int", valueWidth, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<UInt16>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_STOP(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_STOP", "ptr", context, "ptr", fromUArgs, "ushort*", codeUnits, "int", length, "int", codePoint, "int", reason, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {PSTR} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_STOP(context, toUArgs, codeUnits, length, reason, err) {
        codeUnits := codeUnits is String ? StrPtr(codeUnits) : codeUnits

        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_STOP", "ptr", context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<UInt16>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_SKIP(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_SKIP", "ptr", context, "ptr", fromUArgs, "ushort*", codeUnits, "int", length, "int", codePoint, "int", reason, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<UInt16>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_SUBSTITUTE(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_SUBSTITUTE", "ptr", context, "ptr", fromUArgs, "ushort*", codeUnits, "int", length, "int", codePoint, "int", reason, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterFromUnicodeArgs>} fromUArgs 
     * @param {Pointer<UInt16>} codeUnits 
     * @param {Integer} length 
     * @param {Integer} codePoint 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_FROM_U_CALLBACK_ESCAPE(context, fromUArgs, codeUnits, length, codePoint, reason, err) {
        DllCall("icuuc.dll\UCNV_FROM_U_CALLBACK_ESCAPE", "ptr", context, "ptr", fromUArgs, "ushort*", codeUnits, "int", length, "int", codePoint, "int", reason, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {PSTR} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_SKIP(context, toUArgs, codeUnits, length, reason, err) {
        codeUnits := codeUnits is String ? StrPtr(codeUnits) : codeUnits

        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_SKIP", "ptr", context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {PSTR} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_SUBSTITUTE(context, toUArgs, codeUnits, length, reason, err) {
        codeUnits := codeUnits is String ? StrPtr(codeUnits) : codeUnits

        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_SUBSTITUTE", "ptr", context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UConverterToUnicodeArgs>} toUArgs 
     * @param {PSTR} codeUnits 
     * @param {Integer} length 
     * @param {Integer} reason 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static UCNV_TO_U_CALLBACK_ESCAPE(context, toUArgs, codeUnits, length, reason, err) {
        codeUnits := codeUnits is String ? StrPtr(codeUnits) : codeUnits

        DllCall("icuuc.dll\UCNV_TO_U_CALLBACK_ESCAPE", "ptr", context, "ptr", toUArgs, "ptr", codeUnits, "int", length, "int", reason, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} name1 
     * @param {PSTR} name2 
     * @returns {Integer} 
     */
    static ucnv_compareNames(name1, name2) {
        name1 := name1 is String ? StrPtr(name1) : name1
        name2 := name2 is String ? StrPtr(name2) : name2

        result := DllCall("icuuc.dll\ucnv_compareNames", "ptr", name1, "ptr", name2, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} converterName 
     * @param {Pointer<Int32>} err 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_open(converterName, err) {
        converterName := converterName is String ? StrPtr(converterName) : converterName

        result := DllCall("icuuc.dll\ucnv_open", "ptr", converterName, "int*", err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} name 
     * @param {Pointer<Int32>} err 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_openU(name, err) {
        result := DllCall("icuuc.dll\ucnv_openU", "ushort*", name, "int*", err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} codepage 
     * @param {Integer} platform 
     * @param {Pointer<Int32>} err 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_openCCSID(codepage, platform, err) {
        result := DllCall("icuuc.dll\ucnv_openCCSID", "int", codepage, "int", platform, "int*", err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {PSTR} converterName 
     * @param {Pointer<Int32>} err 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_openPackage(packageName, converterName, err) {
        packageName := packageName is String ? StrPtr(packageName) : packageName
        converterName := converterName is String ? StrPtr(converterName) : converterName

        result := DllCall("icuuc.dll\ucnv_openPackage", "ptr", packageName, "ptr", converterName, "int*", err, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Int32>} pBufferSize 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_safeClone(cnv, stackBuffer, pBufferSize, status) {
        result := DllCall("icuuc.dll\ucnv_safeClone", "ptr", cnv, "ptr", stackBuffer, "int*", pBufferSize, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UConverter>} 
     */
    static ucnv_clone(cnv, status) {
        result := DllCall("icu.dll\ucnv_clone", "ptr", cnv, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_close(converter) {
        DllCall("icuuc.dll\ucnv_close", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {PSTR} subChars 
     * @param {Pointer<SByte>} len 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getSubstChars(converter, subChars, len, err) {
        subChars := subChars is String ? StrPtr(subChars) : subChars

        DllCall("icuuc.dll\ucnv_getSubstChars", "ptr", converter, "ptr", subChars, "char*", len, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {PSTR} subChars 
     * @param {Integer} len 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setSubstChars(converter, subChars, len, err) {
        subChars := subChars is String ? StrPtr(subChars) : subChars

        DllCall("icuuc.dll\ucnv_setSubstChars", "ptr", converter, "ptr", subChars, "char", len, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setSubstString(cnv, s, length, err) {
        DllCall("icuuc.dll\ucnv_setSubstString", "ptr", cnv, "ushort*", s, "int", length, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {PSTR} errBytes 
     * @param {Pointer<SByte>} len 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getInvalidChars(converter, errBytes, len, err) {
        errBytes := errBytes is String ? StrPtr(errBytes) : errBytes

        DllCall("icuuc.dll\ucnv_getInvalidChars", "ptr", converter, "ptr", errBytes, "char*", len, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<UInt16>} errUChars 
     * @param {Pointer<SByte>} len 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getInvalidUChars(converter, errUChars, len, err) {
        DllCall("icuuc.dll\ucnv_getInvalidUChars", "ptr", converter, "ushort*", errUChars, "char*", len, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_reset(converter) {
        DllCall("icuuc.dll\ucnv_reset", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_resetToUnicode(converter) {
        DllCall("icuuc.dll\ucnv_resetToUnicode", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_resetFromUnicode(converter) {
        DllCall("icuuc.dll\ucnv_resetFromUnicode", "ptr", converter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {Integer} 
     */
    static ucnv_getMaxCharSize(converter) {
        result := DllCall("icuuc.dll\ucnv_getMaxCharSize", "ptr", converter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {Integer} 
     */
    static ucnv_getMinCharSize(converter) {
        result := DllCall("icuuc.dll\ucnv_getMinCharSize", "ptr", converter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {PSTR} displayLocale 
     * @param {Pointer<UInt16>} displayName 
     * @param {Integer} displayNameCapacity 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static ucnv_getDisplayName(converter, displayLocale, displayName, displayNameCapacity, err) {
        displayLocale := displayLocale is String ? StrPtr(displayLocale) : displayLocale

        result := DllCall("icuuc.dll\ucnv_getDisplayName", "ptr", converter, "ptr", displayLocale, "ushort*", displayName, "int", displayNameCapacity, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Int32>} err 
     * @returns {PSTR} 
     */
    static ucnv_getName(converter, err) {
        result := DllCall("icuuc.dll\ucnv_getName", "ptr", converter, "int*", err, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static ucnv_getCCSID(converter, err) {
        result := DllCall("icuuc.dll\ucnv_getCCSID", "ptr", converter, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static ucnv_getPlatform(converter, err) {
        result := DllCall("icuuc.dll\ucnv_getPlatform", "ptr", converter, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @returns {Integer} 
     */
    static ucnv_getType(converter) {
        result := DllCall("icuuc.dll\ucnv_getType", "ptr", converter, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<SByte>} starters 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getStarters(converter, starters, err) {
        DllCall("icuuc.dll\ucnv_getStarters", "ptr", converter, "char*", starters, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<USet>} setFillIn 
     * @param {Integer} whichSet 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getUnicodeSet(cnv, setFillIn, whichSet, pErrorCode) {
        DllCall("icuuc.dll\ucnv_getUnicodeSet", "ptr", cnv, "ptr", setFillIn, "int", whichSet, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<UConverterToUCallback>} action 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getToUCallBack(converter, action, context) {
        DllCall("icuuc.dll\ucnv_getToUCallBack", "ptr", converter, "ptr", action, "ptr", context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<UConverterFromUCallback>} action 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getFromUCallBack(converter, action, context) {
        DllCall("icuuc.dll\ucnv_getFromUCallBack", "ptr", converter, "ptr", action, "ptr", context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<UConverterToUCallback>} newAction 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<UConverterToUCallback>} oldAction 
     * @param {Pointer<Void>} oldContext 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setToUCallBack(converter, newAction, newContext, oldAction, oldContext, err) {
        DllCall("icuuc.dll\ucnv_setToUCallBack", "ptr", converter, "ptr", newAction, "ptr", newContext, "ptr", oldAction, "ptr", oldContext, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<UConverterFromUCallback>} newAction 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<UConverterFromUCallback>} oldAction 
     * @param {Pointer<Void>} oldContext 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setFromUCallBack(converter, newAction, newContext, oldAction, oldContext, err) {
        DllCall("icuuc.dll\ucnv_setFromUCallBack", "ptr", converter, "ptr", newAction, "ptr", newContext, "ptr", oldAction, "ptr", oldContext, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<SByte>} target 
     * @param {PSTR} targetLimit 
     * @param {Pointer<UInt16>} source 
     * @param {Pointer<UInt16>} sourceLimit 
     * @param {Pointer<Int32>} offsets 
     * @param {Integer} flush 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_fromUnicode(converter, target, targetLimit, source, sourceLimit, offsets, flush, err) {
        targetLimit := targetLimit is String ? StrPtr(targetLimit) : targetLimit

        DllCall("icuuc.dll\ucnv_fromUnicode", "ptr", converter, "char*", target, "ptr", targetLimit, "ushort*", source, "ushort*", sourceLimit, "int*", offsets, "char", flush, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<UInt16>} target 
     * @param {Pointer<UInt16>} targetLimit 
     * @param {Pointer<SByte>} source 
     * @param {PSTR} sourceLimit 
     * @param {Pointer<Int32>} offsets 
     * @param {Integer} flush 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_toUnicode(converter, target, targetLimit, source, sourceLimit, offsets, flush, err) {
        sourceLimit := sourceLimit is String ? StrPtr(sourceLimit) : sourceLimit

        DllCall("icuuc.dll\ucnv_toUnicode", "ptr", converter, "ushort*", target, "ushort*", targetLimit, "char*", source, "ptr", sourceLimit, "int*", offsets, "char", flush, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_fromUChars(cnv, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\ucnv_fromUChars", "ptr", cnv, "ptr", dest, "int", destCapacity, "ushort*", src, "int", srcLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_toUChars(cnv, dest, destCapacity, src, srcLength, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\ucnv_toUChars", "ptr", cnv, "ushort*", dest, "int", destCapacity, "ptr", src, "int", srcLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} converter 
     * @param {Pointer<SByte>} source 
     * @param {PSTR} sourceLimit 
     * @param {Pointer<Int32>} err 
     * @returns {Integer} 
     */
    static ucnv_getNextUChar(converter, source, sourceLimit, err) {
        sourceLimit := sourceLimit is String ? StrPtr(sourceLimit) : sourceLimit

        result := DllCall("icuuc.dll\ucnv_getNextUChar", "ptr", converter, "char*", source, "ptr", sourceLimit, "int*", err, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} targetCnv 
     * @param {Pointer<UConverter>} sourceCnv 
     * @param {Pointer<SByte>} target 
     * @param {PSTR} targetLimit 
     * @param {Pointer<SByte>} source 
     * @param {PSTR} sourceLimit 
     * @param {Pointer<UInt16>} pivotStart 
     * @param {Pointer<UInt16>} pivotSource 
     * @param {Pointer<UInt16>} pivotTarget 
     * @param {Pointer<UInt16>} pivotLimit 
     * @param {Integer} reset 
     * @param {Integer} flush 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_convertEx(targetCnv, sourceCnv, target, targetLimit, source, sourceLimit, pivotStart, pivotSource, pivotTarget, pivotLimit, reset, flush, pErrorCode) {
        targetLimit := targetLimit is String ? StrPtr(targetLimit) : targetLimit
        sourceLimit := sourceLimit is String ? StrPtr(sourceLimit) : sourceLimit

        DllCall("icuuc.dll\ucnv_convertEx", "ptr", targetCnv, "ptr", sourceCnv, "char*", target, "ptr", targetLimit, "char*", source, "ptr", sourceLimit, "ushort*", pivotStart, "ushort*", pivotSource, "ushort*", pivotTarget, "ushort*", pivotLimit, "char", reset, "char", flush, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} toConverterName 
     * @param {PSTR} fromConverterName 
     * @param {PSTR} target 
     * @param {Integer} targetCapacity 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_convert(toConverterName, fromConverterName, target, targetCapacity, source, sourceLength, pErrorCode) {
        toConverterName := toConverterName is String ? StrPtr(toConverterName) : toConverterName
        fromConverterName := fromConverterName is String ? StrPtr(fromConverterName) : fromConverterName
        target := target is String ? StrPtr(target) : target
        source := source is String ? StrPtr(source) : source

        result := DllCall("icuuc.dll\ucnv_convert", "ptr", toConverterName, "ptr", fromConverterName, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} algorithmicType 
     * @param {Pointer<UConverter>} cnv 
     * @param {PSTR} target 
     * @param {Integer} targetCapacity 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_toAlgorithmic(algorithmicType, cnv, target, targetCapacity, source, sourceLength, pErrorCode) {
        target := target is String ? StrPtr(target) : target
        source := source is String ? StrPtr(source) : source

        result := DllCall("icuuc.dll\ucnv_toAlgorithmic", "int", algorithmicType, "ptr", cnv, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Integer} algorithmicType 
     * @param {PSTR} target 
     * @param {Integer} targetCapacity 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_fromAlgorithmic(cnv, algorithmicType, target, targetCapacity, source, sourceLength, pErrorCode) {
        target := target is String ? StrPtr(target) : target
        source := source is String ? StrPtr(source) : source

        result := DllCall("icuuc.dll\ucnv_fromAlgorithmic", "ptr", cnv, "int", algorithmicType, "ptr", target, "int", targetCapacity, "ptr", source, "int", sourceLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_flushCache() {
        result := DllCall("icuuc.dll\ucnv_flushCache", "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_countAvailable() {
        result := DllCall("icuuc.dll\ucnv_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @returns {PSTR} 
     */
    static ucnv_getAvailableName(n) {
        result := DllCall("icuuc.dll\ucnv_getAvailableName", "int", n, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucnv_openAllNames(pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_openAllNames", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucnv_countAliases(alias, pErrorCode) {
        alias := alias is String ? StrPtr(alias) : alias

        result := DllCall("icuuc.dll\ucnv_countAliases", "ptr", alias, "int*", pErrorCode, "CDecl ushort")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @param {Integer} n 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_getAlias(alias, n, pErrorCode) {
        alias := alias is String ? StrPtr(alias) : alias

        result := DllCall("icuuc.dll\ucnv_getAlias", "ptr", alias, "ushort", n, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @param {Pointer<SByte>} aliases 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_getAliases(alias, aliases, pErrorCode) {
        alias := alias is String ? StrPtr(alias) : alias

        DllCall("icuuc.dll\ucnv_getAliases", "ptr", alias, "char*", aliases, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} convName 
     * @param {PSTR} standard 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucnv_openStandardNames(convName, standard, pErrorCode) {
        convName := convName is String ? StrPtr(convName) : convName
        standard := standard is String ? StrPtr(standard) : standard

        result := DllCall("icuuc.dll\ucnv_openStandardNames", "ptr", convName, "ptr", standard, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucnv_countStandards() {
        result := DllCall("icuuc.dll\ucnv_countStandards", "CDecl ushort")
        return result
    }

    /**
     * 
     * @param {Integer} n 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_getStandard(n, pErrorCode) {
        result := DllCall("icuuc.dll\ucnv_getStandard", "ushort", n, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} name 
     * @param {PSTR} standard 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_getStandardName(name, standard, pErrorCode) {
        name := name is String ? StrPtr(name) : name
        standard := standard is String ? StrPtr(standard) : standard

        result := DllCall("icuuc.dll\ucnv_getStandardName", "ptr", name, "ptr", standard, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @param {PSTR} standard 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_getCanonicalName(alias, standard, pErrorCode) {
        alias := alias is String ? StrPtr(alias) : alias
        standard := standard is String ? StrPtr(standard) : standard

        result := DllCall("icuuc.dll\ucnv_getCanonicalName", "ptr", alias, "ptr", standard, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @returns {PSTR} 
     */
    static ucnv_getDefaultName() {
        result := DllCall("icuuc.dll\ucnv_getDefaultName", "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} name 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setDefaultName(name) {
        name := name is String ? StrPtr(name) : name

        DllCall("icuuc.dll\ucnv_setDefaultName", "ptr", name, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_fixFileSeparator(cnv, source, sourceLen) {
        DllCall("icuuc.dll\ucnv_fixFileSeparator", "ptr", cnv, "ushort*", source, "int", sourceLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @returns {Integer} 
     */
    static ucnv_isAmbiguous(cnv) {
        result := DllCall("icuuc.dll\ucnv_isAmbiguous", "ptr", cnv, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Integer} usesFallback 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_setFallback(cnv, usesFallback) {
        DllCall("icuuc.dll\ucnv_setFallback", "ptr", cnv, "char", usesFallback, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @returns {Integer} 
     */
    static ucnv_usesFallback(cnv) {
        result := DllCall("icuuc.dll\ucnv_usesFallback", "ptr", cnv, "CDecl char")
        return result
    }

    /**
     * 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} signatureLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PSTR} 
     */
    static ucnv_detectUnicodeSignature(source, sourceLength, signatureLength, pErrorCode) {
        source := source is String ? StrPtr(source) : source

        result := DllCall("icuuc.dll\ucnv_detectUnicodeSignature", "ptr", source, "int", sourceLength, "int*", signatureLength, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucnv_fromUCountPending(cnv, status) {
        result := DllCall("icuuc.dll\ucnv_fromUCountPending", "ptr", cnv, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucnv_toUCountPending(cnv, status) {
        result := DllCall("icuuc.dll\ucnv_toUCountPending", "ptr", cnv, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverter>} cnv 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucnv_isFixedWidth(cnv, status) {
        result := DllCall("icuuc.dll\ucnv_isFixedWidth", "ptr", cnv, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {PSTR} source 
     * @param {Integer} length 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteBytes(args, source, length, offsetIndex, err) {
        source := source is String ? StrPtr(source) : source

        DllCall("icuuc.dll\ucnv_cbFromUWriteBytes", "ptr", args, "ptr", source, "int", length, "int", offsetIndex, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteSub(args, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbFromUWriteSub", "ptr", args, "int", offsetIndex, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterFromUnicodeArgs>} args 
     * @param {Pointer<UInt16>} source 
     * @param {Pointer<UInt16>} sourceLimit 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbFromUWriteUChars(args, source, sourceLimit, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbFromUWriteUChars", "ptr", args, "ushort*", source, "ushort*", sourceLimit, "int", offsetIndex, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterToUnicodeArgs>} args 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} length 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbToUWriteUChars(args, source, length, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbToUWriteUChars", "ptr", args, "ushort*", source, "int", length, "int", offsetIndex, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConverterToUnicodeArgs>} args 
     * @param {Integer} offsetIndex 
     * @param {Pointer<Int32>} err 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnv_cbToUWriteSub(args, offsetIndex, err) {
        DllCall("icuuc.dll\ucnv_cbToUWriteSub", "ptr", args, "int", offsetIndex, "int*", err, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_init(status) {
        DllCall("icuuc.dll\u_init", "int*", status, "CDecl ")
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_cleanup() {
        DllCall("icuuc.dll\u_cleanup", "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} context 
     * @param {Pointer<UMemAllocFn>} a 
     * @param {Pointer<UMemReallocFn>} r 
     * @param {Pointer<UMemFreeFn>} f 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_setMemoryFunctions(context, a, r, f, status) {
        DllCall("icuuc.dll\u_setMemoryFunctions", "ptr", context, "ptr", a, "ptr", r, "ptr", f, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} name 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UResourceBundle>} 
     */
    static u_catopen(name, locale, ec) {
        name := name is String ? StrPtr(name) : name
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\u_catopen", "ptr", name, "ptr", locale, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} catd 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_catclose(catd) {
        DllCall("icuuc.dll\u_catclose", "ptr", catd, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UResourceBundle>} catd 
     * @param {Integer} set_num 
     * @param {Integer} msg_num 
     * @param {Pointer<UInt16>} s 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UInt16>} 
     */
    static u_catgets(catd, set_num, msg_num, s, len, ec) {
        result := DllCall("icuuc.dll\u_catgets", "ptr", catd, "int", set_num, "int", msg_num, "ushort*", s, "int*", len, "int*", ec, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_hasBinaryProperty(c, which) {
        result := DllCall("icuuc.dll\u_hasBinaryProperty", "int", c, "int", which, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_stringHasBinaryProperty(s, length, which) {
        result := DllCall("icu.dll\u_stringHasBinaryProperty", "ushort*", s, "int", length, "int", which, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<USet>} 
     */
    static u_getBinaryPropertySet(property, pErrorCode) {
        result := DllCall("icu.dll\u_getBinaryPropertySet", "int", property, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUAlphabetic(c) {
        result := DllCall("icuuc.dll\u_isUAlphabetic", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isULowercase(c) {
        result := DllCall("icuuc.dll\u_isULowercase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUUppercase(c) {
        result := DllCall("icuuc.dll\u_isUUppercase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isUWhiteSpace(c) {
        result := DllCall("icuuc.dll\u_isUWhiteSpace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyValue(c, which) {
        result := DllCall("icuuc.dll\u_getIntPropertyValue", "int", c, "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyMinValue(which) {
        result := DllCall("icuuc.dll\u_getIntPropertyMinValue", "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} which 
     * @returns {Integer} 
     */
    static u_getIntPropertyMaxValue(which) {
        result := DllCall("icuuc.dll\u_getIntPropertyMaxValue", "int", which, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UCPMap>} 
     */
    static u_getIntPropertyMap(property, pErrorCode) {
        result := DllCall("icu.dll\u_getIntPropertyMap", "int", property, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Float} 
     */
    static u_getNumericValue(c) {
        result := DllCall("icuuc.dll\u_getNumericValue", "int", c, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_islower(c) {
        result := DllCall("icuuc.dll\u_islower", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isupper(c) {
        result := DllCall("icuuc.dll\u_isupper", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_istitle(c) {
        result := DllCall("icuuc.dll\u_istitle", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isdigit(c) {
        result := DllCall("icuuc.dll\u_isdigit", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isalpha(c) {
        result := DllCall("icuuc.dll\u_isalpha", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isalnum(c) {
        result := DllCall("icuuc.dll\u_isalnum", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isxdigit(c) {
        result := DllCall("icuuc.dll\u_isxdigit", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_ispunct(c) {
        result := DllCall("icuuc.dll\u_ispunct", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isgraph(c) {
        result := DllCall("icuuc.dll\u_isgraph", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isblank(c) {
        result := DllCall("icuuc.dll\u_isblank", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isdefined(c) {
        result := DllCall("icuuc.dll\u_isdefined", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isspace(c) {
        result := DllCall("icuuc.dll\u_isspace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaSpaceChar(c) {
        result := DllCall("icuuc.dll\u_isJavaSpaceChar", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isWhitespace(c) {
        result := DllCall("icuuc.dll\u_isWhitespace", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_iscntrl(c) {
        result := DllCall("icuuc.dll\u_iscntrl", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isISOControl(c) {
        result := DllCall("icuuc.dll\u_isISOControl", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isprint(c) {
        result := DllCall("icuuc.dll\u_isprint", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isbase(c) {
        result := DllCall("icuuc.dll\u_isbase", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charDirection(c) {
        result := DllCall("icuuc.dll\u_charDirection", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isMirrored(c) {
        result := DllCall("icuuc.dll\u_isMirrored", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charMirror(c) {
        result := DllCall("icuuc.dll\u_charMirror", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_getBidiPairedBracket(c) {
        result := DllCall("icuuc.dll\u_getBidiPairedBracket", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charType(c) {
        result := DllCall("icuuc.dll\u_charType", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharEnumTypeRange>} enumRange 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_enumCharTypes(enumRange, context) {
        DllCall("icuuc.dll\u_enumCharTypes", "ptr", enumRange, "ptr", context, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_getCombiningClass(c) {
        result := DllCall("icuuc.dll\u_getCombiningClass", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_charDigitValue(c) {
        result := DllCall("icuuc.dll\u_charDigitValue", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ublock_getCode(c) {
        result := DllCall("icuuc.dll\ublock_getCode", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} code 
     * @param {Integer} nameChoice 
     * @param {PSTR} buffer 
     * @param {Integer} bufferLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_charName(code, nameChoice, buffer, bufferLength, pErrorCode) {
        buffer := buffer is String ? StrPtr(buffer) : buffer

        result := DllCall("icuuc.dll\u_charName", "int", code, "int", nameChoice, "ptr", buffer, "int", bufferLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} nameChoice 
     * @param {PSTR} name 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_charFromName(nameChoice, name, pErrorCode) {
        name := name is String ? StrPtr(name) : name

        result := DllCall("icuuc.dll\u_charFromName", "int", nameChoice, "ptr", name, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<UEnumCharNamesFn>} fn 
     * @param {Pointer<Void>} context 
     * @param {Integer} nameChoice 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_enumCharNames(start, limit, fn, context, nameChoice, pErrorCode) {
        DllCall("icuuc.dll\u_enumCharNames", "int", start, "int", limit, "ptr", fn, "ptr", context, "int", nameChoice, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Integer} nameChoice 
     * @returns {PSTR} 
     */
    static u_getPropertyName(property, nameChoice) {
        result := DllCall("icuuc.dll\u_getPropertyName", "int", property, "int", nameChoice, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} alias 
     * @returns {Integer} 
     */
    static u_getPropertyEnum(alias) {
        alias := alias is String ? StrPtr(alias) : alias

        result := DllCall("icuuc.dll\u_getPropertyEnum", "ptr", alias, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {Integer} value 
     * @param {Integer} nameChoice 
     * @returns {PSTR} 
     */
    static u_getPropertyValueName(property, value, nameChoice) {
        result := DllCall("icuuc.dll\u_getPropertyValueName", "int", property, "int", value, "int", nameChoice, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Integer} property 
     * @param {PSTR} alias 
     * @returns {Integer} 
     */
    static u_getPropertyValueEnum(property, alias) {
        alias := alias is String ? StrPtr(alias) : alias

        result := DllCall("icuuc.dll\u_getPropertyValueEnum", "int", property, "ptr", alias, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDStart(c) {
        result := DllCall("icuuc.dll\u_isIDStart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDPart(c) {
        result := DllCall("icuuc.dll\u_isIDPart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isIDIgnorable(c) {
        result := DllCall("icuuc.dll\u_isIDIgnorable", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaIDStart(c) {
        result := DllCall("icuuc.dll\u_isJavaIDStart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_isJavaIDPart(c) {
        result := DllCall("icuuc.dll\u_isJavaIDPart", "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_tolower(c) {
        result := DllCall("icuuc.dll\u_tolower", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_toupper(c) {
        result := DllCall("icuuc.dll\u_toupper", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static u_totitle(c) {
        result := DllCall("icuuc.dll\u_totitle", "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_foldCase(c, options) {
        result := DllCall("icuuc.dll\u_foldCase", "int", c, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} ch 
     * @param {Integer} radix 
     * @returns {Integer} 
     */
    static u_digit(ch, radix) {
        result := DllCall("icuuc.dll\u_digit", "int", ch, "char", radix, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} digit 
     * @param {Integer} radix 
     * @returns {Integer} 
     */
    static u_forDigit(digit, radix) {
        result := DllCall("icuuc.dll\u_forDigit", "int", digit, "char", radix, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<Byte>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_charAge(c, versionArray) {
        DllCall("icuuc.dll\u_charAge", "int", c, "char*", versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getUnicodeVersion(versionArray) {
        DllCall("icuuc.dll\u_getUnicodeVersion", "char*", versionArray, "CDecl ")
    }

    /**
     * 
     * @param {Integer} c 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_getFC_NFKC_Closure(c, dest, destCapacity, pErrorCode) {
        result := DllCall("icuuc.dll\u_getFC_NFKC_Closure", "int", c, "ushort*", dest, "int", destCapacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Pointer<UBiDi>} 
     */
    static ubidi_open() {
        result := DllCall("icuuc.dll\ubidi_open", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} maxLength 
     * @param {Integer} maxRunCount 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UBiDi>} 
     */
    static ubidi_openSized(maxLength, maxRunCount, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_openSized", "int", maxLength, "int", maxRunCount, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_close(pBiDi) {
        DllCall("icuuc.dll\ubidi_close", "ptr", pBiDi, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} isInverse 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setInverse(pBiDi, isInverse) {
        DllCall("icuuc.dll\ubidi_setInverse", "ptr", pBiDi, "char", isInverse, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_isInverse(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_isInverse", "ptr", pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} orderParagraphsLTR 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_orderParagraphsLTR(pBiDi, orderParagraphsLTR) {
        DllCall("icuuc.dll\ubidi_orderParagraphsLTR", "ptr", pBiDi, "char", orderParagraphsLTR, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_isOrderParagraphsLTR(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_isOrderParagraphsLTR", "ptr", pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} reorderingMode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setReorderingMode(pBiDi, reorderingMode) {
        DllCall("icuuc.dll\ubidi_setReorderingMode", "ptr", pBiDi, "int", reorderingMode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getReorderingMode(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getReorderingMode", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} reorderingOptions 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setReorderingOptions(pBiDi, reorderingOptions) {
        DllCall("icuuc.dll\ubidi_setReorderingOptions", "ptr", pBiDi, "uint", reorderingOptions, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getReorderingOptions(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getReorderingOptions", "ptr", pBiDi, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<UInt16>} prologue 
     * @param {Integer} proLength 
     * @param {Pointer<UInt16>} epilogue 
     * @param {Integer} epiLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setContext(pBiDi, prologue, proLength, epilogue, epiLength, pErrorCode) {
        DllCall("icuuc.dll\ubidi_setContext", "ptr", pBiDi, "ushort*", prologue, "int", proLength, "ushort*", epilogue, "int", epiLength, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} length 
     * @param {Integer} paraLevel 
     * @param {Pointer<Byte>} embeddingLevels 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setPara(pBiDi, text, length, paraLevel, embeddingLevels, pErrorCode) {
        DllCall("icuuc.dll\ubidi_setPara", "ptr", pBiDi, "ushort*", text, "int", length, "char", paraLevel, "char*", embeddingLevels, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pParaBiDi 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<UBiDi>} pLineBiDi 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setLine(pParaBiDi, start, limit, pLineBiDi, pErrorCode) {
        DllCall("icuuc.dll\ubidi_setLine", "ptr", pParaBiDi, "int", start, "int", limit, "ptr", pLineBiDi, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getDirection(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getDirection", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} length 
     * @returns {Integer} 
     */
    static ubidi_getBaseDirection(text, length) {
        result := DllCall("icuuc.dll\ubidi_getBaseDirection", "ushort*", text, "int", length, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Pointer<UInt16>} 
     */
    static ubidi_getText(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getText", "ptr", pBiDi, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getLength(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getLength", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getParaLevel(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getParaLevel", "ptr", pBiDi, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_countParagraphs(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_countParagraphs", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} charIndex 
     * @param {Pointer<Int32>} pParaStart 
     * @param {Pointer<Int32>} pParaLimit 
     * @param {Pointer<Byte>} pParaLevel 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getParagraph(pBiDi, charIndex, pParaStart, pParaLimit, pParaLevel, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_getParagraph", "ptr", pBiDi, "int", charIndex, "int*", pParaStart, "int*", pParaLimit, "char*", pParaLevel, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} paraIndex 
     * @param {Pointer<Int32>} pParaStart 
     * @param {Pointer<Int32>} pParaLimit 
     * @param {Pointer<Byte>} pParaLevel 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getParagraphByIndex(pBiDi, paraIndex, pParaStart, pParaLimit, pParaLevel, pErrorCode) {
        DllCall("icuuc.dll\ubidi_getParagraphByIndex", "ptr", pBiDi, "int", paraIndex, "int*", pParaStart, "int*", pParaLimit, "char*", pParaLevel, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} charIndex 
     * @returns {Integer} 
     */
    static ubidi_getLevelAt(pBiDi, charIndex) {
        result := DllCall("icuuc.dll\ubidi_getLevelAt", "ptr", pBiDi, "int", charIndex, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Byte>} 
     */
    static ubidi_getLevels(pBiDi, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_getLevels", "ptr", pBiDi, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} logicalPosition 
     * @param {Pointer<Int32>} pLogicalLimit 
     * @param {Pointer<Byte>} pLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getLogicalRun(pBiDi, logicalPosition, pLogicalLimit, pLevel) {
        DllCall("icuuc.dll\ubidi_getLogicalRun", "ptr", pBiDi, "int", logicalPosition, "int*", pLogicalLimit, "char*", pLevel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_countRuns(pBiDi, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_countRuns", "ptr", pBiDi, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} runIndex 
     * @param {Pointer<Int32>} pLogicalStart 
     * @param {Pointer<Int32>} pLength 
     * @returns {Integer} 
     */
    static ubidi_getVisualRun(pBiDi, runIndex, pLogicalStart, pLength) {
        result := DllCall("icuuc.dll\ubidi_getVisualRun", "ptr", pBiDi, "int", runIndex, "int*", pLogicalStart, "int*", pLength, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} logicalIndex 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getVisualIndex(pBiDi, logicalIndex, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_getVisualIndex", "ptr", pBiDi, "int", logicalIndex, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} visualIndex 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_getLogicalIndex(pBiDi, visualIndex, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_getLogicalIndex", "ptr", pBiDi, "int", visualIndex, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Int32>} indexMap 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getLogicalMap(pBiDi, indexMap, pErrorCode) {
        DllCall("icuuc.dll\ubidi_getLogicalMap", "ptr", pBiDi, "int*", indexMap, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<Int32>} indexMap 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getVisualMap(pBiDi, indexMap, pErrorCode) {
        DllCall("icuuc.dll\ubidi_getVisualMap", "ptr", pBiDi, "int*", indexMap, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} levels 
     * @param {Integer} length 
     * @param {Pointer<Int32>} indexMap 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_reorderLogical(levels, length, indexMap) {
        DllCall("icuuc.dll\ubidi_reorderLogical", "char*", levels, "int", length, "int*", indexMap, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} levels 
     * @param {Integer} length 
     * @param {Pointer<Int32>} indexMap 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_reorderVisual(levels, length, indexMap) {
        DllCall("icuuc.dll\ubidi_reorderVisual", "char*", levels, "int", length, "int*", indexMap, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} srcMap 
     * @param {Pointer<Int32>} destMap 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_invertMap(srcMap, destMap, length) {
        DllCall("icuuc.dll\ubidi_invertMap", "int*", srcMap, "int*", destMap, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getProcessedLength(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getProcessedLength", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @returns {Integer} 
     */
    static ubidi_getResultLength(pBiDi) {
        result := DllCall("icuuc.dll\ubidi_getResultLength", "ptr", pBiDi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static ubidi_getCustomizedClass(pBiDi, c) {
        result := DllCall("icuuc.dll\ubidi_getCustomizedClass", "ptr", pBiDi, "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<UBiDiClassCallback>} newFn 
     * @param {Pointer<Void>} newContext 
     * @param {Pointer<UBiDiClassCallback>} oldFn 
     * @param {Pointer<Void>} oldContext 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_setClassCallback(pBiDi, newFn, newContext, oldFn, oldContext, pErrorCode) {
        DllCall("icuuc.dll\ubidi_setClassCallback", "ptr", pBiDi, "ptr", newFn, "ptr", newContext, "ptr", oldFn, "ptr", oldContext, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<UBiDiClassCallback>} fn 
     * @param {Pointer<Void>} context 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubidi_getClassCallback(pBiDi, fn, context) {
        DllCall("icuuc.dll\ubidi_getClassCallback", "ptr", pBiDi, "ptr", fn, "ptr", context, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBiDi>} pBiDi 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_writeReordered(pBiDi, dest, destSize, options, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_writeReordered", "ptr", pBiDi, "ushort*", dest, "int", destSize, "ushort", options, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destSize 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubidi_writeReverse(src, srcLength, dest, destSize, options, pErrorCode) {
        result := DllCall("icuuc.dll\ubidi_writeReverse", "ushort*", src, "int", srcLength, "ushort*", dest, "int", destSize, "ushort", options, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDiTransform>} pBiDiTransform 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destSize 
     * @param {Integer} inParaLevel 
     * @param {Integer} inOrder 
     * @param {Integer} outParaLevel 
     * @param {Integer} outOrder 
     * @param {Integer} doMirroring 
     * @param {Integer} shapingOptions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ubiditransform_transform(pBiDiTransform, src, srcLength, dest, destSize, inParaLevel, inOrder, outParaLevel, outOrder, doMirroring, shapingOptions, pErrorCode) {
        result := DllCall("icuuc.dll\ubiditransform_transform", "ptr", pBiDiTransform, "ushort*", src, "int", srcLength, "ushort*", dest, "int", destSize, "char", inParaLevel, "int", inOrder, "char", outParaLevel, "int", outOrder, "int", doMirroring, "uint", shapingOptions, "int*", pErrorCode, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UBiDiTransform>} 
     */
    static ubiditransform_open(pErrorCode) {
        result := DllCall("icuuc.dll\ubiditransform_open", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBiDiTransform>} pBidiTransform 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubiditransform_close(pBidiTransform) {
        DllCall("icuuc.dll\ubiditransform_close", "ptr", pBidiTransform, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Pointer<UText>} 
     */
    static utext_close(ut) {
        result := DllCall("icuuc.dll\utext_close", "ptr", ut, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static utext_openUTF8(ut, s, length, status) {
        s := s is String ? StrPtr(s) : s

        result := DllCall("icuuc.dll\utext_openUTF8", "ptr", ut, "ptr", s, "int64", length, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static utext_openUChars(ut, s, length, status) {
        result := DllCall("icuuc.dll\utext_openUChars", "ptr", ut, "ushort*", s, "int64", length, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<UText>} src 
     * @param {Integer} deep 
     * @param {Integer} readOnly 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static utext_clone(dest, src, deep, readOnly, status) {
        result := DllCall("icuuc.dll\utext_clone", "ptr", dest, "ptr", src, "char", deep, "char", readOnly, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} a 
     * @param {Pointer<UText>} b 
     * @returns {Integer} 
     */
    static utext_equals(a, b) {
        result := DllCall("icuuc.dll\utext_equals", "ptr", a, "ptr", b, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_nativeLength(ut) {
        result := DllCall("icuuc.dll\utext_nativeLength", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_isLengthExpensive(ut) {
        result := DllCall("icuuc.dll\utext_isLengthExpensive", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_char32At(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_char32At", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_current32(ut) {
        result := DllCall("icuuc.dll\utext_current32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_next32(ut) {
        result := DllCall("icuuc.dll\utext_next32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_previous32(ut) {
        result := DllCall("icuuc.dll\utext_previous32", "ptr", ut, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_next32From(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_next32From", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {Integer} 
     */
    static utext_previous32From(ut, nativeIndex) {
        result := DllCall("icuuc.dll\utext_previous32From", "ptr", ut, "int64", nativeIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_getNativeIndex(ut) {
        result := DllCall("icuuc.dll\utext_getNativeIndex", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeIndex 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_setNativeIndex(ut, nativeIndex) {
        DllCall("icuuc.dll\utext_setNativeIndex", "ptr", ut, "int64", nativeIndex, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} delta 
     * @returns {Integer} 
     */
    static utext_moveIndex32(ut, delta) {
        result := DllCall("icuuc.dll\utext_moveIndex32", "ptr", ut, "int", delta, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_getPreviousNativeIndex(ut) {
        result := DllCall("icuuc.dll\utext_getPreviousNativeIndex", "ptr", ut, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utext_extract(ut, nativeStart, nativeLimit, dest, destCapacity, status) {
        result := DllCall("icuuc.dll\utext_extract", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, "ushort*", dest, "int", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_isWritable(ut) {
        result := DllCall("icuuc.dll\utext_isWritable", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {Integer} 
     */
    static utext_hasMetaData(ut) {
        result := DllCall("icuuc.dll\utext_hasMetaData", "ptr", ut, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Pointer<UInt16>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utext_replace(ut, nativeStart, nativeLimit, replacementText, replacementLength, status) {
        result := DllCall("icuuc.dll\utext_replace", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, "ushort*", replacementText, "int", replacementLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} nativeStart 
     * @param {Integer} nativeLimit 
     * @param {Integer} destIndex 
     * @param {Integer} move 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_copy(ut, nativeStart, nativeLimit, destIndex, move, status) {
        DllCall("icuuc.dll\utext_copy", "ptr", ut, "int64", nativeStart, "int64", nativeLimit, "int64", destIndex, "char", move, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @returns {String} Nothing - always returns an empty string
     */
    static utext_freeze(ut) {
        DllCall("icuuc.dll\utext_freeze", "ptr", ut, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UText>} ut 
     * @param {Integer} extraSpace 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static utext_setup(ut, extraSpace, status) {
        result := DllCall("icuuc.dll\utext_setup", "ptr", ut, "int", extraSpace, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @returns {Pointer<USet>} 
     */
    static uset_openEmpty() {
        result := DllCall("icuuc.dll\uset_openEmpty", "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {Pointer<USet>} 
     */
    static uset_open(start, end) {
        result := DllCall("icuuc.dll\uset_open", "int", start, "int", end, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<USet>} 
     */
    static uset_openPattern(pattern, patternLength, ec) {
        result := DllCall("icuuc.dll\uset_openPattern", "ushort*", pattern, "int", patternLength, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} options 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<USet>} 
     */
    static uset_openPatternOptions(pattern, patternLength, options, ec) {
        result := DllCall("icuuc.dll\uset_openPatternOptions", "ushort*", pattern, "int", patternLength, "uint", options, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_close(set) {
        DllCall("icuuc.dll\uset_close", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Pointer<USet>} 
     */
    static uset_clone(set) {
        result := DllCall("icuuc.dll\uset_clone", "ptr", set, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_isFrozen(set) {
        result := DllCall("icuuc.dll\uset_isFrozen", "ptr", set, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_freeze(set) {
        DllCall("icuuc.dll\uset_freeze", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Pointer<USet>} 
     */
    static uset_cloneAsThawed(set) {
        result := DllCall("icuuc.dll\uset_cloneAsThawed", "ptr", set, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_set(set, start, end) {
        DllCall("icuuc.dll\uset_set", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} options 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uset_applyPattern(set, pattern, patternLength, options, status) {
        result := DllCall("icuuc.dll\uset_applyPattern", "ptr", set, "ushort*", pattern, "int", patternLength, "uint", options, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} prop 
     * @param {Integer} value 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_applyIntPropertyValue(set, prop, value, ec) {
        DllCall("icuuc.dll\uset_applyIntPropertyValue", "ptr", set, "int", prop, "int", value, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} prop 
     * @param {Integer} propLength 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} valueLength 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_applyPropertyAlias(set, prop, propLength, value, valueLength, ec) {
        DllCall("icuuc.dll\uset_applyPropertyAlias", "ptr", set, "ushort*", prop, "int", propLength, "ushort*", value, "int", valueLength, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} pos 
     * @returns {Integer} 
     */
    static uset_resemblesPattern(pattern, patternLength, pos) {
        result := DllCall("icuuc.dll\uset_resemblesPattern", "ushort*", pattern, "int", patternLength, "int", pos, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Integer} escapeUnprintable 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static uset_toPattern(set, result, resultCapacity, escapeUnprintable, ec) {
        result := DllCall("icuuc.dll\uset_toPattern", "ptr", set, "ushort*", result, "int", resultCapacity, "char", escapeUnprintable, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_add(set, c) {
        DllCall("icuuc.dll\uset_add", "ptr", set, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<USet>} additionalSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addAll(set, additionalSet) {
        DllCall("icuuc.dll\uset_addAll", "ptr", set, "ptr", additionalSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addRange(set, start, end) {
        DllCall("icuuc.dll\uset_addRange", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addString(set, str, strLen) {
        DllCall("icuuc.dll\uset_addString", "ptr", set, "ushort*", str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_addAllCodePoints(set, str, strLen) {
        DllCall("icuuc.dll\uset_addAllCodePoints", "ptr", set, "ushort*", str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_remove(set, c) {
        DllCall("icuuc.dll\uset_remove", "ptr", set, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeRange(set, start, end) {
        DllCall("icuuc.dll\uset_removeRange", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeString(set, str, strLen) {
        DllCall("icuuc.dll\uset_removeString", "ptr", set, "ushort*", str, "int", strLen, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeAllCodePoints(set, str, length) {
        DllCall("icu.dll\uset_removeAllCodePoints", "ptr", set, "ushort*", str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<USet>} removeSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeAll(set, removeSet) {
        DllCall("icuuc.dll\uset_removeAll", "ptr", set, "ptr", removeSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retain(set, start, end) {
        DllCall("icuuc.dll\uset_retain", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retainString(set, str, length) {
        DllCall("icu.dll\uset_retainString", "ptr", set, "ushort*", str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retainAllCodePoints(set, str, length) {
        DllCall("icu.dll\uset_retainAllCodePoints", "ptr", set, "ushort*", str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<USet>} retain 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_retainAll(set, retain) {
        DllCall("icuuc.dll\uset_retainAll", "ptr", set, "ptr", retain, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_compact(set) {
        DllCall("icuuc.dll\uset_compact", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complement(set) {
        DllCall("icuuc.dll\uset_complement", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementRange(set, start, end) {
        DllCall("icu.dll\uset_complementRange", "ptr", set, "int", start, "int", end, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementString(set, str, length) {
        DllCall("icu.dll\uset_complementString", "ptr", set, "ushort*", str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementAllCodePoints(set, str, length) {
        DllCall("icu.dll\uset_complementAllCodePoints", "ptr", set, "ushort*", str, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<USet>} complement 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_complementAll(set, complement) {
        DllCall("icuuc.dll\uset_complementAll", "ptr", set, "ptr", complement, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_clear(set) {
        DllCall("icuuc.dll\uset_clear", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} attributes 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_closeOver(set, attributes) {
        DllCall("icuuc.dll\uset_closeOver", "ptr", set, "int", attributes, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_removeAllStrings(set) {
        DllCall("icuuc.dll\uset_removeAllStrings", "ptr", set, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_isEmpty(set) {
        result := DllCall("icuuc.dll\uset_isEmpty", "ptr", set, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_hasStrings(set) {
        result := DllCall("icu.dll\uset_hasStrings", "ptr", set, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_contains(set, c) {
        result := DllCall("icuuc.dll\uset_contains", "ptr", set, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} start 
     * @param {Integer} end 
     * @returns {Integer} 
     */
    static uset_containsRange(set, start, end) {
        result := DllCall("icuuc.dll\uset_containsRange", "ptr", set, "int", start, "int", end, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {Integer} 
     */
    static uset_containsString(set, str, strLen) {
        result := DllCall("icuuc.dll\uset_containsString", "ptr", set, "ushort*", str, "int", strLen, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_indexOf(set, c) {
        result := DllCall("icuuc.dll\uset_indexOf", "ptr", set, "int", c, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} charIndex 
     * @returns {Integer} 
     */
    static uset_charAt(set, charIndex) {
        result := DllCall("icuuc.dll\uset_charAt", "ptr", set, "int", charIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_size(set) {
        result := DllCall("icuuc.dll\uset_size", "ptr", set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_getRangeCount(set) {
        result := DllCall("icu.dll\uset_getRangeCount", "ptr", set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @returns {Integer} 
     */
    static uset_getItemCount(set) {
        result := DllCall("icuuc.dll\uset_getItemCount", "ptr", set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Integer} itemIndex 
     * @param {Pointer<Int32>} start 
     * @param {Pointer<Int32>} end 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static uset_getItem(set, itemIndex, start, end, str, strCapacity, ec) {
        result := DllCall("icuuc.dll\uset_getItem", "ptr", set, "int", itemIndex, "int*", start, "int*", end, "ushort*", str, "int", strCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set1 
     * @param {Pointer<USet>} set2 
     * @returns {Integer} 
     */
    static uset_containsAll(set1, set2) {
        result := DllCall("icuuc.dll\uset_containsAll", "ptr", set1, "ptr", set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} str 
     * @param {Integer} strLen 
     * @returns {Integer} 
     */
    static uset_containsAllCodePoints(set, str, strLen) {
        result := DllCall("icuuc.dll\uset_containsAllCodePoints", "ptr", set, "ushort*", str, "int", strLen, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set1 
     * @param {Pointer<USet>} set2 
     * @returns {Integer} 
     */
    static uset_containsNone(set1, set2) {
        result := DllCall("icuuc.dll\uset_containsNone", "ptr", set1, "ptr", set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set1 
     * @param {Pointer<USet>} set2 
     * @returns {Integer} 
     */
    static uset_containsSome(set1, set2) {
        result := DllCall("icuuc.dll\uset_containsSome", "ptr", set1, "ptr", set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_span(set, s, length, spanCondition) {
        result := DllCall("icuuc.dll\uset_span", "ptr", set, "ushort*", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanBack(set, s, length, spanCondition) {
        result := DllCall("icuuc.dll\uset_spanBack", "ptr", set, "ushort*", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanUTF8(set, s, length, spanCondition) {
        s := s is String ? StrPtr(s) : s

        result := DllCall("icuuc.dll\uset_spanUTF8", "ptr", set, "ptr", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @param {Integer} spanCondition 
     * @returns {Integer} 
     */
    static uset_spanBackUTF8(set, s, length, spanCondition) {
        s := s is String ? StrPtr(s) : s

        result := DllCall("icuuc.dll\uset_spanBackUTF8", "ptr", set, "ptr", s, "int", length, "int", spanCondition, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set1 
     * @param {Pointer<USet>} set2 
     * @returns {Integer} 
     */
    static uset_equals(set1, set2) {
        result := DllCall("icuuc.dll\uset_equals", "ptr", set1, "ptr", set2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USet>} set 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uset_serialize(set, dest, destCapacity, pErrorCode) {
        result := DllCall("icuuc.dll\uset_serialize", "ptr", set, "ushort*", dest, "int", destCapacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} fillSet 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @returns {Integer} 
     */
    static uset_getSerializedSet(fillSet, src, srcLength) {
        result := DllCall("icuuc.dll\uset_getSerializedSet", "ptr", fillSet, "ushort*", src, "int", srcLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} fillSet 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static uset_setSerializedToOne(fillSet, c) {
        DllCall("icuuc.dll\uset_setSerializedToOne", "ptr", fillSet, "int", c, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static uset_serializedContains(set, c) {
        result := DllCall("icuuc.dll\uset_serializedContains", "ptr", set, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @returns {Integer} 
     */
    static uset_getSerializedRangeCount(set) {
        result := DllCall("icuuc.dll\uset_getSerializedRangeCount", "ptr", set, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USerializedSet>} set 
     * @param {Integer} rangeIndex 
     * @param {Pointer<Int32>} pStart 
     * @param {Pointer<Int32>} pEnd 
     * @returns {Integer} 
     */
    static uset_getSerializedRange(set, rangeIndex, pStart, pEnd) {
        result := DllCall("icuuc.dll\uset_getSerializedRange", "ptr", set, "int", rangeIndex, "int*", pStart, "int*", pEnd, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFCInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFCInstance", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFDInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFDInstance", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFKCInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFKCInstance", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFKDInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFKDInstance", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getNFKCCasefoldInstance(pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getNFKCCasefoldInstance", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} packageName 
     * @param {PSTR} name 
     * @param {Integer} mode 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_getInstance(packageName, name, mode, pErrorCode) {
        packageName := packageName is String ? StrPtr(packageName) : packageName
        name := name is String ? StrPtr(name) : name

        result := DllCall("icuuc.dll\unorm2_getInstance", "ptr", packageName, "ptr", name, "int", mode, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<USet>} filterSet 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UNormalizer2>} 
     */
    static unorm2_openFiltered(norm2, filterSet, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_openFiltered", "ptr", norm2, "ptr", filterSet, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @returns {String} Nothing - always returns an empty string
     */
    static unorm2_close(norm2) {
        DllCall("icuuc.dll\unorm2_close", "ptr", norm2, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_normalize(norm2, src, length, dest, capacity, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_normalize", "ptr", norm2, "ushort*", src, "int", length, "ushort*", dest, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<UInt16>} first 
     * @param {Integer} firstLength 
     * @param {Integer} firstCapacity 
     * @param {Pointer<UInt16>} second 
     * @param {Integer} secondLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_normalizeSecondAndAppend(norm2, first, firstLength, firstCapacity, second, secondLength, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_normalizeSecondAndAppend", "ptr", norm2, "ushort*", first, "int", firstLength, "int", firstCapacity, "ushort*", second, "int", secondLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<UInt16>} first 
     * @param {Integer} firstLength 
     * @param {Integer} firstCapacity 
     * @param {Pointer<UInt16>} second 
     * @param {Integer} secondLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_append(norm2, first, firstLength, firstCapacity, second, secondLength, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_append", "ptr", norm2, "ushort*", first, "int", firstLength, "int", firstCapacity, "ushort*", second, "int", secondLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @param {Pointer<UInt16>} decomposition 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_getDecomposition(norm2, c, decomposition, capacity, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getDecomposition", "ptr", norm2, "int", c, "ushort*", decomposition, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @param {Pointer<UInt16>} decomposition 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_getRawDecomposition(norm2, c, decomposition, capacity, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_getRawDecomposition", "ptr", norm2, "int", c, "ushort*", decomposition, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} a 
     * @param {Integer} b 
     * @returns {Integer} 
     */
    static unorm2_composePair(norm2, a, b) {
        result := DllCall("icuuc.dll\unorm2_composePair", "ptr", norm2, "int", a, "int", b, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_getCombiningClass(norm2, c) {
        result := DllCall("icuuc.dll\unorm2_getCombiningClass", "ptr", norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_isNormalized(norm2, s, length, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_isNormalized", "ptr", norm2, "ushort*", s, "int", length, "int*", pErrorCode, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_quickCheck(norm2, s, length, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_quickCheck", "ptr", norm2, "ushort*", s, "int", length, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm2_spanQuickCheckYes(norm2, s, length, pErrorCode) {
        result := DllCall("icuuc.dll\unorm2_spanQuickCheckYes", "ptr", norm2, "ushort*", s, "int", length, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_hasBoundaryBefore(norm2, c) {
        result := DllCall("icuuc.dll\unorm2_hasBoundaryBefore", "ptr", norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_hasBoundaryAfter(norm2, c) {
        result := DllCall("icuuc.dll\unorm2_hasBoundaryAfter", "ptr", norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNormalizer2>} norm2 
     * @param {Integer} c 
     * @returns {Integer} 
     */
    static unorm2_isInert(norm2, c) {
        result := DllCall("icuuc.dll\unorm2_isInert", "ptr", norm2, "int", c, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Integer} length1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} length2 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static unorm_compare(s1, length1, s2, length2, options, pErrorCode) {
        result := DllCall("icuuc.dll\unorm_compare", "ushort*", s1, "int", length1, "ushort*", s2, "int", length2, "uint", options, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<SByte>} converterList 
     * @param {Integer} converterListSize 
     * @param {Pointer<USet>} excludedCodePoints 
     * @param {Integer} whichSet 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UConverterSelector>} 
     */
    static ucnvsel_open(converterList, converterListSize, excludedCodePoints, whichSet, status) {
        result := DllCall("icuuc.dll\ucnvsel_open", "char*", converterList, "int", converterListSize, "ptr", excludedCodePoints, "int", whichSet, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterSelector>} sel 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucnvsel_close(sel) {
        DllCall("icuuc.dll\ucnvsel_close", "ptr", sel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} buffer 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UConverterSelector>} 
     */
    static ucnvsel_openFromSerialized(buffer, length, status) {
        result := DllCall("icuuc.dll\ucnvsel_openFromSerialized", "ptr", buffer, "int", length, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterSelector>} sel 
     * @param {Pointer<Void>} buffer 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucnvsel_serialize(sel, buffer, bufferCapacity, status) {
        result := DllCall("icuuc.dll\ucnvsel_serialize", "ptr", sel, "ptr", buffer, "int", bufferCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterSelector>} sel 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucnvsel_selectForString(sel, s, length, status) {
        result := DllCall("icuuc.dll\ucnvsel_selectForString", "ptr", sel, "ushort*", s, "int", length, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConverterSelector>} sel 
     * @param {PSTR} s 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucnvsel_selectForUTF8(sel, s, length, status) {
        s := s is String ? StrPtr(s) : s

        result := DllCall("icuuc.dll\ucnvsel_selectForUTF8", "ptr", sel, "ptr", s, "int", length, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} cs 
     * @param {Pointer<UInt16>} us 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_charsToUChars(cs, us, length) {
        cs := cs is String ? StrPtr(cs) : cs

        DllCall("icuuc.dll\u_charsToUChars", "ptr", cs, "ushort*", us, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} us 
     * @param {PSTR} cs 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_UCharsToChars(us, cs, length) {
        cs := cs is String ? StrPtr(cs) : cs

        DllCall("icuuc.dll\u_UCharsToChars", "ushort*", us, "ptr", cs, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @returns {Integer} 
     */
    static u_strlen(s) {
        result := DllCall("icuuc.dll\u_strlen", "ushort*", s, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @returns {Integer} 
     */
    static u_countChar32(s, length) {
        result := DllCall("icuuc.dll\u_countChar32", "ushort*", s, "int", length, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Integer} number 
     * @returns {Integer} 
     */
    static u_strHasMoreChar32Than(s, length, number) {
        result := DllCall("icuuc.dll\u_strHasMoreChar32Than", "ushort*", s, "int", length, "int", number, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<UInt16>} src 
     * @returns {Pointer<UInt16>} 
     */
    static u_strcat(dst, src) {
        result := DllCall("icuuc.dll\u_strcat", "ushort*", dst, "ushort*", src, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} n 
     * @returns {Pointer<UInt16>} 
     */
    static u_strncat(dst, src, n) {
        result := DllCall("icuuc.dll\u_strncat", "ushort*", dst, "ushort*", src, "int", n, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Pointer<UInt16>} substring 
     * @returns {Pointer<UInt16>} 
     */
    static u_strstr(s, substring) {
        result := DllCall("icuuc.dll\u_strstr", "ushort*", s, "ushort*", substring, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} substring 
     * @param {Integer} subLength 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFindFirst(s, length, substring, subLength) {
        result := DllCall("icuuc.dll\u_strFindFirst", "ushort*", s, "int", length, "ushort*", substring, "int", subLength, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @returns {Pointer<UInt16>} 
     */
    static u_strchr(s, c) {
        result := DllCall("icuuc.dll\u_strchr", "ushort*", s, "ushort", c, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @returns {Pointer<UInt16>} 
     */
    static u_strchr32(s, c) {
        result := DllCall("icuuc.dll\u_strchr32", "ushort*", s, "int", c, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Pointer<UInt16>} substring 
     * @returns {Pointer<UInt16>} 
     */
    static u_strrstr(s, substring) {
        result := DllCall("icuuc.dll\u_strrstr", "ushort*", s, "ushort*", substring, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} substring 
     * @param {Integer} subLength 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFindLast(s, length, substring, subLength) {
        result := DllCall("icuuc.dll\u_strFindLast", "ushort*", s, "int", length, "ushort*", substring, "int", subLength, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @returns {Pointer<UInt16>} 
     */
    static u_strrchr(s, c) {
        result := DllCall("icuuc.dll\u_strrchr", "ushort*", s, "ushort", c, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @returns {Pointer<UInt16>} 
     */
    static u_strrchr32(s, c) {
        result := DllCall("icuuc.dll\u_strrchr32", "ushort*", s, "int", c, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} string 
     * @param {Pointer<UInt16>} matchSet 
     * @returns {Pointer<UInt16>} 
     */
    static u_strpbrk(string, matchSet) {
        result := DllCall("icuuc.dll\u_strpbrk", "ushort*", string, "ushort*", matchSet, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} string 
     * @param {Pointer<UInt16>} matchSet 
     * @returns {Integer} 
     */
    static u_strcspn(string, matchSet) {
        result := DllCall("icuuc.dll\u_strcspn", "ushort*", string, "ushort*", matchSet, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} string 
     * @param {Pointer<UInt16>} matchSet 
     * @returns {Integer} 
     */
    static u_strspn(string, matchSet) {
        result := DllCall("icuuc.dll\u_strspn", "ushort*", string, "ushort*", matchSet, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} src 
     * @param {Pointer<UInt16>} delim 
     * @param {Pointer<UInt16>} saveState 
     * @returns {Pointer<UInt16>} 
     */
    static u_strtok_r(src, delim, saveState) {
        result := DllCall("icuuc.dll\u_strtok_r", "ushort*", src, "ushort*", delim, "ushort*", saveState, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @returns {Integer} 
     */
    static u_strcmp(s1, s2) {
        result := DllCall("icuuc.dll\u_strcmp", "ushort*", s1, "ushort*", s2, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @returns {Integer} 
     */
    static u_strcmpCodePointOrder(s1, s2) {
        result := DllCall("icuuc.dll\u_strcmpCodePointOrder", "ushort*", s1, "ushort*", s2, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Integer} length1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} length2 
     * @param {Integer} codePointOrder 
     * @returns {Integer} 
     */
    static u_strCompare(s1, length1, s2, length2, codePointOrder) {
        result := DllCall("icuuc.dll\u_strCompare", "ushort*", s1, "int", length1, "ushort*", s2, "int", length2, "char", codePointOrder, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharIterator>} iter1 
     * @param {Pointer<UCharIterator>} iter2 
     * @param {Integer} codePointOrder 
     * @returns {Integer} 
     */
    static u_strCompareIter(iter1, iter2, codePointOrder) {
        result := DllCall("icuuc.dll\u_strCompareIter", "ptr", iter1, "ptr", iter2, "char", codePointOrder, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Integer} length1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} length2 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strCaseCompare(s1, length1, s2, length2, options, pErrorCode) {
        result := DllCall("icuuc.dll\u_strCaseCompare", "ushort*", s1, "int", length1, "ushort*", s2, "int", length2, "uint", options, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} ucs1 
     * @param {Pointer<UInt16>} ucs2 
     * @param {Integer} n 
     * @returns {Integer} 
     */
    static u_strncmp(ucs1, ucs2, n) {
        result := DllCall("icuuc.dll\u_strncmp", "ushort*", ucs1, "ushort*", ucs2, "int", n, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} n 
     * @returns {Integer} 
     */
    static u_strncmpCodePointOrder(s1, s2, n) {
        result := DllCall("icuuc.dll\u_strncmpCodePointOrder", "ushort*", s1, "ushort*", s2, "int", n, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_strcasecmp(s1, s2, options) {
        result := DllCall("icuuc.dll\u_strcasecmp", "ushort*", s1, "ushort*", s2, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} n 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_strncasecmp(s1, s2, n, options) {
        result := DllCall("icuuc.dll\u_strncasecmp", "ushort*", s1, "ushort*", s2, "int", n, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} length 
     * @param {Integer} options 
     * @returns {Integer} 
     */
    static u_memcasecmp(s1, s2, length, options) {
        result := DllCall("icuuc.dll\u_memcasecmp", "ushort*", s1, "ushort*", s2, "int", length, "uint", options, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<UInt16>} src 
     * @returns {Pointer<UInt16>} 
     */
    static u_strcpy(dst, src) {
        result := DllCall("icuuc.dll\u_strcpy", "ushort*", dst, "ushort*", src, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} n 
     * @returns {Pointer<UInt16>} 
     */
    static u_strncpy(dst, src, n) {
        result := DllCall("icuuc.dll\u_strncpy", "ushort*", dst, "ushort*", src, "int", n, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {PSTR} src 
     * @returns {Pointer<UInt16>} 
     */
    static u_uastrcpy(dst, src) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\u_uastrcpy", "ushort*", dst, "ptr", src, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dst 
     * @param {PSTR} src 
     * @param {Integer} n 
     * @returns {Pointer<UInt16>} 
     */
    static u_uastrncpy(dst, src, n) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\u_uastrncpy", "ushort*", dst, "ptr", src, "int", n, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {PSTR} dst 
     * @param {Pointer<UInt16>} src 
     * @returns {PSTR} 
     */
    static u_austrcpy(dst, src) {
        dst := dst is String ? StrPtr(dst) : dst

        result := DllCall("icuuc.dll\u_austrcpy", "ptr", dst, "ushort*", src, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} dst 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} n 
     * @returns {PSTR} 
     */
    static u_austrncpy(dst, src, n) {
        dst := dst is String ? StrPtr(dst) : dst

        result := DllCall("icuuc.dll\u_austrncpy", "ptr", dst, "ushort*", src, "int", n, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memcpy(dest, src, count) {
        result := DllCall("icuuc.dll\u_memcpy", "ushort*", dest, "ushort*", src, "int", count, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memmove(dest, src, count) {
        result := DllCall("icuuc.dll\u_memmove", "ushort*", dest, "ushort*", src, "int", count, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memset(dest, c, count) {
        result := DllCall("icuuc.dll\u_memset", "ushort*", dest, "ushort", c, "int", count, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} buf1 
     * @param {Pointer<UInt16>} buf2 
     * @param {Integer} count 
     * @returns {Integer} 
     */
    static u_memcmp(buf1, buf2, count) {
        result := DllCall("icuuc.dll\u_memcmp", "ushort*", buf1, "ushort*", buf2, "int", count, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s1 
     * @param {Pointer<UInt16>} s2 
     * @param {Integer} count 
     * @returns {Integer} 
     */
    static u_memcmpCodePointOrder(s1, s2, count) {
        result := DllCall("icuuc.dll\u_memcmpCodePointOrder", "ushort*", s1, "ushort*", s2, "int", count, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memchr(s, c, count) {
        result := DllCall("icuuc.dll\u_memchr", "ushort*", s, "ushort", c, "int", count, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memchr32(s, c, count) {
        result := DllCall("icuuc.dll\u_memchr32", "ushort*", s, "int", c, "int", count, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memrchr(s, c, count) {
        result := DllCall("icuuc.dll\u_memrchr", "ushort*", s, "ushort", c, "int", count, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} s 
     * @param {Integer} c 
     * @param {Integer} count 
     * @returns {Pointer<UInt16>} 
     */
    static u_memrchr32(s, c, count) {
        result := DllCall("icuuc.dll\u_memrchr32", "ushort*", s, "int", c, "int", count, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {PSTR} src 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @returns {Integer} 
     */
    static u_unescape(src, dest, destCapacity) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\u_unescape", "ptr", src, "ushort*", dest, "int", destCapacity, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNESCAPE_CHAR_AT>} charAt 
     * @param {Pointer<Int32>} offset 
     * @param {Integer} length 
     * @param {Pointer<Void>} context 
     * @returns {Integer} 
     */
    static u_unescapeAt(charAt, offset, length, context) {
        result := DllCall("icuuc.dll\u_unescapeAt", "ptr", charAt, "int*", offset, "int", length, "ptr", context, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToUpper(dest, destCapacity, src, srcLength, locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\u_strToUpper", "ushort*", dest, "int", destCapacity, "ushort*", src, "int", srcLength, "ptr", locale, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToLower(dest, destCapacity, src, srcLength, locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\u_strToLower", "ushort*", dest, "int", destCapacity, "ushort*", src, "int", srcLength, "ptr", locale, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<UBreakIterator>} titleIter 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strToTitle(dest, destCapacity, src, srcLength, titleIter, locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\u_strToTitle", "ushort*", dest, "int", destCapacity, "ushort*", src, "int", srcLength, "ptr", titleIter, "ptr", locale, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static u_strFoldCase(dest, destCapacity, src, srcLength, options, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFoldCase", "ushort*", dest, "int", destCapacity, "ushort*", src, "int", srcLength, "uint", options, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PWSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PWSTR} 
     */
    static u_strToWCS(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\u_strToWCS", "ptr", dest, "int", destCapacity, "int*", pDestLength, "ushort*", src, "int", srcLength, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {PWSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromWCS(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\u_strFromWCS", "ushort*", dest, "int", destCapacity, "int*", pDestLength, "ptr", src, "int", srcLength, "int*", pErrorCode, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PSTR} 
     */
    static u_strToUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\u_strToUTF8", "ptr", dest, "int", destCapacity, "int*", pDestLength, "ushort*", src, "int", srcLength, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\u_strFromUTF8", "ushort*", dest, "int", destCapacity, "int*", pDestLength, "ptr", src, "int", srcLength, "int*", pErrorCode, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PSTR} 
     */
    static u_strToUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\u_strToUTF8WithSub", "ptr", dest, "int", destCapacity, "int*", pDestLength, "ushort*", src, "int", srcLength, "int", subchar, "int*", pNumSubstitutions, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\u_strFromUTF8WithSub", "ushort*", dest, "int", destCapacity, "int*", pDestLength, "ptr", src, "int", srcLength, "int", subchar, "int*", pNumSubstitutions, "int*", pErrorCode, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF8Lenient(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\u_strFromUTF8Lenient", "ushort*", dest, "int", destCapacity, "int*", pDestLength, "ptr", src, "int", srcLength, "int*", pErrorCode, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Int32>} 
     */
    static u_strToUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToUTF32", "int*", dest, "int", destCapacity, "int*", pDestLength, "ushort*", src, "int", srcLength, "int*", pErrorCode, "CDecl int*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<Int32>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF32(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromUTF32", "ushort*", dest, "int", destCapacity, "int*", pDestLength, "int*", src, "int", srcLength, "int*", pErrorCode, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Int32>} 
     */
    static u_strToUTF32WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        result := DllCall("icuuc.dll\u_strToUTF32WithSub", "int*", dest, "int", destCapacity, "int*", pDestLength, "ushort*", src, "int", srcLength, "int", subchar, "int*", pNumSubstitutions, "int*", pErrorCode, "CDecl int*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<Int32>} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromUTF32WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        result := DllCall("icuuc.dll\u_strFromUTF32WithSub", "ushort*", dest, "int", destCapacity, "int*", pDestLength, "int*", src, "int", srcLength, "int", subchar, "int*", pNumSubstitutions, "int*", pErrorCode, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {PSTR} 
     */
    static u_strToJavaModifiedUTF8(dest, destCapacity, pDestLength, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\u_strToJavaModifiedUTF8", "ptr", dest, "int", destCapacity, "int*", pDestLength, "ushort*", src, "int", srcLength, "int*", pErrorCode, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pDestLength 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Integer} subchar 
     * @param {Pointer<Int32>} pNumSubstitutions 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UInt16>} 
     */
    static u_strFromJavaModifiedUTF8WithSub(dest, destCapacity, pDestLength, src, srcLength, subchar, pNumSubstitutions, pErrorCode) {
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\u_strFromJavaModifiedUTF8WithSub", "ushort*", dest, "int", destCapacity, "int*", pDestLength, "ptr", src, "int", srcLength, "int", subchar, "int*", pNumSubstitutions, "int*", pErrorCode, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UCaseMap>} 
     */
    static ucasemap_open(locale, options, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ucasemap_open", "ptr", locale, "uint", options, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_close(csm) {
        DllCall("icuuc.dll\ucasemap_close", "ptr", csm, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @returns {PSTR} 
     */
    static ucasemap_getLocale(csm) {
        result := DllCall("icuuc.dll\ucasemap_getLocale", "ptr", csm, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @returns {Integer} 
     */
    static ucasemap_getOptions(csm) {
        result := DllCall("icuuc.dll\ucasemap_getOptions", "ptr", csm, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setLocale(csm, locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        DllCall("icuuc.dll\ucasemap_setLocale", "ptr", csm, "ptr", locale, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setOptions(csm, options, pErrorCode) {
        DllCall("icuuc.dll\ucasemap_setOptions", "ptr", csm, "uint", options, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ucasemap_getBreakIterator(csm) {
        result := DllCall("icuuc.dll\ucasemap_getBreakIterator", "ptr", csm, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {Pointer<UBreakIterator>} iterToAdopt 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucasemap_setBreakIterator(csm, iterToAdopt, pErrorCode) {
        DllCall("icuuc.dll\ucasemap_setBreakIterator", "ptr", csm, "ptr", iterToAdopt, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_toTitle(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        result := DllCall("icuuc.dll\ucasemap_toTitle", "ptr", csm, "ushort*", dest, "int", destCapacity, "ushort*", src, "int", srcLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToLower(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\ucasemap_utf8ToLower", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToUpper(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\ucasemap_utf8ToUpper", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8ToTitle(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\ucasemap_utf8ToTitle", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCaseMap>} csm 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {PSTR} src 
     * @param {Integer} srcLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucasemap_utf8FoldCase(csm, dest, destCapacity, src, srcLength, pErrorCode) {
        dest := dest is String ? StrPtr(dest) : dest
        src := src is String ? StrPtr(src) : src

        result := DllCall("icuuc.dll\ucasemap_utf8FoldCase", "ptr", csm, "ptr", dest, "int", destCapacity, "ptr", src, "int", srcLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} path 
     * @param {PSTR} fileName 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UStringPrepProfile>} 
     */
    static usprep_open(path, fileName, status) {
        path := path is String ? StrPtr(path) : path
        fileName := fileName is String ? StrPtr(fileName) : fileName

        result := DllCall("icuuc.dll\usprep_open", "ptr", path, "ptr", fileName, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UStringPrepProfile>} 
     */
    static usprep_openByType(type, status) {
        result := DllCall("icuuc.dll\usprep_openByType", "int", type, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringPrepProfile>} profile 
     * @returns {String} Nothing - always returns an empty string
     */
    static usprep_close(profile) {
        DllCall("icuuc.dll\usprep_close", "ptr", profile, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringPrepProfile>} prep 
     * @param {Pointer<UInt16>} src 
     * @param {Integer} srcLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Integer} options 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usprep_prepare(prep, src, srcLength, dest, destCapacity, options, parseError, status) {
        result := DllCall("icuuc.dll\usprep_prepare", "ptr", prep, "ushort*", src, "int", srcLength, "ushort*", dest, "int", destCapacity, "int", options, "ptr", parseError, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} options 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UIDNA>} 
     */
    static uidna_openUTS46(options, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_openUTS46", "uint", options, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @returns {String} Nothing - always returns an empty string
     */
    static uidna_close(idna) {
        DllCall("icuuc.dll\uidna_close", "ptr", idna, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {Pointer<UInt16>} label 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToASCII(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_labelToASCII", "ptr", idna, "ushort*", label, "int", length, "ushort*", dest, "int", capacity, "ptr", pInfo, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {Pointer<UInt16>} label 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToUnicode(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_labelToUnicode", "ptr", idna, "ushort*", label, "int", length, "ushort*", dest, "int", capacity, "ptr", pInfo, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {Pointer<UInt16>} name 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToASCII(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_nameToASCII", "ptr", idna, "ushort*", name, "int", length, "ushort*", dest, "int", capacity, "ptr", pInfo, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {Pointer<UInt16>} name 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToUnicode(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        result := DllCall("icuuc.dll\uidna_nameToUnicode", "ptr", idna, "ushort*", name, "int", length, "ushort*", dest, "int", capacity, "ptr", pInfo, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {PSTR} label 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToASCII_UTF8(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        label := label is String ? StrPtr(label) : label
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\uidna_labelToASCII_UTF8", "ptr", idna, "ptr", label, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {PSTR} label 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_labelToUnicodeUTF8(idna, label, length, dest, capacity, pInfo, pErrorCode) {
        label := label is String ? StrPtr(label) : label
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\uidna_labelToUnicodeUTF8", "ptr", idna, "ptr", label, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {PSTR} name 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToASCII_UTF8(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        name := name is String ? StrPtr(name) : name
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\uidna_nameToASCII_UTF8", "ptr", idna, "ptr", name, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UIDNA>} idna 
     * @param {PSTR} name 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} capacity 
     * @param {Pointer<UIDNAInfo>} pInfo 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static uidna_nameToUnicodeUTF8(idna, name, length, dest, capacity, pInfo, pErrorCode) {
        name := name is String ? StrPtr(name) : name
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuuc.dll\uidna_nameToUnicodeUTF8", "ptr", idna, "ptr", name, "int", length, "ptr", dest, "int", capacity, "ptr", pInfo, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_open(type, locale, text, textLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ubrk_open", "int", type, "ptr", locale, "ushort*", text, "int", textLength, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} rules 
     * @param {Integer} rulesLength 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<UParseError>} parseErr 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_openRules(rules, rulesLength, text, textLength, parseErr, status) {
        result := DllCall("icuuc.dll\ubrk_openRules", "ushort*", rules, "int", rulesLength, "ushort*", text, "int", textLength, "ptr", parseErr, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} binaryRules 
     * @param {Integer} rulesLength 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_openBinaryRules(binaryRules, rulesLength, text, textLength, status) {
        result := DllCall("icuuc.dll\ubrk_openBinaryRules", "char*", binaryRules, "int", rulesLength, "ushort*", text, "int", textLength, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Int32>} pBufferSize 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_safeClone(bi, stackBuffer, pBufferSize, status) {
        result := DllCall("icuuc.dll\ubrk_safeClone", "ptr", bi, "ptr", stackBuffer, "int*", pBufferSize, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UBreakIterator>} 
     */
    static ubrk_clone(bi, status) {
        result := DllCall("icu.dll\ubrk_clone", "ptr", bi, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_close(bi) {
        DllCall("icuuc.dll\ubrk_close", "ptr", bi, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_setText(bi, text, textLength, status) {
        DllCall("icuuc.dll\ubrk_setText", "ptr", bi, "ushort*", text, "int", textLength, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_setUText(bi, text, status) {
        DllCall("icuuc.dll\ubrk_setUText", "ptr", bi, "ptr", text, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_current(bi) {
        result := DllCall("icuuc.dll\ubrk_current", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_next(bi) {
        result := DllCall("icuuc.dll\ubrk_next", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_previous(bi) {
        result := DllCall("icuuc.dll\ubrk_previous", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_first(bi) {
        result := DllCall("icuuc.dll\ubrk_first", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_last(bi) {
        result := DllCall("icuuc.dll\ubrk_last", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_preceding(bi, offset) {
        result := DllCall("icuuc.dll\ubrk_preceding", "ptr", bi, "int", offset, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_following(bi, offset) {
        result := DllCall("icuuc.dll\ubrk_following", "ptr", bi, "int", offset, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} index 
     * @returns {PSTR} 
     */
    static ubrk_getAvailable(index) {
        result := DllCall("icuuc.dll\ubrk_getAvailable", "int", index, "CDecl char*")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ubrk_countAvailable() {
        result := DllCall("icuuc.dll\ubrk_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Integer} offset 
     * @returns {Integer} 
     */
    static ubrk_isBoundary(bi, offset) {
        result := DllCall("icuuc.dll\ubrk_isBoundary", "ptr", bi, "int", offset, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @returns {Integer} 
     */
    static ubrk_getRuleStatus(bi) {
        result := DllCall("icuuc.dll\ubrk_getRuleStatus", "ptr", bi, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Int32>} fillInVec 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ubrk_getRuleStatusVec(bi, fillInVec, capacity, status) {
        result := DllCall("icuuc.dll\ubrk_getRuleStatusVec", "ptr", bi, "int*", fillInVec, "int", capacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ubrk_getLocaleByType(bi, type, status) {
        result := DllCall("icuuc.dll\ubrk_getLocaleByType", "ptr", bi, "int", type, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ubrk_refreshUText(bi, text, status) {
        DllCall("icuuc.dll\ubrk_refreshUText", "ptr", bi, "ptr", text, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UBreakIterator>} bi 
     * @param {Pointer<Byte>} binaryRules 
     * @param {Integer} rulesCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ubrk_getBinaryRules(bi, binaryRules, rulesCapacity, status) {
        result := DllCall("icuuc.dll\ubrk_getBinaryRules", "ptr", bi, "char*", binaryRules, "int", rulesCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} dataVersionFillin 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_getDataVersion(dataVersionFillin, status) {
        DllCall("icuuc.dll\u_getDataVersion", "char*", dataVersionFillin, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} zoneType 
     * @param {PSTR} region 
     * @param {Pointer<Int32>} rawOffset 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucal_openTimeZoneIDEnumeration(zoneType, region, rawOffset, ec) {
        region := region is String ? StrPtr(region) : region

        result := DllCall("icuin.dll\ucal_openTimeZoneIDEnumeration", "int", zoneType, "ptr", region, "int*", rawOffset, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucal_openTimeZones(ec) {
        result := DllCall("icuin.dll\ucal_openTimeZones", "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} country 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucal_openCountryTimeZones(country, ec) {
        country := country is String ? StrPtr(country) : country

        result := DllCall("icuin.dll\ucal_openCountryTimeZones", "ptr", country, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucal_getDefaultTimeZone(result, resultCapacity, ec) {
        result := DllCall("icuin.dll\ucal_getDefaultTimeZone", "ushort*", result, "int", resultCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} zoneID 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDefaultTimeZone(zoneID, ec) {
        DllCall("icuin.dll\ucal_setDefaultTimeZone", "ushort*", zoneID, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucal_getHostTimeZone(result, resultCapacity, ec) {
        result := DllCall("icu.dll\ucal_getHostTimeZone", "ushort*", result, "int", resultCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} zoneID 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucal_getDSTSavings(zoneID, ec) {
        result := DllCall("icuin.dll\ucal_getDSTSavings", "ushort*", zoneID, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @returns {Float} 
     */
    static ucal_getNow() {
        result := DllCall("icuin.dll\ucal_getNow", "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} zoneID 
     * @param {Integer} len 
     * @param {PSTR} locale 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static ucal_open(zoneID, len, locale, type, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\ucal_open", "ushort*", zoneID, "int", len, "ptr", locale, "int", type, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_close(cal) {
        DllCall("icuin.dll\ucal_close", "ptr", cal, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static ucal_clone(cal, status) {
        result := DllCall("icuin.dll\ucal_clone", "ptr", cal, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<UInt16>} zoneID 
     * @param {Integer} len 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setTimeZone(cal, zoneID, len, status) {
        DllCall("icuin.dll\ucal_setTimeZone", "ptr", cal, "ushort*", zoneID, "int", len, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneID(cal, result, resultLength, status) {
        result := DllCall("icuin.dll\ucal_getTimeZoneID", "ptr", cal, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} type 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneDisplayName(cal, type, locale, result, resultLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\ucal_getTimeZoneDisplayName", "ptr", cal, "int", type, "ptr", locale, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_inDaylightTime(cal, status) {
        result := DllCall("icuin.dll\ucal_inDaylightTime", "ptr", cal, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Float} date 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setGregorianChange(cal, date, pErrorCode) {
        DllCall("icuin.dll\ucal_setGregorianChange", "ptr", cal, "double", date, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Float} 
     */
    static ucal_getGregorianChange(cal, pErrorCode) {
        result := DllCall("icuin.dll\ucal_getGregorianChange", "ptr", cal, "int*", pErrorCode, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} attr 
     * @returns {Integer} 
     */
    static ucal_getAttribute(cal, attr) {
        result := DllCall("icuin.dll\ucal_getAttribute", "ptr", cal, "int", attr, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setAttribute(cal, attr, newValue) {
        DllCall("icuin.dll\ucal_setAttribute", "ptr", cal, "int", attr, "int", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {PSTR} 
     */
    static ucal_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\ucal_getAvailable", "int", localeIndex, "CDecl char*")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucal_countAvailable() {
        result := DllCall("icuin.dll\ucal_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static ucal_getMillis(cal, status) {
        result := DllCall("icuin.dll\ucal_getMillis", "ptr", cal, "int*", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Float} dateTime 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setMillis(cal, dateTime, status) {
        DllCall("icuin.dll\ucal_setMillis", "ptr", cal, "double", dateTime, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} year 
     * @param {Integer} month 
     * @param {Integer} date 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDate(cal, year, month, date, status) {
        DllCall("icuin.dll\ucal_setDate", "ptr", cal, "int", year, "int", month, "int", date, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} year 
     * @param {Integer} month 
     * @param {Integer} date 
     * @param {Integer} hour 
     * @param {Integer} minute 
     * @param {Integer} second 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_setDateTime(cal, year, month, date, hour, minute, second, status) {
        DllCall("icuin.dll\ucal_setDateTime", "ptr", cal, "int", year, "int", month, "int", date, "int", hour, "int", minute, "int", second, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal1 
     * @param {Pointer<Void>} cal2 
     * @returns {Integer} 
     */
    static ucal_equivalentTo(cal1, cal2) {
        result := DllCall("icuin.dll\ucal_equivalentTo", "ptr", cal1, "ptr", cal2, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Integer} amount 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_add(cal, field, amount, status) {
        DllCall("icuin.dll\ucal_add", "ptr", cal, "int", field, "int", amount, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Integer} amount 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_roll(cal, field, amount, status) {
        DllCall("icuin.dll\ucal_roll", "ptr", cal, "int", field, "int", amount, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_get(cal, field, status) {
        result := DllCall("icuin.dll\ucal_get", "ptr", cal, "int", field, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Integer} value 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_set(cal, field, value) {
        DllCall("icuin.dll\ucal_set", "ptr", cal, "int", field, "int", value, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @returns {Integer} 
     */
    static ucal_isSet(cal, field) {
        result := DllCall("icuin.dll\ucal_isSet", "ptr", cal, "int", field, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_clearField(cal, field) {
        DllCall("icuin.dll\ucal_clearField", "ptr", cal, "int", field, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} calendar 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_clear(calendar) {
        DllCall("icuin.dll\ucal_clear", "ptr", calendar, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} field 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getLimit(cal, field, type, status) {
        result := DllCall("icuin.dll\ucal_getLimit", "ptr", cal, "int", field, "int", type, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ucal_getLocaleByType(cal, type, status) {
        result := DllCall("icuin.dll\ucal_getLocaleByType", "ptr", cal, "int", type, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ucal_getTZDataVersion(status) {
        result := DllCall("icuin.dll\ucal_getTZDataVersion", "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} len 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<SByte>} isSystemID 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getCanonicalTimeZoneID(id, len, result, resultCapacity, isSystemID, status) {
        result := DllCall("icuin.dll\ucal_getCanonicalTimeZoneID", "ushort*", id, "int", len, "ushort*", result, "int", resultCapacity, "char*", isSystemID, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ucal_getType(cal, status) {
        result := DllCall("icuin.dll\ucal_getType", "ptr", cal, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {PSTR} key 
     * @param {PSTR} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucal_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        key := key is String ? StrPtr(key) : key
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\ucal_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} dayOfWeek 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getDayOfWeekType(cal, dayOfWeek, status) {
        result := DllCall("icuin.dll\ucal_getDayOfWeekType", "ptr", cal, "int", dayOfWeek, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} dayOfWeek 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getWeekendTransition(cal, dayOfWeek, status) {
        result := DllCall("icuin.dll\ucal_getWeekendTransition", "ptr", cal, "int", dayOfWeek, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Float} date 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_isWeekend(cal, date, status) {
        result := DllCall("icuin.dll\ucal_isWeekend", "ptr", cal, "double", date, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Float} target 
     * @param {Integer} field 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getFieldDifference(cal, target, field, status) {
        result := DllCall("icuin.dll\ucal_getFieldDifference", "ptr", cal, "double", target, "int", field, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} type 
     * @param {Pointer<Double>} transition 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneTransitionDate(cal, type, transition, status) {
        result := DllCall("icuin.dll\ucal_getTimeZoneTransitionDate", "ptr", cal, "int", type, "double*", transition, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} len 
     * @param {Pointer<UInt16>} winid 
     * @param {Integer} winidCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getWindowsTimeZoneID(id, len, winid, winidCapacity, status) {
        result := DllCall("icuin.dll\ucal_getWindowsTimeZoneID", "ushort*", id, "int", len, "ushort*", winid, "int", winidCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} winid 
     * @param {Integer} len 
     * @param {PSTR} region 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} idCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucal_getTimeZoneIDForWindowsID(winid, len, region, id, idCapacity, status) {
        region := region is String ? StrPtr(region) : region

        result := DllCall("icuin.dll\ucal_getTimeZoneIDForWindowsID", "ushort*", winid, "int", len, "ptr", region, "ushort*", id, "int", idCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} cal 
     * @param {Integer} nonExistingTimeOpt 
     * @param {Integer} duplicatedTimeOpt 
     * @param {Pointer<Int32>} rawOffset 
     * @param {Pointer<Int32>} dstOffset 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucal_getTimeZoneOffsetFromLocal(cal, nonExistingTimeOpt, duplicatedTimeOpt, rawOffset, dstOffset, status) {
        DllCall("icu.dll\ucal_getTimeZoneOffsetFromLocal", "ptr", cal, "int", nonExistingTimeOpt, "int", duplicatedTimeOpt, "int*", rawOffset, "int*", dstOffset, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} loc 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_open(loc, status) {
        loc := loc is String ? StrPtr(loc) : loc

        result := DllCall("icuin.dll\ucol_open", "ptr", loc, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} rules 
     * @param {Integer} rulesLength 
     * @param {Integer} normalizationMode 
     * @param {Integer} strength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_openRules(rules, rulesLength, normalizationMode, strength, parseError, status) {
        result := DllCall("icuin.dll\ucol_openRules", "ushort*", rules, "int", rulesLength, "int", normalizationMode, "int", strength, "ptr", parseError, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<USet>} contractions 
     * @param {Pointer<USet>} expansions 
     * @param {Integer} addPrefixes 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getContractionsAndExpansions(coll, contractions, expansions, addPrefixes, status) {
        DllCall("icuin.dll\ucol_getContractionsAndExpansions", "ptr", coll, "ptr", contractions, "ptr", expansions, "char", addPrefixes, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_close(coll) {
        DllCall("icuin.dll\ucol_close", "ptr", coll, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_strcoll(coll, source, sourceLength, target, targetLength) {
        result := DllCall("icuin.dll\ucol_strcoll", "ptr", coll, "ushort*", source, "int", sourceLength, "ushort*", target, "int", targetLength, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {PSTR} source 
     * @param {Integer} sourceLength 
     * @param {PSTR} target 
     * @param {Integer} targetLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_strcollUTF8(coll, source, sourceLength, target, targetLength, status) {
        source := source is String ? StrPtr(source) : source
        target := target is String ? StrPtr(target) : target

        result := DllCall("icuin.dll\ucol_strcollUTF8", "ptr", coll, "ptr", source, "int", sourceLength, "ptr", target, "int", targetLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_greater(coll, source, sourceLength, target, targetLength) {
        result := DllCall("icuin.dll\ucol_greater", "ptr", coll, "ushort*", source, "int", sourceLength, "ushort*", target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_greaterOrEqual(coll, source, sourceLength, target, targetLength) {
        result := DllCall("icuin.dll\ucol_greaterOrEqual", "ptr", coll, "ushort*", source, "int", sourceLength, "ushort*", target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UInt16>} target 
     * @param {Integer} targetLength 
     * @returns {Integer} 
     */
    static ucol_equal(coll, source, sourceLength, target, targetLength) {
        result := DllCall("icuin.dll\ucol_equal", "ptr", coll, "ushort*", source, "int", sourceLength, "ushort*", target, "int", targetLength, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UCharIterator>} sIter 
     * @param {Pointer<UCharIterator>} tIter 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_strcollIter(coll, sIter, tIter, status) {
        result := DllCall("icuin.dll\ucol_strcollIter", "ptr", coll, "ptr", sIter, "ptr", tIter, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @returns {Integer} 
     */
    static ucol_getStrength(coll) {
        result := DllCall("icuin.dll\ucol_getStrength", "ptr", coll, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} strength 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setStrength(coll, strength) {
        DllCall("icuin.dll\ucol_setStrength", "ptr", coll, "int", strength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Int32>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucol_getReorderCodes(coll, dest, destCapacity, pErrorCode) {
        result := DllCall("icuin.dll\ucol_getReorderCodes", "ptr", coll, "int*", dest, "int", destCapacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Int32>} reorderCodes 
     * @param {Integer} reorderCodesLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setReorderCodes(coll, reorderCodes, reorderCodesLength, pErrorCode) {
        DllCall("icuin.dll\ucol_setReorderCodes", "ptr", coll, "int*", reorderCodes, "int", reorderCodesLength, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Integer} reorderCode 
     * @param {Pointer<Int32>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static ucol_getEquivalentReorderCodes(reorderCode, dest, destCapacity, pErrorCode) {
        result := DllCall("icuin.dll\ucol_getEquivalentReorderCodes", "int", reorderCode, "int*", dest, "int", destCapacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} objLoc 
     * @param {PSTR} dispLoc 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getDisplayName(objLoc, dispLoc, result, resultLength, status) {
        objLoc := objLoc is String ? StrPtr(objLoc) : objLoc
        dispLoc := dispLoc is String ? StrPtr(dispLoc) : dispLoc

        result := DllCall("icuin.dll\ucol_getDisplayName", "ptr", objLoc, "ptr", dispLoc, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {PSTR} 
     */
    static ucol_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\ucol_getAvailable", "int", localeIndex, "CDecl char*")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ucol_countAvailable() {
        result := DllCall("icuin.dll\ucol_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucol_openAvailableLocales(status) {
        result := DllCall("icuin.dll\ucol_openAvailableLocales", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucol_getKeywords(status) {
        result := DllCall("icuin.dll\ucol_getKeywords", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} keyword 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucol_getKeywordValues(keyword, status) {
        keyword := keyword is String ? StrPtr(keyword) : keyword

        result := DllCall("icuin.dll\ucol_getKeywordValues", "ptr", keyword, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} key 
     * @param {PSTR} locale 
     * @param {Integer} commonlyUsed 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucol_getKeywordValuesForLocale(key, locale, commonlyUsed, status) {
        key := key is String ? StrPtr(key) : key
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\ucol_getKeywordValuesForLocale", "ptr", key, "ptr", locale, "char", commonlyUsed, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} result 
     * @param {Integer} resultCapacity 
     * @param {PSTR} keyword 
     * @param {PSTR} locale 
     * @param {Pointer<SByte>} isAvailable 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getFunctionalEquivalent(result, resultCapacity, keyword, locale, isAvailable, status) {
        result := result is String ? StrPtr(result) : result
        keyword := keyword is String ? StrPtr(keyword) : keyword
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\ucol_getFunctionalEquivalent", "ptr", result, "int", resultCapacity, "ptr", keyword, "ptr", locale, "char*", isAvailable, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Int32>} length 
     * @returns {Pointer<UInt16>} 
     */
    static ucol_getRules(coll, length) {
        result := DllCall("icuin.dll\ucol_getRules", "ptr", coll, "int*", length, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Byte>} result 
     * @param {Integer} resultLength 
     * @returns {Integer} 
     */
    static ucol_getSortKey(coll, source, sourceLength, result, resultLength) {
        result := DllCall("icuin.dll\ucol_getSortKey", "ptr", coll, "ushort*", source, "int", sourceLength, "char*", result, "int", resultLength, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UCharIterator>} iter 
     * @param {Pointer<UInt32>} state 
     * @param {Pointer<Byte>} dest 
     * @param {Integer} count 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_nextSortKeyPart(coll, iter, state, dest, count, status) {
        result := DllCall("icuin.dll\ucol_nextSortKeyPart", "ptr", coll, "ptr", iter, "uint*", state, "char*", dest, "int", count, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} source 
     * @param {Integer} sourceLength 
     * @param {Integer} boundType 
     * @param {Integer} noOfLevels 
     * @param {Pointer<Byte>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getBound(source, sourceLength, boundType, noOfLevels, result, resultLength, status) {
        result := DllCall("icuin.dll\ucol_getBound", "char*", source, "int", sourceLength, "int", boundType, "uint", noOfLevels, "char*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Byte>} info 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getVersion(coll, info) {
        DllCall("icuin.dll\ucol_getVersion", "ptr", coll, "char*", info, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Byte>} info 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_getUCAVersion(coll, info) {
        DllCall("icuin.dll\ucol_getUCAVersion", "ptr", coll, "char*", info, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} src1 
     * @param {Integer} src1Length 
     * @param {Pointer<Byte>} src2 
     * @param {Integer} src2Length 
     * @param {Pointer<Byte>} dest 
     * @param {Integer} destCapacity 
     * @returns {Integer} 
     */
    static ucol_mergeSortkeys(src1, src1Length, src2, src2Length, dest, destCapacity) {
        result := DllCall("icuin.dll\ucol_mergeSortkeys", "char*", src1, "int", src1Length, "char*", src2, "int", src2Length, "char*", dest, "int", destCapacity, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} attr 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setAttribute(coll, attr, value, status) {
        DllCall("icuin.dll\ucol_setAttribute", "ptr", coll, "int", attr, "int", value, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} attr 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getAttribute(coll, attr, status) {
        result := DllCall("icuin.dll\ucol_getAttribute", "ptr", coll, "int", attr, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} group 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setMaxVariable(coll, group, pErrorCode) {
        DllCall("icuin.dll\ucol_setMaxVariable", "ptr", coll, "int", group, "int*", pErrorCode, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @returns {Integer} 
     */
    static ucol_getMaxVariable(coll) {
        result := DllCall("icuin.dll\ucol_getMaxVariable", "ptr", coll, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_getVariableTop(coll, status) {
        result := DllCall("icuin.dll\ucol_getVariableTop", "ptr", coll, "int*", status, "CDecl uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Void>} stackBuffer 
     * @param {Pointer<Int32>} pBufferSize 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_safeClone(coll, stackBuffer, pBufferSize, status) {
        result := DllCall("icuin.dll\ucol_safeClone", "ptr", coll, "ptr", stackBuffer, "int*", pBufferSize, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_clone(coll, status) {
        result := DllCall("icu.dll\ucol_clone", "ptr", coll, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} delta 
     * @param {Pointer<UInt16>} buffer 
     * @param {Integer} bufferLen 
     * @returns {Integer} 
     */
    static ucol_getRulesEx(coll, delta, buffer, bufferLen) {
        result := DllCall("icuin.dll\ucol_getRulesEx", "ptr", coll, "int", delta, "ushort*", buffer, "int", bufferLen, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ucol_getLocaleByType(coll, type, status) {
        result := DllCall("icuin.dll\ucol_getLocaleByType", "ptr", coll, "int", type, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USet>} 
     */
    static ucol_getTailoredSet(coll, status) {
        result := DllCall("icuin.dll\ucol_getTailoredSet", "ptr", coll, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<Byte>} buffer 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_cloneBinary(coll, buffer, capacity, status) {
        result := DllCall("icuin.dll\ucol_cloneBinary", "ptr", coll, "char*", buffer, "int", capacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} bin 
     * @param {Integer} length 
     * @param {Pointer<UCollator>} base 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCollator>} 
     */
    static ucol_openBinary(bin, length, base, status) {
        result := DllCall("icuin.dll\ucol_openBinary", "char*", bin, "int", length, "ptr", base, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollator>} coll 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCollationElements>} 
     */
    static ucol_openElements(coll, text, textLength, status) {
        result := DllCall("icuin.dll\ucol_openElements", "ptr", coll, "ushort*", text, "int", textLength, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} key 
     * @param {Integer} length 
     * @returns {Integer} 
     */
    static ucol_keyHashCode(key, length) {
        result := DllCall("icuin.dll\ucol_keyHashCode", "char*", key, "int", length, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_closeElements(elems) {
        DllCall("icuin.dll\ucol_closeElements", "ptr", elems, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_reset(elems) {
        DllCall("icuin.dll\ucol_reset", "ptr", elems, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_next(elems, status) {
        result := DllCall("icuin.dll\ucol_next", "ptr", elems, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucol_previous(elems, status) {
        result := DllCall("icuin.dll\ucol_previous", "ptr", elems, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_getMaxExpansion(elems, order) {
        result := DllCall("icuin.dll\ucol_getMaxExpansion", "ptr", elems, "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setText(elems, text, textLength, status) {
        DllCall("icuin.dll\ucol_setText", "ptr", elems, "ushort*", text, "int", textLength, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @returns {Integer} 
     */
    static ucol_getOffset(elems) {
        result := DllCall("icuin.dll\ucol_getOffset", "ptr", elems, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCollationElements>} elems 
     * @param {Integer} offset 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucol_setOffset(elems, offset, status) {
        DllCall("icuin.dll\ucol_setOffset", "ptr", elems, "int", offset, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_primaryOrder(order) {
        result := DllCall("icuin.dll\ucol_primaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_secondaryOrder(order) {
        result := DllCall("icuin.dll\ucol_secondaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} order 
     * @returns {Integer} 
     */
    static ucol_tertiaryOrder(order) {
        result := DllCall("icuin.dll\ucol_tertiaryOrder", "int", order, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCharsetDetector>} 
     */
    static ucsdet_open(status) {
        result := DllCall("icuin.dll\ucsdet_open", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_close(ucsd) {
        DllCall("icuin.dll\ucsdet_close", "ptr", ucsd, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {PSTR} textIn 
     * @param {Integer} len 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_setText(ucsd, textIn, len, status) {
        textIn := textIn is String ? StrPtr(textIn) : textIn

        DllCall("icuin.dll\ucsdet_setText", "ptr", ucsd, "ptr", textIn, "int", len, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {PSTR} encoding 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucsdet_setDeclaredEncoding(ucsd, encoding, length, status) {
        encoding := encoding is String ? StrPtr(encoding) : encoding

        DllCall("icuin.dll\ucsdet_setDeclaredEncoding", "ptr", ucsd, "ptr", encoding, "int", length, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCharsetMatch>} 
     */
    static ucsdet_detect(ucsd, status) {
        result := DllCall("icuin.dll\ucsdet_detect", "ptr", ucsd, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {Pointer<Int32>} matchesFound 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UCharsetMatch>} 
     */
    static ucsdet_detectAll(ucsd, matchesFound, status) {
        result := DllCall("icuin.dll\ucsdet_detectAll", "ptr", ucsd, "int*", matchesFound, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetMatch>} ucsm 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ucsdet_getName(ucsm, status) {
        result := DllCall("icuin.dll\ucsdet_getName", "ptr", ucsm, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetMatch>} ucsm 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucsdet_getConfidence(ucsm, status) {
        result := DllCall("icuin.dll\ucsdet_getConfidence", "ptr", ucsm, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetMatch>} ucsm 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ucsdet_getLanguage(ucsm, status) {
        result := DllCall("icuin.dll\ucsdet_getLanguage", "ptr", ucsm, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetMatch>} ucsm 
     * @param {Pointer<UInt16>} buf 
     * @param {Integer} cap 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ucsdet_getUChars(ucsm, buf, cap, status) {
        result := DllCall("icuin.dll\ucsdet_getUChars", "ptr", ucsm, "ushort*", buf, "int", cap, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static ucsdet_getAllDetectableCharsets(ucsd, status) {
        result := DllCall("icuin.dll\ucsdet_getAllDetectableCharsets", "ptr", ucsd, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @returns {Integer} 
     */
    static ucsdet_isInputFilterEnabled(ucsd) {
        result := DllCall("icuin.dll\ucsdet_isInputFilterEnabled", "ptr", ucsd, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UCharsetDetector>} ucsd 
     * @param {Integer} filter 
     * @returns {Integer} 
     */
    static ucsdet_enableInputFilter(ucsd, filter) {
        result := DllCall("icuin.dll\ucsdet_enableInputFilter", "ptr", ucsd, "char", filter, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UFieldPositionIterator>} 
     */
    static ufieldpositer_open(status) {
        result := DllCall("icuin.dll\ufieldpositer_open", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufieldpositer_close(fpositer) {
        DllCall("icuin.dll\ufieldpositer_close", "ptr", fpositer, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @param {Pointer<Int32>} beginIndex 
     * @param {Pointer<Int32>} endIndex 
     * @returns {Integer} 
     */
    static ufieldpositer_next(fpositer, beginIndex, endIndex) {
        result := DllCall("icuin.dll\ufieldpositer_next", "ptr", fpositer, "int*", beginIndex, "int*", endIndex, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static ufmt_open(status) {
        result := DllCall("icuin.dll\ufmt_open", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ufmt_close(fmt) {
        DllCall("icuin.dll\ufmt_close", "ptr", fmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ufmt_getType(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getType", "ptr", fmt, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {Integer} 
     */
    static ufmt_isNumeric(fmt) {
        result := DllCall("icuin.dll\ufmt_isNumeric", "ptr", fmt, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static ufmt_getDate(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getDate", "ptr", fmt, "int*", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static ufmt_getDouble(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getDouble", "ptr", fmt, "int*", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ufmt_getLong(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getLong", "ptr", fmt, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ufmt_getInt64(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getInt64", "ptr", fmt, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static ufmt_getObject(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getObject", "ptr", fmt, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static ufmt_getUChars(fmt, len, status) {
        result := DllCall("icuin.dll\ufmt_getUChars", "ptr", fmt, "int*", len, "int*", status, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ufmt_getArrayLength(fmt, status) {
        result := DllCall("icuin.dll\ufmt_getArrayLength", "ptr", fmt, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} n 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static ufmt_getArrayItemByIndex(fmt, n, status) {
        result := DllCall("icuin.dll\ufmt_getArrayItemByIndex", "ptr", fmt, "int", n, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} len 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static ufmt_getDecNumChars(fmt, len, status) {
        result := DllCall("icuin.dll\ufmt_getDecNumChars", "ptr", fmt, "int*", len, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UConstrainedFieldPosition>} 
     */
    static ucfpos_open(ec) {
        result := DllCall("icu.dll\ucfpos_open", "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_reset(ucfpos, ec) {
        DllCall("icu.dll\ucfpos_reset", "ptr", ucfpos, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_close(ucfpos) {
        DllCall("icu.dll\ucfpos_close", "ptr", ucfpos, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} category 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_constrainCategory(ucfpos, category, ec) {
        DllCall("icu.dll\ucfpos_constrainCategory", "ptr", ucfpos, "int", category, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_constrainField(ucfpos, category, field, ec) {
        DllCall("icu.dll\ucfpos_constrainField", "ptr", ucfpos, "int", category, "int", field, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getCategory(ucfpos, ec) {
        result := DllCall("icu.dll\ucfpos_getCategory", "ptr", ucfpos, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getField(ucfpos, ec) {
        result := DllCall("icu.dll\ucfpos_getField", "ptr", ucfpos, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Int32>} pStart 
     * @param {Pointer<Int32>} pLimit 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_getIndexes(ucfpos, pStart, pLimit, ec) {
        DllCall("icu.dll\ucfpos_getIndexes", "ptr", ucfpos, "int*", pStart, "int*", pLimit, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucfpos_getInt64IterationContext(ucfpos, ec) {
        result := DllCall("icu.dll\ucfpos_getInt64IterationContext", "ptr", ucfpos, "int*", ec, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} context 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_setInt64IterationContext(ucfpos, context, ec) {
        DllCall("icu.dll\ucfpos_setInt64IterationContext", "ptr", ucfpos, "int64", context, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ucfpos_matchesField(ucfpos, category, field, ec) {
        result := DllCall("icu.dll\ucfpos_matchesField", "ptr", ucfpos, "int", category, "int", field, "int*", ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Integer} category 
     * @param {Integer} field 
     * @param {Integer} start 
     * @param {Integer} limit 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static ucfpos_setState(ucfpos, category, field, start, limit, ec) {
        DllCall("icu.dll\ucfpos_setState", "ptr", ucfpos, "int", category, "int", field, "int", start, "int", limit, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedValue>} ufmtval 
     * @param {Pointer<Int32>} pLength 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UInt16>} 
     */
    static ufmtval_getString(ufmtval, pLength, ec) {
        result := DllCall("icu.dll\ufmtval_getString", "ptr", ufmtval, "int*", pLength, "int*", ec, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedValue>} ufmtval 
     * @param {Pointer<UConstrainedFieldPosition>} ucfpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static ufmtval_nextPosition(ufmtval, ucfpos, ec) {
        result := DllCall("icu.dll\ufmtval_nextPosition", "ptr", ufmtval, "ptr", ucfpos, "int*", ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<UInt16>} tzID 
     * @param {Integer} tzIDLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UDateIntervalFormat>} 
     */
    static udtitvfmt_open(locale, skeleton, skeletonLength, tzID, tzIDLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\udtitvfmt_open", "ptr", locale, "ushort*", skeleton, "int", skeletonLength, "ushort*", tzID, "int", tzIDLength, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_close(formatter) {
        DllCall("icuin.dll\udtitvfmt_close", "ptr", formatter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedDateInterval>} 
     */
    static udtitvfmt_openResult(ec) {
        result := DllCall("icu.dll\udtitvfmt_openResult", "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedDateInterval>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static udtitvfmt_resultAsValue(uresult, ec) {
        result := DllCall("icu.dll\udtitvfmt_resultAsValue", "ptr", uresult, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedDateInterval>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_closeResult(uresult) {
        DllCall("icu.dll\udtitvfmt_closeResult", "ptr", uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @param {Float} fromDate 
     * @param {Float} toDate 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udtitvfmt_format(formatter, fromDate, toDate, result, resultCapacity, position, status) {
        result := DllCall("icuin.dll\udtitvfmt_format", "ptr", formatter, "double", fromDate, "double", toDate, "ushort*", result, "int", resultCapacity, "ptr", position, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @param {Float} fromDate 
     * @param {Float} toDate 
     * @param {Pointer<UFormattedDateInterval>} result 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_formatToResult(formatter, fromDate, toDate, result, status) {
        DllCall("icu.dll\udtitvfmt_formatToResult", "ptr", formatter, "double", fromDate, "double", toDate, "ptr", result, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udtitvfmt_setContext(formatter, value, status) {
        DllCall("icu.dll\udtitvfmt_setContext", "ptr", formatter, "int", value, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UDateIntervalFormat>} formatter 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udtitvfmt_getContext(formatter, type, status) {
        result := DllCall("icu.dll\udtitvfmt_getContext", "ptr", formatter, "int", type, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UGenderInfo>} 
     */
    static ugender_getInstance(locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\ugender_getInstance", "ptr", locale, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UGenderInfo>} genderInfo 
     * @param {Pointer<Int32>} genders 
     * @param {Integer} size 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ugender_getListGender(genderInfo, genders, size, status) {
        result := DllCall("icuin.dll\ugender_getListGender", "ptr", genderInfo, "int*", genders, "int", size, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UListFormatter>} 
     */
    static ulistfmt_open(locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuuc.dll\ulistfmt_open", "ptr", locale, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Integer} type 
     * @param {Integer} width 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UListFormatter>} 
     */
    static ulistfmt_openForType(locale, type, width, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icu.dll\ulistfmt_openForType", "ptr", locale, "int", type, "int", width, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UListFormatter>} listfmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_close(listfmt) {
        DllCall("icuuc.dll\ulistfmt_close", "ptr", listfmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedList>} 
     */
    static ulistfmt_openResult(ec) {
        result := DllCall("icu.dll\ulistfmt_openResult", "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedList>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static ulistfmt_resultAsValue(uresult, ec) {
        result := DllCall("icu.dll\ulistfmt_resultAsValue", "ptr", uresult, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedList>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_closeResult(uresult) {
        DllCall("icu.dll\ulistfmt_closeResult", "ptr", uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UListFormatter>} listfmt 
     * @param {Pointer<UInt16>} strings 
     * @param {Pointer<Int32>} stringLengths 
     * @param {Integer} stringCount 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulistfmt_format(listfmt, strings, stringLengths, stringCount, result, resultCapacity, status) {
        result := DllCall("icuuc.dll\ulistfmt_format", "ptr", listfmt, "ushort*", strings, "int*", stringLengths, "int", stringCount, "ushort*", result, "int", resultCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UListFormatter>} listfmt 
     * @param {Pointer<UInt16>} strings 
     * @param {Pointer<Int32>} stringLengths 
     * @param {Integer} stringCount 
     * @param {Pointer<UFormattedList>} uresult 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulistfmt_formatStringsToResult(listfmt, strings, stringLengths, stringCount, uresult, status) {
        DllCall("icu.dll\ulistfmt_formatStringsToResult", "ptr", listfmt, "ushort*", strings, "int*", stringLengths, "int", stringCount, "ptr", uresult, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<ULocaleData>} 
     */
    static ulocdata_open(localeID, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuin.dll\ulocdata_open", "ptr", localeID, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_close(uld) {
        DllCall("icuin.dll\ulocdata_close", "ptr", uld, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Integer} setting 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_setNoSubstitute(uld, setting) {
        DllCall("icuin.dll\ulocdata_setNoSubstitute", "ptr", uld, "char", setting, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @returns {Integer} 
     */
    static ulocdata_getNoSubstitute(uld) {
        result := DllCall("icuin.dll\ulocdata_getNoSubstitute", "ptr", uld, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Pointer<USet>} fillIn 
     * @param {Integer} options 
     * @param {Integer} extype 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USet>} 
     */
    static ulocdata_getExemplarSet(uld, fillIn, options, extype, status) {
        result := DllCall("icuin.dll\ulocdata_getExemplarSet", "ptr", uld, "ptr", fillIn, "uint", options, "int", extype, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Integer} type 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulocdata_getDelimiter(uld, type, result, resultLength, status) {
        result := DllCall("icuin.dll\ulocdata_getDelimiter", "ptr", uld, "int", type, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulocdata_getMeasurementSystem(localeID, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        result := DllCall("icuin.dll\ulocdata_getMeasurementSystem", "ptr", localeID, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} localeID 
     * @param {Pointer<Int32>} height 
     * @param {Pointer<Int32>} width 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_getPaperSize(localeID, height, width, status) {
        localeID := localeID is String ? StrPtr(localeID) : localeID

        DllCall("icuin.dll\ulocdata_getPaperSize", "ptr", localeID, "int*", height, "int*", width, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Byte>} versionArray 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ulocdata_getCLDRVersion(versionArray, status) {
        DllCall("icuin.dll\ulocdata_getCLDRVersion", "char*", versionArray, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulocdata_getLocaleDisplayPattern(uld, pattern, patternCapacity, status) {
        result := DllCall("icuin.dll\ulocdata_getLocaleDisplayPattern", "ptr", uld, "ushort*", pattern, "int", patternCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<ULocaleData>} uld 
     * @param {Pointer<UInt16>} separator 
     * @param {Integer} separatorCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ulocdata_getLocaleSeparator(uld, separator, separatorCapacity, status) {
        result := DllCall("icuin.dll\ulocdata_getLocaleSeparator", "ptr", uld, "ushort*", separator, "int", separatorCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static u_formatMessage(locale, pattern, patternLength, result, resultLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\u_formatMessage", "ptr", locale, "ushort*", pattern, "int", patternLength, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static u_vformatMessage(locale, pattern, patternLength, result, resultLength, ap, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\u_vformatMessage", "ptr", locale, "ushort*", pattern, "int", patternLength, "ushort*", result, "int", resultLength, "char*", ap, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_parseMessage(locale, pattern, patternLength, source, sourceLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        DllCall("icuin.dll\u_parseMessage", "ptr", locale, "ushort*", pattern, "int", patternLength, "ushort*", source, "int", sourceLength, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_vparseMessage(locale, pattern, patternLength, source, sourceLength, ap, status) {
        locale := locale is String ? StrPtr(locale) : locale

        DllCall("icuin.dll\u_vparseMessage", "ptr", locale, "ushort*", pattern, "int", patternLength, "ushort*", source, "int", sourceLength, "char*", ap, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static u_formatMessageWithError(locale, pattern, patternLength, result, resultLength, parseError, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\u_formatMessageWithError", "ptr", locale, "ushort*", pattern, "int", patternLength, "ushort*", result, "int", resultLength, "ptr", parseError, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static u_vformatMessageWithError(locale, pattern, patternLength, result, resultLength, parseError, ap, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\u_vformatMessageWithError", "ptr", locale, "ushort*", pattern, "int", patternLength, "ushort*", result, "int", resultLength, "ptr", parseError, "char*", ap, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_parseMessageWithError(locale, pattern, patternLength, source, sourceLength, parseError, status) {
        locale := locale is String ? StrPtr(locale) : locale

        DllCall("icuin.dll\u_parseMessageWithError", "ptr", locale, "ushort*", pattern, "int", patternLength, "ushort*", source, "int", sourceLength, "ptr", parseError, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static u_vparseMessageWithError(locale, pattern, patternLength, source, sourceLength, ap, parseError, status) {
        locale := locale is String ? StrPtr(locale) : locale

        DllCall("icuin.dll\u_vparseMessageWithError", "ptr", locale, "ushort*", pattern, "int", patternLength, "ushort*", source, "int", sourceLength, "char*", ap, "ptr", parseError, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {PSTR} locale 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static umsg_open(pattern, patternLength, locale, parseError, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\umsg_open", "ushort*", pattern, "int", patternLength, "ptr", locale, "ptr", parseError, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_close(format) {
        DllCall("icuin.dll\umsg_close", "ptr", format, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static umsg_clone(fmt, status) {
        result := DllCall("icuin.dll\umsg_clone", "ptr", fmt, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {PSTR} locale 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_setLocale(fmt, locale) {
        locale := locale is String ? StrPtr(locale) : locale

        DllCall("icuin.dll\umsg_setLocale", "ptr", fmt, "ptr", locale, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {PSTR} 
     */
    static umsg_getLocale(fmt) {
        result := DllCall("icuin.dll\umsg_getLocale", "ptr", fmt, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_applyPattern(fmt, pattern, patternLength, parseError, status) {
        DllCall("icuin.dll\umsg_applyPattern", "ptr", fmt, "ushort*", pattern, "int", patternLength, "ptr", parseError, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static umsg_toPattern(fmt, result, resultLength, status) {
        result := DllCall("icuin.dll\umsg_toPattern", "ptr", fmt, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static umsg_format(fmt, result, resultLength, status) {
        result := DllCall("icuin.dll\umsg_format", "ptr", fmt, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static umsg_vformat(fmt, result, resultLength, ap, status) {
        result := DllCall("icuin.dll\umsg_vformat", "ptr", fmt, "ushort*", result, "int", resultLength, "char*", ap, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} count 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_parse(fmt, source, sourceLength, count, status) {
        DllCall("icuin.dll\umsg_parse", "ptr", fmt, "ushort*", source, "int", sourceLength, "int*", count, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} source 
     * @param {Integer} sourceLength 
     * @param {Pointer<Int32>} count 
     * @param {Pointer<SByte>} ap 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static umsg_vparse(fmt, source, sourceLength, count, ap, status) {
        DllCall("icuin.dll\umsg_vparse", "ptr", fmt, "ushort*", source, "int", sourceLength, "int*", count, "char*", ap, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static umsg_autoQuoteApostrophe(pattern, patternLength, dest, destCapacity, ec) {
        result := DllCall("icuin.dll\umsg_autoQuoteApostrophe", "ushort*", pattern, "int", patternLength, "ushort*", dest, "int", destCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} style 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {PSTR} locale 
     * @param {Pointer<UParseError>} parseErr 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static unum_open(style, pattern, patternLength, locale, parseErr, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\unum_open", "int", style, "ushort*", pattern, "int", patternLength, "ptr", locale, "ptr", parseErr, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_close(fmt) {
        DllCall("icuin.dll\unum_close", "ptr", fmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static unum_clone(fmt, status) {
        result := DllCall("icuin.dll\unum_clone", "ptr", fmt, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_format(fmt, number, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_format", "ptr", fmt, "int", number, "ushort*", result, "int", resultLength, "ptr", pos, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatInt64(fmt, number, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatInt64", "ptr", fmt, "int64", number, "ushort*", result, "int", resultLength, "ptr", pos, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Float} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatDouble(fmt, number, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatDouble", "ptr", fmt, "double", number, "ushort*", result, "int", resultLength, "ptr", pos, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Float} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatDoubleForFields(format, number, result, resultLength, fpositer, status) {
        result := DllCall("icuin.dll\unum_formatDoubleForFields", "ptr", format, "double", number, "ushort*", result, "int", resultLength, "ptr", fpositer, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {PSTR} number 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatDecimal(fmt, number, length, result, resultLength, pos, status) {
        number := number is String ? StrPtr(number) : number

        result := DllCall("icuin.dll\unum_formatDecimal", "ptr", fmt, "ptr", number, "int", length, "ushort*", result, "int", resultLength, "ptr", pos, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Float} number 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatDoubleCurrency(fmt, number, currency, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatDoubleCurrency", "ptr", fmt, "double", number, "ushort*", currency, "ushort*", result, "int", resultLength, "ptr", pos, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} number 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_formatUFormattable(fmt, number, result, resultLength, pos, status) {
        result := DllCall("icuin.dll\unum_formatUFormattable", "ptr", fmt, "ptr", number, "ushort*", result, "int", resultLength, "ptr", pos, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_parse(fmt, text, textLength, parsePos, status) {
        result := DllCall("icuin.dll\unum_parse", "ptr", fmt, "ushort*", text, "int", textLength, "int*", parsePos, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_parseInt64(fmt, text, textLength, parsePos, status) {
        result := DllCall("icuin.dll\unum_parseInt64", "ptr", fmt, "ushort*", text, "int", textLength, "int*", parsePos, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static unum_parseDouble(fmt, text, textLength, parsePos, status) {
        result := DllCall("icuin.dll\unum_parseDouble", "ptr", fmt, "ushort*", text, "int", textLength, "int*", parsePos, "int*", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {PSTR} outBuf 
     * @param {Integer} outBufLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_parseDecimal(fmt, text, textLength, parsePos, outBuf, outBufLength, status) {
        outBuf := outBuf is String ? StrPtr(outBuf) : outBuf

        result := DllCall("icuin.dll\unum_parseDecimal", "ptr", fmt, "ushort*", text, "int", textLength, "int*", parsePos, "ptr", outBuf, "int", outBufLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<UInt16>} currency 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static unum_parseDoubleCurrency(fmt, text, textLength, parsePos, currency, status) {
        result := DllCall("icuin.dll\unum_parseDoubleCurrency", "ptr", fmt, "ushort*", text, "int", textLength, "int*", parsePos, "ushort*", currency, "int*", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} result 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static unum_parseToUFormattable(fmt, result, text, textLength, parsePos, status) {
        result := DllCall("icuin.dll\unum_parseToUFormattable", "ptr", fmt, "ptr", result, "ushort*", text, "int", textLength, "int*", parsePos, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Integer} localized 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_applyPattern(format, localized, pattern, patternLength, parseError, status) {
        DllCall("icuin.dll\unum_applyPattern", "ptr", format, "char", localized, "ushort*", pattern, "int", patternLength, "ptr", parseError, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {PSTR} 
     */
    static unum_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\unum_getAvailable", "int", localeIndex, "CDecl char*")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static unum_countAvailable() {
        result := DllCall("icuin.dll\unum_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @returns {Integer} 
     */
    static unum_getAttribute(fmt, attr) {
        result := DllCall("icuin.dll\unum_getAttribute", "ptr", fmt, "int", attr, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setAttribute(fmt, attr, newValue) {
        DllCall("icuin.dll\unum_setAttribute", "ptr", fmt, "int", attr, "int", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @returns {Float} 
     */
    static unum_getDoubleAttribute(fmt, attr) {
        result := DllCall("icuin.dll\unum_getDoubleAttribute", "ptr", fmt, "int", attr, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @param {Float} newValue 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setDoubleAttribute(fmt, attr, newValue) {
        DllCall("icuin.dll\unum_setDoubleAttribute", "ptr", fmt, "int", attr, "double", newValue, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} tag 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_getTextAttribute(fmt, tag, result, resultLength, status) {
        result := DllCall("icuin.dll\unum_getTextAttribute", "ptr", fmt, "int", tag, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} tag 
     * @param {Pointer<UInt16>} newValue 
     * @param {Integer} newValueLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setTextAttribute(fmt, tag, newValue, newValueLength, status) {
        DllCall("icuin.dll\unum_setTextAttribute", "ptr", fmt, "int", tag, "ushort*", newValue, "int", newValueLength, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} isPatternLocalized 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_toPattern(fmt, isPatternLocalized, result, resultLength, status) {
        result := DllCall("icuin.dll\unum_toPattern", "ptr", fmt, "char", isPatternLocalized, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} symbol 
     * @param {Pointer<UInt16>} buffer 
     * @param {Integer} size 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_getSymbol(fmt, symbol, buffer, size, status) {
        result := DllCall("icuin.dll\unum_getSymbol", "ptr", fmt, "int", symbol, "ushort*", buffer, "int", size, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} symbol 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} length 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setSymbol(fmt, symbol, value, length, status) {
        DllCall("icuin.dll\unum_setSymbol", "ptr", fmt, "int", symbol, "ushort*", value, "int", length, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static unum_getLocaleByType(fmt, type, status) {
        result := DllCall("icuin.dll\unum_getLocaleByType", "ptr", fmt, "int", type, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static unum_setContext(fmt, value, status) {
        DllCall("icuin.dll\unum_setContext", "ptr", fmt, "int", value, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unum_getContext(fmt, type, status) {
        result := DllCall("icuin.dll\unum_getContext", "ptr", fmt, "int", type, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} field 
     * @returns {Integer} 
     */
    static udat_toCalendarDateField(field) {
        result := DllCall("icuin.dll\udat_toCalendarDateField", "int", field, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} timeStyle 
     * @param {Integer} dateStyle 
     * @param {PSTR} locale 
     * @param {Pointer<UInt16>} tzID 
     * @param {Integer} tzIDLength 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static udat_open(timeStyle, dateStyle, locale, tzID, tzIDLength, pattern, patternLength, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\udat_open", "int", timeStyle, "int", dateStyle, "ptr", locale, "ushort*", tzID, "int", tzIDLength, "ushort*", pattern, "int", patternLength, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_close(format) {
        DllCall("icuin.dll\udat_close", "ptr", format, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_getBooleanAttribute(fmt, attr, status) {
        result := DllCall("icuin.dll\udat_getBooleanAttribute", "ptr", fmt, "int", attr, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} attr 
     * @param {Integer} newValue 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setBooleanAttribute(fmt, attr, newValue, status) {
        DllCall("icuin.dll\udat_setBooleanAttribute", "ptr", fmt, "int", attr, "char", newValue, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static udat_clone(fmt, status) {
        result := DllCall("icuin.dll\udat_clone", "ptr", fmt, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Float} dateToFormat 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_format(format, dateToFormat, result, resultLength, position, status) {
        result := DllCall("icuin.dll\udat_format", "ptr", format, "double", dateToFormat, "ushort*", result, "int", resultLength, "ptr", position, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Pointer<Void>} calendar 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} capacity 
     * @param {Pointer<UFieldPosition>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_formatCalendar(format, calendar, result, capacity, position, status) {
        result := DllCall("icuin.dll\udat_formatCalendar", "ptr", format, "ptr", calendar, "ushort*", result, "int", capacity, "ptr", position, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Float} dateToFormat 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_formatForFields(format, dateToFormat, result, resultLength, fpositer, status) {
        result := DllCall("icuin.dll\udat_formatForFields", "ptr", format, "double", dateToFormat, "ushort*", result, "int", resultLength, "ptr", fpositer, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Pointer<Void>} calendar 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} capacity 
     * @param {Pointer<UFieldPositionIterator>} fpositer 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_formatCalendarForFields(format, calendar, result, capacity, fpositer, status) {
        result := DllCall("icuin.dll\udat_formatCalendarForFields", "ptr", format, "ptr", calendar, "ushort*", result, "int", capacity, "ptr", fpositer, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static udat_parse(format, text, textLength, parsePos, status) {
        result := DllCall("icuin.dll\udat_parse", "ptr", format, "ushort*", text, "int", textLength, "int*", parsePos, "int*", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Pointer<Void>} calendar 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} parsePos 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_parseCalendar(format, calendar, text, textLength, parsePos, status) {
        DllCall("icuin.dll\udat_parseCalendar", "ptr", format, "ptr", calendar, "ushort*", text, "int", textLength, "int*", parsePos, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {Integer} 
     */
    static udat_isLenient(fmt) {
        result := DllCall("icuin.dll\udat_isLenient", "ptr", fmt, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} isLenient 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setLenient(fmt, isLenient) {
        DllCall("icuin.dll\udat_setLenient", "ptr", fmt, "char", isLenient, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {Pointer<Void>} 
     */
    static udat_getCalendar(fmt) {
        result := DllCall("icuin.dll\udat_getCalendar", "ptr", fmt, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} calendarToSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setCalendar(fmt, calendarToSet) {
        DllCall("icuin.dll\udat_setCalendar", "ptr", fmt, "ptr", calendarToSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @returns {Pointer<Void>} 
     */
    static udat_getNumberFormat(fmt) {
        result := DllCall("icuin.dll\udat_getNumberFormat", "ptr", fmt, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} field 
     * @returns {Pointer<Void>} 
     */
    static udat_getNumberFormatForField(fmt, field) {
        result := DllCall("icuin.dll\udat_getNumberFormatForField", "ptr", fmt, "ushort", field, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<UInt16>} fields 
     * @param {Pointer<Void>} numberFormatToSet 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_adoptNumberFormatForFields(fmt, fields, numberFormatToSet, status) {
        DllCall("icuin.dll\udat_adoptNumberFormatForFields", "ptr", fmt, "ushort*", fields, "ptr", numberFormatToSet, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} numberFormatToSet 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setNumberFormat(fmt, numberFormatToSet) {
        DllCall("icuin.dll\udat_setNumberFormat", "ptr", fmt, "ptr", numberFormatToSet, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Void>} numberFormatToAdopt 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_adoptNumberFormat(fmt, numberFormatToAdopt) {
        DllCall("icuin.dll\udat_adoptNumberFormat", "ptr", fmt, "ptr", numberFormatToAdopt, "CDecl ")
    }

    /**
     * 
     * @param {Integer} localeIndex 
     * @returns {PSTR} 
     */
    static udat_getAvailable(localeIndex) {
        result := DllCall("icuin.dll\udat_getAvailable", "int", localeIndex, "CDecl char*")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static udat_countAvailable() {
        result := DllCall("icuin.dll\udat_countAvailable", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Pointer<Int32>} status 
     * @returns {Float} 
     */
    static udat_get2DigitYearStart(fmt, status) {
        result := DllCall("icuin.dll\udat_get2DigitYearStart", "ptr", fmt, "int*", status, "CDecl double")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Float} d 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_set2DigitYearStart(fmt, d, status) {
        DllCall("icuin.dll\udat_set2DigitYearStart", "ptr", fmt, "double", d, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} localized 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_toPattern(fmt, localized, result, resultLength, status) {
        result := DllCall("icuin.dll\udat_toPattern", "ptr", fmt, "char", localized, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Integer} localized 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_applyPattern(format, localized, pattern, patternLength) {
        DllCall("icuin.dll\udat_applyPattern", "ptr", format, "char", localized, "ushort*", pattern, "int", patternLength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Integer} symbolIndex 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_getSymbols(fmt, type, symbolIndex, result, resultLength, status) {
        result := DllCall("icuin.dll\udat_getSymbols", "ptr", fmt, "int", type, "int", symbolIndex, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @returns {Integer} 
     */
    static udat_countSymbols(fmt, type) {
        result := DllCall("icuin.dll\udat_countSymbols", "ptr", fmt, "int", type, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} format 
     * @param {Integer} type 
     * @param {Integer} symbolIndex 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} valueLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setSymbols(format, type, symbolIndex, value, valueLength, status) {
        DllCall("icuin.dll\udat_setSymbols", "ptr", format, "int", type, "int", symbolIndex, "ushort*", value, "int", valueLength, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static udat_getLocaleByType(fmt, type, status) {
        result := DllCall("icuin.dll\udat_getLocaleByType", "ptr", fmt, "int", type, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static udat_setContext(fmt, value, status) {
        DllCall("icuin.dll\udat_setContext", "ptr", fmt, "int", value, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} fmt 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static udat_getContext(fmt, type, status) {
        result := DllCall("icuin.dll\udat_getContext", "ptr", fmt, "int", type, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Void>} 
     */
    static udatpg_open(locale, pErrorCode) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\udatpg_open", "ptr", locale, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Void>} 
     */
    static udatpg_openEmpty(pErrorCode) {
        result := DllCall("icuin.dll\udatpg_openEmpty", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_close(dtpg) {
        DllCall("icuin.dll\udatpg_close", "ptr", dtpg, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Void>} 
     */
    static udatpg_clone(dtpg, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_clone", "ptr", dtpg, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} bestPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBestPattern(dtpg, skeleton, length, bestPattern, capacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_getBestPattern", "ptr", dtpg, "ushort*", skeleton, "int", length, "ushort*", bestPattern, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} length 
     * @param {Integer} options 
     * @param {Pointer<UInt16>} bestPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBestPatternWithOptions(dtpg, skeleton, length, options, bestPattern, capacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_getBestPatternWithOptions", "ptr", dtpg, "ushort*", skeleton, "int", length, "int", options, "ushort*", bestPattern, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} unusedDtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getSkeleton(unusedDtpg, pattern, length, skeleton, capacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_getSkeleton", "ptr", unusedDtpg, "ushort*", pattern, "int", length, "ushort*", skeleton, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} unusedDtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} baseSkeleton 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getBaseSkeleton(unusedDtpg, pattern, length, baseSkeleton, capacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_getBaseSkeleton", "ptr", unusedDtpg, "ushort*", pattern, "int", length, "ushort*", baseSkeleton, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} override 
     * @param {Pointer<UInt16>} conflictingPattern 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_addPattern(dtpg, pattern, patternLength, override, conflictingPattern, capacity, pLength, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_addPattern", "ptr", dtpg, "ushort*", pattern, "int", patternLength, "char", override, "ushort*", conflictingPattern, "int", capacity, "int*", pLength, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setAppendItemFormat(dtpg, field, value, length) {
        DllCall("icuin.dll\udatpg_setAppendItemFormat", "ptr", dtpg, "int", field, "ushort*", value, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getAppendItemFormat(dtpg, field, pLength) {
        result := DllCall("icuin.dll\udatpg_getAppendItemFormat", "ptr", dtpg, "int", field, "int*", pLength, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<UInt16>} value 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setAppendItemName(dtpg, field, value, length) {
        DllCall("icuin.dll\udatpg_setAppendItemName", "ptr", dtpg, "int", field, "ushort*", value, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getAppendItemName(dtpg, field, pLength) {
        result := DllCall("icuin.dll\udatpg_getAppendItemName", "ptr", dtpg, "int", field, "int*", pLength, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Integer} field 
     * @param {Integer} width 
     * @param {Pointer<UInt16>} fieldName 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getFieldDisplayName(dtpg, field, width, fieldName, capacity, pErrorCode) {
        result := DllCall("icu.dll\udatpg_getFieldDisplayName", "ptr", dtpg, "int", field, "int", width, "ushort*", fieldName, "int", capacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} dtFormat 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setDateTimeFormat(dtpg, dtFormat, length) {
        DllCall("icuin.dll\udatpg_setDateTimeFormat", "ptr", dtpg, "ushort*", dtFormat, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getDateTimeFormat(dtpg, pLength) {
        result := DllCall("icuin.dll\udatpg_getDateTimeFormat", "ptr", dtpg, "int*", pLength, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} decimal 
     * @param {Integer} length 
     * @returns {String} Nothing - always returns an empty string
     */
    static udatpg_setDecimal(dtpg, decimal, length) {
        DllCall("icuin.dll\udatpg_setDecimal", "ptr", dtpg, "ushort*", decimal, "int", length, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getDecimal(dtpg, pLength) {
        result := DllCall("icuin.dll\udatpg_getDecimal", "ptr", dtpg, "int*", pLength, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_replaceFieldTypes(dtpg, pattern, patternLength, skeleton, skeletonLength, dest, destCapacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_replaceFieldTypes", "ptr", dtpg, "ushort*", pattern, "int", patternLength, "ushort*", skeleton, "int", skeletonLength, "ushort*", dest, "int", destCapacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Integer} options 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_replaceFieldTypesWithOptions(dtpg, pattern, patternLength, skeleton, skeletonLength, options, dest, destCapacity, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_replaceFieldTypesWithOptions", "ptr", dtpg, "ushort*", pattern, "int", patternLength, "ushort*", skeleton, "int", skeletonLength, "int", options, "ushort*", dest, "int", destCapacity, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static udatpg_openSkeletons(dtpg, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_openSkeletons", "ptr", dtpg, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static udatpg_openBaseSkeletons(dtpg, pErrorCode) {
        result := DllCall("icuin.dll\udatpg_openBaseSkeletons", "ptr", dtpg, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLength 
     * @param {Pointer<Int32>} pLength 
     * @returns {Pointer<UInt16>} 
     */
    static udatpg_getPatternForSkeleton(dtpg, skeleton, skeletonLength, pLength) {
        result := DllCall("icuin.dll\udatpg_getPatternForSkeleton", "ptr", dtpg, "ushort*", skeleton, "int", skeletonLength, "int*", pLength, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} dtpg 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Integer} 
     */
    static udatpg_getDefaultHourCycle(dtpg, pErrorCode) {
        result := DllCall("icu.dll\udatpg_getDefaultHourCycle", "ptr", dtpg, "int*", pErrorCode, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLen 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UNumberFormatter>} 
     */
    static unumf_openForSkeletonAndLocale(skeleton, skeletonLen, locale, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icu.dll\unumf_openForSkeletonAndLocale", "ushort*", skeleton, "int", skeletonLen, "ptr", locale, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLen 
     * @param {PSTR} locale 
     * @param {Pointer<UParseError>} perror 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UNumberFormatter>} 
     */
    static unumf_openForSkeletonAndLocaleWithError(skeleton, skeletonLen, locale, perror, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icu.dll\unumf_openForSkeletonAndLocaleWithError", "ushort*", skeleton, "int", skeletonLen, "ptr", locale, "ptr", perror, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedNumber>} 
     */
    static unumf_openResult(ec) {
        result := DllCall("icu.dll\unumf_openResult", "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberFormatter>} uformatter 
     * @param {Integer} value 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatInt(uformatter, value, uresult, ec) {
        DllCall("icu.dll\unumf_formatInt", "ptr", uformatter, "int64", value, "ptr", uresult, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UNumberFormatter>} uformatter 
     * @param {Float} value 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatDouble(uformatter, value, uresult, ec) {
        DllCall("icu.dll\unumf_formatDouble", "ptr", uformatter, "double", value, "ptr", uresult, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UNumberFormatter>} uformatter 
     * @param {PSTR} value 
     * @param {Integer} valueLen 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_formatDecimal(uformatter, value, valueLen, uresult, ec) {
        value := value is String ? StrPtr(value) : value

        DllCall("icu.dll\unumf_formatDecimal", "ptr", uformatter, "ptr", value, "int", valueLen, "ptr", uresult, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static unumf_resultAsValue(uresult, ec) {
        result := DllCall("icu.dll\unumf_resultAsValue", "ptr", uresult, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<UInt16>} buffer 
     * @param {Integer} bufferCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static unumf_resultToString(uresult, buffer, bufferCapacity, ec) {
        result := DllCall("icu.dll\unumf_resultToString", "ptr", uresult, "ushort*", buffer, "int", bufferCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<UFieldPosition>} ufpos 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static unumf_resultNextFieldPosition(uresult, ufpos, ec) {
        result := DllCall("icu.dll\unumf_resultNextFieldPosition", "ptr", uresult, "ptr", ufpos, "int*", ec, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {Pointer<UFieldPositionIterator>} ufpositer 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_resultGetAllFieldPositions(uresult, ufpositer, ec) {
        DllCall("icu.dll\unumf_resultGetAllFieldPositions", "ptr", uresult, "ptr", ufpositer, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static unumf_resultToDecimalNumber(uresult, dest, destCapacity, ec) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icu.dll\unumf_resultToDecimalNumber", "ptr", uresult, "ptr", dest, "int", destCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberFormatter>} uformatter 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_close(uformatter) {
        DllCall("icu.dll\unumf_close", "ptr", uformatter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumber>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumf_closeResult(uresult) {
        DllCall("icu.dll\unumf_closeResult", "ptr", uresult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} skeleton 
     * @param {Integer} skeletonLen 
     * @param {Integer} collapse 
     * @param {Integer} identityFallback 
     * @param {PSTR} locale 
     * @param {Pointer<UParseError>} perror 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UNumberRangeFormatter>} 
     */
    static unumrf_openForSkeletonWithCollapseAndIdentityFallback(skeleton, skeletonLen, collapse, identityFallback, locale, perror, ec) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icu.dll\unumrf_openForSkeletonWithCollapseAndIdentityFallback", "ushort*", skeleton, "int", skeletonLen, "int", collapse, "int", identityFallback, "ptr", locale, "ptr", perror, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedNumberRange>} 
     */
    static unumrf_openResult(ec) {
        result := DllCall("icu.dll\unumrf_openResult", "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberRangeFormatter>} uformatter 
     * @param {Float} first 
     * @param {Float} second 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumrf_formatDoubleRange(uformatter, first, second, uresult, ec) {
        DllCall("icu.dll\unumrf_formatDoubleRange", "ptr", uformatter, "double", first, "double", second, "ptr", uresult, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UNumberRangeFormatter>} uformatter 
     * @param {PSTR} first 
     * @param {Integer} firstLen 
     * @param {PSTR} second 
     * @param {Integer} secondLen 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumrf_formatDecimalRange(uformatter, first, firstLen, second, secondLen, uresult, ec) {
        first := first is String ? StrPtr(first) : first
        second := second is String ? StrPtr(second) : second

        DllCall("icu.dll\unumrf_formatDecimalRange", "ptr", uformatter, "ptr", first, "int", firstLen, "ptr", second, "int", secondLen, "ptr", uresult, "int*", ec, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static unumrf_resultAsValue(uresult, ec) {
        result := DllCall("icu.dll\unumrf_resultAsValue", "ptr", uresult, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static unumrf_resultGetIdentityResult(uresult, ec) {
        result := DllCall("icu.dll\unumrf_resultGetIdentityResult", "ptr", uresult, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static unumrf_resultGetFirstDecimalNumber(uresult, dest, destCapacity, ec) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icu.dll\unumrf_resultGetFirstDecimalNumber", "ptr", uresult, "ptr", dest, "int", destCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} ec 
     * @returns {Integer} 
     */
    static unumrf_resultGetSecondDecimalNumber(uresult, dest, destCapacity, ec) {
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icu.dll\unumrf_resultGetSecondDecimalNumber", "ptr", uresult, "ptr", dest, "int", destCapacity, "int*", ec, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberRangeFormatter>} uformatter 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumrf_close(uformatter) {
        DllCall("icu.dll\unumrf_close", "ptr", uformatter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UFormattedNumberRange>} uresult 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumrf_closeResult(uresult) {
        DllCall("icu.dll\unumrf_closeResult", "ptr", uresult, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UNumberingSystem>} 
     */
    static unumsys_open(locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\unumsys_open", "ptr", locale, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} name 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UNumberingSystem>} 
     */
    static unumsys_openByName(name, status) {
        name := name is String ? StrPtr(name) : name

        result := DllCall("icuin.dll\unumsys_openByName", "ptr", name, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @returns {String} Nothing - always returns an empty string
     */
    static unumsys_close(unumsys) {
        DllCall("icuin.dll\unumsys_close", "ptr", unumsys, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static unumsys_openAvailableNames(status) {
        result := DllCall("icuin.dll\unumsys_openAvailableNames", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @returns {PSTR} 
     */
    static unumsys_getName(unumsys) {
        result := DllCall("icuin.dll\unumsys_getName", "ptr", unumsys, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @returns {Integer} 
     */
    static unumsys_isAlgorithmic(unumsys) {
        result := DllCall("icuin.dll\unumsys_isAlgorithmic", "ptr", unumsys, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @returns {Integer} 
     */
    static unumsys_getRadix(unumsys) {
        result := DllCall("icuin.dll\unumsys_getRadix", "ptr", unumsys, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UNumberingSystem>} unumsys 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static unumsys_getDescription(unumsys, result, resultLength, status) {
        result := DllCall("icuin.dll\unumsys_getDescription", "ptr", unumsys, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UPluralRules>} 
     */
    static uplrules_open(locale, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\uplrules_open", "ptr", locale, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UPluralRules>} 
     */
    static uplrules_openForType(locale, type, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\uplrules_openForType", "ptr", locale, "int", type, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UPluralRules>} uplrules 
     * @returns {String} Nothing - always returns an empty string
     */
    static uplrules_close(uplrules) {
        DllCall("icuin.dll\uplrules_close", "ptr", uplrules, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UPluralRules>} uplrules 
     * @param {Float} number 
     * @param {Pointer<UInt16>} keyword 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uplrules_select(uplrules, number, keyword, capacity, status) {
        result := DllCall("icuin.dll\uplrules_select", "ptr", uplrules, "double", number, "ushort*", keyword, "int", capacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UPluralRules>} uplrules 
     * @param {Pointer<UFormattedNumber>} number 
     * @param {Pointer<UInt16>} keyword 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uplrules_selectFormatted(uplrules, number, keyword, capacity, status) {
        result := DllCall("icu.dll\uplrules_selectFormatted", "ptr", uplrules, "ptr", number, "ushort*", keyword, "int", capacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UPluralRules>} uplrules 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uplrules_getKeywords(uplrules, status) {
        result := DllCall("icuin.dll\uplrules_getKeywords", "ptr", uplrules, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternLength 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<URegularExpression>} 
     */
    static uregex_open(pattern, patternLength, flags, pe, status) {
        result := DllCall("icuin.dll\uregex_open", "ushort*", pattern, "int", patternLength, "uint", flags, "ptr", pe, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UText>} pattern 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<URegularExpression>} 
     */
    static uregex_openUText(pattern, flags, pe, status) {
        result := DllCall("icuin.dll\uregex_openUText", "ptr", pattern, "uint", flags, "ptr", pe, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} pattern 
     * @param {Integer} flags 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<URegularExpression>} 
     */
    static uregex_openC(pattern, flags, pe, status) {
        pattern := pattern is String ? StrPtr(pattern) : pattern

        result := DllCall("icuin.dll\uregex_openC", "ptr", pattern, "uint", flags, "ptr", pe, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_close(regexp) {
        DllCall("icuin.dll\uregex_close", "ptr", regexp, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<URegularExpression>} 
     */
    static uregex_clone(regexp, status) {
        result := DllCall("icuin.dll\uregex_clone", "ptr", regexp, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} patLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static uregex_pattern(regexp, patLength, status) {
        result := DllCall("icuin.dll\uregex_pattern", "ptr", regexp, "int*", patLength, "int*", status, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_patternUText(regexp, status) {
        result := DllCall("icuin.dll\uregex_patternUText", "ptr", regexp, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_flags(regexp, status) {
        result := DllCall("icuin.dll\uregex_flags", "ptr", regexp, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setText(regexp, text, textLength, status) {
        DllCall("icuin.dll\uregex_setText", "ptr", regexp, "ushort*", text, "int", textLength, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setUText(regexp, text, status) {
        DllCall("icuin.dll\uregex_setUText", "ptr", regexp, "ptr", text, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} textLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UInt16>} 
     */
    static uregex_getText(regexp, textLength, status) {
        result := DllCall("icuin.dll\uregex_getText", "ptr", regexp, "int*", textLength, "int*", status, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_getUText(regexp, dest, status) {
        result := DllCall("icuin.dll\uregex_getUText", "ptr", regexp, "ptr", dest, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} text 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_refreshUText(regexp, text, status) {
        DllCall("icuin.dll\uregex_refreshUText", "ptr", regexp, "ptr", text, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_matches(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_matches", "ptr", regexp, "int", startIndex, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_matches64(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_matches64", "ptr", regexp, "int64", startIndex, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_lookingAt(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_lookingAt", "ptr", regexp, "int", startIndex, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_lookingAt64(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_lookingAt64", "ptr", regexp, "int64", startIndex, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_find(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_find", "ptr", regexp, "int", startIndex, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_find64(regexp, startIndex, status) {
        result := DllCall("icuin.dll\uregex_find64", "ptr", regexp, "int64", startIndex, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_findNext(regexp, status) {
        result := DllCall("icuin.dll\uregex_findNext", "ptr", regexp, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_groupCount(regexp, status) {
        result := DllCall("icuin.dll\uregex_groupCount", "ptr", regexp, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UInt16>} groupName 
     * @param {Integer} nameLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_groupNumberFromName(regexp, groupName, nameLength, status) {
        result := DllCall("icuin.dll\uregex_groupNumberFromName", "ptr", regexp, "ushort*", groupName, "int", nameLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {PSTR} groupName 
     * @param {Integer} nameLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_groupNumberFromCName(regexp, groupName, nameLength, status) {
        groupName := groupName is String ? StrPtr(groupName) : groupName

        result := DllCall("icuin.dll\uregex_groupNumberFromCName", "ptr", regexp, "ptr", groupName, "int", nameLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_group(regexp, groupNum, dest, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_group", "ptr", regexp, "int", groupNum, "ushort*", dest, "int", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int64>} groupLength 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_groupUText(regexp, groupNum, dest, groupLength, status) {
        result := DllCall("icuin.dll\uregex_groupUText", "ptr", regexp, "int", groupNum, "ptr", dest, "int64*", groupLength, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_start(regexp, groupNum, status) {
        result := DllCall("icuin.dll\uregex_start", "ptr", regexp, "int", groupNum, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_start64(regexp, groupNum, status) {
        result := DllCall("icuin.dll\uregex_start64", "ptr", regexp, "int", groupNum, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_end(regexp, groupNum, status) {
        result := DllCall("icuin.dll\uregex_end", "ptr", regexp, "int", groupNum, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} groupNum 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_end64(regexp, groupNum, status) {
        result := DllCall("icuin.dll\uregex_end64", "ptr", regexp, "int", groupNum, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} index 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_reset(regexp, index, status) {
        DllCall("icuin.dll\uregex_reset", "ptr", regexp, "int", index, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} index 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_reset64(regexp, index, status) {
        DllCall("icuin.dll\uregex_reset64", "ptr", regexp, "int64", index, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegion(regexp, regionStart, regionLimit, status) {
        DllCall("icuin.dll\uregex_setRegion", "ptr", regexp, "int", regionStart, "int", regionLimit, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegion64(regexp, regionStart, regionLimit, status) {
        DllCall("icuin.dll\uregex_setRegion64", "ptr", regexp, "int64", regionStart, "int64", regionLimit, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} regionStart 
     * @param {Integer} regionLimit 
     * @param {Integer} startIndex 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setRegionAndStart(regexp, regionStart, regionLimit, startIndex, status) {
        DllCall("icuin.dll\uregex_setRegionAndStart", "ptr", regexp, "int64", regionStart, "int64", regionLimit, "int64", startIndex, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_regionStart(regexp, status) {
        result := DllCall("icuin.dll\uregex_regionStart", "ptr", regexp, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_regionStart64(regexp, status) {
        result := DllCall("icuin.dll\uregex_regionStart64", "ptr", regexp, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_regionEnd(regexp, status) {
        result := DllCall("icuin.dll\uregex_regionEnd", "ptr", regexp, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_regionEnd64(regexp, status) {
        result := DllCall("icuin.dll\uregex_regionEnd64", "ptr", regexp, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_hasTransparentBounds(regexp, status) {
        result := DllCall("icuin.dll\uregex_hasTransparentBounds", "ptr", regexp, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} b 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_useTransparentBounds(regexp, b, status) {
        DllCall("icuin.dll\uregex_useTransparentBounds", "ptr", regexp, "char", b, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_hasAnchoringBounds(regexp, status) {
        result := DllCall("icuin.dll\uregex_hasAnchoringBounds", "ptr", regexp, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} b 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_useAnchoringBounds(regexp, b, status) {
        DllCall("icuin.dll\uregex_useAnchoringBounds", "ptr", regexp, "char", b, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_hitEnd(regexp, status) {
        result := DllCall("icuin.dll\uregex_hitEnd", "ptr", regexp, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_requireEnd(regexp, status) {
        result := DllCall("icuin.dll\uregex_requireEnd", "ptr", regexp, "int*", status, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UInt16>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_replaceAll(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_replaceAll", "ptr", regexp, "ushort*", replacementText, "int", replacementLength, "ushort*", destBuf, "int", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} replacement 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_replaceAllUText(regexp, replacement, dest, status) {
        result := DllCall("icuin.dll\uregex_replaceAllUText", "ptr", regexp, "ptr", replacement, "ptr", dest, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UInt16>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_replaceFirst(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_replaceFirst", "ptr", regexp, "ushort*", replacementText, "int", replacementLength, "ushort*", destBuf, "int", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} replacement 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_replaceFirstUText(regexp, replacement, dest, status) {
        result := DllCall("icuin.dll\uregex_replaceFirstUText", "ptr", regexp, "ptr", replacement, "ptr", dest, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UInt16>} replacementText 
     * @param {Integer} replacementLength 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Pointer<Int32>} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_appendReplacement(regexp, replacementText, replacementLength, destBuf, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_appendReplacement", "ptr", regexp, "ushort*", replacementText, "int", replacementLength, "ushort*", destBuf, "int*", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} replacementText 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_appendReplacementUText(regexp, replacementText, dest, status) {
        DllCall("icuin.dll\uregex_appendReplacementUText", "ptr", regexp, "ptr", replacementText, "ptr", dest, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Pointer<Int32>} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_appendTail(regexp, destBuf, destCapacity, status) {
        result := DllCall("icuin.dll\uregex_appendTail", "ptr", regexp, "ushort*", destBuf, "int*", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} dest 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UText>} 
     */
    static uregex_appendTailUText(regexp, dest, status) {
        result := DllCall("icuin.dll\uregex_appendTailUText", "ptr", regexp, "ptr", dest, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UInt16>} destBuf 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} requiredCapacity 
     * @param {Pointer<UInt16>} destFields 
     * @param {Integer} destFieldsCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_split(regexp, destBuf, destCapacity, requiredCapacity, destFields, destFieldsCapacity, status) {
        result := DllCall("icuin.dll\uregex_split", "ptr", regexp, "ushort*", destBuf, "int", destCapacity, "int*", requiredCapacity, "ushort*", destFields, "int", destFieldsCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<UText>} destFields 
     * @param {Integer} destFieldsCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_splitUText(regexp, destFields, destFieldsCapacity, status) {
        result := DllCall("icuin.dll\uregex_splitUText", "ptr", regexp, "ptr", destFields, "int", destFieldsCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} limit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setTimeLimit(regexp, limit, status) {
        DllCall("icuin.dll\uregex_setTimeLimit", "ptr", regexp, "int", limit, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_getTimeLimit(regexp, status) {
        result := DllCall("icuin.dll\uregex_getTimeLimit", "ptr", regexp, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Integer} limit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setStackLimit(regexp, limit, status) {
        DllCall("icuin.dll\uregex_setStackLimit", "ptr", regexp, "int", limit, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uregex_getStackLimit(regexp, status) {
        result := DllCall("icuin.dll\uregex_getStackLimit", "ptr", regexp, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<URegexMatchCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setMatchCallback(regexp, callback, context, status) {
        DllCall("icuin.dll\uregex_setMatchCallback", "ptr", regexp, "ptr", callback, "ptr", context, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<URegexMatchCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_getMatchCallback(regexp, callback, context, status) {
        DllCall("icuin.dll\uregex_getMatchCallback", "ptr", regexp, "ptr", callback, "ptr", context, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<URegexFindProgressCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_setFindProgressCallback(regexp, callback, context, status) {
        DllCall("icuin.dll\uregex_setFindProgressCallback", "ptr", regexp, "ptr", callback, "ptr", context, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URegularExpression>} regexp 
     * @param {Pointer<URegexFindProgressCallback>} callback 
     * @param {Pointer<Void>} context 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uregex_getFindProgressCallback(regexp, callback, context, status) {
        DllCall("icuin.dll\uregex_getFindProgressCallback", "ptr", regexp, "ptr", callback, "ptr", context, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {PSTR} regionCode 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<URegion>} 
     */
    static uregion_getRegionFromCode(regionCode, status) {
        regionCode := regionCode is String ? StrPtr(regionCode) : regionCode

        result := DllCall("icuin.dll\uregion_getRegionFromCode", "ptr", regionCode, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} code 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<URegion>} 
     */
    static uregion_getRegionFromNumericCode(code, status) {
        result := DllCall("icuin.dll\uregion_getRegionFromNumericCode", "int", code, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uregion_getAvailable(type, status) {
        result := DllCall("icuin.dll\uregion_getAvailable", "int", type, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Pointer<URegion>} otherRegion 
     * @returns {Integer} 
     */
    static uregion_areEqual(uregion, otherRegion) {
        result := DllCall("icuin.dll\uregion_areEqual", "ptr", uregion, "ptr", otherRegion, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @returns {Pointer<URegion>} 
     */
    static uregion_getContainingRegion(uregion) {
        result := DllCall("icuin.dll\uregion_getContainingRegion", "ptr", uregion, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Integer} type 
     * @returns {Pointer<URegion>} 
     */
    static uregion_getContainingRegionOfType(uregion, type) {
        result := DllCall("icuin.dll\uregion_getContainingRegionOfType", "ptr", uregion, "int", type, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uregion_getContainedRegions(uregion, status) {
        result := DllCall("icuin.dll\uregion_getContainedRegions", "ptr", uregion, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Integer} type 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uregion_getContainedRegionsOfType(uregion, type, status) {
        result := DllCall("icuin.dll\uregion_getContainedRegionsOfType", "ptr", uregion, "int", type, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Pointer<URegion>} otherRegion 
     * @returns {Integer} 
     */
    static uregion_contains(uregion, otherRegion) {
        result := DllCall("icuin.dll\uregion_contains", "ptr", uregion, "ptr", otherRegion, "CDecl char")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UEnumeration>} 
     */
    static uregion_getPreferredValues(uregion, status) {
        result := DllCall("icuin.dll\uregion_getPreferredValues", "ptr", uregion, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @returns {PSTR} 
     */
    static uregion_getRegionCode(uregion) {
        result := DllCall("icuin.dll\uregion_getRegionCode", "ptr", uregion, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @returns {Integer} 
     */
    static uregion_getNumericCode(uregion) {
        result := DllCall("icuin.dll\uregion_getNumericCode", "ptr", uregion, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URegion>} uregion 
     * @returns {Integer} 
     */
    static uregion_getType(uregion) {
        result := DllCall("icuin.dll\uregion_getType", "ptr", uregion, "CDecl int")
        return result
    }

    /**
     * 
     * @param {PSTR} locale 
     * @param {Pointer<Void>} nfToAdopt 
     * @param {Integer} width 
     * @param {Integer} capitalizationContext 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<URelativeDateTimeFormatter>} 
     */
    static ureldatefmt_open(locale, nfToAdopt, width, capitalizationContext, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\ureldatefmt_open", "ptr", locale, "ptr", nfToAdopt, "int", width, "int", capitalizationContext, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_close(reldatefmt) {
        DllCall("icuin.dll\ureldatefmt_close", "ptr", reldatefmt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedRelativeDateTime>} 
     */
    static ureldatefmt_openResult(ec) {
        result := DllCall("icu.dll\ureldatefmt_openResult", "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedRelativeDateTime>} ufrdt 
     * @param {Pointer<Int32>} ec 
     * @returns {Pointer<UFormattedValue>} 
     */
    static ureldatefmt_resultAsValue(ufrdt, ec) {
        result := DllCall("icu.dll\ureldatefmt_resultAsValue", "ptr", ufrdt, "int*", ec, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UFormattedRelativeDateTime>} ufrdt 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_closeResult(ufrdt) {
        DllCall("icu.dll\ureldatefmt_closeResult", "ptr", ufrdt, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_formatNumeric(reldatefmt, offset, unit, result, resultCapacity, status) {
        result := DllCall("icuin.dll\ureldatefmt_formatNumeric", "ptr", reldatefmt, "double", offset, "int", unit, "ushort*", result, "int", resultCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<UFormattedRelativeDateTime>} result 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_formatNumericToResult(reldatefmt, offset, unit, result, status) {
        DllCall("icu.dll\ureldatefmt_formatNumericToResult", "ptr", reldatefmt, "double", offset, "int", unit, "ptr", result, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_format(reldatefmt, offset, unit, result, resultCapacity, status) {
        result := DllCall("icuin.dll\ureldatefmt_format", "ptr", reldatefmt, "double", offset, "int", unit, "ushort*", result, "int", resultCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Float} offset 
     * @param {Integer} unit 
     * @param {Pointer<UFormattedRelativeDateTime>} result 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static ureldatefmt_formatToResult(reldatefmt, offset, unit, result, status) {
        DllCall("icu.dll\ureldatefmt_formatToResult", "ptr", reldatefmt, "double", offset, "int", unit, "ptr", result, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<URelativeDateTimeFormatter>} reldatefmt 
     * @param {Pointer<UInt16>} relativeDateString 
     * @param {Integer} relativeDateStringLen 
     * @param {Pointer<UInt16>} timeString 
     * @param {Integer} timeStringLen 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static ureldatefmt_combineDateAndTime(reldatefmt, relativeDateString, relativeDateStringLen, timeString, timeStringLen, result, resultCapacity, status) {
        result := DllCall("icuin.dll\ureldatefmt_combineDateAndTime", "ptr", reldatefmt, "ushort*", relativeDateString, "int", relativeDateStringLen, "ushort*", timeString, "int", timeStringLen, "ushort*", result, "int", resultCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textlength 
     * @param {PSTR} locale 
     * @param {Pointer<UBreakIterator>} breakiter 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UStringSearch>} 
     */
    static usearch_open(pattern, patternlength, text, textlength, locale, breakiter, status) {
        locale := locale is String ? StrPtr(locale) : locale

        result := DllCall("icuin.dll\usearch_open", "ushort*", pattern, "int", patternlength, "ushort*", text, "int", textlength, "ptr", locale, "ptr", breakiter, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textlength 
     * @param {Pointer<UCollator>} collator 
     * @param {Pointer<UBreakIterator>} breakiter 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<UStringSearch>} 
     */
    static usearch_openFromCollator(pattern, patternlength, text, textlength, collator, breakiter, status) {
        result := DllCall("icuin.dll\usearch_openFromCollator", "ushort*", pattern, "int", patternlength, "ushort*", text, "int", textlength, "ptr", collator, "ptr", breakiter, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} searchiter 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_close(searchiter) {
        DllCall("icuin.dll\usearch_close", "ptr", searchiter, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setOffset(strsrch, position, status) {
        DllCall("icuin.dll\usearch_setOffset", "ptr", strsrch, "int", position, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getOffset(strsrch) {
        result := DllCall("icuin.dll\usearch_getOffset", "ptr", strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} attribute 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setAttribute(strsrch, attribute, value, status) {
        DllCall("icuin.dll\usearch_setAttribute", "ptr", strsrch, "int", attribute, "int", value, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} attribute 
     * @returns {Integer} 
     */
    static usearch_getAttribute(strsrch, attribute) {
        result := DllCall("icuin.dll\usearch_getAttribute", "ptr", strsrch, "int", attribute, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getMatchedStart(strsrch) {
        result := DllCall("icuin.dll\usearch_getMatchedStart", "ptr", strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Integer} 
     */
    static usearch_getMatchedLength(strsrch) {
        result := DllCall("icuin.dll\usearch_getMatchedLength", "ptr", strsrch, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_getMatchedText(strsrch, result, resultCapacity, status) {
        result := DllCall("icuin.dll\usearch_getMatchedText", "ptr", strsrch, "ushort*", result, "int", resultCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<UBreakIterator>} breakiter 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setBreakIterator(strsrch, breakiter, status) {
        DllCall("icuin.dll\usearch_setBreakIterator", "ptr", strsrch, "ptr", breakiter, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Pointer<UBreakIterator>} 
     */
    static usearch_getBreakIterator(strsrch) {
        result := DllCall("icuin.dll\usearch_getBreakIterator", "ptr", strsrch, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<UInt16>} text 
     * @param {Integer} textlength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setText(strsrch, text, textlength, status) {
        DllCall("icuin.dll\usearch_setText", "ptr", strsrch, "ushort*", text, "int", textlength, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Int32>} length 
     * @returns {Pointer<UInt16>} 
     */
    static usearch_getText(strsrch, length) {
        result := DllCall("icuin.dll\usearch_getText", "ptr", strsrch, "int*", length, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {Pointer<UCollator>} 
     */
    static usearch_getCollator(strsrch) {
        result := DllCall("icuin.dll\usearch_getCollator", "ptr", strsrch, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<UCollator>} collator 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setCollator(strsrch, collator, status) {
        DllCall("icuin.dll\usearch_setCollator", "ptr", strsrch, "ptr", collator, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<UInt16>} pattern 
     * @param {Integer} patternlength 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_setPattern(strsrch, pattern, patternlength, status) {
        DllCall("icuin.dll\usearch_setPattern", "ptr", strsrch, "ushort*", pattern, "int", patternlength, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Int32>} length 
     * @returns {Pointer<UInt16>} 
     */
    static usearch_getPattern(strsrch, length) {
        result := DllCall("icuin.dll\usearch_getPattern", "ptr", strsrch, "int*", length, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_first(strsrch, status) {
        result := DllCall("icuin.dll\usearch_first", "ptr", strsrch, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_following(strsrch, position, status) {
        result := DllCall("icuin.dll\usearch_following", "ptr", strsrch, "int", position, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_last(strsrch, status) {
        result := DllCall("icuin.dll\usearch_last", "ptr", strsrch, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Integer} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_preceding(strsrch, position, status) {
        result := DllCall("icuin.dll\usearch_preceding", "ptr", strsrch, "int", position, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_next(strsrch, status) {
        result := DllCall("icuin.dll\usearch_next", "ptr", strsrch, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static usearch_previous(strsrch, status) {
        result := DllCall("icuin.dll\usearch_previous", "ptr", strsrch, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<UStringSearch>} strsrch 
     * @returns {String} Nothing - always returns an empty string
     */
    static usearch_reset(strsrch) {
        DllCall("icuin.dll\usearch_reset", "ptr", strsrch, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USpoofChecker>} 
     */
    static uspoof_open(status) {
        result := DllCall("icuin.dll\uspoof_open", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} data 
     * @param {Integer} length 
     * @param {Pointer<Int32>} pActualLength 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<USpoofChecker>} 
     */
    static uspoof_openFromSerialized(data, length, pActualLength, pErrorCode) {
        result := DllCall("icuin.dll\uspoof_openFromSerialized", "ptr", data, "int", length, "int*", pActualLength, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {PSTR} confusables 
     * @param {Integer} confusablesLen 
     * @param {PSTR} confusablesWholeScript 
     * @param {Integer} confusablesWholeScriptLen 
     * @param {Pointer<Int32>} errType 
     * @param {Pointer<UParseError>} pe 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USpoofChecker>} 
     */
    static uspoof_openFromSource(confusables, confusablesLen, confusablesWholeScript, confusablesWholeScriptLen, errType, pe, status) {
        confusables := confusables is String ? StrPtr(confusables) : confusables
        confusablesWholeScript := confusablesWholeScript is String ? StrPtr(confusablesWholeScript) : confusablesWholeScript

        result := DllCall("icuin.dll\uspoof_openFromSource", "ptr", confusables, "int", confusablesLen, "ptr", confusablesWholeScript, "int", confusablesWholeScriptLen, "int*", errType, "ptr", pe, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_close(sc) {
        DllCall("icuin.dll\uspoof_close", "ptr", sc, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USpoofChecker>} 
     */
    static uspoof_clone(sc, status) {
        result := DllCall("icuin.dll\uspoof_clone", "ptr", sc, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Integer} checks 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setChecks(sc, checks, status) {
        DllCall("icuin.dll\uspoof_setChecks", "ptr", sc, "int", checks, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getChecks(sc, status) {
        result := DllCall("icuin.dll\uspoof_getChecks", "ptr", sc, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Integer} restrictionLevel 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setRestrictionLevel(sc, restrictionLevel) {
        DllCall("icuin.dll\uspoof_setRestrictionLevel", "ptr", sc, "int", restrictionLevel, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @returns {Integer} 
     */
    static uspoof_getRestrictionLevel(sc) {
        result := DllCall("icuin.dll\uspoof_getRestrictionLevel", "ptr", sc, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {PSTR} localesList 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setAllowedLocales(sc, localesList, status) {
        localesList := localesList is String ? StrPtr(localesList) : localesList

        DllCall("icuin.dll\uspoof_setAllowedLocales", "ptr", sc, "ptr", localesList, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Int32>} status 
     * @returns {PSTR} 
     */
    static uspoof_getAllowedLocales(sc, status) {
        result := DllCall("icuin.dll\uspoof_getAllowedLocales", "ptr", sc, "int*", status, "CDecl char*")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<USet>} chars 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_setAllowedChars(sc, chars, status) {
        DllCall("icuin.dll\uspoof_setAllowedChars", "ptr", sc, "ptr", chars, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USet>} 
     */
    static uspoof_getAllowedChars(sc, status) {
        result := DllCall("icuin.dll\uspoof_getAllowedChars", "ptr", sc, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} length 
     * @param {Pointer<Int32>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_check(sc, id, length, position, status) {
        result := DllCall("icuin.dll\uspoof_check", "ptr", sc, "ushort*", id, "int", length, "int*", position, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {PSTR} id 
     * @param {Integer} length 
     * @param {Pointer<Int32>} position 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_checkUTF8(sc, id, length, position, status) {
        id := id is String ? StrPtr(id) : id

        result := DllCall("icuin.dll\uspoof_checkUTF8", "ptr", sc, "ptr", id, "int", length, "int*", position, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} length 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_check2(sc, id, length, checkResult, status) {
        result := DllCall("icuin.dll\uspoof_check2", "ptr", sc, "ushort*", id, "int", length, "ptr", checkResult, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {PSTR} id 
     * @param {Integer} length 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_check2UTF8(sc, id, length, checkResult, status) {
        id := id is String ? StrPtr(id) : id

        result := DllCall("icuin.dll\uspoof_check2UTF8", "ptr", sc, "ptr", id, "int", length, "ptr", checkResult, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USpoofCheckResult>} 
     */
    static uspoof_openCheckResult(status) {
        result := DllCall("icuin.dll\uspoof_openCheckResult", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @returns {String} Nothing - always returns an empty string
     */
    static uspoof_closeCheckResult(checkResult) {
        DllCall("icuin.dll\uspoof_closeCheckResult", "ptr", checkResult, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getCheckResultChecks(checkResult, status) {
        result := DllCall("icuin.dll\uspoof_getCheckResultChecks", "ptr", checkResult, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getCheckResultRestrictionLevel(checkResult, status) {
        result := DllCall("icuin.dll\uspoof_getCheckResultRestrictionLevel", "ptr", checkResult, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofCheckResult>} checkResult 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USet>} 
     */
    static uspoof_getCheckResultNumerics(checkResult, status) {
        result := DllCall("icuin.dll\uspoof_getCheckResultNumerics", "ptr", checkResult, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<UInt16>} id1 
     * @param {Integer} length1 
     * @param {Pointer<UInt16>} id2 
     * @param {Integer} length2 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_areConfusable(sc, id1, length1, id2, length2, status) {
        result := DllCall("icuin.dll\uspoof_areConfusable", "ptr", sc, "ushort*", id1, "int", length1, "ushort*", id2, "int", length2, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {PSTR} id1 
     * @param {Integer} length1 
     * @param {PSTR} id2 
     * @param {Integer} length2 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_areConfusableUTF8(sc, id1, length1, id2, length2, status) {
        id1 := id1 is String ? StrPtr(id1) : id1
        id2 := id2 is String ? StrPtr(id2) : id2

        result := DllCall("icuin.dll\uspoof_areConfusableUTF8", "ptr", sc, "ptr", id1, "int", length1, "ptr", id2, "int", length2, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Integer} type 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} length 
     * @param {Pointer<UInt16>} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getSkeleton(sc, type, id, length, dest, destCapacity, status) {
        result := DllCall("icuin.dll\uspoof_getSkeleton", "ptr", sc, "uint", type, "ushort*", id, "int", length, "ushort*", dest, "int", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Integer} type 
     * @param {PSTR} id 
     * @param {Integer} length 
     * @param {PSTR} dest 
     * @param {Integer} destCapacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_getSkeletonUTF8(sc, type, id, length, dest, destCapacity, status) {
        id := id is String ? StrPtr(id) : id
        dest := dest is String ? StrPtr(dest) : dest

        result := DllCall("icuin.dll\uspoof_getSkeletonUTF8", "ptr", sc, "uint", type, "ptr", id, "int", length, "ptr", dest, "int", destCapacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USet>} 
     */
    static uspoof_getInclusionSet(status) {
        result := DllCall("icuin.dll\uspoof_getInclusionSet", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USet>} 
     */
    static uspoof_getRecommendedSet(status) {
        result := DllCall("icuin.dll\uspoof_getRecommendedSet", "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<USpoofChecker>} sc 
     * @param {Pointer<Void>} data 
     * @param {Integer} capacity 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static uspoof_serialize(sc, data, capacity, status) {
        result := DllCall("icuin.dll\uspoof_serialize", "ptr", sc, "ptr", data, "int", capacity, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Integer} timeScale 
     * @param {Integer} value 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utmscale_getTimeScaleValue(timeScale, value, status) {
        result := DllCall("icuin.dll\utmscale_getTimeScaleValue", "int", timeScale, "int", value, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Integer} otherTime 
     * @param {Integer} timeScale 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utmscale_fromInt64(otherTime, timeScale, status) {
        result := DllCall("icuin.dll\utmscale_fromInt64", "int64", otherTime, "int", timeScale, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Integer} universalTime 
     * @param {Integer} timeScale 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utmscale_toInt64(universalTime, timeScale, status) {
        result := DllCall("icuin.dll\utmscale_toInt64", "int64", universalTime, "int", timeScale, "int*", status, "CDecl int64")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} idLength 
     * @param {Integer} dir 
     * @param {Pointer<UInt16>} rules 
     * @param {Integer} rulesLength 
     * @param {Pointer<UParseError>} parseError 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<Void>} 
     */
    static utrans_openU(id, idLength, dir, rules, rulesLength, parseError, pErrorCode) {
        result := DllCall("icuin.dll\utrans_openU", "ushort*", id, "int", idLength, "int", dir, "ushort*", rules, "int", rulesLength, "ptr", parseError, "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static utrans_openInverse(trans, status) {
        result := DllCall("icuin.dll\utrans_openInverse", "ptr", trans, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<Void>} 
     */
    static utrans_clone(trans, status) {
        result := DllCall("icuin.dll\utrans_clone", "ptr", trans, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_close(trans) {
        DllCall("icuin.dll\utrans_close", "ptr", trans, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Int32>} resultLength 
     * @returns {Pointer<UInt16>} 
     */
    static utrans_getUnicodeID(trans, resultLength) {
        result := DllCall("icuin.dll\utrans_getUnicodeID", "ptr", trans, "int*", resultLength, "CDecl ushort*")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} adoptedTrans 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_register(adoptedTrans, status) {
        DllCall("icuin.dll\utrans_register", "ptr", adoptedTrans, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<UInt16>} id 
     * @param {Integer} idLength 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_unregisterID(id, idLength) {
        DllCall("icuin.dll\utrans_unregisterID", "ushort*", id, "int", idLength, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<UInt16>} filterPattern 
     * @param {Integer} filterPatternLen 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_setFilter(trans, filterPattern, filterPatternLen, status) {
        DllCall("icuin.dll\utrans_setFilter", "ptr", trans, "ushort*", filterPattern, "int", filterPatternLen, "int*", status, "CDecl ")
    }

    /**
     * 
     * @returns {Integer} 
     */
    static utrans_countAvailableIDs() {
        result := DllCall("icuin.dll\utrans_countAvailableIDs", "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Int32>} pErrorCode 
     * @returns {Pointer<UEnumeration>} 
     */
    static utrans_openIDs(pErrorCode) {
        result := DllCall("icuin.dll\utrans_openIDs", "int*", pErrorCode, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Void>} rep 
     * @param {Pointer<UReplaceableCallbacks>} repFunc 
     * @param {Integer} start 
     * @param {Pointer<Int32>} limit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_trans(trans, rep, repFunc, start, limit, status) {
        DllCall("icuin.dll\utrans_trans", "ptr", trans, "ptr", rep, "ptr", repFunc, "int", start, "int*", limit, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<Void>} rep 
     * @param {Pointer<UReplaceableCallbacks>} repFunc 
     * @param {Pointer<UTransPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transIncremental(trans, rep, repFunc, pos, status) {
        DllCall("icuin.dll\utrans_transIncremental", "ptr", trans, "ptr", rep, "ptr", repFunc, "ptr", pos, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<UInt16>} text 
     * @param {Pointer<Int32>} textLength 
     * @param {Integer} textCapacity 
     * @param {Integer} start 
     * @param {Pointer<Int32>} limit 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transUChars(trans, text, textLength, textCapacity, start, limit, status) {
        DllCall("icuin.dll\utrans_transUChars", "ptr", trans, "ushort*", text, "int*", textLength, "int", textCapacity, "int", start, "int*", limit, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Pointer<UInt16>} text 
     * @param {Pointer<Int32>} textLength 
     * @param {Integer} textCapacity 
     * @param {Pointer<UTransPosition>} pos 
     * @param {Pointer<Int32>} status 
     * @returns {String} Nothing - always returns an empty string
     */
    static utrans_transIncrementalUChars(trans, text, textLength, textCapacity, pos, status) {
        DllCall("icuin.dll\utrans_transIncrementalUChars", "ptr", trans, "ushort*", text, "int*", textLength, "int", textCapacity, "ptr", pos, "int*", status, "CDecl ")
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Integer} escapeUnprintable 
     * @param {Pointer<UInt16>} result 
     * @param {Integer} resultLength 
     * @param {Pointer<Int32>} status 
     * @returns {Integer} 
     */
    static utrans_toRules(trans, escapeUnprintable, result, resultLength, status) {
        result := DllCall("icuin.dll\utrans_toRules", "ptr", trans, "char", escapeUnprintable, "ushort*", result, "int", resultLength, "int*", status, "CDecl int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} trans 
     * @param {Integer} ignoreFilter 
     * @param {Pointer<USet>} fillIn 
     * @param {Pointer<Int32>} status 
     * @returns {Pointer<USet>} 
     */
    static utrans_getSourceSet(trans, ignoreFilter, fillIn, status) {
        result := DllCall("icuin.dll\utrans_getSourceSet", "ptr", trans, "char", ignoreFilter, "ptr", fillIn, "int*", status, "CDecl ptr")
        return result
    }

    /**
     * Determines the distance between the specified language code and the closest match in a list of languages.
     * @param {PWSTR} pszLanguage Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A [BCP-47](https://tools.ietf.org/html/bcp47) language tag that represents the candidate language.
     * @param {PWSTR} pszLanguagesList Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A character delimited list of [BCP-47](https://tools.ietf.org/html/bcp47) language tags to compare to the candidate language. This is typically the list of user languages.
     * @param {Integer} wchListDelimiter Type: **[wchar_t](/windows/win32/midl/wchar-t)**
     * 
     * The character used as a delimiter in the language list.
     * @param {Pointer<Double>} pClosestDistance Type: **[double](/windows/win32/midl/double)**
     * 
     * The distance between the candidate language and the closest language in the list.
     * @returns {HRESULT} Type: **[HRESULT](/windows/desktop/com/structure-of-com-error-codes)**
     * @see https://docs.microsoft.com/windows/win32/api//bcp47mrm/nf-bcp47mrm-getdistanceofclosestlanguageinlist
     */
    static GetDistanceOfClosestLanguageInList(pszLanguage, pszLanguagesList, wchListDelimiter, pClosestDistance) {
        pszLanguage := pszLanguage is String ? StrPtr(pszLanguage) : pszLanguage
        pszLanguagesList := pszLanguagesList is String ? StrPtr(pszLanguagesList) : pszLanguagesList

        result := DllCall("bcp47mrm.dll\GetDistanceOfClosestLanguageInList", "ptr", pszLanguage, "ptr", pszLanguagesList, "char", wchListDelimiter, "double*", pClosestDistance, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines whether a BCP-47 language tag is well-formed.
     * @param {PWSTR} pszTag Type: **[PCWSTR](/windows/win32/winprog/windows-data-types)**
     * 
     * A [BCP-47](https://tools.ietf.org/html/bcp47) language tag.
     * @returns {Integer} `true` if the language tag is well-formed as defined by [BCP-47](https://tools.ietf.org/html/bcp47), except when the language tag can never be valid according to BCP-47. Otherwise it returns `false`.
     * @see https://docs.microsoft.com/windows/win32/api//bcp47mrm/nf-bcp47mrm-iswellformedtag
     */
    static IsWellFormedTag(pszTag) {
        pszTag := pszTag is String ? StrPtr(pszTag) : pszTag

        result := DllCall("bcp47mrm.dll\IsWellFormedTag", "ptr", pszTag, "char")
        return result
    }

    /**
     * 
     * @param {Integer} Calendar 
     * @param {Pointer<CALDATETIME>} lpCalMinDateTime 
     * @param {Pointer<CALDATETIME>} lpCalMaxDateTime 
     * @returns {BOOL} 
     */
    static GetCalendarSupportedDateRange(Calendar, lpCalMinDateTime, lpCalMaxDateTime) {
        result := DllCall("KERNEL32.dll\GetCalendarSupportedDateRange", "uint", Calendar, "ptr", lpCalMinDateTime, "ptr", lpCalMaxDateTime, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} lpszLocale 
     * @param {Integer} dwFlags 
     * @param {Pointer<CALDATETIME>} lpCalDateTime 
     * @param {PWSTR} lpFormat 
     * @param {PWSTR} lpDateStr 
     * @param {Integer} cchDate 
     * @returns {BOOL} 
     */
    static GetCalendarDateFormatEx(lpszLocale, dwFlags, lpCalDateTime, lpFormat, lpDateStr, cchDate) {
        lpszLocale := lpszLocale is String ? StrPtr(lpszLocale) : lpszLocale
        lpFormat := lpFormat is String ? StrPtr(lpFormat) : lpFormat
        lpDateStr := lpDateStr is String ? StrPtr(lpDateStr) : lpDateStr

        result := DllCall("KERNEL32.dll\GetCalendarDateFormatEx", "ptr", lpszLocale, "uint", dwFlags, "ptr", lpCalDateTime, "ptr", lpFormat, "ptr", lpDateStr, "int", cchDate, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<SYSTEMTIME>} lpSysTime 
     * @param {Integer} calId 
     * @param {Pointer<CALDATETIME>} lpCalDateTime 
     * @returns {BOOL} 
     */
    static ConvertSystemTimeToCalDateTime(lpSysTime, calId, lpCalDateTime) {
        result := DllCall("KERNEL32.dll\ConvertSystemTimeToCalDateTime", "ptr", lpSysTime, "uint", calId, "ptr", lpCalDateTime, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<CALDATETIME>} lpCalDateTime 
     * @returns {BOOL} 
     */
    static UpdateCalendarDayOfWeek(lpCalDateTime) {
        result := DllCall("KERNEL32.dll\UpdateCalendarDayOfWeek", "ptr", lpCalDateTime, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<CALDATETIME>} lpCalDateTime 
     * @param {Integer} calUnit 
     * @param {Integer} amount 
     * @returns {BOOL} 
     */
    static AdjustCalendarDate(lpCalDateTime, calUnit, amount) {
        result := DllCall("KERNEL32.dll\AdjustCalendarDate", "ptr", lpCalDateTime, "int", calUnit, "int", amount, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<CALDATETIME>} lpCalDateTime 
     * @param {Pointer<SYSTEMTIME>} lpSysTime 
     * @returns {BOOL} 
     */
    static ConvertCalDateTimeToSystemTime(lpCalDateTime, lpSysTime) {
        result := DllCall("KERNEL32.dll\ConvertCalDateTimeToSystemTime", "ptr", lpCalDateTime, "ptr", lpSysTime, "int")
        return result
    }

    /**
     * 
     * @param {Integer} calId 
     * @param {Integer} year 
     * @param {Integer} era 
     * @returns {BOOL} 
     */
    static IsCalendarLeapYear(calId, year, era) {
        result := DllCall("KERNEL32.dll\IsCalendarLeapYear", "uint", calId, "uint", year, "uint", era, "int")
        return result
    }

    /**
     * Locates a Unicode string (wide characters) in another Unicode string for a non-linguistic comparison.
     * @param {Integer} dwFindStringOrdinalFlags Flags specifying details of the find operation. These flags are mutually exclusive, with FIND_FROMSTART being the default. The application can specify just one of the find flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMSTART"></a><a id="find_fromstart"></a><dl>
     * <dt><b>FIND_FROMSTART</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string, starting with the first character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FROMEND"></a><a id="find_fromend"></a><dl>
     * <dt><b>FIND_FROMEND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the string in the reverse direction, starting with the last character of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_STARTSWITH"></a><a id="find_startswith"></a><dl>
     * <dt><b>FIND_STARTSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the first value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_ENDSWITH"></a><a id="find_endswith"></a><dl>
     * <dt><b>FIND_ENDSWITH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Test to find out if the value specified by <i>lpStringValue</i> is the last value in the source string indicated by <i>lpStringSource</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpStringSource Pointer to the source string, in which the function searches for the string specified by <i>lpStringValue</i>.
     * @param {Integer} cchSource Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringSource</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the source string is null-terminated and the function should calculate the size automatically.
     * @param {PWSTR} lpStringValue Pointer to the search string for which the function searches in the source string.
     * @param {Integer} cchValue Size, in characters excluding the terminating null character, of the string indicated by <i>lpStringValue</i>. The application must normally specify a positive number, or 0. The application can specify -1 if the string is null-terminated and the function should calculate the size automatically.
     * @param {BOOL} bIgnoreCase <b>TRUE</b> if the function is to perform a case-insensitive comparison, and <b>FALSE</b> otherwise. The comparison is not a linguistic operation and is not appropriate for all locales and languages. Its behavior is similar to that for English.
     * @returns {Integer} Returns a 0-based index into the source string indicated by <i>lpStringSource</i> if successful. If the function succeeds, the found string is the same size as the value of <i>lpStringValue</i>. A return value of 0 indicates that the function found a match at the beginning of the source string.
     * 
     * The function returns -1 if it does not succeed or if it does not find the search string. To get extended error information, the application can call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which can return one of the following error codes:
     * 
     * <ul>
     * <li>ERROR_INVALID_FLAGS. The values supplied for flags were not valid.</li>
     * <li>ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.</li>
     * <li>ERROR_SUCCESS. The action completed successfully but yielded no results.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-findstringordinal
     * @since windows6.1
     */
    static FindStringOrdinal(dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase) {
        lpStringSource := lpStringSource is String ? StrPtr(lpStringSource) : lpStringSource
        lpStringValue := lpStringValue is String ? StrPtr(lpStringValue) : lpStringValue

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindStringOrdinal", "uint", dwFindStringOrdinalFlags, "ptr", lpStringSource, "int", cchSource, "ptr", lpStringValue, "int", cchValue, "int", bIgnoreCase, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two character strings. The comparison is case-sensitive.
     * @param {PSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {PSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the string pointed to by 
     * 						<i>lpString1</i> is less than the string pointed to by 
     * 						<i>lpString2</i>, the return value is negative. If the string pointed to by 
     * 						<i>lpString1</i> is greater than the string pointed to by 
     * 						<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpa
     * @since windows5.0
     */
    static lstrcmpA(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcmpA", "ptr", lpString1, "ptr", lpString2, "int")
        return result
    }

    /**
     * Compares two character strings. The comparison is case-sensitive.
     * @param {PWSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {PWSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the string pointed to by 
     * 						<i>lpString1</i> is less than the string pointed to by 
     * 						<i>lpString2</i>, the return value is negative. If the string pointed to by 
     * 						<i>lpString1</i> is greater than the string pointed to by 
     * 						<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpw
     * @since windows5.0
     */
    static lstrcmpW(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcmpW", "ptr", lpString1, "ptr", lpString2, "int")
        return result
    }

    /**
     * Compares two character strings. The comparison is not case-sensitive.
     * @param {PSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {PSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the string pointed to by 
     * 						<i>lpString1</i> is less than the string pointed to by 
     * 						<i>lpString2</i>, the return value is negative. If the string pointed to by 
     * 						<i>lpString1</i> is greater than the string pointed to by 
     * 						<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpia
     * @since windows5.0
     */
    static lstrcmpiA(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcmpiA", "ptr", lpString1, "ptr", lpString2, "int")
        return result
    }

    /**
     * Compares two character strings. The comparison is not case-sensitive.
     * @param {PWSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * The first null-terminated string to be compared.
     * @param {PWSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the string pointed to by 
     * 						<i>lpString1</i> is less than the string pointed to by 
     * 						<i>lpString2</i>, the return value is negative. If the string pointed to by 
     * 						<i>lpString1</i> is greater than the string pointed to by 
     * 						<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcmpiw
     * @since windows5.0
     */
    static lstrcmpiW(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcmpiW", "ptr", lpString1, "ptr", lpString2, "int")
        return result
    }

    /**
     * Copies a specified number of characters from a source string into a buffer.WarningDo not use.
     * @param {PSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the copied characters. The buffer 
     * 				must be large enough to contain the number of <b>TCHAR</b> values 
     * 				specified by <i>iMaxLength</i>, including room 
     * 				for a terminating null character.
     * @param {PSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The source string from which the function is to copy characters.
     * @param {Integer} iMaxLength Type: <b>int</b>
     * 
     * The number of <b>TCHAR</b> values to be copied from the 
     * 				string pointed to by <i>lpString2</i> into the 
     * 				buffer pointed to by <i>lpString1</i>, including 
     * 				a terminating null character.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer. 
     * 				The function can succeed even if the source string is greater than 
     * 				<i>iMaxLength</i> characters.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpyna
     * @since windows5.0
     */
    static lstrcpynA(lpString1, lpString2, iMaxLength) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcpynA", "ptr", lpString1, "ptr", lpString2, "int", iMaxLength, "char*")
        return result
    }

    /**
     * Copies a specified number of characters from a source string into a buffer.WarningDo not use.
     * @param {PWSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the copied characters. The buffer 
     * 				must be large enough to contain the number of <b>TCHAR</b> values 
     * 				specified by <i>iMaxLength</i>, including room 
     * 				for a terminating null character.
     * @param {PWSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * The source string from which the function is to copy characters.
     * @param {Integer} iMaxLength Type: <b>int</b>
     * 
     * The number of <b>TCHAR</b> values to be copied from the 
     * 				string pointed to by <i>lpString2</i> into the 
     * 				buffer pointed to by <i>lpString1</i>, including 
     * 				a terminating null character.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer. 
     * 				The function can succeed even if the source string is greater than 
     * 				<i>iMaxLength</i> characters.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpynw
     * @since windows5.0
     */
    static lstrcpynW(lpString1, lpString2, iMaxLength) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcpynW", "ptr", lpString1, "ptr", lpString2, "int", iMaxLength, "char*")
        return result
    }

    /**
     * Copies a string to a buffer.
     * @param {PSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * A buffer to receive the contents of the string pointed to by the 
     * 					<i>lpString2</i> parameter. 
     * 					The buffer must be large enough to contain the string, including the 
     * 					terminating null character.
     * @param {PSTR} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be copied.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpya
     * @since windows5.0
     */
    static lstrcpyA(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcpyA", "ptr", lpString1, "ptr", lpString2, "char*")
        return result
    }

    /**
     * Copies a string to a buffer.
     * @param {PWSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * A buffer to receive the contents of the string pointed to by the 
     * 					<i>lpString2</i> parameter. 
     * 					The buffer must be large enough to contain the string, including the 
     * 					terminating null character.
     * @param {PWSTR} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be copied.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcpyw
     * @since windows5.0
     */
    static lstrcpyW(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcpyW", "ptr", lpString1, "ptr", lpString2, "char*")
        return result
    }

    /**
     * Appends one string to another.WarningDo not use.
     * @param {PSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * The first null-terminated string. This buffer must be large enough 
     * 				to contain both strings.
     * @param {PSTR} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be appended to the string 
     * 				specified in the <i>lpString1</i> parameter.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcata
     * @since windows5.0
     */
    static lstrcatA(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcatA", "ptr", lpString1, "ptr", lpString2, "char*")
        return result
    }

    /**
     * Appends one string to another.WarningDo not use.
     * @param {PWSTR} lpString1 Type: <b>LPTSTR</b>
     * 
     * The first null-terminated string. This buffer must be large enough 
     * 				to contain both strings.
     * @param {PWSTR} lpString2 Type: <b>LPTSTR</b>
     * 
     * The null-terminated string to be appended to the string 
     * 				specified in the <i>lpString1</i> parameter.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * If the function succeeds, the return value is a pointer to the buffer.
     * 
     * If the function fails, the return value is <b>NULL</b> 
     *                     and <i>lpString1</i> may not be null-terminated.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrcatw
     * @since windows5.0
     */
    static lstrcatW(lpString1, lpString2) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("KERNEL32.dll\lstrcatW", "ptr", lpString1, "ptr", lpString2, "char*")
        return result
    }

    /**
     * Determines the length of the specified string (not including the terminating null character).
     * @param {PSTR} lpString Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be checked.
     * @returns {Integer} Type: <b>int</b>
     * 
     * The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrlena
     * @since windows5.0
     */
    static lstrlenA(lpString) {
        lpString := lpString is String ? StrPtr(lpString) : lpString

        result := DllCall("KERNEL32.dll\lstrlenA", "ptr", lpString, "int")
        return result
    }

    /**
     * Determines the length of the specified string (not including the terminating null character).
     * @param {PWSTR} lpString Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be checked.
     * @returns {Integer} Type: <b>int</b>
     * 
     * The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-lstrlenw
     * @since windows5.0
     */
    static lstrlenW(lpString) {
        lpString := lpString is String ? StrPtr(lpString) : lpString

        result := DllCall("KERNEL32.dll\lstrlenW", "ptr", lpString, "int")
        return result
    }

    /**
     * Determines if a buffer is likely to contain a form of Unicode text.
     * @param {Pointer} lpv Pointer to the input buffer to examine.
     * @param {Integer} iSize Size, in bytes, of the input buffer indicated by <i>lpv</i>.
     * @param {Pointer<UInt32>} lpiResult On input, pointer to the tests to apply to the input buffer text. On output, this parameter receives the results of the specified tests: 1 if the contents of the buffer pass a test, 0 for failure. Only flags that are set upon input to the function are significant upon output.
     * 
     * If <i>lpiResult</i> is <b>NULL</b>, the function uses all available tests to determine if the data in the buffer is likely to be Unicode text.
     * @returns {BOOL} Returns a nonzero value if the data in the buffer passes the specified tests. The function returns 0 if the data in the buffer does not pass the specified tests.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-istextunicode
     * @since windows5.0
     */
    static IsTextUnicode(lpv, iSize, lpiResult) {
        result := DllCall("ADVAPI32.dll\IsTextUnicode", "ptr", lpv, "int", iSize, "uint*", lpiResult, "int")
        return result
    }

;@endregion Methods
}
