#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.UI.Shell
 * @version v4.0.30319
 */
class Shell {

;@region Constants

    /**
     * @type {Integer (Int32)}
     */
    static HLINK_E_FIRST => -2147221248

    /**
     * @type {Integer (Int32)}
     */
    static HLINK_S_FIRST => 262400

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CPL_LAUNCH => 2024

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CPL_LAUNCHED => 2025

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_DYNAMIC_RES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_INIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_GETCOUNT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_INQUIRE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_SELECT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_DBLCLK => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_STOP => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_EXIT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_NEWINQUIRE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_STARTWPARMSA => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_STARTWPARMSW => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_STARTWPARMS => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_SETUP => 200

    /**
     * @type {Integer (Int32)}
     */
    static HLINK_S_DONTHIDE => 262400

    /**
     * @type {String}
     */
    static FOLDERID_NetworkFolder => "{d20beec4-5ca8-4905-ae3b-bf251ea09b53}"

    /**
     * @type {String}
     */
    static FOLDERID_ComputerFolder => "{0ac0837c-bbf8-452a-850d-79d08e667ca7}"

    /**
     * @type {String}
     */
    static FOLDERID_InternetFolder => "{4d9f7874-4e0c-4904-967b-40b0d20c3e4b}"

    /**
     * @type {String}
     */
    static FOLDERID_ControlPanelFolder => "{82a74aeb-aeb4-465c-a014-d097ee346d63}"

    /**
     * @type {String}
     */
    static FOLDERID_PrintersFolder => "{76fc4e2d-d6ad-4519-a663-37bd56068185}"

    /**
     * @type {String}
     */
    static FOLDERID_SyncManagerFolder => "{43668bf8-c14e-49b2-97c9-747784d784b7}"

    /**
     * @type {String}
     */
    static FOLDERID_SyncSetupFolder => "{0f214138-b1d3-4a90-bba9-27cbc0c5389a}"

    /**
     * @type {String}
     */
    static FOLDERID_ConflictFolder => "{4bfefb45-347d-4006-a5be-ac0cb0567192}"

    /**
     * @type {String}
     */
    static FOLDERID_SyncResultsFolder => "{289a9a43-be44-4057-a41b-587a76d7e7f9}"

    /**
     * @type {String}
     */
    static FOLDERID_RecycleBinFolder => "{b7534046-3ecb-4c18-be4e-64cd4cb7d6ac}"

    /**
     * @type {String}
     */
    static FOLDERID_ConnectionsFolder => "{6f0cd92b-2e97-45d1-88ff-b0d186b8dedd}"

    /**
     * @type {String}
     */
    static FOLDERID_Fonts => "{fd228cb7-ae11-4ae3-864c-16f3910ab8fe}"

    /**
     * @type {String}
     */
    static FOLDERID_Desktop => "{b4bfcc3a-db2c-424c-b029-7fe99a87c641}"

    /**
     * @type {String}
     */
    static FOLDERID_Startup => "{b97d20bb-f46a-4c97-ba10-5e3608430854}"

    /**
     * @type {String}
     */
    static FOLDERID_Programs => "{a77f5d77-2e2b-44c3-a6a2-aba601054a51}"

    /**
     * @type {String}
     */
    static FOLDERID_StartMenu => "{625b53c3-ab48-4ec1-ba1f-a1ef4146fc19}"

    /**
     * @type {String}
     */
    static FOLDERID_Recent => "{ae50c081-ebd2-438a-8655-8a092e34987a}"

    /**
     * @type {String}
     */
    static FOLDERID_SendTo => "{8983036c-27c0-404b-8f08-102d10dcfd74}"

    /**
     * @type {String}
     */
    static FOLDERID_Documents => "{fdd39ad0-238f-46af-adb4-6c85480369c7}"

    /**
     * @type {String}
     */
    static FOLDERID_Favorites => "{1777f761-68ad-4d8a-87bd-30b759fa33dd}"

    /**
     * @type {String}
     */
    static FOLDERID_NetHood => "{c5abbf53-e17f-4121-8900-86626fc2c973}"

    /**
     * @type {String}
     */
    static FOLDERID_PrintHood => "{9274bd8d-cfd1-41c3-b35e-b13f55a758f4}"

    /**
     * @type {String}
     */
    static FOLDERID_Templates => "{a63293e8-664e-48db-a079-df759e0509f7}"

    /**
     * @type {String}
     */
    static FOLDERID_CommonStartup => "{82a5ea35-d9cd-47c5-9629-e15d2f714e6e}"

    /**
     * @type {String}
     */
    static FOLDERID_CommonPrograms => "{0139d44e-6afe-49f2-8690-3dafcae6ffb8}"

    /**
     * @type {String}
     */
    static FOLDERID_CommonStartMenu => "{a4115719-d62e-491d-aa7c-e74b8be3b067}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicDesktop => "{c4aa340d-f20f-4863-afef-f87ef2e6ba25}"

    /**
     * @type {String}
     */
    static FOLDERID_ProgramData => "{62ab5d82-fdc1-4dc3-a9dd-070d1d495d97}"

    /**
     * @type {String}
     */
    static FOLDERID_CommonTemplates => "{b94237e7-57ac-4347-9151-b08c6c32d1f7}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicDocuments => "{ed4824af-dce4-45a8-81e2-fc7965083634}"

    /**
     * @type {String}
     */
    static FOLDERID_RoamingAppData => "{3eb685db-65f9-4cf6-a03a-e3ef65729f3d}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalAppData => "{f1b32785-6fba-4fcf-9d55-7b8e7f157091}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalAppDataLow => "{a520a1a4-1780-4ff6-bd18-167343c5af16}"

    /**
     * @type {String}
     */
    static FOLDERID_InternetCache => "{352481e8-33be-4251-ba85-6007caedcf9d}"

    /**
     * @type {String}
     */
    static FOLDERID_Cookies => "{2b0f765d-c0e9-4171-908e-08a611b84ff6}"

    /**
     * @type {String}
     */
    static FOLDERID_History => "{d9dc8a3b-b784-432e-a781-5a1130a75963}"

    /**
     * @type {String}
     */
    static FOLDERID_System => "{1ac14e77-02e7-4e5d-b744-2eb1ae5198b7}"

    /**
     * @type {String}
     */
    static FOLDERID_SystemX86 => "{d65231b0-b2f1-4857-a4ce-a8e7c6ea7d27}"

    /**
     * @type {String}
     */
    static FOLDERID_Windows => "{f38bf404-1d43-42f2-9305-67de0b28fc23}"

    /**
     * @type {String}
     */
    static FOLDERID_Profile => "{5e6c858f-0e22-4760-9afe-ea3317b67173}"

    /**
     * @type {String}
     */
    static FOLDERID_Pictures => "{33e28130-4e1e-4676-835a-98395c3bc3bb}"

    /**
     * @type {String}
     */
    static FOLDERID_ProgramFilesX86 => "{7c5a40ef-a0fb-4bfc-874a-c0f2e0b9fa8e}"

    /**
     * @type {String}
     */
    static FOLDERID_ProgramFilesCommonX86 => "{de974d24-d9c6-4d3e-bf91-f4455120b917}"

    /**
     * @type {String}
     */
    static FOLDERID_ProgramFilesX64 => "{6d809377-6af0-444b-8957-a3773f02200e}"

    /**
     * @type {String}
     */
    static FOLDERID_ProgramFilesCommonX64 => "{6365d5a7-0f0d-45e5-87f6-0da56b6a4f7d}"

    /**
     * @type {String}
     */
    static FOLDERID_ProgramFiles => "{905e63b6-c1bf-494e-b29c-65b732d3d21a}"

    /**
     * @type {String}
     */
    static FOLDERID_ProgramFilesCommon => "{f7f1ed05-9f6d-47a2-aaae-29d317c6f066}"

    /**
     * @type {String}
     */
    static FOLDERID_UserProgramFiles => "{5cd7aee2-2219-4a67-b85d-6c9ce15660cb}"

    /**
     * @type {String}
     */
    static FOLDERID_UserProgramFilesCommon => "{bcbd3057-ca5c-4622-b42d-bc56db0ae516}"

    /**
     * @type {String}
     */
    static FOLDERID_AdminTools => "{724ef170-a42d-4fef-9f26-b60e846fba4f}"

    /**
     * @type {String}
     */
    static FOLDERID_CommonAdminTools => "{d0384e7d-bac3-4797-8f14-cba229b392b5}"

    /**
     * @type {String}
     */
    static FOLDERID_Music => "{4bd8d571-6d19-48d3-be97-422220080e43}"

    /**
     * @type {String}
     */
    static FOLDERID_Videos => "{18989b1d-99b5-455b-841c-ab7c74e4ddfc}"

    /**
     * @type {String}
     */
    static FOLDERID_Ringtones => "{c870044b-f49e-4126-a9c3-b52a1ff411e8}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicPictures => "{b6ebfb86-6907-413c-9af7-4fc2abf07cc5}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicMusic => "{3214fab5-9757-4298-bb61-92a9deaa44ff}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicVideos => "{2400183a-6185-49fb-a2d8-4a392a602ba3}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicRingtones => "{e555ab60-153b-4d17-9f04-a5fe99fc15ec}"

    /**
     * @type {String}
     */
    static FOLDERID_ResourceDir => "{8ad10c31-2adb-4296-a8f7-e4701232c972}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalizedResourcesDir => "{2a00375e-224c-49de-b8d1-440df7ef3ddc}"

    /**
     * @type {String}
     */
    static FOLDERID_CommonOEMLinks => "{c1bae2d0-10df-4334-bedd-7aa20b227a9d}"

    /**
     * @type {String}
     */
    static FOLDERID_CDBurning => "{9e52ab10-f80d-49df-acb8-4330f5687855}"

    /**
     * @type {String}
     */
    static FOLDERID_UserProfiles => "{0762d272-c50a-4bb0-a382-697dcd729b80}"

    /**
     * @type {String}
     */
    static FOLDERID_Playlists => "{de92c1c7-837f-4f69-a3bb-86e631204a23}"

    /**
     * @type {String}
     */
    static FOLDERID_SamplePlaylists => "{15ca69b3-30ee-49c1-ace1-6b5ec372afb5}"

    /**
     * @type {String}
     */
    static FOLDERID_SampleMusic => "{b250c668-f57d-4ee1-a63c-290ee7d1aa1f}"

    /**
     * @type {String}
     */
    static FOLDERID_SamplePictures => "{c4900540-2379-4c75-844b-64e6faf8716b}"

    /**
     * @type {String}
     */
    static FOLDERID_SampleVideos => "{859ead94-2e85-48ad-a71a-0969cb56a6cd}"

    /**
     * @type {String}
     */
    static FOLDERID_PhotoAlbums => "{69d2cf90-fc33-4fb7-9a0c-ebb0f0fcb43c}"

    /**
     * @type {String}
     */
    static FOLDERID_Public => "{dfdf76a2-c82a-4d63-906a-5644ac457385}"

    /**
     * @type {String}
     */
    static FOLDERID_ChangeRemovePrograms => "{df7266ac-9274-4867-8d55-3bd661de872d}"

    /**
     * @type {String}
     */
    static FOLDERID_AppUpdates => "{a305ce99-f527-492b-8b1a-7e76fa98d6e4}"

    /**
     * @type {String}
     */
    static FOLDERID_AddNewPrograms => "{de61d971-5ebc-4f02-a3a9-6c82895e5c04}"

    /**
     * @type {String}
     */
    static FOLDERID_Downloads => "{374de290-123f-4565-9164-39c4925e467b}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicDownloads => "{3d644c9b-1fb8-4f30-9b45-f670235f79c0}"

    /**
     * @type {String}
     */
    static FOLDERID_SavedSearches => "{7d1d3a04-debb-4115-95cf-2f29da2920da}"

    /**
     * @type {String}
     */
    static FOLDERID_QuickLaunch => "{52a4f021-7b75-48a9-9f6b-4b87a210bc8f}"

    /**
     * @type {String}
     */
    static FOLDERID_Contacts => "{56784854-c6cb-462b-8169-88e350acb882}"

    /**
     * @type {String}
     */
    static FOLDERID_SidebarParts => "{a75d362e-50fc-4fb7-ac2c-a8beaa314493}"

    /**
     * @type {String}
     */
    static FOLDERID_SidebarDefaultParts => "{7b396e54-9ec5-4300-be0a-2482ebae1a26}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicGameTasks => "{debf2536-e1a8-4c59-b6a2-414586476aea}"

    /**
     * @type {String}
     */
    static FOLDERID_GameTasks => "{054fae61-4dd8-4787-80b6-090220c4b700}"

    /**
     * @type {String}
     */
    static FOLDERID_SavedGames => "{4c5c32ff-bb9d-43b0-b5b4-2d72e54eaaa4}"

    /**
     * @type {String}
     */
    static FOLDERID_Games => "{cac52c1a-b53d-4edc-92d7-6b2e8ac19434}"

    /**
     * @type {String}
     */
    static FOLDERID_SEARCH_MAPI => "{98ec0e18-2098-4d44-8644-66979315a281}"

    /**
     * @type {String}
     */
    static FOLDERID_SEARCH_CSC => "{ee32e446-31ca-4aba-814f-a5ebd2fd6d5e}"

    /**
     * @type {String}
     */
    static FOLDERID_Links => "{bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968}"

    /**
     * @type {String}
     */
    static FOLDERID_UsersFiles => "{f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}"

    /**
     * @type {String}
     */
    static FOLDERID_UsersLibraries => "{a302545d-deff-464b-abe8-61c8648d939b}"

    /**
     * @type {String}
     */
    static FOLDERID_SearchHome => "{190337d1-b8ca-4121-a639-6d472d16972a}"

    /**
     * @type {String}
     */
    static FOLDERID_OriginalImages => "{2c36c0aa-5812-4b87-bfd0-4cd0dfb19b39}"

    /**
     * @type {String}
     */
    static FOLDERID_DocumentsLibrary => "{7b0db17d-9cd2-4a93-9733-46cc89022e7c}"

    /**
     * @type {String}
     */
    static FOLDERID_MusicLibrary => "{2112ab0a-c86a-4ffe-a368-0de96e47012e}"

    /**
     * @type {String}
     */
    static FOLDERID_PicturesLibrary => "{a990ae9f-a03b-4e80-94bc-9912d7504104}"

    /**
     * @type {String}
     */
    static FOLDERID_VideosLibrary => "{491e922f-5643-4af4-a7eb-4e7a138d8174}"

    /**
     * @type {String}
     */
    static FOLDERID_RecordedTVLibrary => "{1a6fdba2-f42d-4358-a798-b74d745926c5}"

    /**
     * @type {String}
     */
    static FOLDERID_HomeGroup => "{52528a6b-b9e3-4add-b60d-588c2dba842d}"

    /**
     * @type {String}
     */
    static FOLDERID_HomeGroupCurrentUser => "{9b74b6a3-0dfd-4f11-9e78-5f7800f2e772}"

    /**
     * @type {String}
     */
    static FOLDERID_DeviceMetadataStore => "{5ce4a5e9-e4eb-479d-b89f-130c02886155}"

    /**
     * @type {String}
     */
    static FOLDERID_Libraries => "{1b3ea5dc-b587-4786-b4ef-bd1dc332aeae}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicLibraries => "{48daf80b-e6cf-4f4e-b800-0e69d84ee384}"

    /**
     * @type {String}
     */
    static FOLDERID_UserPinned => "{9e3995ab-1f9c-4f13-b827-48b24b6c7174}"

    /**
     * @type {String}
     */
    static FOLDERID_ImplicitAppShortcuts => "{bcb5256f-79f6-4cee-b725-dc34e402fd46}"

    /**
     * @type {String}
     */
    static FOLDERID_AccountPictures => "{008ca0b1-55b4-4c56-b8a8-4de4b299d3be}"

    /**
     * @type {String}
     */
    static FOLDERID_PublicUserTiles => "{0482af6c-08f1-4c34-8c90-e17ec98b1e17}"

    /**
     * @type {String}
     */
    static FOLDERID_AppsFolder => "{1e87508d-89c2-42f0-8a7e-645a0f50ca58}"

    /**
     * @type {String}
     */
    static FOLDERID_StartMenuAllPrograms => "{f26305ef-6948-40b9-b255-81453d09c785}"

    /**
     * @type {String}
     */
    static FOLDERID_CommonStartMenuPlaces => "{a440879f-87a0-4f7d-b700-0207b966194a}"

    /**
     * @type {String}
     */
    static FOLDERID_ApplicationShortcuts => "{a3918781-e5f2-4890-b3d9-a7e54332328c}"

    /**
     * @type {String}
     */
    static FOLDERID_RoamingTiles => "{00bcfc5a-ed94-4e48-96a1-3f6217f21990}"

    /**
     * @type {String}
     */
    static FOLDERID_RoamedTileImages => "{aaa8d5a5-f1d6-4259-baa8-78e7ef60835e}"

    /**
     * @type {String}
     */
    static FOLDERID_Screenshots => "{b7bede81-df94-4682-a7d8-57a52620b86f}"

    /**
     * @type {String}
     */
    static FOLDERID_CameraRoll => "{ab5fb87b-7ce2-4f83-915d-550846c9537b}"

    /**
     * @type {String}
     */
    static FOLDERID_SkyDrive => "{a52bba46-e9e1-435f-b3d9-28daa648c0f6}"

    /**
     * @type {String}
     */
    static FOLDERID_OneDrive => "{a52bba46-e9e1-435f-b3d9-28daa648c0f6}"

    /**
     * @type {String}
     */
    static FOLDERID_SkyDriveDocuments => "{24d89e24-2f19-4534-9dde-6a6671fbb8fe}"

    /**
     * @type {String}
     */
    static FOLDERID_SkyDrivePictures => "{339719b5-8c47-4894-94c2-d8f77add44a6}"

    /**
     * @type {String}
     */
    static FOLDERID_SkyDriveMusic => "{c3f2459e-80d6-45dc-bfef-1f769f2be730}"

    /**
     * @type {String}
     */
    static FOLDERID_SkyDriveCameraRoll => "{767e6811-49cb-4273-87c2-20f355e1085b}"

    /**
     * @type {String}
     */
    static FOLDERID_SearchHistory => "{0d4c3db6-03a3-462f-a0e6-08924c41b5d4}"

    /**
     * @type {String}
     */
    static FOLDERID_SearchTemplates => "{7e636bfe-dfa9-4d5e-b456-d7b39851d8a9}"

    /**
     * @type {String}
     */
    static FOLDERID_CameraRollLibrary => "{2b20df75-1eda-4039-8097-38798227d5b7}"

    /**
     * @type {String}
     */
    static FOLDERID_SavedPictures => "{3b193882-d3ad-4eab-965a-69829d1fb59f}"

    /**
     * @type {String}
     */
    static FOLDERID_SavedPicturesLibrary => "{e25b5812-be88-4bd9-94b0-29233477b6c3}"

    /**
     * @type {String}
     */
    static FOLDERID_RetailDemo => "{12d4c69e-24ad-4923-be19-31321c43a767}"

    /**
     * @type {String}
     */
    static FOLDERID_Device => "{1c2ac1dc-4358-4b6c-9733-af21156576f0}"

    /**
     * @type {String}
     */
    static FOLDERID_DevelopmentFiles => "{dbe8e08e-3053-4bbc-b183-2a7b2b191e59}"

    /**
     * @type {String}
     */
    static FOLDERID_Objects3D => "{31c0dd25-9439-4f12-bf41-7ff4eda38722}"

    /**
     * @type {String}
     */
    static FOLDERID_AppCaptures => "{edc0fe71-98d8-4f4a-b920-c8dc133cb165}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalDocuments => "{f42ee2d3-909f-4907-8871-4c22fc0bf756}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalPictures => "{0ddd015d-b06c-45d5-8c4c-f59713854639}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalVideos => "{35286a68-3c57-41a1-bbb1-0eae73d76c95}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalMusic => "{a0c69a99-21c8-4671-8703-7934162fcf1d}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalDownloads => "{7d83ee9b-2244-4e70-b1f5-5393042af1e4}"

    /**
     * @type {String}
     */
    static FOLDERID_RecordedCalls => "{2f8b40c2-83ed-48ee-b383-a1f157ec6f9a}"

    /**
     * @type {String}
     */
    static FOLDERID_AllAppMods => "{7ad67899-66af-43ba-9156-6aad42e6c596}"

    /**
     * @type {String}
     */
    static FOLDERID_CurrentAppMods => "{3db40b20-2a30-4dbe-917e-771dd21dd099}"

    /**
     * @type {String}
     */
    static FOLDERID_AppDataDesktop => "{b2c5e279-7add-439f-b28c-c41fe1bbf672}"

    /**
     * @type {String}
     */
    static FOLDERID_AppDataDocuments => "{7be16610-1f7f-44ac-bff0-83e15f2ffca1}"

    /**
     * @type {String}
     */
    static FOLDERID_AppDataFavorites => "{7cfbefbc-de1f-45aa-b843-a542ac536cc9}"

    /**
     * @type {String}
     */
    static FOLDERID_AppDataProgramData => "{559d40a3-a036-40fa-af61-84cb430a4d34}"

    /**
     * @type {String}
     */
    static FOLDERID_LocalStorage => "{b3eb08d3-a1f3-496b-865a-42b536cda0ec}"

    /**
     * @type {String}
     */
    static CLSID_InternetShortcut => "{fbf23b40-e3f0-101b-8488-00aa003e56f8}"

    /**
     * @type {String}
     */
    static CLSID_NetworkDomain => "{46e06680-4bf0-11d1-83ee-00a0c90dc849}"

    /**
     * @type {String}
     */
    static CLSID_NetworkServer => "{c0542a90-4bf0-11d1-83ee-00a0c90dc849}"

    /**
     * @type {String}
     */
    static CLSID_NetworkShare => "{54a754c0-4bf0-11d1-83ee-00a0c90dc849}"

    /**
     * @type {String}
     */
    static CLSID_MyComputer => "{20d04fe0-3aea-1069-a2d8-08002b30309d}"

    /**
     * @type {String}
     */
    static CLSID_Internet => "{871c5380-42a0-1069-a2ea-08002b30309d}"

    /**
     * @type {String}
     */
    static CLSID_RecycleBin => "{645ff040-5081-101b-9f08-00aa002f954e}"

    /**
     * @type {String}
     */
    static CLSID_ControlPanel => "{21ec2020-3aea-1069-a2dd-08002b30309d}"

    /**
     * @type {String}
     */
    static CLSID_Printers => "{2227a280-3aea-1069-a2de-08002b30309d}"

    /**
     * @type {String}
     */
    static CLSID_MyDocuments => "{450d8fba-ad25-11d0-98a8-0800361b1103}"

    /**
     * @type {String}
     */
    static STR_MYDOCS_CLSID => "{450D8FBA-AD25-11D0-98A8-0800361B1103}"

    /**
     * @type {String}
     */
    static CATID_BrowsableShellExt => "{00021490-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CATID_BrowseInPlace => "{00021491-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CATID_DeskBand => "{00021492-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CATID_InfoBand => "{00021493-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CATID_CommBand => "{00021494-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static FMTID_Intshcut => "{000214a0-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static FMTID_InternetSite => "{000214a1-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CGID_Explorer => "{000214d0-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CGID_ShellDocView => "{000214d1-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CGID_ShellServiceObject => "{000214d2-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CGID_ExplorerBarDoc => "{000214d3-0000-0000-c000-000000000046}"

    /**
     * @type {String}
     */
    static CLSID_FolderShortcut => "{0afaced1-e828-11d1-9187-b532f1e9575d}"

    /**
     * @type {String}
     */
    static CLSID_CFSIconOverlayManager => "{63b51f81-c868-11d0-999c-00c04fd655e1}"

    /**
     * @type {String}
     */
    static CLSID_ShellThumbnailDiskCache => "{1ebdcf80-a200-11d0-a3a4-00c04fd706ec}"

    /**
     * @type {String}
     */
    static SID_DefView => "{6d12fe80-7911-11cf-9534-0000c05bae0b}"

    /**
     * @type {String}
     */
    static CGID_DefView => "{4af07f10-d231-11d0-b942-00a0c90312e1}"

    /**
     * @type {String}
     */
    static CLSID_MenuBand => "{5b4dae26-b807-11d0-9815-00c04fd91972}"

    /**
     * @type {String}
     */
    static VID_LargeIcons => "{0057d0e0-3573-11cf-ae69-08002b2e1262}"

    /**
     * @type {String}
     */
    static VID_SmallIcons => "{089000c0-3573-11cf-ae69-08002b2e1262}"

    /**
     * @type {String}
     */
    static VID_List => "{0e1fa5e0-3573-11cf-ae69-08002b2e1262}"

    /**
     * @type {String}
     */
    static VID_Details => "{137e7700-3573-11cf-ae69-08002b2e1262}"

    /**
     * @type {String}
     */
    static VID_Tile => "{65f125e5-7be1-4810-ba9d-d271c8432ce3}"

    /**
     * @type {String}
     */
    static VID_Content => "{30c2c434-0889-4c8d-985d-a9f71830b0a9}"

    /**
     * @type {String}
     */
    static VID_Thumbnails => "{8bebb290-52d0-11d0-b7f4-00c04fd706ec}"

    /**
     * @type {String}
     */
    static VID_ThumbStrip => "{8eefa624-d1e9-445b-94b7-74fbce2ea11a}"

    /**
     * @type {String}
     */
    static SID_SInPlaceBrowser => "{1d2ae02b-3655-46cc-b63a-285988153bca}"

    /**
     * @type {String}
     */
    static SID_SSearchBoxInfo => "{142daa61-516b-4713-b49c-fb985ef82998}"

    /**
     * @type {String}
     */
    static SID_CommandsPropertyBag => "{6e043250-4416-485c-b143-e62a760d9fe5}"

    /**
     * @type {String}
     */
    static CLSID_CURLSearchHook => "{cfbfae00-17a6-11d0-99cb-00c04fd64497}"

    /**
     * @type {String}
     */
    static CLSID_AutoComplete => "{00bb2763-6a77-11d0-a535-00c04fd7d062}"

    /**
     * @type {String}
     */
    static CLSID_ACLHistory => "{00bb2764-6a77-11d0-a535-00c04fd7d062}"

    /**
     * @type {String}
     */
    static CLSID_ACListISF => "{03c036f1-a186-11d0-824a-00aa005b4383}"

    /**
     * @type {String}
     */
    static CLSID_ACLMRU => "{6756a641-de71-11d0-831b-00aa005b4383}"

    /**
     * @type {String}
     */
    static CLSID_ACLMulti => "{00bb2765-6a77-11d0-a535-00c04fd7d062}"

    /**
     * @type {String}
     */
    static CLSID_ACLCustomMRU => "{6935db93-21e8-4ccc-beb9-9fe3c77a297a}"

    /**
     * @type {String}
     */
    static CLSID_ProgressDialog => "{f8383852-fcd3-11d1-a6b9-006097df5bd4}"

    /**
     * @type {String}
     */
    static SID_STopLevelBrowser => "{4c96be40-915c-11cf-99d3-00aa004ae837}"

    /**
     * @type {String}
     */
    static CLSID_FileTypes => "{b091e540-83e3-11cf-a713-0020afd79762}"

    /**
     * @type {String}
     */
    static CLSID_ActiveDesktop => "{75048700-ef1f-11d0-9888-006097deacf9}"

    /**
     * @type {String}
     */
    static CLSID_QueryAssociations => "{a07034fd-6caa-4954-ac3f-97a27216f98a}"

    /**
     * @type {String}
     */
    static CLSID_LinkColumnProvider => "{24f14f02-7b1c-11d1-838f-0000f80461cf}"

    /**
     * @type {String}
     */
    static CGID_ShortCut => "{93a68750-951a-11d1-946f-000000000000}"

    /**
     * @type {String}
     */
    static CLSID_InternetButtons => "{1e796980-9cc5-11d1-a83f-00c04fc99d61}"

    /**
     * @type {String}
     */
    static CLSID_MSOButtons => "{178f34b8-a282-11d2-86c5-00c04f8eea99}"

    /**
     * @type {String}
     */
    static CLSID_ToolbarExtButtons => "{2ce4b5d8-a28f-11d2-86c5-00c04f8eea99}"

    /**
     * @type {String}
     */
    static CLSID_DarwinAppPublisher => "{cfccc7a0-a282-11d1-9082-006008059382}"

    /**
     * @type {String}
     */
    static CLSID_DocHostUIHandler => "{7057e952-bd1b-11d1-8919-00c04fc2c836}"

    /**
     * @type {String}
     */
    static PSGUID_SHELLDETAILS => "{28636aa6-953d-11d2-b5d6-00c04fd918d0}"

    /**
     * @type {String}
     */
    static FMTID_ShellDetails => "{28636aa6-953d-11d2-b5d6-00c04fd918d0}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_FINDDATA => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PID_NETRESOURCE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PID_DESCRIPTIONID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_WHICHFOLDER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PID_NETWORKLOCATION => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PID_COMPUTERNAME => 5

    /**
     * @type {String}
     */
    static FMTID_Storage => "{b725f130-47ef-101a-a5f1-02608c9eebac}"

    /**
     * @type {String}
     */
    static PSGUID_IMAGEPROPERTIES => "{14b81da1-0135-4d31-96d9-6cbfc9671a99}"

    /**
     * @type {String}
     */
    static FMTID_ImageProperties => "{14b81da1-0135-4d31-96d9-6cbfc9671a99}"

    /**
     * @type {String}
     */
    static PSGUID_CUSTOMIMAGEPROPERTIES => "{7ecd8b0e-c136-4a9b-9411-4ebd6673ccc3}"

    /**
     * @type {String}
     */
    static FMTID_CustomImageProperties => "{7ecd8b0e-c136-4a9b-9411-4ebd6673ccc3}"

    /**
     * @type {String}
     */
    static PSGUID_LIBRARYPROPERTIES => "{5d76b67f-9b3d-44bb-b6ae-25da4f638a67}"

    /**
     * @type {String}
     */
    static FMTID_LibraryProperties => "{5d76b67f-9b3d-44bb-b6ae-25da4f638a67}"

    /**
     * @type {String}
     */
    static PSGUID_DISPLACED => "{9b174b33-40ff-11d2-a27e-00c04fc30871}"

    /**
     * @type {String}
     */
    static FMTID_Displaced => "{9b174b33-40ff-11d2-a27e-00c04fc30871}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_DISPLACED_FROM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_DISPLACED_DATE => 3

    /**
     * @type {String}
     */
    static PSGUID_BRIEFCASE => "{328d8b21-7729-4bfc-954c-902b329d56b0}"

    /**
     * @type {String}
     */
    static FMTID_Briefcase => "{328d8b21-7729-4bfc-954c-902b329d56b0}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_SYNC_COPY_IN => 2

    /**
     * @type {String}
     */
    static PSGUID_MISC => "{9b174b34-40ff-11d2-a27e-00c04fc30871}"

    /**
     * @type {String}
     */
    static FMTID_Misc => "{9b174b34-40ff-11d2-a27e-00c04fc30871}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_MISC_STATUS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_MISC_ACCESSCOUNT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PID_MISC_OWNER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PID_HTMLINFOTIPFILE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PID_MISC_PICS => 6

    /**
     * @type {String}
     */
    static PSGUID_WEBVIEW => "{f2275480-f782-4291-bd94-f13693513aec}"

    /**
     * @type {String}
     */
    static FMTID_WebView => "{f2275480-f782-4291-bd94-f13693513aec}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_DISPLAY_PROPERTIES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PID_INTROTEXT => 1

    /**
     * @type {String}
     */
    static PSGUID_MUSIC => "{56a3372e-ce9c-11d2-9f0e-006097c686f6}"

    /**
     * @type {String}
     */
    static FMTID_MUSIC => "{56a3372e-ce9c-11d2-9f0e-006097c686f6}"

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_ARTIST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_SONGTITLE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_ALBUM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_YEAR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_COMMENT => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_TRACK => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_GENRE => 11

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_LYRICS => 12

    /**
     * @type {String}
     */
    static PSGUID_DRM => "{aeac19e4-89ae-4508-b9b7-bb867abee2ed}"

    /**
     * @type {String}
     */
    static FMTID_DRM => "{aeac19e4-89ae-4508-b9b7-bb867abee2ed}"

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_PROTECTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_DESCRIPTION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_PLAYCOUNT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_PLAYSTARTS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_PLAYEXPIRES => 6

    /**
     * @type {String}
     */
    static PSGUID_VIDEO => "{64440491-4c8b-11d1-8b70-080036b11a03}"

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_STREAM_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_FRAME_WIDTH => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_FRAME_HEIGHT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_TIMELENGTH => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_FRAME_COUNT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_FRAME_RATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_DATA_RATE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_SAMPLE_SIZE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_COMPRESSION => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_STREAM_NUMBER => 11

    /**
     * @type {String}
     */
    static PSGUID_AUDIO => "{64440490-4c8b-11d1-8b70-080036b11a03}"

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_FORMAT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_TIMELENGTH => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_AVG_DATA_RATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_SAMPLE_RATE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_SAMPLE_SIZE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_CHANNEL_COUNT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_STREAM_NUMBER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_STREAM_NAME => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_COMPRESSION => 10

    /**
     * @type {String}
     */
    static PSGUID_CONTROLPANEL => "{305ca226-d286-468e-b848-2b2e8e697b74}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_CONTROLPANEL_CATEGORY => 2

    /**
     * @type {String}
     */
    static PSGUID_VOLUME => "{9b174b35-40ff-11d2-a27e-00c04fc30871}"

    /**
     * @type {String}
     */
    static FMTID_Volume => "{9b174b35-40ff-11d2-a27e-00c04fc30871}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_VOLUME_FREE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_VOLUME_CAPACITY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PID_VOLUME_FILESYSTEM => 4

    /**
     * @type {String}
     */
    static PSGUID_SHARE => "{d8c3986f-813b-449c-845d-87b95d674ade}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_SHARE_CSC_STATUS => 2

    /**
     * @type {String}
     */
    static PSGUID_LINK => "{b9b4b3fc-2b51-4a42-b5d8-324146afcf25}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_LINK_TARGET => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_LINK_TARGET_TYPE => 3

    /**
     * @type {String}
     */
    static PSGUID_QUERY_D => "{49691c90-7e17-101a-a91c-08002b2ecda9}"

    /**
     * @type {String}
     */
    static FMTID_Query => "{49691c90-7e17-101a-a91c-08002b2ecda9}"

    /**
     * @type {Integer (UInt32)}
     */
    static PID_QUERY_RANK => 2

    /**
     * @type {String}
     */
    static PSGUID_SUMMARYINFORMATION => "{f29f85e0-4ff9-1068-ab91-08002b27b3d9}"

    /**
     * @type {String}
     */
    static PSGUID_DOCUMENTSUMMARYINFORMATION => "{d5cdd502-2e9c-101b-9397-08002b2cf9ae}"

    /**
     * @type {String}
     */
    static PSGUID_MEDIAFILESUMMARYINFORMATION => "{64440492-4c8b-11d1-8b70-080036b11a03}"

    /**
     * @type {String}
     */
    static PSGUID_IMAGESUMMARYINFORMATION => "{6444048f-4c8b-11d1-8b70-080036b11a03}"

    /**
     * @type {String}
     */
    static CLSID_HWShellExecute => "{ffb8655f-81b9-4fce-b89c-9a6ba76d13e7}"

    /**
     * @type {String}
     */
    static CLSID_DragDropHelper => "{4657278a-411b-11d2-839a-00c04fd918d0}"

    /**
     * @type {String}
     */
    static CLSID_CAnchorBrowsePropertyPage => "{3050f3bb-98b5-11cf-bb82-00aa00bdce0b}"

    /**
     * @type {String}
     */
    static CLSID_CImageBrowsePropertyPage => "{3050f3b3-98b5-11cf-bb82-00aa00bdce0b}"

    /**
     * @type {String}
     */
    static CLSID_CDocBrowsePropertyPage => "{3050f3b4-98b5-11cf-bb82-00aa00bdce0b}"

    /**
     * @type {String}
     */
    static SID_STopWindow => "{49e1b500-4636-11d3-97f7-00c04f45d0b3}"

    /**
     * @type {String}
     */
    static SID_SGetViewFromViewDual => "{889a935d-971e-4b12-b90c-24dfc9e1e5e8}"

    /**
     * @type {String}
     */
    static CLSID_FolderItemsMultiLevel => "{53c74826-ab99-4d33-aca4-3117f51d3788}"

    /**
     * @type {String}
     */
    static CLSID_NewMenu => "{d969a300-e7ff-11d0-a93b-00a0c90f2719}"

    /**
     * @type {String}
     */
    static BHID_SFObject => "{3981e224-f559-11d3-8e3a-00c04f6837d5}"

    /**
     * @type {String}
     */
    static BHID_SFUIObject => "{3981e225-f559-11d3-8e3a-00c04f6837d5}"

    /**
     * @type {String}
     */
    static BHID_SFViewObject => "{3981e226-f559-11d3-8e3a-00c04f6837d5}"

    /**
     * @type {String}
     */
    static BHID_Storage => "{3981e227-f559-11d3-8e3a-00c04f6837d5}"

    /**
     * @type {String}
     */
    static BHID_Stream => "{1cebb3ab-7c10-499a-a417-92ca16c4cb83}"

    /**
     * @type {String}
     */
    static BHID_RandomAccessStream => "{f16fc93b-77ae-4cfe-bda7-a866eea6878d}"

    /**
     * @type {String}
     */
    static BHID_LinkTargetItem => "{3981e228-f559-11d3-8e3a-00c04f6837d5}"

    /**
     * @type {String}
     */
    static BHID_StorageEnum => "{4621a4e3-f0d6-4773-8a9c-46e77b174840}"

    /**
     * @type {String}
     */
    static BHID_Transfer => "{d5e346a1-f753-4932-b403-4574800e2498}"

    /**
     * @type {String}
     */
    static BHID_PropertyStore => "{0384e1a4-1523-439c-a4c8-ab911052f586}"

    /**
     * @type {String}
     */
    static BHID_ThumbnailHandler => "{7b2e650a-8e20-4f4a-b09e-6597afc72fb0}"

    /**
     * @type {String}
     */
    static BHID_EnumItems => "{94f60519-2850-4924-aa5a-d15e84868039}"

    /**
     * @type {String}
     */
    static BHID_DataObject => "{b8c0bd9f-ed24-455c-83e6-d5390c4fe8c4}"

    /**
     * @type {String}
     */
    static BHID_AssociationArray => "{bea9ef17-82f1-4f60-9284-4f8db75c3be9}"

    /**
     * @type {String}
     */
    static BHID_Filter => "{38d08778-f557-4690-9ebf-ba54706ad8f7}"

    /**
     * @type {String}
     */
    static BHID_EnumAssocHandlers => "{b8ab0b9c-c2ec-4f7a-918d-314900e6280a}"

    /**
     * @type {String}
     */
    static BHID_StorageItem => "{404e2109-77d2-4699-a5a0-4fdf10db9837}"

    /**
     * @type {String}
     */
    static BHID_FilePlaceholder => "{8677dceb-aae0-4005-8d3d-547fa852f825}"

    /**
     * @type {String}
     */
    static CATID_FilePlaceholderMergeHandler => "{3e9c9a51-d4aa-4870-b47c-7424b491f1cc}"

    /**
     * @type {String}
     */
    static SID_CtxQueryAssociations => "{faadfc40-b777-4b69-aa81-77035ef0e6e8}"

    /**
     * @type {String}
     */
    static CLSID_QuickLinks => "{0e5cbf21-d15f-11d0-8301-00aa005b4383}"

    /**
     * @type {String}
     */
    static CLSID_ISFBand => "{d82be2b0-5764-11d0-a96e-00c04fd705a2}"

    /**
     * @type {String}
     */
    static CLSID_ShellFldSetExt => "{6d5313c0-8c62-11d1-b2cd-006097df8c11}"

    /**
     * @type {String}
     */
    static SID_SMenuBandChild => "{ed9cc020-08b9-11d1-9823-00c04fd91972}"

    /**
     * @type {String}
     */
    static SID_SMenuBandParent => "{8c278eec-3eab-11d1-8cb0-00c04fd918d0}"

    /**
     * @type {String}
     */
    static SID_SMenuPopup => "{d1e7afeb-6a2e-11d0-8c78-00c04fd918b4}"

    /**
     * @type {String}
     */
    static SID_SMenuBandBottomSelected => "{165ebaf4-6d51-11d2-83ad-00c04fd918d0}"

    /**
     * @type {String}
     */
    static SID_SMenuBandBottom => "{743ca664-0deb-11d1-9825-00c04fd91972}"

    /**
     * @type {String}
     */
    static SID_MenuShellFolder => "{a6c17eb4-2d65-11d2-838f-00c04fd918d0}"

    /**
     * @type {String}
     */
    static SID_SMenuBandContextMenuModifier => "{39545874-7162-465e-b783-2aa1874fef81}"

    /**
     * @type {String}
     */
    static SID_SMenuBandBKContextMenu => "{164bbd86-1d0d-4de0-9a3b-d9729647c2b8}"

    /**
     * @type {String}
     */
    static CGID_MENUDESKBAR => "{5c9f0a12-959e-11d0-a3a4-00a0c9082636}"

    /**
     * @type {String}
     */
    static SID_SMenuBandTop => "{9493a810-ec38-11d0-bc46-00aa006ce2f5}"

    /**
     * @type {String}
     */
    static CLSID_MenuToolbarBase => "{40b96610-b522-11d1-b3b4-00aa006efde7}"

    /**
     * @type {String}
     */
    static CLSID_MenuBandSite => "{e13ef4e4-d2f2-11d0-9816-00c04fd91972}"

    /**
     * @type {String}
     */
    static SID_SCommDlgBrowser => "{80f30233-b7df-11d2-a33b-006097df5bd4}"

    /**
     * @type {String}
     */
    static CPFG_LOGON_USERNAME => "{da15bbe8-954d-4fd3-b0f4-1fb5b90b174b}"

    /**
     * @type {String}
     */
    static CPFG_LOGON_PASSWORD => "{60624cfa-a477-47b1-8a8e-3a4a19981827}"

    /**
     * @type {String}
     */
    static CPFG_SMARTCARD_USERNAME => "{3e1ecf69-568c-4d96-9d59-46444174e2d6}"

    /**
     * @type {String}
     */
    static CPFG_SMARTCARD_PIN => "{4fe5263b-9181-46c1-b0a4-9dedd4db7dea}"

    /**
     * @type {String}
     */
    static CPFG_CREDENTIAL_PROVIDER_LOGO => "{2d837775-f6cd-464e-a745-482fd0b47493}"

    /**
     * @type {String}
     */
    static CPFG_CREDENTIAL_PROVIDER_LABEL => "{286bbff3-bad4-438f-b007-79b7267c3d48}"

    /**
     * @type {String}
     */
    static CPFG_STANDALONE_SUBMIT_BUTTON => "{0b7b0ad8-cc36-4d59-802b-82f714fa7022}"

    /**
     * @type {String}
     */
    static CPFG_STYLE_LINK_AS_BUTTON => "{088fa508-94a6-4430-a4cb-6fc6e3c0b9e2}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Invalid => "{57807898-8c4f-4462-bb63-71042380b109}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Generic => "{5c4f28b5-f869-4e84-8e60-f11db97c5cc7}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_GenericSearchResults => "{7fde1a1e-8b31-49a5-93b8-6be14cfa4943}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_GenericLibrary => "{5f4eab9a-6833-4f61-899d-31cf46979d49}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Documents => "{7d49d726-3c21-4f05-99aa-fdc2c9474656}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Pictures => "{b3690e58-e961-423b-b687-386ebfd83239}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Music => "{94d6ddcc-4a68-4175-a374-bd584a510b78}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Videos => "{5fa96407-7e77-483c-ac93-691d05850de8}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Downloads => "{885a186e-a440-4ada-812b-db871b942259}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_UserFiles => "{cd0fc69b-71e2-46e5-9690-5bcd9f57aab3}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_UsersLibraries => "{c4d98f09-6124-4fe0-9942-826416082da9}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_OtherUsers => "{b337fd00-9dd5-4635-a6d4-da33fd102b7a}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_PublishedItems => "{7f2f5b96-ff74-41da-afd8-1c78a5f3aea2}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Communications => "{91475fe5-586b-4eba-8d75-d17434b8cdf6}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Contacts => "{de2b70ec-9bf7-4a93-bd3d-243f7881d492}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_StartMenu => "{ef87b4cb-f2ce-4785-8658-4ca6c63e38c6}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_RecordedTV => "{5557a28f-5da6-4f83-8809-c2c98a11a6fa}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_SavedGames => "{d0363307-28cb-4106-9f23-2956e3e5e0e7}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_OpenSearch => "{8faf9629-1980-46ff-8023-9dceab9c3ee3}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_SearchConnector => "{982725ee-6f47-479e-b447-812bfa7d2e8f}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_AccountPictures => "{db2a5d8f-06e6-4007-aba6-af877d526ea6}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Games => "{b689b0d0-76d3-4cbb-87f7-585d0e0ce070}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_ControlPanelCategory => "{de4f0660-fa10-4b8f-a494-068b20b22307}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_ControlPanelClassic => "{0c3794f3-b545-43aa-a329-c37430c58d2a}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Printers => "{2c7bbec6-c844-4a0a-91fa-cef6f59cfda1}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_RecycleBin => "{d6d9e004-cd87-442b-9d57-5e0aeb4f6f72}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_SoftwareExplorer => "{d674391b-52d9-4e07-834e-67c98610f39d}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_CompressedFolder => "{80213e82-bcfd-4c4f-8817-bb27601267a9}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_NetworkExplorer => "{25cc242b-9a7c-4f51-80e0-7a2928febe42}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_Searches => "{0b0ba2e3-405f-415e-a6ee-cad625207853}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_SearchHome => "{834d8a44-0974-4ed6-866e-f203d80b3810}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_StorageProviderGeneric => "{4f01ebc5-2385-41f2-a28e-2c5c91fb56e0}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_StorageProviderDocuments => "{dd61bd66-70e8-48dd-9655-65c5e1aac2d1}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_StorageProviderPictures => "{71d642a9-f2b1-42cd-ad92-eb9300c7cc0a}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_StorageProviderMusic => "{672ecd7e-af04-4399-875c-0290845b6247}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_StorageProviderVideos => "{51294da1-d7b1-485b-9e9a-17cffe33e187}"

    /**
     * @type {String}
     */
    static FOLDERTYPEID_VersionControl => "{69f1e26b-ec64-4280-bc83-f1eb887ec35a}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_Icon => "{6dbc85c3-5d07-4c72-a777-7fec78072c06}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_EventStore => "{4bef34b9-a786-4075-ba88-0c2b9d89a98f}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_ConflictStore => "{d78181f4-2389-47e4-a960-60bcc2ed930b}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_BrowseContent => "{57cbb584-e9b4-47ae-a120-c4df3335dee2}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_ShowSchedule => "{edc6f3e3-8441-4109-adf3-6c1ca0b7de47}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_QueryBeforeActivate => "{d882d80b-e7aa-49ed-86b7-e6e1f714cdfe}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_QueryBeforeDeactivate => "{a0efc282-60e0-460e-9374-ea88513cfc80}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_QueryBeforeEnable => "{04cbf7f0-5beb-4de1-bc90-908345c480f6}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_QueryBeforeDisable => "{bb5f64aa-f004-4eb5-8e4d-26751966344c}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_QueryBeforeDelete => "{f76c3397-afb3-45d7-a59f-5a49e905437e}"

    /**
     * @type {String}
     */
    static SYNCMGR_OBJECTID_EventLinkClick => "{2203bdc1-1af1-4082-8c30-28399f41384c}"

    /**
     * @type {String}
     */
    static EP_NavPane => "{cb316b22-25f7-42b8-8a09-540d23a43c2f}"

    /**
     * @type {String}
     */
    static EP_Commands => "{d9745868-ca5f-4a76-91cd-f5a129fbb076}"

    /**
     * @type {String}
     */
    static EP_Commands_Organize => "{72e81700-e3ec-4660-bf24-3c3b7b648806}"

    /**
     * @type {String}
     */
    static EP_Commands_View => "{21f7c32d-eeaa-439b-bb51-37b96fd6a943}"

    /**
     * @type {String}
     */
    static EP_DetailsPane => "{43abf98b-89b8-472d-b9ce-e69b8229f019}"

    /**
     * @type {String}
     */
    static EP_PreviewPane => "{893c63d1-45c8-4d17-be19-223be71be365}"

    /**
     * @type {String}
     */
    static EP_QueryPane => "{65bcde4f-4f07-4f27-83a7-1afca4df7ddd}"

    /**
     * @type {String}
     */
    static EP_AdvQueryPane => "{b4e9db8b-34ba-4c39-b5cc-16a1bd2c411c}"

    /**
     * @type {String}
     */
    static EP_StatusBar => "{65fe56ce-5cfe-4bc4-ad8a-7ae3fe7e8f7c}"

    /**
     * @type {String}
     */
    static EP_Ribbon => "{d27524a8-c9f2-4834-a106-df8889fd4f37}"

    /**
     * @type {String}
     */
    static CATID_LocationFactory => "{965c4d51-8b76-4e57-80b7-564d2ea4b55e}"

    /**
     * @type {String}
     */
    static CATID_LocationProvider => "{1b3ca474-2614-414b-b813-1aceca3e3dd8}"

    /**
     * @type {String}
     */
    static ItemCount_Property_GUID => "{abbf5c45-5ccc-47b7-bb4e-87cb87bbd162}"

    /**
     * @type {String}
     */
    static SelectedItemCount_Property_GUID => "{8fe316d2-0e52-460a-9c1e-48f273d470a3}"

    /**
     * @type {String}
     */
    static ItemIndex_Property_GUID => "{92a053da-2969-4021-bf27-514cfc2e4a69}"

    /**
     * @type {String}
     */
    static CATID_SearchableApplication => "{366c292a-d9b3-4dbf-bb70-e62ec3d0bbbf}"

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_WIZEXTN_FIRST => 20480

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_WIZEXTN_LAST => 20736

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_NORECOMPRESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_NONETPLACECREATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_NOFILESELECTOR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_USEMRU => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_ANYLOCATION => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_VALIDATEVIAWEBFOLDERS => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static ACDD_VISIBLE => 1

    /**
     * @type {String}
     */
    static PROPSTR_EXTENSIONCOMPLETIONSTATE => "ExtensionCompletionState"

    /**
     * @type {String}
     */
    static SID_SCommandBarState => "{b99eaa5c-3850-4400-bc33-2ce534048bf8}"

    /**
     * @type {Integer (Int32)}
     */
    static NSTCDHPOS_ONTOP => -1

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_RECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_PINNED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_NEWFAILED => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_NEWFILE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_CANVIEWIT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_TOOLBAR => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_STATUS => 40961

    /**
     * @type {Integer (UInt32)}
     */
    static IDC_OFFLINE_HAND => 103

    /**
     * @type {Integer (UInt32)}
     */
    static IDC_PANTOOL_HAND_OPEN => 104

    /**
     * @type {Integer (UInt32)}
     */
    static IDC_PANTOOL_HAND_CLOSED => 105

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_NONE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_ZONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_OFFLINE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_PRINTER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_SSL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_NAVIGATION => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_PROGRESS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_PRIVACY => 7

    /**
     * @type {Integer (UInt32)}
     */
    static DWFRF_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DWFRF_DELETECONFIGDATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DWFAF_HIDDEN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DWFAF_GROUP1 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DWFAF_GROUP2 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DWFAF_AUTOHIDE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMSTCAPFLAG_LOCKABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMSTCAPFLAG_PURGEABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_STATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_BKCOLOR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_VIEWMODE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_SHELLFOLDER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_IDLIST => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_COLORS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_DEBOSSED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_ALLOWRENAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_NOSHOWTEXT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_CHANNELBAR => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_QLINKSMODE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_FULLOPEN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_NONAMESORT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_BTNMINSIZE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static ISFBVIEWMODE_SMALLICONS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISFBVIEWMODE_LARGEICONS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISFBVIEWMODE_LOGOS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_GS_IDEAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_GS_SIZEDOWN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_HIDE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_SHOW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_SHOWOBSCURE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSM_CLEAR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SSM_SET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSM_REFRESH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSM_UPDATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_DISPLAY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_EDIT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_LOCAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_GLOBAL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_REFRESH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_UPDATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_DONOTUSE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_CREATE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static GADOF_DIRTY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHCDF_UPDATEITEM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_ADDQUOTES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_ADDARGUMENTS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_NODIRECTORIES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_FORCEQUALIFY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_LONGESTPOSSIBLE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static OPENPROPS_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OPENPROPS_INHIBITPIF => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static GETPROPS_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SETPROPS_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLOSEPROPS_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLOSEPROPS_DISCARD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_APPEND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_PREPEND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_REPLACE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_INTERNETBAR => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_STANDARDTOOLBAR => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_NOTOOLBAR => 196608

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_REARRANGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_ADDOBJECT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_REMOVEOBJECT => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_UPDATEOBJECT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_GETSELECTEDOBJECTS => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_SETITEMPOS => 14

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_SETCLIPBOARD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_SETPOINTS => 23

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_OPENICON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_FORSHELL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_ASYNC => 32

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_DEFAULTICON => 64

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_FORSHORTCUT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_CHECKSHIELD => 512

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_SIMULATEDOC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_PERINSTANCE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_PERCLASS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_NOTFILENAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_DONTCACHE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_SHIELD => 512

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_FORCENOSHIELD => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_OVERLAYINDEX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_ICONINDEX => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_RESERVED_SHARED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_RESERVED_LINK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_RESERVED_SLOWFILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_RESERVED_DEFAULT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static OI_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OI_ASYNC => 4294962926

    /**
     * @type {Integer (UInt32)}
     */
    static IDO_SHGIOI_SHARE => 268435455

    /**
     * @type {Integer (UInt32)}
     */
    static IDO_SHGIOI_LINK => 268435454

    /**
     * @type {Integer (UInt64)}
     */
    static IDO_SHGIOI_SLOWFILE => 4294967293

    /**
     * @type {Integer (UInt64)}
     */
    static IDO_SHGIOI_DEFAULT => 4294967292

    /**
     * @type {Integer (UInt32)}
     */
    static NT_CONSOLE_PROPS_SIG => 2684354562

    /**
     * @type {Integer (UInt32)}
     */
    static NT_FE_CONSOLE_PROPS_SIG => 2684354564

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_DARWIN_ID_SIG => 2684354566

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_SPECIAL_FOLDER_SIG => 2684354565

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_SZ_LINK_SIG => 2684354561

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_SZ_ICON_SIG => 2684354567

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_PROPERTYSTORAGE_SIG => 2684354569

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_SHVIEWFIRST => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_SHVIEWLAST => 32767

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_BROWSERFIRST => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_BROWSERLAST => 48896

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_GLOBALFIRST => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_GLOBALLAST => 40959

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_FILE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_EDIT => 32832

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_VIEW => 32896

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_VIEW_SEP_OPTIONS => 32897

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_TOOLS => 32960

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_TOOLS_SEP_GOTO => 32961

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_HELP => 33024

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_FIND => 33088

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_EXPLORE => 33104

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_FAVORITES => 33136

    /**
     * @type {Integer (UInt32)}
     */
    static OFASI_EDIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFASI_OPENDESKTOP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_DESKTOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_INTERNET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAMS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_CONTROLS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PRINTERS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PERSONAL => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FAVORITES => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_STARTUP => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_RECENT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_SENDTO => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_BITBUCKET => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_STARTMENU => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_MYDOCUMENTS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_MYMUSIC => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_MYVIDEO => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_DESKTOPDIRECTORY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_DRIVES => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_NETWORK => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_NETHOOD => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FONTS => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_TEMPLATES => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_STARTMENU => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_PROGRAMS => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_STARTUP => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_DESKTOPDIRECTORY => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_APPDATA => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PRINTHOOD => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_LOCAL_APPDATA => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_ALTSTARTUP => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_ALTSTARTUP => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_FAVORITES => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_INTERNET_CACHE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COOKIES => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_HISTORY => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_APPDATA => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_WINDOWS => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_SYSTEM => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAM_FILES => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_MYPICTURES => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROFILE => 40

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_SYSTEMX86 => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAM_FILESX86 => 42

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAM_FILES_COMMON => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAM_FILES_COMMONX86 => 44

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_TEMPLATES => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_DOCUMENTS => 46

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_ADMINTOOLS => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_ADMINTOOLS => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_CONNECTIONS => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_MUSIC => 53

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_PICTURES => 54

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_VIDEO => 55

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_RESOURCES => 56

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_RESOURCES_LOCALIZED => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_OEM_LINKS => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_CDBURN_AREA => 59

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMPUTERSNEARME => 61

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_CREATE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_DONT_VERIFY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_DONT_UNEXPAND => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_NO_ALIAS => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_PER_USER_INIT => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_MASK => 65280

    /**
     * @type {Integer (UInt32)}
     */
    static FCS_READ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FCS_FORCEWRITE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCS_FLAG_DRAGDROP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_VIEWID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_WEBVIEWTEMPLATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_INFOTIP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_CLSID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_ICONFILE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_LOGO => 32

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_FLAGS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_RETURNONLYFSDIRS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_DONTGOBELOWDOMAIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_STATUSTEXT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_RETURNFSANCESTORS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_EDITBOX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_VALIDATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_NEWDIALOGSTYLE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEINCLUDEURLS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_UAHINT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_NONEWFOLDERBUTTON => 512

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_NOTRANSLATETARGETS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEFORCOMPUTER => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEFORPRINTER => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEINCLUDEFILES => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_SHAREABLE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEFILEJUNCTIONS => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_INITIALIZED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SELCHANGED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_VALIDATEFAILEDA => 3

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_VALIDATEFAILEDW => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_IUNKNOWN => 5

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSTATUSTEXTA => 1124

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_ENABLEOK => 1125

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSELECTIONA => 1126

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSELECTIONW => 1127

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSTATUSTEXTW => 1128

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETOKTEXT => 1129

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETEXPANDED => 1130

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSTATUSTEXT => 1128

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSELECTION => 1127

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_VALIDATEFAILED => 4

    /**
     * @type {Integer (Int32)}
     */
    static CMDID_INTSHORTCUTCREATE => 1

    /**
     * @type {String}
     */
    static STR_PARSE_WITH_PROPERTIES => "ParseWithProperties"

    /**
     * @type {String}
     */
    static STR_PARSE_PARTIAL_IDLIST => "ParseOriginalItem"

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_MODAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_AUTOTIME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NOTIME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NOMINIMIZE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NOPROGRESSBAR => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_MARQUEEPROGRESS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NOCANCEL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PDTIMER_RESET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PDTIMER_PAUSE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PDTIMER_RESUME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static COMPONENT_TOP => 1073741823

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_HTMLDOC => 0

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_PICTURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_WEBSITE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_CONTROL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_CFHTML => 4

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_MAX => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IS_NORMAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IS_FULLSCREEN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IS_SPLIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_SAVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_HTMLGEN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_REFRESH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_FORCE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_BUFFERED_REFRESH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_DYNAMICREFRESH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static AD_GETWP_BMP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static AD_GETWP_IMAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AD_GETWP_LAST_APPLIED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_CENTER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_TILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_STRETCH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_KEEPASPECT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_CROPTOFIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_SPAN => 5

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_MAX => 6

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_CHECKED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_DIRTY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_NOSCROLL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_POS_LEFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_POS_TOP => 32

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_SIZE_WIDTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_SIZE_HEIGHT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_POS_ZINDEX => 256

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_SOURCE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_FRIENDLYNAME => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_SUBSCRIBEDURL => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_ORIGINAL_CSI => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_RESTORED_CSI => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_CURITEMSTATE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static ADDURL_SILENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COMPONENT_DEFAULT_LEFT => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static COMPONENT_DEFAULT_TOP => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_COLUMN_NAME_LEN => 80

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_COLUMN_DESC_LEN => 128

    /**
     * @type {String}
     */
    static CFSTR_SHELLIDLIST => "Shell IDList Array"

    /**
     * @type {String}
     */
    static CFSTR_SHELLIDLISTOFFSET => "Shell Object Offsets"

    /**
     * @type {String}
     */
    static CFSTR_NETRESOURCES => "Net Resource"

    /**
     * @type {String}
     */
    static CFSTR_FILEDESCRIPTORA => "FileGroupDescriptor"

    /**
     * @type {String}
     */
    static CFSTR_FILEDESCRIPTORW => "FileGroupDescriptorW"

    /**
     * @type {String}
     */
    static CFSTR_FILECONTENTS => "FileContents"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEA => "FileName"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEW => "FileNameW"

    /**
     * @type {String}
     */
    static CFSTR_PRINTERGROUP => "PrinterFriendlyName"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEMAPA => "FileNameMap"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEMAPW => "FileNameMapW"

    /**
     * @type {String}
     */
    static CFSTR_SHELLURL => "UniformResourceLocator"

    /**
     * @type {String}
     */
    static CFSTR_INETURLA => "UniformResourceLocator"

    /**
     * @type {String}
     */
    static CFSTR_INETURLW => "UniformResourceLocatorW"

    /**
     * @type {String}
     */
    static CFSTR_PREFERREDDROPEFFECT => "Preferred DropEffect"

    /**
     * @type {String}
     */
    static CFSTR_PERFORMEDDROPEFFECT => "Performed DropEffect"

    /**
     * @type {String}
     */
    static CFSTR_PASTESUCCEEDED => "Paste Succeeded"

    /**
     * @type {String}
     */
    static CFSTR_INDRAGLOOP => "InShellDragLoop"

    /**
     * @type {String}
     */
    static CFSTR_MOUNTEDVOLUME => "MountedVolume"

    /**
     * @type {String}
     */
    static CFSTR_PERSISTEDDATAOBJECT => "PersistedDataObject"

    /**
     * @type {String}
     */
    static CFSTR_TARGETCLSID => "TargetCLSID"

    /**
     * @type {String}
     */
    static CFSTR_LOGICALPERFORMEDDROPEFFECT => "Logical Performed DropEffect"

    /**
     * @type {String}
     */
    static CFSTR_AUTOPLAY_SHELLIDLISTS => "Autoplay Enumerated IDList Array"

    /**
     * @type {String}
     */
    static CFSTR_UNTRUSTEDDRAGDROP => "UntrustedDragDrop"

    /**
     * @type {String}
     */
    static CFSTR_FILE_ATTRIBUTES_ARRAY => "File Attributes Array"

    /**
     * @type {String}
     */
    static CFSTR_INVOKECOMMAND_DROPPARAM => "InvokeCommand DropParam"

    /**
     * @type {String}
     */
    static CFSTR_SHELLDROPHANDLER => "DropHandlerCLSID"

    /**
     * @type {String}
     */
    static CFSTR_DROPDESCRIPTION => "DropDescription"

    /**
     * @type {String}
     */
    static CFSTR_ZONEIDENTIFIER => "ZoneIdentifier"

    /**
     * @type {String}
     */
    static CFSTR_FILEDESCRIPTOR => "FileGroupDescriptorW"

    /**
     * @type {String}
     */
    static CFSTR_FILENAME => "FileNameW"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEMAP => "FileNameMapW"

    /**
     * @type {String}
     */
    static CFSTR_INETURL => "UniformResourceLocatorW"

    /**
     * @type {Integer (UInt32)}
     */
    static DVASPECT_SHORTNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DVASPECT_COPY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DVASPECT_LINK => 4

    /**
     * @type {Integer (Int32)}
     */
    static SHCNEE_ORDERCHANGED => 2

    /**
     * @type {Integer (Int32)}
     */
    static SHCNEE_MSI_CHANGE => 4

    /**
     * @type {Integer (Int32)}
     */
    static SHCNEE_MSI_UNINSTALL => 5

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_POINTS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CABINETSTATE_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIFNAMESIZE => 30

    /**
     * @type {Integer (UInt32)}
     */
    static PIFSTARTLOCSIZE => 63

    /**
     * @type {Integer (UInt32)}
     */
    static PIFDEFPATHSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIFPARAMSSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIFSHPROGSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIFSHDATASIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIFDEFFILESIZE => 80

    /**
     * @type {Integer (UInt32)}
     */
    static PIFMAXFILEPATH => 260

    /**
     * @type {Integer (UInt32)}
     */
    static QCMINFO_PLACE_BEFORE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static QCMINFO_PLACE_AFTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SFVSOC_INVALIDATE_ALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SFVSOC_NOSCROLL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHELLSTATEVERSION_IE4 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SHELLSTATEVERSION_WIN2K => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_DIRCREATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_ASKDIRCREATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_IGNOREFILENAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_NOWRITECHECK => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_MEDIACHECKONLY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_DEFAULTONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_VERBSONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_EXPLORE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_NOVERBS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_CANRENAME => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_NODEFAULT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_INCLUDESTATIC => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_ITEMMENU => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_EXTENDEDVERBS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_DISABLEDVERBS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_ASYNCVERBSTATE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_OPTIMIZEFORINVOKE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_SYNCCASCADEMENU => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_DONOTPICKDEFAULT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_RESERVED => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VERBA => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_HELPTEXTA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VALIDATEA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VERBW => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_HELPTEXTW => 5

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VALIDATEW => 6

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VERBICONW => 20

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_UNICODE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VERB => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_HELPTEXT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VALIDATE => 6

    /**
     * @type {String}
     */
    static CMDSTR_NEWFOLDERA => "NewFolder"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWLISTA => "ViewList"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWDETAILSA => "ViewDetails"

    /**
     * @type {String}
     */
    static CMDSTR_NEWFOLDERW => "NewFolder"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWLISTW => "ViewList"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWDETAILSW => "ViewDetails"

    /**
     * @type {String}
     */
    static CMDSTR_NEWFOLDER => "NewFolder"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWLIST => "ViewList"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWDETAILS => "ViewDetails"

    /**
     * @type {Integer (UInt32)}
     */
    static CMIC_MASK_SHIFT_DOWN => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CMIC_MASK_CONTROL_DOWN => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CMIC_MASK_PTINVOKE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_NOT_RUNNING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_RUNNING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_SUSPENDED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_PENDING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_FINISHED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ITSAT_DEFAULT_PRIORITY => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static ITSAT_MAX_PRIORITY => 2147483647

    /**
     * @type {Integer (UInt32)}
     */
    static ITSAT_MIN_PRIORITY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ITSSFLAG_COMPLETE_ON_DESTROY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ITSSFLAG_KILL_ON_DESTROY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ITSSFLAG_FLAGS_MASK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ITSS_THREAD_TIMEOUT_NO_CHANGE => 4294967294

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_PFTI_TRACKTARGET => 16384

    /**
     * @type {Integer (Int32)}
     */
    static SHCIDS_ALLFIELDS => -2147483648

    /**
     * @type {Integer (Int32)}
     */
    static SHCIDS_CANONICALONLY => 268435456

    /**
     * @type {Integer (Int32)}
     */
    static SHCIDS_BITMASK => -65536

    /**
     * @type {Integer (Int32)}
     */
    static SHCIDS_COLUMNMASK => 65535

    /**
     * @type {String}
     */
    static CONFLICT_RESOLUTION_CLSID_KEY => "ConflictResolutionCLSID"

    /**
     * @type {String}
     */
    static STR_BIND_FORCE_FOLDER_SHORTCUT_RESOLVE => "Force Folder Shortcut Resolve"

    /**
     * @type {String}
     */
    static STR_AVOID_DRIVE_RESTRICTION_POLICY => "Avoid Drive Restriction Policy"

    /**
     * @type {String}
     */
    static STR_SKIP_BINDING_CLSID => "Skip Binding CLSID"

    /**
     * @type {String}
     */
    static STR_PARSE_PREFER_FOLDER_BROWSING => "Parse Prefer Folder Browsing"

    /**
     * @type {String}
     */
    static STR_DONT_PARSE_RELATIVE => "Don't Parse Relative"

    /**
     * @type {String}
     */
    static STR_PARSE_TRANSLATE_ALIASES => "Parse Translate Aliases"

    /**
     * @type {String}
     */
    static STR_PARSE_SKIP_NET_CACHE => "Skip Net Resource Cache"

    /**
     * @type {String}
     */
    static STR_PARSE_SHELL_PROTOCOL_TO_FILE_OBJECTS => "Parse Shell Protocol To File Objects"

    /**
     * @type {String}
     */
    static STR_TRACK_CLSID => "Track the CLSID"

    /**
     * @type {String}
     */
    static STR_INTERNAL_NAVIGATE => "Internal Navigation"

    /**
     * @type {String}
     */
    static STR_PARSE_PROPERTYSTORE => "DelegateNamedProperties"

    /**
     * @type {String}
     */
    static STR_NO_VALIDATE_FILENAME_CHARS => "NoValidateFilenameChars"

    /**
     * @type {String}
     */
    static STR_BIND_DELEGATE_CREATE_OBJECT => "Delegate Object Creation"

    /**
     * @type {String}
     */
    static STR_PARSE_ALLOW_INTERNET_SHELL_FOLDERS => "Allow binding to Internet shell folder handlers and negate STR_PARSE_PREFER_WEB_BROWSING"

    /**
     * @type {String}
     */
    static STR_PARSE_PREFER_WEB_BROWSING => "Do not bind to Internet shell folder handlers"

    /**
     * @type {String}
     */
    static STR_PARSE_SHOW_NET_DIAGNOSTICS_UI => "Show network diagnostics UI"

    /**
     * @type {String}
     */
    static STR_PARSE_DONT_REQUIRE_VALIDATED_URLS => "Do not require validated URLs"

    /**
     * @type {String}
     */
    static STR_INTERNETFOLDER_PARSE_ONLY_URLMON_BINDABLE => "Validate URL"

    /**
     * @type {Integer (UInt32)}
     */
    static BIND_INTERRUPTABLE => 4294967295

    /**
     * @type {String}
     */
    static STR_BIND_FOLDERS_READ_ONLY => "Folders As Read Only"

    /**
     * @type {String}
     */
    static STR_BIND_FOLDER_ENUM_MODE => "Folder Enum Mode"

    /**
     * @type {String}
     */
    static STR_PARSE_WITH_EXPLICIT_PROGID => "ExplicitProgid"

    /**
     * @type {String}
     */
    static STR_PARSE_WITH_EXPLICIT_ASSOCAPP => "ExplicitAssociationApp"

    /**
     * @type {String}
     */
    static STR_PARSE_EXPLICIT_ASSOCIATION_SUCCESSFUL => "ExplicitAssociationSuccessful"

    /**
     * @type {String}
     */
    static STR_PARSE_AND_CREATE_ITEM => "ParseAndCreateItem"

    /**
     * @type {String}
     */
    static STR_PROPERTYBAG_PARAM => "SHBindCtxPropertyBag"

    /**
     * @type {String}
     */
    static STR_ENUM_ITEMS_FLAGS => "SHCONTF"

    /**
     * @type {String}
     */
    static STR_STORAGEITEM_CREATION_FLAGS => "SHGETSTORAGEITEM"

    /**
     * @type {String}
     */
    static STR_ITEM_CACHE_CONTEXT => "ItemCacheContext"

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_SETFOCUS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_KILLFOCUS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_SELCHANGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_RENAME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_STATECHANGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2N_CONTEXTMENU_DONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2N_CONTEXTMENU_START => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_SHOWALLFILES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_ISFILESAVE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_ALLOWPREVIEWPANE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_NOSELECTVERB => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_NOINCLUDEITEM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_ISFOLDERPICKER => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_ADDSHIELD => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_DEFBROWSER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_SAMEBROWSER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NEWBROWSER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_DEFMODE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_OPENMODE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_EXPLOREMODE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_HELPMODE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NOTRANSFERHIST => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_ABSOLUTE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_RELATIVE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_PARENT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NAVIGATEBACK => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NAVIGATEFORWARD => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_ALLOW_AUTONAVIGATE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_KEEPSAMETEMPLATE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_KEEPWORDWHEELTEXT => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_ACTIVATE_NOFOCUS => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_CREATENOHISTORY => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_PLAYNOSOUND => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_CALLERUNTRUSTED => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_TRUSTFIRSTDOWNLOAD => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_UNTRUSTEDFORDOWNLOAD => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NOAUTOSELECT => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_WRITENOHISTORY => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_TRUSTEDFORACTIVEX => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_FEEDNAVIGATION => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_REDIRECT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_INITIATEDBYHLINKFRAME => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_STATUS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_TOOLBAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_TREE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_INTERNETBAR => 6

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_PROGRESS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FCT_MERGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FCT_CONFIGABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCT_ADDTOEND => 4

    /**
     * @type {String}
     */
    static STR_DONT_RESOLVE_LINK => "Don't Resolve Link"

    /**
     * @type {String}
     */
    static STR_GET_ASYNC_HANDLER => "GetAsyncHandler"

    /**
     * @type {String}
     */
    static STR_GPS_HANDLERPROPERTIESONLY => "GPS_HANDLERPROPERTIESONLY"

    /**
     * @type {String}
     */
    static STR_GPS_FASTPROPERTIESONLY => "GPS_FASTPROPERTIESONLY"

    /**
     * @type {String}
     */
    static STR_GPS_OPENSLOWITEM => "GPS_OPENSLOWITEM"

    /**
     * @type {String}
     */
    static STR_GPS_DELAYCREATION => "GPS_DELAYCREATION"

    /**
     * @type {String}
     */
    static STR_GPS_BESTEFFORT => "GPS_BESTEFFORT"

    /**
     * @type {String}
     */
    static STR_GPS_NO_OPLOCK => "GPS_NO_OPLOCK"

    /**
     * @type {String}
     */
    static DI_GETDRAGIMAGE => "ShellGetDragImage"

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUTORUNINF => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUDIOCD => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_DVDMOVIE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_BLANKCD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_BLANKDVD => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_UNKNOWNCONTENT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUTOPLAYPIX => 128

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUTOPLAYMUSIC => 256

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUTOPLAYVIDEO => 512

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_VCD => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_SVCD => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_DVDAUDIO => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_BLANKBD => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_BLURAY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_CAMERASTORAGE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_CUSTOMEVENT => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_MASK => 131070

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_PRESNIFF => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_SNIFFING => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_FINAL => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_MASK => 1879048192

    /**
     * @type {Integer (UInt32)}
     */
    static IEI_PRIORITY_MAX => 2147483647

    /**
     * @type {Integer (UInt32)}
     */
    static IEI_PRIORITY_MIN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IEIT_PRIORITY_NORMAL => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_ASYNC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_CACHE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_ASPECT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_OFFLINE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_GLEAM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_SCREEN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_ORIGSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_NOSTAMP => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_NOBORDER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_QUALITY => 512

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_REFRESH => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_MINSIZE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_MAXSIZE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_INTEGRAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_ACTUAL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_TITLE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_MODEFLAGS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_BKCOLOR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_FIXED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_FIXEDBMP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_VARIABLEHEIGHT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_UNDELETEABLE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_DEBOSSED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_BKCOLOR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_USECHEVRON => 128

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_BREAK => 256

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_ADDTOFRONT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_TOPALIGN => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_NOGRIPPER => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_ALWAYSGRIPPER => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_NOMARGINS => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static DBIF_VIEWMODE_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBIF_VIEWMODE_VERTICAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBIF_VIEWMODE_FLOATING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DBIF_VIEWMODE_TRANSPARENT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBPC_SELECTFIRST => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static THBN_CLICKED => 6144

    /**
     * @type {Integer (UInt32)}
     */
    static BSIM_STATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSIM_STYLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSSF_VISIBLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSSF_NOTITLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSSF_UNDELETEABLE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_AUTOGRIPPER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_NOGRIPPER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_ALWAYSGRIPPER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_LEFTALIGN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_SINGLECLICK => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_NOCONTEXTMENU => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_NODROPTARGET => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_NOCAPTION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_PREFERNOLINEBREAK => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_LOCKED => 256

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_PRESERVEORDERDURINGLAYOUT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_FIXEDORDER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static OF_CAP_CANSWITCHTO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OF_CAP_CANCLOSE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMDM_SHELLFOLDER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMDM_HMENU => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMDM_TOOLBAR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_INITMENU => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_CREATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_EXITMENU => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETINFO => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETSFINFO => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETOBJECT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETSFOBJECT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SFEXEC => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SFSELECTITEM => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_REFRESH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_DEMOTE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_PROMOTE => 18

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_DEFAULTICON => 22

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_NEWITEM => 23

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_CHEVRONEXPAND => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_DISPLAYCHEVRONTIP => 42

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SETSFOBJECT => 45

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SHCHANGENOTIFY => 46

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_CHEVRONGETTIP => 47

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SFDDRESTRICTED => 48

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SFEXEC_MIDDLE => 49

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETAUTOEXPANDSTATE => 65

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_AUTOEXPANDCHANGE => 66

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETCONTEXTMENUMODIFIER => 67

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETBKCONTEXTMENU => 68

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_OPEN => 69

    /**
     * @type {Integer (UInt32)}
     */
    static SMAE_EXPANDED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMAE_CONTRACTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMAE_USER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SMAE_VALID => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_RESTRICT_DRAGDROP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_TOPLEVEL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_CACHED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_AUTOEXPAND => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_AUTOTOOLTIP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_DROPONCONTAINER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_VERTICAL => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_HORIZONTAL => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SMSET_TOP => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SMSET_BOTTOM => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SMSET_DONTOWN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMINV_REFRESH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMINV_ID => 8

    /**
     * @type {Integer (Int32)}
     */
    static E_PREVIEWHANDLER_DRM_FAIL => -2042494975

    /**
     * @type {Integer (Int32)}
     */
    static E_PREVIEWHANDLER_NOAUTH => -2042494974

    /**
     * @type {Integer (Int32)}
     */
    static E_PREVIEWHANDLER_NOTFOUND => -2042494973

    /**
     * @type {Integer (Int32)}
     */
    static E_PREVIEWHANDLER_CORRUPT => -2042494972

    /**
     * @type {String}
     */
    static STR_FILE_SYS_BIND_DATA => "File System Bind Data"

    /**
     * @type {String}
     */
    static STR_FILE_SYS_BIND_DATA_WIN7_FORMAT => "Win7FileSystemIdList"

    /**
     * @type {String}
     */
    static HOMEGROUP_SECURITY_GROUP_MULTI => "HUG"

    /**
     * @type {String}
     */
    static HOMEGROUP_SECURITY_GROUP => "HomeUsers"

    /**
     * @type {String}
     */
    static PROP_CONTRACT_DELEGATE => "ContractDelegate"

    /**
     * @type {String}
     */
    static SID_URLExecutionContext => "{fb5f8ebc-bbb6-4d10-a461-777291a09030}"

    /**
     * @type {String}
     */
    static STR_TAB_REUSE_IDENTIFIER => "Tab Reuse Identifier"

    /**
     * @type {String}
     */
    static STR_REFERRER_IDENTIFIER => "Referrer Identifier"

    /**
     * @type {String}
     */
    static SID_LaunchSourceViewSizePreference => "{80605492-67d9-414f-af89-a1cdf1242bc1}"

    /**
     * @type {String}
     */
    static SID_LaunchTargetViewSizePreference => "{26db2472-b7b7-406b-9702-730a4e20d3bf}"

    /**
     * @type {String}
     */
    static SID_LaunchSourceAppUserModelId => "{2ce78010-74db-48bc-9c6a-10f372495723}"

    /**
     * @type {String}
     */
    static SID_ShellExecuteNamedPropertyStore => "{eb84ada2-00ff-4992-8324-ed5ce061cb29}"

    /**
     * @type {Integer (UInt32)}
     */
    static ISIOI_ICONFILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISIOI_ICONINDEX => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_NEW => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_REMOVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_QUERYPOS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_SETPOS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_GETSTATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_GETTASKBARPOS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_ACTIVATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_GETAUTOHIDEBAR => 7

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_SETAUTOHIDEBAR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_WINDOWPOSCHANGED => 9

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_SETSTATE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_GETAUTOHIDEBAREX => 11

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_SETAUTOHIDEBAREX => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ABN_STATECHANGE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ABN_POSCHANGED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ABN_FULLSCREENAPP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABN_WINDOWARRANGE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ABS_AUTOHIDE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ABS_ALWAYSONTOP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABE_LEFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ABE_TOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ABE_RIGHT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABE_BOTTOM => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FO_MOVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FO_COPY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FO_DELETE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FO_RENAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PO_DELETE => 19

    /**
     * @type {Integer (UInt32)}
     */
    static PO_RENAME => 20

    /**
     * @type {Integer (UInt32)}
     */
    static PO_PORTCHANGE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PO_REN_PORT => 52

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_FNF => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_PNF => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_ACCESSDENIED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_OOM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_DLLNOTFOUND => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_SHARE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_ASSOCINCOMPLETE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_DDETIMEOUT => 28

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_DDEFAIL => 29

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_DDEBUSY => 30

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_NOASSOC => 31

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_CLASSNAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_CLASSKEY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_IDLIST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_INVOKEIDLIST => 12

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_ICON => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_HOTKEY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NOCLOSEPROCESS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_CONNECTNETDRV => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NOASYNC => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_FLAG_DDEWAIT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_DOENVSUBST => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_FLAG_NO_UI => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_UNICODE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NO_CONSOLE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_ASYNCOK => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_HMONITOR => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NOZONECHECKS => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NOQUERYCLASSSTORE => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_WAITFORINPUTIDLE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_FLAG_LOG_USAGE => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_FLAG_HINST_IS_SITE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static SHERB_NOCONFIRMATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHERB_NOPROGRESSUI => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHERB_NOSOUND => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_SELECT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static NINF_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_BALLOONSHOW => 1026

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_BALLOONHIDE => 1027

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_BALLOONTIMEOUT => 1028

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_BALLOONUSERCLICK => 1029

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_POPUPOPEN => 1030

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_POPUPCLOSE => 1031

    /**
     * @type {Integer (UInt32)}
     */
    static NOTIFYICON_VERSION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NOTIFYICON_VERSION_4 => 4

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_PIDL => 1

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_PREFIXNAME => 2

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_NOUNIQUE => 4

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_NOLNK => 8

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_NOLOCNAME => 16

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_USEURLEXT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_OPEN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_PROPERTIES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_NETINSTALL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_NETINSTALLLINK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_TESTPAGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_OPENNETPRN => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_DOCUMENTDEFAULTS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_SERVERPROPERTIES => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PRINT_PROP_FORCE_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_STATUS_LOCAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_STATUS_REMOTE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_STATUS_INCOMPLETE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_LARGE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_SMALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_EXTRALARGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_SYSSMALL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_JUMBO => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_LAST => 4

    /**
     * @type {String}
     */
    static WC_NETADDRESS => "msctls_netaddress"

    /**
     * @type {Integer (UInt32)}
     */
    static NCM_GETADDRESS => 1025

    /**
     * @type {Integer (UInt32)}
     */
    static NCM_SETALLOWTYPE => 1026

    /**
     * @type {Integer (UInt32)}
     */
    static NCM_GETALLOWTYPE => 1027

    /**
     * @type {Integer (UInt32)}
     */
    static NCM_DISPLAYERRORTIP => 1028

    /**
     * @type {Integer (UInt32)}
     */
    static CREDENTIAL_PROVIDER_NO_DEFAULT => 4294967295

    /**
     * @type {String}
     */
    static Identity_LocalUserProvider => "{a198529b-730f-4089-b646-a12557f5665e}"

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGR_ID => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGR_PROGRESSTEXT => 260

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGR_NAME => 128

    /**
     * @type {Integer (Int32)}
     */
    static STIF_DEFAULT => 0

    /**
     * @type {Integer (Int32)}
     */
    static STIF_SUPPORT_HEX => 1

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_HTMLA => "text/html"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_HTMLW => "text/html"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_CDFA => "application/x-cdf"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_CDFW => "application/x-cdf"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_HTML => "text/html"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_CDF => "application/x-cdf"

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_INVALID => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_LFNCHAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_SHORTCHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_WILD => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_SEPARATOR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PMSF_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PMSF_MULTIPLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PMSF_DONT_STRIP_SPACES => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_UNSAFE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static URL_PLUGGABLE_PROTOCOL => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static URL_WININET_COMPATIBILITY => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static URL_DONT_ESCAPE_EXTRA_INFO => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static URL_DONT_UNESCAPE_EXTRA_INFO => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static URL_BROWSER_MODE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_SPACES_ONLY => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static URL_DONT_SIMPLIFY => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static URL_NO_META => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE_INPLACE => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static URL_CONVERT_IF_DOSPATH => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE_HIGH_ANSI_ONLY => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static URL_INTERNAL_PATH => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static URL_FILE_USE_PATHURL => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static URL_DONT_UNESCAPE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_AS_UTF8 => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE_AS_UTF8 => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_ASCII_URI_COMPONENT => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE_URI_COMPONENT => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_PERCENT => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_SEGMENT_ONLY => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static URL_PARTFLAG_KEEPSCHEME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static URL_APPLY_DEFAULT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static URL_APPLY_GUESSSCHEME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static URL_APPLY_GUESSFILE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static URL_APPLY_FORCEAPPLY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_NONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_SZ => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_EXPAND_SZ => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_BINARY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_DWORD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_MULTI_SZ => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_QWORD => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_ANY => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RM_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RM_NORMAL => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RM_SAFE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RM_SAFENETWORK => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_NOEXPAND => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_ZEROONFAILURE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_NOVIRT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static SHREGSET_HKCU => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHREGSET_FORCE_HKCU => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHREGSET_HKLM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHREGSET_FORCE_HKLM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_SHELL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_DEBUGOUT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_TEST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_BROWSER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_FLUSH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_EVENT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_MSVM => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_FORMATTEXT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_PROFILE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_DEBUGBREAK => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_MSGTRACE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_PERFTAGS => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_MEMWATCH => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_DBMON => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_MULTISTOP => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_EVENTTRACE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_PERUSER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_ALLUSERS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_PERFOLDER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_ALLFOLDERS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_INHERIT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_ROAM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_NOAUTODEFAULTS => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_SHORTTIME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_SHORTDATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_LONGDATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_LONGTIME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_RELATIVE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_LTRDATE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_RTLDATE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_NOAUTOREADINGORDER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static PLATFORM_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PLATFORM_IE3 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PLATFORM_BROWSERONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PLATFORM_INTEGRATED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ILMM_IE4 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DLLVER_PLATFORM_WINDOWS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DLLVER_PLATFORM_NT => 2

    /**
     * @type {Integer (UInt64)}
     */
    static DLLVER_MAJOR_MASK => 18446462598732840960

    /**
     * @type {Integer (UInt64)}
     */
    static DLLVER_MINOR_MASK => 281470681743360

    /**
     * @type {Integer (UInt64)}
     */
    static DLLVER_BUILD_MASK => 4294901760

    /**
     * @type {Integer (UInt64)}
     */
    static DLLVER_QFE_MASK => 65535

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_FAILEDEXTRACTION => -2147175936

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_EXTRACTIONTIMEDOUT => -2147175935

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_SURROGATEUNAVAILABLE => -2147175934

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_FASTEXTRACTIONNOTSUPPORTED => -2147175933

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_DATAFILEUNAVAILABLE => -2147175932

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_EXTRACTIONPENDING => -2147175931

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_EXTRACTIONBLOCKED => -2147175930

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_NOSTORAGEPROVIDERTHUMBNAILHANDLER => -2147175929

    /**
     * @type {String}
     */
    static SHIMGKEY_QUALITY => "Compression"

    /**
     * @type {String}
     */
    static SHIMGKEY_RAWFORMAT => "RawDataFormat"

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMGDEC_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMGDEC_THUMBNAIL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMGDEC_LOADFULL => 2

    /**
     * @type {Integer (Int32)}
     */
    static E_NOTVALIDFORANIMATEDIMAGE => -2147221503

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_MISSINGITEMS => 262657

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_RETRYSYNC => 262658

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_CANCELITEM => 262659

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_CANCELALL => 262660

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_ITEMDELETED => 262672

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_ENUMITEMS => 262673

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRPROGRESSITEM_STATUSTEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRPROGRESSITEM_STATUSTYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRPROGRESSITEM_PROGVALUE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRPROGRESSITEM_MAXVALUE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRLOGERROR_ERRORFLAGS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRLOGERROR_ERRORID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRLOGERROR_ITEMID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRITEM_ITEMFLAGMASK => 127

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGRITEMNAME => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRHANDLERFLAG_MASK => 15

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGRHANDLERNAME => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRREGISTERFLAGS_MASK => 7

    /**
     * @type {Integer (Int32)}
     */
    static TLOG_BACK => -1

    /**
     * @type {Integer (UInt32)}
     */
    static TLOG_CURRENT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TLOG_FORE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TLMENUF_INCLUDECURRENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TLMENUF_BACK => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TLMENUF_FORE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_REGISTERASDROPTARGET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_THEATERMODE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_NOLOCALFILEWARNING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_UISETBYAUTOMATION => 256

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_RESIZABLE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_CANMAXIMIZE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_TOPBROWSER => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_NAVNOHISTORY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_HTMLNAVCANCELED => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_DONTSHOWNAVCANCELPAGE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_SETNAVIGATABLECODEPAGE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_DELEGATEDNAVIGATION => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_TRUSTEDFORACTIVEX => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_MERGEDMENUS => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_FEEDNAVIGATION => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_FEEDSUBSCRIBED => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_CALLERUNTRUSTED => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_TRUSTEDFORACTIVEX => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_DISABLEWINDOWRESTRICTIONS => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_TRUSTFIRSTDOWNLOAD => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_UNTRUSTEDFORDOWNLOAD => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static SHHLNF_NOAUTOSELECT => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SHHLNF_WRITENOHISTORY => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_EXTERNALNAVIGATE => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_ALLOW_AUTONAVIGATE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_NEWWINDOWSMANAGED => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static INTERNET_MAX_PATH_LENGTH => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static INTERNET_MAX_SCHEME_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_RESTRICTED => 112

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_CACHEHIT => 80

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_STALECACHEHIT => 69

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_USEASDEFAULT => 67

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_SHELLEXT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_CACHEMISS => 48

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_INHERIT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_SHELLEXT_ASBACKUP => 21

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_DESPERATE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_NONE => 0

    /**
     * @type {String}
     */
    static VOLUME_PREFIX => "\\?\Volume"

    /**
     * @type {Integer (UInt32)}
     */
    static PATHCCH_MAX_CCH => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static IDS_DESCRIPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ID_APP => 100

    /**
     * @type {Integer (UInt32)}
     */
    static DLG_SCRNSAVECONFIGURE => 2003

    /**
     * @type {Integer (UInt32)}
     */
    static idsIsPassword => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static idsIniFile => 1001

    /**
     * @type {Integer (UInt32)}
     */
    static idsScreenSaver => 1002

    /**
     * @type {Integer (UInt32)}
     */
    static idsPassword => 1003

    /**
     * @type {Integer (UInt32)}
     */
    static idsDifferentPW => 1004

    /**
     * @type {Integer (UInt32)}
     */
    static idsChangePW => 1005

    /**
     * @type {Integer (UInt32)}
     */
    static idsBadOldPW => 1006

    /**
     * @type {Integer (UInt32)}
     */
    static idsAppName => 1007

    /**
     * @type {Integer (UInt32)}
     */
    static idsNoHelpMemory => 1008

    /**
     * @type {Integer (UInt32)}
     */
    static idsHelpFile => 1009

    /**
     * @type {Integer (UInt32)}
     */
    static idsDefKeyword => 1010

    /**
     * @type {Integer (UInt32)}
     */
    static MAXFILELEN => 13

    /**
     * @type {Integer (UInt32)}
     */
    static TITLEBARNAMELEN => 40

    /**
     * @type {Integer (UInt32)}
     */
    static APPNAMEBUFFERLEN => 40

    /**
     * @type {Integer (UInt32)}
     */
    static BUFFLEN => 255

    /**
     * @type {Integer (UInt32)}
     */
    static SCRM_VERIFYPW => 32768

    /**
     * @type {Integer (Int32)}
     */
    static E_FLAGS => -2147217408

    /**
     * @type {Integer (Int32)}
     */
    static IS_E_EXEC_FAILED => -2147213310

    /**
     * @type {Integer (Int32)}
     */
    static URL_E_INVALID_SYNTAX => -2147217407

    /**
     * @type {Integer (Int32)}
     */
    static URL_E_UNREGISTERED_PROTOCOL => -2147217406

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_MOUSE_BUTTONS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_MOUSE_PTRMOTION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_MOUSE_WHEEL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_KEYBOARD_SPEED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_DISPLAY_BACKGROUND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SELECTIONCHANGED => 200

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_FILELISTENUMDONE => 201

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_VERBINVOKED => 202

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_DEFAULTVERBINVOKED => 203

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_BEGINDRAG => 204

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_VIEWMODECHANGED => 205

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_NOITEMSTATE_CHANGED => 206

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_CONTENTSCHANGED => 207

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_FOCUSCHANGED => 208

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_CHECKSTATECHANGED => 209

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_ORDERCHANGED => 210

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_VIEWPAINTDONE => 211

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_COLUMNSCHANGED => 212

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_CTRLMOUSEWHEEL => 213

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SORTDONE => 214

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_ICONSIZECHANGED => 215

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_FOLDERCHANGED => 217

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_FILTERINVOKED => 218

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_WORDWHEELEDITED => 219

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SELECTEDITEMCHANGED => 220

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_EXPLORERWINDOWREADY => 221

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_UPDATEIMAGE => 222

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_INITIALENUMERATIONDONE => 223

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_ENTERPRISEIDCHANGED => 224

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_ENTERPRESSED => 200

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_START => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_COMPLETE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_ABORT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_UPDATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_PROGRESSTEXT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_ERROR => 6

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_RESTORE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_DIRTY => 256

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_PUBCAT => 257

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_SORT => 258

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_FORCEX86 => 259

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_SHOWPOSTSETUP => 260

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_ONDOMAIN => 261

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_DEFAULTCAT => 262

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_YES => 2555905

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_NOT_HANDLED => 2555907

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_USER_RETRY => 2555908

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_USER_IGNORED => 2555909

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_MERGE => 2555910

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_DONT_PROCESS_CHILDREN => 2555912

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_ALREADY_DONE => 2555914

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_PENDING => 2555915

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_KEEP_BOTH => 2555916

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_CLOSE_PROGRAM => 2555917

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_COLLISIONRESOLVED => 2555918

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_PROGRESS_PAUSE => 2555919

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_PENDING_DELETE => 2555920

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_PENDING_BATCH_COPY => 2555921

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_USER_CANCELLED => -2144927744

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_CANCELLED => -2144927743

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REQUIRES_ELEVATION => -2144927742

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SAME_FILE => -2144927741

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DIFF_DIR => -2144927740

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_MANY_SRC_1_DEST => -2144927739

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_SUBTREE => -2144927735

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_SAME_TREE => -2144927734

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_FLD_IS_FILE_DEST => -2144927733

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_FILE_IS_FLD_DEST => -2144927732

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_FILE_TOO_LARGE => -2144927731

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REMOVABLE_FULL => -2144927730

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_RO_CD => -2144927729

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_RW_CD => -2144927728

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_R_CD => -2144927727

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_RO_DVD => -2144927726

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_RW_DVD => -2144927725

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_R_DVD => -2144927724

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_RO_CD => -2144927723

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_RW_CD => -2144927722

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_R_CD => -2144927721

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_RO_DVD => -2144927720

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_RW_DVD => -2144927719

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_R_DVD => -2144927718

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INVALID_FILES_SRC => -2144927717

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INVALID_FILES_DEST => -2144927716

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PATH_TOO_DEEP_SRC => -2144927715

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PATH_TOO_DEEP_DEST => -2144927714

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ROOT_DIR_SRC => -2144927713

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ROOT_DIR_DEST => -2144927712

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ACCESS_DENIED_SRC => -2144927711

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ACCESS_DENIED_DEST => -2144927710

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PATH_NOT_FOUND_SRC => -2144927709

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PATH_NOT_FOUND_DEST => -2144927708

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_NET_DISCONNECT_SRC => -2144927707

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_NET_DISCONNECT_DEST => -2144927706

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SHARING_VIOLATION_SRC => -2144927705

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SHARING_VIOLATION_DEST => -2144927704

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ALREADY_EXISTS_NORMAL => -2144927703

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ALREADY_EXISTS_READONLY => -2144927702

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ALREADY_EXISTS_SYSTEM => -2144927701

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ALREADY_EXISTS_FOLDER => -2144927700

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_STREAM_LOSS => -2144927699

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_EA_LOSS => -2144927698

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PROPERTY_LOSS => -2144927697

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PROPERTIES_LOSS => -2144927696

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ENCRYPTION_LOSS => -2144927695

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DISK_FULL => -2144927694

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DISK_FULL_CLEAN => -2144927693

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_EA_NOT_SUPPORTED => -2144927692

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_CANT_REACH_SOURCE => -2144927691

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_UNKNOWN_ERROR => -2144927691

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_FORCE_NUKE => -2144927690

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_SIZE_TOO_BIG => -2144927689

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_PATH_TOO_LONG => -2144927688

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_BIN_NOT_FOUND => -2144927686

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_NEWFILE_NAME_TOO_LONG => -2144927685

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_NEWFOLDER_NAME_TOO_LONG => -2144927684

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DIR_NOT_EMPTY => -2144927683

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_FAT_MAX_IN_ROOT => -2144927682

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ACCESSDENIED_READONLY => -2144927681

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REDIRECTED_TO_WEBPAGE => -2144927680

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SERVER_BAD_FILE_TYPE => -2144927679

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INTERNET_ITEM_UNAVAILABLE => -2144927678

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_CANNOT_MOVE_FROM_RECYCLE_BIN => -2144927677

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_CANNOT_MOVE_SHARED_FOLDER => -2144927676

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_ERROR => -2144927675

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_PAUSED => -2144927674

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REQUIRES_EDP_CONSENT => -2144927673

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_BLOCKED_BY_EDP_POLICY => -2144927672

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE => -2144927671

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE => -2144927670

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RMS_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE => -2144927669

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RMS_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE => -2144927668

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_WARNED_BY_DLP_POLICY => -2144927667

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_BLOCKED_BY_DLP_POLICY => -2144927666

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SILENT_FAIL_BY_DLP_POLICY => -2144927665

    /**
     * @type {Integer (Int32)}
     */
    static NETCACHE_E_NEGATIVE_CACHE => -2144927488

    /**
     * @type {Integer (Int32)}
     */
    static EXECUTE_E_LAUNCH_APPLICATION => -2144927487

    /**
     * @type {Integer (Int32)}
     */
    static SHELL_E_WRONG_BITDEPTH => -2144927486

    /**
     * @type {Integer (Int32)}
     */
    static LINK_E_DELETE => -2144927485

    /**
     * @type {Integer (Int32)}
     */
    static STORE_E_NEWER_VERSION_AVAILABLE => -2144927484

    /**
     * @type {Integer (Int32)}
     */
    static E_FILE_PLACEHOLDER_NOT_INITIALIZED => -2144927472

    /**
     * @type {Integer (Int32)}
     */
    static E_FILE_PLACEHOLDER_VERSION_MISMATCH => -2144927471

    /**
     * @type {Integer (Int32)}
     */
    static E_FILE_PLACEHOLDER_SERVER_TIMED_OUT => -2144927470

    /**
     * @type {Integer (Int32)}
     */
    static E_FILE_PLACEHOLDER_STORAGEPROVIDER_NOT_FOUND => -2144927469

    /**
     * @type {Integer (Int32)}
     */
    static CAMERAROLL_E_NO_DOWNSAMPLING_REQUIRED => -2144927456

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_USERCLOSE => -2144927440

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_SHELLERROR => -2144927439

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_SHELLRESTART => -2144927438

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_UNEXPECTED => -2144927437

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_SHELLNOTREADY => -2144927436

    /**
     * @type {Integer (Int32)}
     */
    static LIBRARY_E_NO_SAVE_LOCATION => -2144927232

    /**
     * @type {Integer (Int32)}
     */
    static LIBRARY_E_NO_ACCESSIBLE_LOCATION => -2144927231

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_UNSUPPORTEDFILETYPE => -2144927216

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_CHANGEDISABLED => -2144927215

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_LARGEORDYNAMIC => -2144927214

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_VIDEOFRAMESIZE => -2144927213

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_FILESIZE => -2144927212

    /**
     * @type {Integer (Int32)}
     */
    static IMM_ACC_DOCKING_E_INSUFFICIENTHEIGHT => -2144927184

    /**
     * @type {Integer (Int32)}
     */
    static IMM_ACC_DOCKING_E_DOCKOCCUPIED => -2144927183

    /**
     * @type {Integer (Int32)}
     */
    static IMSC_E_SHELL_COMPONENT_STARTUP_FAILURE => -2144927181

    /**
     * @type {Integer (Int32)}
     */
    static SHC_E_SHELL_COMPONENT_STARTUP_FAILURE => -2144927180

    /**
     * @type {Integer (Int32)}
     */
    static E_TILE_NOTIFICATIONS_PLATFORM_FAILURE => -2144927159

    /**
     * @type {Integer (Int32)}
     */
    static E_SHELL_EXTENSION_BLOCKED => -2144926975

    /**
     * @type {Integer (Int32)}
     */
    static E_IMAGEFEED_CHANGEDISABLED => -2144926960

    /**
     * @type {String}
     */
    static CLSID_CUrlHistory => "{3c374a40-bae4-11cf-bf7d-00aa006946ee}"

    /**
     * @type {String}
     */
    static CLSID_CUrlHistoryBoth => "{6659983c-8476-4eb4-b78c-e5968f326ba0}"

    /**
     * @type {Integer (Int32)}
     */
    static ISHCUTCMDID_DOWNLOADICON => 0

    /**
     * @type {Integer (Int32)}
     */
    static ISHCUTCMDID_INTSHORTCUTCREATE => 1

    /**
     * @type {Integer (Int32)}
     */
    static ISHCUTCMDID_COMMITHISTORY => 2

    /**
     * @type {Integer (Int32)}
     */
    static ISHCUTCMDID_SETUSERAWURL => 3

    /**
     * @type {Integer (Int32)}
     */
    static SFBID_PIDLCHANGED => 0

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_EMPTY => 0

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_ONDRAG => 1

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_CLSIDOFBAR => 2

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_RESIZE => 3

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_GETBAR => 4

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_UPDATESIZE => 5

    /**
     * @type {Integer (Int32)}
     */
    static BMICON_LARGE => 0

    /**
     * @type {Integer (Int32)}
     */
    static BMICON_SMALL => 1

    /**
     * @type {Integer (Int32)}
     */
    static CTF_INSIST => 1

    /**
     * @type {Integer (Int32)}
     */
    static CTF_THREAD_REF => 2

    /**
     * @type {Integer (Int32)}
     */
    static CTF_PROCESS_REF => 4

    /**
     * @type {Integer (Int32)}
     */
    static CTF_COINIT_STA => 8

    /**
     * @type {Integer (Int32)}
     */
    static CTF_COINIT => 8

    /**
     * @type {Integer (Int32)}
     */
    static CTF_FREELIBANDEXIT => 16

    /**
     * @type {Integer (Int32)}
     */
    static CTF_REF_COUNTED => 32

    /**
     * @type {Integer (Int32)}
     */
    static CTF_WAIT_ALLOWCOM => 64

    /**
     * @type {Integer (Int32)}
     */
    static CTF_UNUSED => 128

    /**
     * @type {Integer (Int32)}
     */
    static CTF_INHERITWOW64 => 256

    /**
     * @type {Integer (Int32)}
     */
    static CTF_WAIT_NO_REENTRANCY => 512

    /**
     * @type {Integer (Int32)}
     */
    static CTF_KEYBOARD_LOCALE => 1024

    /**
     * @type {Integer (Int32)}
     */
    static CTF_OLEINITIALIZE => 2048

    /**
     * @type {Integer (Int32)}
     */
    static CTF_COINIT_MTA => 4096

    /**
     * @type {Integer (Int32)}
     */
    static CTF_NOADDREFLIB => 8192
;@endregion Constants

;@region Methods
    /**
     * Initializes or reinitializes the system image list.
     * @remarks
     * If you are using system image lists in your own process, you must call **FileIconInit** at the following times:
     * 
     * -   On launch.
     * -   In response to a [**WM\_SETTINGCHANGE**](../winmsg/wm-settingchange.md) message when the [**SPI\_SETNONCLIENTMETRICS**](/windows/win32/api/winuser/nf-winuser-systemparametersinfoa) flag is set.
     * 
     * **FileIconInit** is not included in a header file. You must call it directly from Shell32.dll, using ordinal 660.
     * @param {Integer} fRestoreCache Type: **BOOL**
     * @returns {Integer} Type: **BOOL**
     * 
     * **TRUE** if the cache was successfully refreshed, **FALSE** if the initialization failed.
     * @see https://learn.microsoft.com/windows/win32/shell/fileiconinit
     */
    static FileIconInit(fRestoreCache) {
        result := DllCall("SHELL32.dll\FileIconInit", "int", fRestoreCache, "int")
        return result
    }

    /**
     * Loads the specified user's profile. The profile can be a local user profile or a roaming user profile. (ANSI)
     * @remarks
     * When a user logs on interactively, the system automatically loads the user's profile. If a service or an application impersonates a user, the system does not load the user's profile. Therefore, the service or application should load the user's profile with <b>LoadUserProfile</b>.
     * 
     * Services and applications that call <b>LoadUserProfile</b> should check to see if the user has a roaming profile. If the user has a roaming profile, specify its path as the <b>lpProfilePath</b> member of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a>. To retrieve the user's roaming profile path, you can call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmaccess/nf-lmaccess-netusergetinfo">NetUserGetInfo</a> function, specifying information level 3 or 4.
     * 
     * Upon successful return, the <b>hProfile</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a> is a registry key handle opened to the root of the user's hive. It has been opened with full access (KEY_ALL_ACCESS). If a service that is impersonating a user needs to read or write to the user's registry file, use this handle instead of <b>HKEY_CURRENT_USER</b>. Do not close the <b>hProfile</b> handle. Instead, pass it to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/userenv/nf-userenv-unloaduserprofile">UnloadUserProfile</a> function. This function closes the handle. You should ensure that all handles to keys in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-hives">Registry Hives</a>.
     * 
     * Note that it is your responsibility to load the user's registry hive into the <b>HKEY_USERS</b> registry key with the <b>LoadUserProfile</b> function before you call <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera">CreateProcessAsUser</a>. This is because <b>CreateProcessAsUser</b> does not load the specified user's profile into <b>HKEY_USERS</b>. This means that access to information in the <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon.
     * 
     * The calling process must have the <b>SE_RESTORE_NAME</b> and <b>SE_BACKUP_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.
     * 
     * Starting with WindowsXP Service Pack2 (SP2) and Windows Server2003, the caller must be an administrator or the LocalSystem account. It is not sufficient for the caller to merely impersonate the administrator or LocalSystem account.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines LoadUserProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * Token for the user, which is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {Pointer<PROFILEINFOA>} lpProfileInfo Type: <b>LPPROFILEINFO</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <c>sizeof(PROFILEINFO)</c> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     *                 
     *                     
     * 
     * The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <c>sizeof(PROFILEINFO)</c> or if the <b>lpUserName</b> member is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-loaduserprofilea
     * @since windows5.0
     */
    static LoadUserProfileA(hToken, lpProfileInfo) {
        A_LastError := 0

        result := DllCall("USERENV.dll\LoadUserProfileA", "ptr", hToken, "ptr", lpProfileInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified user's profile. The profile can be a local user profile or a roaming user profile. (Unicode)
     * @remarks
     * When a user logs on interactively, the system automatically loads the user's profile. If a service or an application impersonates a user, the system does not load the user's profile. Therefore, the service or application should load the user's profile with <b>LoadUserProfile</b>.
     * 
     * Services and applications that call <b>LoadUserProfile</b> should check to see if the user has a roaming profile. If the user has a roaming profile, specify its path as the <b>lpProfilePath</b> member of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a>. To retrieve the user's roaming profile path, you can call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmaccess/nf-lmaccess-netusergetinfo">NetUserGetInfo</a> function, specifying information level 3 or 4.
     * 
     * Upon successful return, the <b>hProfile</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a> is a registry key handle opened to the root of the user's hive. It has been opened with full access (KEY_ALL_ACCESS). If a service that is impersonating a user needs to read or write to the user's registry file, use this handle instead of <b>HKEY_CURRENT_USER</b>. Do not close the <b>hProfile</b> handle. Instead, pass it to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/userenv/nf-userenv-unloaduserprofile">UnloadUserProfile</a> function. This function closes the handle. You should ensure that all handles to keys in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-hives">Registry Hives</a>.
     * 
     * Note that it is your responsibility to load the user's registry hive into the <b>HKEY_USERS</b> registry key with the <b>LoadUserProfile</b> function before you call <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera">CreateProcessAsUser</a>. This is because <b>CreateProcessAsUser</b> does not load the specified user's profile into <b>HKEY_USERS</b>. This means that access to information in the <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon.
     * 
     * The calling process must have the <b>SE_RESTORE_NAME</b> and <b>SE_BACKUP_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.
     * 
     * Starting with WindowsXP Service Pack2 (SP2) and Windows Server2003, the caller must be an administrator or the LocalSystem account. It is not sufficient for the caller to merely impersonate the administrator or LocalSystem account.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines LoadUserProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * Token for the user, which is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {Pointer<PROFILEINFOW>} lpProfileInfo Type: <b>LPPROFILEINFO</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <c>sizeof(PROFILEINFO)</c> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     *                 
     *                     
     * 
     * The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <c>sizeof(PROFILEINFO)</c> or if the <b>lpUserName</b> member is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-loaduserprofilew
     * @since windows5.0
     */
    static LoadUserProfileW(hToken, lpProfileInfo) {
        A_LastError := 0

        result := DllCall("USERENV.dll\LoadUserProfileW", "ptr", hToken, "ptr", lpProfileInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Unloads a user's profile that was loaded by the LoadUserProfile function. The caller must have administrative privileges on the computer. For more information, see the Remarks section of the LoadUserProfile function.
     * @remarks
     * Before calling <b>UnloadUserProfile</b> you should ensure that all handles to keys that you have opened in the user's registry hive are closed. If you do not close all open registry handles, the user's profile fails to unload. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a> and <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-hives">Registry Hives</a>.
     * 
     * For more information about calling functions that require administrator privileges, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * Token for the user, returned from the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {Pointer<Void>} hProfile Type: <b>HANDLE</b>
     * 
     * Handle to the registry key. This value is the <b>hProfile</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a> structure. For more information see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/userenv/nf-userenv-loaduserprofilea">LoadUserProfile</a> and <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-unloaduserprofile
     * @since windows5.0
     */
    static UnloadUserProfile(hToken, hProfile) {
        A_LastError := 0

        result := DllCall("USERENV.dll\UnloadUserProfile", "ptr", hToken, "ptr", hProfile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to the root directory where user profiles are stored. (ANSI)
     * @remarks
     * The following is an example of the path returned by <b>GetProfilesDirectory</b> in WindowsXP:
     * 
     * 
     * ``` syntax
     * C:\Documents and Settings
     * ```
     * 
     * The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows7:
     * 
     * 
     * ``` syntax
     * C:\Users
     * ```
     * 
     * To obtain the paths of subdirectories of this directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a> (WindowsXP and earlier) or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a> (WindowsVista) function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines GetProfilesDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
     * @param {Pointer<UInt32>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getprofilesdirectorya
     * @since windows5.0
     */
    static GetProfilesDirectoryA(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String? StrPtr(lpProfileDir) : lpProfileDir

        A_LastError := 0

        result := DllCall("USERENV.dll\GetProfilesDirectoryA", "ptr", lpProfileDir, "uint*", lpcchSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to the root directory where user profiles are stored. (Unicode)
     * @remarks
     * The following is an example of the path returned by <b>GetProfilesDirectory</b> in WindowsXP:
     * 
     * 
     * ``` syntax
     * C:\Documents and Settings
     * ```
     * 
     * The following is an example of the path returned by <b>GetProfilesDirectory</b> in Windows7:
     * 
     * 
     * ``` syntax
     * C:\Users
     * ```
     * 
     * To obtain the paths of subdirectories of this directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a> (WindowsXP and earlier) or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a> (WindowsVista) function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines GetProfilesDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
     * @param {Pointer<UInt32>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getprofilesdirectoryw
     * @since windows5.0
     */
    static GetProfilesDirectoryW(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String? StrPtr(lpProfileDir) : lpProfileDir

        A_LastError := 0

        result := DllCall("USERENV.dll\GetProfilesDirectoryW", "ptr", lpProfileDir, "uint*", lpcchSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the type of profile loaded for the current user.
     * @remarks
     * If the user profile is not already loaded, the function fails.
     * 
     * Note that the caller must have <b>KEY_READ</b> access to <b>HKEY_LOCAL_MACHINE</b>. This access right is granted by default. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     * If the profile type is <b>PT_ROAMING_PREEXISTING</b>, Explorer will not reinitialize default programs associations when a profile is loaded on a machine for the first time.
     * @param {Pointer<UInt32>} dwFlags Type: <b>DWORD*</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getprofiletype
     * @since windows5.0
     */
    static GetProfileType(dwFlags) {
        A_LastError := 0

        result := DllCall("USERENV.dll\GetProfileType", "uint*", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile. (ANSI)
     * @remarks
     * <b>DeleteProfile</b> might fail when passed the security identifier (SID) of the local system account (S-1-5-18). 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines DeleteProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpSidString Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the user 
     *     <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/security-identifiers">SID</a>.
     * @param {Pointer<Byte>} lpProfilePath Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.
     * @param {Pointer<Byte>} lpComputerName Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.
     *     
     *                         
     * 
     * <div class="alert"><b>Note</b>As of WindowsVista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</div>
     * <div></div>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-deleteprofilea
     * @since windows5.0
     */
    static DeleteProfileA(lpSidString, lpProfilePath, lpComputerName) {
        lpSidString := lpSidString is String? StrPtr(lpSidString) : lpSidString
        lpProfilePath := lpProfilePath is String? StrPtr(lpProfilePath) : lpProfilePath
        lpComputerName := lpComputerName is String? StrPtr(lpComputerName) : lpComputerName

        A_LastError := 0

        result := DllCall("USERENV.dll\DeleteProfileA", "ptr", lpSidString, "ptr", lpProfilePath, "ptr", lpComputerName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile. (Unicode)
     * @remarks
     * <b>DeleteProfile</b> might fail when passed the security identifier (SID) of the local system account (S-1-5-18). 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines DeleteProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpSidString Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the user 
     *     <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/security-identifiers">SID</a>.
     * @param {Pointer<Char>} lpProfilePath Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.
     * @param {Pointer<Char>} lpComputerName Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.
     *     
     *                         
     * 
     * <div class="alert"><b>Note</b>As of WindowsVista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</div>
     * <div></div>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-deleteprofilew
     * @since windows5.0
     */
    static DeleteProfileW(lpSidString, lpProfilePath, lpComputerName) {
        lpSidString := lpSidString is String? StrPtr(lpSidString) : lpSidString
        lpProfilePath := lpProfilePath is String? StrPtr(lpProfilePath) : lpProfilePath
        lpComputerName := lpComputerName is String? StrPtr(lpComputerName) : lpComputerName

        A_LastError := 0

        result := DllCall("USERENV.dll\DeleteProfileW", "ptr", lpSidString, "ptr", lpProfilePath, "ptr", lpComputerName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new user profile.
     * @remarks
     * The caller must have administrator privileges to call this function.
     * @param {Pointer<Char>} pszUserSid Type: <b>LPCWSTR</b>
     * 
     * Pointer to the SID of the user as a string.
     * @param {Pointer<Char>} pszUserName Type: <b>LPCWSTR</b>
     * 
     * The user name of the new user. This name is used as the base name for the profile directory.
     * @param {Pointer<Char>} pszProfilePath Type: <b>LPWSTR</b>
     * 
     * When this function returns, contains a pointer to the full path of the profile.
     * @param {Integer} cchProfilePath Type: <b>DWORD</b>
     * 
     * Size of the buffer pointed to by <i>pszProfilePath</i>, in characters.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have a sufficient permission level to create the profile.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A profile already exists for the specified user.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-createprofile
     * @since windows6.0.6000
     */
    static CreateProfile(pszUserSid, pszUserName, pszProfilePath, cchProfilePath) {
        pszUserSid := pszUserSid is String? StrPtr(pszUserSid) : pszUserSid
        pszUserName := pszUserName is String? StrPtr(pszUserName) : pszUserName
        pszProfilePath := pszProfilePath is String? StrPtr(pszProfilePath) : pszProfilePath

        result := DllCall("USERENV.dll\CreateProfile", "ptr", pszUserSid, "ptr", pszUserName, "ptr", pszProfilePath, "uint", cchProfilePath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the path to the root of the default user's profile. (ANSI)
     * @remarks
     * The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in WindowsXP:
     * 
     * 
     * ``` syntax
     * C:\Documents and Settings\Default User
     * ```
     * 
     * The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows7:
     * 
     * 
     * ``` syntax
     * C:\Users\Default
     * ```
     * 
     * To obtain the paths of subdirectories of this directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a> (WindowsXP and earlier) or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a> (WindowsVista) function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines GetDefaultUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
     * @param {Pointer<UInt32>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getdefaultuserprofiledirectorya
     * @since windows5.0
     */
    static GetDefaultUserProfileDirectoryA(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String? StrPtr(lpProfileDir) : lpProfileDir

        A_LastError := 0

        result := DllCall("USERENV.dll\GetDefaultUserProfileDirectoryA", "ptr", lpProfileDir, "uint*", lpcchSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to the root of the default user's profile. (Unicode)
     * @remarks
     * The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in WindowsXP:
     * 
     * 
     * ``` syntax
     * C:\Documents and Settings\Default User
     * ```
     * 
     * The following is an example of the path returned by <b>GetDefaultUserProfileDirectory</b> in Windows7:
     * 
     * 
     * ``` syntax
     * C:\Users\Default
     * ```
     * 
     * To obtain the paths of subdirectories of this directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a> (WindowsXP and earlier) or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a> (WindowsVista) function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines GetDefaultUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
     * @param {Pointer<UInt32>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getdefaultuserprofiledirectoryw
     * @since windows5.0
     */
    static GetDefaultUserProfileDirectoryW(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String? StrPtr(lpProfileDir) : lpProfileDir

        A_LastError := 0

        result := DllCall("USERENV.dll\GetDefaultUserProfileDirectoryW", "ptr", lpProfileDir, "uint*", lpcchSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to the root of the directory that contains program data shared by all users. (ANSI)
     * @remarks
     * The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in WindowsXP:
     * 
     * 
     * ``` syntax
     * C:\Documents and Settings\All Users
     * ```
     * 
     * The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows7:
     * 
     * 
     * ``` syntax
     * C:\ProgramData
     * ```
     * 
     * To obtain the paths of subdirectories of this directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a> (WindowsXP and earlier) or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a> (WindowsVista) function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines GetAllUsersProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.
     * @param {Pointer<UInt32>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getallusersprofiledirectorya
     * @since windows5.0
     */
    static GetAllUsersProfileDirectoryA(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String? StrPtr(lpProfileDir) : lpProfileDir

        A_LastError := 0

        result := DllCall("USERENV.dll\GetAllUsersProfileDirectoryA", "ptr", lpProfileDir, "uint*", lpcchSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to the root of the directory that contains program data shared by all users. (Unicode)
     * @remarks
     * The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in WindowsXP:
     * 
     * 
     * ``` syntax
     * C:\Documents and Settings\All Users
     * ```
     * 
     * The following is an example of the path returned by <b>GetAllUsersProfileDirectory</b> in Windows7:
     * 
     * 
     * ``` syntax
     * C:\ProgramData
     * ```
     * 
     * To obtain the paths of subdirectories of this directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a> (WindowsXP and earlier) or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a> (WindowsVista) function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines GetAllUsersProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.
     * @param {Pointer<UInt32>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getallusersprofiledirectoryw
     * @since windows5.0
     */
    static GetAllUsersProfileDirectoryW(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String? StrPtr(lpProfileDir) : lpProfileDir

        A_LastError := 0

        result := DllCall("USERENV.dll\GetAllUsersProfileDirectoryW", "ptr", lpProfileDir, "uint*", lpcchSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to the root directory of the specified user's profile. (ANSI)
     * @remarks
     * The following is an example of the path returned by <b>GetUserProfileDirectory</b> in WindowsXP:
     * 
     * 
     * ``` syntax
     * C:\Documents and Settings\Joe
     * ```
     * 
     * The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows7:
     * 
     * 
     * ``` syntax
     * C:\Users\Joe
     * ```
     * 
     * To obtain the paths of subdirectories of this directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a> (WindowsXP and earlier) or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a> (WindowsVista) function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines GetUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * A token for the user, which is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or  <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {Pointer<Byte>} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.
     * @param {Pointer<UInt32>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya
     * @since windows5.0
     */
    static GetUserProfileDirectoryA(hToken, lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String? StrPtr(lpProfileDir) : lpProfileDir

        A_LastError := 0

        result := DllCall("USERENV.dll\GetUserProfileDirectoryA", "ptr", hToken, "ptr", lpProfileDir, "uint*", lpcchSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path to the root directory of the specified user's profile. (Unicode)
     * @remarks
     * The following is an example of the path returned by <b>GetUserProfileDirectory</b> in WindowsXP:
     * 
     * 
     * ``` syntax
     * C:\Documents and Settings\Joe
     * ```
     * 
     * The following is an example of the path returned by <b>GetUserProfileDirectory</b> in Windows7:
     * 
     * 
     * ``` syntax
     * C:\Users\Joe
     * ```
     * 
     * To obtain the paths of subdirectories of this directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a> (WindowsXP and earlier) or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a> (WindowsVista) function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The userenv.h header defines GetUserProfileDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * A token for the user, which is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or  <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {Pointer<Char>} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.
     * @param {Pointer<UInt32>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/userenv/nf-userenv-getuserprofiledirectoryw
     * @since windows5.0
     */
    static GetUserProfileDirectoryW(hToken, lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String? StrPtr(lpProfileDir) : lpProfileDir

        A_LastError := 0

        result := DllCall("USERENV.dll\GetUserProfileDirectoryW", "ptr", hToken, "ptr", lpProfileDir, "uint*", lpcchSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Initializes a PROPVARIANT structure based on a string stored in a STRRET structure.
     * @remarks
     * Creates a VT_LPWSTR propvariant.
     * 
     * <div class="alert"><b>Note</b>This function frees the memory used for the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> contents.</div>
     * <div></div>
     * @param {Pointer<STRRET>} pstrret Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure that contains the string.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * PIDL of the item whose details are being retrieved.
     * @param {Pointer<PROPVARIANT>} ppropvar Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a>*</b>
     * 
     * When this function returns, contains the initialized <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structure.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/propvarutil/nf-propvarutil-initpropvariantfromstrret
     * @since windows5.1.2600
     */
    static InitPropVariantFromStrRet(pstrret, pidl, ppropvar) {
        result := DllCall("PROPSYS.dll\InitPropVariantFromStrRet", "ptr", pstrret, "ptr", pidl, "ptr", ppropvar, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Extracts a string from a PROPVARIANT structure and places it into a STRRET structure.
     * @remarks
     * This helper function is used in applications that wish to convert a string value in a <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structure into a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. For instance, an application implementing <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof">IShellFolder::GetDisplayNameOf</a> may find this function useful.
     * 
     * If the source <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> has type VT_LPWSTR or VT_BSTR, this function extracts the string and places it into the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. Otherwise, it attempts to convert the value in the <b>PROPVARIANT</b> structure into a string. If a conversion is not possible, <a href="https://docs.microsoft.com/windows/desktop/api/propvarutil/nf-propvarutil-propvarianttostring">PropVariantToString</a> will return a failure code. See <a href="https://docs.microsoft.com/windows/desktop/api/propvarutil/nf-propvarutil-propvariantchangetype">PropVariantChangeType</a> for a list of possible conversions. Of note, VT_EMPTY is successfully converted to "".
     * 
     * In addition to the conversions provided by <a href="https://docs.microsoft.com/windows/desktop/api/propvarutil/nf-propvarutil-propvariantchangetype">PropVariantChangeType</a>, the following special cases apply to <a href="https://docs.microsoft.com/windows/desktop/api/propvarutil/nf-propvarutil-propvarianttostring">PropVariantToString</a>. 
     *         
     * 
     * <ul>
     * <li>Vector-valued <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a>s are converted to strings by separating each element with using "; ". For example, <a href="https://docs.microsoft.com/windows/desktop/api/propvarutil/nf-propvarutil-propvarianttostring">PropVariantToString</a> converts a vector of 3 integers, {3, 1, 4}, to the string "3; 1; 4". The semicolon is independent of the current locale.</li>
     * <li>VT_BLOB, VT_STREAM, VT_STREAMED_OBJECT, and VT_UNKNOWN values are converted to strings using an unsupported encoding. It is not possible to decode strings created in this way and the format may change in the future.</li>
     * </ul>
     * If the extraction is successful, the function will initialize uType member of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure with STRRET_WSTR and set the pOleStr member of that structure to point to an allocated copy of the string. The calling application is responsible for using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-strrettostra">StrRetToStr</a> to free this string when it is no longer needed.
     * @param {Pointer<PROPVARIANT>} propvar Type: <b>REFPROPVARIANT</b>
     * 
     * Reference to a source <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structure.
     * @param {Pointer<STRRET>} pstrret Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * Points to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When this function returns, the structure has been initialized to contain a copy of the extracted string.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/propvarutil/nf-propvarutil-propvarianttostrret
     * @since windows5.1.2600
     */
    static PropVariantToStrRet(propvar, pstrret) {
        result := DllCall("PROPSYS.dll\PropVariantToStrRet", "ptr", propvar, "ptr", pstrret, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Initializes a VARIANT structure with a string stored in a STRRET structure.
     * @remarks
     * Creates a VT_BSTR variant.
     * 
     * <div class="alert"><b>Note</b>This function frees the resources used for the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> contents.</div>
     * <div></div>
     * @param {Pointer<STRRET>} pstrret Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * PIDL of the item whose details are being retrieved.
     * @param {Pointer<VARIANT>} pvar Type: <b>VARIANT*</b>
     * 
     * When this function returns, contains the initialized <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/ns-oaidl-variant">VARIANT</a> structure.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/propvarutil/nf-propvarutil-initvariantfromstrret
     * @since windows5.1.2600
     */
    static InitVariantFromStrRet(pstrret, pidl, pvar) {
        result := DllCall("PROPSYS.dll\InitVariantFromStrRet", "ptr", pstrret, "ptr", pidl, "ptr", pvar, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * If the source variant is a VT_BSTR, extracts string and places it into a STRRET structure.
     * @param {Pointer<VARIANT>} varIn Type: <b>REFVARIANT</b>
     * 
     * Reference to a source variant structure.
     * @param {Pointer<STRRET>} pstrret Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * Pointer to the extracted string if one exists.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/propvarutil/nf-propvarutil-varianttostrret
     * @since windows5.1.2600
     */
    static VariantToStrRet(varIn, pstrret) {
        result := DllCall("PROPSYS.dll\VariantToStrRet", "ptr", varIn, "ptr", pstrret, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Installs or updates a window subclass callback.
     * @remarks
     * Subclass callbacks are identified by the combination of the callback address and the caller-defined subclass ID. If the callback address and ID pair have not yet been installed, then this function installs the subclass. If the pair has already been installed, then this function just updates the reference data.
     * 
     * Each callback can store a single <b>DWORD_PTR</b> of reference data, which is passed to the callback function when it is called to filter messages. No reference counting is performed for the callback; it may repeatedly call <b>SetWindowSubclass</b> to alter the value of its reference data element.
     * 
     * <div class="alert"><b>Warning</b>You cannot use the subclassing helper functions to subclass a window across threads.</div>
     * <div></div>
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * The handle of the window being subclassed.
     * @param {Pointer<SUBCLASSPROC>} pfnSubclass Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a></b>
     * 
     * A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback. For the callback function prototype, see <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a>.
     * @param {Pointer} uIdSubclass Type: <b>UINT_PTR</b>
     * 
     * The subclass ID. This ID together with the subclass procedure uniquely identify a subclass. To remove a subclass, pass the subclass procedure and this value to the <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-removewindowsubclass">RemoveWindowSubclass</a> function. This value is passed to the subclass procedure in the uIdSubclass parameter.
     * @param {Pointer} dwRefData Type: <b>DWORD_PTR</b>
     * 
     * <b>DWORD_PTR</b> to reference data. The meaning of this value is determined by the calling application. This value is passed to the subclass procedure in the dwRefData parameter. A different dwRefData is associated with each combination of window handle, subclass procedure and uIdSubclass.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the subclass callback was successfully installed; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-setwindowsubclass
     * @since windows5.1.2600
     */
    static SetWindowSubclass(hWnd, pfnSubclass, uIdSubclass, dwRefData) {
        result := DllCall("COMCTL32.dll\SetWindowSubclass", "ptr", hWnd, "ptr", pfnSubclass, "ptr", uIdSubclass, "ptr", dwRefData, "int")
        return result
    }

    /**
     * Retrieves the reference data for the specified window subclass callback.
     * @remarks
     * To use <b>GetWindowSubclass</b>, specify Comctl32.dll version 6 in the manifest. For more information on manifests, see <a href="https://docs.microsoft.com/windows/desktop/Controls/cookbook-overview">Enabling Visual Styles</a>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * The handle of the window being subclassed.
     * @param {Pointer<SUBCLASSPROC>} pfnSubclass Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a></b>
     * 
     * A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback.
     * @param {Pointer} uIdSubclass Type: <b>UINT_PTR</b>
     * 
     * <b>UINT_PTR</b> subclass ID. This ID and the callback pointer uniquely identify this subclass callback. Note: On 64-bit versions of Windows this is a 64-bit value.
     * @param {Pointer<UIntPtr>} pdwRefData Type: <b>DWORD_PTR*</b>
     * 
     * A pointer to a <b>DWORD</b> which will return the reference data. Note: On 64-bit versions of Windows, pointers are 64-bit values.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>TRUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subclass callback was successfully installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subclass callback was not installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-getwindowsubclass
     * @since windows5.1.2600
     */
    static GetWindowSubclass(hWnd, pfnSubclass, uIdSubclass, pdwRefData) {
        result := DllCall("COMCTL32.dll\GetWindowSubclass", "ptr", hWnd, "ptr", pfnSubclass, "ptr", uIdSubclass, "ptr*", pdwRefData, "int")
        return result
    }

    /**
     * Removes a subclass callback from a window.
     * @remarks
     * Subclass callbacks are identified by their combination of the callback address and the subclass ID defined by the calling process.
     * 
     * The SUBCLASS module defines helper functions that are used to subclass windows. The code maintains a single property on the subclassed window and dispatches various subclass callbacks to its clients as required. The client is provided reference data and a default processing API.
     * 
     * No reference counting is performed for the callback; it may repeatedly call <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-setwindowsubclass">SetWindowSubclass</a> to alter the value of its reference data element.
     * 
     * <div class="alert"><b>Warning</b>You cannot use the subclassing helper functions to subclass a window across threads.</div>
     * <div></div>
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * The handle of the window being subclassed.
     * @param {Pointer<SUBCLASSPROC>} pfnSubclass Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a></b>
     * 
     * A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback. For the callback function prototype, see <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a>.
     * @param {Pointer} uIdSubclass Type: <b>UINT_PTR</b>
     * 
     * The <b>UINT_PTR</b> subclass ID. This ID and the callback pointer uniquely identify this subclass callback. Note: On 64-bit versions of Windows this is a 64-bit value.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the subclass callback was successfully removed; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-removewindowsubclass
     * @since windows5.1.2600
     */
    static RemoveWindowSubclass(hWnd, pfnSubclass, uIdSubclass) {
        result := DllCall("COMCTL32.dll\RemoveWindowSubclass", "ptr", hWnd, "ptr", pfnSubclass, "ptr", uIdSubclass, "int")
        return result
    }

    /**
     * Calls the next handler in a window's subclass chain. The last handler in the subclass chain calls the original window procedure for the window.
     * @remarks
     * You do not need to call the default window procedure; this function calls it automatically.
     * 
     * The SUBCLASS module defines helper functions that are used to subclass windows. The code maintains a single property on the subclassed window and dispatches various subclass callbacks to its clients as required. The client is provided reference data and a default processing API.
     * 
     * A subclass callback is identified by a unique pairing of a callback function pointer and an unsigned ID value. Each callback can also store a single <b>DWORD</b> of reference data, which is passed to the callback function when it is called to filter messages. No reference counting is performed for the callback; it may repeatedly call <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-setwindowsubclass">SetWindowSubclass</a> to alter the value of its reference data element.
     * 
     * <div class="alert"><b>Warning</b>You cannot use the subclassing helper functions to subclass a window across threads.</div>
     * <div></div>
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window being subclassed.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * A value of type unsigned <b>int</b> that specifies a window message.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Specifies additional message information. The contents of this parameter depend on the value of the window message.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Specifies additional message information. The contents of this parameter depend on the value of the window message. Note: On 64-bit versions of Windows LPARAM is a 64-bit value.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The returned value is specific to the message sent. This value should be ignored.
     * @see https://learn.microsoft.com/windows/win32/api/commctrl/nf-commctrl-defsubclassproc
     * @since windows5.1.2600
     */
    static DefSubclassProc(hWnd, uMsg, wParam, lParam) {
        result := DllCall("COMCTL32.dll\DefSubclassProc", "ptr", hWnd, "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Associates a Help context identifier with the specified window.
     * @remarks
     * If a child window does not have a Help context identifier, it inherits the identifier of its parent window. Likewise, if an owned window does not have a Help context identifier, it inherits the identifier of its owner window. This inheritance of Help context identifiers allows an application to set just one identifier for a dialog box and all of its controls.
     * @param {Pointer<Void>} param0 
     * @param {Integer} param1 
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * 
     * To retrieve extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowcontexthelpid
     * @since windows5.1.2600
     */
    static SetWindowContextHelpId(param0, param1) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowContextHelpId", "ptr", param0, "uint", param1, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the Help context identifier, if any, associated with the specified window.
     * @param {Pointer<Void>} param0 
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns the Help context identifier if the window has one, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowcontexthelpid
     * @since windows5.1.2600
     */
    static GetWindowContextHelpId(param0) {
        result := DllCall("USER32.dll\GetWindowContextHelpId", "ptr", param0, "uint")
        return result
    }

    /**
     * Associates a Help context identifier with a menu.
     * @remarks
     * All items in the menu share this identifier. Help context identifiers can't be attached to individual menu items.
     * @param {Pointer<Void>} param0 
     * @param {Integer} param1 
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * 
     * To retrieve extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setmenucontexthelpid
     * @since windows5.1.2600
     */
    static SetMenuContextHelpId(param0, param1) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetMenuContextHelpId", "ptr", param0, "uint", param1, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the Help context identifier associated with the specified menu.
     * @param {Pointer<Void>} param0 
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns the Help context identifier if the menu has one, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenucontexthelpid
     * @since windows5.1.2600
     */
    static GetMenuContextHelpId(param0) {
        result := DllCall("USER32.dll\GetMenuContextHelpId", "ptr", param0, "uint")
        return result
    }

    /**
     * Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application. (ANSI)
     * @remarks
     * Before closing the window that requested help, the application must call <b>WinHelp</b> with the <i>uCommand</i> parameter set to HELP_QUIT. Until all applications have done this, Windows Help will not terminate. Note that calling Windows Help with the HELP_QUIT command is not necessary if you used the HELP_CONTEXTPOPUP command to start Windows Help.
     * 
     * This function fails if called from any context but the current user.
     * 
     * The following table shows the possible values for the <i>uCommand</i> parameter and the corresponding formats of the <i>dwData</i> parameter.
     * 
     * <table class="clsStd">
     * <tr>
     * <th><i>uCommand</i></th>
     * <th>Action</th>
     * <th><i>dwData</i></th>
     * </tr>
     * <tr>
     * <td>HELP_COMMAND</td>
     * <td>Executes a Help macro or macro string.</td>
     * <td>Address of a string that specifies the name of the Help macro(s) to run. If the string specifies multiple macro names, the names must be separated by semicolons. You must use the short form of the macro name for some macros because Windows Help does not support the long name.</td>
     * </tr>
     * <tr>
     * <td>HELP_CONTENTS</td>
     * <td>Displays the topic specified by the Contents option in the [OPTIONS] section of the .hpj file. This command is for backward compatibility. New applications should provide a .cnt file and use the HELP_FINDER command.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_CONTEXT</td>
     * <td>Displays the topic identified by the specified context identifier defined in the [MAP] section of the .hpj file.</td>
     * <td>Contains the context identifier for the topic.</td>
     * </tr>
     * <tr>
     * <td>HELP_CONTEXTMENU</td>
     * <td>Displays the <b>Help</b> menu for the selected window, then displays the topic for the selected control in a pop-up window.</td>
     * <td>Address of an array of <b>DWORD</b> pairs. The first <b>DWORD</b> in each pair is the control identifier, and the second is the context identifier for the topic. The array must be terminated by a pair of zeros {0,0}. If you do not want to add Help to a particular control, set its context identifier to -1.</td>
     * </tr>
     * <tr>
     * <td>HELP_CONTEXTPOPUP</td>
     * <td>Displays the topic identified by the specified context identifier defined in the [MAP] section of the .hpj file in a pop-up window.</td>
     * <td>Contains the context identifier for a topic.</td>
     * </tr>
     * <tr>
     * <td>HELP_FINDER</td>
     * <td>Displays the Help Topics dialog box.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_FORCEFILE</td>
     * <td>Ensures that Windows Help is displaying the correct Help file. If the incorrect Help file is being displayed, Windows Help opens the correct one; otherwise, there is no action.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_HELPONHELP</td>
     * <td>Displays help on how to use Windows Help, if the Winhlp32.hlp file is available.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_INDEX</td>
     * <td>Displays the topic specified by the Contents option in the [OPTIONS] section of the .hpj file. This command is for backward compatibility. New applications should use the HELP_FINDER command.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_KEY</td>
     * <td>Displays the topic in the keyword table that matches the specified keyword, if there is an exact match. If there is more than one match, displays the Index with the topics listed in the <b>Topics Found</b> list box.</td>
     * <td>Address of a keyword string. Multiple keywords must be separated by semicolons.</td>
     * </tr>
     * <tr>
     * <td>HELP_MULTIKEY</td>
     * <td>Displays the topic specified by a keyword in an alternative keyword table.</td>
     * <td>Address of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-multikeyhelpa">MULTIKEYHELP</a> structure that specifies a table footnote character and a keyword.</td>
     * </tr>
     * <tr>
     * <td>HELP_PARTIALKEY</td>
     * <td>Displays the topic in the keyword table that matches the specified keyword, if there is an exact match. If there is more than one match, displays the <b>Topics Found</b> dialog box. To display the index without passing a keyword, use a pointer to an empty string.</td>
     * <td>Address of a keyword string. Multiple keywords must be separated by semicolons.</td>
     * </tr>
     * <tr>
     * <td>HELP_QUIT</td>
     * <td>Informs Windows Help that it is no longer needed. If no other applications have asked for help, Windows closes Windows Help.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_SETCONTENTS</td>
     * <td>Specifies the Contents topic. Windows Help displays this topic when the user clicks the <b>Contents</b> button if the Help file does not have an associated .cnt file.</td>
     * <td>Contains the context identifier for the Contents topic.</td>
     * </tr>
     * <tr>
     * <td>HELP_SETPOPUP_POS</td>
     * <td>Sets the position of the subsequent pop-up window.</td>
     * <td>Contains the position data. Use <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632660(v=vs.85)">MAKELONG</a> to concatenate the horizontal and vertical coordinates into a single value. The pop-up window is positioned as if the mouse cursor were at the specified point when the pop-up window was invoked.</td>
     * </tr>
     * <tr>
     * <td>HELP_SETWINPOS</td>
     * <td>Displays the Windows Help window, if it is minimized or in memory, and sets its size and position as specified.</td>
     * <td>Address of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-helpwininfoa">HELPWININFO</a> structure that specifies the size and position of either a primary or secondary Help window.</td>
     * </tr>
     * <tr>
     * <td>HELP_TCARD</td>
     * <td>Indicates that a command is for a training card instance of Windows Help. Combine this command with other commands using the bitwise OR operator.</td>
     * <td>Depends on the command with which this command is combined.</td>
     * </tr>
     * <tr>
     * <td>HELP_WM_HELP</td>
     * <td>Displays the topic for the control identified by the <i>hWndMain</i> parameter in a pop-up window.</td>
     * <td>Address of an array of <b>DWORD</b> pairs. The first <b>DWORD</b> in each pair is a control identifier, and the second is a context identifier for a topic. The array must be terminated by a pair of zeros {0,0}. If you do not want to add Help to a particular control, set its context identifier to -1.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines WinHelp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWndMain Type: <b>HWND</b>
     * 
     * A handle to the window requesting help. The <b>WinHelp</b> function uses this handle to keep track of which applications have requested help. If the <i>uCommand</i> parameter specifies <b>HELP_CONTEXTMENU</b> or <b>HELP_WM_HELP</b>, <i>hWndMain</i> identifies the control requesting help.
     * @param {Pointer<Byte>} lpszHelp Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string containing the path, if necessary, and the name of the Help file that <b>WinHelp</b> is to display.
     * 	
     *     				
     * 
     * The file name can be followed by an angle bracket (&gt;) and the name of a secondary window if the topic is to be displayed in a secondary window rather than in the primary window. You must define the name of the secondary window in the [WINDOWS] section of the Help project (.hpj) file.
     * @param {Integer} uCommand Type: <b>UINT</b>
     * 
     * The type of help requested. For a list of possible values and how they affect the value to place in the <i>dwData</i> parameter, see the Remarks section.
     * @param {Pointer} dwData Type: <b>ULONG_PTR</b>
     * 
     * Additional data. The value used depends on the value of the <i>uCommand</i> parameter. For a list of possible <i>dwData</i> values, see the Remarks section.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-winhelpa
     * @since windows5.1.2600
     */
    static WinHelpA(hWndMain, lpszHelp, uCommand, dwData) {
        lpszHelp := lpszHelp is String? StrPtr(lpszHelp) : lpszHelp

        A_LastError := 0

        result := DllCall("USER32.dll\WinHelpA", "ptr", hWndMain, "ptr", lpszHelp, "uint", uCommand, "ptr", dwData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application. (Unicode)
     * @remarks
     * Before closing the window that requested help, the application must call <b>WinHelp</b> with the <i>uCommand</i> parameter set to HELP_QUIT. Until all applications have done this, Windows Help will not terminate. Note that calling Windows Help with the HELP_QUIT command is not necessary if you used the HELP_CONTEXTPOPUP command to start Windows Help.
     * 
     * This function fails if called from any context but the current user.
     * 
     * The following table shows the possible values for the <i>uCommand</i> parameter and the corresponding formats of the <i>dwData</i> parameter.
     * 
     * <table class="clsStd">
     * <tr>
     * <th><i>uCommand</i></th>
     * <th>Action</th>
     * <th><i>dwData</i></th>
     * </tr>
     * <tr>
     * <td>HELP_COMMAND</td>
     * <td>Executes a Help macro or macro string.</td>
     * <td>Address of a string that specifies the name of the Help macro(s) to run. If the string specifies multiple macro names, the names must be separated by semicolons. You must use the short form of the macro name for some macros because Windows Help does not support the long name.</td>
     * </tr>
     * <tr>
     * <td>HELP_CONTENTS</td>
     * <td>Displays the topic specified by the Contents option in the [OPTIONS] section of the .hpj file. This command is for backward compatibility. New applications should provide a .cnt file and use the HELP_FINDER command.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_CONTEXT</td>
     * <td>Displays the topic identified by the specified context identifier defined in the [MAP] section of the .hpj file.</td>
     * <td>Contains the context identifier for the topic.</td>
     * </tr>
     * <tr>
     * <td>HELP_CONTEXTMENU</td>
     * <td>Displays the <b>Help</b> menu for the selected window, then displays the topic for the selected control in a pop-up window.</td>
     * <td>Address of an array of <b>DWORD</b> pairs. The first <b>DWORD</b> in each pair is the control identifier, and the second is the context identifier for the topic. The array must be terminated by a pair of zeros {0,0}. If you do not want to add Help to a particular control, set its context identifier to -1.</td>
     * </tr>
     * <tr>
     * <td>HELP_CONTEXTPOPUP</td>
     * <td>Displays the topic identified by the specified context identifier defined in the [MAP] section of the .hpj file in a pop-up window.</td>
     * <td>Contains the context identifier for a topic.</td>
     * </tr>
     * <tr>
     * <td>HELP_FINDER</td>
     * <td>Displays the Help Topics dialog box.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_FORCEFILE</td>
     * <td>Ensures that Windows Help is displaying the correct Help file. If the incorrect Help file is being displayed, Windows Help opens the correct one; otherwise, there is no action.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_HELPONHELP</td>
     * <td>Displays help on how to use Windows Help, if the Winhlp32.hlp file is available.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_INDEX</td>
     * <td>Displays the topic specified by the Contents option in the [OPTIONS] section of the .hpj file. This command is for backward compatibility. New applications should use the HELP_FINDER command.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_KEY</td>
     * <td>Displays the topic in the keyword table that matches the specified keyword, if there is an exact match. If there is more than one match, displays the Index with the topics listed in the <b>Topics Found</b> list box.</td>
     * <td>Address of a keyword string. Multiple keywords must be separated by semicolons.</td>
     * </tr>
     * <tr>
     * <td>HELP_MULTIKEY</td>
     * <td>Displays the topic specified by a keyword in an alternative keyword table.</td>
     * <td>Address of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-multikeyhelpa">MULTIKEYHELP</a> structure that specifies a table footnote character and a keyword.</td>
     * </tr>
     * <tr>
     * <td>HELP_PARTIALKEY</td>
     * <td>Displays the topic in the keyword table that matches the specified keyword, if there is an exact match. If there is more than one match, displays the <b>Topics Found</b> dialog box. To display the index without passing a keyword, use a pointer to an empty string.</td>
     * <td>Address of a keyword string. Multiple keywords must be separated by semicolons.</td>
     * </tr>
     * <tr>
     * <td>HELP_QUIT</td>
     * <td>Informs Windows Help that it is no longer needed. If no other applications have asked for help, Windows closes Windows Help.</td>
     * <td>Ignored; set to 0.</td>
     * </tr>
     * <tr>
     * <td>HELP_SETCONTENTS</td>
     * <td>Specifies the Contents topic. Windows Help displays this topic when the user clicks the <b>Contents</b> button if the Help file does not have an associated .cnt file.</td>
     * <td>Contains the context identifier for the Contents topic.</td>
     * </tr>
     * <tr>
     * <td>HELP_SETPOPUP_POS</td>
     * <td>Sets the position of the subsequent pop-up window.</td>
     * <td>Contains the position data. Use <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632660(v=vs.85)">MAKELONG</a> to concatenate the horizontal and vertical coordinates into a single value. The pop-up window is positioned as if the mouse cursor were at the specified point when the pop-up window was invoked.</td>
     * </tr>
     * <tr>
     * <td>HELP_SETWINPOS</td>
     * <td>Displays the Windows Help window, if it is minimized or in memory, and sets its size and position as specified.</td>
     * <td>Address of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-helpwininfoa">HELPWININFO</a> structure that specifies the size and position of either a primary or secondary Help window.</td>
     * </tr>
     * <tr>
     * <td>HELP_TCARD</td>
     * <td>Indicates that a command is for a training card instance of Windows Help. Combine this command with other commands using the bitwise OR operator.</td>
     * <td>Depends on the command with which this command is combined.</td>
     * </tr>
     * <tr>
     * <td>HELP_WM_HELP</td>
     * <td>Displays the topic for the control identified by the <i>hWndMain</i> parameter in a pop-up window.</td>
     * <td>Address of an array of <b>DWORD</b> pairs. The first <b>DWORD</b> in each pair is a control identifier, and the second is a context identifier for a topic. The array must be terminated by a pair of zeros {0,0}. If you do not want to add Help to a particular control, set its context identifier to -1.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines WinHelp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWndMain Type: <b>HWND</b>
     * 
     * A handle to the window requesting help. The <b>WinHelp</b> function uses this handle to keep track of which applications have requested help. If the <i>uCommand</i> parameter specifies <b>HELP_CONTEXTMENU</b> or <b>HELP_WM_HELP</b>, <i>hWndMain</i> identifies the control requesting help.
     * @param {Pointer<Char>} lpszHelp Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string containing the path, if necessary, and the name of the Help file that <b>WinHelp</b> is to display.
     * 	
     *     				
     * 
     * The file name can be followed by an angle bracket (&gt;) and the name of a secondary window if the topic is to be displayed in a secondary window rather than in the primary window. You must define the name of the secondary window in the [WINDOWS] section of the Help project (.hpj) file.
     * @param {Integer} uCommand Type: <b>UINT</b>
     * 
     * The type of help requested. For a list of possible values and how they affect the value to place in the <i>dwData</i> parameter, see the Remarks section.
     * @param {Pointer} dwData Type: <b>ULONG_PTR</b>
     * 
     * Additional data. The value used depends on the value of the <i>uCommand</i> parameter. For a list of possible <i>dwData</i> values, see the Remarks section.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-winhelpw
     * @since windows5.1.2600
     */
    static WinHelpW(hWndMain, lpszHelp, uCommand, dwData) {
        lpszHelp := lpszHelp is String? StrPtr(lpszHelp) : lpszHelp

        A_LastError := 0

        result := DllCall("USER32.dll\WinHelpW", "ptr", hWndMain, "ptr", lpszHelp, "uint", uCommand, "ptr", dwData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deprecated. Returns a pointer to an ITEMIDLIST structure when passed a path.
     * @remarks
     * Prior to Windows7, this function was declared in Shlobj.h. In Windows7 and later versions, it is declared in Shobjidl.h.
     * 
     * <div class="alert"><b>Note</b>This function is available through Windows7 and Windows Server2003. It is possible that it will not be present in future versions of Windows.</div>
     * <div></div>
     * An alternative to this function is as follows:
     *                 
     *                 
     * 
     * <ol>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetdesktopfolder">SHGetDesktopFolder</a> to obtain <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> for the desktop folder.</li>
     * <li>Get the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>'s bind context (<a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>).</li>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname">IShellFolder::ParseDisplayName</a> with the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> and the path.</li>
     * </ol>
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to be converted to a PIDL.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shsimpleidlistfrompath
     * @since windows5.0
     */
    static SHSimpleIDListFromPath(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHSimpleIDListFromPath", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Creates and initializes a Shell item object from a pointer to an item identifier list (PIDL). The resulting shell item object supports the IShellItem interface.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The source PIDL.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the requested interface.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in riid.  This will typically be <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateitemfromidlist
     * @since windows6.0.6000
     */
    static SHCreateItemFromIDList(pidl, riid, ppv) {
        result := DllCall("SHELL32.dll\SHCreateItemFromIDList", "ptr", pidl, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates and initializes a Shell item object from a parsing name.
     * @remarks
     * We recommend that you use the <b>IID_PPV_ARGS</b> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct <b>IID</b> based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error in <i>riid</i> that could lead to unexpected results.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a display name.
     * @param {Pointer<IBindCtx>} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * Optional. A pointer to a bind context used to pass parameters as inputs and outputs to the parsing function. These passed parameters are often specific to the data source and are documented by the data source owners. For example, the file system data source accepts the name being parsed (as a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure), using the <a href="https://docs.microsoft.com/windows/desktop/shell/str-constants">STR_FILE_SYS_BIND_DATA</a> bind context parameter.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/shell/str-constants">STR_PARSE_PREFER_FOLDER_BROWSING</a> can be passed to indicate that URLs are parsed using the file system data source when possible. Construct a bind context object using <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createbindctx">CreateBindCtx</a> and populate the values using <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-registerobjectparam">IBindCtx::RegisterObjectParam</a>. See <b>Bind Context String Keys</b> for a complete list of these. See the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd940368(v=vs.85)">Parsing With Parameters Sample</a> for an example of the use of this parameter.
     * 
     * 
     * 
     * If no data is being passed to or received from the parsing function, this value can be <b>NULL</b>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>, typically <b>IID_IShellItem</b> or <b>IID_IShellItem2</b>.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns successfully, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateitemfromparsingname
     * @since windows6.0.6000
     */
    static SHCreateItemFromParsingName(pszPath, pbc, riid, ppv) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHCreateItemFromParsingName", "ptr", pszPath, "ptr", pbc, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Create a Shell item, given a parent folder and a child item ID.
     * @param {Pointer<ITEMIDLIST>} pidlParent Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The IDList of the parent folder of the item being created; the IDList of <i>psfParent</i>. This parameter can be <b>NULL</b>, if <i>psfParent</i> is specified.
     * @param {Pointer<IShellFolder>} psfParent Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface that specifies the shell data source of the child item specified by the <i>pidl</i>.This parameter can be <b>NULL</b>, if <i>pidlParent</i> is specified.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A child item ID relative to its parent folder specified by <i>psfParent</i> or <i>pidlParent</i>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to an interface ID.
     * @param {Pointer<Void>} ppvItem Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in riid.  This will typically be <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateitemwithparent
     * @since windows6.0.6000
     */
    static SHCreateItemWithParent(pidlParent, psfParent, pidl, riid, ppvItem) {
        result := DllCall("SHELL32.dll\SHCreateItemWithParent", "ptr", pidlParent, "ptr", psfParent, "ptr", pidl, "ptr", riid, "ptr", ppvItem, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates and initializes a Shell item object from a relative parsing name.
     * @param {Pointer<IShellItem>} psiParent Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the parent Shell item.
     * @param {Pointer<Char>} pszName Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string that specifies a display name that is relative to the <i>psiParent</i>.
     * @param {Pointer<IBindCtx>} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A pointer to a bind context that controls the parsing operation. This parameter can be <b>NULL</b>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to an interface ID.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in riid.  This will usually be <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateitemfromrelativename
     * @since windows6.0.6000
     */
    static SHCreateItemFromRelativeName(psiParent, pszName, pbc, riid, ppv) {
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHELL32.dll\SHCreateItemFromRelativeName", "ptr", psiParent, "ptr", pszName, "ptr", pbc, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a Shell item object for a single file that exists inside a known folder.
     * @param {Pointer<Guid>} kfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A reference to the <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a>, a <b>GUID</b> that identifies the folder that contains the item.
     * @param {Integer} dwKFFlags Type: <b>DWORD</b>
     * 
     * Flags that specify special options in the object retrieval. This value can be 0; otherwise, one or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a> values.
     * @param {Pointer<Char>} pszItem Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the file name of the new item as a Unicode string. This parameter can also be <b>NULL</b>. In this case, an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> that represents the known folder itself is created.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface that represents the item, retrieved through <i>ppv</i>. This value is typically IID_IShellItem or IID_IShellItem2.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this function returns successfully, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateiteminknownfolder
     * @since windows6.0.6000
     */
    static SHCreateItemInKnownFolder(kfid, dwKFFlags, pszItem, riid, ppv) {
        pszItem := pszItem is String? StrPtr(pszItem) : pszItem

        result := DllCall("SHELL32.dll\SHCreateItemInKnownFolder", "ptr", kfid, "uint", dwKFFlags, "ptr", pszItem, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the pointer to an item identifier list (PIDL) of an object.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> of the object from which to get the PIDL.
     * @param {Pointer<ITEMIDLIST>} ppidl Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * When this function returns, contains a pointer to the PIDL of the given object.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shgetidlistfromobject
     * @since windows6.0.6000
     */
    static SHGetIDListFromObject(punk, ppidl) {
        result := DllCall("SHELL32.dll\SHGetIDListFromObject", "ptr", punk, "ptr", ppidl, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves an IShellItem for an object.
     * @remarks
     * From the standpoint of performance, this method is preferred to <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shgetidlistfromobject">SHGetIDListFromObject</a> in those cases where the IDList is already bound to a folder.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> of the object.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired IID.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or a related interface.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shgetitemfromobject
     * @since windows6.1
     */
    static SHGetItemFromObject(punk, riid, ppv) {
        result := DllCall("SHELL32.dll\SHGetItemFromObject", "ptr", punk, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the display name of an item identified by its IDList.
     * @remarks
     * It is the responsibility of the caller to free the string pointed to by <i>ppszName</i> when it is no longer needed. Call <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> on *<i>ppszName</i> to free the memory.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A PIDL that identifies the item.
     * @param {Integer} sigdnName Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-sigdn">SIGDN</a></b>
     * 
     * A value from the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-sigdn">SIGDN</a> enumeration that specifies the type of display name to retrieve.
     * @param {Pointer<Char>} ppszName Type: <b>PWSTR*</b>
     * 
     * A value that, when this function returns successfully, receives the address of a pointer to the retrieved display name.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shgetnamefromidlist
     * @since windows6.0.6000
     */
    static SHGetNameFromIDList(pidl, sigdnName, ppszName) {
        result := DllCall("SHELL32.dll\SHGetNameFromIDList", "ptr", pidl, "int", sigdnName, "ptr", ppszName, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates an IShellItem or related object based on an item specified by an IDataObject.
     * @remarks
     * It is recommended that you use the <b>IID_PPV_ARGS</b> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error.
     * @param {Pointer<IDataObject>} pdtobj Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to the source <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> instance.
     * @param {Integer} dwFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-dataobj_get_item_flags">DATAOBJ_GET_ITEM_FLAGS</a></b>
     * 
     * One or more values from the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-dataobj_get_item_flags">DATAOBJ_GET_ITEM_FLAGS</a> enumeration to specify options regarding the target object. This value can be 0.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>, typically IID_IShellItem.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shgetitemfromdataobject
     * @since windows6.1
     */
    static SHGetItemFromDataObject(pdtobj, dwFlags, riid, ppv) {
        result := DllCall("SHELL32.dll\SHGetItemFromDataObject", "ptr", pdtobj, "int", dwFlags, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a Shell item array object.
     * @param {Pointer<ITEMIDLIST>} pidlParent Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The ID list of the parent folder of the items specified in <i>ppidl</i>. If <i>psf</i> is specified, this parameter can be <b>NULL</b>. If this <i>pidlParent</i> is not specified, it is computed from the <i>psf</i> parameter using <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder2">IPersistFolder2</a>.
     * @param {Pointer<IShellFolder>} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * The Shell data source object that is the parent of the child items specified in <i>ppidl</i>. If <i>pidlParent</i> is specified, this parameter can be <b>NULL</b>.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of elements in the array specified by <i>ppidl</i>.
     * @param {Pointer<ITEMIDLIST>} ppidl Type: <b>PCUITEMID_CHILD_ARRAY</b>
     * 
     * The list of child item IDs for which the array is being created. This value can be <b>NULL</b>.
     * @param {Pointer<IShellItemArray>} ppsiItemArray Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a>**</b>
     * 
     * When this function returns, contains the address of an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a> interface pointer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarray
     * @since windows6.0.6000
     */
    static SHCreateShellItemArray(pidlParent, psf, cidl, ppidl, ppsiItemArray) {
        result := DllCall("SHELL32.dll\SHCreateShellItemArray", "ptr", pidlParent, "ptr", psf, "uint", cidl, "ptr", ppidl, "ptr", ppsiItemArray, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a Shell item array object from a data object.
     * @remarks
     * This function is useful for Shell extensions that implement <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellextinit">IShellExtInit</a> and are passed a data object to the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellextinit-initialize">IShellExtInit::Initialize</a> method; for example, context menu handlers.
     * 
     * This API lets you convert the data object into a Shell item that the handler can consume. It is recommend that handlers use a Shell item array rather than clipboard formats like <b>CF_HDROP</b> and <b>CFSTR_SHELLIDLIST</b> (also known as HIDA) as it leads to simpler code and allows some performance improvements.
     * 
     * The resulting shell item array holds a reference to the source data object.  Therefore, that data object must remain valid for the lifetime of the shell item array.  Notably, the data objects passed to <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idroptarget">IDropTarget</a> methods are no longer valid after the drop operation completes.
     * @param {Pointer<IDataObject>} pdo Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the desired interface ID.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject
     * @since windows6.0.6000
     */
    static SHCreateShellItemArrayFromDataObject(pdo, riid, ppv) {
        result := DllCall("SHELL32.dll\SHCreateShellItemArrayFromDataObject", "ptr", pdo, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a Shell item array object from a list of ITEMIDLIST structures.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of elements in the array.
     * @param {Pointer<ITEMIDLIST>} rgpidl Type: <b>PCIDLIST_ABSOLUTE_ARRAY</b>
     * 
     * A list of <i>cidl</i> constant pointers to <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures.
     * @param {Pointer<IShellItemArray>} ppsiItemArray Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a>**</b>
     * 
     * When this function returns, contains an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a> interface pointer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromidlists
     * @since windows6.0.6000
     */
    static SHCreateShellItemArrayFromIDLists(cidl, rgpidl, ppsiItemArray) {
        result := DllCall("SHELL32.dll\SHCreateShellItemArrayFromIDLists", "uint", cidl, "ptr", rgpidl, "ptr", ppsiItemArray, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates an array of one element from a single Shell item.
     * @remarks
     * This function creates a one-element array from a single item. To create an array from the contents of a folder, use <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarray">SHCreateShellItemArray</a>.
     * @param {Pointer<IShellItem>} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * Pointer to <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> object that represents the item.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>, typically IID_IShellItemArray.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromshellitem
     * @since windows6.0.6000
     */
    static SHCreateShellItemArrayFromShellItem(psi, riid, ppv) {
        result := DllCall("SHELL32.dll\SHCreateShellItemArrayFromShellItem", "ptr", psi, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates an IApplicationAssociationRegistration object based on the stock implementation of the interface provided by Windows.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the requested interface.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this function returns, contains the address of a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-iapplicationassociationregistration">IApplicationAssociationRegistration</a> object.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreateassociationregistration
     * @since windows6.0.6000
     */
    static SHCreateAssociationRegistration(riid, ppv) {
        result := DllCall("SHELL32.dll\SHCreateAssociationRegistration", "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a standard icon extractor, whose defaults can be further configured via the IDefaultExtractIconInit interface.
     * @remarks
     * The intended usage for this function is as follows:
     *             
     *                 
     * 
     * 
     * ```
     * IExtractIcon *pxi;
     * 
     * IDefaultExtractIconInit *pdxi;
     * 
     * HRESULT hr = SHCreateDefaultExtractIcon(IID_PPV_ARGS(&pdxi);
     * 
     *  if (SUCCEEDED(hr)) &&
     * 
     *       SUCCEEDED(hr = pdxi->SetFlags(GIL_PERCLASS)) &&
     * 
     *       SUCCEEDED(hr = pdxi->SetKey(hkey)) &&   // optional
     * 
     *       SUCCEEDED(hr = pdxi->SetNormalIcon(L"this.dll", 1)) &&
     * 
     *       SUCCEEDED(hr = pdxi->SetOpenIcon(NULL, SIID_FOLDEROPEN)) && // optional
     * 
     *       SUCCEEDED(hr = pdxi->SetDefaultIcon(NULL, SIID_FOLDER)) && // optional
     * 
     *       SUCCEEDED(hr = pdxi->SetShortcutIcon(L"this.dll", 2))) // optional
     * 
     * {
     * 
     *       hr = pdxi->QueryInterface(IID_PPV_ARGS(&pxi)) 
     * 
     * }
     * 
     *  if (pdxi)
     * 
     * {
     * 
     *     pdxi->Release();
     * 
     * }
     * ```
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to interface ID.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * The address of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idefaultextracticoninit">IDefaultExtractIconInit</a> interface pointer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shcreatedefaultextracticon
     * @since windows6.0.6000
     */
    static SHCreateDefaultExtractIcon(riid, ppv) {
        result := DllCall("SHELL32.dll\SHCreateDefaultExtractIcon", "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Specifies a unique application-defined Application User Model ID (AppUserModelID) that identifies the current process to the taskbar. This identifier allows an application to group its associated processes and windows under a single taskbar button.
     * @remarks
     * This method must be called during an application's initial startup routine before the application presents any UI or makes any manipulation of its Jump Lists. This includes any call to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shaddtorecentdocs">SHAddToRecentDocs</a>.
     * @param {Pointer<Char>} AppID Type: <b>PCWSTR</b>
     * 
     * Pointer to the AppUserModelID to assign to the current process.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-setcurrentprocessexplicitappusermodelid
     * @since windows6.1
     */
    static SetCurrentProcessExplicitAppUserModelID(AppID) {
        AppID := AppID is String? StrPtr(AppID) : AppID

        result := DllCall("SHELL32.dll\SetCurrentProcessExplicitAppUserModelID", "ptr", AppID, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the application-defined, explicit Application User Model ID (AppUserModelID) for the current process.
     * @remarks
     * The AppUserModelID retrieved by this function was set earlier through <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-setcurrentprocessexplicitappusermodelid">SetCurrentProcessExplicitAppUserModelID</a>.
     * 
     * An application can only retrieve an AppUserModelID that has been explicitly set. System-assigned default AppUserModelIDs cannot be retrieved. If the application requires knowledge of its AppUserModelID it should set one explicitly.
     * @param {Pointer<Char>} AppID Type: <b>PWSTR*</b>
     * 
     * A pointer that receives the address of the AppUserModelID assigned to the process. The caller is responsible for freeing this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-getcurrentprocessexplicitappusermodelid
     * @since windows6.1
     */
    static GetCurrentProcessExplicitAppUserModelID(AppID) {
        result := DllCall("SHELL32.dll\GetCurrentProcessExplicitAppUserModelID", "ptr", AppID, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the temporary property for the given item. A temporary property is a read/write store that holds properties only for the lifetime of the IShellItem object, rather than being persisted back into the item.
     * @param {Pointer<IShellItem>} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the item for which the temporary property is to be retrieved.
     * @param {Pointer<PROPERTYKEY>} propkey Type: <b>REFPROPERTYKEY</b>
     * 
     * The property key.
     * @param {Pointer<PROPVARIANT>} ppropvar Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a>*</b>
     * 
     * A pointer to the temporary property for the item.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shgettemporarypropertyforitem
     * @since windows6.0.6000
     */
    static SHGetTemporaryPropertyForItem(psi, propkey, ppropvar) {
        result := DllCall("SHELL32.dll\SHGetTemporaryPropertyForItem", "ptr", psi, "ptr", propkey, "ptr", ppropvar, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Sets a temporary property for the specified item. A temporary property is kept in a read/write store that holds properties only for the lifetime of the IShellItem object, instead of writing them back into the item.
     * @remarks
     * A temporary value can only be read with <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shgettemporarypropertyforitem">SHGetTemporaryPropertyForItem</a> or by passing GPS_TEMPORARY to <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem2-getpropertystore">IShellItem2::GetPropertyStore</a>.
     * @param {Pointer<IShellItem>} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the item on which the temporary property is to be set.
     * @param {Pointer<PROPERTYKEY>} propkey Type: <b>REFPROPERTYKEY</b>
     * 
     * Reference to the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ns-wtypes-propertykey">PROPERTYKEY</a> that identifies the temporary property that is being set.
     * @param {Pointer<PROPVARIANT>} propvar Type: <b>REFPROPVARIANT</b>
     * 
     * Reference to a <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> that contains the value of the temporary property.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shsettemporarypropertyforitem
     * @since windows6.0.6000
     */
    static SHSetTemporaryPropertyForItem(psi, propkey, propvar) {
        result := DllCall("SHELL32.dll\SHSetTemporaryPropertyForItem", "ptr", psi, "ptr", propkey, "ptr", propvar, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Shows the library management dialog box, which enables users to manage the library folders and default save location.
     * @param {Pointer<IShellItem>} psiLibrary Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> object that represents the library that is to be managed.
     * @param {Pointer<Void>} hwndOwner Type: <b>HWND</b>
     * 
     * The handle for the window that owns the library management dialog box. The value of this parameter can be <b>NULL</b>.
     * @param {Pointer<Char>} pszTitle Type: <b>LPCWSTR</b>
     * 
     * A pointer to the title for the library management dialog. To display the generic title string, set the value of this parameter to <b>NULL</b>.
     * @param {Pointer<Char>} pszInstruction Type: <b>LPCWSTR</b>
     * 
     * A pointer to a help string to display below the title string in the library management dialog box. To display the generic help string, set the value of this parameter to <b>NULL</b>.
     * @param {Integer} lmdOptions Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-librarymanagedialogoptions">LIBRARYMANAGEDIALOGOPTIONS</a></b>
     * 
     * A value from the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-librarymanagedialogoptions">LIBRARYMANAGEDIALOGOPTIONS</a> enumeration that specifies the behavior of the management dialog box.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shshowmanagelibraryui
     * @since windows6.1
     */
    static SHShowManageLibraryUI(psiLibrary, hwndOwner, pszTitle, pszInstruction, lmdOptions) {
        pszTitle := pszTitle is String? StrPtr(pszTitle) : pszTitle
        pszInstruction := pszInstruction is String? StrPtr(pszInstruction) : pszInstruction

        result := DllCall("SHELL32.dll\SHShowManageLibraryUI", "ptr", psiLibrary, "ptr", hwndOwner, "ptr", pszTitle, "ptr", pszInstruction, "int", lmdOptions, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Resolves all locations in a library, even those locations that have been moved or renamed.
     * @remarks
     * This function can block the calling thread for as long as it takes to resolve all the locations in the specified library. Because it blocks the thread from which it is called, it should not be called from a thread that also handles user interface interactions.
     * 
     * This function resolves all locations in the specified library in a single call. To resolve an individual location in a library, see the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishelllibrary-resolvefolder">IShellLibrary::ResolveFolder</a> method or the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl/nf-shobjidl-shresolvefolderpathinlibrary">SHResolveFolderPathInLibrary</a> function.
     * @param {Pointer<IShellItem>} psiLibrary Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> object that represents the library.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shresolvelibrary
     * @since windows6.1
     */
    static SHResolveLibrary(psiLibrary) {
        result := DllCall("SHELL32.dll\SHResolveLibrary", "ptr", psiLibrary, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Returns an enumeration object for a specified set of file name extension handlers.
     * @param {Pointer<Char>} pszExtra Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains a single file type extension, for instance ".jpg". Only handlers associated with the given extension are enumerated. This parameter may not be **NULL**.
     * @param {Integer} afFilter Type: <b>ASSOC_FILTER</b>
     * @param {Pointer<IEnumAssocHandlers>} ppEnumHandler Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumassochandlers">IEnumAssocHandlers</a>**</b>
     * 
     * When this method returns, contains the address of a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumassochandlers">IEnumAssocHandlers</a> object.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shassocenumhandlers
     * @since windows6.0.6000
     */
    static SHAssocEnumHandlers(pszExtra, afFilter, ppEnumHandler) {
        pszExtra := pszExtra is String? StrPtr(pszExtra) : pszExtra

        result := DllCall("SHELL32.dll\SHAssocEnumHandlers", "ptr", pszExtra, "int", afFilter, "ptr", ppEnumHandler, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Gets an enumeration interface that provides access to handlers associated with a given protocol.
     * @remarks
     * It is recommended that you use the <b>IID_PPV_ARGS</b> macro, defined in Objbase.h, to package the <i>riid</i> and <i>enumHandlers</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>enumHandlers</i>, which eliminates the possibility of a coding error.
     * @param {Pointer<Char>} protocol Type: <b>PCWSTR</b>
     * 
     * Pointer to a string that specifies the protocol.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>enumHandlers</i>, typically IID_IEnumAssocHandlers.
     * @param {Pointer<Void>} enumHandlers Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumassochandlers">IEnumAssocHandlers</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl_core/nf-shobjidl_core-shassocenumhandlersforprotocolbyapplication
     * @since windows6.1
     */
    static SHAssocEnumHandlersForProtocolByApplication(protocol, riid, enumHandlers) {
        protocol := protocol is String? StrPtr(protocol) : protocol

        result := DllCall("SHELL32.dll\SHAssocEnumHandlersForProtocolByApplication", "ptr", protocol, "ptr", riid, "ptr", enumHandlers, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} param0 
     * @param {Integer} param1 
     * @param {Pointer<Void>} param2 
     * @returns {Integer} 
     */
    static HMONITOR_UserSize(param0, param1, param2) {
        result := DllCall("OLE32.dll\HMONITOR_UserSize", "uint*", param0, "uint", param1, "ptr", param2, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} param0 
     * @param {Pointer<Byte>} param1 
     * @param {Pointer<Void>} param2 
     * @returns {Pointer<Byte>} 
     */
    static HMONITOR_UserMarshal(param0, param1, param2) {
        result := DllCall("OLE32.dll\HMONITOR_UserMarshal", "uint*", param0, "char*", param1, "ptr", param2, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} param0 
     * @param {Pointer<Byte>} param1 
     * @param {Pointer<Void>} param2 
     * @returns {Pointer<Byte>} 
     */
    static HMONITOR_UserUnmarshal(param0, param1, param2) {
        result := DllCall("OLE32.dll\HMONITOR_UserUnmarshal", "uint*", param0, "char*", param1, "ptr", param2, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} param0 
     * @param {Pointer<Void>} param1 
     * @returns {String} Nothing - always returns an empty string
     */
    static HMONITOR_UserFree(param0, param1) {
        DllCall("OLE32.dll\HMONITOR_UserFree", "uint*", param0, "ptr", param1)
    }

    /**
     * 
     * @param {Pointer<UInt32>} param0 
     * @param {Integer} param1 
     * @param {Pointer<Void>} param2 
     * @returns {Integer} 
     */
    static HMONITOR_UserSize64(param0, param1, param2) {
        result := DllCall("OLE32.dll\HMONITOR_UserSize64", "uint*", param0, "uint", param1, "ptr", param2, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} param0 
     * @param {Pointer<Byte>} param1 
     * @param {Pointer<Void>} param2 
     * @returns {Pointer<Byte>} 
     */
    static HMONITOR_UserMarshal64(param0, param1, param2) {
        result := DllCall("OLE32.dll\HMONITOR_UserMarshal64", "uint*", param0, "char*", param1, "ptr", param2, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} param0 
     * @param {Pointer<Byte>} param1 
     * @param {Pointer<Void>} param2 
     * @returns {Pointer<Byte>} 
     */
    static HMONITOR_UserUnmarshal64(param0, param1, param2) {
        result := DllCall("OLE32.dll\HMONITOR_UserUnmarshal64", "uint*", param0, "char*", param1, "ptr", param2, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} param0 
     * @param {Pointer<Void>} param1 
     * @returns {String} Nothing - always returns an empty string
     */
    static HMONITOR_UserFree64(param0, param1) {
        DllCall("OLE32.dll\HMONITOR_UserFree64", "uint*", param0, "ptr", param1)
    }

    /**
     * Creates a file operation that sets the default properties on the Shell item that have not already been set.
     * @remarks
     * The list of properties to set a default value comes from the <b>SetDefaultsFor</b> registry entry under the ProgID for the file association of the item. The list is prefixed by <c>prop:</code> and contains the canonical names of the properties to set the default value, for example, <code>prop:System.Author;System.Document.DateCreated</c>. The possible properties for this list are <a href="https://docs.microsoft.com/windows/desktop/properties/props-system-author">System.Author</a>, <a href="https://docs.microsoft.com/windows/desktop/properties/props-system-document-datecreated">System.Document.DateCreated</a>, and <a href="https://docs.microsoft.com/windows/desktop/properties/props-system-photo-datetaken">System.Photo.DateTaken</a>. If the <b>SetDefaultsFor</b> entry does not exist on the ProgID, this function uses the default found on the <b>SetDefaultsFor</b> entry of <b>HKEY_CLASSES_ROOT</b>&#92;<b>*</b>.
     * @param {Pointer<IShellItem>} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the source shell item. See <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>.
     * @param {Pointer<IFileOperation>} ppFileOp Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifileoperation">IFileOperation</a>**</b>
     * 
     * The address of the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifileoperation">IFileOperation</a> interface pointer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl/nf-shobjidl-shcreatedefaultpropertiesop
     * @since windows6.0.6000
     */
    static SHCreateDefaultPropertiesOp(psi, ppFileOp) {
        result := DllCall("SHELL32.dll\SHCreateDefaultPropertiesOp", "ptr", psi, "ptr", ppFileOp, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Applies the default set of properties on a Shell item.
     * @remarks
     * The list of properties to set a default value comes from the <b>SetDefaultsFor</b> registry entry under the ProgID for the file association of the item. The list is prefixed by "<c>prop:</code>" and contains the canonical names of the properties to set the default value, for example, "<code>prop:System.Author;System.Document.DateCreated</c>". The possible properties for this list are <a href="https://docs.microsoft.com/windows/desktop/properties/props-system-author">System.Author</a>, <a href="https://docs.microsoft.com/windows/desktop/properties/props-system-document-datecreated">System.Document.DateCreated</a>, and <a href="https://docs.microsoft.com/windows/desktop/properties/props-system-photo-datetaken">System.Photo.DateTaken</a>. If the <b>SetDefaultsFor</b> entry does not exist on the ProgID, this function uses the default found on the <b>SetDefaultsFor</b> entry of <b>HKEY_CLASSES_ROOT</b>&#92;<b>*</b>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the item's parent window, which receives error notifications. This value can be <b>NULL</b>.
     * @param {Pointer<IShellItem>} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> object that represents the item.
     * @param {Integer} dwFileOpFlags Type: <b>DWORD</b>
     * 
     * Flags that customize the operation. See <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ifileoperation-setoperationflags">IFileOperation::SetOperationFlags</a> for flag values.
     * @param {Pointer<IFileOperationProgressSink>} pfops Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifileoperationprogresssink">IFileOperationProgressSink</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifileoperationprogresssink">IFileOperationProgressSink</a> object used to follow the progress of the operation. See <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ifileoperation-advise">IFileOperation::Advise</a> for details. This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shobjidl/nf-shobjidl-shsetdefaultproperties
     * @since windows6.0.6000
     */
    static SHSetDefaultProperties(hwnd, psi, dwFileOpFlags, pfops) {
        result := DllCall("SHELL32.dll\SHSetDefaultProperties", "ptr", hwnd, "ptr", psi, "uint", dwFileOpFlags, "ptr", pfops, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves a pointer to the Shell's IMalloc interface.
     * @remarks
     * <b>SHGetMalloc</b> was introduced in Windows95 and Microsoft WindowsNT4.0, but as of Windows2000 it is no longer necessary. In its place, programs can call the equivalent (and easier to use) <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a> and <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>. If you find an older reference document that suggests or even requires the use of <b>SHGetMalloc</b>, it is acceptable and encouraged to use <b>CoTaskMemAlloc</b> and <b>CoTaskMemFree</b> instead.
     * @param {Pointer<IMalloc>} ppMalloc Type: <b>LPMALLOC*</b>
     * 
     * The address of a pointer that receives the Shell's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imalloc">IMalloc</a> interface pointer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetmalloc
     * @since windows5.1.2600
     */
    static SHGetMalloc(ppMalloc) {
        result := DllCall("SHELL32.dll\SHGetMalloc", "ptr", ppMalloc, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Allocates memory from the Shell's heap.
     * @remarks
     * You can free this memory by calling <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shfree">SHFree</a>.
     * @param {Pointer} cb Type: <b>SIZE_T</b>
     * 
     * The number of bytes of memory to allocate.
     * @returns {Pointer<Void>} Type: <b>LPVOID</b>
     * 
     * A pointer to the allocated memory.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shalloc
     * @since windows5.0
     */
    static SHAlloc(cb) {
        result := DllCall("SHELL32.dll\SHAlloc", "ptr", cb)
        return result
    }

    /**
     * Frees the memory allocated by SHAlloc.
     * @param {Pointer<Void>} pv Type: <b>void*</b>
     * 
     * A pointer to the memory allocated by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shalloc">SHAlloc</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shfree
     * @since windows5.0
     */
    static SHFree(pv) {
        DllCall("SHELL32.dll\SHFree", "ptr", pv)
    }

    /**
     * Returns the index of the overlay icon in the system image list. (ANSI)
     * @remarks
     * Icon overlays are part of the system image list. They have two identifiers. The first is a one-based overlay index that identifies the overlay relative to other overlays in the image list. The other is an image index that identifies the actual image. These two indexes are equivalent to the values that you assign to the <i>iOverlay</i> and <i>iImage</i> parameters, respectively, when you add an icon overlay to a private image list with <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-imagelist_setoverlayimage">ImageList_SetOverlayImage</a>. <b>SHGetIconOverlayIndex</b> returns the overlay index. To convert an overlay index to its equivalent image index, call <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-indextooverlaymask">INDEXTOOVERLAYMASK</a>.
     * 
     * <div class="alert"><b>Note</b>After the image has been loaded into the system image list during initialization, it cannot be changed. The file name and index specified by <i>pszIconPath</i> and <i>iIconIndex</i> are used only to identify the icon overlay. <b>SHGetIconOverlayIndex</b> cannot be used to modify the system image list.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetIconOverlayIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszIconPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgeticonoverlayindexa
     * @since windows5.0
     */
    static SHGetIconOverlayIndexA(pszIconPath, iIconIndex) {
        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\SHGetIconOverlayIndexA", "ptr", pszIconPath, "int", iIconIndex, "int")
        return result
    }

    /**
     * Returns the index of the overlay icon in the system image list. (Unicode)
     * @remarks
     * Icon overlays are part of the system image list. They have two identifiers. The first is a one-based overlay index that identifies the overlay relative to other overlays in the image list. The other is an image index that identifies the actual image. These two indexes are equivalent to the values that you assign to the <i>iOverlay</i> and <i>iImage</i> parameters, respectively, when you add an icon overlay to a private image list with <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-imagelist_setoverlayimage">ImageList_SetOverlayImage</a>. <b>SHGetIconOverlayIndex</b> returns the overlay index. To convert an overlay index to its equivalent image index, call <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-indextooverlaymask">INDEXTOOVERLAYMASK</a>.
     * 
     * <div class="alert"><b>Note</b>After the image has been loaded into the system image list during initialization, it cannot be changed. The file name and index specified by <i>pszIconPath</i> and <i>iIconIndex</i> are used only to identify the icon overlay. <b>SHGetIconOverlayIndex</b> cannot be used to modify the system image list.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetIconOverlayIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszIconPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgeticonoverlayindexw
     * @since windows5.0
     */
    static SHGetIconOverlayIndexW(pszIconPath, iIconIndex) {
        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\SHGetIconOverlayIndexW", "ptr", pszIconPath, "int", iIconIndex, "int")
        return result
    }

    /**
     * Clones an ITEMIDLIST structure.
     * @remarks
     * When you are finished with the cloned <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure, release it with <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a> to avoid memory leaks.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure to be cloned.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_RELATIVE</b>
     * 
     * Returns a pointer to a copy of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure pointed to by <i>pidl</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilclone
     * @since windows5.1.2600
     */
    static ILClone(pidl) {
        result := DllCall("SHELL32.dll\ILClone", "ptr", pidl, "ptr")
        return result
    }

    /**
     * Clones the first SHITEMID structure in an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that you want to clone.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PITEMID_CHILD</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that contains the first <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure from the <b>ITEMIDLIST</b> structure specified by <i>pidl</i>. Returns <b>NULL</b> on failure.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilclonefirst
     * @since windows5.1.2600
     */
    static ILCloneFirst(pidl) {
        result := DllCall("SHELL32.dll\ILCloneFirst", "ptr", pidl, "ptr")
        return result
    }

    /**
     * Combines two ITEMIDLIST structures.
     * @param {Pointer<ITEMIDLIST>} pidl1 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to the first <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<ITEMIDLIST>} pidl2 Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to the second <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure. This structure is appended to the structure pointed to by <i>pidl1</i>.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> containing the combined structures. If you set either <i>pidl1</i> or <i>pidl2</i> to <b>NULL</b>, the returned <b>ITEMIDLIST</b> structure is a clone of the non-<b>NULL</b> parameter. Returns <b>NULL</b> if <i>pidl1</i> and <i>pidl2</i> are both set to <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilcombine
     * @since windows5.1.2600
     */
    static ILCombine(pidl1, pidl2) {
        result := DllCall("SHELL32.dll\ILCombine", "ptr", pidl1, "ptr", pidl2, "ptr")
        return result
    }

    /**
     * Frees an ITEMIDLIST structure allocated by the Shell.
     * @remarks
     * <b>ILFree</b> is often used with <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures allocated by one of the other IL functions, but it can be used to free any such structure returned by the Shellfor example, the <b>ITEMIDLIST</b> structure returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shbrowseforfoldera">SHBrowseForFolder</a> or used in a call to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderlocation">SHGetFolderLocation</a>.
     * 
     * <div class="alert"><b>Note</b>When using Windows2000 or later, use <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> rather than <b>ILFree</b>. <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures are always allocated with the Component Object Model (COM) task allocator on those platforms.</div>
     * <div></div>
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure to be freed. This parameter can be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilfree
     * @since windows5.1.2600
     */
    static ILFree(pidl) {
        DllCall("SHELL32.dll\ILFree", "ptr", pidl)
    }

    /**
     * Retrieves the next SHITEMID structure in an ITEMIDLIST structure. (ILGetNext)
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to a particular <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure in a larger <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PUIDLIST_RELATIVE</b>
     * 
     * Returns a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure that follows the one specified by <i>pidl</i>. Returns <b>NULL</b> if <i>pidl</i> points to the last <b>SHITEMID</b> structure.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilgetnext
     * @since windows5.1.2600
     */
    static ILGetNext(pidl) {
        result := DllCall("SHELL32.dll\ILGetNext", "ptr", pidl, "ptr")
        return result
    }

    /**
     * Returns the size, in bytes, of an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * The size of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure specified by <i>pidl</i>, in bytes.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilgetsize
     * @since windows5.1.2600
     */
    static ILGetSize(pidl) {
        result := DllCall("SHELL32.dll\ILGetSize", "ptr", pidl, "uint")
        return result
    }

    /**
     * Determines whether a specified ITEMIDLIST structure is the child of another ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidlParent Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to the parent <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<ITEMIDLIST>} pidlChild Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to the child <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PUIDLIST_RELATIVE</b>
     * 
     * Returns a pointer to the child's simple <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure if <i>pidlChild</i> is a child of <i>pidlParent</i>. The returned structure consists of <i>pidlChild</i>, minus the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structures that make up <i>pidlParent</i>. Returns <b>NULL</b> if <i>pidlChild</i> is not a child of <i>pidlParent</i>.
     * 
     * <div class="alert"><b>Note</b>The returned pointer is a pointer into the existing parent structure. It is an alias for <i>pidlChild</i>. No new memory is allocated in association with the returned pointer. It is not the caller's responsibility to free the returned value.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilfindchild
     * @since windows5.1.2600
     */
    static ILFindChild(pidlParent, pidlChild) {
        result := DllCall("SHELL32.dll\ILFindChild", "ptr", pidlParent, "ptr", pidlChild, "ptr")
        return result
    }

    /**
     * Returns a pointer to the last SHITEMID structure in an ITEMIDLIST structure.
     * @remarks
     * This function does not clone the last item, so you do not have to call <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a> to release the returned pointer.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PUITEMID_CHILD</b>
     * 
     * A pointer to the last <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure in <i>pidl</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilfindlastid
     * @since windows5.1.2600
     */
    static ILFindLastID(pidl) {
        result := DllCall("SHELL32.dll\ILFindLastID", "ptr", pidl, "ptr")
        return result
    }

    /**
     * Removes the last SHITEMID structure from an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PUIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure to be shortened. When the function returns, this variable points to the shortened structure.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilremovelastid
     * @since windows5.1.2600
     */
    static ILRemoveLastID(pidl) {
        result := DllCall("SHELL32.dll\ILRemoveLastID", "ptr", pidl, "int")
        return result
    }

    /**
     * Tests whether two ITEMIDLIST structures are equal in a binary comparison.
     * @remarks
     * <b>ILIsEqual</b> performs a binary comparison of the item data. It is possible for two <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures to differ at the binary level while referring to the same item. <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-compareids">IShellFolder::CompareIDs</a> should be used to perform a non-binary comparison.
     * @param {Pointer<ITEMIDLIST>} pidl1 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The first <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<ITEMIDLIST>} pidl2 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The second <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the two structures are equal, <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilisequal
     * @since windows5.1.2600
     */
    static ILIsEqual(pidl1, pidl2) {
        result := DllCall("SHELL32.dll\ILIsEqual", "ptr", pidl1, "ptr", pidl2, "int")
        return result
    }

    /**
     * Tests whether an ITEMIDLIST structure is the parent of another ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl1 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) structure that specifies the parent. This must be an absolute PIDL.
     * @param {Pointer<ITEMIDLIST>} pidl2 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) structure that specifies the child. This must be an absolute PIDL.
     * @param {Integer} fImmediate Type: <b>BOOL</b>
     * 
     * A Boolean value that is set to <b>TRUE</b> to test for immediate parents of <i>pidl2</i>, or <b>FALSE</b> to test for any parents of <i>pidl2</i>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pidl1</i> is a parent of <i>pidl2</i>. If <i>fImmediate</i> is set to <b>TRUE</b>, the function only returns <b>TRUE</b> if <i>pidl1</i> is the immediate parent of <i>pidl2</i>. Otherwise, the function returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilisparent
     * @since windows5.1.2600
     */
    static ILIsParent(pidl1, pidl2, fImmediate) {
        result := DllCall("SHELL32.dll\ILIsParent", "ptr", pidl1, "ptr", pidl2, "int", fImmediate, "int")
        return result
    }

    /**
     * Saves an ITEMIDLIST structure to a stream.
     * @remarks
     * The stream must be opened for writing, or <b>ILSaveToStream</b> returns an error.
     * @param {Pointer<IStream>} pstm Type: <b>IStream *</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface where the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> is saved.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure to be saved.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or a COM error value otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilsavetostream
     * @since windows5.1.2600
     */
    static ILSaveToStream(pstm, pidl) {
        result := DllCall("SHELL32.dll\ILSaveToStream", "ptr", pstm, "ptr", pidl, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * This function may be altered or unavailable.
     * @remarks
     * For use where STRICT_TYPED_ITEMIDS is defined.
     * @param {Pointer<IStream>} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface from which the absolute 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> loads.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * When this method returns and succeeds, contains the resulting absolute 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a>. If it fails, contains 
     *       <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-illoadfromstreamex
     * @since windows6.0.6000
     */
    static ILLoadFromStreamEx(pstm, pidl) {
        result := DllCall("SHELL32.dll\ILLoadFromStreamEx", "ptr", pstm, "ptr", pidl, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Returns the ITEMIDLIST structure associated with a specified file path. (ILCreateFromPathA)
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a> to release the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> when you are finished with it.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines ILCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that corresponds to the path.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilcreatefrompatha
     * @since windows5.1.2600
     */
    static ILCreateFromPathA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\ILCreateFromPathA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * The ILCreateFromPathW (Unicode) function returns the ITEMIDLIST structure associated with a specified file path.
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a> to release the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> when you are finished with it.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines ILCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that corresponds to the path.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilcreatefrompathw
     * @since windows5.1.2600
     */
    static ILCreateFromPathW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\ILCreateFromPathW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * SHILCreateFromPath may be altered or unavailable.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH containing the path to be converted.
     * @param {Pointer<ITEMIDLIST>} ppidl Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * The path in <i>pszPath</i> expressed as a PIDL.
     * @param {Pointer<UInt32>} rgfInOut Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that, on entry, indicates any attributes of the folder named in <i>pszPath</i> that the calling application would like to retrieve along with the PIDL. On exit, this value contains those requested attributes. For a list of possible attribute flags for this parameter, see <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">IShellFolder::GetAttributesOf</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shilcreatefrompath
     * @since windows5.1.2600
     */
    static SHILCreateFromPath(pszPath, ppidl, rgfInOut) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHILCreateFromPath", "ptr", pszPath, "ptr", ppidl, "uint*", rgfInOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Appends or prepends an SHITEMID structure to an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PIDLIST_RELATIVE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure. When the function returns, the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure specified by <i>pmkid</i> is appended or prepended.
     * @param {Pointer<SHITEMID>} pmkid Type: <b>LPSHITEMID</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure to be appended or prepended to <i>pidl</i>.
     * @param {Integer} fAppend Type: <b>BOOL</b>
     * 
     * Value that is set to <b>TRUE</b> to append <i>pmkid</i> to <i>pidl</i>. Set this value to <b>FALSE</b> to prepend <i>pmkid</i> to <i>pidl</i>.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_RELATIVE</b>
     * 
     * Returns the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure specified by <i>pidl</i>, with <i>pmkid</i> appended or prepended. Returns <b>NULL</b> on failure.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-ilappendid
     * @since windows5.1.2600
     */
    static ILAppendID(pidl, pmkid, fAppend) {
        result := DllCall("SHELL32.dll\ILAppendID", "ptr", pidl, "ptr", pmkid, "int", fAppend, "ptr")
        return result
    }

    /**
     * Converts an item identifier list to a file system path. This function extends SHGetPathFromIDList by allowing you to set the initial size of the string buffer and declare the options below.
     * @remarks
     * Except for UNC printer names, if the location specified by the <i>pidl</i> parameter is not part of the file system, this function fails.
     * 
     * If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> contains the path to the shortcut, not to the shortcut's target.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).
     * @param {Pointer<Char>} pszPath Type: <b>PWSTR</b>
     * 
     * When this function is called it is passed a null-terminated, Unicode buffer to receive the file system path. This buffer is of size <i>cchPath</i>. 
     *                         
     *                         
     * 
     * When this function returns, contains the address of a null-terminated, Unicode buffer that contains the file system path. This buffer is of size <i>cchPath</i>.
     * @param {Integer} cchPath Type: <b>DWORD</b>
     * 
     * The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Integer} uOpts Type: <b>GPFIDL_FLAGS</b>
     * 
     * These flags determine the type of path returned.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetpathfromidlistex
     * @since windows6.0.6000
     */
    static SHGetPathFromIDListEx(pidl, pszPath, cchPath, uOpts) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetPathFromIDListEx", "ptr", pidl, "ptr", pszPath, "uint", cchPath, "uint", uOpts, "int")
        return result
    }

    /**
     * Converts an item identifier list to a file system path. (ANSI)
     * @remarks
     * If the location specified by the <i>pidl</i> parameter is not part of the file system, this function will fail.
     * 
     * If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> will contain the path to the shortcut, not to the shortcut's target.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetPathFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetpathfromidlista
     * @since windows5.1.2600
     */
    static SHGetPathFromIDListA(pidl, pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetPathFromIDListA", "ptr", pidl, "ptr", pszPath, "int")
        return result
    }

    /**
     * Converts an item identifier list to a file system path. (Unicode)
     * @remarks
     * If the location specified by the <i>pidl</i> parameter is not part of the file system, this function will fail.
     * 
     * If the <i>pidl</i> parameter specifies a shortcut, the <i>pszPath</i> will contain the path to the shortcut, not to the shortcut's target.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetPathFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetpathfromidlistw
     * @since windows5.1.2600
     */
    static SHGetPathFromIDListW(pidl, pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetPathFromIDListW", "ptr", pidl, "ptr", pszPath, "int")
        return result
    }

    /**
     * Creates a new file system folder.
     * @remarks
     * This function creates a file system folder whose fully qualified path is given by <i>pszPath</i>. If one or more of the intermediate folders do not exist, it creates them.
     * 
     * To set security attributes on a new folder, use <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedirectoryexa">SHCreateDirectoryEx</a>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface is displayed.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that contains the fully qualified path of the directory. This string should have no more than MAX_PATH characters, including the terminating null character.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be returned, including those listed here. For values not specifically listed, see <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_PATHNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszPath</i> parameter was set to a relative path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path pointed to by <i>pszPath</i> is too long.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user canceled the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreatedirectory
     * @since windows5.1.2600
     */
    static SHCreateDirectory(hwnd, pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHCreateDirectory", "ptr", hwnd, "ptr", pszPath, "int")
        return result
    }

    /**
     * Creates a new file system folder, with optional security attributes. (ANSI)
     * @remarks
     * This function creates a file system folder whose fully qualified path is given by <i>pszPath</i>. If one or more of the intermediate folders do not exist, they are created as well. <b>SHCreateDirectoryEx</b> also verifies that the files are visible. If they are not visible, expect one of the following:
     * 
     * 				
     * 
     * <ul>
     * <li>If <i>hwnd</i> is set to a valid window handle, a message box is displayed warning the user that he or she might not be able to access the files. If the user chooses not to proceed, the function returns <b>ERROR_CANCELLED</b>.</li>
     * <li>If <i>hwnd</i> is set to <b>NULL</b>, no user interface is displayed and the function returns <b>ERROR_CANCELLED</b>.</li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHCreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface will be displayed.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string specifying the fully qualified path of the directory. This string is of maximum length of 248 characters, including the terminating null character.
     * @param {Pointer<SECURITY_ATTRIBUTES>} psa Type: <b>const <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>*</b>
     * 
     *  A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure with the directory's security attribute. Set this parameter to <b>NULL</b> if no security attributes need to be set.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be returned, including those listed here. For values not specifically listed, see <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_PATHNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszPath</i> parameter was set to a relative path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path pointed to by <i>pszPath</i> is too long.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system cannot find the path pointed to by <i>pszPath</i>. The path may contain an invalid entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user canceled the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreatedirectoryexa
     * @since windows5.0
     */
    static SHCreateDirectoryExA(hwnd, pszPath, psa) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHCreateDirectoryExA", "ptr", hwnd, "ptr", pszPath, "ptr", psa, "int")
        return result
    }

    /**
     * Creates a new file system folder, with optional security attributes. (Unicode)
     * @remarks
     * This function creates a file system folder whose fully qualified path is given by <i>pszPath</i>. If one or more of the intermediate folders do not exist, they are created as well. <b>SHCreateDirectoryEx</b> also verifies that the files are visible. If they are not visible, expect one of the following:
     * 
     * 				
     * 
     * <ul>
     * <li>If <i>hwnd</i> is set to a valid window handle, a message box is displayed warning the user that he or she might not be able to access the files. If the user chooses not to proceed, the function returns <b>ERROR_CANCELLED</b>.</li>
     * <li>If <i>hwnd</i> is set to <b>NULL</b>, no user interface is displayed and the function returns <b>ERROR_CANCELLED</b>.</li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHCreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface will be displayed.
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string specifying the fully qualified path of the directory. This string is of maximum length of 248 characters, including the terminating null character.
     * @param {Pointer<SECURITY_ATTRIBUTES>} psa Type: <b>const <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>*</b>
     * 
     *  A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure with the directory's security attribute. Set this parameter to <b>NULL</b> if no security attributes need to be set.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be returned, including those listed here. For values not specifically listed, see <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_PATHNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszPath</i> parameter was set to a relative path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path pointed to by <i>pszPath</i> is too long.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system cannot find the path pointed to by <i>pszPath</i>. The path may contain an invalid entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user canceled the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreatedirectoryexw
     * @since windows5.0
     */
    static SHCreateDirectoryExW(hwnd, pszPath, psa) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHCreateDirectoryExW", "ptr", hwnd, "ptr", pszPath, "ptr", psa, "int")
        return result
    }

    /**
     * Opens a Windows Explorer window with specified items in a particular folder selected.
     * @remarks
     * <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a> must be called before using <b>SHOpenFolderAndSelectItems</b>. Not doing so causes <b>SHOpenFolderAndSelectItems</b> to fail.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to a fully qualified item ID list that specifies the folder.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * A count of items in the selection array, <i>apidl</i>. If <i>cidl</i> is zero, then <i>pidlFolder</i> must point to a fully specified <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> describing a single item to select. This function opens the parent folder and selects that item.
     * @param {Pointer<ITEMIDLIST>} apidl Type: <b>PCUITEMID_CHILD_ARRAY</b>
     * 
     * A pointer to an array of PIDL structures, each of which is an item to select in the target folder referenced by <i>pidlFolder</i>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The optional flags. Under WindowsXP this parameter is ignored. In WindowsVista, the following flags are defined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shopenfolderandselectitems
     * @since windows5.1.2600
     */
    static SHOpenFolderAndSelectItems(pidlFolder, cidl, apidl, dwFlags) {
        result := DllCall("SHELL32.dll\SHOpenFolderAndSelectItems", "ptr", pidlFolder, "uint", cidl, "ptr", apidl, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates an IShellItem object.
     * @remarks
     * <b>SHCreateShellItem</b> creates an object that represents a Shell namespace item. The caller must provide parent information in <i>pidlParent</i> or <i>psfParent</i>; alternatively, the caller can provide an absolute IDList in the <i>pidl</i> parameter.
     * 
     * There are three valid calling patterns for this function:
     * 
     *                 
     * 
     * <ol>
     * <li>The parent folder is identified by an absolute IDList <i>pidlParent</i>. The <i>pidl</i> parameter points to a child IDList that identifies the item within the folder identified by <i>pidlParent</i>.
     * 
     *                         
     * 
     * 
     * ```cpp
     * IShellItem *psi;
     * SHCreateShellItem(pidlParent, NULL, pidlChild, &psi);
     * 
     * ```
     * 
     * 
     * </li>
     * <li>The parent folder is identified by <i>psfParent</i>. The <i>pidl</i> parameter points to a child IDList that identifies the item within the folder identified by <i>psfParent</i>.
     * 
     *                         
     * 
     * 
     * ```cpp
     * IShellItem *psi;
     * SHCreateShellItem(NULL, psfParent, pidlChild, &psi);
     * 
     * ```
     * 
     * 
     * </li>
     * <li>The item is identified by an absolute IDList passed to the <i>pidl</i> parameter.
     * 
     *                         
     * 
     * 
     * ```cpp
     * IShellItem *psi;
     * SHCreateShellItem(NULL, NULL, pidlFull, &psi);
     * 
     * ```
     * 
     * 
     * </li>
     * </ol>
     * @param {Pointer<ITEMIDLIST>} pidlParent Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A PIDL to the parent. This value can be <b>NULL</b>.
     * @param {Pointer<IShellFolder>} psfParent Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to the parent <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>. This value can be <b>NULL</b>.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A PIDL to the requested item. If parent information is not included in <i>pidlParent</i> or <i>psfParent</i>, this must be an absolute PIDL.
     * @param {Pointer<IShellItem>} ppsi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>**</b>
     * 
     * When this method returns, contains the interface pointer to the new <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreateshellitem
     * @since windows5.1.2600
     */
    static SHCreateShellItem(pidlParent, psfParent, pidl, ppsi) {
        result := DllCall("SHELL32.dll\SHCreateShellItem", "ptr", pidlParent, "ptr", psfParent, "ptr", pidl, "ptr", ppsi, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHGetSpecialFolderLocation is not supported and may be altered or unavailable in the future. Instead, use SHGetFolderLocation.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder of interest.
     * @param {Pointer<ITEMIDLIST>} ppidl Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * A PIDL specifying the folder's location relative to the root of the namespace (the desktop). It is the responsibility of the calling application to free the returned IDList by using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetspecialfolderlocation
     * @since windows5.0
     */
    static SHGetSpecialFolderLocation(csidl, ppidl) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        result := DllCall("SHELL32.dll\SHGetSpecialFolderLocation", "ptr", hwnd, "int", csidl, "ptr", ppidl, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHCloneSpecialIDList may be altered or unavailable. Instead, use SHGetSpecialFolderLocation.
     * @remarks
     * When finished, you should free the pointer to the cloned folder with <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a>.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder of interest.
     * @param {Integer} fCreate Type: <b>BOOL</b>
     * 
     * A value of type <b>BOOL</b> that indicates if the folder should be created if it does not already exist. If  <i>fCreate</i> is <b>TRUE</b>, the folder is created. If it is <b>FALSE</b>, the folder is not created.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure of a special folder specified by <i>csidl</i>. The function creates the folder if <i>fCreate</i> is <b>TRUE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shclonespecialidlist
     * @since windows5.1.2600
     */
    static SHCloneSpecialIDList(csidl, fCreate) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        result := DllCall("SHELL32.dll\SHCloneSpecialIDList", "ptr", hwnd, "int", csidl, "int", fCreate, "ptr")
        return result
    }

    /**
     * SHGetSpecialFolderPath is not supported. Instead, use ShGetFolderPath. (ANSI)
     * @remarks
     * The Microsoft Internet Explorer4.0 Desktop Update must be installed for this function to be available.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetSpecialFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that receives the drive and path of the specified folder. This buffer must be at least MAX_PATH characters in size.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> that identifies the folder of interest. If a virtual folder is specified, this function will fail.
     * @param {Integer} fCreate Type: <b>BOOL</b>
     * 
     * Indicates whether the folder should be created if it does not already exist. If this value is nonzero, the folder is created. If this value is zero, the folder is not created.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetspecialfolderpatha
     * @since windows5.0
     */
    static SHGetSpecialFolderPathA(pszPath, csidl, fCreate) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetSpecialFolderPathA", "ptr", hwnd, "ptr", pszPath, "int", csidl, "int", fCreate, "int")
        return result
    }

    /**
     * SHGetSpecialFolderPath is not supported. Instead, use ShGetFolderPath. (Unicode)
     * @remarks
     * The Microsoft Internet Explorer4.0 Desktop Update must be installed for this function to be available.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetSpecialFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that receives the drive and path of the specified folder. This buffer must be at least MAX_PATH characters in size.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> that identifies the folder of interest. If a virtual folder is specified, this function will fail.
     * @param {Integer} fCreate Type: <b>BOOL</b>
     * 
     * Indicates whether the folder should be created if it does not already exist. If this value is nonzero, the folder is created. If this value is zero, the folder is not created.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetspecialfolderpathw
     * @since windows5.0
     */
    static SHGetSpecialFolderPathW(pszPath, csidl, fCreate) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetSpecialFolderPathW", "ptr", hwnd, "ptr", pszPath, "int", csidl, "int", fCreate, "int")
        return result
    }

    /**
     * SHFlushSFCache may be altered or unavailable.
     * @remarks
     * <b>SHFlushSFCache</b> is called when the path to a special 
     *     folder is changed. This ensures that the updated path stored in the registry is used rather than the cached 
     *     value.
     * 
     * For more information on special folders, see the <i>Special Folders and CSIDLs</i> section 
     *     of <a href="https://docs.microsoft.com/windows/desktop/shell/folder-id">Getting a Folder's ID</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shflushsfcache
     * @since windows5.1.2600
     */
    static SHFlushSFCache() {
        DllCall("SHELL32.dll\SHFlushSFCache")
    }

    /**
     * Deprecated. (SHGetFolderPathA)
     * @remarks
     * This function is a superset of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetspecialfolderpatha">SHGetSpecialFolderPath</a>.
     * 
     * Only some <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> values are supported, including the following:
     * 
     * 				
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_ADMINTOOLS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_APPDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_COMMON_ADMINTOOLS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_COMMON_APPDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_COMMON_DOCUMENTS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_COOKIES</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_CREATE</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_VERIFY</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_HISTORY</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_INTERNET_CACHE</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_LOCAL_APPDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_PERSONAL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES_COMMON</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_SYSTEM</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_WINDOWS</a>
     * </li>
     * </ul>
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. 
     *     
     *                         
     * 
     * <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.
     * 
     * <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator. 
     *     
     *                         
     * 
     * The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-redirect">IKnownFolderManager::Redirect</a>, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.
     * 
     * The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.
     * 
     * For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users&#92;<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\\".
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderpatha
     * @since windows5.0
     */
    static SHGetFolderPathA(csidl, hToken, dwFlags, pszPath) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFolderPathA", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Deprecated. (SHGetFolderPathW)
     * @remarks
     * This function is a superset of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetspecialfolderpatha">SHGetSpecialFolderPath</a>.
     * 
     * Only some <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> values are supported, including the following:
     * 
     * 				
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_ADMINTOOLS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_APPDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_COMMON_ADMINTOOLS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_COMMON_APPDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_COMMON_DOCUMENTS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_COOKIES</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_CREATE</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_VERIFY</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_HISTORY</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_INTERNET_CACHE</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_LOCAL_APPDATA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_PERSONAL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_PROGRAM_FILES_COMMON</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_SYSTEM</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_WINDOWS</a>
     * </li>
     * </ul>
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. 
     *     
     *                         
     * 
     * <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.
     * 
     * <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator. 
     *     
     *                         
     * 
     * The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-redirect">IKnownFolderManager::Redirect</a>, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.
     * 
     * The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.
     * 
     * For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users&#92;<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.
     * @param {Pointer<Char>} pszPath Type: <b>LPWSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\\".
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderpathw
     * @since windows5.0
     */
    static SHGetFolderPathW(csidl, hToken, dwFlags, pszPath) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFolderPathW", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Deprecated. Retrieves the path of a folder as an ITEMIDLIST structure.
     * @remarks
     * <div class="alert"><b>Note</b>As of WindowsVista, this function is merely a wrapper for <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderidlist">SHGetKnownFolderIDList</a>. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHGetKnownFolderIDList</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</div>
     * <div></div>
     * The <b>SHGetFolderLocation</b>, <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a>, <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetspecialfolderlocation">SHGetSpecialFolderLocation</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetspecialfolderpatha">SHGetSpecialFolderPath</a> functions are the preferred ways to obtain handles to folders on systems earlier than WindowsVista. Functions such as <a href="https://docs.microsoft.com/windows/desktop/api/rrascfg/nn-rrascfg-ieapproviderconfig">ExpandEnvironmentStrings</a> that use the environment variable names directly, in the form %VariableName%, may not be reliable.
     * 
     * This function is a superset of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetspecialfolderlocation">SHGetSpecialFolderLocation</a>, included with earlier versions of the Shell.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder to be located. The folders associated with the CSIDLs might not exist on a particular system.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. It is usually set to <b>NULL</b>, but it may be needed when there are multiple users for those folders that are treated as belonging to a single user. The most commonly used folder of this type is <b>My Documents</b>. The calling application is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. It must have appropriate security privileges for the particular user, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     *     
     *     					
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetFolderLocation</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>My Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @param {Pointer<ITEMIDLIST>} ppidl Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * The address of a pointer to an item identifier list structure that specifies the folder's location relative to the root of the namespace (the desktop). The <i>ppidl</i> parameter is set to <b>NULL</b> on failure. The calling application is responsible for freeing this resource by calling <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> in <i>nFolder</i> is valid but the folder does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> in <i>nFolder</i> is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderlocation
     * @since windows5.0
     */
    static SHGetFolderLocation(csidl, hToken, dwFlags, ppidl) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        result := DllCall("SHELL32.dll\SHGetFolderLocation", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", ppidl, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Deprecated. Assigns a new path to a system folder identified by its CSIDL. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b>As of WindowsVista, this function is merely a wrapper for <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shsetknownfolderpath">SHSetKnownFolderPath</a>. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHSetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</div>
     * <div></div>
     * <b>SHSetFolderPath</b> is not exported by name from Shell32.dll. To use the function, you must call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> with ordinal 231 for <b>SHSetFolderPathA</b> (for ANSI strings) or ordinal 232 for <b>SHSetFolderPathW</b> (for Unicode strings) to obtain a function pointer.
     * 
     * It is recommended that the paths be expressed as Unicode strings because folder names might contain Unicode characters not expressible in ANSI.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHSetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.
     * 
     * Add the <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Must be set to 0.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns standard <b>HRESULT</b> codes, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The folder's path was successfully updated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Several error conditions cause the return of this value, including the following:
     * 
     * <ul>
     * <li>The <i>csidl</i> value is not valid.</li>
     * <li>The <i>csidl</i> value does not refer to a virtual folder.</li>
     * <li>The <i>csidl</i> value does not refer to a system folder.</li>
     * <li>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</li>
     * <li>The <i>dwFlags</i> value is not 0 (zero).</li>
     * <li>The <i>pszPath</i> value is <b>NULL</b>.</li>
     * <li>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</li>
     * </ul>
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shsetfolderpatha
     * @since windows5.1.2600
     */
    static SHSetFolderPathA(csidl, hToken, dwFlags, pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHSetFolderPathA", "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Deprecated. Assigns a new path to a system folder identified by its CSIDL. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b>As of WindowsVista, this function is merely a wrapper for <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shsetknownfolderpath">SHSetKnownFolderPath</a>. The CSIDL value is translated to its associated <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> and <b>SHSetKnownFolderPath</b> is called. New applications should use the known folder system rather than the older CSIDL system, which is supported only for backward compatibility.</div>
     * <div></div>
     * <b>SHSetFolderPath</b> is not exported by name from Shell32.dll. To use the function, you must call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> with ordinal 231 for <b>SHSetFolderPathA</b> (for ANSI strings) or ordinal 232 for <b>SHSetFolderPathW</b> (for Unicode strings) to obtain a function pointer.
     * 
     * It is recommended that the paths be expressed as Unicode strings because folder names might contain Unicode characters not expressible in ANSI.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHSetFolderPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.
     * 
     * Add the <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Must be set to 0.
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns standard <b>HRESULT</b> codes, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The folder's path was successfully updated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Several error conditions cause the return of this value, including the following:
     * 
     * <ul>
     * <li>The <i>csidl</i> value is not valid.</li>
     * <li>The <i>csidl</i> value does not refer to a virtual folder.</li>
     * <li>The <i>csidl</i> value does not refer to a system folder.</li>
     * <li>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</li>
     * <li>The <i>dwFlags</i> value is not 0 (zero).</li>
     * <li>The <i>pszPath</i> value is <b>NULL</b>.</li>
     * <li>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</li>
     * </ul>
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shsetfolderpathw
     * @since windows5.1.2600
     */
    static SHSetFolderPathW(csidl, hToken, dwFlags, pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHSetFolderPathW", "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Gets the path of a folder and appends a user-provided subfolder path. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetFolderPathAndSubDir as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com/windows/desktop/shell/manage">My Documents</a>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.
     * @param {Pointer<Byte>} pszSubDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderpathandsubdira
     * @since windows5.1.2600
     */
    static SHGetFolderPathAndSubDirA(csidl, hToken, dwFlags, pszSubDir, pszPath) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        pszSubDir := pszSubDir is String? StrPtr(pszSubDir) : pszSubDir
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFolderPathAndSubDirA", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszSubDir, "ptr", pszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Gets the path of a folder and appends a user-provided subfolder path. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetFolderPathAndSubDir as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com/windows/desktop/shell/manage">My Documents</a>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.
     * @param {Pointer<Char>} pszSubDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderpathandsubdirw
     * @since windows5.1.2600
     */
    static SHGetFolderPathAndSubDirW(csidl, hToken, dwFlags, pszSubDir, pszPath) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        pszSubDir := pszSubDir is String? StrPtr(pszSubDir) : pszSubDir
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFolderPathAndSubDirW", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszSubDir, "ptr", pszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the path of a known folder as an ITEMIDLIST structure.
     * @remarks
     * This function replaces <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderlocation">SHGetFolderLocation</a>. That older function is now simply a wrapper for <b>SHGetKnownFolderIDList</b>.
     * 
     * Callers using this function must have at least User privileges.
     * 
     * Some known folders, for example, the <b>Documents</b> folder, are per-user. Each user has a different path for the <b>Documents</b> folder. If <i>hToken</i> is <b>NULL</b>, the API tries to access the current user's instance of the folder. If <i>hToken</i> is a valid user token, the API tries to impersonate the user using this token, and attempts to access that user's instance of the folder.
     * @param {Pointer<Guid>} rfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A reference to the <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that identifies the folder. The folders associated with the known folder IDs might not exist on a particular system.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify special retrieval options. This value can be 0; otherwise, it is one or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a> values.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetKnownFolderIDList</b> to find folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.
     * @param {Pointer<ITEMIDLIST>} ppidl Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * When this method returns, contains a pointer to the PIDL of the folder. This parameter is passed uninitialized. The caller is responsible for freeing the returned PIDL when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-getfolderids">IKnownFolderManager::GetFolderIds</a> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderidlist
     * @since windows6.0.6000
     */
    static SHGetKnownFolderIDList(rfid, dwFlags, hToken, ppidl) {
        result := DllCall("SHELL32.dll\SHGetKnownFolderIDList", "ptr", rfid, "uint", dwFlags, "ptr", hToken, "ptr", ppidl, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Redirects a known folder to a new location.
     * @remarks
     * This function replaces <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shsetfolderpatha">SHSetFolderPath</a>. That older function is now simply a wrapper for <b>SHSetKnownFolderPath</b>.
     * 
     * The caller of this function must have Administrator privileges. To call this function on public known folders, the caller must have Administrator privileges. For per-user known folders the caller only requires User privileges.
     * 
     * Some of the known folders, for example, the <b>Documents</b> folder, are per-user. Every user has a different path for their <b>Documents</b> folder. If <i>hToken</i> is <b>NULL</b>, the API tries to access the calling application's instance of the folder, which is that of the current user. If <i>hToken</i> is a valid user token, the API tries to impersonate the user using this token and tries to access that user's instance.
     * 
     * This function cannot be called on folders of type <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-kf_category">KF_CATEGORY_FIXED</a> and <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-kf_category">KF_CATEGORY_VIRTUAL</a>.
     * 
     * To call this function on a folder of type <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-kf_category">KF_CATEGORY_COMMON</a>, the calling application must be running with elevated privileges.
     * @param {Pointer<Guid>} rfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A <b>GUID</b> that identifies the known folder.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Either 0 or the following value.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 			
     *             		
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHSetKnownFolderPath</b> to set folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to the folder's new path. This is a null-terminated Unicode string of length MAX_PATH. This path cannot be of zero length.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-getfolderids">IKnownFolderManager::GetFolderIds</a> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shsetknownfolderpath
     * @since windows6.0.6000
     */
    static SHSetKnownFolderPath(rfid, dwFlags, hToken, pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHSetKnownFolderPath", "ptr", rfid, "uint", dwFlags, "ptr", hToken, "ptr", pszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the full path of a known folder identified by the folder's KNOWNFOLDERID.
     * @remarks
     * This function replaces <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPath</a>. That older function is now simply a wrapper for <b>SHGetKnownFolderPath</b>.
     * @param {Pointer<Guid>} rfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A reference to the <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that identifies the folder.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify special retrieval options. This value can be 0; otherwise, one or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a> values.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. If this parameter is <b>NULL</b>, which is the most common usage, the function requests the known folder for the current user. 
     *     
     *                         
     * 
     * Request a specific user's folder by passing the <i>hToken</i> of that user. This is typically done in the context of a service that has sufficient privileges to retrieve the token of a given user. That token must be opened with <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_QUERY</a> and <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_IMPERSONATE</a> rights. In some cases, you also need to include <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_DUPLICATE</a>. In addition to passing the user's <i>hToken</i>, the registry hive of that specific user must be mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetKnownFolderPath</b> to find folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.
     * @param {Pointer<Char>} ppszPath Type: <b>PWSTR*</b>
     * 
     * When this method returns, contains the address of a pointer to a null-terminated Unicode string that specifies the path of the known folder. The calling process is responsible for freeing this resource once it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>, whether <b>SHGetKnownFolderPath</b> succeeds or not. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\\".
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> which does not have a path (such as a folder marked as <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-kf_category">KF_CATEGORY_VIRTUAL</a>).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-getfolderids">IKnownFolderManager::GetFolderIds</a> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath
     * @since windows6.0.6000
     */
    static SHGetKnownFolderPath(rfid, dwFlags, hToken, ppszPath) {
        result := DllCall("SHELL32.dll\SHGetKnownFolderPath", "ptr", rfid, "uint", dwFlags, "ptr", hToken, "ptr", ppszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves an IShellItem object that represents a known folder.
     * @remarks
     * The caller of this function must have Administrator privileges. To call this function on public known folders, the caller must have Administrator privileges. For per-user known folders the caller only requires User privileges.
     * 
     * Some of the known folders, for example, the <b>Documents</b> folder, are per-user. Every user has a different path for their <b>Documents</b> folder. If <i>hToken</i> is <b>NULL</b>, the API tries to access the calling application's instance of the folder, which is that of the current user. If <i>hToken</i> is a valid user token, the API tries to impersonate the user using this token and tries to access that user's instance.
     * 
     * This function cannot be called on folders of type <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-kf_category">KF_CATEGORY_FIXED</a> and <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-kf_category">KF_CATEGORY_VIRTUAL</a>.
     * 
     * To call this function on a folder of type <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-kf_category">KF_CATEGORY_COMMON</a>, the calling application must be running with elevated privileges.
     * @param {Pointer<Guid>} rfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A reference to the <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a>, a <b>GUID</b> that identifies the folder that contains the item.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a></b>
     * 
     * Flags that specify special options used in the retrieval of the known folder <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>. This value can be <b>KF_FLAG_DEFAULT</b>; otherwise, one or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a> values.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * 
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-<b>null</b>. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shsetknownfolderpath">SHSetKnownFolderPath</a> to set folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface that represents the item, usually IID_IShellItem or IID_IShellItem2.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-getfolderids">IKnownFolderManager::GetFolderIds</a> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderitem
     * @since windows6.1
     */
    static SHGetKnownFolderItem(rfid, flags, hToken, riid, ppv) {
        result := DllCall("SHELL32.dll\SHGetKnownFolderItem", "ptr", rfid, "int", flags, "ptr", hToken, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHGetSetFolderCustomSettings may be altered or unavailable.
     * @remarks
     * Only Unicode strings are supported.
     * 
     * <b>Windows Server2003 and WindowsXP:</b><b>SHGetSetFolderCustomSettings</b> supports both ANSI and Unicode strings.
     * @param {Pointer<SHFOLDERCUSTOMSETTINGS>} pfcs Type: <b>LPSHFOLDERCUSTOMSETTINGS</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shfoldercustomsettings">SHFOLDERCUSTOMSETTINGS</a> structure that provides or receives the custom folder settings.
     * @param {Pointer<Char>} pszPath Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that contains the path to the folder. The length of  <b>pszPath</b> must be MAX_PATH or less, including the terminating null character.
     * @param {Integer} dwReadWrite Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetsetfoldercustomsettings
     * @since windows5.1.2600
     */
    static SHGetSetFolderCustomSettings(pfcs, pszPath, dwReadWrite) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetSetFolderCustomSettings", "ptr", pfcs, "ptr", pszPath, "uint", dwReadWrite, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Displays a dialog box that enables the user to select a Shell folder. (ANSI)
     * @remarks
     * For WindowsVista or later, it is recommended that you use <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifiledialog">IFileDialog</a> with the FOS_PICKFOLDERS option rather than the SHBrowseForFolder function. This uses the Open Files dialog in pick folders mode and is the preferred implementation.
     * 
     * You must initialize Component Object Model (COM) before you call <b>SHBrowseForFolder</b>. If you initialize COM using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a>, you must set the COINIT_APARTMENTTHREADED flag in its <i>dwCoInit</i> parameter. You can also use <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a>, which always use apartment threading. If you require drag-and-drop functionality, <b>OleInitialize</b> is recommended because it initializes the required OLE as well as COM.
     * 
     * <div class="alert"><b>Note</b>If COM is initialized using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a> with the COINIT_MULTITHREADED flag, <b>SHBrowseForFolder</b> fails if the calling application uses the BIF_USENEWUI or BIF_NEWDIALOGSTYLE flag in the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure.</div>
     * <div></div>
     * It is the responsibility of the calling application to call <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> to free the IDList returned by <b>SHBrowseForFolder</b> when it is no longer needed.
     * 
     * There are two styles of dialog box available. The older style is displayed by default and is not resizable. The newer style provides a number of additional features, including drag-and-drop capability within the dialog box, reordering, deletion, shortcut menus, the ability to create new folders, and other shortcut menu commands. Initially, it is larger than the older dialog box, but the user can resize it. To specify a dialog box using the newer style, set the <b>BIF_USENEWUI</b> flag in the <b>ulFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure.
     * 
     * If you implement a callback function, specified in the <b>lpfn</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure, you receive a handle to the dialog box. One use of this window handle is to modify the layout or contents of the dialog box. Because it is not resizable, modifying the older style dialog box is relatively straightforward. Modifying the newer style dialog box is much more difficult, and not recommended. Not only does it have a different size and layout than the old style, but its dimensions and the positions of its controls change every time it is resized by the user.
     * 
     * If the BIF_RETURNONLYFSDIRS flag is set in the <b>ulFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure, the <b>OK</b> button remains enabled for "\\server" items, as well as "\\server\share" and directory items. However, if the user selects a "\\server" item, passing the PIDL returned by <b>SHBrowseForFolder</b> to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetpathfromidlista">SHGetPathFromIDList</a> fails.
     * 
     * <h3><a id="Custom_Filtering"></a><a id="custom_filtering"></a><a id="CUSTOM_FILTERING"></a>Custom Filtering</h3>
     * As of WindowsXP, <b>SHBrowseForFolder</b> supports custom filtering on the contents of the dialog box. To create a custom filter, follow these steps.
     * 
     * 				
     * 
     * <ol>
     * <li>Set the BIF_NEWDIALOGSTYLE flag in the <b>ulFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure pointed to by the <i>lpbi</i> parameter.</li>
     * <li>Specify a callback function in the <b>lpfn</b> member of that same <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure.</li>
     * <li>Code the callback function to receive the BFFM_INITIALIZED and BFFM_IUNKNOWN messages. On receipt of the BFFM_IUNKNOWN message, the callback function's <i>lParam</i> parameter contains a pointer to the dialog box's implementation of <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>. Call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">QueryInterface</a> on that <b>IUnknown</b> to obtain a pointer to an instance of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifolderfiltersite">IFolderFilterSite</a>.</li>
     * <li>Create an object that implements <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifolderfilter">IFolderFilter</a>.</li>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ifolderfiltersite-setfilter">IFolderFilterSite::SetFilter</a>, passing to it a pointer to your <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifolderfilter">IFolderFilter</a>. <b>IFolderFilter</b> methods can then be used to include and exclude items from the tree.</li>
     * <li>Once the filter is created, the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifolderfiltersite">IFolderFilterSite</a> interface is no longer needed. Call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IFolderFilterSite::Release</a> if you have no further use for it.</li>
     * </ol>
     * <h3><a id="Dealing_With_Shortcuts"></a><a id="dealing_with_shortcuts"></a><a id="DEALING_WITH_SHORTCUTS"></a>Dealing With Shortcuts</h3>
     * <div class="alert"><b>Note</b>This section applies to only Windows2000 and earlier systems. By default, WindowsXP and later systems return the PIDL of a shortcut's target rather than the shortcut itself, as long as the BIF_NOTRANSLATETARGETS flag is not set in the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure.</div>
     * <div></div>
     * If <b>SHBrowseForFolder</b> returns a PIDL to a shortcut, sending that PIDL to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetpathfromidlista">SHGetPathFromIDList</a> returns the path of the shortcut itself rather than the path of its target. The path to the shortcut's target can be obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishelllinka">IShellLink</a> interface as shown in this example.
     * 
     * 
     * ```
     * @param {Pointer<BROWSEINFOA>} lpbi Type: <b>LPBROWSEINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure that contains information used to display the dialog box.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.
     *     
     *     					
     * 
     * It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shbrowseforfoldera
     * @since windows5.1.2600
     */
    static SHBrowseForFolderA(lpbi) {
        result := DllCall("SHELL32.dll\SHBrowseForFolderA", "ptr", lpbi, "ptr")
        return result
    }

    /**
     * Displays a dialog box that enables the user to select a Shell folder. (Unicode)
     * @remarks
     * For WindowsVista or later, it is recommended that you use <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifiledialog">IFileDialog</a> with the FOS_PICKFOLDERS option rather than the SHBrowseForFolder function. This uses the Open Files dialog in pick folders mode and is the preferred implementation.
     * 
     * You must initialize Component Object Model (COM) before you call <b>SHBrowseForFolder</b>. If you initialize COM using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a>, you must set the COINIT_APARTMENTTHREADED flag in its <i>dwCoInit</i> parameter. You can also use <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a>, which always use apartment threading. If you require drag-and-drop functionality, <b>OleInitialize</b> is recommended because it initializes the required OLE as well as COM.
     * 
     * <div class="alert"><b>Note</b>If COM is initialized using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex">CoInitializeEx</a> with the COINIT_MULTITHREADED flag, <b>SHBrowseForFolder</b> fails if the calling application uses the BIF_USENEWUI or BIF_NEWDIALOGSTYLE flag in the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure.</div>
     * <div></div>
     * It is the responsibility of the calling application to call <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> to free the IDList returned by <b>SHBrowseForFolder</b> when it is no longer needed.
     * 
     * There are two styles of dialog box available. The older style is displayed by default and is not resizable. The newer style provides a number of additional features, including drag-and-drop capability within the dialog box, reordering, deletion, shortcut menus, the ability to create new folders, and other shortcut menu commands. Initially, it is larger than the older dialog box, but the user can resize it. To specify a dialog box using the newer style, set the <b>BIF_USENEWUI</b> flag in the <b>ulFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure.
     * 
     * If you implement a callback function, specified in the <b>lpfn</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure, you receive a handle to the dialog box. One use of this window handle is to modify the layout or contents of the dialog box. Because it is not resizable, modifying the older style dialog box is relatively straightforward. Modifying the newer style dialog box is much more difficult, and not recommended. Not only does it have a different size and layout than the old style, but its dimensions and the positions of its controls change every time it is resized by the user.
     * 
     * If the BIF_RETURNONLYFSDIRS flag is set in the <b>ulFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure, the <b>OK</b> button remains enabled for "\\server" items, as well as "\\server\share" and directory items. However, if the user selects a "\\server" item, passing the PIDL returned by <b>SHBrowseForFolder</b> to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetpathfromidlista">SHGetPathFromIDList</a> fails.
     * 
     * <h3><a id="Custom_Filtering"></a><a id="custom_filtering"></a><a id="CUSTOM_FILTERING"></a>Custom Filtering</h3>
     * As of WindowsXP, <b>SHBrowseForFolder</b> supports custom filtering on the contents of the dialog box. To create a custom filter, follow these steps.
     * 
     * 				
     * 
     * <ol>
     * <li>Set the BIF_NEWDIALOGSTYLE flag in the <b>ulFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure pointed to by the <i>lpbi</i> parameter.</li>
     * <li>Specify a callback function in the <b>lpfn</b> member of that same <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure.</li>
     * <li>Code the callback function to receive the BFFM_INITIALIZED and BFFM_IUNKNOWN messages. On receipt of the BFFM_IUNKNOWN message, the callback function's <i>lParam</i> parameter contains a pointer to the dialog box's implementation of <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>. Call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">QueryInterface</a> on that <b>IUnknown</b> to obtain a pointer to an instance of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifolderfiltersite">IFolderFilterSite</a>.</li>
     * <li>Create an object that implements <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifolderfilter">IFolderFilter</a>.</li>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ifolderfiltersite-setfilter">IFolderFilterSite::SetFilter</a>, passing to it a pointer to your <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifolderfilter">IFolderFilter</a>. <b>IFolderFilter</b> methods can then be used to include and exclude items from the tree.</li>
     * <li>Once the filter is created, the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifolderfiltersite">IFolderFilterSite</a> interface is no longer needed. Call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IFolderFilterSite::Release</a> if you have no further use for it.</li>
     * </ol>
     * <h3><a id="Dealing_With_Shortcuts"></a><a id="dealing_with_shortcuts"></a><a id="DEALING_WITH_SHORTCUTS"></a>Dealing With Shortcuts</h3>
     * <div class="alert"><b>Note</b>This section applies to only Windows2000 and earlier systems. By default, WindowsXP and later systems return the PIDL of a shortcut's target rather than the shortcut itself, as long as the BIF_NOTRANSLATETARGETS flag is not set in the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure.</div>
     * <div></div>
     * If <b>SHBrowseForFolder</b> returns a PIDL to a shortcut, sending that PIDL to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetpathfromidlista">SHGetPathFromIDList</a> returns the path of the shortcut itself rather than the path of its target. The path to the shortcut's target can be obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishelllinka">IShellLink</a> interface as shown in this example.
     * 
     * 
     * ```
     * @param {Pointer<BROWSEINFOW>} lpbi Type: <b>LPBROWSEINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure that contains information used to display the dialog box.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.
     *     
     *     					
     * 
     * It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shbrowseforfolderw
     * @since windows5.1.2600
     */
    static SHBrowseForFolderW(lpbi) {
        result := DllCall("SHELL32.dll\SHBrowseForFolderW", "ptr", lpbi, "ptr")
        return result
    }

    /**
     * Creates an instance of the specified object class from within the context of the Shell's process. WindowsVista and later:\_This function has been disabled and returns E_NOTIMPL.
     * @remarks
     * <div class="alert"><b>Note</b>This function is available through WindowsXP Service Pack2 (SP2) and Windows Server2003. It is not available in later versions of Windows, including WindowsVista.</div>
     * <div></div>
     * This function creates the requested object instance by calling the <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance">CoCreateInstance</a> function and immediately releasing the returned object. The associated DLL is unloaded according to standard Component Object Model (COM) rules when it returns S_OK from its <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow">DllCanUnloadNow</a> function.
     * @param {Pointer<Guid>} rclsid Type: <b>REFCLSID</b>
     * 
     * The CLSID of the object class to be created.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise. In WindowsVista and later versions, always returns E_NOTIMPL.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shloadinproc
     * @since windows5.1.2600
     */
    static SHLoadInProc(rclsid) {
        result := DllCall("SHELL32.dll\SHLoadInProc", "ptr", rclsid, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the IShellFolder interface for the desktop folder, which is the root of the Shell's namespace.
     * @param {Pointer<IShellFolder>} ppshf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>**</b>
     * 
     * When this method returns, receives an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface pointer for the desktop folder. The calling application is responsible for eventually freeing the interface by calling its <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> method.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetdesktopfolder
     * @since windows5.1.2600
     */
    static SHGetDesktopFolder(ppshf) {
        result := DllCall("SHELL32.dll\SHGetDesktopFolder", "ptr", ppshf, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Notifies the system of an event that an application has performed. An application should use this function if it performs an action that may affect the Shell.
     * @remarks
     * Applications that register new handlers of any type must call <b>SHChangeNotify</b> with the <b>SHCNE_ASSOCCHANGED</b> flag to instruct the Shell to invalidate the icon and thumbnail cache. This will also load new icon and thumbnail handlers that have been registered. Note, however, that icon overlay handlers are not reloaded.
     * 
     * The strings pointed to by <i>dwItem1</i> and <i>dwItem2</i> can be either ANSI or Unicode.
     * @param {Integer} wEventId Type: <b>LONG</b>
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @param {Pointer<Void>} dwItem1 Type: <b>LPCVOID</b>
     * 
     * Optional. First event-dependent value.
     * @param {Pointer<Void>} dwItem2 Type: <b>LPCVOID</b>
     * 
     * Optional. Second event-dependent value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shchangenotify
     * @since windows5.1.2600
     */
    static SHChangeNotify(wEventId, uFlags, dwItem1, dwItem2) {
        DllCall("SHELL32.dll\SHChangeNotify", "int", wEventId, "uint", uFlags, "ptr", dwItem1, "ptr", dwItem2)
    }

    /**
     * Notifies the system that an item has been accessed, for the purposes of tracking those items used most recently and most frequently. This function can also be used to clear all usage data.
     * @remarks
     * The usage statistics gathered through calls to this method are used to determine lists of items accessed most recently and most frequently. These lists are seen in the <b>Start</b> menu and, in Windows7 and later, in an application's Jump List.
     * 
     * When this method is called, it affects the following areas:
     *             
     *                 
     * 
     * <ul>
     * <li>Updates the <b>Recent</b> and <b>Frequent</b> lists for the associated application's Jump List.</li>
     * <li>Adds a shortcut to the user's <a href="https://docs.microsoft.com/windows/desktop/shell/manage">Recent</a> folder (<a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">FOLDERID_Recent</a>, <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_RECENT</a>). This is reflected in the <b>My Recent Documents</b> (WindowsXP) and <b>Recent Items</b> (WindowsVista and later) menu in the <b>Start</b> menu.</li>
     * <li>Adds a shortcut to the Classic <b>Start</b> menu's <b>Documents</b> submenu. (Note that the Classic <b>Start</b> menu option is not available in Windows7 and later.)</li>
     * </ul>
     * Items represented by an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishelllinka">IShellLink</a> are not added to the <b>Recent</b> folder, although they are reflected in an application's Jump List.
     * 
     * In some cases, notably when a user opens an item through Windows Explorer or uses the common file dialog to open, save, or create a file, the Shell calls <b>SHAddToRecentDocs</b> on behalf of the application. An application that has a custom UI for selecting items should call <b>SHAddToRecentDocs</b> explicitly to ensure accurate statistics. Duplicate calls are accounted for by the system so there is no risk of skewing the data by doing so.
     * 
     * Executable (.exe) files are filtered from the recently used documents list in WindowsXP and later versions. Although <b>SHAddToRecentDocs</b> will accept the path of an executable file, that file will not appear in the <b>Recent Items</b> list.
     * 
     * Folders are also accepted by <b>SHAddToRecentDocs</b>, but appear only in the Jump List for the Windows Explorer taskbar button. Folders do not appear in any other application's Jump List.
     * 
     * In certain cases, <b>SHAddToRecentDocs</b> attempts to register an application to handle a file type that it is not registered to handle. This occurs under these circumstances:
     * 
     * <ul>
     * <li>An application explicitly calls <b>SHAddToRecentDocs</b> with a file type that it is not registered to handle. This also applies to calls made to <b>SHAddToRecentDocs</b> by the common file dialog on behalf of the application, but only when the dialog is used to open a file, not when it is used to save one.</li>
     * <li>The user drops a file of a type that the application is not registered to handle on the application's taskbar button.</li>
     * </ul>
     * This registration is done per-user.
     * 
     * A set of requirements must be met for the registration to be accomplished successfully:
     * 
     * <ul>
     * <li>The application must be registered under <b>HKEY_CLASSES_ROOT</b>&#92;<b>Applications</b>.</li>
     * <li>That registration cannot include the NoOpenWith value. See <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-types">File Types</a> for more details on NoOpenWith.</li>
     * <li>That registration cannot supply data under a <b>SupportedTypes</b> subkey. See <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-types">File Types</a> for more details on the <b>SupportedTypes</b> subkey.</li>
     * <li>
     * The application's executable file cannot be listed in the KillList value found here:
     * 
     * 
     * <pre><b>HKEY_LOCAL_MACHINE</b>
     * <b>Software</b>
     * <b>Microsoft</b>
     * <b>Windows</b>
     * <b>CurrentVersion</b>
     * <b>Explorer</b>
     * <b>FileAssociation</b>
     * <b>KillList</b></pre>
     * 
     * 
     * <div class="alert"><b>Note</b>Third party applications should not modify the KillList value. It should be regarded as read-only.</div>
     * <div></div>
     * </li>
     * <li>
     * The application's <b>HKEY_CLASSES_ROOT</b>&#92;<b>Applications</b> registration must have a set of default verbs defined under a 
     *                         
     *                             
     *                             <b>HKEY_CLASSES_ROOT</b>&#92;<b>Applications</b>&#92;<i>ExampleApp.exe</i>&#92;<b>shell</b> subkey.
     *                         
     * 
     * If <b>SHAddToRecentDocs</b> is attempting the registration as the result of a drag-and-drop onto the taskbar button, the <b>shell</b> subkey is created if it does not already exist, as long as the existing application registration does not contain a NoOpenWith value and the application's executable is not listed in the KillList value.
     * 
     * </li>
     * </ul>
     * <h3><a id="Suppressing_Calls_to_SHAddToRecentDocs"></a><a id="suppressing_calls_to_shaddtorecentdocs"></a><a id="SUPPRESSING_CALLS_TO_SHADDTORECENTDOCS"></a>Suppressing Calls to SHAddToRecentDocs</h3>
     * In versions of Windows before Windows7, a file type could set the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-filetypeattributeflags">FTA_NoRecentDocs</a> flag to prevent that file type from being added to the <b>Recent</b> folder. This mechanism is also supported under Windows7 and later. See <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-types">File Types</a> for more information.
     * 
     * <b>SHAddToRecentDocs</b> tracks document usage statistics through the verbs that are invoked to access those documents. Verbs supplied by registered <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> handlers are tracked, those items appear in <b>My Recent Documents</b> (WindowsXP) and <b>Recent Items</b> (WindowsVista). In Windows7, the parent folders of the documents appear in the Jump List for the Windows Explorer taskbar button. However, the documents accessed through those <b>IContextMenu</b> verbs do not appear in application Jump Lists. For those items to appear in an application's Jump List, an application must call <b>SHAddToRecentDocs</b> explicitly.
     * 
     * Prior to Windows7, only the <c>open</c> verb resulted in a call to <b>SHAddToRecentDocs</b>. In Windows7 and later, other verbs can also generate usage statistics. This information is used to make a Jump List's destinations more complete and accurate.
     * 
     * However, some classes of file type association registrations or individual <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> implementations are not appropriate for this sort of tracking. The point of usage tracking is to generate a list of items that the user is likely to want to access again. If a particular verb<c>delete</c>, for instanceis inherently invoked on an item that the user will not access again, or is a secondary action such as a virus scan on a file, that verb is not appropriate for tracking. File type classes should remove themselves from this tracking through the registry entry NoRecentDocs. NoRecentDocs is of type REG_SZ and has no associated data. Its presence is all that is required to prevent the call to <b>SHAddToRecentDocs</b>.
     * 
     * For example, context menu extensions and static verbs registered under <b>HKEY_CLASSES_ROOT</b> in classes such as "*", "AllFileSystemObjects", or "Folder" should not be tracked. In cases such as these, the NoRecentDocs entry is added to the root of the class key as shown here to suppress tracking of documents launched through any verb or extension registered to that class:
     * 
     * 
     * <pre><b>HKEY_CLASSES_ROOT</b>
     * <b>AllFileSystemObjects</b>
     * <b>NoRecentDocs</b></pre>
     * 
     * 
     * The NoRecentDocs entry is assigned by default to the <b>*</b>, <b>AllFileSystemObjects</b>, <b>Folder</b>, <b>Directory</b>, and <b>DesktopBackground</b> class subkeys.
     * 
     * Individual <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> implementations can opt out of tracking by adding a NoRecentDocs subkey to its Component Object Model (COM) object's registration, in its <b>shellex</b> subkey, as shown here:
     * 
     * 
     * <pre><b>HKEY_CLASSES_ROOT</b>
     * <b>CLSID</b>
     * <i>{093C7AAB-5E72-454f-A91D-CA1BC991FCEC}</i>
     * <b>shellex</b>
     * <b>NoRecentDocs</b></pre>
     * 
     * 
     * This subkey is not present by default on any <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> implementation.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * A value from the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-shard">SHARD</a> enumeration that indicates the form of the information pointed to by the <i>pv</i> parameter.
     * @param {Pointer<Void>} pv Type: <b>LPCVOID</b>
     * 
     * A pointer to data that identifies the item that has been accessed. The item can be specified in this parameter in one of the following forms:
     *     
     *                         
     * 
     * 
     * <ul>
     * <li>A null-terminated string that contains the path and file name of the item.</li>
     * <li>A PIDL that identifies the item's file object.</li>
     * <li><b>Windows7 and later only</b>. A <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shardappidinfo">SHARDAPPIDINFO</a>, <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shardappidinfoidlist">SHARDAPPIDINFOIDLIST</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shardappidinfolink">SHARDAPPIDINFOLINK</a> structure that identifies the item through an AppUserModelID. See <a href="https://docs.microsoft.com/windows/desktop/shell/appids">Application User Model IDs (AppUserModelIDs)</a> for more information.</li>
     * <li><b>Windows7 and later only</b>. An <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishelllinka">IShellLink</a> object that identifies the item through a shortcut.</li>
     * </ul>
     * 
     * 
     * Set this parameter to <b>NULL</b> to clear all usage data on all items.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shaddtorecentdocs
     * @since windows5.1.2600
     */
    static SHAddToRecentDocs(uFlags, pv) {
        DllCall("SHELL32.dll\SHAddToRecentDocs", "uint", uFlags, "ptr", pv)
    }

    /**
     * SHHandleUpdateImage may be altered or unavailable.
     * @remarks
     * Use <b>SHHandleUpdateImage</b> only when the <i>pidl2</i> parameter received by your change notification callback is non-<b>NULL</b>.
     * @param {Pointer<ITEMIDLIST>} pidlExtra Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The index in the system image list that has changed, specified in the <i>pidl2</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ishellchangenotify-onchange">IShellChangeNotify::OnChange</a>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns -1 on failure or the index of the changed image list entry on success.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shhandleupdateimage
     * @since windows5.1.2600
     */
    static SHHandleUpdateImage(pidlExtra) {
        result := DllCall("SHELL32.dll\SHHandleUpdateImage", "ptr", pidlExtra, "int")
        return result
    }

    /**
     * Notifies the Shell that an image in the system image list has changed. (ANSI)
     * @remarks
     * If you do not know the index in the system image list of the icon that you want to update, use <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shgetfileinfoa">SHGetFileInfo</a> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.
     * 
     * You must use <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszHashItem Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>.
     * @param {Integer} iIndex Type: <b>int</b>
     * 
     * An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.
     * @param {Integer} iImageIndex Type: <b>int</b>
     * 
     * An integer that specifies the index in the system image list of the icon that is being updated.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shupdateimagea
     * @since windows5.0
     */
    static SHUpdateImageA(pszHashItem, iIndex, uFlags, iImageIndex) {
        pszHashItem := pszHashItem is String? StrPtr(pszHashItem) : pszHashItem

        DllCall("SHELL32.dll\SHUpdateImageA", "ptr", pszHashItem, "int", iIndex, "uint", uFlags, "int", iImageIndex)
    }

    /**
     * Notifies the Shell that an image in the system image list has changed. (Unicode)
     * @remarks
     * If you do not know the index in the system image list of the icon that you want to update, use <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shgetfileinfoa">SHGetFileInfo</a> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.
     * 
     * You must use <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszHashItem Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>.
     * @param {Integer} iIndex Type: <b>int</b>
     * 
     * An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.
     * @param {Integer} iImageIndex Type: <b>int</b>
     * 
     * An integer that specifies the index in the system image list of the icon that is being updated.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shupdateimagew
     * @since windows5.0
     */
    static SHUpdateImageW(pszHashItem, iIndex, uFlags, iImageIndex) {
        pszHashItem := pszHashItem is String? StrPtr(pszHashItem) : pszHashItem

        DllCall("SHELL32.dll\SHUpdateImageW", "ptr", pszHashItem, "int", iIndex, "uint", uFlags, "int", iImageIndex)
    }

    /**
     * Registers a window to receive notifications from the file system or Shell, if the file system supports notifications.
     * @remarks
     * See the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd940348(v=vs.85)">Change Notify Watcher Sample</a> in the Windows Software Development Kit (SDK) for a full example that demonstrates the use of this function.
     * 
     * When a change notification event is raised, the message indicated by <i>wMsg</i> is delivered to the window specified by the <i>hwnd</i> parameter. 
     * 
     *                 
     * 
     * <ul>
     * <li>If SHCNRF_NewDelivery is specified, the <i>wParam</i> and <i>lParam</i> values in the message should be passed to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotification_lock">SHChangeNotification_Lock</a> as the <i>hChange</i> and <i>dwProcID</i> parameters respectively.</li>
     * <li>If SHCNRF_NewDelivery is not specified, <i>wParam</i> is a pointer to two PIDLIST_ABSOLUTE pointers, and <i>lParam</i> specifies the event. The two PIDLIST_ABSOLUTE pointers can be <b>NULL</b>, depending on the event being sent.</li>
     * </ul>
     * When a relevant file system event takes place and the <i>hwnd</i> parameter is not <b>NULL</b>, then the message indicated by <i>wMsg</i> is posted to the specified window. Otherwise, if the <i>pshcne</i> parameter is not <b>NULL</b>, then that notification entry is used.
     * 
     * For performance reasons, multiple notifications can be combined into a single notification. For example, if a large number of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotify">SHCNE_UPDATEITEM</a> notifications are generated for files in the same folder, they can be joined into a single <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotify">SHCNE_UPDATEDIR</a> notification.
     * 
     * The <b>NTSHChangeNotifyRegister</b> function, which is no longer available as of WindowsVista, was equivalent to <b>SHChangeNotifyRegister</b> with the SHCNRF_NewDelivery flag.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window that receives the change or notification messages.
     * @param {Integer} fSources Type: <b>int</b>
     * @param {Integer} fEvents Type: <b>LONG</b>
     * 
     * Change notification events for which to receive notification. See the SHCNE flags listed in <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotify">SHChangeNotify</a> for possible values.
     * @param {Integer} wMsg Type: <b>UINT</b>
     * 
     * Message to be posted to the window procedure.
     * @param {Integer} cEntries Type: <b>int</b>
     * 
     * Number of entries in the <i>pshcne</i> array.
     * @param {Pointer<SHChangeNotifyEntry>} pshcne Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shchangenotifyentry">SHChangeNotifyEntry</a>*</b>
     * 
     * Array of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shchangenotifyentry">SHChangeNotifyEntry</a> structures that contain the notifications. This array should always be set to one when calling <b>SHChangeNotifyRegister</b> or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotifyderegister">SHChangeNotifyDeregister</a> will not work properly.
     * @returns {Integer} Type: <b>ULONG</b>
     * 
     * Returns a positive integer registration ID. Returns 0 if out of memory or in response to invalid parameters.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shchangenotifyregister
     * @since windows5.0
     */
    static SHChangeNotifyRegister(hwnd, fSources, fEvents, wMsg, cEntries, pshcne) {
        result := DllCall("SHELL32.dll\SHChangeNotifyRegister", "ptr", hwnd, "int", fSources, "int", fEvents, "uint", wMsg, "int", cEntries, "ptr", pshcne, "uint")
        return result
    }

    /**
     * Unregisters the client's window process from receiving SHChangeNotify messages.
     * @remarks
     * See the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd940348(v=vs.85)">Change Notify Watcher Sample</a> in the Windows Software Development Kit (SDK) for a full example that demonstrates the use of this function.
     * 
     * The <b>NTSHChangeNotifyDeregister</b> function, which is no longer available for use as of WindowsVista, was equivalent to <b>SHChangeNotifyDeregister</b>.
     * @param {Integer} ulID Type: <b>ULONG</b>
     * 
     * A value of type <b>ULONG</b> that specifies the registration ID returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotifyregister">SHChangeNotifyRegister</a>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the specified client was found and removed; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shchangenotifyderegister
     * @since windows5.1.2600
     */
    static SHChangeNotifyDeregister(ulID) {
        result := DllCall("SHELL32.dll\SHChangeNotifyDeregister", "uint", ulID, "int")
        return result
    }

    /**
     * Locks the shared memory associated with a Shell change notification event.
     * @param {Pointer<Void>} hChange Type: <b>HANDLE</b>
     * 
     * A handle to a window received as a <i>wParam</i> in the specified Shell change notification message.
     * @param {Integer} dwProcId Type: <b>DWORD</b>
     * 
     * The process ID (<i>lParam</i> in the message callback).
     * @param {Pointer<ITEMIDLIST>} pppidl Type: <b>PIDLIST_ABSOLUTE**</b>
     * 
     * The address of a pointer to a PIDLIST_ABSOLUTE that, when this function returns successfully, receives the list of affected PIDLs.
     * @param {Pointer<Int32>} plEvent Type: <b>LONG*</b>
     * 
     * A pointer to a LONG value that, when this function returns successfully, receives the Shell change notification ID of the event that took place.
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * Returns a handle (HLOCK) to the locked memory. Pass this value to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotification_unlock">SHChangeNotification_Unlock</a> when finished.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shchangenotification_lock
     * @since windows5.0
     */
    static SHChangeNotification_Lock(hChange, dwProcId, pppidl, plEvent) {
        result := DllCall("SHELL32.dll\SHChangeNotification_Lock", "ptr", hChange, "uint", dwProcId, "ptr", pppidl, "int*", plEvent)
        return result
    }

    /**
     * Unlocks shared memory for a change notification.
     * @param {Pointer<Void>} hLock Type: <b>HANDLE</b>
     * 
     * A handle to the memory lock. This is the handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotification_lock">SHChangeNotification_Lock</a> when it locked the memory.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> on success; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shchangenotification_unlock
     * @since windows5.0
     */
    static SHChangeNotification_Unlock(hLock) {
        result := DllCall("SHELL32.dll\SHChangeNotification_Unlock", "ptr", hLock, "int")
        return result
    }

    /**
     * SHGetRealIDL may be altered or unavailable.
     * @param {Pointer<IShellFolder>} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to an instance of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> whose simple PIDL is to be converted.
     * @param {Pointer<ITEMIDLIST>} pidlSimple Type: <b>PCUITEMID_CHILD</b>
     * 
     * The simple PIDL to be converted.
     * @param {Pointer<ITEMIDLIST>} ppidlReal Type: <b>PITEMID_CHILD*</b>
     * 
     * When this method returns, contains a pointer to the full converted PIDL. If the function fails, this parameter is set to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetrealidl
     * @since windows5.1.2600
     */
    static SHGetRealIDL(psf, pidlSimple, ppidlReal) {
        result := DllCall("SHELL32.dll\SHGetRealIDL", "ptr", psf, "ptr", pidlSimple, "ptr", ppidlReal, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves an interface that allows hosted Shell extensions and other components to prevent their host process from closing prematurely.
     * @remarks
     * There are a number of components, such as Shell extension handlers, that are implemented as DLLs and run in a host process such as Windows Explorer (Explorer.exe) or Internet Explorer (Iexplore.exe). Typically, when the user closes the host process, the component is shut down immediately as well. Such an abrupt termination can create problems for some components. For example, if a component is using a background thread to download data or run user-interface functions, it might need additional time to safely shut itself down.
     * 
     * <b>SHGetInstanceExplorer</b> allows components that run in a host process to hold a reference on the host process. <b>SHGetInstanceExplorer</b> increments the host's reference count and returns a pointer to the host's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface. By holding that reference, a component can prevent the host process from closing prematurely. After the component has completed its necessary processing, it should call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">(*ppunk)->Release</a> to release the host's reference and allow the process to terminate.
     * 
     * <div class="alert"><b>Note</b>If <b>SHGetInstanceExplorer</b> is successful, the component must release the host's reference when it is no longer needed. Otherwise, all resources associated with the process will remain in memory. The <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface pointed to by *<i>ppunk</i> can only be used to release this reference. Components cannot use <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">(*ppunk)->QueryInterface</a> to request other interface pointers.</div>
     * <div></div>
     * <b>SHGetInstanceExplorer</b> succeeds only if it is called from from an application which had previously called <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shsetinstanceexplorer">SHSetInstanceExplorer</a> to set a process reference.
     * @param {Pointer<IUnknown>} ppunk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>**</b>
     * 
     * When this function returns successfully, contains the address of the host process' <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface pointer. This is a free-threaded interface used to prevent the host process from terminating. If the function call fails, this value is set to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer
     * @since windows5.1.2600
     */
    static SHGetInstanceExplorer(ppunk) {
        result := DllCall("SHELL32.dll\SHGetInstanceExplorer", "ptr", ppunk, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves extended property data from a relative identifier list. (ANSI)
     * @remarks
     * This function extracts only information that is present in the pointer to an item identifier list (PIDL). Since the content of a PIDL depends on the folder object that created the PIDL, there is no guarantee that all requested information will be available. In addition, the information that is returned reflects the state of the object at the time the PIDL was created. The current state of the object could be different. For example, if you set <i>nFormat</i> to <b>SHGDFIL_FINDDATA</b>, the function might assign meaningful values to only some of the members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure. The remaining members will be set to zero. To retrieve complete current information on a file system file or folder, use standard file system functions such as <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfiletime">GetFileTime</a> or <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a>.
     * 
     * E_INVALIDARG is returned if the <i>psf</i>, <i>pidl</i>, <i>pv</i>, or <i>cb</i> parameter does not match the <i>nFormat</i> parameter, or if <i>nFormat</i> is not one of the specific SHGDFIL_ values shown above.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetDataFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<IShellFolder>} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * The address of the parent <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface. This must be the immediate parent of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure referenced by the <i>pidl</i> parameter.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that identifies the object relative to the folder specified in <i>psf</i>.
     * @param {Integer} nFormat Type: <b>int</b>
     * @param {Pointer} pv Type: <b>void*</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.
     * 
     * If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.
     * @param {Integer} cb Type: <b>int</b>
     * 
     * Size of the buffer at <i>pv</i>, in bytes.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or E_INVALIDARG otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetdatafromidlista
     * @since windows5.1.2600
     */
    static SHGetDataFromIDListA(psf, pidl, nFormat, pv, cb) {
        result := DllCall("SHELL32.dll\SHGetDataFromIDListA", "ptr", psf, "ptr", pidl, "int", nFormat, "ptr", pv, "int", cb, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves extended property data from a relative identifier list. (Unicode)
     * @remarks
     * This function extracts only information that is present in the pointer to an item identifier list (PIDL). Since the content of a PIDL depends on the folder object that created the PIDL, there is no guarantee that all requested information will be available. In addition, the information that is returned reflects the state of the object at the time the PIDL was created. The current state of the object could be different. For example, if you set <i>nFormat</i> to <b>SHGDFIL_FINDDATA</b>, the function might assign meaningful values to only some of the members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure. The remaining members will be set to zero. To retrieve complete current information on a file system file or folder, use standard file system functions such as <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfiletime">GetFileTime</a> or <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a>.
     * 
     * E_INVALIDARG is returned if the <i>psf</i>, <i>pidl</i>, <i>pv</i>, or <i>cb</i> parameter does not match the <i>nFormat</i> parameter, or if <i>nFormat</i> is not one of the specific SHGDFIL_ values shown above.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHGetDataFromIDList as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<IShellFolder>} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * The address of the parent <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface. This must be the immediate parent of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure referenced by the <i>pidl</i> parameter.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that identifies the object relative to the folder specified in <i>psf</i>.
     * @param {Integer} nFormat Type: <b>int</b>
     * @param {Pointer} pv Type: <b>void*</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.
     * 
     * If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.
     * @param {Integer} cb Type: <b>int</b>
     * 
     * Size of the buffer at <i>pv</i>, in bytes.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or E_INVALIDARG otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetdatafromidlistw
     * @since windows5.1.2600
     */
    static SHGetDataFromIDListW(psf, pidl, nFormat, pv, cb) {
        result := DllCall("SHELL32.dll\SHGetDataFromIDListW", "ptr", psf, "ptr", pidl, "int", nFormat, "ptr", pv, "int", cb, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Displays a dialog box that prompts the user to restart Windows. When the user clicks the button, the function calls ExitWindowsEx to attempt to restart Windows.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {Pointer<Char>} pszPrompt Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the text that displays in the dialog box which prompts the user.
     * @param {Integer} dwReturn Type: <b>DWORD</b>
     * 
     * The flags that specify the type of shutdown.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the identifier of the button that was pressed to close the dialog box.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-restartdialog
     * @since windows5.0
     */
    static RestartDialog(hwnd, pszPrompt, dwReturn) {
        pszPrompt := pszPrompt is String? StrPtr(pszPrompt) : pszPrompt

        result := DllCall("SHELL32.dll\RestartDialog", "ptr", hwnd, "ptr", pszPrompt, "uint", dwReturn, "int")
        return result
    }

    /**
     * Displays a dialog box that asks the user to restart Windows. When the user clicks the button, the function calls ExitWindowsEx to attempt to restart Windows.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {Pointer<Char>} pszPrompt Type: <b>PCWSTR</b>
     * 
     * A null-terminated string that contains the text that displays in the dialog box to prompt the user.
     * @param {Integer} dwReturn Type: <b>DWORD</b>
     * 
     * The flags that specify the type of shutdown.
     * @param {Integer} dwReasonCode Type: <b>DWORD</b>
     * 
     * <b>Windows XP:</b>Specifies the reason for initiating the shutdown. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Shutdown/system-shutdown-reason-codes">System Shutdown Reason Codes</a>.
     *     
     *     					
     * 
     * <b>Windows 2000:</b> This parameter is ignored.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the identifier of the button that was pressed to close the dialog box.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-restartdialogex
     * @since windows5.0
     */
    static RestartDialogEx(hwnd, pszPrompt, dwReturn, dwReasonCode) {
        pszPrompt := pszPrompt is String? StrPtr(pszPrompt) : pszPrompt

        result := DllCall("SHELL32.dll\RestartDialogEx", "ptr", hwnd, "ptr", pszPrompt, "uint", dwReturn, "uint", dwReasonCode, "int")
        return result
    }

    /**
     * SHCoCreateInstance may be altered or unavailable. Instead, use CoCreateInstance.
     * @remarks
     * We recommend that you use the <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-iid_ppv_args">IID_PPV_ARGS</a> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error in <i>riid</i> that could lead to unexpected results.
     * @param {Pointer<Char>} pszCLSID Type: <b>PCWSTR</b>
     * 
     * A pointer to a string to convert to a CLSID. If <b>NULL</b>, <i>pclsid</i> is used as the CLSID.
     * @param {Pointer<Guid>} pclsid Type: <b>const CLSID*</b>
     * 
     * The CLSID to create.
     * @param {Pointer<IUnknown>} pUnkOuter Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to outer <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>. Used for aggregation.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this function returns successfully, receives the interface pointer requested in <i>riid</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcocreateinstance
     * @since windows5.1.2600
     */
    static SHCoCreateInstance(pszCLSID, pclsid, pUnkOuter, riid, ppv) {
        pszCLSID := pszCLSID is String? StrPtr(pszCLSID) : pszCLSID

        result := DllCall("SHELL32.dll\SHCoCreateInstance", "ptr", pszCLSID, "ptr", pclsid, "ptr", pUnkOuter, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a data object in a parent folder.
     * @remarks
     * This function is typically called when implementing method <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof">IShellFolder::GetUIObjectOf</a>. When an interface pointer of interface ID  IID_IDataObject is requested (using parameter <i>riid</i>), the implementer can return the interface pointer on the object created with <b>SHCreateDataObject</b> in response.
     * 
     * This function supports the <a href="https://docs.microsoft.com/windows/desktop/shell/clipboard">CFSTR_SHELLIDLIST</a> (also known as HIDA) clipboard format and also has generic support for arbitrary clipboard formats through <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-setdata">IDataObject::SetData</a>. For more information on clipboard formats, see Shell Clipboard Formats.
     * 
     * The new data object is intended to be used in operations such as drag-and-drop, in which the data is stored in the clipboard with a given format.
     * 
     * We recommend that you use the <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-iid_ppv_args">IID_PPV_ARGS</a> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error in <i>riid</i> that could lead to unexpected results.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) of the parent folder that contains the data object.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of file objects or subfolders specified in the <i>apidl</i> parameter.
     * @param {Pointer<ITEMIDLIST>} apidl Type: <b>PCUITEMID_CHILD_ARRAY</b>
     * 
     * An array of pointers to constant <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures, each of which uniquely identifies a file object or subfolder relative to the parent folder. Each item identifier list must contain exactly one <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure followed by a terminating zero.
     * @param {Pointer<IDataObject>} pdtInner Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to interface <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>. This parameter can be <b>NULL</b>. Specify <i>pdtInner</i> only if the data object created needs to support additional <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a>  clipboard formats beyond the default formats it is assigned at creation.  Alternatively, provide support for populating the created data object using non-default clipboard formats by calling method <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-setdata">IDataObject::SetData</a> and specifying the format in the <b>FORMATETC</b> structure passed in parameter <i>pFormatetc</i>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>. This must be IID_IDataObject.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns successfully, contains the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface pointer requested in <i>riid</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreatedataobject
     * @since windows6.0.6000
     */
    static SHCreateDataObject(pidlFolder, cidl, apidl, pdtInner, riid, ppv) {
        result := DllCall("SHELL32.dll\SHCreateDataObject", "ptr", pidlFolder, "uint", cidl, "ptr", apidl, "ptr", pdtInner, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * CIDLData_CreateFromIDArray may be altered or unavailable.
     * @remarks
     * The data object created by this function offers the Shell clipboard format identifier <a href="https://docs.microsoft.com/windows/desktop/shell/clipboard">CFSTR_SHELLIDLIST</a>. This data object also supports <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-setdata">IDataObject::SetData</a> calls to pick up other clipboard formats.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A fully qualified IDLIST for the root of the items specified in <i>apidl</i>.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of entries in the <i>apidl</i> array.
     * @param {Pointer<ITEMIDLIST>} apidl Type: <b>PCUIDLIST_RELATIVE_ARRAY</b>
     * 
     * The array of item IDs relative to <i>pidlFolder</i>. Typically, <i>apidl</i> is an array of child IDs and <i>pidlFolder</i> is a full PIDL for those items. However, <i>pidlFolder</i> can be a null PIDL (desktop IDLISTs). In that case, <i>apidl</i> can contain fully qualified ID lists.
     * @param {Pointer<IDataObject>} ppdtobj Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>**</b>
     * 
     * The address to a pointer to the object that implements <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-cidldata_createfromidarray
     * @since windows5.0
     */
    static CIDLData_CreateFromIDArray(pidlFolder, cidl, apidl, ppdtobj) {
        result := DllCall("SHELL32.dll\CIDLData_CreateFromIDArray", "ptr", pidlFolder, "uint", cidl, "ptr", apidl, "ptr", ppdtobj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHCreateStdEnumFmtEtc may be altered or unavailable.
     * @param {Integer} cfmt Type: <b>UINT</b>
     * 
     * The number of entries in the <i>afmt</i> array.
     * @param {Pointer<FORMATETC>} afmt Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a>[]</b>
     * 
     * An array of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structures that specifies the clipboard formats of interest.
     * @param {Pointer<IEnumFORMATETC>} ppenumFormatEtc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumformatetc">IEnumFORMATETC</a>**</b>
     * 
     * When this function returns successfully, receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumformatetc">IEnumFORMATETC</a> interface pointer. Receives <b>NULL</b> on failure.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreatestdenumfmtetc
     * @since windows5.1.2600
     */
    static SHCreateStdEnumFmtEtc(cfmt, afmt, ppenumFormatEtc) {
        result := DllCall("SHELL32.dll\SHCreateStdEnumFmtEtc", "uint", cfmt, "ptr", afmt, "ptr", ppenumFormatEtc, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Executes a drag-and-drop operation. Supports drag source creation on demand, as well as drag images.
     * @remarks
     * As of WindowsVista, if a drag image is not already stored in the data object <i>pdtobj</i> and a drag image cannot be obtained from the window specified by <i>hwnd</i>, the Shell provides a generic drag image. A drag image can fail to be obtained from the specified window either because <i>hwnd</i> is <b>NULL</b> or the specified window does not support the DI_GETDRAGIMAGE message.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * The handle of the window used to obtain the drag image. This value can be <b>NULL</b>. See Remarks for more details.
     * @param {Pointer<IDataObject>} pdata Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface on a data object that contains the data being dragged.
     * @param {Pointer<IDropSource>} pdsrc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idropsource">IDropSource</a>*</b>
     * 
     * A pointer to an implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idropsource">IDropSource</a> interface, which is used to communicate with the source during the drag operation.
     *         
     *                         
     * 
     * As of WindowsVista, if this value is <b>NULL</b>, the Shell creates a drop source object for you.
     * @param {Integer} dwEffect Type: <b>DWORD</b>
     * 
     * The effects that the source allows in the drag-and-drop operation. The most significant effect is whether the drag-and-drop operation permits a move. For a list of possible values, see <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a>.
     * @param {Pointer<UInt32>} pdwEffect Type: <b>DWORD*</b>
     * 
     * A pointer to a value that indicates how the drag-and-drop operation affected the source data. The <i>pdwEffect</i> parameter is set only if the operation is not canceled. For a list of possible values, see <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * This function supports the standard return value E_OUTOFMEMORY, as well as the following values:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRAGDROP_S_DROP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drag-and-drop operation was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRAGDROP_S_CANCEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drag-and-drop operation was canceled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_UNSPEC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexpected error occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shdodragdrop
     * @since windows5.1.2600
     */
    static SHDoDragDrop(hwnd, pdata, pdsrc, dwEffect, pdwEffect) {
        result := DllCall("SHELL32.dll\SHDoDragDrop", "ptr", hwnd, "ptr", pdata, "ptr", pdsrc, "uint", dwEffect, "uint*", pdwEffect, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Sets the drag image.
     * @remarks
     * You can clear the drag image by setting the <i>him</i> parameter to <c>-1</code> and the <i>pptOffset</i> parameter to <code>NULL</c>. The image must have been set within the same thread.
     * @param {Pointer} him Type: <b>HIMAGELIST</b>
     * 
     * A handle to an image list. This parameter uses the zero index in the ImageList.
     * @param {Pointer<POINT>} pptOffset Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b>
     * 
     * A pointer to the coordinates used as the hot spot for dragging the image. The coordinates are relative to upper-left corner of the image.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-dad_setdragimage
     * @since windows5.0
     */
    static DAD_SetDragImage(him, pptOffset) {
        result := DllCall("SHELL32.dll\DAD_SetDragImage", "ptr", him, "ptr", pptOffset, "int")
        return result
    }

    /**
     * Locks updates to the specified window during a drag operation and displays the drag image at the specified position within the window. (DAD_DragEnterEx)
     * @param {Pointer<Void>} hwndTarget Type: <b>HWND</b>
     * 
     * A handle to the window that owns the drag image.
     * @param {Pointer} ptStart Type: <b>const <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * The coordinates at which to begin displaying the drag image. The coordinates are relative to the upper-left corner of the window, not the client area.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-dad_dragenterex
     * @since windows5.0
     */
    static DAD_DragEnterEx(hwndTarget, ptStart) {
        result := DllCall("SHELL32.dll\DAD_DragEnterEx", "ptr", hwndTarget, "ptr", ptStart, "int")
        return result
    }

    /**
     * Locks updates to the specified window during a drag-and-drop operation and displays the drag image at the specified position within the window.
     * @param {Pointer<Void>} hwndTarget Type: <b>HWND</b>
     * 
     * A handle to the window that owns the drag image.
     * @param {Pointer} ptStart Type: <b>const <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * Specifies the coordinates at which to begin displaying the drag image. The coordinates are relative to the upper-left corner of the window, not the client area.
     * @param {Pointer<IDataObject>} pdtObject Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface on the data object. This data object contains the data being transferred in the drag-and-drop operation. If the drop occurs, this data object will be incorporated into the target. This parameter may be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-dad_dragenterex2
     * @since windows5.0
     */
    static DAD_DragEnterEx2(hwndTarget, ptStart, pdtObject) {
        result := DllCall("SHELL32.dll\DAD_DragEnterEx2", "ptr", hwndTarget, "ptr", ptStart, "ptr", pdtObject, "int")
        return result
    }

    /**
     * Shows or hides the image being dragged. (DAD_ShowDragImage)
     * @remarks
     * This function works on locked windows. It does not work on layered windows.
     * @param {Integer} fShow Type: <b>BOOL</b>
     * 
     * A value that specifies whether to show or hide the image being dragged.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-dad_showdragimage
     * @since windows5.0
     */
    static DAD_ShowDragImage(fShow) {
        result := DllCall("SHELL32.dll\DAD_ShowDragImage", "int", fShow, "int")
        return result
    }

    /**
     * Moves the image that is being dragged during a drag-and-drop operation.
     * @param {Pointer} pt Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * The coordinates at which to display the drag image. The coordinates are relative to the upper-left corner of the window, not the client area.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-dad_dragmove
     * @since windows5.0
     */
    static DAD_DragMove(pt) {
        result := DllCall("SHELL32.dll\DAD_DragMove", "ptr", pt, "int")
        return result
    }

    /**
     * Unlocks the window locked by the DAD_DragEnterEx function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>SUCCEEDED</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-dad_dragleave
     * @since windows5.0
     */
    static DAD_DragLeave() {
        result := DllCall("SHELL32.dll\DAD_DragLeave", "int")
        return result
    }

    /**
     * Scrolls the window while an image is being dragged.
     * @remarks
     * The function is successful and the window scrolls only when the <b>bFull</b> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-auto_scroll_data">AUTO_SCROLL_DATA</a> structure is <b>TRUE</b>. Each time this function is called, as long as <b>bFull</b> is <b>FALSE</b>, the <b>iNextSample</b> parameter is incremented by 1 and the current scroll coordinates and time are returned in the <b>AUTO_SCROLL_DATA</b> structure. When <b>iNextSample</b> is equal to NUM_POINTS, <b>bFull</b> is set to <b>TRUE</b>, the function succeeds, and the window scrolls.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window being scrolled.
     * @param {Pointer<AUTO_SCROLL_DATA>} pad Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-auto_scroll_data">AUTO_SCROLL_DATA</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-auto_scroll_data">AUTO_SCROLL_DATA</a> structure.
     * @param {Pointer<POINT>} pptNow Type: <b>const <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b>
     * 
     * A pointer to the current scroll coordinates.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-dad_autoscroll
     * @since windows5.0
     */
    static DAD_AutoScroll(hwnd, pad, pptNow) {
        result := DllCall("SHELL32.dll\DAD_AutoScroll", "ptr", hwnd, "ptr", pad, "ptr", pptNow, "int")
        return result
    }

    /**
     * ReadCabinetState may be altered or unavailable.
     * @param {Pointer} pcs Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-cabinetstate">CABINETSTATE</a>*</b>
     * 
     * When this function returns, contains a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-cabinetstate">CABINETSTATE</a> structure that contains either information pulled from the registry or default information.
     * @param {Integer} cLength Type: <b>int</b>
     * 
     * The size of the structure pointed to by <i>pcs</i>, in bytes.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the returned structure contains information from the registry. Returns <b>FALSE</b> if the structure contains default information.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-readcabinetstate
     * @since windows5.1.2600
     */
    static ReadCabinetState(pcs, cLength) {
        result := DllCall("SHELL32.dll\ReadCabinetState", "ptr", pcs, "int", cLength, "int")
        return result
    }

    /**
     * WriteCabinetState may be altered or unavailable.
     * @param {Pointer<CABINETSTATE>} pcs Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-cabinetstate">CABINETSTATE</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-cabinetstate">CABINETSTATE</a> structure that holds the values to be set.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-writecabinetstate
     * @since windows5.1.2600
     */
    static WriteCabinetState(pcs) {
        result := DllCall("SHELL32.dll\WriteCabinetState", "ptr", pcs, "int")
        return result
    }

    /**
     * Creates a unique path name from a template.
     * @remarks
     * This function generates a new unique file name based on the templates specified by <i>pszTemplate</i>, for drives that require the 8.3 format, and <i>pszLongPlate</i> for drives that support long file names. For example, if you specify "My New Filename" for <i>pszLongPlate</i>, <b>PathMakeUniqueName</b> returns names such as "My New Filename (1)", "My New Filename (2)", and so on.
     * @param {Pointer<Char>} pszUniqueName Type: <b>PWSTR</b>
     * 
     * A buffer that receives a null-terminated Unicode string that contains the unique path name. It should be at least MAX_PATH characters in length.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The number of characters in the buffer pointed to by <i>pszUniqueName</i>.
     * @param {Pointer<Char>} pszTemplate Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains a template that is used to construct the unique name. This template is used for drives that require file names with the 8.3 format. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @param {Pointer<Char>} pszLongPlate Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains a template that is used to construct the unique name. This template is used for drives that support long file names. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @param {Pointer<Char>} pszDir Type: <b>PCWSTR</b>
     * 
     * A null-terminated string that contains the directory in which the new file resides. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-pathmakeuniquename
     * @since windows5.0
     */
    static PathMakeUniqueName(pszUniqueName, cchMax, pszTemplate, pszLongPlate, pszDir) {
        pszUniqueName := pszUniqueName is String? StrPtr(pszUniqueName) : pszUniqueName
        pszTemplate := pszTemplate is String? StrPtr(pszTemplate) : pszTemplate
        pszLongPlate := pszLongPlate is String? StrPtr(pszLongPlate) : pszLongPlate
        pszDir := pszDir is String? StrPtr(pszDir) : pszDir

        result := DllCall("SHELL32.dll\PathMakeUniqueName", "ptr", pszUniqueName, "uint", cchMax, "ptr", pszTemplate, "ptr", pszLongPlate, "ptr", pszDir, "int")
        return result
    }

    /**
     * PathIsExe may be altered or unavailable.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string that contains the file path, which includes the name of the file.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the file name extension is .cmd, .bat, .pif, .scf, .exe, .com, or .scr; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-pathisexe
     * @since windows5.1.2600
     */
    static PathIsExe(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\PathIsExe", "ptr", pszPath, "int")
        return result
    }

    /**
     * PathCleanupSpec may be altered or unavailable.
     * @remarks
     * The following are considered invalid characters in all names.
     *                 
     * 
     * 
     * ```
     * \ / : * ? " < > |
     * ```
     * 
     * 
     * Control characters are also considered invalid. If long file names are not supported, the semi-colon (;) and comma (,) characters are also invalid.
     * 
     * The drive named in <i>pszDir</i> is checked to determine 
     * whether its file system supports long file names. If it does not, the name at <i>pszSpec</i> is truncated to the 8.3 format and the PCS_TRUNCATED value returned. If <i>pszDir</i> is <b>NULL</b>, the drive on which Windows is installed is used to determine long file name support.
     * 
     * If the full paththe number of characters in the path at <i>pszDir</i> plus the number of characters in the cleaned name at <i>pszSpec</i>exceeds MAX_PATH  1 (to account for the terminating null character), the function returns PCS_PATHTOOLONG.
     * @param {Pointer<Char>} pszDir Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the fully qualified path of the directory that will contain the file or directory named at <i>pszSpec</i>. The path must not exceed MAX_PATH characters in length, including the terminating null character. This path is not altered.
     *                         
     *                         
     * 
     * This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszSpec Type: <b>PWSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the file or directory name to be cleaned. In the case of a file, include the file's extension. Note that because '\' is considered an invalid character and will be removed, this buffer cannot contain a path more than one directory deep.
     *                     
     *                         
     * 
     * On exit, the buffer contains a null-terminated string that includes the cleaned name.
     * 
     * This buffer should be at least MAX_PATH characters in length to avoid the possibility of a buffer overrun.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns one or more of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_REPLACEDCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Replaced one or more invalid characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_REMOVEDCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Removed one or more invalid characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_TRUNCATED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The returned path is truncated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_PATHTOOLONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed because the input path specified at <i>pszDir</i> is too long to allow the formation of a valid file name from <i>pszSpec</i>. When this flag is returned, it is always accompanied by the PCS_FATAL flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_FATAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cleaned path is not a valid file name. This flag is always returned in conjunction with PCS_PATHTOOLONG.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-pathcleanupspec
     * @since windows5.1.2600
     */
    static PathCleanupSpec(pszDir, pszSpec) {
        pszDir := pszDir is String? StrPtr(pszDir) : pszDir
        pszSpec := pszSpec is String? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHELL32.dll\PathCleanupSpec", "ptr", pszDir, "ptr", pszSpec, "int")
        return result
    }

    /**
     * PathResolve may be altered or unavailable.
     * @remarks
     * A <b>FALSE</b> return value does not necessarily mean that the file does not exist. It might mean that the function is simply unable to find the file from the supplied information.
     * 
     * If <b>PathResolve</b> cannot resolve the path specified in <i>pszPath</i>, it calls <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-pathfindonpatha">PathFindOnPath</a> using <i>pszPath</i> and <i>dirs</i> as the parameters.
     * @param {Pointer<Char>} pszPath Type: <b>PWSTR</b>
     * 
     * A null-terminated Unicode string that contains the path to resolve. When the function returns, the string contains the corresponding fully qualified path. This buffer should be at least MAX_PATH characters long.
     * @param {Pointer<UInt16>} dirs Type: <b>PZPCWSTR</b>
     * 
     * A pointer to an optional null-terminated array of directories to be searched first in the case that the path cannot be resolved from <i>pszPath</i>. This value can be <b>NULL</b>.
     * @param {Integer} fFlags Type: <b>UINT</b>
     * 
     * Flags that specify how the function operates.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns <b>TRUE</b>, unless PRF_VERIFYEXISTS is set. If that flag is set, the function returns <b>TRUE</b> if the file is verified to exist and <b>FALSE</b> otherwise. It also sets an ERROR_FILE_NOT_FOUND error code that you can retrieve by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-pathresolve
     * @since windows5.1.2600
     */
    static PathResolve(pszPath, dirs, fFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHELL32.dll\PathResolve", "ptr", pszPath, "ptr", dirs, "uint", fFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetFileNameFromBrowse function creates an Open dialog box so that the user can specify the drive, directory, and name of a file to open.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box. This member can be any valid window handle, or it can be <b>NULL</b> if the dialog box has no owner.
     * @param {Pointer<Char>} pszFilePath Type: <b>PWSTR</b>
     * 
     * A null-terminated Unicode string that contains a file name used to initialize the File Name edit control. This string corresponds to the <a href="https://docs.microsoft.com/windows/win32/api/commdlg/ns-commdlg-openfilenamea">OPENFILENAME</a> structure's <b>lpstrFile</b> member and is used in exactly the same way.
     * @param {Integer} cchFilePath Type: <b>UINT</b>
     * 
     * The number of characters in <i>pszFilePath</i>, including the terminating null character.
     * @param {Pointer<Char>} pszWorkingDir Type: <b>PCWSTR</b>
     * 
     * The fully qualified file path of the initial directory. This string corresponds to the <a href="https://docs.microsoft.com/windows/win32/api/commdlg/ns-commdlg-openfilenamea">OPENFILENAME</a> structure's <b>lpstrInitialDir</b> member and is used in exactly the same way.
     * @param {Pointer<Char>} pszDefExt Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the default file name extension. This extension is added to <i>pszFilePath</i> if the user does not specify an extension. The string should not contain any '.' characters. If this string is <b>NULL</b> and the user fails to type an extension, no extension is appended.
     * @param {Pointer<Char>} pszFilters Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that defines the filter. This string corresponds to the <a href="https://docs.microsoft.com/windows/win32/api/commdlg/ns-commdlg-openfilenamea">OPENFILENAME</a> structure's <b>lpstrFilter</b> member and is used in exactly the same way.
     * @param {Pointer<Char>} pszTitle Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that is placed in the title bar of the dialog box. If this value is <b>NULL</b>, the system uses the default title.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the user specifies a file name and clicks <b>OK</b>, the return value is <b>TRUE</b>. The buffer that <i>pszFilePath</i> points to contains the full path and file name that the user specifies. If the user cancels or closes the <b>Open</b> dialog box or an error occurs, the return value is <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-getfilenamefrombrowse
     * @since windows5.0
     */
    static GetFileNameFromBrowse(hwnd, pszFilePath, cchFilePath, pszWorkingDir, pszDefExt, pszFilters, pszTitle) {
        pszFilePath := pszFilePath is String? StrPtr(pszFilePath) : pszFilePath
        pszWorkingDir := pszWorkingDir is String? StrPtr(pszWorkingDir) : pszWorkingDir
        pszDefExt := pszDefExt is String? StrPtr(pszDefExt) : pszDefExt
        pszFilters := pszFilters is String? StrPtr(pszFilters) : pszFilters
        pszTitle := pszTitle is String? StrPtr(pszTitle) : pszTitle

        result := DllCall("SHELL32.dll\GetFileNameFromBrowse", "ptr", hwnd, "ptr", pszFilePath, "uint", cchFilePath, "ptr", pszWorkingDir, "ptr", pszDefExt, "ptr", pszFilters, "ptr", pszTitle, "int")
        return result
    }

    /**
     * The DriveType function determines the drive type based on the drive number. (DriveType function)
     * @remarks
     * <b>DriveType</b> is equivalent to calling <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-realdrivetype">RealDriveType</a>. <b>RealDriveType</b> is the preferred function.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * The number of the drive that you want to test. "A:" corresponds to 0, "B:" to 1, and so on.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_UNKNOWN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive type cannot be determined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_NO_ROOT_DIR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The root path is invalid. For example, no volume is mounted at the path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOVABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disk can be removed from the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_FIXED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disk cannot be removed from the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a remote (network) drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_CDROM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a CD-ROM drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_RAMDISK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a RAM disk.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-drivetype
     * @since windows5.1.2600
     */
    static DriveType(iDrive) {
        result := DllCall("SHELL32.dll\DriveType", "int", iDrive, "int")
        return result
    }

    /**
     * RealDriveType may be altered or unavailable.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * The number of the drive that you want to test. "A:" corresponds to 0, "B:" to 1, and so on.
     * @param {Integer} fOKToHitNet Type: <b>BOOL</b>
     * 
     * Reserved. Must be set to 0.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_UNKNOWN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive type cannot be determined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_NO_ROOT_DIR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The root path is invalid. For example, no volume is mounted at the path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOVABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disk can be removed from the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_FIXED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disk cannot be removed from the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a remote (network) drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_CDROM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a CD-ROM drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_RAMDISK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a RAM disk.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-realdrivetype
     * @since windows5.1.2600
     */
    static RealDriveType(iDrive, fOKToHitNet) {
        result := DllCall("SHELL32.dll\RealDriveType", "int", iDrive, "int", fOKToHitNet, "int")
        return result
    }

    /**
     * Tests whether a drive is a network drive.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * An integer that indicates which drive letter you want to test. Set it to 0 for  A:, 1 for B:, and so on.
     * @returns {Integer} Type: <b>int</b>
     * 
     * This function returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is not a network drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is a network drive that is properly connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is a network drive that is disconnected or in an error state.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-isnetdrive
     * @since windows5.0
     */
    static IsNetDrive(iDrive) {
        result := DllCall("SHELL32.dll\IsNetDrive", "int", iDrive, "int")
        return result
    }

    /**
     * Shell_MergeMenus may be altered or unavailable.
     * @param {Pointer<Void>} hmDst Type: <b>HMENU</b>
     * 
     * The destination menu to which <i>hmSrc</i> is added.
     * @param {Pointer<Void>} hmSrc Type: <b>HMENU</b>
     * 
     * The source menu which is added to <i>hmDst</i>.
     * @param {Integer} uInsert Type: <b>UINT</b>
     * 
     * The point in <i>hmDst</i> after which the entries in <i>hmSrc</i> are inserted.
     * @param {Integer} uIDAdjust Type: <b>UINT</b>
     * 
     * This number is added to each menu's ID to give an adjusted ID. Set to <c>0</c> for no adjustment. The value for <i>uIDAdjust</i> would typically be the number of items in <i>hmDst</i>. This number can be obtained using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmenuitemcount">GetMenuItemCount</a>.
     * @param {Integer} uIDAdjustMax Type: <b>UINT</b>
     * 
     * The maximum adjusted ID to add to the menu. Any adjusted ID greater than this value is not added. To allow all IDs, set this parameter to 0xFFFF.
     * @param {Integer} uFlags Type: <b>ULONG</b>
     * 
     * One or more of the following flags.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * Returns the next open ID at the end of the menu (the maximum adjusted ID + 1).
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shell_mergemenus
     * @since windows5.1.2600
     */
    static Shell_MergeMenus(hmDst, hmSrc, uInsert, uIDAdjust, uIDAdjustMax, uFlags) {
        result := DllCall("SHELL32.dll\Shell_MergeMenus", "ptr", hmDst, "ptr", hmSrc, "uint", uInsert, "uint", uIDAdjust, "uint", uIDAdjustMax, "uint", uFlags, "uint")
        return result
    }

    /**
     * SHObjectProperties may be altered or unavailable.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window of the dialog box. This value can be <b>NULL</b>.
     * @param {Integer} shopObjectType Type: <b>DWORD</b>
     * 
     * A flag value that specifies the type of object.
     * @param {Pointer<Char>} pszObjectName Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the object name. The contents of the string are determined by the flag set in <i>shopObjectType</i>.
     * @param {Pointer<Char>} pszPropertyPage Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the name of the property sheet page to be opened initially. Set this parameter to <b>NULL</b> to specify the default page.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the command is successfully invoked; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shobjectproperties
     * @since windows5.1.2600
     */
    static SHObjectProperties(hwnd, shopObjectType, pszObjectName, pszPropertyPage) {
        pszObjectName := pszObjectName is String? StrPtr(pszObjectName) : pszObjectName
        pszPropertyPage := pszPropertyPage is String? StrPtr(pszPropertyPage) : pszPropertyPage

        result := DllCall("SHELL32.dll\SHObjectProperties", "ptr", hwnd, "uint", shopObjectType, "ptr", pszObjectName, "ptr", pszPropertyPage, "int")
        return result
    }

    /**
     * SHFormatDrive may be altered or unavailable.
     * @remarks
     * The format is controlled by the dialog box interface. That is, the user must click the <b>OK</b> button to actually begin the formatthe format cannot be started programmatically.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window of the dialog box. The <b>Format</b> dialog box must have a parent window; therefore, this parameter cannot be <b>NULL</b>.
     * @param {Integer} drive Type: <b>UINT</b>
     * 
     * The drive to format. The value of this parameter represents a letter drive starting at 0 for the A: drive. For example, a value of 2 stands for the C: drive.
     * @param {Integer} fmtID Type: <b>UINT</b>
     * 
     * The ID of the physical format. Only the following flag is currently defined.
     * @param {Integer} options Type: <b>UINT</b>
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns the format ID of the last successful format or one of the following values. The LOWORD of this value can be passed on subsequent calls as the <i>fmtID</i> parameter to repeat the last format.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SHFMT_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred during the last format. This does not indicate that the drive is unformattable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SHFMT_CANCEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The last format was canceled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SHFMT_NOFORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive cannot be formatted.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shformatdrive
     * @since windows5.1.2600
     */
    static SHFormatDrive(hwnd, drive, fmtID, options) {
        result := DllCall("SHELL32.dll\SHFormatDrive", "ptr", hwnd, "uint", drive, "uint", fmtID, "uint", options, "uint")
        return result
    }

    /**
     * Frees property sheet handlers that are pointed to an array created by SHCreatePropSheetExtArray.
     * @param {Pointer<Void>} hpsxa Type: <b>HPSXA</b>
     * 
     * The handle of the array that contains pointers to the property sheet handlers to destroy.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shdestroypropsheetextarray
     * @since windows5.1.2600
     */
    static SHDestroyPropSheetExtArray(hpsxa) {
        DllCall("SHELL32.dll\SHDestroyPropSheetExtArray", "ptr", hpsxa)
    }

    /**
     * Adds pages to a property sheet extension array created by SHCreatePropSheetExtArray.
     * @remarks
     * This function should be called only once for the property sheet extension array named in <i>hpsxa</i>.
     * 
     * This function calls each extension's <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellpropsheetext-addpages">IShellPropSheetExt::AddPages</a> method. See that page for further details.
     * @param {Pointer<Void>} hpsxa Type: <b>HPSXA</b>
     * 
     * The array of property sheet handlers returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj/nf-shlobj-shcreatepropsheetextarray">SHCreatePropSheetExtArray</a>.
     * @param {Pointer<LPFNSVADDPROPSHEETPAGE>} lpfnAddPage Type: <b>LPFNADDPROPSHEETPAGE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/prsht/nc-prsht-lpfnaddpropsheetpage">AddPropSheetPageProc</a> callback function. It is called once for each property sheet handler. The callback function then returns the information needed to add a page to the handler's property sheet.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * A pointer to application-defined data. This data is passed to the callback function specified by <i>lpfnAddPage</i>.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * Returns the number of pages actually added.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shaddfrompropsheetextarray
     * @since windows5.0
     */
    static SHAddFromPropSheetExtArray(hpsxa, lpfnAddPage, lParam) {
        result := DllCall("SHELL32.dll\SHAddFromPropSheetExtArray", "ptr", hpsxa, "ptr", lpfnAddPage, "ptr", lParam, "uint")
        return result
    }

    /**
     * Requests each property sheet in a property sheet extension array to replace pages. Each page is allowed up to one replacement.
     * @param {Pointer<Void>} hpsxa Type: <b>HPSXA</b>
     * 
     * A property sheet array handle (HPSXA) returned from a call to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj/nf-shlobj-shcreatepropsheetextarray">SHCreatePropSheetExtArray</a>.
     * @param {Integer} uPageID Type: <b>UINT</b>
     * 
     * The ID of the page to replace.
     * @param {Pointer<LPFNSVADDPROPSHEETPAGE>} lpfnReplaceWith Type: <b>LPFNADDPROPSHEETPAGE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/prsht/nc-prsht-lpfnaddpropsheetpage">AddPropSheetPageProc</a> function used by the property sheet extension to add a page to a property sheet.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * An application-defined value.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * The number of replacements actually performed.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shreplacefrompropsheetextarray
     * @since windows5.1.2600
     */
    static SHReplaceFromPropSheetExtArray(hpsxa, uPageID, lpfnReplaceWith, lParam) {
        result := DllCall("SHELL32.dll\SHReplaceFromPropSheetExtArray", "ptr", hpsxa, "uint", uPageID, "ptr", lpfnReplaceWith, "ptr", lParam, "uint")
        return result
    }

    /**
     * OpenRegStream may be altered or unavailable. Instead, use SHOpenRegStream2 or SHOpenRegStream.
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the key that is currently open.
     * @param {Pointer<Char>} pszSubkey Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that specifies the name of the subkey.
     * @param {Pointer<Char>} pszValue Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that specifies the value to be accessed.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {Pointer<IStream>} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns the address of an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-openregstream
     * @since windows5.1.2600
     */
    static OpenRegStream(hkey, pszSubkey, pszValue, grfMode) {
        pszSubkey := pszSubkey is String? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHELL32.dll\OpenRegStream", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * SHFindFiles may be altered or unavailable.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The folder from which to start the search. This folder appears in the <b>Look in:</b> box in the <b>Search</b> window. This folder and all of its subfolders are searched unless users choose other options in the <b>Search</b> window's <b>More Advanced Options</b>. This value can be <b>NULL</b>.
     * @param {Pointer<ITEMIDLIST>} pidlSaveFile Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * This parameter is not used and must be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A saved search file (.fnd) to load. You can save search parameters to a .fnd file after the search is begun. This value can be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful in displaying the <b>Search</b> window; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shfindfiles
     * @since windows5.1.2600
     */
    static SHFindFiles(pidlFolder, pidlSaveFile) {
        result := DllCall("SHELL32.dll\SHFindFiles", "ptr", pidlFolder, "ptr", pidlSaveFile, "int")
        return result
    }

    /**
     * PathGetShortPath may be altered or unavailable.
     * @param {Pointer<Char>} pszLongPath Type: <b>PWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string that contains the long path. When the function returns, it contains the equivalent short path.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-pathgetshortpath
     * @since windows5.1.2600
     */
    static PathGetShortPath(pszLongPath) {
        pszLongPath := pszLongPath is String? StrPtr(pszLongPath) : pszLongPath

        DllCall("SHELL32.dll\PathGetShortPath", "ptr", pszLongPath)
    }

    /**
     * Creates a unique filename based on an existing filename.
     * @remarks
     * If the generated path exceeds MAX_PATH characters, this function may return a truncated string in <b>PathYetAnotherMakeUniqueName</b>. In that case, the function returns <b>FALSE</b>.
     * @param {Pointer<Char>} pszUniqueName Type: <b>PWSTR</b>
     * 
     * A string buffer that receives a null-terminated Unicode string that contains the fully qualified path of the unique file name. This buffer should be at least MAX_PATH characters long to avoid causing a buffer overrun.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the fully qualified path of folder that will contain the new file. If <i>pszShort</i> is set to <b>NULL</b>, this string must contain a full destination path, ending with the long file name that the new file name will be base on.
     * @param {Pointer<Char>} pszShort Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the short file name that the unique name will be based on. Set this value to <b>NULL</b> to create a name based on the long file name.
     * @param {Pointer<Char>} pszFileSpec Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the long file name that the unique name will be based on.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a unique name was successfully created; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-pathyetanothermakeuniquename
     * @since windows5.0
     */
    static PathYetAnotherMakeUniqueName(pszUniqueName, pszPath, pszShort, pszFileSpec) {
        pszUniqueName := pszUniqueName is String? StrPtr(pszUniqueName) : pszUniqueName
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszShort := pszShort is String? StrPtr(pszShort) : pszShort
        pszFileSpec := pszFileSpec is String? StrPtr(pszFileSpec) : pszFileSpec

        result := DllCall("SHELL32.dll\PathYetAnotherMakeUniqueName", "ptr", pszUniqueName, "ptr", pszPath, "ptr", pszShort, "ptr", pszFileSpec, "int")
        return result
    }

    /**
     * Win32DeleteFile may be altered or unavailable.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a buffer that contains the full name of the file to delete.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the file was successfully deleted; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-win32deletefile
     * @since windows5.1.2600
     */
    static Win32DeleteFile(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\Win32DeleteFile", "ptr", pszPath, "int")
        return result
    }

    /**
     * SHRestricted may be altered or unavailable.
     * @param {Integer} rest Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-restrictions">RESTRICTIONS</a></b>
     * 
     * Specifies one of the flags described in the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-restrictions">RESTRICTIONS</a> enumerated type.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns nonzero if the specified restriction is in effect, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shrestricted
     * @since windows5.1.2600
     */
    static SHRestricted(rest) {
        result := DllCall("SHELL32.dll\SHRestricted", "int", rest, "uint")
        return result
    }

    /**
     * SignalFileOpen may be altered or unavailable.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A PIDL that specifies the file.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-signalfileopen
     * @since windows5.1.2600
     */
    static SignalFileOpen(pidl) {
        result := DllCall("SHELL32.dll\SignalFileOpen", "ptr", pidl, "int")
        return result
    }

    /**
     * Retrieves the value for a given property key using the file association information provided by the Namespace Extensions.
     * @remarks
     * This function is to be used only by implementers of 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> <a href="https://docs.microsoft.com/windows/desktop/shell/nse-works">Namespace Extensions</a>. Other calling applications should use 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder2-getdetailsex">IShellFolder2::GetDetailsEx</a> to get a value 
     *      for a <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ns-wtypes-propertykey">PROPERTYKEY</a>. This function is to be used by 
     *      implementers of <b>IShellFolder</b> Namespace Extensions.
     * 
     * The provided namespace extension must support the use of this API in one of the following three ways.
     * 
     * <ol>
     * <li>If the provided <a href="https://docs.microsoft.com/windows/desktop/shell/nse-works">Namespace Extensions</a> supports retrieving an <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface for the item by implementing <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof">IShellFolder::GetUIObjectOf</a>(..., <b>IID_IQueryAssociations</b>, ...), then <b>AssocGetDetailsOfPropKey</b> will use the provided file associations API to retrieve the value for the property key.</li>
     * <li>If the provided namespace extension returns <b>SFGAO_FILESYSTEM</b> for the item from <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">IShellFolder::GetAttributesOf</a> and provides a parsing name for the item, then <b>AssocGetDetailsOfPropKey</b> will use the standard file system associations to retrieve the value for the property key.</li>
     * <li>If the provided namespace extension returns <b>SFGAO_FOLDER</b> | <b>SFGAO_BROWSABLE</b> for the item from <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">IShellFolder::GetAttributesOf</a>, then <b>AssocGetDetailsOfPropKey</b> will use the file association for folders (<b>ASSOCCLASS_FOLDER</b>) to retrieve the value for the property key.</li>
     * </ol>
     * If the ShellFolder being implemented contains items that are extensible through the file associations mechanism, then you can use this function to retrieve <b>PropertyKeys</b> that are declared for a given file association. For example, if a given Shell folder drives a details pane and you want the properties displayed in that pane to be governed by third party file name extensions, then you can use this function to return <b>PKEY_PropList_PreviewDetails</b>.  This key has a value that is declared in the registry for that file name extension with a semicolon delimited list of properties. There is a list of file name extension defined properties in the registry. This list includes but is not limited to the following:
     * 
     * <ul>
     * <li><b>PKEY_PropList_PreviewDetails</b></li>
     * <li><b>PKEY_PropList_PreviewTitle</b></li>
     * <li><b>PKEY_PropList_FullDetails</b></li>
     * <li><b>PKEY_PropList_TileInfo</b></li>
     * <li><b>PKEY_PropList_ExtendedTileInfo</b></li>
     * <li><b>PKEY_PropList_InfoTip</b></li>
     * <li><b>PKEY_PropList_QuickTip</b></li>
     * <li><b>PKEY_PropList_FileOperationPrompt</b></li>
     * <li><b>PKEY_PropList_ConflictPrompt</b></li>
     * <li><b>PKEY_PropList_SetDefaultsFor</b></li>
     * <li><b>PKEY_PropList_NonPersonal</b></li>
     * <li><b>PKEY_NewMenuPreferredTypes</b></li>
     * <li><b>PKEY_NewMenuAllowedTypes</b></li>
     * </ul>
     * @param {Pointer<IShellFolder>} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to the shell folder for which the details of the property key of the file association are being retrieved.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * The PIDL of the child item for which the file associations are being requested.
     * @param {Pointer<PROPERTYKEY>} pkey Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ns-wtypes-propertykey">PROPERTYKEY</a>*</b>
     * 
     * A pointer to the property key that is being retrieved.
     * @param {Pointer<VARIANT>} pv Type: <b>VARIANT*</b>
     * 
     * When this function returns, contains the details of the given property key.
     * @param {Pointer<Int32>} pfFoundPropKey Type: <b>BOOL*</b>
     * 
     * When this function returns, contains a flag that is <b>TRUE</b> if the property key was found, otherwise <b>FALSE</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-assocgetdetailsofpropkey
     * @since windows6.0.6000
     */
    static AssocGetDetailsOfPropKey(psf, pidl, pkey, pv, pfFoundPropKey) {
        result := DllCall("SHELL32.dll\AssocGetDetailsOfPropKey", "ptr", psf, "ptr", pidl, "ptr", pkey, "ptr", pv, "int*", pfFoundPropKey, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHStartNetConnectionDialog may be altered or unavailable. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlobj_core.h header defines SHStartNetConnectionDialog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {Pointer<Char>} pszRemoteName Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated character string that specifies the remote network name. This value can be set to <b>NULL</b>.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Always returns S_OK.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shstartnetconnectiondialogw
     * @since windows5.1.2600
     */
    static SHStartNetConnectionDialogW(hwnd, pszRemoteName, dwType) {
        pszRemoteName := pszRemoteName is String? StrPtr(pszRemoteName) : pszRemoteName

        result := DllCall("SHELL32.dll\SHStartNetConnectionDialogW", "ptr", hwnd, "ptr", pszRemoteName, "uint", dwType, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Provides a default handler to extract an icon from a file. (ANSI)
     * @remarks
     * It is the responsibility of the caller to free the icon resources created through this function when they are no longer needed. This can be done through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHDefExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszIconFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.
     * @param {Integer} iIndex Type: <b>int</b>
     * 
     * The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * A flag that controls the icon extraction.
     * @param {Pointer<Void>} phiconLarge Type: <b>HICON*</b>
     * 
     * A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.
     * @param {Pointer<Void>} phiconSmall Type: <b>HICON*</b>
     * 
     * A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.
     * @param {Integer} nIconSize Type: <b>UINT</b>
     * 
     * A value that contains the large icon size in its <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * This function can return one of these values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Success.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested icon is not present.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file cannot be accessed, or is being accessed through a slow link.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shdefextracticona
     * @since windows5.1.2600
     */
    static SHDefExtractIconA(pszIconFile, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize) {
        pszIconFile := pszIconFile is String? StrPtr(pszIconFile) : pszIconFile

        result := DllCall("SHELL32.dll\SHDefExtractIconA", "ptr", pszIconFile, "int", iIndex, "uint", uFlags, "ptr", phiconLarge, "ptr", phiconSmall, "uint", nIconSize, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Provides a default handler to extract an icon from a file. (Unicode)
     * @remarks
     * It is the responsibility of the caller to free the icon resources created through this function when they are no longer needed. This can be done through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHDefExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszIconFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.
     * @param {Integer} iIndex Type: <b>int</b>
     * 
     * The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * A flag that controls the icon extraction.
     * @param {Pointer<Void>} phiconLarge Type: <b>HICON*</b>
     * 
     * A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.
     * @param {Pointer<Void>} phiconSmall Type: <b>HICON*</b>
     * 
     * A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.
     * @param {Integer} nIconSize Type: <b>UINT</b>
     * 
     * A value that contains the large icon size in its <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * This function can return one of these values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Success.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested icon is not present.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file cannot be accessed, or is being accessed through a slow link.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shdefextracticonw
     * @since windows5.1.2600
     */
    static SHDefExtractIconW(pszIconFile, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize) {
        pszIconFile := pszIconFile is String? StrPtr(pszIconFile) : pszIconFile

        result := DllCall("SHELL32.dll\SHDefExtractIconW", "ptr", pszIconFile, "int", iIndex, "uint", uFlags, "ptr", phiconLarge, "ptr", phiconSmall, "uint", nIconSize, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Displays the Open With dialog box.
     * @remarks
     * Starting in Windows10, the <b>OAIF_ALLOW_REGISTRATION</b>, <b>OAIF_FORCE_REGISTRATION</b>, and <b>OAIF_HIDE_REGISTRATION</b> flags will be ignored by <b>SHOpenWithDialog</b>. The <b>Open With</b> dialog box can no longer be used to change the default program used to open a file extension. You can only use <b>SHOpenWithDialog</b> to open a single file.
     * 
     * If <b>SHOpenWithDialog</b> is called without passing <b>OAIF_EXEC</b>, the user will receive a dialog that informs them that they can change the default programs used to open file extensions in their <b>Settings</b>.
     * @param {Pointer<Void>} hwndParent Type: <b>HWND</b>
     * 
     * The handle of the parent window. This value can be <b>NULL</b>.
     * @param {Pointer<OPENASINFO>} poainfo Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-openasinfo">OPENASINFO</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-openasinfo">OPENASINFO</a> structure, which specifies the contents of the resulting dialog.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shopenwithdialog
     * @since windows6.0.6000
     */
    static SHOpenWithDialog(hwndParent, poainfo) {
        result := DllCall("SHELL32.dll\SHOpenWithDialog", "ptr", hwndParent, "ptr", poainfo, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves system image lists for large and small icons.
     * @remarks
     * <div class="alert"><b>Important</b>The image lists retrieved through this function are global system image lists; do not call <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-imagelist_destroy">ImageList_Destroy</a> using them.</div>
     * <div></div>
     * @param {Pointer<IntPtr>} phiml Type: <b>HIMAGELIST*</b>
     * 
     * A pointer to the handle of an image list which, on success, receives the system image list for large (32 x 32) icons.
     * @param {Pointer<IntPtr>} phimlSmall Type: <b>HIMAGELIST*</b>
     * 
     * A pointer to the handle of an image list which, on success, receives the system image list for small (16 x 16) icons.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> on success. On failure, returns <b>FALSE</b> and the image lists pointed to by <i>phiml</i> and <i>phimlSmall</i> are unchanged.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shell_getimagelists
     * @since windows5.1.2600
     */
    static Shell_GetImageLists(phiml, phimlSmall) {
        result := DllCall("SHELL32.dll\Shell_GetImageLists", "ptr*", phiml, "ptr*", phimlSmall, "int")
        return result
    }

    /**
     * Shell_GetCachedImageIndex may be altered or unavailable.
     * @remarks
     * The <b>Shell_GetCachedImageIndexA</b> and <b>Shell_GetCachedImageIndexW</b> versions of this function were added in WindowsVista. For Unicode strings, call either <b>Shell_GetCachedImageIndexW</b> or <b>Shell_GetCachedImageIndex</b>. For ANSI strings, you must call <b>Shell_GetCachedImageIndexA</b> explicitly.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>Only <b>Shell_GetCachedImageIndex</b> is supported. <b>Shell_GetCachedImageIndex</b> requires a Unicode string.
     * @param {Pointer<Char>} pwszIconPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a buffer that contains the path to the image file.
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The index of the image within the file named at <i>pwszIconPath</i>.
     * @param {Integer} uIconFlags Type: <b>UINT</b>
     * 
     * Not used.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the image, or 1 on failure.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shell_getcachedimageindex
     * @since windows5.1.2600
     */
    static Shell_GetCachedImageIndex(pwszIconPath, iIconIndex, uIconFlags) {
        pwszIconPath := pwszIconPath is String? StrPtr(pwszIconPath) : pwszIconPath

        result := DllCall("SHELL32.dll\Shell_GetCachedImageIndex", "ptr", pwszIconPath, "int", iIconIndex, "uint", uIconFlags, "int")
        return result
    }

    /**
     * Shell_GetCachedImageIndex may be altered or unavailable. (ANSI)
     * @remarks
     * The <b>Shell_GetCachedImageIndexA</b> and <b>Shell_GetCachedImageIndexW</b> versions of this function were added in WindowsVista. For Unicode strings, call either <b>Shell_GetCachedImageIndexW</b> or <b>Shell_GetCachedImageIndex</b>. For ANSI strings, you must call <b>Shell_GetCachedImageIndexA</b> explicitly.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>Only <b>Shell_GetCachedImageIndex</b> is supported. <b>Shell_GetCachedImageIndex</b> requires a Unicode string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines Shell_GetCachedImageIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszIconPath TBD
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The index of the image within the file named at <i>pwszIconPath</i>.
     * @param {Integer} uIconFlags Type: <b>UINT</b>
     * 
     * Not used.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the image, or 1 on failure.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shell_getcachedimageindexa
     * @since windows5.1.2600
     */
    static Shell_GetCachedImageIndexA(pszIconPath, iIconIndex, uIconFlags) {
        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\Shell_GetCachedImageIndexA", "ptr", pszIconPath, "int", iIconIndex, "uint", uIconFlags, "int")
        return result
    }

    /**
     * Shell_GetCachedImageIndex may be altered or unavailable. (Unicode)
     * @remarks
     * The <b>Shell_GetCachedImageIndexA</b> and <b>Shell_GetCachedImageIndexW</b> versions of this function were added in WindowsVista. For Unicode strings, call either <b>Shell_GetCachedImageIndexW</b> or <b>Shell_GetCachedImageIndex</b>. For ANSI strings, you must call <b>Shell_GetCachedImageIndexA</b> explicitly.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>Only <b>Shell_GetCachedImageIndex</b> is supported. <b>Shell_GetCachedImageIndex</b> requires a Unicode string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines Shell_GetCachedImageIndex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszIconPath TBD
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The index of the image within the file named at <i>pwszIconPath</i>.
     * @param {Integer} uIconFlags Type: <b>UINT</b>
     * 
     * Not used.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the image, or 1 on failure.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shell_getcachedimageindexw
     * @since windows5.1.2600
     */
    static Shell_GetCachedImageIndexW(pszIconPath, iIconIndex, uIconFlags) {
        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\Shell_GetCachedImageIndexW", "ptr", pszIconPath, "int", iIconIndex, "uint", uIconFlags, "int")
        return result
    }

    /**
     * SHValidateUNC may be altered or unavailable.
     * @param {Pointer<Void>} hwndOwner Type: <b>HWND</b>
     * 
     * Handle of the parent window, used to display UI. If this is not needed, this value can be set to <b>NULL</b>.
     * @param {Pointer<Char>} pszFile Type: <b>PWSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that specifies the UNC path to validate. Note: This string must not be a constant string.
     * @param {Integer} fConnect Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the UNC path exists; <b>FALSE</b> if the UNC path does not exist or if some other failure occurred.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shvalidateunc
     * @since windows5.1.2600
     */
    static SHValidateUNC(hwndOwner, pszFile, fConnect) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHELL32.dll\SHValidateUNC", "ptr", hwndOwner, "ptr", pszFile, "uint", fConnect, "int")
        return result
    }

    /**
     * Provides an interface that allows hosted Shell extensions and other components to prevent their host process from closing prematurely.
     * @remarks
     * Windows Explorer and Internet Explorer can use <b>SHSetInstanceExplorer</b> to allow components such as Shell extensions to extend the lifetime of the process. Other applications can also use <b>SHSetInstanceExplorer</b> to allow for the same capability. For instance, the browser message loop and the proxy desktop use <b>SHSetInstanceExplorer</b> to let other threads extend their lifetime.
     * 
     * Applications other than Windows Explorer and Internet Explorer that call this function might encounter compatibility problems because some components use <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer">SHGetInstanceExplorer</a> to detect whether they are being hosted from within Windows Explorer or Internet Explorer.
     * 
     * The interface pointer passed to <b>SHSetInstanceExplorer</b> must reference a free-threaded object.
     * 
     * Each time a component calls <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer">SHGetInstanceExplorer</a>, the system calls the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> method before returning the interface pointer to the calling component. The component then calls the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> method when processing is complete. The process that calls <b>SHSetInstanceExplorer</b> must not terminate while the reference count of the provided interface pointer is nonzero.
     * 
     * For further information on how components use the process references, see <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer">SHGetInstanceExplorer</a>.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to a free-threaded <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>. Components can use this interface (through <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer">SHGetInstanceExplorer</a>) to prevent the host process from terminating. This value can be <b>NULL</b>, in which case the process reference is no longer made available to components.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shsetinstanceexplorer
     * @since windows5.1.2600
     */
    static SHSetInstanceExplorer(punk) {
        DllCall("SHELL32.dll\SHSetInstanceExplorer", "ptr", punk)
    }

    /**
     * IsUserAnAdmin may be altered or unavailable.
     * @remarks
     * This function is a wrapper for <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-checktokenmembership">CheckTokenMembership</a>. It is recommended to call that function directly to determine Administrator group status rather than calling  <b>IsUserAnAdmin</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the user is a member of the Administrator's group; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-isuseranadmin
     * @since windows5.1.2600
     */
    static IsUserAnAdmin() {
        result := DllCall("SHELL32.dll\IsUserAnAdmin", "int")
        return result
    }

    /**
     * SHShellFolderView_Message may be altered or unavailable.
     * @param {Pointer<Void>} hwndMain Type: <b>HWND</b>
     * 
     * A handle to the window that receives the message.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to send. The following is a list of possible messages.
     * 
     * 						
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Message</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/samples-usingimagefactory">SFVM_ADDOBJECT</a>
     * </td>
     * <td>Adds an object to the shell view.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-getselectedobjects">SFVM_GETSELECTEDOBJECTS</a>
     * </td>
     * <td>Retrieves an array of PIDLs for all selected objects.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-rearrange">SFVM_REARRANGE</a>
     * </td>
     * <td>Notifies the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> to rearrange its items.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-removeobject">SFVM_REMOVEOBJECT</a>
     * </td>
     * <td>Removes an object from the shell view.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-setclipboard">SFVM_SETCLIPBOARD</a>
     * </td>
     * <td>Notifies the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> when one of its objects is placed on the clipboard as a result of a menu command.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-setitempos">SFVM_SETITEMPOS</a>
     * </td>
     * <td>Sets the position of an item in the shell view.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-setpoints">SFVM_SETPOINTS</a>
     * </td>
     * <td>Sets the points of the currently selected objects to the data object on <b>copy</b> and <b>cut</b> commands.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-updateobject">SFVM_UPDATEOBJECT</a>
     * </td>
     * <td>Updates an object by passing a pointer to an array of two PIDLs.</td>
     * </tr>
     * </table>
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Contents of this value depend on the message passed in <i>uMsg</i>. See individual message topics for more information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value depends on the message passed in <i>uMsg</i>. See individual message topics for more information.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shshellfolderview_message
     * @since windows5.1.2600
     */
    static SHShellFolderView_Message(hwndMain, uMsg, lParam) {
        result := DllCall("SHELL32.dll\SHShellFolderView_Message", "ptr", hwndMain, "uint", uMsg, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Creates a new instance of the default Shell folder view object (DefView).
     * @remarks
     * <b>SHCreateShellFolderView</b> is recommended over <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreateshellfolderviewex">SHCreateShellFolderViewEx</a> because of the greater flexibility of its elements to participate in various scenarios, provide new functionality to the view, and interact with other objects.
     * 
     * When dealing with several instances of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a>, you might want to verify which is the default Shell folder view object. To do so, call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">QueryInterface</a> on the object using the IID_CDefView IID. This call succeeds only when made on the default Shell folder view object.
     * 
     * Data sources that use the default Shell folder view object must implement these interfaces:
     *                 
     *                 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder2">IShellFolder2</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder">IPersistFolder</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder2">IPersistFolder2</a>
     * </li>
     * </ul>
     * Optionally, they can also implement <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder3">IPersistFolder3</a>.
     * @param {Pointer<SFV_CREATE>} pcsfv Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-sfv_create">SFV_CREATE</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-sfv_create">SFV_CREATE</a> structure that describes the particulars used in creating this instance of the Shell folder view object.
     * @param {Pointer<IShellView>} ppsv Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a>**</b>
     * 
     * When this function returns successfully, contains an interface pointer to the new <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> object. On failure, this value is <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreateshellfolderview
     * @since windows5.0
     */
    static SHCreateShellFolderView(pcsfv, ppsv) {
        result := DllCall("SHELL32.dll\SHCreateShellFolderView", "ptr", pcsfv, "ptr", ppsv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a context menu for a selected group of file folder objects.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure for the parent folder. This value can be <b>NULL</b>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window. This value can be <b>NULL</b>.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures in the array pointed to by <i>apidl</i>.
     * @param {Pointer<ITEMIDLIST>} apidl Type: <b>PCUITEMID_CHILD_ARRAY*</b>
     * 
     * A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures, one for each item that is selected.
     * @param {Pointer<IShellFolder>} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to the parent folder's <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface. This <b>IShellFolder</b> must support the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface. If it does not, <b>CDefFolderMenu_Create2</b> fails and returns E_NOINTERFACE. This value can be <b>NULL</b>.
     * @param {Pointer<LPFNDFMCALLBACK>} pfn Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nc-shlobj_core-lpfndfmcallback">LPFNDFMCALLBACK</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nc-shlobj_core-lpfndfmcallback">LPFNDFMCALLBACK</a> callback object. This value can be <b>NULL</b> if the callback object is not needed.
     * @param {Integer} nKeys Type: <b>UINT</b>
     * 
     * The number of registry keys in the array pointed to by <i>ahkeys</i>.
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>The maximum number of registry keys is 16. Callers must enforce this limit as the API does not. Failing to do so can result in memory corruption.</div>
     * <div></div>
     * @param {Pointer<Void>} ahkeys Type: <b>const HKEY*</b>
     * 
     * A pointer to an array of registry keys that specify the context menu handlers used with the menu's entries. For more information on context menu handlers, see <a href="https://docs.microsoft.com/windows/desktop/shell/context-menu-handlers">Creating Context Menu Handlers</a>. This array can contain a maximum of 16 registry keys.
     * @param {Pointer<IContextMenu>} ppcm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a>**</b>
     * 
     * The address of an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> interface pointer that, when this function returns successfully, points to the <b>IContextMenu</b> object that represents the context menu.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-cdeffoldermenu_create2
     * @since windows5.0
     */
    static CDefFolderMenu_Create2(pidlFolder, hwnd, cidl, apidl, psf, pfn, nKeys, ahkeys, ppcm) {
        result := DllCall("SHELL32.dll\CDefFolderMenu_Create2", "ptr", pidlFolder, "ptr", hwnd, "uint", cidl, "ptr", apidl, "ptr", psf, "ptr", pfn, "uint", nKeys, "ptr", ahkeys, "ptr", ppcm, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates an object that represents the Shell's default context menu implementation.
     * @remarks
     * This function is typically used in the implementation of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof">IShellFolder::GetUIObjectOf</a>. <b>GetUIObjectOf</b> creates a context menu that merges <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> handlers specified by the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-defcontextmenu">DEFCONTEXTMENU</a> structure, and can optionally provide default context menu verb implementations such as open, explore, delete, and copy.
     * 
     * The operation of this function is controlled by the input specified in the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-defcontextmenu">DEFCONTEXTMENU</a> structure.The API<a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-cdeffoldermenu_create2">CDefFolderMenu_Create2</a> is another way to construct the default context menu implementation. It is less expressive than <b>SHCreateDefaultContextMenu</b> but it exists in platforms prior to WindowsVista.
     * @param {Pointer<DEFCONTEXTMENU>} pdcm Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-defcontextmenu">DEFCONTEXTMENU</a>*</b>
     * 
     * A pointer to a constant <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-defcontextmenu">DEFCONTEXTMENU</a> structure.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the interface ID of the interface on which to base the object. This is typically the IID of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a>, <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu2">IContextMenu2</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu3">IContextMenu3</a>.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreatedefaultcontextmenu
     * @since windows6.0.6000
     */
    static SHCreateDefaultContextMenu(pdcm, riid, ppv) {
        result := DllCall("SHELL32.dll\SHCreateDefaultContextMenu", "ptr", pdcm, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHFind_InitMenuPopup may be altered or unavailable.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * The handle of the popup menu.
     * @param {Pointer<Void>} hwndOwner Type: <b>HWND</b>
     * 
     * The handle of the popup menu's owner window. This value can be <b>NULL</b>.
     * @param {Integer} idCmdFirst Type: <b>UINT</b>
     * 
     * The ID of the first menu item.
     * @param {Integer} idCmdLast Type: <b>UINT</b>
     * 
     * The ID of the last menu item.
     * @returns {Pointer<IContextMenu>} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a>*</b>
     * 
     * If successful, returns an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> pointer. On failure, returns <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shfind_initmenupopup
     * @since windows5.1.2600
     */
    static SHFind_InitMenuPopup(hmenu, hwndOwner, idCmdFirst, idCmdLast) {
        result := DllCall("SHELL32.dll\SHFind_InitMenuPopup", "ptr", hmenu, "ptr", hwndOwner, "uint", idCmdFirst, "uint", idCmdLast, "ptr")
        return result
    }

    /**
     * Creates a new instance of the default Shell folder view object. It is recommended that you use SHCreateShellFolderView rather than this function.
     * @remarks
     * <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreateshellfolderview">SHCreateShellFolderView</a> is recommended over <b>SHCreateShellFolderViewEx</b> because of the greater flexibility of its elements to participate in various scenarios, provide new functionality to the view, and interact with other objects.
     * 
     * When dealing with several instances of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a>, you might want to verify which is the default Shell folder view object. To do so, call <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">QueryInterface</a> on the object using IID_CDefView. This call succeeds only on the default Shell folder view object.
     * @param {Pointer<CSFV>} pcsfv Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-csfv">CSFV</a>*</b>
     * 
     * Pointer to a structure that describes the details used in creating this instance of the Shell folder view object.
     * @param {Pointer<IShellView>} ppsv Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a>**</b>
     * 
     * The address of an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> interface pointer that, when this function returns successfully, points to the new view object. On failure, this value is <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreateshellfolderviewex
     * @since windows5.0
     */
    static SHCreateShellFolderViewEx(pcsfv, ppsv) {
        result := DllCall("SHELL32.dll\SHCreateShellFolderViewEx", "ptr", pcsfv, "ptr", ppsv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHGetSetSettings may be altered or unavailable.
     * @param {Pointer<SHELLSTATEA>} lpss Type: <b>LPSHELLSTATE</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shellstatea">SHELLSTATE</a> structure that provides or receives the Shell state settings.
     * @param {Integer} dwMask Type: <b>DWORD</b>
     * 
     * One or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/ssf-constants">SSF</a> flags that indicate which settings should be set or retrieved.
     * @param {Integer} bSet Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> to indicate that the contents of <i>lpss</i> should be used to set the Shell settings, <b>FALSE</b> to indicate that the Shell settings should be retrieved to <i>lpss</i>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetsetsettings
     * @since windows5.1.2600
     */
    static SHGetSetSettings(lpss, dwMask, bSet) {
        DllCall("SHELL32.dll\SHGetSetSettings", "ptr", lpss, "uint", dwMask, "int", bSet)
    }

    /**
     * Retrieves the current Shell option settings.
     * @param {Pointer<Int32>} psfs Type: <b>LPSHELLFLAGSTATE</b>
     * 
     * The address of a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shellflagstate">SHELLFLAGSTATE</a> structure that receives the Shell option settings.
     * @param {Integer} dwMask Type: <b>DWORD</b>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetsettings
     * @since windows5.0
     */
    static SHGetSettings(psfs, dwMask) {
        DllCall("SHELL32.dll\SHGetSettings", "int*", psfs, "uint", dwMask)
    }

    /**
     * Takes a pointer to a fully qualified item identifier list (PIDL), and returns a specified interface pointer on the parent object.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The item's PIDL.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * The <b>REFIID</b> of one of the interfaces exposed by the item's parent object.
     * @param {Pointer<Void>} ppv Type: <b>VOID**</b>
     * 
     * A pointer to the interface specified by <i>riid</i>. You must release the object when you are finished.
     * @param {Pointer<ITEMIDLIST>} ppidlLast Type: <b>PCUITEMID_CHILD*</b>
     * 
     * The item's PIDL relative to the parent folder. This PIDL can be used with many of the methods supported by the parent folder's interfaces. If you set <i>ppidlLast</i> to <b>NULL</b>, the PIDL is not returned.
     * 
     * 
     * 
     * <div class="alert"><b>Note</b><b>SHBindToParent</b> does not allocate a new PIDL; it simply receives a pointer through this parameter. Therefore, you are not responsible for freeing this resource.</div>
     * <div></div>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shbindtoparent
     * @since windows5.0
     */
    static SHBindToParent(pidl, riid, ppv, ppidlLast) {
        result := DllCall("SHELL32.dll\SHBindToParent", "ptr", pidl, "ptr", riid, "ptr", ppv, "ptr", ppidlLast, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Given a Shell namespace item specified in the form of a folder, and an item identifier list relative to that folder, this function binds to the parent of the namespace item and optionally returns a pointer to the final component of the item identifier list.
     * @remarks
     * <div class="alert"><b>Note</b>Calling the <b>SHBindToFolderIDListParent</b> function is equivalent to calling the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shbindtofolderidlistparentex">SHBindToFolderIDListParentEx</a> function with <b>NULL</b> as the bind context.</div>
     * <div></div>
     * @param {Pointer<IShellFolder>} psfRoot Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to a Shell folder object. If <i>psfRoot</i> is <b>NULL</b>, indicates that the IDList passed is relative to the desktop.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A PIDL to bind to, relative to <i>psfRoot</i>. If <i>psfRoot</i> is <b>NULL</b>, this is an absolute IDList relative to the desktop folder.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired interface ID. This is typically IID_IShellFolder or IID_IShellFolder2, but can be anything supported by the target folder.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder2">IShellFolder2</a>, but can be anything supported by the target folder.
     * @param {Pointer<ITEMIDLIST>} ppidlLast Type: <b>PCUITEMID_CHILD*</b>
     * 
     * A pointer to the last ID of the <i>pidl</i> parameter, and is a child ID relative to the parent folder returned in <i>ppv</i>. This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shbindtofolderidlistparent
     * @since windows6.0.6000
     */
    static SHBindToFolderIDListParent(psfRoot, pidl, riid, ppv, ppidlLast) {
        result := DllCall("SHELL32.dll\SHBindToFolderIDListParent", "ptr", psfRoot, "ptr", pidl, "ptr", riid, "ptr", ppv, "ptr", ppidlLast, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Extends the SHBindToFolderIDListParent function by allowing the caller to specify a bind context.
     * @param {Pointer<IShellFolder>} psfRoot Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to a Shell folder object. If <i>psfRoot</i> is <b>NULL</b>, indicates that the IDList passed is relative to the desktop.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A PIDL to bind to, relative to <i>psfRoot</i>. If <i>psfRoot</i> is <b>NULL</b>, this is an absolute IDList relative to the desktop folder.
     * @param {Pointer<IBindCtx>} ppbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on a bind context object to be used during this operation. If this parameter is not used, set it to <b>NULL</b>, which is equivalent to calling the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shbindtofolderidlistparent">SHBindToFolderIDListParent</a> function. Because support for <i>pbc</i> is optional for folder object implementations, some folders may not support the use of bind contexts.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired interface ID. This is typically IID_IShellFolder or IID_IShellFolder2, but can be anything supported by the target folder.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder2">IShellFolder2</a>, but can be anything supported by the target folder.
     * @param {Pointer<ITEMIDLIST>} ppidlLast Type: <b>PCUITEMID_CHILD*</b>
     * 
     * A pointer to the last ID of the <i>pidl</i> parameter, and is a child ID relative to the parent folder returned in <i>ppv</i>. This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shbindtofolderidlistparentex
     * @since windows6.0.6000
     */
    static SHBindToFolderIDListParentEx(psfRoot, pidl, ppbc, riid, ppv, ppidlLast) {
        result := DllCall("SHELL32.dll\SHBindToFolderIDListParentEx", "ptr", psfRoot, "ptr", pidl, "ptr", ppbc, "ptr", riid, "ptr", ppv, "ptr", ppidlLast, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves and binds to a specified object by using the Shell namespace IShellFolder::BindToObject method.
     * @remarks
     * <div class="alert"><b>Note</b>This is a helper function that gets the desktop object by calling <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetdesktopfolder">SHGetDesktopFolder</a>.</div>
     * <div></div>
     * @param {Pointer<IShellFolder>} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>. This parameter can be <b>NULL</b>.   If <i>psf</i> is <b>NULL</b>,  this indicates 
     * parameter <i>pidl</i> is relative to the desktop. In this case, <i>pidl</i> must specify an absolute <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a>.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to a constant <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> to bind to that is relative to <i>psf</i>. If <i>psf</i> is <b>NULL</b>, this is an absolute <b>ITEMIDLIST</b> relative to the desktop folder.
     * @param {Pointer<IBindCtx>} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on a bind context object to be used during this operation. If this parameter is not used, set it to <b>NULL</b>. Because support for <i>pbc</i> is optional for folder object implementations, some folders may not support the use of bind contexts.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Identifier of the interface to return.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer as specified in <i>riid</i> to the bound object. If an error occurs, contains a <b>NULL</b> pointer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shbindtoobject
     * @since windows6.0.6000
     */
    static SHBindToObject(psf, pidl, pbc, riid, ppv) {
        result := DllCall("SHELL32.dll\SHBindToObject", "ptr", psf, "ptr", pidl, "ptr", pbc, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Translates a Shell namespace object's display name into an item identifier list and returns the attributes of the object. This function is the preferred method to convert a string to a pointer to an item identifier list (PIDL).
     * @remarks
     * You should call this function from a background thread. Failure to do so could cause the UI to stop responding.
     * @param {Pointer<Char>} pszName Type: <b>LPCWSTR</b>
     * 
     * A pointer to a zero-terminated wide string that contains the display name to parse.
     * @param {Pointer<IBindCtx>} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A bind context that controls the parsing operation. This parameter is normally set to <b>NULL</b>.
     * @param {Pointer<ITEMIDLIST>} ppidl Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * The address of a pointer to a variable of type <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> that receives the item identifier list for the object. If an error occurs, then this parameter is set to <b>NULL</b>.
     * @param {Integer} sfgaoIn Type: <b>SFGAOF</b>
     * 
     * A <b>ULONG</b> value that specifies the attributes to query. To query for one or more attributes, initialize this parameter with the flags that represent the attributes of interest. For a list of available SFGAO flags, see <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">IShellFolder::GetAttributesOf</a>.
     * @param {Pointer<UInt32>} psfgaoOut Type: <b>SFGAOF*</b>
     * 
     * A pointer to a <b>ULONG</b>. On return, those attributes that are true for the object and were requested in <i>sfgaoIn</i> are set. An object's attribute flags can be zero or a combination of SFGAO flags. For a list of available SFGAO flags, see <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">IShellFolder::GetAttributesOf</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shparsedisplayname
     * @since windows5.1.2600
     */
    static SHParseDisplayName(pszName, pbc, ppidl, sfgaoIn, psfgaoOut) {
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHELL32.dll\SHParseDisplayName", "ptr", pszName, "ptr", pbc, "ptr", ppidl, "uint", sfgaoIn, "uint*", psfgaoOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Checks to see if the path exists. (ANSI)
     * @remarks
     * The primary use of this function is for a program to check a path before using it and display the necessary user interface to prompt the user. For example, if the disk in drive A: were missing, a window that prompts the user to insert the disk would appear.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHPathPrepareForWrite as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.
     * @param {Pointer<IUnknown>} punkEnableModless Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface that specifies the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-ioleinplaceactiveobject">IOleInPlaceActiveObject</a> object that implements the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellview-enablemodeless">EnableModeless</a> method.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shpathprepareforwritea
     * @since windows5.0
     */
    static SHPathPrepareForWriteA(hwnd, punkEnableModless, pszPath, dwFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHPathPrepareForWriteA", "ptr", hwnd, "ptr", punkEnableModless, "ptr", pszPath, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Checks to see if the path exists. (Unicode)
     * @remarks
     * The primary use of this function is for a program to check a path before using it and display the necessary user interface to prompt the user. For example, if the disk in drive A: were missing, a window that prompts the user to insert the disk would appear.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHPathPrepareForWrite as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.
     * @param {Pointer<IUnknown>} punkEnableModless Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface that specifies the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-ioleinplaceactiveobject">IOleInPlaceActiveObject</a> object that implements the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellview-enablemodeless">EnableModeless</a> method.
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shpathprepareforwritew
     * @since windows5.0
     */
    static SHPathPrepareForWriteW(hwnd, punkEnableModless, pszPath, dwFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHPathPrepareForWriteW", "ptr", hwnd, "ptr", punkEnableModless, "ptr", pszPath, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHCreateFileExtractIcon may be altered or unavailable. (Unicode)
     * @param {Pointer<Char>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the file system object. The buffer must not exceed MAX_PATH characters in length.
     * @param {Integer} dwFileAttributes Type: <b>DWORD</b>
     * 
     * A combination of one or more file attribute flags (FILE_ATTRIBUTE_* values as defined in Winnt.h) that specify the type of object.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired interface ID of the icon extractor interface to create. This must be either IID_IExtractIconA or IID_IExtractIconW.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nn-shlobj_core-iextracticona">IExtractIcon</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shcreatefileextracticonw
     * @since windows5.1.2600
     */
    static SHCreateFileExtractIconW(pszFile, dwFileAttributes, riid, ppv) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHELL32.dll\SHCreateFileExtractIconW", "ptr", pszFile, "uint", dwFileAttributes, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Sets limits on valid characters for an edit control.
     * @param {Pointer<Void>} hwndEdit Type: <b>HWND</b>
     * 
     * The handle of the edit control.
     * @param {Pointer<IShellFolder>} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface pointer. This object must also implement <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-iitemnamelimits">IItemNameLimits</a>, which supplies a list of invalid characters and a maximum name length.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shlimitinputedit
     * @since windows5.0
     */
    static SHLimitInputEdit(hwndEdit, psf) {
        result := DllCall("SHELL32.dll\SHLimitInputEdit", "ptr", hwndEdit, "ptr", psf, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHGetAttributesFromDataObject may be altered or unavailable.
     * @param {Pointer<IDataObject>} pdo Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * The data object from which to retrieve the information.
     * @param {Integer} dwAttributeMask Type: <b>DWORD</b>
     * 
     * One or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">SFGAO</a> flags that indicate which pieces of information the calling application wants to retrieve.
     * @param {Pointer<UInt32>} pdwAttributes Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that, when this function returns successfully, receives one or more <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">SFGAO</a> flags that indicate the attributes, among those requested, that are common to all items in <i>pdo</i>. This pointer can be <b>NULL</b> if this information is not needed.
     * @param {Pointer<UInt32>} pcItems Type: <b>UINT*</b>
     * 
     * A pointer to a <b>UINT</b> that, when this function returns successfully, receives the number of PIDLs in the data object pointed to by <i>pdo</i>. This pointer can be <b>NULL</b> if this information is not needed.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * This function can return one of these values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Success.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object is not a system data object. In this case, <i>pdwAttributes</i> is set to 0.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetattributesfromdataobject
     * @since windows5.1.2600
     */
    static SHGetAttributesFromDataObject(pdo, dwAttributeMask, pdwAttributes, pcItems) {
        result := DllCall("SHELL32.dll\SHGetAttributesFromDataObject", "ptr", pdo, "uint", dwAttributeMask, "uint*", pdwAttributes, "uint*", pcItems, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHMapPIDLToSystemImageListIndex may be altered or unavailable.
     * @param {Pointer<IShellFolder>} pshf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface pointer for the folder that contains the item.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<Int32>} piIndexSel Type: <b>int*</b>
     * 
     * A pointer to an <b>int</b> that, when this function returns successfully, receives the index of the item's <b>open</b> icon in the system image list. If the item does not have a special <b>open</b> icon then the index of its normal icon is returned. If the <b>open</b> icon exists and cannot be obtained, then the value pointed to by <i>piIndex</i> is set to -1. This parameter can be <b>NULL</b> if the calling application is not interested in the <b>open</b> icon.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the item's normal icon in the system image list if successful, or -1 otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shmappidltosystemimagelistindex
     * @since windows5.1.2600
     */
    static SHMapPIDLToSystemImageListIndex(pshf, pidl, piIndexSel) {
        result := DllCall("SHELL32.dll\SHMapPIDLToSystemImageListIndex", "ptr", pshf, "ptr", pidl, "int*", piIndexSel, "int")
        return result
    }

    /**
     * Takes the string form of a class identifier (CLSID) and creates the corresponding CLSID.
     * @param {Pointer<Char>} psz Type: <b>PCWSTR</b>
     * 
     * A Unicode string that contains the CLSID in the format, <c>{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</c>.
     * @param {Pointer<Guid>} pclsid Type: <b>CLSID*</b>
     * 
     * A pointer to a CLSID value that, when this function returns successfully, receives the converted string as a CLSID.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shclsidfromstring
     * @since windows5.0
     */
    static SHCLSIDFromString(psz, pclsid) {
        psz := psz is String? StrPtr(psz) : psz

        result := DllCall("SHELL32.dll\SHCLSIDFromString", "ptr", psz, "ptr", pclsid, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * PickIconDlg may be altered or unavailable.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszIconPath Type: <b>PWSTR</b>
     * 
     * A pointer to a string that contains the null-terminated, fully qualified path of the default resource that contains the icons. If the user chooses a different resource in the dialog, this buffer contains the path of that file when the function returns. This buffer should be at least MAX_PATH characters in length, or the returned path may be truncated. You should verify that the path is valid before using it.
     * @param {Integer} cchIconPath Type: <b>UINT</b>
     * 
     * The number of characters in <i>pszIconPath</i>, including the terminating <b>NULL</b> character.
     * @param {Pointer<Int32>} piIconIndex Type: <b>int*</b>
     * 
     * A pointer to an integer that on entry specifies the index of the initial selection and, when this function returns successfully, receives the index of the icon that was selected.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns 1 if successful; otherwise, 0.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-pickicondlg
     * @since windows5.1.2600
     */
    static PickIconDlg(hwnd, pszIconPath, cchIconPath, piIconIndex) {
        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\PickIconDlg", "ptr", hwnd, "ptr", pszIconPath, "uint", cchIconPath, "int*", piIconIndex, "int")
        return result
    }

    /**
     * Creates a unique name for a stream or storage object from a template.
     * @remarks
     * It is recommended that you use the <b>IID_PPV_ARGS</b> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error.
     * @param {Pointer<IStorage>} pstgParent Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> object.
     * @param {Pointer<Char>} pszFileSpec Type: <b>PCWSTR</b>
     * 
     * The format or template for the name of the stream or storage object.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * 
     * The access mode to use when opening the stream or storage object. For more information and descriptions of the possible values, see STGM Constants.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>, typically IID_IStorage or IID_IStream.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-stgmakeuniquename
     * @since windows6.1
     */
    static StgMakeUniqueName(pstgParent, pszFileSpec, grfMode, riid, ppv) {
        pszFileSpec := pszFileSpec is String? StrPtr(pszFileSpec) : pszFileSpec

        result := DllCall("SHELL32.dll\StgMakeUniqueName", "ptr", pstgParent, "ptr", pszFileSpec, "uint", grfMode, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enables asynchronous register and deregister of a thread.
     * @param {Integer} status Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-scnrt_status">SCNRT_STATUS</a></b>
     * 
     * Indicates whether the function is being used to register or deregister the thread. One of the values of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-scnrt_status">SCNRT_STATUS</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-shchangenotifyregisterthread
     * @since windows6.0.6000
     */
    static SHChangeNotifyRegisterThread(status) {
        DllCall("SHELL32.dll\SHChangeNotifyRegisterThread", "int", status)
    }

    /**
     * 
     * @param {Pointer<Char>} psz 
     * @returns {String} Nothing - always returns an empty string
     */
    static PathQualify(psz) {
        psz := psz is String? StrPtr(psz) : psz

        DllCall("SHELL32.dll\PathQualify", "ptr", psz)
    }

    /**
     * PathIsSlow may be altered or unavailable. (ANSI)
     * @remarks
     * A path is considered slow if the MultinetGetConnectionPerformance function returns a dwSpeed of 400 or less in its <a href="https://docs.microsoft.com/windows/desktop/api/winnetwk/ns-winnetwk-netconnectinfostruct">NETCONNECTINFOSTRUCT</a> structurethis is the speed of the media to the network resource, in 100 bits-per-second (bps)or if FILE_ATTRIBUTE_OFFLINE is set on the file.
     * 
     * Note that network conditions can impact function performance time.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj.h header defines PathIsSlow as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the fully qualified path of the file.
     * @param {Integer} dwAttr Type: <b>DWORD</b>
     * 
     * The file attributes, if known; otherwise, pass 1 and this function gets the attributes by calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>. See <b>GetFileAttributes</b> for a list of file attributes.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the connection is high-latency; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-pathisslowa
     * @since windows5.1.2600
     */
    static PathIsSlowA(pszFile, dwAttr) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHELL32.dll\PathIsSlowA", "ptr", pszFile, "uint", dwAttr, "int")
        return result
    }

    /**
     * PathIsSlow may be altered or unavailable. (Unicode)
     * @remarks
     * A path is considered slow if the MultinetGetConnectionPerformance function returns a dwSpeed of 400 or less in its <a href="https://docs.microsoft.com/windows/desktop/api/winnetwk/ns-winnetwk-netconnectinfostruct">NETCONNECTINFOSTRUCT</a> structurethis is the speed of the media to the network resource, in 100 bits-per-second (bps)or if FILE_ATTRIBUTE_OFFLINE is set on the file.
     * 
     * Note that network conditions can impact function performance time.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj.h header defines PathIsSlow as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the fully qualified path of the file.
     * @param {Integer} dwAttr Type: <b>DWORD</b>
     * 
     * The file attributes, if known; otherwise, pass 1 and this function gets the attributes by calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>. See <b>GetFileAttributes</b> for a list of file attributes.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the connection is high-latency; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-pathissloww
     * @since windows5.1.2600
     */
    static PathIsSlowW(pszFile, dwAttr) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHELL32.dll\PathIsSlowW", "ptr", pszFile, "uint", dwAttr, "int")
        return result
    }

    /**
     * SHCreatePropSheetExtArray may be altered or unavailable.
     * @remarks
     * When you are finished with the returned HPSXA handle, destroy it by calling <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shdestroypropsheetextarray">SHDestroyPropSheetExtArray</a>.
     * 
     * This function loads up to <i>max_iface</i> property sheet extensions into an array that is then passed to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shaddfrompropsheetextarray">SHAddFromPropSheetExtArray</a>.
     * @param {Pointer<Void>} hKey Type: <b>HKEY</b>
     * 
     * The registry root key that contains the subkey with the property sheet extension handlers. For instance, <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer<Char>} pszSubKey Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated string specifying the name of the subkey that contains <b>shellex</b>&#92;<b>PropertySheetHandlers</b>.
     * 
     * For example, if  <i>hkey</i> specifies HKEY_LOCAL_MACHINE and <i>pszSubkey</i> specifies "Software\Microsoft\Windows\CurrentVersion\Controls Folder\Display", this function returns property sheet extension handlers using the following subkey:
     * 
     * 
     * <pre><b>HKEY_LOCAL_MACHINE</b>
     * <b>SOFTWARE</b>
     * <b>Microsoft</b>
     * <b>Windows</b>
     * <b>CurrentVersion</b>
     * <b>Controls Folder</b>
     * <b>Display</b>
     * <b>shellex</b>
     * <b>PropertySheetHandlers</b></pre>
     * @param {Integer} max_iface Type: <b>UINT</b>
     * 
     * The maximum number of property sheet handlers to be returned.
     * @returns {Pointer<Void>} Type: <b>HPSXA</b>
     * 
     * Returns a handle to an array of property sheet handlers. Pass this value to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shaddfrompropsheetextarray">SHAddFromPropSheetExtArray</a>. You do not access this value directly.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-shcreatepropsheetextarray
     * @since windows5.1.2600
     */
    static SHCreatePropSheetExtArray(hKey, pszSubKey, max_iface) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHELL32.dll\SHCreatePropSheetExtArray", "ptr", hKey, "ptr", pszSubKey, "uint", max_iface)
        return result
    }

    /**
     * SHOpenPropSheet may be altered or unavailable. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlobj.h header defines SHOpenPropSheet as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszCaption Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string that contains the caption for the property sheet. This value can be <b>NULL</b> if no caption is needed.
     * @param {Pointer<Void>} ahkeys Type: <b>HKEY[]</b>
     * 
     * An array of registry keys that represent the <b>CLSID</b>s of the individual property sheets.
     * @param {Integer} ckeys Type: <b>UINT</b>
     * 
     * <b>UINT</b> value that specifies the number of property sheets in the array specified by <i>ahkeys</i>.
     * @param {Pointer<Guid>} pclsidDefault Type: <b>const CLSID*</b>
     * 
     * A pointer to the default <b>CLSID</b>. This value can be <b>NULL</b>.
     * @param {Pointer<IDataObject>} pdtobj Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>, an OLE object that can be used to carry out actions on the property sheet(s).
     * @param {Pointer<IShellBrowser>} psb Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellbrowser">IShellBrowser</a>*</b>
     * 
     * Not used.
     * @param {Pointer<Char>} pStartPage Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string that specifies the start page. This value can be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the property sheet was successfully created; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-shopenpropsheetw
     * @since windows5.1.2600
     */
    static SHOpenPropSheetW(pszCaption, ahkeys, ckeys, pclsidDefault, pdtobj, psb, pStartPage) {
        pszCaption := pszCaption is String? StrPtr(pszCaption) : pszCaption
        pStartPage := pStartPage is String? StrPtr(pStartPage) : pStartPage

        result := DllCall("SHELL32.dll\SHOpenPropSheetW", "ptr", pszCaption, "ptr", ahkeys, "uint", ckeys, "ptr", pclsidDefault, "ptr", pdtobj, "ptr", psb, "ptr", pStartPage, "int")
        return result
    }

    /**
     * Displays a standard message box that can be used to notify a user that an application has been updated.
     * @remarks
     * The preferred way to handle updates is to author a Channel Definition Format (CDF) with an Open Software Description (OSD) vocabulary and make the shortcut OSD-aware. Refer to the <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa768023(v=vs.85)">Channel Definition Format</a> documentation for details.
     * 
     * The <b>SoftwareUpdateMessageBox</b> function is intended to be used in the case where Shell shortcut hooks do not work. One example is an application that was not installed on the start menu. If that application needs to do its own software update check, it should use this function.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {Pointer<Char>} pszDistUnit Type: <b>PCWSTR</b>
     * 
     * The string value containing the identifier for the code distribution unit. For ActiveX controls, <i>pszDistUnit</i> is typically a GUID.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Must be set to zero.
     * @param {Pointer<SOFTDISTINFO>} psdi Type: <b>LPSOFTDISTINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/urlmon/ns-urlmon-softdistinfo">SOFTDISTINFO</a> structure that, when this method returns successfully, receives the update information. The <b>cbSize</b> member must be initialized to the <c>sizeof(SOFTDISTINFO)</c>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDNO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user clicked the <b>Do Not Update</b> button on the dialog box.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDYES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user clicked the <b>Update Now</b> or <b>About Update</b> button. The application should navigate to the HTML page referred to by the <b>szHREF</b> member of the structure pointed to by <i>psdi</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDIGNORE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no pending software update.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDABORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-softwareupdatemessagebox
     * @since windows5.0
     */
    static SoftwareUpdateMessageBox(hWnd, pszDistUnit, dwFlags, psdi) {
        pszDistUnit := pszDistUnit is String? StrPtr(pszDistUnit) : pszDistUnit

        result := DllCall("SHDOCVW.dll\SoftwareUpdateMessageBox", "ptr", hWnd, "ptr", pszDistUnit, "uint", dwFlags, "ptr", psdi, "uint")
        return result
    }

    /**
     * Displays a merged property sheet for a set of files. Property values common to all the files are shown while those that differ display the string (multiple values).
     * @param {Pointer<IDataObject>} pdtobj Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to a data object that supplies the PIDLs of all of the files for which to display the merged property sheet. The data object must use the <a href="https://docs.microsoft.com/windows/desktop/shell/clipboard">CFSTR_SHELLIDLIST</a> clipboard format. The parent folder's implementation of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof">IShellFolder::GetDisplayNameOf</a> must return a fully qualified file system path for each item in response to the <a href="https://docs.microsoft.com/windows/win32/api/shobjidl_core/ne-shobjidl_core-_shgdnf">SHGDN_FORPARSING</a> flag.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Must be set to 0.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-shmultifileproperties
     * @since windows5.0
     */
    static SHMultiFileProperties(pdtobj, dwFlags) {
        result := DllCall("SHELL32.dll\SHMultiFileProperties", "ptr", pdtobj, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Deprecated. Creates a QueryCancelAutoPlay class moniker, which can then be used to register the IQueryCancelAutoPlay handler in the running object table (ROT).
     * @remarks
     * If successful, <b>SHCreateQueryCancelAutoPlayMoniker</b> calls the interface's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> method and increments the reference count. When you are finished, call the interface's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> method to release.
     * @param {Pointer<IMoniker>} ppmoniker Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a>**</b>
     * 
     * The address of a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface pointer that, when this function returns successfully, receives the <b>QueryCancelAutoPlay</b> class moniker. If this function call fails, this value is <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlobj/nf-shlobj-shcreatequerycancelautoplaymoniker
     * @since windows5.1.2600
     */
    static SHCreateQueryCancelAutoPlayMoniker(ppmoniker) {
        result := DllCall("SHELL32.dll\SHCreateQueryCancelAutoPlayMoniker", "ptr", ppmoniker, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pszFilename 
     * @param {Pointer<Int32>} pfParsePrivacyPreferences 
     * @param {Pointer<Int32>} pfParsePerSiteRules 
     * @returns {Integer} 
     */
    static ImportPrivacySettings(pszFilename, pfParsePrivacyPreferences, pfParsePerSiteRules) {
        pszFilename := pszFilename is String? StrPtr(pszFilename) : pszFilename

        result := DllCall("SHDOCVW.dll\ImportPrivacySettings", "ptr", pszFilename, "int*", pfParsePrivacyPreferences, "int*", pfParsePerSiteRules, "int")
        return result
    }

    /**
     * Gets the preferred scale factor for a display device.
     * @remarks
     * The default <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">DEVICE_SCALE_FACTOR</a> is <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">SCALE_100_PERCENT</a>.
     * 
     * Use the scale factor that is returned to scale point values for fonts and pixel values.
     * @param {Integer} deviceType Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-display_device_type">DISPLAY_DEVICE_TYPE</a></b>
     * 
     * The value that indicates the type of the display device.
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">DEVICE_SCALE_FACTOR</a></b>
     * 
     * A value that indicates the scale factor that should be used with the specified <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-display_device_type">DISPLAY_DEVICE_TYPE</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SCALE_100_PERCENT</b></dt>
     * <dt>100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use a scale factor of 1x.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SCALE_140_PERCENT</b></dt>
     * <dt>140</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use a scale factor of 1.4x.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SCALE_180_PERCENT</b></dt>
     * <dt>180</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use a scale factor of 1.8x.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-getscalefactorfordevice
     * @since windows8.0
     */
    static GetScaleFactorForDevice(deviceType) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-0.dll\GetScaleFactorForDevice", "int", deviceType, "int")
        return result
    }

    /**
     * Registers a window to receive callbacks when scaling information changes.
     * @remarks
     * This message specified by <i>uMsgNotify</i> is posted to the registered window through <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a>. The <i>wParam</i> of the message can contain a combination of <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-scale_change_flags">SCALE_CHANGE_FLAGS</a> that describe  the change that occurred.
     * @param {Integer} displayDevice Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-display_device_type">DISPLAY_DEVICE_TYPE</a></b>
     * 
     * The enum value that indicates which display device to receive notifications about.
     * @param {Pointer<Void>} hwndNotify Type: <b>HWND</b>
     * 
     * The handle of the window that will receive the notifications.
     * @param {Integer} uMsgNotify Type: <b>UINT</b>
     * 
     * An application-defined message that is passed to the window specified by <i>hwndNotify</i> when scaling information changes.  Typically, this should be set to <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-app">WM_APP</a>+<i>x</i>, where <i>x</i> is an integer value.
     * @param {Pointer<UInt32>} pdwCookie Type: <b>DWORD*</b>
     * 
     * Pointer to a value that, when this function returns successfully, receives a registration token. This token is used to revoke notifications by calling <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-revokescalechangenotifications">RevokeScaleChangeNotifications</a>.
     * @returns {HRESULT} Type: <b>STDAPI</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-registerscalechangenotifications
     * @since windows8.0
     */
    static RegisterScaleChangeNotifications(displayDevice, hwndNotify, uMsgNotify, pdwCookie) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-0.dll\RegisterScaleChangeNotifications", "int", displayDevice, "ptr", hwndNotify, "uint", uMsgNotify, "uint*", pdwCookie, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Revokes the registration of a window, preventing it from receiving callbacks when scaling information changes.
     * @param {Integer} displayDevice Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-display_device_type">DISPLAY_DEVICE_TYPE</a></b>
     * 
     * The enum value that indicates which display device to receive notifications about.
     * @param {Integer} dwCookie Type: <b>DWORD</b>
     * 
     * The registration token returned by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-registerscalechangenotifications">RegisterScaleChangeNotifications</a>.
     * @returns {HRESULT} Type: <b>STDAPI</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-revokescalechangenotifications
     * @since windows8.0
     */
    static RevokeScaleChangeNotifications(displayDevice, dwCookie) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-0.dll\RevokeScaleChangeNotifications", "int", displayDevice, "uint", dwCookie, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Gets the scale factor of a specific monitor. This function replaces GetScaleFactorForDevice.
     * @remarks
     * Your code needs to handle the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-windowposchanged">WM_WINDOWPOSCHANGED</a> message in addition to the scale change event registered through <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-registerscalechangeevent">RegisterScaleChangeEvent</a>, because the app window can be moved between monitors. In response to the <b>WM_WINDOWPOSCHANGED</b> message, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-monitorfromwindow">MonitorFromWindow</a>, followed by <b>GetScaleFactorForMonitor</b> to get the scale factor of the monitor which the app window is on. Your code can then react to any dots per inch (dpi) change by reloading assets and changing layout.
     * @param {Pointer<Void>} hMon The monitor's handle.
     * @param {Pointer<Int32>} pScale When this function returns successfully, this value points to one of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">DEVICE_SCALE_FACTOR</a> values that specify the scale factor of the specified monitor.
     *                         
     * 
     * If the function call fails, this value points to a valid scale factor so that apps can opt to continue on with incorrectly sized resources.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-getscalefactorformonitor
     * @since windows8.1
     */
    static GetScaleFactorForMonitor(hMon, pScale) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-1.dll\GetScaleFactorForMonitor", "ptr", hMon, "int*", pScale, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Registers for an event that is triggered when the scale has possibly changed. This function replaces RegisterScaleChangeNotifications.
     * @remarks
     * The event is raised whenever something that can affect scale changes, but just because the scale can be affected doesn't mean that it has been. Callers can cache the scale factor to verify that the monitor's scale actually has changed. The event handle will be duplicated, so callers can close their handle at any time.
     * @param {Pointer<Void>} hEvent Handle of the event to register for scale change notifications.
     * @param {Pointer<UIntPtr>} pdwCookie When this function returns successfully, this value receives the address of a pointer to a cookie that can be used later to unregister for the scale change notifications through <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-unregisterscalechangeevent">UnregisterScaleChangeEvent</a>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-registerscalechangeevent
     * @since windows8.1
     */
    static RegisterScaleChangeEvent(hEvent, pdwCookie) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-1.dll\RegisterScaleChangeEvent", "ptr", hEvent, "ptr*", pdwCookie, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Unregisters for the scale change event registered through RegisterScaleChangeEvent. This function replaces RevokeScaleChangeNotifications.
     * @param {Pointer} dwCookie A pointer to the cookie retrieved in the call to <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-registerscalechangeevent">RegisterScaleChangeEvent</a>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-unregisterscalechangeevent
     * @since windows8.1
     */
    static UnregisterScaleChangeEvent(dwCookie) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-1.dll\UnregisterScaleChangeEvent", "ptr", dwCookie, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the dots per inch (dpi) occupied by a SHELL_UI_COMPONENT based on the current scale factor and PROCESS_DPI_AWARENESS.
     * @param {Integer} param0 
     * @returns {Integer} The DPI required for an icon of this type.
     * @see https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-getdpiforshelluicomponent
     * @since windows8.1
     */
    static GetDpiForShellUIComponent(param0) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-2.dll\GetDpiForShellUIComponent", "int", param0, "uint")
        return result
    }

    /**
     * Parses a Unicode command line string and returns an array of pointers to the command line arguments, along with a count of such arguments, in a way that is similar to the standard C run-time argv and argc values.
     * @remarks
     * The address returned by <b>CommandLineToArgvW</b> is the address of the first element in an array of <b>LPWSTR</b> values; the number of pointers in this array is indicated by <i>pNumArgs</i>. Each pointer to a <b>null</b>-terminated Unicode string represents an individual argument found on the command line.
     * 
     * <b>CommandLineToArgvW</b> allocates a block of contiguous memory for pointers to the argument strings, and for the argument strings themselves; the calling application must free the memory used by the argument list when it is no longer needed. To free the memory, use a single call to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * 
     * For more information about the <i>argv</i> and <i>argc</i> argument convention, see <a href="https://docs.microsoft.com/previous-versions/88w63h9k(v=vs.85)">Argument Definitions</a> and <a href="https://docs.microsoft.com/cpp/c-language/parsing-c-command-line-arguments">Parsing C Command-Line Arguments</a>.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-getcommandlinew">GetCommandLineW</a> function can be used to get a command line string that is suitable for use as the <i>lpCmdLine</i> parameter.
     * 
     * This function accepts command lines that contain a program name; the program name can be enclosed in quotation marks or not.
     * 
     * <b>CommandLineToArgvW</b> has a special interpretation of backslash characters when they are followed by a quotation mark character ("). This interpretation assumes that any preceding argument is a valid file system path, or else it may behave unpredictably. 
     * 
     * This special interpretation controls the "in quotes" mode tracked by the parser. When this mode is off, whitespace terminates the current argument. When on, whitespace is added to the argument like all other characters.
     *     
     *                 
     * 
     * <ul>
     * <li>2<i>n</i> backslashes followed by a quotation mark produce <i>n</i> backslashes followed by begin/end quote. This does not become part of the parsed argument, but toggles the "in quotes" mode.</li>
     * <li>(2<i>n</i>) + 1 backslashes followed by a quotation mark again produce <i>n</i> backslashes followed by a quotation mark literal ("). This does not toggle the "in quotes" mode.</li>
     * <li><i>n</i> backslashes not followed by a quotation mark simply produce <i>n</i> backslashes.</li>
     * </ul>
     * <div class="alert"><b>Important</b><p class="note"><b>CommandLineToArgvW</b> treats whitespace outside of quotation marks as argument delimiters. However, if <i>lpCmdLine</i> starts with any amount of whitespace, <b>CommandLineToArgvW</b> will consider the first argument to be an empty string. Excess whitespace at the end of <i>lpCmdLine</i> is ignored.
     * 
     * </div>
     * <div></div>
     * @param {Pointer<Char>} lpCmdLine Type: <b>LPCWSTR</b>
     * 
     * Pointer to a <b>null</b>-terminated Unicode string that contains the full command line. If this parameter is an empty string the function returns the path to the current executable file.
     * @param {Pointer<Int32>} pNumArgs Type: <b>int*</b>
     * 
     * Pointer to an <b>int</b> that receives the number of array elements returned, similar to <i>argc</i>.
     * @returns {Pointer<Char>} Type: <b>LPWSTR*</b>
     * 
     * A pointer to an array of <b>LPWSTR</b> values, similar to <i>argv</i>.
     * 
     *                     
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw
     * @since windows5.0
     */
    static CommandLineToArgvW(lpCmdLine, pNumArgs) {
        lpCmdLine := lpCmdLine is String? StrPtr(lpCmdLine) : lpCmdLine

        A_LastError := 0

        result := DllCall("SHELL32.dll\CommandLineToArgvW", "ptr", lpCmdLine, "int*", pNumArgs, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the names of dropped files that result from a successful drag-and-drop operation. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hDrop Type: <b>HDROP</b>
     * 
     * Identifier of the structure that contains the file names of the dropped files.
     * @param {Integer} iFile Type: <b>UINT</b>
     * 
     * Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.
     * @param {Pointer<Byte>} lpszFile Type: <b>LPTSTR</b>
     * 
     * The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.
     * @param {Integer} cch Type: <b>UINT</b>
     * 
     * The size, in characters, of the <i>lpszFile</i> buffer.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * A nonzero value indicates a successful call.
     * 
     * When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.
     * 
     * If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.
     * 
     * If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragqueryfilea
     * @since windows5.1.2600
     */
    static DragQueryFileA(hDrop, iFile, lpszFile, cch) {
        lpszFile := lpszFile is String? StrPtr(lpszFile) : lpszFile

        result := DllCall("SHELL32.dll\DragQueryFileA", "ptr", hDrop, "uint", iFile, "ptr", lpszFile, "uint", cch, "uint")
        return result
    }

    /**
     * Retrieves the names of dropped files that result from a successful drag-and-drop operation. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shellapi.h header defines DragQueryFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hDrop Type: <b>HDROP</b>
     * 
     * Identifier of the structure that contains the file names of the dropped files.
     * @param {Integer} iFile Type: <b>UINT</b>
     * 
     * Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.
     * @param {Pointer<Char>} lpszFile Type: <b>LPTSTR</b>
     * 
     * The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.
     * @param {Integer} cch Type: <b>UINT</b>
     * 
     * The size, in characters, of the <i>lpszFile</i> buffer.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * A nonzero value indicates a successful call.
     * 
     * When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.
     * 
     * If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.
     * 
     * If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragqueryfilew
     * @since windows5.1.2600
     */
    static DragQueryFileW(hDrop, iFile, lpszFile, cch) {
        lpszFile := lpszFile is String? StrPtr(lpszFile) : lpszFile

        result := DllCall("SHELL32.dll\DragQueryFileW", "ptr", hDrop, "uint", iFile, "ptr", lpszFile, "uint", cch, "uint")
        return result
    }

    /**
     * Retrieves the position of the mouse pointer at the time a file was dropped during a drag-and-drop operation.
     * @remarks
     * The window for which coordinates are returned is the window that received the <a href="https://docs.microsoft.com/windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message.
     * @param {Pointer<Void>} hDrop Type: <b>HDROP</b>
     * 
     * Handle of the drop structure that describes the dropped file.
     * @param {Pointer<POINT>} ppt Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that, when this function returns successfully, receives the coordinates of the mouse pointer at the time the file was dropped.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the drop occurred in the client area of the window; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragquerypoint
     * @since windows5.1.2600
     */
    static DragQueryPoint(hDrop, ppt) {
        result := DllCall("SHELL32.dll\DragQueryPoint", "ptr", hDrop, "ptr", ppt, "int")
        return result
    }

    /**
     * Releases memory that the system allocated for use in transferring file names to the application.
     * @param {Pointer<Void>} hDrop Type: <b>HDROP</b>
     * 
     * Identifier of the structure that describes dropped files. This handle is retrieved from the <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragfinish
     * @since windows5.1.2600
     */
    static DragFinish(hDrop) {
        DllCall("SHELL32.dll\DragFinish", "ptr", hDrop)
    }

    /**
     * Registers whether a window accepts dropped files.
     * @remarks
     * An application that calls <b>DragAcceptFiles</b> with the <i>fAccept</i> parameter set to <b>TRUE</b> has identified itself as able to process the <a href="https://docs.microsoft.com/windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message from File Manager.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * The identifier of the window that is registering whether it will accept dropped files.
     * @param {Integer} fAccept Type: <b>BOOL</b>
     * 
     * A value that indicates if the window identified by the <i>hWnd</i> parameter accepts dropped files. This value is <b>TRUE</b> to accept dropped files or <b>FALSE</b> to discontinue accepting dropped files.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-dragacceptfiles
     * @since windows5.1.2600
     */
    static DragAcceptFiles(hWnd, fAccept) {
        DllCall("SHELL32.dll\DragAcceptFiles", "ptr", hWnd, "int", fAccept)
    }

    /**
     * Performs an operation on a specified file. (ShellExecuteA)
     * @remarks
     * Because <b>ShellExecute</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecute</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:
     * 
     *                 
     * 
     * 
     * ```
     * CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
     * ```
     * 
     * 
     * There are certainly instances where <b>ShellExecute</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to <i>always</i> initialize COM before using this function.
     * 
     * This method allows you to execute any commands in a folder's shortcut menu or stored in the registry.
     * 
     * To open a folder, use either of the following calls: 			
     * 
     * 				
     * 
     * 
     * ```
     * ShellExecute(handle, NULL, <fully_qualified_path_to_folder>, NULL, NULL, SW_SHOWNORMAL);
     * ```
     * 
     * 
     * or
     * 
     * 
     * ```
     * ShellExecute(handle, "open", <fully_qualified_path_to_folder>, NULL, NULL, SW_SHOWNORMAL);
     * ```
     * 
     * 
     * To explore a folder, use the following call:
     * 				
     * 
     * 
     * ```
     * ShellExecute(handle, "explore", <fully_qualified_path_to_folder>, NULL, NULL, SW_SHOWNORMAL);
     * ```
     * 
     * 
     * To launch the Shell's Find utility for a directory, use the following call.
     * 				
     * 
     * 
     * ```
     * ShellExecute(handle, "find", <fully_qualified_path_to_folder>, NULL, NULL, 0);
     * ```
     * 
     * 
     * If <i>lpOperation</i> is <b>NULL</b>, the function opens the file specified by <i>lpFile</i>. If <i>lpOperation</i> is "open" or "explore", the function  attempts to open or explore the folder.
     * 
     * To obtain information about the application that is launched as a result of calling <b>ShellExecute</b>, use <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecuteexa">ShellExecuteEx</a>.
     * 
     * <div class="alert"><b>Note</b>The <b>Launch folder windows in a separate process</b> setting in Folder Options affects <b>ShellExecute</b>. If that option is disabled (the default setting), <b>ShellExecute</b> uses an open Explorer window rather than launch a new one. If no Explorer window is open, <b>ShellExecute</b> launches a new one.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ShellExecute as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.
     * @param {Pointer<Byte>} lpOperation Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:
     * @param {Pointer<Byte>} lpFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.
     * @param {Pointer<Byte>} lpParameters Type: <b>LPCTSTR</b>
     * 
     * If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.
     * @param {Pointer<Byte>} lpDirectory Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.
     * @param {Integer} nShowCmd Type: <b>INT</b>
     * 
     * The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function.
     * @returns {Pointer<Void>} Type: <b>HINSTANCE</b>
     * 
     * If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>INT_PTR</b> and compared to either 32 or the following error codes below.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system is out of memory or resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The .exe file is invalid (non-Win32 .exe or error in .exe image).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system denied access to the specified file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ASSOCINCOMPLETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file name association is incomplete or invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDEBUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction could not be completed because other DDE transactions were being processed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDEFAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDETIMEOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction could not be completed because the request timed out.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DLLNOTFOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified DLL was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_FNF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_NOASSOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_OOM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_PNF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_SHARE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A sharing violation occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellexecutea
     * @since windows5.1.2600
     */
    static ShellExecuteA(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd) {
        lpOperation := lpOperation is String? StrPtr(lpOperation) : lpOperation
        lpFile := lpFile is String? StrPtr(lpFile) : lpFile
        lpParameters := lpParameters is String? StrPtr(lpParameters) : lpParameters
        lpDirectory := lpDirectory is String? StrPtr(lpDirectory) : lpDirectory

        result := DllCall("SHELL32.dll\ShellExecuteA", "ptr", hwnd, "ptr", lpOperation, "ptr", lpFile, "ptr", lpParameters, "ptr", lpDirectory, "int", nShowCmd)
        return result
    }

    /**
     * Performs an operation on a specified file. (ShellExecuteW)
     * @remarks
     * Because <b>ShellExecute</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecute</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:
     * 
     *                 
     * 
     * 
     * ```
     * CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
     * ```
     * 
     * 
     * There are certainly instances where <b>ShellExecute</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to <i>always</i> initialize COM before using this function.
     * 
     * This method allows you to execute any commands in a folder's shortcut menu or stored in the registry.
     * 
     * To open a folder, use either of the following calls: 			
     * 
     * 				
     * 
     * 
     * ```
     * ShellExecute(handle, NULL, <fully_qualified_path_to_folder>, NULL, NULL, SW_SHOWNORMAL);
     * ```
     * 
     * 
     * or
     * 
     * 
     * ```
     * ShellExecute(handle, "open", <fully_qualified_path_to_folder>, NULL, NULL, SW_SHOWNORMAL);
     * ```
     * 
     * 
     * To explore a folder, use the following call:
     * 				
     * 
     * 
     * ```
     * ShellExecute(handle, "explore", <fully_qualified_path_to_folder>, NULL, NULL, SW_SHOWNORMAL);
     * ```
     * 
     * 
     * To launch the Shell's Find utility for a directory, use the following call.
     * 				
     * 
     * 
     * ```
     * ShellExecute(handle, "find", <fully_qualified_path_to_folder>, NULL, NULL, 0);
     * ```
     * 
     * 
     * If <i>lpOperation</i> is <b>NULL</b>, the function opens the file specified by <i>lpFile</i>. If <i>lpOperation</i> is "open" or "explore", the function  attempts to open or explore the folder.
     * 
     * To obtain information about the application that is launched as a result of calling <b>ShellExecute</b>, use <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecuteexa">ShellExecuteEx</a>.
     * 
     * <div class="alert"><b>Note</b>The <b>Launch folder windows in a separate process</b> setting in Folder Options affects <b>ShellExecute</b>. If that option is disabled (the default setting), <b>ShellExecute</b> uses an open Explorer window rather than launch a new one. If no Explorer window is open, <b>ShellExecute</b> launches a new one.</div>
     * <div></div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ShellExecute as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.
     * @param {Pointer<Char>} lpOperation Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:
     * @param {Pointer<Char>} lpFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.
     * @param {Pointer<Char>} lpParameters Type: <b>LPCTSTR</b>
     * 
     * If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.
     * @param {Pointer<Char>} lpDirectory Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.
     * @param {Integer} nShowCmd Type: <b>INT</b>
     * 
     * The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function.
     * @returns {Pointer<Void>} Type: <b>HINSTANCE</b>
     * 
     * If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>INT_PTR</b> and compared to either 32 or the following error codes below.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system is out of memory or resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The .exe file is invalid (non-Win32 .exe or error in .exe image).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system denied access to the specified file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ASSOCINCOMPLETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file name association is incomplete or invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDEBUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction could not be completed because other DDE transactions were being processed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDEFAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDETIMEOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction could not be completed because the request timed out.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DLLNOTFOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified DLL was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_FNF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_NOASSOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_OOM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_PNF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_SHARE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A sharing violation occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellexecutew
     * @since windows5.1.2600
     */
    static ShellExecuteW(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd) {
        lpOperation := lpOperation is String? StrPtr(lpOperation) : lpOperation
        lpFile := lpFile is String? StrPtr(lpFile) : lpFile
        lpParameters := lpParameters is String? StrPtr(lpParameters) : lpParameters
        lpDirectory := lpDirectory is String? StrPtr(lpDirectory) : lpDirectory

        result := DllCall("SHELL32.dll\ShellExecuteW", "ptr", hwnd, "ptr", lpOperation, "ptr", lpFile, "ptr", lpParameters, "ptr", lpDirectory, "int", nShowCmd)
        return result
    }

    /**
     * Retrieves the name of and handle to the executable (.exe) file associated with a specific document file. (ANSI)
     * @remarks
     * Use <b>FindExecutable</b> for documents. If you want to retrieve the path of an executable file, use the following:
     * 
     * 				
     * 
     * 
     * ```
     * AssocQueryString(ASSOCF_OPEN_BYEXENAME,
     *                  ASSOCSTR_EXECUTABLE,
     *                  pszExecutableName,
     *                  NULL,
     *                  pszPath,
     *                  pcchOut);
     * ```
     * 
     * 
     * Here, <i>pszExecutableName</i> is a pointer to a <b>null</b>-terminated string that specifies the name of the executable file, <i>pszPath</i> is a pointer to the <b>null</b>-terminated string buffer that receives the path to the executable file, and <i>pcchOut</i> is a pointer to a <b>DWORD</b> that specifies the number of characters in the <i>pszPath</i> buffer. When the function returns, <i>pcchOut</i> is set to the number of characters actually placed in the buffer. See <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-assocquerystringa">AssocQueryString</a> for more information.
     * 
     * When <b>FindExecutable</b> returns, the <i>lpResult</i> parameter may contain the path to the Dynamic Data Exchange (DDE) server started if a server does not respond to a request to initiate a DDE conversation with the DDE client application.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines FindExecutable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFile Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.
     * @param {Pointer<Byte>} lpDirectory Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.
     * @param {Pointer<Byte>} lpResult Type: <b>LPTSTR</b>
     * 
     * The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.
     * @returns {Pointer<Void>} Type: <b>HINSTANCE</b>
     * 
     * Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.
     * 					
     *                     
     * 
     * The following table lists possible error values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_FNF</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_PNF</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ACCESSDENIED</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file cannot be accessed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_OOM</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory or resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_NOASSOC</b></dt>
     * <dt>31</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no association for the specified file type with an executable file.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-findexecutablea
     * @since windows5.1.2600
     */
    static FindExecutableA(lpFile, lpDirectory, lpResult) {
        lpFile := lpFile is String? StrPtr(lpFile) : lpFile
        lpDirectory := lpDirectory is String? StrPtr(lpDirectory) : lpDirectory
        lpResult := lpResult is String? StrPtr(lpResult) : lpResult

        result := DllCall("SHELL32.dll\FindExecutableA", "ptr", lpFile, "ptr", lpDirectory, "ptr", lpResult)
        return result
    }

    /**
     * Retrieves the name of and handle to the executable (.exe) file associated with a specific document file. (Unicode)
     * @remarks
     * Use <b>FindExecutable</b> for documents. If you want to retrieve the path of an executable file, use the following:
     * 
     * 				
     * 
     * 
     * ```
     * AssocQueryString(ASSOCF_OPEN_BYEXENAME,
     *                  ASSOCSTR_EXECUTABLE,
     *                  pszExecutableName,
     *                  NULL,
     *                  pszPath,
     *                  pcchOut);
     * ```
     * 
     * 
     * Here, <i>pszExecutableName</i> is a pointer to a <b>null</b>-terminated string that specifies the name of the executable file, <i>pszPath</i> is a pointer to the <b>null</b>-terminated string buffer that receives the path to the executable file, and <i>pcchOut</i> is a pointer to a <b>DWORD</b> that specifies the number of characters in the <i>pszPath</i> buffer. When the function returns, <i>pcchOut</i> is set to the number of characters actually placed in the buffer. See <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-assocquerystringa">AssocQueryString</a> for more information.
     * 
     * When <b>FindExecutable</b> returns, the <i>lpResult</i> parameter may contain the path to the Dynamic Data Exchange (DDE) server started if a server does not respond to a request to initiate a DDE conversation with the DDE client application.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines FindExecutable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFile Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.
     * @param {Pointer<Char>} lpDirectory Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} lpResult Type: <b>LPTSTR</b>
     * 
     * The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.
     * @returns {Pointer<Void>} Type: <b>HINSTANCE</b>
     * 
     * Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.
     * 					
     *                     
     * 
     * The following table lists possible error values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_FNF</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_PNF</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ACCESSDENIED</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file cannot be accessed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_OOM</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory or resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_NOASSOC</b></dt>
     * <dt>31</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no association for the specified file type with an executable file.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-findexecutablew
     * @since windows5.1.2600
     */
    static FindExecutableW(lpFile, lpDirectory, lpResult) {
        lpFile := lpFile is String? StrPtr(lpFile) : lpFile
        lpDirectory := lpDirectory is String? StrPtr(lpDirectory) : lpDirectory
        lpResult := lpResult is String? StrPtr(lpResult) : lpResult

        result := DllCall("SHELL32.dll\FindExecutableW", "ptr", lpFile, "ptr", lpDirectory, "ptr", lpResult)
        return result
    }

    /**
     * Displays a ShellAbout dialog box. (ANSI)
     * @remarks
     * Note that the <b>ShellAbout</b> function dialog box uses text and a default icon that are specific to Windows.
     * 
     * To see an example of a <b>ShellAbout</b> dialog box, choose <b>About Windows</b> from the <b>Help</b> menu drop-down list in Windows Explorer.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ShellAbout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A window handle to a parent window. This parameter can be <b>NULL</b>.
     * @param {Pointer<Byte>} szApp Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".
     * 
     *                     
     * 
     * <b>Windows2000, WindowsXP, Windows Server2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writable.
     * 
     * <b>WindowsVista, Windows Server2008</b>: This string cannot exceed 200 characters in length.
     * @param {Pointer<Byte>} szOtherStuff Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.
     * @param {Pointer<Void>} hIcon Type: <b>HICON</b>
     * 
     * The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.
     * @returns {Integer} Type: <b>int</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellabouta
     * @since windows5.1.2600
     */
    static ShellAboutA(hWnd, szApp, szOtherStuff, hIcon) {
        szApp := szApp is String? StrPtr(szApp) : szApp
        szOtherStuff := szOtherStuff is String? StrPtr(szOtherStuff) : szOtherStuff

        result := DllCall("SHELL32.dll\ShellAboutA", "ptr", hWnd, "ptr", szApp, "ptr", szOtherStuff, "ptr", hIcon, "int")
        return result
    }

    /**
     * Displays a ShellAbout dialog box. (Unicode)
     * @remarks
     * Note that the <b>ShellAbout</b> function dialog box uses text and a default icon that are specific to Windows.
     * 
     * To see an example of a <b>ShellAbout</b> dialog box, choose <b>About Windows</b> from the <b>Help</b> menu drop-down list in Windows Explorer.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ShellAbout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A window handle to a parent window. This parameter can be <b>NULL</b>.
     * @param {Pointer<Char>} szApp Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".
     * 
     *                     
     * 
     * <b>Windows2000, WindowsXP, Windows Server2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writable.
     * 
     * <b>WindowsVista, Windows Server2008</b>: This string cannot exceed 200 characters in length.
     * @param {Pointer<Char>} szOtherStuff Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.
     * @param {Pointer<Void>} hIcon Type: <b>HICON</b>
     * 
     * The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.
     * @returns {Integer} Type: <b>int</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellaboutw
     * @since windows5.1.2600
     */
    static ShellAboutW(hWnd, szApp, szOtherStuff, hIcon) {
        szApp := szApp is String? StrPtr(szApp) : szApp
        szOtherStuff := szOtherStuff is String? StrPtr(szOtherStuff) : szOtherStuff

        result := DllCall("SHELL32.dll\ShellAboutW", "ptr", hWnd, "ptr", szApp, "ptr", szOtherStuff, "ptr", hIcon, "int")
        return result
    }

    /**
     * Creates a duplicate of a specified icon.
     * @remarks
     * When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>DuplicateIcon</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * @param {Pointer<Void>} hIcon Type: <b>HICON</b>
     * 
     * Handle to the icon to be duplicated.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If successful, the function returns the handle to the new icon that was created; otherwise, <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-duplicateicon
     * @since windows5.1.2600
     */
    static DuplicateIcon(hIcon) {
        static hInst := 0 ;Reserved parameters must always be NULL

        result := DllCall("SHELL32.dll\DuplicateIcon", "ptr", hInst, "ptr", hIcon)
        return result
    }

    /**
     * Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file. (ANSI)
     * @remarks
     * When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>ExtractAssociatedIcon</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * 
     * The <b>ExtractAssociatedIcon</b> function first looks for the indexed icon in the file specified by <i>lpIconPath</i>. If the function cannot obtain the icon handle from that file, and the file has an associated executable file, it looks in that executable file for an icon. Associations with executable files are based on file name extensions and are stored in the per-user part of the registry.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ExtractAssociatedIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszIconPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file. 
     * 
     *                     
     * 
     * When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.
     * @param {Pointer<UInt16>} piIcon Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained. 
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.
     * 
     * 					
     * 
     * If the function fails, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extractassociatedicona
     * @since windows5.1.2600
     */
    static ExtractAssociatedIconA(pszIconPath, piIcon) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\ExtractAssociatedIconA", "ptr", hInst, "ptr", pszIconPath, "ushort*", piIcon)
        return result
    }

    /**
     * Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file. (Unicode)
     * @remarks
     * When it is no longer needed, the caller is responsible for freeing the icon handle returned by <b>ExtractAssociatedIcon</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * 
     * The <b>ExtractAssociatedIcon</b> function first looks for the indexed icon in the file specified by <i>lpIconPath</i>. If the function cannot obtain the icon handle from that file, and the file has an associated executable file, it looks in that executable file for an icon. Associations with executable files are based on file name extensions and are stored in the per-user part of the registry.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ExtractAssociatedIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszIconPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file. 
     * 
     *                     
     * 
     * When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.
     * @param {Pointer<UInt16>} piIcon Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained. 
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.
     * 
     * 					
     * 
     * If the function fails, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extractassociatediconw
     * @since windows5.1.2600
     */
    static ExtractAssociatedIconW(pszIconPath, piIcon) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\ExtractAssociatedIconW", "ptr", hInst, "ptr", pszIconPath, "ushort*", piIcon)
        return result
    }

    /**
     * ExtractAssociatedIconEx may be altered or unavailable. (ANSI)
     * @remarks
     * The icon handle returned by this function must be released by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> when it is no longer needed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ExtractAssociatedIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszIconPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file. 
     * 
     *                     
     * 
     * When this function returns, if the icon handle was obtained from an executable file (either an executable file directly pointed to by this parameter or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.
     * @param {Pointer<UInt16>} piIconIndex Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained. 
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.
     * @param {Pointer<UInt16>} piIconId Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the ID of the icon whose handle is to be obtained.
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's ID within that file.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * Returns the icon's handle if successful, otherwise <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extractassociatediconexa
     * @since windows5.1.2600
     */
    static ExtractAssociatedIconExA(pszIconPath, piIconIndex, piIconId) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\ExtractAssociatedIconExA", "ptr", hInst, "ptr", pszIconPath, "ushort*", piIconIndex, "ushort*", piIconId)
        return result
    }

    /**
     * ExtractAssociatedIconEx may be altered or unavailable. (Unicode)
     * @remarks
     * The icon handle returned by this function must be released by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> when it is no longer needed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ExtractAssociatedIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszIconPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file. 
     * 
     *                     
     * 
     * When this function returns, if the icon handle was obtained from an executable file (either an executable file directly pointed to by this parameter or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.
     * @param {Pointer<UInt16>} piIconIndex Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained. 
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.
     * @param {Pointer<UInt16>} piIconId Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the ID of the icon whose handle is to be obtained.
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's ID within that file.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * Returns the icon's handle if successful, otherwise <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extractassociatediconexw
     * @since windows5.1.2600
     */
    static ExtractAssociatedIconExW(pszIconPath, piIconIndex, piIconId) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszIconPath := pszIconPath is String? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\ExtractAssociatedIconExW", "ptr", hInst, "ptr", pszIconPath, "ushort*", piIconIndex, "ushort*", piIconId)
        return result
    }

    /**
     * Gets a handle to an icon from the specified executable file, DLL, or icon file. To retrieve an array of handles to large or small icons, use the ExtractIconEx function. (ANSI)
     * @remarks
     * When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszExeFileName Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.
     * @param {Integer} nIconIndex Type: <b>UINT</b>
     * 
     * Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file. 
     *                     
     *                     
     * 
     * If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.
     * 
     * If this value is a negative number not equal to 1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use 3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-extracticonexa">ExtractIconEx</a> function.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticona
     * @since windows5.1.2600
     */
    static ExtractIconA(pszExeFileName, nIconIndex) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszExeFileName := pszExeFileName is String? StrPtr(pszExeFileName) : pszExeFileName

        result := DllCall("SHELL32.dll\ExtractIconA", "ptr", hInst, "ptr", pszExeFileName, "uint", nIconIndex)
        return result
    }

    /**
     * Gets a handle to an icon from the specified executable file, DLL, or icon file. To retrieve an array of handles to large or small icons, use the ExtractIconEx function. (Unicode)
     * @remarks
     * When it is no longer needed, you must destroy the icon handle returned by <b>ExtractIcon</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ExtractIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszExeFileName Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.
     * @param {Integer} nIconIndex Type: <b>UINT</b>
     * 
     * Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file. 
     *                     
     *                     
     * 
     * If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.
     * 
     * If this value is a negative number not equal to 1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use 3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-extracticonexa">ExtractIconEx</a> function.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonw
     * @since windows5.1.2600
     */
    static ExtractIconW(pszExeFileName, nIconIndex) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszExeFileName := pszExeFileName is String? StrPtr(pszExeFileName) : pszExeFileName

        result := DllCall("SHELL32.dll\ExtractIconW", "ptr", hInst, "ptr", pszExeFileName, "uint", nIconIndex)
        return result
    }

    /**
     * Sends an appbar message to the system.
     * @param {Integer} dwMessage Type: <b>DWORD</b>
     * @param {Pointer<APPBARDATA>} pData Type: <b>PAPPBARDATA</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-appbardata">APPBARDATA</a> structure. The content of the structure on entry and on exit depends on the value set in the <i>dwMessage</i> parameter. See the individual message pages for specifics.
     * @returns {Pointer} Type: <b>UINT_PTR</b>
     * 
     * This function returns a message-dependent value. For more information, see the Windows SDK documentation for the specific appbar message sent. Links to those documents are given in the See Also section.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shappbarmessage
     * @since windows5.1.2600
     */
    static SHAppBarMessage(dwMessage, pData) {
        result := DllCall("SHELL32.dll\SHAppBarMessage", "uint", dwMessage, "ptr", pData, "ptr")
        return result
    }

    /**
     * Parses an input string that contains references to one or more environment variables and replaces them with their fully expanded values. (ANSI)
     * @remarks
     * Parameters must contain valid, non-<b>NULL</b> values. You must validate these values. Failure to do so can provide unexpected results.
     * 
     * Because the string that is returned in <i>pszSrc</i> will typically be longer than the input string, make sure that the buffer is large enough to hold the expanded version of the string. The allotted size of the <i>cchSrc</i> buffer for ANSI strings must be one larger than the buffer for a Unicode string. When dealing with ANSI strings, use the formula <i>buffer size = string length + terminating null character + 1</i> to determine the minimum correct buffer size.
     * 
     * Because environment variables can be added by the user or applications, the complete list is system-dependent. The following environment variables are standard and are available to both interactive applications and services.
     *     				
     *             	
     * 
     * <ul>
     * <li>ALLUSERSPROFILE</li>
     * <li>APPDATA</li>
     * <li>COMPUTERNAME</li>
     * <li>LOCALAPPDATA</li>
     * <li>NUMBER_OF_PROCESSORS</li>
     * <li>OS</li>
     * <li>PROCESSOR_ARCHITECTURE</li>
     * <li>PROCESSOR_IDENTIFIER</li>
     * <li>PROCESSOR_LEVEL</li>
     * <li>PROCESSOR_REVISION</li>
     * <li>ProgramData</li>
     * <li>ProgramFiles</li>
     * <li>PUBLIC</li>
     * <li>SystemDrive</li>
     * <li>SystemRoot</li>
     * <li>USERPROFILE</li>
     * <li>windir</li>
     * </ul>
     * The following are only available to interactive applications.
     * 
     * <ul>
     * <li>HOMEDRIVE</li>
     * <li>HOMEPATH</li>
     * <li>LOGONSERVER</li>
     * <li>USERDOMAIN</li>
     * <li>USERNAME</li>
     * </ul>
     * The environment variables that correspond to file system folders can be mapped to an equivalent <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> or <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> value can be obtained through <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderlocation">SHGetFolderLocation</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a>. CSIDLs and KNOWNFOLDERIDs are more reliable than environment variable names and should be used whenever possible.
     * @param {Pointer<Byte>} pszSrc Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that contains references to one or more environment variables, each in the following form. Case is ignored. 
     *     					
     *                         
     * 
     * 
     * ``` syntax
     * %VariableName%
     * ```
     * 
     * Any character in the string that is not enclosed in '%' characters is ignored and returned unchanged. Therefore, if your string contains multiple environment variables, you can use any character other than '%' as a separator, including spaces or no separator.
     * 
     * When this function returns successfully, each %<i>VariableName</i>% is replaced with its expanded value. The replacement rules are the same as those used by the command interpreter. If the variable name is not found on the system, the %<i>variableName</i>% is left as it was submitted on entry.
     * 
     * If this function fails due to the expanded string being too large for the buffer, the contents of this buffer are left unchanged.
     * @param {Integer} cchSrc Type: <b>UINT</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>pszSrc</i>. Note that the buffer must be large enough to hold the returned string.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the expanded string fits in the buffer, <b>TRUE</b> is returned in the HIWORD and the length, in characters, of the new <i>pszSrc</i> is returned in the LOWORD. 
     *                     
     *                         
     * 
     * If the expanded string is too large for the buffer, <b>FALSE</b> is returned in the HIWORD and <i>cchSrc</i> in the LOWORD.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-doenvironmentsubsta
     * @since windows5.1.2600
     */
    static DoEnvironmentSubstA(pszSrc, cchSrc) {
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHELL32.dll\DoEnvironmentSubstA", "ptr", pszSrc, "uint", cchSrc, "uint")
        return result
    }

    /**
     * Parses an input string that contains references to one or more environment variables and replaces them with their fully expanded values. (Unicode)
     * @remarks
     * Parameters must contain valid, non-<b>NULL</b> values. You must validate these values. Failure to do so can provide unexpected results.
     * 
     * Because the string that is returned in <i>pszSrc</i> will typically be longer than the input string, make sure that the buffer is large enough to hold the expanded version of the string. The allotted size of the <i>cchSrc</i> buffer for ANSI strings must be one larger than the buffer for a Unicode string. When dealing with ANSI strings, use the formula <i>buffer size = string length + terminating null character + 1</i> to determine the minimum correct buffer size.
     * 
     * Because environment variables can be added by the user or applications, the complete list is system-dependent. The following environment variables are standard and are available to both interactive applications and services.
     *     				
     *             	
     * 
     * <ul>
     * <li>ALLUSERSPROFILE</li>
     * <li>APPDATA</li>
     * <li>COMPUTERNAME</li>
     * <li>LOCALAPPDATA</li>
     * <li>NUMBER_OF_PROCESSORS</li>
     * <li>OS</li>
     * <li>PROCESSOR_ARCHITECTURE</li>
     * <li>PROCESSOR_IDENTIFIER</li>
     * <li>PROCESSOR_LEVEL</li>
     * <li>PROCESSOR_REVISION</li>
     * <li>ProgramData</li>
     * <li>ProgramFiles</li>
     * <li>PUBLIC</li>
     * <li>SystemDrive</li>
     * <li>SystemRoot</li>
     * <li>USERPROFILE</li>
     * <li>windir</li>
     * </ul>
     * The following are only available to interactive applications.
     * 
     * <ul>
     * <li>HOMEDRIVE</li>
     * <li>HOMEPATH</li>
     * <li>LOGONSERVER</li>
     * <li>USERDOMAIN</li>
     * <li>USERNAME</li>
     * </ul>
     * The environment variables that correspond to file system folders can be mapped to an equivalent <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> or <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> value can be obtained through <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderlocation">SHGetFolderLocation</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath</a>. CSIDLs and KNOWNFOLDERIDs are more reliable than environment variable names and should be used whenever possible.
     * @param {Pointer<Char>} pszSrc Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that contains references to one or more environment variables, each in the following form. Case is ignored. 
     *     					
     *                         
     * 
     * 
     * ``` syntax
     * %VariableName%
     * ```
     * 
     * Any character in the string that is not enclosed in '%' characters is ignored and returned unchanged. Therefore, if your string contains multiple environment variables, you can use any character other than '%' as a separator, including spaces or no separator.
     * 
     * When this function returns successfully, each %<i>VariableName</i>% is replaced with its expanded value. The replacement rules are the same as those used by the command interpreter. If the variable name is not found on the system, the %<i>variableName</i>% is left as it was submitted on entry.
     * 
     * If this function fails due to the expanded string being too large for the buffer, the contents of this buffer are left unchanged.
     * @param {Integer} cchSrc Type: <b>UINT</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>pszSrc</i>. Note that the buffer must be large enough to hold the returned string.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the expanded string fits in the buffer, <b>TRUE</b> is returned in the HIWORD and the length, in characters, of the new <i>pszSrc</i> is returned in the LOWORD. 
     *                     
     *                         
     * 
     * If the expanded string is too large for the buffer, <b>FALSE</b> is returned in the HIWORD and <i>cchSrc</i> in the LOWORD.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-doenvironmentsubstw
     * @since windows5.1.2600
     */
    static DoEnvironmentSubstW(pszSrc, cchSrc) {
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHELL32.dll\DoEnvironmentSubstW", "ptr", pszSrc, "uint", cchSrc, "uint")
        return result
    }

    /**
     * The ExtractIconEx function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file. (ANSI)
     * @remarks
     * When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * 
     * To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpszFile Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.
     * @param {Integer} nIconIndex Type: <b>int</b>
     * 
     * Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file. 
     *     
     *                         
     * 
     * If this value is 1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.
     * 
     *  If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.
     * @param {Pointer<Void>} phiconLarge Type: <b>HICON*</b>
     * 
     * Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.
     * @param {Pointer<Void>} phiconSmall Type: <b>HICON*</b>
     * 
     * Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.
     * @param {Integer} nIcons Type: <b>UINT</b>
     * 
     * The number of icons to extract from the file.
     * @returns {Integer} Type: **UINT**
     * 
     * If the *nIconIndex* parameter is -1 and both the *phiconLarge* and *phiconSmall* parameters are **NULL**, then the return value is the number of icons contained in the specified file.
     * 
     * If the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**, the return value is the number of icons successfully extracted from the file.
     * 
     * > [!NOTE]
     * > If the function encounters an error, it returns **UINT_MAX**. In this case, you can call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md) to retrieve the error code. For example, this function returns **UINT_MAX** if the file specified by *lpszFile* cannot be found while the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**. In this case, **GetLastError** returns **ERROR_FILE_NOT_FOUND** (2).
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonexa
     * @since windows5.1.2600
     */
    static ExtractIconExA(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons) {
        lpszFile := lpszFile is String? StrPtr(lpszFile) : lpszFile

        A_LastError := 0

        result := DllCall("SHELL32.dll\ExtractIconExA", "ptr", lpszFile, "int", nIconIndex, "ptr", phiconLarge, "ptr", phiconSmall, "uint", nIcons, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The ExtractIconEx function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file. (Unicode)
     * @remarks
     * When they are no longer needed, you must destroy all icons extracted by <b>ExtractIconEx</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * 
     * To retrieve the dimensions of the large and small icons, use this function with the SM_CXICON, SM_CYICON, SM_CXSMICON, and SM_CYSMICON flags.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ExtractIconEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpszFile Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.
     * @param {Integer} nIconIndex Type: <b>int</b>
     * 
     * Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file. 
     *     
     *                         
     * 
     * If this value is 1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.
     * 
     *  If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.
     * @param {Pointer<Void>} phiconLarge Type: <b>HICON*</b>
     * 
     * Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.
     * @param {Pointer<Void>} phiconSmall Type: <b>HICON*</b>
     * 
     * Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.
     * @param {Integer} nIcons Type: <b>UINT</b>
     * 
     * The number of icons to extract from the file.
     * @returns {Integer} Type: **UINT**
     * 
     * If the *nIconIndex* parameter is -1 and both the *phiconLarge* and *phiconSmall* parameters are **NULL**, then the return value is the number of icons contained in the specified file.
     * 
     * If the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**, the return value is the number of icons successfully extracted from the file.
     * 
     * > [!NOTE]
     * > If the function encounters an error, it returns **UINT_MAX**. In this case, you can call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md) to retrieve the error code. For example, this function returns **UINT_MAX** if the file specified by *lpszFile* cannot be found while the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**. In this case, **GetLastError** returns **ERROR_FILE_NOT_FOUND** (2).
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extracticonexw
     * @since windows5.1.2600
     */
    static ExtractIconExW(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons) {
        lpszFile := lpszFile is String? StrPtr(lpszFile) : lpszFile

        A_LastError := 0

        result := DllCall("SHELL32.dll\ExtractIconExW", "ptr", lpszFile, "int", nIconIndex, "ptr", phiconLarge, "ptr", phiconSmall, "uint", nIcons, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies, moves, renames, or deletes a file system object. This function has been replaced in WindowsVista by IFileOperation.
     * @remarks
     * You should use fully qualified path names with this function. Using it with relative path names is not thread safe.
     * 
     * With two exceptions, you cannot use <b>SHFileOperation</b> to move special folders from a local drive to a remote computer by specifying a network path. The exceptions are the <b>My Documents</b> (<a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_PERSONAL</a>, <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_DOCUMENTS</a>) and <b>My Pictures</b> folders (<a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>).
     * 
     * When used to delete a file, <b>SHFileOperation</b> permanently deletes the file unless you set the <b>FOF_ALLOWUNDO</b> flag in the <b>fFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a> structure pointed to by <i>lpFileOp</i>. Setting that flag sends the file to the Recycle Bin. If you want to simply delete a file and guarantee that it is not placed in the Recycle Bin, use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>.
     * 
     * If a copy callback handler is exposed and registered, <b>SHFileOperation</b> calls it unless you set a flag such as <b>FOF_NOCONFIRMATION</b> in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>. See <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/bb776048(v=vs.85)">ICopyHook::CopyCallback</a> for details on implementing copy callback handlers.
     * 
     * File deletion is recursive unless you set the <b>FOF_NORECURSION</b> flag in <i>lpFileOp</i>.
     * 
     * <h3><a id="Connecting_Files"></a><a id="connecting_files"></a><a id="CONNECTING_FILES"></a>Connecting Files</h3>
     * With Windows2000 or later, it is possible to <i>connect</i> an HTML file with a folder that contains related files such as Graphics Interchange Format (GIF) images or style sheets. If file connection is enabled, when you move or copy the HTML file, the connected folder and all of its files are also moved or copied. Conversely, if you move the folder with the related files, the HTML file is also moved.
     * 
     * The HTML file must have a .htm or .html extension. You create the connection to the related files by placing the folder that contains them into the same folder as the HTML file. The name of the folder that contains the connected files must be the same as the name of the HTML file followed by "_files" or ".files" (this is case sensitive; for example, ".Files" does not work). An example is given here.
     * 
     * <ol>
     * <li>Create a file named Test.htm in the C:\Files directory (C:\Files\Test.htm).</li>
     * <li>Create a new folder named Test.files in the C:\Files directory (C:\Files\Test.files).</li>
     * <li>Populate the folder with a few files. Any file placed in this folder is connected to Test.htm.</li>
     * <li>Move or copy the Test.htm file to the C:\Files2 directory.</li>
     * <li>Note that the Test.files directory is now found in the C:\Files2 directory as well.</li>
     * </ol>
     * 
     * 
     * File connection is enabled by default. It can be disabled by adding a <b>REG_DWORD</b> entry, NoFileFolderConnection, as shown here:
     * 
     * 
     * <pre><b>HKEY_CURRENT_USER</b>
     * <b>Software</b>
     * <b>Microsoft</b>
     * <b>Windows</b>
     * <b>CurrentVersion</b>
     * <b>Explorer</b>
     * <b>NoFileFolderConnection</b></pre>
     * 
     * 
     * Setting NoFileFolderConnection to 1 disables file connection. If the value is set to zero or is missing, file connection is enabled.
     * 
     * To move only the specified files and none of the connected files, set the <b>FOF_NO_CONNECTED_ELEMENTS</b> flag in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>.
     * 
     * Note that the use of a folder with a name like "MyFile_files" to define a connection may not be valid for localized versions of Windows. The term "files" may need to be replaced by the equivalent word in the local language.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHFileOperation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SHFILEOPSTRUCTA>} lpFileOp Type: <b>LPSHFILEOPSTRUCT</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero. 
     * 
     *                     
     * 
     * It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a>. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.
     * 
     * Do not use <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> with the return values of this function.
     * 
     * To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:
     * 
     * <ul>
     * <li>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</li>
     * <li>These error codes are subject to change and have historically done so.</li>
     * <li>These values are provided only as an aid in debugging. They should not be regarded as definitive.</li>
     * </ul>
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error Code</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>DE_SAMEFILE</td>
     * <td>0x71</td>
     * <td>The source and destination files are the same file.</td>
     * </tr>
     * <tr>
     * <td>DE_MANYSRC1DEST</td>
     * <td>0x72</td>
     * <td>Multiple file paths were specified in the source buffer, but only one destination file path.</td>
     * </tr>
     * <tr>
     * <td>DE_DIFFDIR</td>
     * <td>0x73</td>
     * <td>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</td>
     * </tr>
     * <tr>
     * <td>DE_ROOTDIR</td>
     * <td>0x74</td>
     * <td>The source is a root directory, which cannot be moved or renamed.</td>
     * </tr>
     * <tr>
     * <td>DE_OPCANCELLED</td>
     * <td>0x75</td>
     * <td>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</td>
     * </tr>
     * <tr>
     * <td>DE_DESTSUBTREE</td>
     * <td>0x76</td>
     * <td>The destination is a subtree of the source.</td>
     * </tr>
     * <tr>
     * <td>DE_ACCESSDENIEDSRC</td>
     * <td>0x78</td>
     * <td>Security settings denied access to the source.</td>
     * </tr>
     * <tr>
     * <td>DE_PATHTOODEEP</td>
     * <td>0x79</td>
     * <td>The source or destination path exceeded or would exceed MAX_PATH.</td>
     * </tr>
     * <tr>
     * <td>DE_MANYDEST</td>
     * <td>0x7A</td>
     * <td>The operation involved multiple destination paths, which can fail in the case of a move operation.</td>
     * </tr>
     * <tr>
     * <td>DE_INVALIDFILES</td>
     * <td>0x7C</td>
     * <td>The path in the source or destination or both was invalid.</td>
     * </tr>
     * <tr>
     * <td>DE_DESTSAMETREE</td>
     * <td>0x7D</td>
     * <td>The source and destination have the same parent folder.</td>
     * </tr>
     * <tr>
     * <td>DE_FLDDESTISFILE</td>
     * <td>0x7E</td>
     * <td>The destination path is an existing file.</td>
     * </tr>
     * <tr>
     * <td>DE_FILEDESTISFLD</td>
     * <td>0x80</td>
     * <td>The destination path is an existing folder.</td>
     * </tr>
     * <tr>
     * <td>DE_FILENAMETOOLONG</td>
     * <td>0x81</td>
     * <td>The name of the file exceeds MAX_PATH.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_CDROM</td>
     * <td>0x82</td>
     * <td>The destination is a read-only CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_DVD</td>
     * <td>0x83</td>
     * <td>The destination is a read-only DVD, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_CDRECORD</td>
     * <td>0x84</td>
     * <td>The destination is a writable CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_FILE_TOO_LARGE</td>
     * <td>0x85</td>
     * <td>The file involved in the operation is too large for the destination media or file system.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_CDROM</td>
     * <td>0x86</td>
     * <td>The source is a read-only CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_DVD</td>
     * <td>0x87</td>
     * <td>The source is a read-only DVD, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_CDRECORD</td>
     * <td>0x88</td>
     * <td>The source is a writable CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_ERROR_MAX</td>
     * <td>0xB7</td>
     * <td>MAX_PATH was exceeded during the operation.</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>0x402</td>
     * <td>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on WindowsVista and later.</td>
     * </tr>
     * <tr>
     * <td>ERRORONDEST</td>
     * <td>0x10000</td>
     * <td>An unspecified error occurred on the destination.</td>
     * </tr>
     * <tr>
     * <td>DE_ROOTDIR | ERRORONDEST</td>
     * <td>0x10074</td>
     * <td>Destination is a root directory and cannot be renamed.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shfileoperationa
     * @since windows5.1.2600
     */
    static SHFileOperationA(lpFileOp) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\SHFileOperationA", "ptr", lpFileOp, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies, moves, renames, or deletes a file system object. On WindowsVista and later releases, we recommend that you use IFileOperation instead of this function.
     * @remarks
     * You should use fully qualified path names with this function. Using it with relative path names is not thread safe.
     * 
     * With two exceptions, you cannot use <b>SHFileOperation</b> to move special folders from a local drive to a remote computer by specifying a network path. The exceptions are the <b>My Documents</b> (<a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_PERSONAL</a>, <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_DOCUMENTS</a>) and <b>My Pictures</b> folders (<a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_MYPICTURES</a>).
     * 
     * When used to delete a file, <b>SHFileOperation</b> permanently deletes the file unless you set the <b>FOF_ALLOWUNDO</b> flag in the <b>fFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a> structure pointed to by <i>lpFileOp</i>. Setting that flag sends the file to the Recycle Bin. If you want to simply delete a file and guarantee that it is not placed in the Recycle Bin, use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>.
     * 
     * If a copy callback handler is exposed and registered, <b>SHFileOperation</b> calls it unless you set a flag such as <b>FOF_NOCONFIRMATION</b> in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>. See <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/bb776048(v=vs.85)">ICopyHook::CopyCallback</a> for details on implementing copy callback handlers.
     * 
     * File deletion is recursive unless you set the <b>FOF_NORECURSION</b> flag in <i>lpFileOp</i>.
     * 
     * <h3><a id="Connecting_Files"></a><a id="connecting_files"></a><a id="CONNECTING_FILES"></a>Connecting Files</h3>
     * With Windows2000 or later, it is possible to <i>connect</i> an HTML file with a folder that contains related files such as Graphics Interchange Format (GIF) images or style sheets. If file connection is enabled, when you move or copy the HTML file, the connected folder and all of its files are also moved or copied. Conversely, if you move the folder with the related files, the HTML file is also moved.
     * 
     * The HTML file must have a .htm or .html extension. You create the connection to the related files by placing the folder that contains them into the same folder as the HTML file. The name of the folder that contains the connected files must be the same as the name of the HTML file followed by "_files" or ".files" (this is case sensitive; for example, ".Files" does not work). An example is given here.
     * 
     * <ol>
     * <li>Create a file named Test.htm in the C:\Files directory (C:\Files\Test.htm).</li>
     * <li>Create a new folder named Test.files in the C:\Files directory (C:\Files\Test.files).</li>
     * <li>Populate the folder with a few files. Any file placed in this folder is connected to Test.htm.</li>
     * <li>Move or copy the Test.htm file to the C:\Files2 directory.</li>
     * <li>Note that the Test.files directory is now found in the C:\Files2 directory as well.</li>
     * </ol>
     * 
     * 
     * File connection is enabled by default. It can be disabled by adding a <b>REG_DWORD</b> entry, NoFileFolderConnection, as shown here:
     * 
     * 
     * <pre><b>HKEY_CURRENT_USER</b>
     * <b>Software</b>
     * <b>Microsoft</b>
     * <b>Windows</b>
     * <b>CurrentVersion</b>
     * <b>Explorer</b>
     * <b>NoFileFolderConnection</b></pre>
     * 
     * 
     * Setting NoFileFolderConnection to 1 disables file connection. If the value is set to zero or is missing, file connection is enabled.
     * 
     * To move only the specified files and none of the connected files, set the <b>FOF_NO_CONNECTED_ELEMENTS</b> flag in the <b>fFlags</b> member of the structure pointed to by <i>lpFileOp</i>.
     * 
     * Note that the use of a folder with a name like "MyFile_files" to define a connection may not be valid for localized versions of Windows. The term "files" may need to be replaced by the equivalent word in the local language.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHFileOperation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SHFILEOPSTRUCTW>} lpFileOp Type: <b>LPSHFILEOPSTRUCT</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero. 
     * 
     *                     
     * 
     * It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a>. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.
     * 
     * Do not use <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> with the return values of this function.
     * 
     * To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:
     * 
     * <ul>
     * <li>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</li>
     * <li>These error codes are subject to change and have historically done so.</li>
     * <li>These values are provided only as an aid in debugging. They should not be regarded as definitive.</li>
     * </ul>
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error Code</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>DE_SAMEFILE</td>
     * <td>0x71</td>
     * <td>The source and destination files are the same file.</td>
     * </tr>
     * <tr>
     * <td>DE_MANYSRC1DEST</td>
     * <td>0x72</td>
     * <td>Multiple file paths were specified in the source buffer, but only one destination file path.</td>
     * </tr>
     * <tr>
     * <td>DE_DIFFDIR</td>
     * <td>0x73</td>
     * <td>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</td>
     * </tr>
     * <tr>
     * <td>DE_ROOTDIR</td>
     * <td>0x74</td>
     * <td>The source is a root directory, which cannot be moved or renamed.</td>
     * </tr>
     * <tr>
     * <td>DE_OPCANCELLED</td>
     * <td>0x75</td>
     * <td>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</td>
     * </tr>
     * <tr>
     * <td>DE_DESTSUBTREE</td>
     * <td>0x76</td>
     * <td>The destination is a subtree of the source.</td>
     * </tr>
     * <tr>
     * <td>DE_ACCESSDENIEDSRC</td>
     * <td>0x78</td>
     * <td>Security settings denied access to the source.</td>
     * </tr>
     * <tr>
     * <td>DE_PATHTOODEEP</td>
     * <td>0x79</td>
     * <td>The source or destination path exceeded or would exceed MAX_PATH.</td>
     * </tr>
     * <tr>
     * <td>DE_MANYDEST</td>
     * <td>0x7A</td>
     * <td>The operation involved multiple destination paths, which can fail in the case of a move operation.</td>
     * </tr>
     * <tr>
     * <td>DE_INVALIDFILES</td>
     * <td>0x7C</td>
     * <td>The path in the source or destination or both was invalid.</td>
     * </tr>
     * <tr>
     * <td>DE_DESTSAMETREE</td>
     * <td>0x7D</td>
     * <td>The source and destination have the same parent folder.</td>
     * </tr>
     * <tr>
     * <td>DE_FLDDESTISFILE</td>
     * <td>0x7E</td>
     * <td>The destination path is an existing file.</td>
     * </tr>
     * <tr>
     * <td>DE_FILEDESTISFLD</td>
     * <td>0x80</td>
     * <td>The destination path is an existing folder.</td>
     * </tr>
     * <tr>
     * <td>DE_FILENAMETOOLONG</td>
     * <td>0x81</td>
     * <td>The name of the file exceeds MAX_PATH.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_CDROM</td>
     * <td>0x82</td>
     * <td>The destination is a read-only CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_DVD</td>
     * <td>0x83</td>
     * <td>The destination is a read-only DVD, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_CDRECORD</td>
     * <td>0x84</td>
     * <td>The destination is a writable CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_FILE_TOO_LARGE</td>
     * <td>0x85</td>
     * <td>The file involved in the operation is too large for the destination media or file system.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_CDROM</td>
     * <td>0x86</td>
     * <td>The source is a read-only CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_DVD</td>
     * <td>0x87</td>
     * <td>The source is a read-only DVD, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_CDRECORD</td>
     * <td>0x88</td>
     * <td>The source is a writable CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_ERROR_MAX</td>
     * <td>0xB7</td>
     * <td>MAX_PATH was exceeded during the operation.</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>0x402</td>
     * <td>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on WindowsVista and later.</td>
     * </tr>
     * <tr>
     * <td>ERRORONDEST</td>
     * <td>0x10000</td>
     * <td>An unspecified error occurred on the destination.</td>
     * </tr>
     * <tr>
     * <td>DE_ROOTDIR | ERRORONDEST</td>
     * <td>0x10074</td>
     * <td>Destination is a root directory and cannot be renamed.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shfileoperationw
     * @since windows5.1.2600
     */
    static SHFileOperationW(lpFileOp) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\SHFileOperationW", "ptr", lpFileOp, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Frees a file name mapping object that was retrieved by the SHFileOperation function.
     * @param {Pointer<Void>} hNameMappings Type: <b>HANDLE</b>
     * 
     * A handle to the file name mapping object to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shfreenamemappings
     * @since windows5.1.2600
     */
    static SHFreeNameMappings(hNameMappings) {
        DllCall("SHELL32.dll\SHFreeNameMappings", "ptr", hNameMappings)
    }

    /**
     * Performs an operation on a specified file. (ShellExecuteExA)
     * @remarks
     * Because <b>ShellExecuteEx</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecuteEx</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:
     * 
     *                 
     * 
     * 
     * ``` syntax
     * CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
     * ```
     * 
     * There are instances where <b>ShellExecuteEx</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to always initialize COM before using this function.
     * 
     * When DLLs are loaded into your process, you acquire a lock known as a <a href="https://docs.microsoft.com/windows/win32/win7appqual/preventing-hangs-in-windows-applications">loader lock</a>. The <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function always executes under the loader lock. It is important that you do not call <b>ShellExecuteEx</b> while you hold a loader lock. Because <b>ShellExecuteEx</b> is extensible, you could load code that does not function properly in the presence of a loader lock, risking a deadlock and therefore an unresponsive thread.
     * 
     * With multiple monitors, if you specify an <b>HWND</b> and set the <b>lpVerb</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> structure pointed to by <i>lpExecInfo</i> to "Properties", any windows created by <b>ShellExecuteEx</b> might not appear in the correct position.
     * 
     * If the function succeeds, it sets the <b>hInstApp</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> structure to a value greater than 32. If the function fails, <b>hInstApp</b> is set to the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">SE_ERR_XXX</a> error value that best indicates the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and can be compared only to either the value 32 or the SE_ERR_XXX error codes.
     * 
     * The SE_ERR_XXX error values are provided for compatibility with <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">ShellExecute</a>. To retrieve more accurate error information, use <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. It may return one of the following values.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>ERROR_FILE_NOT_FOUND </td>
     * <td>The specified file was not found.</td>
     * </tr>
     * <tr>
     * <td>ERROR_PATH_NOT_FOUND </td>
     * <td>The specified path was not found.</td>
     * </tr>
     * <tr>
     * <td>ERROR_DDE_FAIL </td>
     * <td>The Dynamic Data Exchange (DDE) transaction failed.</td>
     * </tr>
     * <tr>
     * <td>ERROR_NO_ASSOCIATION </td>
     * <td>There is no application associated with the specified file name extension.</td>
     * </tr>
     * <tr>
     * <td>ERROR_ACCESS_DENIED </td>
     * <td>Access to the specified file is denied.</td>
     * </tr>
     * <tr>
     * <td>ERROR_DLL_NOT_FOUND </td>
     * <td>One of the library files necessary to run the application can't be found.</td>
     * </tr>
     * <tr>
     * <td>ERROR_CANCELLED </td>
     * <td>The function prompted the user for additional information, but the user canceled the request.</td>
     * </tr>
     * <tr>
     * <td>ERROR_NOT_ENOUGH_MEMORY </td>
     * <td>There is not enough memory to perform the specified action.</td>
     * </tr>
     * <tr>
     * <td>ERROR_SHARING_VIOLATION </td>
     * <td>A sharing violation occurred.</td>
     * </tr>
     * </table>
     * 
     * 
     * <b>Opening items from a URL</b> You can register your application to activate when passed URLs. You can also specify which protocols your application supports. See <a href="https://docs.microsoft.com/windows/desktop/shell/app-registration">Application Registration</a> for more info.
     * 
     * <b>Site chain support</b> As of Windows 8, you can provide a site chain pointer to the <b>ShellExecuteEx</b> function to support item activation with services from that site. See <a href="https://docs.microsoft.com/windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</a> for more information. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ShellExecuteEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SHELLEXECUTEINFOA>} pExecInfo Type: <b>SHELLEXECUTEINFO*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> structure that contains and receives information about the application being executed.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellexecuteexa
     * @since windows5.1.2600
     */
    static ShellExecuteExA(pExecInfo) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\ShellExecuteExA", "ptr", pExecInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Performs an operation on a specified file. (ShellExecuteExW)
     * @remarks
     * Because <b>ShellExecuteEx</b> can delegate execution to Shell extensions (data sources, context menu handlers, verb implementations) that are activated using Component Object Model (COM), COM should be initialized before <b>ShellExecuteEx</b> is called. Some Shell extensions require the COM single-threaded apartment (STA) type. In that case, COM should be initialized as shown here:
     * 
     *                 
     * 
     * 
     * ``` syntax
     * CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)
     * ```
     * 
     * There are instances where <b>ShellExecuteEx</b> does not use one of these types of Shell extension and those instances would not require COM to be initialized at all. Nonetheless, it is good practice to always initialize COM before using this function.
     * 
     * When DLLs are loaded into your process, you acquire a lock known as a <a href="https://docs.microsoft.com/windows/win32/win7appqual/preventing-hangs-in-windows-applications">loader lock</a>. The <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function always executes under the loader lock. It is important that you do not call <b>ShellExecuteEx</b> while you hold a loader lock. Because <b>ShellExecuteEx</b> is extensible, you could load code that does not function properly in the presence of a loader lock, risking a deadlock and therefore an unresponsive thread.
     * 
     * With multiple monitors, if you specify an <b>HWND</b> and set the <b>lpVerb</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> structure pointed to by <i>lpExecInfo</i> to "Properties", any windows created by <b>ShellExecuteEx</b> might not appear in the correct position.
     * 
     * If the function succeeds, it sets the <b>hInstApp</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> structure to a value greater than 32. If the function fails, <b>hInstApp</b> is set to the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">SE_ERR_XXX</a> error value that best indicates the cause of the failure. Although <b>hInstApp</b> is declared as an HINSTANCE for compatibility with 16-bit Windows applications, it is not a true HINSTANCE. It can be cast only to an <b>int</b> and can be compared only to either the value 32 or the SE_ERR_XXX error codes.
     * 
     * The SE_ERR_XXX error values are provided for compatibility with <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">ShellExecute</a>. To retrieve more accurate error information, use <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. It may return one of the following values.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>ERROR_FILE_NOT_FOUND </td>
     * <td>The specified file was not found.</td>
     * </tr>
     * <tr>
     * <td>ERROR_PATH_NOT_FOUND </td>
     * <td>The specified path was not found.</td>
     * </tr>
     * <tr>
     * <td>ERROR_DDE_FAIL </td>
     * <td>The Dynamic Data Exchange (DDE) transaction failed.</td>
     * </tr>
     * <tr>
     * <td>ERROR_NO_ASSOCIATION </td>
     * <td>There is no application associated with the specified file name extension.</td>
     * </tr>
     * <tr>
     * <td>ERROR_ACCESS_DENIED </td>
     * <td>Access to the specified file is denied.</td>
     * </tr>
     * <tr>
     * <td>ERROR_DLL_NOT_FOUND </td>
     * <td>One of the library files necessary to run the application can't be found.</td>
     * </tr>
     * <tr>
     * <td>ERROR_CANCELLED </td>
     * <td>The function prompted the user for additional information, but the user canceled the request.</td>
     * </tr>
     * <tr>
     * <td>ERROR_NOT_ENOUGH_MEMORY </td>
     * <td>There is not enough memory to perform the specified action.</td>
     * </tr>
     * <tr>
     * <td>ERROR_SHARING_VIOLATION </td>
     * <td>A sharing violation occurred.</td>
     * </tr>
     * </table>
     * 
     * 
     * <b>Opening items from a URL</b> You can register your application to activate when passed URLs. You can also specify which protocols your application supports. See <a href="https://docs.microsoft.com/windows/desktop/shell/app-registration">Application Registration</a> for more info.
     * 
     * <b>Site chain support</b> As of Windows 8, you can provide a site chain pointer to the <b>ShellExecuteEx</b> function to support item activation with services from that site. See <a href="https://docs.microsoft.com/windows/desktop/shell/launch">Launching Applications (ShellExecute, ShellExecuteEx, SHELLEXECUTEINFO)</a> for more information. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines ShellExecuteEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SHELLEXECUTEINFOW>} pExecInfo Type: <b>SHELLEXECUTEINFO*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> structure that contains and receives information about the application being executed.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellexecuteexw
     * @since windows5.1.2600
     */
    static ShellExecuteExW(pExecInfo) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\ShellExecuteExW", "ptr", pExecInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new user-mode process and its primary thread to run a specified executable file.
     * @remarks
     * This function is similar to <a href="https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">ShellExecuteEx</a> with <b>runas</b> as the verb. However, <b>SHCreateProcessAsUserW</b> creates a process that runs in the security context of the user represented by the <b>hUserToken</b> member of the structure pointed to by <i>pscpi</i>. The <b>lpProcessInformation</b> member can be used to return a <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> structure with information on the new process.
     * 
     * The <b>runas</b> verb must be supported by the executable file's <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-types">file type</a>. The .exe file type supports <b>runas</b>. Use the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-assocquerystringa">AssocQueryString</a> function to check whether <b>runas</b> is supported by other file types. The following code fragment illustrates the syntax.
     * 			
     * 				
     * 
     * 
     * ```
     * AssocQueryString(0, ASSOCSTR_COMMAND, pszFile, TEXT("runas"), NULL, &cchVerb)
     * ```
     * 
     * 
     * For a discussion of how to use the Shell to launch applications, see <a href="https://docs.microsoft.com/windows/desktop/shell/launch">Launching Applications</a>.
     * 
     * <b>SHCreateProcessAsUserW</b> is not supported under WindowsXP. Users requiring similar functionality should examine <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera">CreateProcessAsUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createprocesswithlogonw">CreateProcessWithLogonW</a> and <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecuteexa">ShellExecuteEx</a>, carefully evaluating each based on required functionality and security. <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> can be used to extract information used with <b>CreateProcess</b>, if necessary.
     * @param {Pointer<SHCREATEPROCESSINFOW>} pscpi Type: <b>PSHCREATEPROCESSINFOW</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shcreateprocessinfow">SHCREATEPROCESSINFOW</a> structure with information on how to create the process.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> if not. To retrieve extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shcreateprocessasuserw
     * @since windows5.0
     */
    static SHCreateProcessAsUserW(pscpi) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\SHCreateProcessAsUserW", "ptr", pscpi, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enforces strict validation of parameters used in a call to CreateProcess or ShellExecute.
     * @remarks
     * This function is used when a calling process needs the deterministic behavior from a command template, regardless of execution context. It ignores the current process state, such as the <c>%PATH%</c>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getcurrentdirectory">GetCurrentDirectory</a>, and parent process directory.
     * 
     * This function is used when the command is hard-coded.
     * 
     * This function is used by <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">ShellExecute</a> when handling file associations from HKEY_CLASSES_ROOT. The purpose of this function is to reduce <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> command-line exploits. It is not designed for processing user input and if used for that purpose can generate unexpected failures.
     * @param {Pointer<Char>} pszCmdTemplate Type: <b>PCWSTR</b>
     * 
     * A command line, which may or may not include parameters. If the parameters are substitution parameters, then <b>SHEvaluateSystemCommandTemplate</b> should be called before parameters have been replaced.
     * @param {Pointer<Char>} ppszApplication Type: <b>PWSTR*</b>
     * 
     * A pointer to the verified path to the application. This value should be passed as the <i>lpApplication</i> parameter in a call to <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> or as the <i>lpFile</i> parameter in a call to <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">ShellExecute</a>. This resource is allocated using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>.
     * @param {Pointer<Char>} ppszCommandLine Type: <b>PWSTR*</b>
     * 
     * A pointer to a command-line string template to be used in a call to <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>. Command-line parameters should be specified based on this template, and then passed as the <i>lpCommandLine</i> parameter to <b>CreateProcess</b>. It is guaranteed to be of a form that <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-pathgetargsa">PathGetArgs</a> can always read correctly. This resource is allocated using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>. 
     * 
     *                     
     * 
     * This parameter can be <b>NULL</b> if this function is not being used in association with a call to <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>.
     * @param {Pointer<Char>} ppszParameters Type: <b>PWSTR*</b>
     * 
     * A pointer to a command-line string template to be used in a call to <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">ShellExecute</a>. Command-line parameters should be specified based on this template, and then passed as the <i>lpParameters</i> parameter to <b>ShellExecute</b>. This parameter is identical to calling <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-pathgetargsa">PathGetArgs</a>. This resource is allocated using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>. 
     * 
     *                     
     * 
     * This parameter can be <b>NULL</b> if this function is not being used in association with a call to <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shevaluatesystemcommandtemplate
     * @since windows6.0.6000
     */
    static SHEvaluateSystemCommandTemplate(pszCmdTemplate, ppszApplication, ppszCommandLine, ppszParameters) {
        pszCmdTemplate := pszCmdTemplate is String? StrPtr(pszCmdTemplate) : pszCmdTemplate

        result := DllCall("SHELL32.dll\SHEvaluateSystemCommandTemplate", "ptr", pszCmdTemplate, "ptr", ppszApplication, "ptr", ppszCommandLine, "ptr", ppszParameters, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves an object that implements an IQueryAssociations interface.
     * @remarks
     * For systems earlier than WindowsVista, use the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-assoccreate">AssocCreate</a> function.
     * @param {Pointer<ASSOCIATIONELEMENT>} rgClasses Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-associationelement">ASSOCIATIONELEMENT</a>*</b>
     * 
     * A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-associationelement">ASSOCIATIONELEMENT</a> structures.
     * @param {Integer} cClasses Type: <b>ULONG</b>
     * 
     * The number of elements in the array pointed to by <i>rgClasses</i>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired IID, normally IID_IQueryAssociations.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is normally <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-assoccreateforclasses
     * @since windows6.0.6000
     */
    static AssocCreateForClasses(rgClasses, cClasses, riid, ppv) {
        result := DllCall("SHELL32.dll\AssocCreateForClasses", "ptr", rgClasses, "uint", cClasses, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive. (ANSI)
     * @remarks
     * With Windows2000, if <b>NULL</b> is passed in the <i>pszRootPath</i> parameter, the function fails and returns an E_INVALIDARG error code. In earlier versions of the operating system, you can pass an empty string or <b>NULL</b>. If <i>pszRootPath</i> contains an empty string or <b>NULL</b>, information is retrieved for all Recycle Bins on all drives.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHQueryRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszRootPath Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).
     * @param {Pointer<SHQUERYRBINFO>} pSHQueryRBInfo Type: <b>LPSHQUERYRBINFO</b>
     * 
     * The address of a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shqueryrbinfo">SHQUERYRBINFO</a> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shqueryrecyclebina
     * @since windows5.0
     */
    static SHQueryRecycleBinA(pszRootPath, pSHQueryRBInfo) {
        pszRootPath := pszRootPath is String? StrPtr(pszRootPath) : pszRootPath

        result := DllCall("SHELL32.dll\SHQueryRecycleBinA", "ptr", pszRootPath, "ptr", pSHQueryRBInfo, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive. (Unicode)
     * @remarks
     * With Windows2000, if <b>NULL</b> is passed in the <i>pszRootPath</i> parameter, the function fails and returns an E_INVALIDARG error code. In earlier versions of the operating system, you can pass an empty string or <b>NULL</b>. If <i>pszRootPath</i> contains an empty string or <b>NULL</b>, information is retrieved for all Recycle Bins on all drives.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHQueryRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszRootPath Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).
     * @param {Pointer<SHQUERYRBINFO>} pSHQueryRBInfo Type: <b>LPSHQUERYRBINFO</b>
     * 
     * The address of a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shqueryrbinfo">SHQUERYRBINFO</a> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shqueryrecyclebinw
     * @since windows5.0
     */
    static SHQueryRecycleBinW(pszRootPath, pSHQueryRBInfo) {
        pszRootPath := pszRootPath is String? StrPtr(pszRootPath) : pszRootPath

        result := DllCall("SHELL32.dll\SHQueryRecycleBinW", "ptr", pszRootPath, "ptr", pSHQueryRBInfo, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Empties the Recycle Bin on the specified drive. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shellapi.h header defines SHEmptyRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.
     * @param {Pointer<Byte>} pszRootPath Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system\. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shemptyrecyclebina
     * @since windows5.0
     */
    static SHEmptyRecycleBinA(hwnd, pszRootPath, dwFlags) {
        pszRootPath := pszRootPath is String? StrPtr(pszRootPath) : pszRootPath

        result := DllCall("SHELL32.dll\SHEmptyRecycleBinA", "ptr", hwnd, "ptr", pszRootPath, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Empties the Recycle Bin on the specified drive. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shellapi.h header defines SHEmptyRecycleBin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.
     * @param {Pointer<Char>} pszRootPath Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system\. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shemptyrecyclebinw
     * @since windows5.0
     */
    static SHEmptyRecycleBinW(hwnd, pszRootPath, dwFlags) {
        pszRootPath := pszRootPath is String? StrPtr(pszRootPath) : pszRootPath

        result := DllCall("SHELL32.dll\SHEmptyRecycleBinW", "ptr", hwnd, "ptr", pszRootPath, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Checks the state of the computer for the current user to determine whether sending a notification is appropriate.
     * @remarks
     * Applications should call <b>SHQueryUserNotificationState</b> and test the return value before displaying any notification UI that is similar to the balloon notifications generated by <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shell_notifyicona">Shell_NotifyIcon</a>. Notifications should only be displayed if this API returns <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-query_user_notification_state">QNS_ACCEPTS_NOTIFICATIONS</a>. This informs the application whether the user is running processes that should not be interrupted. Top-level windows receive a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message when the user turns presentation settings on or off, and also when the user's session is locked or unlocked. Note that there are no notifications sent when the user starts or stops a full-screen application.
     * 
     * If this function returns <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-query_user_notification_state">QUNS_QUIET_TIME</a>, notifications should be displayed only if critical.
     * @param {Pointer<Int32>} pquns Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-query_user_notification_state">QUERY_USER_NOTIFICATION_STATE</a>*</b>
     * 
     * When this function returns, contains a pointer to one of the values of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-query_user_notification_state">QUERY_USER_NOTIFICATION_STATE</a> enumeration.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shqueryusernotificationstate
     * @since windows6.0.6000
     */
    static SHQueryUserNotificationState(pquns) {
        result := DllCall("SHELL32.dll\SHQueryUserNotificationState", "int*", pquns, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Sends a message to the taskbar's status area. (ANSI)
     * @remarks
     * As of Windows2000 (<a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0</a>), if you set the <b>uVersion</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure pointed to by <i>lpdata</i> to NOTIFYICON_VERSION_4 or higher, <b>Shell_NotifyIcon</b> mouse and keyboard events are handled differently than in earlier versions of Windows. The differences include the following:
     * 
     * <ul>
     * <li>If a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-contextmenu">WM_CONTEXTMENU</a> message. Earlier versions send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</li>
     * <li>If a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5.0 Shell sends the associated application an NIN_KEYSELECT notification. Earlier versions send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</li>
     * <li>If a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification. Earlier versions send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</li>
     * </ul>
     * As of WindowsXP (<a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 6.0</a>), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Shell sends the following messages:
     * 
     * <ul>
     * <li>NIN_BALLOONSHOW. Sent when the balloon is shown (balloons are queued).</li>
     * <li>
     * NIN_BALLOONHIDE. Sent when the balloon disappears. For example, when the icon is deleted. This message is not sent if the balloon is dismissed because of a timeout or if the user clicks the mouse.
     * 
     * As of Windows7, NIN_BALLOONHIDE is also sent when a notification with the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NIIF_RESPECT_QUIET_TIME</a> flag set attempts to display during quiet time (a user's first hour on a new computer). In that case, the balloon is never displayed at all.
     * 
     * </li>
     * <li>NIN_BALLOONTIMEOUT. Sent when the balloon is dismissed because of a timeout.</li>
     * <li>NIN_BALLOONUSERCLICK. Sent when the balloon is dismissed because the user clicked the mouse.</li>
     * </ul>
     * In addition to those messages, as of WindowsVista (Shell32.dll version 6.0.6), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the WindowsVista Shell also adds the following messages:
     * 
     * <ul>
     * <li>NIN_POPUPOPEN. Sent when the user hovers the cursor over an icon to indicate that the richer pop-up UI should be used in place of a standard textual tooltip.</li>
     * <li>NIN_POPUPCLOSE. Sent when a cursor no longer hovers over an icon to indicate that the rich pop-up UI should be closed.</li>
     * </ul>
     * Regardless of the operating system version, you can select which way the Shell should behave by calling <b>Shell_NotifyIcon</b> with <i>dwMessage</i> set to <b>NIM_SETVERSION</b>. Set the <b>uVersion</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure pointed to by <i>lpdata</i> to indicate whether you want Windows2000, WindowsVista, or pre-version 5.0 (Windows95) behavior.
     * 
     * <div class="alert"><b>Note</b>The messages discussed above are not conventional Windows messages. They are sent as the <i>lParam</i> value of the application-defined message that is specified in the <b>uCallbackMessage</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure pointed to by <i>lpdata</i>, when <b>Shell_NotifyIcon</b> is called with the <b>NIM_ADD</b> flag set in <i>dwMessage</i>.</div>
     * <div></div>
     * As of WindowsXP Service Pack2 (SP2), a custom icon can be displayed in the notification balloon. This allows the calling process to customize the notification beyond the previously available options of info, warning, and error, and distinguish it from other types of notification for the user.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines Shell_NotifyIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwMessage Type: <b>DWORD</b>
     * @param {Pointer<NOTIFYICONDATAA>} lpData Type: <b>PNOTIFYICONDATA</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shell_notifyicona
     * @since windows5.1.2600
     */
    static Shell_NotifyIconA(dwMessage, lpData) {
        result := DllCall("SHELL32.dll\Shell_NotifyIconA", "uint", dwMessage, "ptr", lpData, "int")
        return result
    }

    /**
     * Sends a message to the taskbar's status area. (Unicode)
     * @remarks
     * As of Windows2000 (<a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 5.0</a>), if you set the <b>uVersion</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure pointed to by <i>lpdata</i> to NOTIFYICON_VERSION_4 or higher, <b>Shell_NotifyIcon</b> mouse and keyboard events are handled differently than in earlier versions of Windows. The differences include the following:
     * 
     * <ul>
     * <li>If a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-contextmenu">WM_CONTEXTMENU</a> message. Earlier versions send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</li>
     * <li>If a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5.0 Shell sends the associated application an NIN_KEYSELECT notification. Earlier versions send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</li>
     * <li>If a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification. Earlier versions send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttondown">WM_RBUTTONDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-rbuttonup">WM_RBUTTONUP</a> messages.</li>
     * </ul>
     * As of WindowsXP (<a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell32.dll version 6.0</a>), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the Shell sends the following messages:
     * 
     * <ul>
     * <li>NIN_BALLOONSHOW. Sent when the balloon is shown (balloons are queued).</li>
     * <li>
     * NIN_BALLOONHIDE. Sent when the balloon disappears. For example, when the icon is deleted. This message is not sent if the balloon is dismissed because of a timeout or if the user clicks the mouse.
     * 
     * As of Windows7, NIN_BALLOONHIDE is also sent when a notification with the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NIIF_RESPECT_QUIET_TIME</a> flag set attempts to display during quiet time (a user's first hour on a new computer). In that case, the balloon is never displayed at all.
     * 
     * </li>
     * <li>NIN_BALLOONTIMEOUT. Sent when the balloon is dismissed because of a timeout.</li>
     * <li>NIN_BALLOONUSERCLICK. Sent when the balloon is dismissed because the user clicked the mouse.</li>
     * </ul>
     * In addition to those messages, as of WindowsVista (Shell32.dll version 6.0.6), if a user passes the mouse pointer over an icon with which a balloon notification is associated, the WindowsVista Shell also adds the following messages:
     * 
     * <ul>
     * <li>NIN_POPUPOPEN. Sent when the user hovers the cursor over an icon to indicate that the richer pop-up UI should be used in place of a standard textual tooltip.</li>
     * <li>NIN_POPUPCLOSE. Sent when a cursor no longer hovers over an icon to indicate that the rich pop-up UI should be closed.</li>
     * </ul>
     * Regardless of the operating system version, you can select which way the Shell should behave by calling <b>Shell_NotifyIcon</b> with <i>dwMessage</i> set to <b>NIM_SETVERSION</b>. Set the <b>uVersion</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure pointed to by <i>lpdata</i> to indicate whether you want Windows2000, WindowsVista, or pre-version 5.0 (Windows95) behavior.
     * 
     * <div class="alert"><b>Note</b>The messages discussed above are not conventional Windows messages. They are sent as the <i>lParam</i> value of the application-defined message that is specified in the <b>uCallbackMessage</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure pointed to by <i>lpdata</i>, when <b>Shell_NotifyIcon</b> is called with the <b>NIM_ADD</b> flag set in <i>dwMessage</i>.</div>
     * <div></div>
     * As of WindowsXP Service Pack2 (SP2), a custom icon can be displayed in the notification balloon. This allows the calling process to customize the notification beyond the previously available options of info, warning, and error, and distinguish it from other types of notification for the user.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines Shell_NotifyIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwMessage Type: <b>DWORD</b>
     * @param {Pointer<NOTIFYICONDATAW>} lpData Type: <b>PNOTIFYICONDATA</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shell_notifyiconw
     * @since windows5.1.2600
     */
    static Shell_NotifyIconW(dwMessage, lpData) {
        result := DllCall("SHELL32.dll\Shell_NotifyIconW", "uint", dwMessage, "ptr", lpData, "int")
        return result
    }

    /**
     * Gets the screen coordinates of the bounding rectangle of a notification icon.
     * @param {Pointer<NOTIFYICONIDENTIFIER>} identifier Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyiconidentifier">NOTIFYICONIDENTIFIER</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyiconidentifier">NOTIFYICONIDENTIFIER</a> structure that identifies the icon.
     * @param {Pointer<RECT>} iconLocation Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that, when this function returns successfully, receives the coordinates of the icon.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shell_notifyicongetrect
     * @since windows6.1
     */
    static Shell_NotifyIconGetRect(identifier, iconLocation) {
        result := DllCall("SHELL32.dll\Shell_NotifyIconGetRect", "ptr", identifier, "ptr", iconLocation, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves information about an object in the file system, such as a file, folder, directory, or drive root. (ANSI)
     * @remarks
     * You should call this function from a background thread. Failure to do so could cause the UI to stop responding.
     * 
     * If <b>SHGetFileInfo</b> returns an icon handle in the <b>hIcon</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure pointed to by <i>psfi</i>, you are responsible for freeing it with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> when you no longer need it.
     * 
     * <div class="alert"><b>Note</b>Once you have a handle to a system image list, you can use the <a href="https://docs.microsoft.com/windows/desktop/Controls/image-lists">Image List API</a> to manipulate it like any other image list. Because system image lists are created on a per-process basis, you should treat them as read-only objects. Writing to a system image list may overwrite or delete one of the system images, making it unavailable or incorrect for the remainder of the process.</div>
     * <div></div>
     * You must initialize Component Object Model (COM) with <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a> prior to calling <b>SHGetFileInfo</b>.
     * 
     * When you use the <b>SHGFI_EXETYPE</b> flag with a Windows application, the Windows version of the executable is given in the HIWORD of the return value. This version is returned as a hexadecimal value. For details on equating this value with a specific Windows version, see <a href="https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.
     *     
     *     					
     * 
     * If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.
     * 
     * If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.
     * 
     * This string can use either short (the 8.3 form) or long file names.
     * @param {Integer} dwFileAttributes Type: <b>DWORD</b>
     * 
     * A combination of one or more <a href="https://docs.microsoft.com/windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.
     * @param {Pointer} psfi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure to receive the file information.
     * @param {Integer} cbFileInfo Type: <b>UINT</b>
     * 
     * The size, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure pointed to by the <i>psfi</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>DWORD_PTR</b>
     * 
     * Returns a value whose meaning depends on the <i>uFlags</i> parameter. 
     *     
     *     					
     * 
     * If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.
     * 
     * If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonexecutable file or an error condition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = NE or PE and HIWORD = Windows version</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Windows application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = MZ and HIWORD = 0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MS-DOS .exe or .com file 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = PE and HIWORD = 0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Console application or .bat file 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetfileinfoa
     * @since windows5.1.2600
     */
    static SHGetFileInfoA(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFileInfoA", "ptr", pszPath, "uint", dwFileAttributes, "ptr", psfi, "uint", cbFileInfo, "uint", uFlags, "ptr")
        return result
    }

    /**
     * Retrieves information about an object in the file system, such as a file, folder, directory, or drive root. (Unicode)
     * @remarks
     * You should call this function from a background thread. Failure to do so could cause the UI to stop responding.
     * 
     * If <b>SHGetFileInfo</b> returns an icon handle in the <b>hIcon</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure pointed to by <i>psfi</i>, you are responsible for freeing it with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> when you no longer need it.
     * 
     * <div class="alert"><b>Note</b>Once you have a handle to a system image list, you can use the <a href="https://docs.microsoft.com/windows/desktop/Controls/image-lists">Image List API</a> to manipulate it like any other image list. Because system image lists are created on a per-process basis, you should treat them as read-only objects. Writing to a system image list may overwrite or delete one of the system images, making it unavailable or incorrect for the remainder of the process.</div>
     * <div></div>
     * You must initialize Component Object Model (COM) with <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a> prior to calling <b>SHGetFileInfo</b>.
     * 
     * When you use the <b>SHGFI_EXETYPE</b> flag with a Windows application, the Windows version of the executable is given in the HIWORD of the return value. This version is returned as a hexadecimal value. For details on equating this value with a specific Windows version, see <a href="https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.
     *     
     *     					
     * 
     * If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.
     * 
     * If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.
     * 
     * This string can use either short (the 8.3 form) or long file names.
     * @param {Integer} dwFileAttributes Type: <b>DWORD</b>
     * 
     * A combination of one or more <a href="https://docs.microsoft.com/windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.
     * @param {Pointer} psfi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure to receive the file information.
     * @param {Integer} cbFileInfo Type: <b>UINT</b>
     * 
     * The size, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure pointed to by the <i>psfi</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>DWORD_PTR</b>
     * 
     * Returns a value whose meaning depends on the <i>uFlags</i> parameter. 
     *     
     *     					
     * 
     * If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.
     * 
     * If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonexecutable file or an error condition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = NE or PE and HIWORD = Windows version</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Windows application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = MZ and HIWORD = 0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MS-DOS .exe or .com file 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = PE and HIWORD = 0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Console application or .bat file 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetfileinfow
     * @since windows5.1.2600
     */
    static SHGetFileInfoW(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFileInfoW", "ptr", pszPath, "uint", dwFileAttributes, "ptr", psfi, "uint", cbFileInfo, "uint", uFlags, "ptr")
        return result
    }

    /**
     * Retrieves information about system-defined Shell icons.
     * @remarks
     * If this function returns an icon handle in the <b>hIcon</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shstockiconinfo">SHSTOCKICONINFO</a>  structure pointed to by <i>psii</i>, you are responsible for freeing the icon with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> when you no longer need it.
     * @param {Integer} siid Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-shstockiconid">SHSTOCKICONID</a></b>
     * 
     * One of the values from the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-shstockiconid">SHSTOCKICONID</a> enumeration that specifies which icon should be retrieved.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * A combination of zero or more of the following flags that specify which information is requested.
     * @param {Pointer<SHSTOCKICONINFO>} psii Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shstockiconinfo">SHSTOCKICONINFO</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shstockiconinfo">SHSTOCKICONINFO</a> structure. When this function is called, the <b>cbSize</b> member of this structure needs to be set to the size of the <b>SHSTOCKICONINFO</b> structure. When this function returns, contains a pointer to a <b>SHSTOCKICONINFO</b> structure that contains the requested information.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetstockiconinfo
     * @since windows6.0.6000
     */
    static SHGetStockIconInfo(siid, uFlags, psii) {
        result := DllCall("SHELL32.dll\SHGetStockIconInfo", "int", siid, "uint", uFlags, "ptr", psii, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves disk space information for a disk volume. (ANSI)
     * @remarks
     * The similarly named function <a href="https://docs.microsoft.com/previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</a> is merely an alias for <b>SHGetDiskFreeSpaceEx</b>. When you call <b>SHGetDiskFreeSpace</b> you actually call this function.
     * 
     * This function calls the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespaceexa">GetDiskFreeSpaceEx</a> function if it is available on the operating system. If <b>GetDiskFreeSpaceEx</b> is not available, it is emulated by calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function and manipulating the return values. For additional information, see the documentation for <b>GetDiskFreeSpaceEx</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHGetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszDirectoryName Type: <b>LPCTSTR</b>
     * 
     * A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.
     * @param {Pointer<UInt64>} pulFreeBytesAvailableToCaller Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.
     * @param {Pointer<UInt64>} pulTotalNumberOfBytes Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the total size of the volume, in bytes.
     * @param {Pointer<UInt64>} pulTotalNumberOfFreeBytes Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the number of bytes of free space on the volume.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetdiskfreespaceexa
     * @since windows5.0
     */
    static SHGetDiskFreeSpaceExA(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes) {
        pszDirectoryName := pszDirectoryName is String? StrPtr(pszDirectoryName) : pszDirectoryName

        result := DllCall("SHELL32.dll\SHGetDiskFreeSpaceExA", "ptr", pszDirectoryName, "uint*", pulFreeBytesAvailableToCaller, "uint*", pulTotalNumberOfBytes, "uint*", pulTotalNumberOfFreeBytes, "int")
        return result
    }

    /**
     * Retrieves disk space information for a disk volume. (Unicode)
     * @remarks
     * The similarly named function <a href="https://docs.microsoft.com/previous-versions/bb762176(v=vs.85)">SHGetDiskFreeSpace</a> is merely an alias for <b>SHGetDiskFreeSpaceEx</b>. When you call <b>SHGetDiskFreeSpace</b> you actually call this function.
     * 
     * This function calls the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespaceexa">GetDiskFreeSpaceEx</a> function if it is available on the operating system. If <b>GetDiskFreeSpaceEx</b> is not available, it is emulated by calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function and manipulating the return values. For additional information, see the documentation for <b>GetDiskFreeSpaceEx</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHGetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszDirectoryName Type: <b>LPCTSTR</b>
     * 
     * A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.
     * @param {Pointer<UInt64>} pulFreeBytesAvailableToCaller Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.
     * @param {Pointer<UInt64>} pulTotalNumberOfBytes Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the total size of the volume, in bytes.
     * @param {Pointer<UInt64>} pulTotalNumberOfFreeBytes Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the number of bytes of free space on the volume.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetdiskfreespaceexw
     * @since windows5.0
     */
    static SHGetDiskFreeSpaceExW(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes) {
        pszDirectoryName := pszDirectoryName is String? StrPtr(pszDirectoryName) : pszDirectoryName

        result := DllCall("SHELL32.dll\SHGetDiskFreeSpaceExW", "ptr", pszDirectoryName, "uint*", pulFreeBytesAvailableToCaller, "uint*", pulTotalNumberOfBytes, "uint*", pulTotalNumberOfFreeBytes, "int")
        return result
    }

    /**
     * Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name. (ANSI)
     * @remarks
     * <b>SHGetNewLinkInfo</b> determines whether the destination file system supports long file names. If it does, a long file name is used for the shortcut name. If the destination file system does not support long file names, the shortcut name is returned in an 8.3 format.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHGetNewLinkInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszLinkTo Type: <b>LPCTSTR</b>
     * 
     * A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.
     * @param {Pointer<Byte>} pszDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.
     * @param {Pointer<Byte>} pszName Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.
     * @param {Pointer<Int32>} pfMustCopy Type: <b>BOOL*</b>
     * 
     * The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetnewlinkinfoa
     * @since windows5.0
     */
    static SHGetNewLinkInfoA(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags) {
        pszLinkTo := pszLinkTo is String? StrPtr(pszLinkTo) : pszLinkTo
        pszDir := pszDir is String? StrPtr(pszDir) : pszDir
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHELL32.dll\SHGetNewLinkInfoA", "ptr", pszLinkTo, "ptr", pszDir, "ptr", pszName, "int*", pfMustCopy, "uint", uFlags, "int")
        return result
    }

    /**
     * Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name. (Unicode)
     * @remarks
     * <b>SHGetNewLinkInfo</b> determines whether the destination file system supports long file names. If it does, a long file name is used for the shortcut name. If the destination file system does not support long file names, the shortcut name is returned in an 8.3 format.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHGetNewLinkInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszLinkTo Type: <b>LPCTSTR</b>
     * 
     * A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.
     * @param {Pointer<Char>} pszDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.
     * @param {Pointer<Char>} pszName Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.
     * @param {Pointer<Int32>} pfMustCopy Type: <b>BOOL*</b>
     * 
     * The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetnewlinkinfow
     * @since windows5.0
     */
    static SHGetNewLinkInfoW(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags) {
        pszLinkTo := pszLinkTo is String? StrPtr(pszLinkTo) : pszLinkTo
        pszDir := pszDir is String? StrPtr(pszDir) : pszDir
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHELL32.dll\SHGetNewLinkInfoW", "ptr", pszLinkTo, "ptr", pszDir, "ptr", pszName, "int*", pfMustCopy, "uint", uFlags, "int")
        return result
    }

    /**
     * Executes a command on a printer object. (ANSI)
     * @remarks
     * When a printer name is specified by <i>lpBuf1</i>, the name can either be the name of a local printer or the server and share name of a network printer. When specifying a network printer name, the name must be specified in this format: 
     * 
     * 
     * ```
     * "\\<server><shared printer name>"
     * ```
     * 
     * 
     * This function is implemented in <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell versions 4.71</a> and later. In order to maintain backward compatibility with previous Shell versions, this function should not be used explicitly. Instead, the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions should be used to obtain the function address.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHInvokePrinterCommand as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window of any windows or dialog boxes that are created during the operation.
     * @param {Integer} uAction Type: <b>UINT</b>
     * @param {Pointer<Byte>} lpBuf1 Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.
     * @param {Pointer<Byte>} lpBuf2 Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.
     * @param {Integer} fModal Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shinvokeprintercommanda
     * @since windows5.0
     */
    static SHInvokePrinterCommandA(hwnd, uAction, lpBuf1, lpBuf2, fModal) {
        lpBuf1 := lpBuf1 is String? StrPtr(lpBuf1) : lpBuf1
        lpBuf2 := lpBuf2 is String? StrPtr(lpBuf2) : lpBuf2

        result := DllCall("SHELL32.dll\SHInvokePrinterCommandA", "ptr", hwnd, "uint", uAction, "ptr", lpBuf1, "ptr", lpBuf2, "int", fModal, "int")
        return result
    }

    /**
     * Executes a command on a printer object. (Unicode)
     * @remarks
     * When a printer name is specified by <i>lpBuf1</i>, the name can either be the name of a local printer or the server and share name of a network printer. When specifying a network printer name, the name must be specified in this format: 
     * 
     * 
     * ```
     * "\\<server><shared printer name>"
     * ```
     * 
     * 
     * This function is implemented in <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell versions 4.71</a> and later. In order to maintain backward compatibility with previous Shell versions, this function should not be used explicitly. Instead, the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions should be used to obtain the function address.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHInvokePrinterCommand as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window of any windows or dialog boxes that are created during the operation.
     * @param {Integer} uAction Type: <b>UINT</b>
     * @param {Pointer<Char>} lpBuf1 Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.
     * @param {Pointer<Char>} lpBuf2 Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.
     * @param {Integer} fModal Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shinvokeprintercommandw
     * @since windows5.0
     */
    static SHInvokePrinterCommandW(hwnd, uAction, lpBuf1, lpBuf2, fModal) {
        lpBuf1 := lpBuf1 is String? StrPtr(lpBuf1) : lpBuf1
        lpBuf2 := lpBuf2 is String? StrPtr(lpBuf2) : lpBuf2

        result := DllCall("SHELL32.dll\SHInvokePrinterCommandW", "ptr", hwnd, "uint", uAction, "ptr", lpBuf1, "ptr", lpBuf2, "int", fModal, "int")
        return result
    }

    /**
     * Signals the Shell that during the next operation requiring overlay information, it should load icon overlay identifiers that either failed creation or were not present for creation at startup. Identifiers that have already been loaded are not affected.
     * @remarks
     * A call to <b>SHLoadNonloadedIconOverlayIdentifiers</b> does not result in the immediate loading of a Shell extension, nor does it cause an icon overlay handler to be loaded. A call to <b>SHLoadNonloadedIconOverlayIdentifiers</b> results in a situation such that the next code to ask for icon overlay information triggers a comparison of icon overlays in the registry to those that are already loaded. If an icon overlay is newly registered and the system has not already reached its upper limit of fifteen icon overlays, the new overlay is loaded. <b>SHLoadNonloadedIconOverlayIdentifiers</b> alone does not load a new icon overlay; you also need to trigger an action that uses the overlay, such as a refresh of a Windows Explorer view.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/how-to-implement-icon-overlay-handlers">How to Implement Icon Overlay Handlers</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Always returns S_OK.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shloadnonloadediconoverlayidentifiers
     * @since windows5.0
     */
    static SHLoadNonloadedIconOverlayIdentifiers() {
        result := DllCall("SHELL32.dll\SHLoadNonloadedIconOverlayIdentifiers", "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines whether a file or folder is available for offline use. This function also determines whether the file would be opened from the network, from the local Offline Files cache, or from both locations.
     * @remarks
     * If <i>pszPath</i> is a directory, <b>SHIsFileAvailableOffline</b> will not return the <b>OFFLINE_STATUS_INCOMPLETE</b> flag.
     * 
     * If <b>SHIsFileAvailableOffline</b> returns both <b>OFFLINE_STATUS_LOCAL</b> and <b>OFFLINE_STATUS_REMOTE</b>, the file or directory is open in both places.  This is common when the server is online.
     * @param {Pointer<Char>} pwszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a string value that specifies the full path to a network file or directory. This path does not need to be in UNC form. If <i>pszPath</i> is not a network path, the function returns E_INVALIDARG.
     * @param {Pointer<UInt32>} pdwStatus Type: <b>LPDWORD</b>
     * 
     * A pointer to a variable of type <b>DWORD</b> that receives one or more of the following flags if the function succeeds.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * This function can return one of these values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is cached.  It is available offline unless <b>OFFLINE_STATUS_INCOMPLETE</b> is set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path is invalid or not a network path. The file or directory is not cached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is not cached.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shisfileavailableoffline
     * @since windows5.0
     */
    static SHIsFileAvailableOffline(pwszPath, pdwStatus) {
        pwszPath := pwszPath is String? StrPtr(pwszPath) : pwszPath

        result := DllCall("SHELL32.dll\SHIsFileAvailableOffline", "ptr", pwszPath, "uint*", pdwStatus, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Sets the localized name of a file in a Shell folder.
     * @remarks
     * When this string is set, Explorer displays this string instead of the file name. The path to the file is unchanged.
     *                 
     *                 
     * 
     * Applications can get the display (localized) name with <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof">IShellFolder::GetDisplayNameOf</a> with the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-sigdn">SIGDN_NORMALDISPLAY</a> flag and the parsing (non-localized) name with <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-getdisplayname">IShellItem::GetDisplayName</a> using the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-sigdn">SIGDN_DESKTOPABSOLUTEPARSING</a> flag.
     * 
     * Calling <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shremovelocalizedname">SHRemoveLocalizedName</a> makes the display name identical to the parsing name.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a string that specifies the fully qualified path of the target file.
     * @param {Pointer<Char>} pszResModule Type: <b>PCWSTR</b>
     * 
     * A pointer to a string resource that specifies the localized version of the file name.
     * @param {Integer} idsRes Type: <b>int</b>
     * 
     * An integer ID that specifies the localized file name in the string resource.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shsetlocalizedname
     * @since windows5.1.2600
     */
    static SHSetLocalizedName(pszPath, pszResModule, idsRes) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszResModule := pszResModule is String? StrPtr(pszResModule) : pszResModule

        result := DllCall("SHELL32.dll\SHSetLocalizedName", "ptr", pszPath, "ptr", pszResModule, "int", idsRes, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes the localized name of a file in a Shell folder.
     * @remarks
     * When a display name string is set by <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shsetlocalizedname">SHSetLocalizedName</a>, Windows Explorer uses that string for display instead of the file name. The path to the file is unchanged.
     * 
     * Applications can use the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof">IShellFolder::GetDisplayNameOf</a> method to get the display (localized) name through with the SIGDN_NORMALDISPLAY flag and the parsing (non-localized) name with SIGDN_DESKTOPABSOLUTEPARSING.
     * 
     * Calling <b>SHRemoveLocalizedName</b> makes the display name identical to the parsing name.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string that specifies the fully qualified path of the target file.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shremovelocalizedname
     * @since windows6.0.6000
     */
    static SHRemoveLocalizedName(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHRemoveLocalizedName", "ptr", pszPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the localized name of a file in a Shell folder.
     * @param {Pointer<Char>} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a string that specifies the fully qualified path of the file.
     * @param {Pointer<Char>} pszResModule Type: <b>PWSTR</b>
     * 
     * When this function returns, contains a pointer to a string resource that specifies the localized version of the file name.
     * @param {Integer} cch Type: <b>UINT</b>
     * 
     * When this function returns, contains the size of the string, in <b>WCHARs</b>, at <i>pszResModule</i>.
     * @param {Pointer<Int32>} pidsRes Type: <b>int*</b>
     * 
     * When this function returns, contains a pointer to the ID of the localized file name in the resource file.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetlocalizedname
     * @since windows6.0.6000
     */
    static SHGetLocalizedName(pszPath, pszResModule, cch, pidsRes) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszResModule := pszResModule is String? StrPtr(pszResModule) : pszResModule

        result := DllCall("SHELL32.dll\SHGetLocalizedName", "ptr", pszPath, "ptr", pszResModule, "uint", cch, "int*", pidsRes, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * ShellMessageBox may be altered or unavailable. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shellapi.h header defines ShellMessageBox as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hAppInst Type: <b>HINSTANCE</b>
     * 
     * The handle of the module from which to load a string resource named in <i>pszTitle</i>. If <i>pszTitle</i> does not name a string resource, this parameter is ignored. This value must be valid if <i>pszMsg</i> or <i>pszTitle</i> is a resource ID.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window of the message box to be created. If this variable is not <b>NULL</b>, the title of the owner window is used as the title of the message box.
     * @param {Pointer<Byte>} lpcText Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains either the message to be displayed or a resource ID specifying where the message is to be retrieved from.
     * @param {Pointer<Byte>} lpcTitle Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the dialog box title or a resource ID specifying where the title is to be retrieved. If both this parameter and <i>hWnd</i> are <b>NULL</b>, no title is displayed. If this parameter points to a loadable resource formed with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro, it overrides <i>hWnd</i> as the title.
     * @param {Integer} fuStyle Type: <b>UINT</b>
     * 
     * Specifies the contents and behavior of the dialog box. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * An integer value indicating a button that was pressed in the message box. For specific values, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * 
     * 					
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellmessageboxa
     * @since windows5.1.2600
     */
    static ShellMessageBoxA(hAppInst, hWnd, lpcText, lpcTitle, fuStyle) {
        lpcText := lpcText is String? StrPtr(lpcText) : lpcText
        lpcTitle := lpcTitle is String? StrPtr(lpcTitle) : lpcTitle

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\ShellMessageBoxA", "ptr", hAppInst, "ptr", hWnd, "ptr", lpcText, "ptr", lpcTitle, "uint", fuStyle, "CDecl int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * ShellMessageBox may be altered or unavailable. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shellapi.h header defines ShellMessageBox as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hAppInst Type: <b>HINSTANCE</b>
     * 
     * The handle of the module from which to load a string resource named in <i>pszTitle</i>. If <i>pszTitle</i> does not name a string resource, this parameter is ignored. This value must be valid if <i>pszMsg</i> or <i>pszTitle</i> is a resource ID.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window of the message box to be created. If this variable is not <b>NULL</b>, the title of the owner window is used as the title of the message box.
     * @param {Pointer<Char>} lpcText Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains either the message to be displayed or a resource ID specifying where the message is to be retrieved from.
     * @param {Pointer<Char>} lpcTitle Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the dialog box title or a resource ID specifying where the title is to be retrieved. If both this parameter and <i>hWnd</i> are <b>NULL</b>, no title is displayed. If this parameter points to a loadable resource formed with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro, it overrides <i>hWnd</i> as the title.
     * @param {Integer} fuStyle Type: <b>UINT</b>
     * 
     * Specifies the contents and behavior of the dialog box. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * An integer value indicating a button that was pressed in the message box. For specific values, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * 
     * 					
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellmessageboxw
     * @since windows5.1.2600
     */
    static ShellMessageBoxW(hAppInst, hWnd, lpcText, lpcTitle, fuStyle) {
        lpcText := lpcText is String? StrPtr(lpcText) : lpcText
        lpcTitle := lpcTitle is String? StrPtr(lpcTitle) : lpcTitle

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\ShellMessageBoxW", "ptr", hAppInst, "ptr", hWnd, "ptr", lpcText, "ptr", lpcTitle, "uint", fuStyle, "CDecl int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} pszPath 
     * @returns {Integer} 
     */
    static IsLFNDriveA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\IsLFNDriveA", "ptr", pszPath, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pszPath 
     * @returns {Integer} 
     */
    static IsLFNDriveW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\IsLFNDriveW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Enumerates the user accounts that have unread email. (Unicode)
     * @remarks
     * The <i>hKeyUser</i> parameter is the HKEY for the root of the user's information, for example <b>HKEY_CURRENT_USER</b>, or any key enumerated under <b>HKEY_USERS</b>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shellapi.h header defines SHEnumerateUnreadMailAccounts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hKeyUser Type: <b>HKEY</b>
     * 
     * A valid HKEY for a given user.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the user account.
     * @param {Pointer<Char>} pszMailAddress Type: <b>LPTSTR</b>
     * 
     * A pointer to a Unicode string that specifies the email address of an account belonging to the specified user.
     * @param {Integer} cchMailAddress Type: <b>int</b>
     * 
     * The number of characters in the email address.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shenumerateunreadmailaccountsw
     * @since windows5.1.2600
     */
    static SHEnumerateUnreadMailAccountsW(hKeyUser, dwIndex, pszMailAddress, cchMailAddress) {
        pszMailAddress := pszMailAddress is String? StrPtr(pszMailAddress) : pszMailAddress

        result := DllCall("SHELL32.dll\SHEnumerateUnreadMailAccountsW", "ptr", hKeyUser, "uint", dwIndex, "ptr", pszMailAddress, "int", cchMailAddress, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves a specified user's unread message count for any or all email accounts. (Unicode)
     * @param {Pointer<Void>} hKeyUser Type: <b>HKEY</b>
     * 
     * A valid HKEY for a given user. This parameter should be <b>NULL</b> if the function is called in a user's environment, in which case <b>HKEY_CURRENT_USER</b> is used. This parameter should be <b>NULL</b> if the function is called from the SYSTEM context, in which case <b>HKEY_USERS</b>&#92;<i>{SID}</i> is used.
     * @param {Pointer<Char>} pszMailAddress Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string in Unicode that specifies the email address of an account belonging to the specified user. When this parameter is <b>NULL</b>, <i>pdwCount</i> returns the total count of unread messages for all accounts owned by the designated user.
     * @param {Pointer<UInt32>} pdwCount Type: <b>DWORD*</b>
     * 
     * Pointer to a DWORD value which receives the unread message count.
     * @param {Pointer<FILETIME>} pFileTime Type: <b>FILETIME*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure.  The use of this parameter is determined by whether <i>pszMailAddress</i> is <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, then this parameter is treated as an [in] parameter, which specifies a filter, so that only unread mail newer than the specified time appears. If <i>pszMailAddress</i> is not <b>NULL</b>, then this parameter is treated as an [out] parameter, which points to a <b>FILETIME</b> structure into which the function places the <b>timestamp</b> of the last <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shsetunreadmailcountw">SHSetUnreadMailCount</a> call for the specified user and email account.
     * @param {Pointer<Char>} pszShellExecuteCommand Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string that returns the ShellExecute command statement passed into the last <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shsetunreadmailcountw">SHSetUnreadMailCount</a> call for the specified user and email account. This command string starts the email application that owns the account referenced by <i>pszMailAddress</i>. If the ShellExecute command is not required, this parameter can be <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, this parameter is ignored and must be <b>NULL</b>.
     * @param {Integer} cchShellExecuteCommand Type: <b>int</b>
     * 
     * The maximum size, in characters, of the ShellExecute command buffer pointed to by <i>pszShellExecuteCommand</i>. This parameter must be zero for total counts when <i>pszMailAddress</i> is <b>NULL</b>. It can also be <b>NULL</b> whenever the ShellExecute command string is not required.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetunreadmailcountw
     * @since windows5.1.2600
     */
    static SHGetUnreadMailCountW(hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand) {
        pszMailAddress := pszMailAddress is String? StrPtr(pszMailAddress) : pszMailAddress
        pszShellExecuteCommand := pszShellExecuteCommand is String? StrPtr(pszShellExecuteCommand) : pszShellExecuteCommand

        result := DllCall("SHELL32.dll\SHGetUnreadMailCountW", "ptr", hKeyUser, "ptr", pszMailAddress, "uint*", pdwCount, "ptr", pFileTime, "ptr", pszShellExecuteCommand, "int", cchShellExecuteCommand, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Stores the current user's unread message count for a specified email account in the registry. (Unicode)
     * @remarks
     * When this function updates the registry, the new registry entry is automatically stamped with the current time and date.
     * 
     * If this function is called by different independent software vendors (ISVs) that specify the same email name, only the last call is saved. That is, calls to this function overwrite any previously saved value for the same email address, even if the calls are made by different ISVs.
     * 
     * It is recommended that the count of unread messages be set only for the main Inbox of the users account. Mail in sub-folders such as Drafts or Deleted Items should be ignored.
     * 
     * It is important that email clients do not set the number of unread messages to 0 when the application exits, because this causes the number of unread messages to be erroneously reported as 0.
     * 
     * Because this function uses HKEY_CURRENT_USER, it should not be called by a system process impersonating a user.
     * @param {Pointer<Char>} pszMailAddress Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string in Unicode that contains the current user's full email address.
     * @param {Integer} dwCount Type: <b>DWORD</b>
     * 
     * The number of unread messages.
     * @param {Pointer<Char>} pszShellExecuteCommand Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string in Unicode that contains the full text of a command that can be passed to ShellExecute. This command should start the email application that owns the account referenced by <i>pszMailAddress</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * <b>HRESULT</b>, which includes the following possible values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call completed successfully.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid string argument in either the <i>pszMailAddress</i> or <i>pszShellExecuteCommand</i> parameters.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shsetunreadmailcountw
     * @since windows5.1.2600
     */
    static SHSetUnreadMailCountW(pszMailAddress, dwCount, pszShellExecuteCommand) {
        pszMailAddress := pszMailAddress is String? StrPtr(pszMailAddress) : pszMailAddress
        pszShellExecuteCommand := pszShellExecuteCommand is String? StrPtr(pszShellExecuteCommand) : pszShellExecuteCommand

        result := DllCall("SHELL32.dll\SHSetUnreadMailCountW", "ptr", pszMailAddress, "uint", dwCount, "ptr", pszShellExecuteCommand, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Uses CheckTokenMembership to test whether the given token is a member of the local group with the specified RID.
     * @remarks
     * This function wraps <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-checktokenmembership">CheckTokenMembership</a> and only checks local groups.
     * @param {Pointer<Void>} hToken Type: <b>HANDLE</b>
     * 
     * A handle to the token. This value can be <b>NULL</b>.
     * @param {Integer} ulRID Type: <b>ULONG</b>
     * 
     * The RID of the local group for which membership is tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> on success, <b>FALSE</b> on failure.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shtesttokenmembership
     * @since windows5.1.2600
     */
    static SHTestTokenMembership(hToken, ulRID) {
        result := DllCall("SHELL32.dll\SHTestTokenMembership", "ptr", hToken, "uint", ulRID, "int")
        return result
    }

    /**
     * Retrieves an image list.
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/commoncontrols/nn-commoncontrols-iimagelist">IImageList</a> pointer type, such as that returned in the <i>ppv</i> parameter, can be cast as an <b>HIMAGELIST</b> as needed; for example, for use in a list view. Conversely, an <b>HIMAGELIST</b> can be cast as a pointer to an <b>IImageList</b>.
     * 
     * As of WindowsVista, <b>SHIL_SMALL</b>, <b>SHIL_LARGE</b>, and <b>SHIL_EXTRALARGE</b> scale with dots per inch (dpi) if the process is marked as dpi-aware. To set these types to be dpi-aware, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setprocessdpiaware">SetProcessDPIAware</a>. <b>SHIL_JUMBO</b> is fixed at 256 pixels regardless of the dpi-aware setting.
     * @param {Integer} iImageList Type: <b>int</b>
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the image list interface identifier, normally IID_IImageList.
     * @param {Pointer<Void>} ppvObj Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/commoncontrols/nn-commoncontrols-iimagelist">IImageList</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetimagelist
     * @since windows5.1.2600
     */
    static SHGetImageList(iImageList, riid, ppvObj) {
        result := DllCall("SHELL32.dll\SHGetImageList", "int", iImageList, "ptr", riid, "ptr", ppvObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Initializes the network address control window class.
     * @remarks
     * The network address control looks like an edit control and offers the additional functionality of network address verification. The control uses a balloon tip to display error messages.
     * 
     * This function initializes class WC_NETADDRESS. If this function returns <b>TRUE</b>, the control can be created.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the initialization succeeded; or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-initnetworkaddresscontrol
     * @since windows6.0.6000
     */
    static InitNetworkAddressControl() {
        result := DllCall("SHELL32.dll\InitNetworkAddressControl", "int")
        return result
    }

    /**
     * Returns the type of media that is in the given drive.
     * @param {Pointer<Char>} pszDrive Type: <b>PCWSTR</b>
     * 
     * The drive in which to check the media type.
     * @param {Pointer<UInt32>} pdwMediaContent Type: <b>DWORD*</b>
     * 
     * A pointer to the type of media in the given drive. A combination of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl/nf-shobjidl-iquerycancelautoplay-allowautoplay">ARCONTENT</a> flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shgetdrivemedia
     * @since windows6.0.6000
     */
    static SHGetDriveMedia(pszDrive, pdwMediaContent) {
        pszDrive := pszDrive is String? StrPtr(pszDrive) : pszDrive

        result := DllCall("SHELL32.dll\SHGetDriveMedia", "ptr", pszDrive, "uint*", pdwMediaContent, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive. (ANSI)
     * @remarks
     * The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStart Type: <b>PTSTR</b>
     * 
     * The address of the string to be searched.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to be used for comparison.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strchra
     * @since windows5.0
     */
    static StrChrA(pszStart, wMatch) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrA", "ptr", pszStart, "ushort", wMatch, "char*")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive. (Unicode)
     * @remarks
     * The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStart Type: <b>PTSTR</b>
     * 
     * The address of the string to be searched.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to be used for comparison.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strchrw
     * @since windows5.0
     */
    static StrChrW(pszStart, wMatch) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrW", "ptr", pszStart, "char", wMatch, "char*")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the string to be searched.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to be used for comparison.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strchria
     * @since windows5.0
     */
    static StrChrIA(pszStart, wMatch) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrIA", "ptr", pszStart, "ushort", wMatch, "char*")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the string to be searched.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to be used for comparison.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strchriw
     * @since windows5.0
     */
    static StrChrIW(pszStart, wMatch) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrIW", "ptr", pszStart, "char", wMatch, "char*")
        return result
    }

    /**
     * Searches a string for the first occurrence of a specified character. The comparison is case-sensitive.
     * @remarks
     * <b>StrChrNW</b> searches for <i>wMatch</i> from <i>pszStart</i> to <i>pszStart</i> + <i>cchMax</i>, or until a <b>NULL</b> character is encountered.
     * 
     * To help ensure optimal performance, <i>pszStart</i> should be word-aligned.
     * @param {Pointer<Char>} pszStart Type: <b>PWSTR</b>
     * 
     * A pointer to the string to be searched.
     * @param {Integer} wMatch Type: <b>WCHAR</b>
     * 
     * The character to be used for comparison.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters to search.
     * @returns {Pointer<Char>} Type: <b>PWSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strchrnw
     * @since windows5.1.2600
     */
    static StrChrNW(pszStart, wMatch, cchMax) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrNW", "ptr", pszStart, "char", wMatch, "uint", cchMax, "char*")
        return result
    }

    /**
     * Searches a string for the first occurrence of a specified character. The comparison is not case-sensitive.
     * @remarks
     * <b>StrChrNIW</b> searches for <i>wMatch</i> from <i>pszStart</i> to <i>pszStart</i> + <i>cchMax</i>, or until a <b>NULL</b> character is encountered.
     * 
     * To help ensure optimal performance, <i>pszStart</i> should be word-aligned.
     * @param {Pointer<Char>} pszStart Type: <b>PCWSTR</b>
     * 
     * A pointer to the string to be searched.
     * @param {Integer} wMatch Type: <b>WCHAR</b>
     * 
     * The character to be used for comparison.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters to search.
     * @returns {Pointer<Char>} Type: <b>PWSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strchrniw
     * @since windows6.0.6000
     */
    static StrChrNIW(pszStart, wMatch, cchMax) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrNIW", "ptr", pszStart, "char", wMatch, "uint", cchMax, "char*")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The StrNCmp macro differs from this function in name only. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Byte>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpna
     * @since windows5.0
     */
    static StrCmpNA(psz1, psz2, nChar) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpNA", "ptr", psz1, "ptr", psz2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The StrNCmp macro differs from this function in name only. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpnw
     * @since windows5.0
     */
    static StrCmpNW(psz1, psz2, nChar) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpNW", "ptr", psz1, "ptr", psz2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The StrNCmpI macro differs from this function in name only. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Byte>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpnia
     * @since windows5.0
     */
    static StrCmpNIA(psz1, psz2, nChar) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpNIA", "ptr", psz1, "ptr", psz2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The StrNCmpI macro differs from this function in name only. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpniw
     * @since windows5.0
     */
    static StrCmpNIW(psz1, psz2, nChar) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpNIW", "ptr", psz1, "ptr", psz2, "int", nChar, "int")
        return result
    }

    /**
     * Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating NULL character is included within the search pattern match. (ANSI)
     * @remarks
     * The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStr Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Byte>} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the characters to search for.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcspna
     * @since windows5.0
     */
    static StrCSpnA(pszStr, pszSet) {
        pszStr := pszStr is String? StrPtr(pszStr) : pszStr
        pszSet := pszSet is String? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrCSpnA", "ptr", pszStr, "ptr", pszSet, "int")
        return result
    }

    /**
     * Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating NULL character is included within the search pattern match. (Unicode)
     * @remarks
     * The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStr Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Char>} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the characters to search for.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcspnw
     * @since windows5.0
     */
    static StrCSpnW(pszStr, pszSet) {
        pszStr := pszStr is String? StrPtr(pszStr) : pszStr
        pszSet := pszSet is String? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrCSpnW", "ptr", pszStr, "ptr", pszSet, "int")
        return result
    }

    /**
     * Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating NULL character is included within the search pattern match. (ANSI)
     * @remarks
     * The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCSpnI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStr Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Byte>} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the characters to search for.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcspnia
     * @since windows5.0
     */
    static StrCSpnIA(pszStr, pszSet) {
        pszStr := pszStr is String? StrPtr(pszStr) : pszStr
        pszSet := pszSet is String? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrCSpnIA", "ptr", pszStr, "ptr", pszSet, "int")
        return result
    }

    /**
     * Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating NULL character is included within the search pattern match. (Unicode)
     * @remarks
     * The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCSpnI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStr Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Char>} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the characters to search for.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcspniw
     * @since windows5.0
     */
    static StrCSpnIW(pszStr, pszSet) {
        pszStr := pszStr is String? StrPtr(pszStr) : pszStr
        pszSet := pszSet is String? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrCSpnIW", "ptr", pszStr, "ptr", pszSet, "int")
        return result
    }

    /**
     * Duplicates a string. (ANSI)
     * @remarks
     * <b>StrDup</b> will allocate storage the size of the original string. If storage allocation is successful, the original string is copied to the duplicate string.
     * 
     * This function uses <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> to allocate storage space for the copy of the string. The calling application must free this memory by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function on the pointer returned by the call to <b>StrDup</b>.
     * @param {Pointer<Byte>} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to a constant <b>null</b>-terminated character string.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strdupa
     * @since windows5.0
     */
    static StrDupA(pszSrch) {
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrDupA", "ptr", pszSrch, "char*")
        return result
    }

    /**
     * Duplicates a string. (Unicode)
     * @remarks
     * <b>StrDup</b> will allocate storage the size of the original string. If storage allocation is successful, the original string is copied to the duplicate string.
     * 
     * This function uses <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> to allocate storage space for the copy of the string. The calling application must free this memory by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function on the pointer returned by the call to <b>StrDup</b>.
     * @param {Pointer<Char>} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to a constant <b>null</b>-terminated character string.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strdupw
     * @since windows5.0
     */
    static StrDupW(pszSrch) {
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrDupW", "ptr", pszSrch, "char*")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
     * @remarks
     * The following table illustrates how this function converts a numeric value into a text string in relation to the passed flag.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Numeric value</th>
     * <th>Flag</th>
     * <th>Text string</th>
     * </tr>
     * <tr>
     * <td>2147483647</td>
     * <td>SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT</td>
     * <td>2.00 GB</td>
     * </tr>
     * <tr>
     * <td>2147483647</td>
     * <td>SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS</td>
     * <td>1.99 GB</td>
     * </tr>
     * </table>
     * 
     * 
     * In Windows10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.
     * @param {Integer} ull Type: <b>ULONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-tagsfbs_flags">SFBS_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-tagsfbs_flags">SFBS_FLAGS</a> enumeration values that specifies whether to round or truncate undisplayed digits. This value cannot be NULL.
     * @param {Pointer<Char>} pszBuf Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that receives the converted string.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszBuf</i>, in characters.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strformatbytesizeex
     * @since windows6.0.6000
     */
    static StrFormatByteSizeEx(ull, flags, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatByteSizeEx", "uint", ull, "int", flags, "ptr", pszBuf, "uint", cchBuf, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size. Differs from StrFormatByteSizeW in one parameter type.
     * @remarks
     * The first parameter of this function has a different type for the ANSI and Unicode versions. If your numeric value is a <b>DWORD</b>, you can use <b>StrFormatByteSize</b> with text macros for both cases. The compiler will cast the numerical value to a <b>LONGLONG</b> for the Unicode case. If your numerical value is a <b>LONGLONG</b>, you should use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-strformatbytesizew">StrFormatByteSizeW</a> explicitly.
     * 
     * In Windows10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.
     * 
     * The following table illustrates how this function converts a numeric value into a text string.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Numeric value</th>
     * <th>Text string</th>
     * </tr>
     * <tr>
     * <td>532</td>
     * <td>532 bytes</td>
     * </tr>
     * <tr>
     * <td>1340</td>
     * <td>1.30 KB</td>
     * </tr>
     * <tr>
     * <td>23506</td>
     * <td>22.9 KB</td>
     * </tr>
     * <tr>
     * <td>2400016</td>
     * <td>2.28 MB</td>
     * </tr>
     * <tr>
     * <td>2400000000</td>
     * <td>2.23 GB</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrFormatByteSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dw Type: <b>DWORD</b>
     * 
     * The numeric value to be converted.
     * @param {Pointer<Byte>} pszBuf Type: <b>PSTR</b>
     * 
     * A pointer to a buffer that receives the converted string.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszBuf</i>, in characters.
     * @returns {Pointer<Byte>} Type: <b>PSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strformatbytesizea
     * @since windows5.0
     */
    static StrFormatByteSizeA(dw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatByteSizeA", "uint", dw, "ptr", pszBuf, "uint", cchBuf, "char*")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
     * @remarks
     * <b>StrFormatByteSize64</b> can be used for either ANSI or Unicode characters. However, while <b>StrFormatByteSize64A</b> can be called directly, <b>StrFormatByteSize64W</b> is not defined. When <b>StrFormatByteSize64</b> is called with a Unicode value, <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-strformatbytesizew">StrFormatByteSizeW</a> is used.
     * 
     * In Windows10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.
     * 
     * The following table illustrates how this function converts a numeric value into a text string.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Numeric value</th>
     * <th>Text string</th>
     * </tr>
     * <tr>
     * <td>532</td>
     * <td>532 bytes</td>
     * </tr>
     * <tr>
     * <td>1340</td>
     * <td>1.30 KB</td>
     * </tr>
     * <tr>
     * <td>23506</td>
     * <td>23.5 KB</td>
     * </tr>
     * <tr>
     * <td>2400016</td>
     * <td>2.40 MB</td>
     * </tr>
     * <tr>
     * <td>2400000000</td>
     * <td>2.4 GB</td>
     * </tr>
     * </table>
     * @param {Integer} qdw Type: <b>LONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {Pointer<Byte>} pszBuf Type: <b>PSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszBuf</i>, in characters.
     * @returns {Pointer<Byte>} Type: <b>PSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strformatbytesize64a
     * @since windows5.0
     */
    static StrFormatByteSize64A(qdw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatByteSize64A", "int64", qdw, "ptr", pszBuf, "uint", cchBuf, "char*")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size. Differs from StrFormatByteSizeA in one parameter type.
     * @remarks
     * The first parameter of this function has different types for the ANSI and Unicode versions. If your numeric value is a <b>DWORD</b>, you can use <b>StrFormatByteSize</b> with text macros for both cases. The compiler will cast the numerical value to a <b>LONGLONG</b> for the Unicode case. If your numerical value is a <b>LONGLONG</b>, you should use <b>StrFormatByteSizeW</b> explicitly.
     * 
     * In Windows10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.
     * 
     * The following table illustrates how this function converts a numeric value into a text string.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Numeric value</th>
     * <th>Text string</th>
     * </tr>
     * <tr>
     * <td>532</td>
     * <td>532 bytes</td>
     * </tr>
     * <tr>
     * <td>1340</td>
     * <td>1.30 KB</td>
     * </tr>
     * <tr>
     * <td>23506</td>
     * <td>22.9 KB</td>
     * </tr>
     * <tr>
     * <td>2400016</td>
     * <td>2.28 MB</td>
     * </tr>
     * <tr>
     * <td>2400000000</td>
     * <td>2.23 GB</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrFormatByteSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} qdw Type: <b>LONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {Pointer<Char>} pszBuf Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszBuf</i>, in characters.
     * @returns {Pointer<Char>} Type: <b>PWSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strformatbytesizew
     * @since windows5.0
     */
    static StrFormatByteSizeW(qdw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatByteSizeW", "int64", qdw, "ptr", pszBuf, "uint", cchBuf, "char*")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in kilobytes. (Unicode)
     * @remarks
     * In Windows10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrFormatKBSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} qdw Type: <b>LONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {Pointer<Char>} pszBuf Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of <i>pszBuf</i>, in characters.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strformatkbsizew
     * @since windows5.0
     */
    static StrFormatKBSizeW(qdw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatKBSizeW", "int64", qdw, "ptr", pszBuf, "uint", cchBuf, "char*")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in kilobytes. (ANSI)
     * @remarks
     * In Windows10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrFormatKBSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} qdw Type: <b>LONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {Pointer<Byte>} pszBuf Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of <i>pszBuf</i>, in characters.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strformatkbsizea
     * @since windows5.0
     */
    static StrFormatKBSizeA(qdw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatKBSizeA", "int64", qdw, "ptr", pszBuf, "uint", cchBuf, "char*")
        return result
    }

    /**
     * Converts a time interval, specified in milliseconds, to a string. (ANSI)
     * @remarks
     * The time value returned in <i>pszOut</i> will always be in the form <i>hh</i> hours <i>mm</i> minutes <i>ss</i> seconds. Times that exceed twenty four hours are not converted to days or months. Fractions of seconds are ignored.
     * @param {Pointer<Byte>} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.
     * @param {Integer} dwTimeMS Type: <b>DWORD</b>
     * 
     * The time interval, in milliseconds.
     * @param {Integer} digits Type: <b>int</b>
     * 
     * The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are: 
     *                 
     *                     
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>dwTimeMS</th>
     * <th>digits</th>
     * <th>pszOut</th>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>3</td>
     * <td>34 sec</td>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>2</td>
     * <td>34 sec</td>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>1</td>
     * <td>30 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>3</td>
     * <td>1 min 14 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>2</td>
     * <td>1 min 10 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>1</td>
     * <td>1 min</td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strfromtimeintervala
     * @since windows5.0
     */
    static StrFromTimeIntervalA(pszOut, cchMax, dwTimeMS, digits) {
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\StrFromTimeIntervalA", "ptr", pszOut, "uint", cchMax, "uint", dwTimeMS, "int", digits, "int")
        return result
    }

    /**
     * Converts a time interval, specified in milliseconds, to a string. (Unicode)
     * @remarks
     * The time value returned in <i>pszOut</i> will always be in the form <i>hh</i> hours <i>mm</i> minutes <i>ss</i> seconds. Times that exceed twenty four hours are not converted to days or months. Fractions of seconds are ignored.
     * @param {Pointer<Char>} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.
     * @param {Integer} dwTimeMS Type: <b>DWORD</b>
     * 
     * The time interval, in milliseconds.
     * @param {Integer} digits Type: <b>int</b>
     * 
     * The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are: 
     *                 
     *                     
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>dwTimeMS</th>
     * <th>digits</th>
     * <th>pszOut</th>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>3</td>
     * <td>34 sec</td>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>2</td>
     * <td>34 sec</td>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>1</td>
     * <td>30 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>3</td>
     * <td>1 min 14 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>2</td>
     * <td>1 min 10 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>1</td>
     * <td>1 min</td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strfromtimeintervalw
     * @since windows5.0
     */
    static StrFromTimeIntervalW(pszOut, cchMax, dwTimeMS, digits) {
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\StrFromTimeIntervalW", "ptr", pszOut, "uint", cchMax, "uint", dwTimeMS, "int", digits, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are equal. (ANSI)
     * @remarks
     * You can set case sensitivity with the <b>StrIntlEqN</b> and <b>StrIntlEqNI</b> macros. <b>StrIntlEqN</b> performs a case-sensitive comparison, and <b>StrIntlEqNI</b> performs a case-insensitive comparison.
     * 
     * The syntax of the two macros is:
     * 				
     * 
     * 
     * ```
     * @param {Integer} fCaseSens Type: <b>BOOL</b>
     * 
     * The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.
     * @param {Pointer<Byte>} pszString1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Byte>} pszString2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strisintlequala
     * @since windows5.0
     */
    static StrIsIntlEqualA(fCaseSens, pszString1, pszString2, nChar) {
        pszString1 := pszString1 is String? StrPtr(pszString1) : pszString1
        pszString2 := pszString2 is String? StrPtr(pszString2) : pszString2

        result := DllCall("SHLWAPI.dll\StrIsIntlEqualA", "int", fCaseSens, "ptr", pszString1, "ptr", pszString2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are equal. (Unicode)
     * @remarks
     * You can set case sensitivity with the <b>StrIntlEqN</b> and <b>StrIntlEqNI</b> macros. <b>StrIntlEqN</b> performs a case-sensitive comparison, and <b>StrIntlEqNI</b> performs a case-insensitive comparison.
     * 
     * The syntax of the two macros is:
     * 				
     * 
     * 
     * ```
     * @param {Integer} fCaseSens Type: <b>BOOL</b>
     * 
     * The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.
     * @param {Pointer<Char>} pszString1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} pszString2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strisintlequalw
     * @since windows5.0
     */
    static StrIsIntlEqualW(fCaseSens, pszString1, pszString2, nChar) {
        pszString1 := pszString1 is String? StrPtr(pszString1) : pszString1
        pszString2 := pszString2 is String? StrPtr(pszString2) : pszString2

        result := DllCall("SHLWAPI.dll\StrIsIntlEqualW", "int", fCaseSens, "ptr", pszString1, "ptr", pszString2, "int", nChar, "int")
        return result
    }

    /**
     * Appends a specified number of characters from the beginning of one string to the end of another. (ANSI)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Be aware that the last argument, <i>cchMax</i>, is the number of characters to copy into <i>psz1</i>, not necessarily the size of the <i>psz1</i> in bytes. Consider using one of the following alternatives. <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcata">StringCbCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatexa">StringCbCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatna">StringCbCatN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatnexa">StringCbCatNEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcata">StringCchCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatexa">StringCchCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatna">StringCchCatN</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatnexa">StringCchCatNEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrNCat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} psz1 Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.
     * @param {Pointer<Byte>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be appended.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>psz1</i>, which holds the combined string.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strncata
     * @since windows5.0
     */
    static StrNCatA(psz1, psz2, cchMax) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrNCatA", "ptr", psz1, "ptr", psz2, "int", cchMax, "char*")
        return result
    }

    /**
     * Appends a specified number of characters from the beginning of one string to the end of another. (Unicode)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Be aware that the last argument, <i>cchMax</i>, is the number of characters to copy into <i>psz1</i>, not necessarily the size of the <i>psz1</i> in bytes. Consider using one of the following alternatives. <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcata">StringCbCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatexa">StringCbCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatna">StringCbCatN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatnexa">StringCbCatNEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcata">StringCchCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatexa">StringCchCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatna">StringCchCatN</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatnexa">StringCchCatNEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrNCat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} psz1 Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.
     * @param {Pointer<Char>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be appended.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>psz1</i>, which holds the combined string.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strncatw
     * @since windows5.0
     */
    static StrNCatW(psz1, psz2, cchMax) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrNCatW", "ptr", psz1, "ptr", psz2, "int", cchMax, "char*")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrPBrk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} psz Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Byte>} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated character buffer that contains the characters for which to search.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strpbrka
     * @since windows5.0
     */
    static StrPBrkA(psz, pszSet) {
        psz := psz is String? StrPtr(psz) : psz
        pszSet := pszSet is String? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrPBrkA", "ptr", psz, "ptr", pszSet, "char*")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrPBrk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} psz Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Char>} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated character buffer that contains the characters for which to search.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strpbrkw
     * @since windows5.0
     */
    static StrPBrkW(psz, pszSet) {
        psz := psz is String? StrPtr(psz) : psz
        pszSet := pszSet is String? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrPBrkW", "ptr", psz, "ptr", pszSet, "char*")
        return result
    }

    /**
     * Searches a string for the last occurrence of a specified character. The comparison is case-sensitive. (ANSI)
     * @remarks
     * The comparison assumes that <i>pszEnd</i> points to the end of the string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrRChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Byte>} pszEnd Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to search for.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrchra
     * @since windows5.0
     */
    static StrRChrA(pszStart, pszEnd, wMatch) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart
        pszEnd := pszEnd is String? StrPtr(pszEnd) : pszEnd

        result := DllCall("SHLWAPI.dll\StrRChrA", "ptr", pszStart, "ptr", pszEnd, "ushort", wMatch, "char*")
        return result
    }

    /**
     * Searches a string for the last occurrence of a specified character. The comparison is case-sensitive. (Unicode)
     * @remarks
     * The comparison assumes that <i>pszEnd</i> points to the end of the string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrRChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Char>} pszEnd Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to search for.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrchrw
     * @since windows5.0
     */
    static StrRChrW(pszStart, pszEnd, wMatch) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart
        pszEnd := pszEnd is String? StrPtr(pszEnd) : pszEnd

        result := DllCall("SHLWAPI.dll\StrRChrW", "ptr", pszStart, "ptr", pszEnd, "char", wMatch, "char*")
        return result
    }

    /**
     * Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * The comparison assumes that <i>pszEnd</i> points to the end of the string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrRChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Byte>} pszEnd Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to search for.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrchria
     * @since windows5.0
     */
    static StrRChrIA(pszStart, pszEnd, wMatch) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart
        pszEnd := pszEnd is String? StrPtr(pszEnd) : pszEnd

        result := DllCall("SHLWAPI.dll\StrRChrIA", "ptr", pszStart, "ptr", pszEnd, "ushort", wMatch, "char*")
        return result
    }

    /**
     * Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * The comparison assumes that <i>pszEnd</i> points to the end of the string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrRChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {Pointer<Char>} pszEnd Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to search for.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrchriw
     * @since windows5.0
     */
    static StrRChrIW(pszStart, pszEnd, wMatch) {
        pszStart := pszStart is String? StrPtr(pszStart) : pszStart
        pszEnd := pszEnd is String? StrPtr(pszEnd) : pszEnd

        result := DllCall("SHLWAPI.dll\StrRChrIW", "ptr", pszStart, "ptr", pszEnd, "char", wMatch, "char*")
        return result
    }

    /**
     * Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrRStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszSource Type: <b>PTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated source string.
     * @param {Pointer<Byte>} pszLast Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.
     * @param {Pointer<Byte>} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrstria
     * @since windows5.0
     */
    static StrRStrIA(pszSource, pszLast, pszSrch) {
        pszSource := pszSource is String? StrPtr(pszSource) : pszSource
        pszLast := pszLast is String? StrPtr(pszLast) : pszLast
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrRStrIA", "ptr", pszSource, "ptr", pszLast, "ptr", pszSrch, "char*")
        return result
    }

    /**
     * Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrRStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszSource Type: <b>PTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated source string.
     * @param {Pointer<Char>} pszLast Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.
     * @param {Pointer<Char>} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrstriw
     * @since windows5.0
     */
    static StrRStrIW(pszSource, pszLast, pszSrch) {
        pszSource := pszSource is String? StrPtr(pszSource) : pszSource
        pszLast := pszLast is String? StrPtr(pszLast) : pszLast
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrRStrIW", "ptr", pszSource, "ptr", pszLast, "ptr", pszSrch, "char*")
        return result
    }

    /**
     * Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} psz Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string that is to be searched.
     * @param {Pointer<Byte>} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated character buffer that contains the set of characters for which to search.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the length, in characters, of the matching string or zero if no match is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strspna
     * @since windows5.0
     */
    static StrSpnA(psz, pszSet) {
        psz := psz is String? StrPtr(psz) : psz
        pszSet := pszSet is String? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrSpnA", "ptr", psz, "ptr", pszSet, "int")
        return result
    }

    /**
     * Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} psz Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string that is to be searched.
     * @param {Pointer<Char>} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated character buffer that contains the set of characters for which to search.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the length, in characters, of the matching string or zero if no match is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strspnw
     * @since windows5.0
     */
    static StrSpnW(psz, pszSet) {
        psz := psz is String? StrPtr(psz) : psz
        pszSet := pszSet is String? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrSpnW", "ptr", psz, "ptr", pszSet, "int")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is case-sensitive. (StrStrA)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszFirst Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to search.
     * @param {Pointer<Byte>} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strstra
     * @since windows5.0
     */
    static StrStrA(pszFirst, pszSrch) {
        pszFirst := pszFirst is String? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrA", "ptr", pszFirst, "ptr", pszSrch, "char*")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is case-sensitive. (StrStrW)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszFirst Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to search.
     * @param {Pointer<Char>} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strstrw
     * @since windows5.0
     */
    static StrStrW(pszFirst, pszSrch) {
        pszFirst := pszFirst is String? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrW", "ptr", pszFirst, "ptr", pszSrch, "char*")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszFirst Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string being searched.
     * @param {Pointer<Byte>} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strstria
     * @since windows5.0
     */
    static StrStrIA(pszFirst, pszSrch) {
        pszFirst := pszFirst is String? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrIA", "ptr", pszFirst, "ptr", pszSrch, "char*")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszFirst Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string being searched.
     * @param {Pointer<Char>} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strstriw
     * @since windows5.0
     */
    static StrStrIW(pszFirst, pszSrch) {
        pszFirst := pszFirst is String? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrIW", "ptr", pszFirst, "ptr", pszSrch, "char*")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is case-sensitive. (StrStrNW)
     * @param {Pointer<Char>} pszFirst Type: <b>PWSTR</b>
     * 
     * A pointer to the null-terminated, Unicode string that is being searched.
     * @param {Pointer<Char>} pszSrch Type: <b>PCWSTR</b>
     * 
     * A pointer to the null-terminated, Unicode substring that is being searched for.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters from the beginning of the searched string in which to search for the substring.
     * @returns {Pointer<Char>} Type: <b>PWSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strstrnw
     * @since windows6.0.6000
     */
    static StrStrNW(pszFirst, pszSrch, cchMax) {
        pszFirst := pszFirst is String? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrNW", "ptr", pszFirst, "ptr", pszSrch, "uint", cchMax, "char*")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is case-insensitive.
     * @param {Pointer<Char>} pszFirst Type: <b>PWSTR</b>
     * 
     * A pointer to the null-terminated, Unicode string that is being searched.
     * @param {Pointer<Char>} pszSrch Type: <b>PCWSTR</b>
     * 
     * A pointer to the null-terminated, Unicode substring that is being searched for.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters from the beginning of the searched string in which to search for the substring.
     * @returns {Pointer<Char>} Type: <b>PWSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strstrniw
     * @since windows6.0.6000
     */
    static StrStrNIW(pszFirst, pszSrch, cchMax) {
        pszFirst := pszFirst is String? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrNIW", "ptr", pszFirst, "ptr", pszSrch, "uint", cchMax, "char*")
        return result
    }

    /**
     * Converts a string that represents a decimal value to an integer. The StrToLong macro is identical to this function. (ANSI)
     * @remarks
     * If the string pointed to by <i>pszSrc</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <b>StrToInt</b> only recognizes "12" and returns that integer value.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrToInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.
     *                     
     *                     
     * 
     * 
     * ``` syntax
     * (optional white space)(optional sign)(one or more decimal digits)
     * ```
     * 
     * The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strtointa
     * @since windows5.0
     */
    static StrToIntA(pszSrc) {
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrToIntA", "ptr", pszSrc, "int")
        return result
    }

    /**
     * Converts a string that represents a decimal value to an integer. The StrToLong macro is identical to this function. (Unicode)
     * @remarks
     * If the string pointed to by <i>pszSrc</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <b>StrToInt</b> only recognizes "12" and returns that integer value.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrToInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.
     *                     
     *                     
     * 
     * 
     * ``` syntax
     * (optional white space)(optional sign)(one or more decimal digits)
     * ```
     * 
     * The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strtointw
     * @since windows5.0
     */
    static StrToIntW(pszSrc) {
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrToIntW", "ptr", pszSrc, "int")
        return result
    }

    /**
     * Converts a string representing a decimal or hexadecimal number to an integer. (ANSI)
     * @remarks
     * The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.
     *                 
     * 
     * <ul>
     * <li>This form is accepted as a decimal value under either flag.
     *                         
     * ``` syntax
     * (optional white space)(optional sign)(one or more decimal digits)
     * ```
     * 
     * </li>
     * <li>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
     *                         
     * ``` syntax
     * (optional white space)(optional sign)0x(one or more hexadecimal digits)
     * ```
     * 
     * 
     * ``` syntax
     * (optional white space)(optional sign)0X(one or more hexadecimal digits)
     * ```
     * 
     * </li>
     * </ul>
     * The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.
     * 
     * <div class="alert"><b>Note</b>If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</div>
     * <div></div>
     * If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToIntEx</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrToIntEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszString Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.
     * @param {Integer} dwFlags Type: <b>STIF_FLAGS</b>
     * @param {Pointer<Int32>} piRet Type: <b>int*</b>
     * 
     * A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123. 
     *                     
     *                     
     * 
     * If this function returns <b>FALSE</b>, this value is undefined.
     * 
     * If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strtointexa
     * @since windows5.0
     */
    static StrToIntExA(pszString, dwFlags, piRet) {
        pszString := pszString is String? StrPtr(pszString) : pszString

        result := DllCall("SHLWAPI.dll\StrToIntExA", "ptr", pszString, "int", dwFlags, "int*", piRet, "int")
        return result
    }

    /**
     * Converts a string representing a decimal or hexadecimal number to an integer. (Unicode)
     * @remarks
     * The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.
     *                 
     * 
     * <ul>
     * <li>This form is accepted as a decimal value under either flag.
     *                         
     * ``` syntax
     * (optional white space)(optional sign)(one or more decimal digits)
     * ```
     * 
     * </li>
     * <li>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
     *                         
     * ``` syntax
     * (optional white space)(optional sign)0x(one or more hexadecimal digits)
     * ```
     * 
     * 
     * ``` syntax
     * (optional white space)(optional sign)0X(one or more hexadecimal digits)
     * ```
     * 
     * </li>
     * </ul>
     * The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.
     * 
     * <div class="alert"><b>Note</b>If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</div>
     * <div></div>
     * If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToIntEx</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrToIntEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszString Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.
     * @param {Integer} dwFlags Type: <b>STIF_FLAGS</b>
     * @param {Pointer<Int32>} piRet Type: <b>int*</b>
     * 
     * A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123. 
     *                     
     *                     
     * 
     * If this function returns <b>FALSE</b>, this value is undefined.
     * 
     * If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strtointexw
     * @since windows5.0
     */
    static StrToIntExW(pszString, dwFlags, piRet) {
        pszString := pszString is String? StrPtr(pszString) : pszString

        result := DllCall("SHLWAPI.dll\StrToIntExW", "ptr", pszString, "int", dwFlags, "int*", piRet, "int")
        return result
    }

    /**
     * Converts a string representing a decimal or hexadecimal value to a 64-bit integer. (ANSI)
     * @remarks
     * The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.
     * 
     *                 
     * 
     * <ul>
     * <li>This form is accepted as a decimal value under either flag.
     *                         
     * ``` syntax
     * (optional white space)(optional sign)(one or more decimal digits)
     * ```
     * 
     * </li>
     * <li>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
     *                         
     * ``` syntax
     * (optional white space)(optional sign)0x(one or more hexadecimal digits)
     * ```
     * 
     * 
     * ``` syntax
     * (optional white space)(optional sign)0X(one or more hexadecimal digits)
     * ```
     * 
     * </li>
     * </ul>
     * The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.
     * 
     * <div class="alert"><b>Note</b>If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</div>
     * <div></div>
     * If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToInt64Ex</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.
     * 
     * If <i>pllRet</i> is <b>NULL</b>, the function returns <b>TRUE</b> if the string can be converted, even though it does not perform the conversion.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrToInt64Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszString Type: <b>PCTSTR</b>
     * 
     * A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.
     * @param {Integer} dwFlags Type: <b>STIF_FLAGS</b>
     * @param {Pointer<Int64>} pllRet Type: <b>LONGLONG*</b>
     * 
     * A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123. 
     * 
     *                     
     * 
     * If this function returns <b>FALSE</b>, this value is undefined.
     * 
     * If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strtoint64exa
     * @since windows5.0
     */
    static StrToInt64ExA(pszString, dwFlags, pllRet) {
        pszString := pszString is String? StrPtr(pszString) : pszString

        result := DllCall("SHLWAPI.dll\StrToInt64ExA", "ptr", pszString, "int", dwFlags, "int64*", pllRet, "int")
        return result
    }

    /**
     * Converts a string representing a decimal or hexadecimal value to a 64-bit integer. (Unicode)
     * @remarks
     * The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.
     * 
     *                 
     * 
     * <ul>
     * <li>This form is accepted as a decimal value under either flag.
     *                         
     * ``` syntax
     * (optional white space)(optional sign)(one or more decimal digits)
     * ```
     * 
     * </li>
     * <li>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
     *                         
     * ``` syntax
     * (optional white space)(optional sign)0x(one or more hexadecimal digits)
     * ```
     * 
     * 
     * ``` syntax
     * (optional white space)(optional sign)0X(one or more hexadecimal digits)
     * ```
     * 
     * </li>
     * </ul>
     * The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.
     * 
     * <div class="alert"><b>Note</b>If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</div>
     * <div></div>
     * If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToInt64Ex</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.
     * 
     * If <i>pllRet</i> is <b>NULL</b>, the function returns <b>TRUE</b> if the string can be converted, even though it does not perform the conversion.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrToInt64Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszString Type: <b>PCTSTR</b>
     * 
     * A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.
     * @param {Integer} dwFlags Type: <b>STIF_FLAGS</b>
     * @param {Pointer<Int64>} pllRet Type: <b>LONGLONG*</b>
     * 
     * A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123. 
     * 
     *                     
     * 
     * If this function returns <b>FALSE</b>, this value is undefined.
     * 
     * If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strtoint64exw
     * @since windows5.0
     */
    static StrToInt64ExW(pszString, dwFlags, pllRet) {
        pszString := pszString is String? StrPtr(pszString) : pszString

        result := DllCall("SHLWAPI.dll\StrToInt64ExW", "ptr", pszString, "int", dwFlags, "int64*", pllRet, "int")
        return result
    }

    /**
     * Removes specified leading and trailing characters from a string. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrTrim as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} psz Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.
     * @param {Pointer<Byte>} pszTrimChars Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strtrima
     * @since windows5.0
     */
    static StrTrimA(psz, pszTrimChars) {
        psz := psz is String? StrPtr(psz) : psz
        pszTrimChars := pszTrimChars is String? StrPtr(pszTrimChars) : pszTrimChars

        result := DllCall("SHLWAPI.dll\StrTrimA", "ptr", psz, "ptr", pszTrimChars, "int")
        return result
    }

    /**
     * Removes specified leading and trailing characters from a string. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrTrim as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} psz Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.
     * @param {Pointer<Char>} pszTrimChars Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strtrimw
     * @since windows5.0
     */
    static StrTrimW(psz, pszTrimChars) {
        psz := psz is String? StrPtr(psz) : psz
        pszTrimChars := pszTrimChars is String? StrPtr(pszTrimChars) : pszTrimChars

        result := DllCall("SHLWAPI.dll\StrTrimW", "ptr", psz, "ptr", pszTrimChars, "int")
        return result
    }

    /**
     * Appends one string to another.
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Consider using one of the following alternatives: <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcata">StringCbCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatexa">StringCbCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatna">StringCbCatN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatnexa">StringCbCatNEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcata">StringCchCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatexa">StringCchCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatna">StringCchCatN</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatnexa">StringCchCatNEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * @param {Pointer<Char>} psz1 Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>psz2</i> appended. This buffer must be large enough to hold both strings and the terminating null character.
     * @param {Pointer<Char>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string to be appended to <i>psz1</i>.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>psz1</i>, which holds the combined strings.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcatw
     * @since windows5.0
     */
    static StrCatW(psz1, psz2) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCatW", "ptr", psz1, "ptr", psz2, "char*")
        return result
    }

    /**
     * Compares two strings to determine if they are the same. The comparison is case-sensitive.
     * @param {Pointer<Char>} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>psz1</i> is greater than that pointed to by <i>psz2</i>. Returns a negative value if the string pointed to by <i>psz1</i> is less than that pointed to by <i>psz2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpw
     * @since windows5.0
     */
    static StrCmpW(psz1, psz2) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpW", "ptr", psz1, "ptr", psz2, "int")
        return result
    }

    /**
     * Compares two strings to determine if they are the same. The comparison is not case-sensitive.
     * @param {Pointer<Char>} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>psz1</i> is greater than that pointed to by <i>psz2</i>. Returns a negative value if the string pointed to by <i>psz1</i> is less than that pointed to by <i>psz2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpiw
     * @since windows5.0
     */
    static StrCmpIW(psz1, psz2) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpIW", "ptr", psz1, "ptr", psz2, "int")
        return result
    }

    /**
     * Copies one string to another. (StrCpyW)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Consider using one of the following alternatives: <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcopya">StringCbCopy</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcopyexa">StringCbCopyEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcopyna">StringCbCopyN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcopynexa">StringCbCopyNEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopyexa">StringCchCopyEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopyna">StringCchCopyN</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopynexa">StringCchCopyNEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * @param {Pointer<Char>} psz1 Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the copied string. This string is not guaranteed to be null-terminated.
     * @param {Pointer<Char>} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated source string.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>psz1</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcpyw
     * @since windows5.0
     */
    static StrCpyW(psz1, psz2) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCpyW", "ptr", psz1, "ptr", psz2, "char*")
        return result
    }

    /**
     * Copies a specified number of characters from the beginning of one string to another.NoteDo not use this function or the StrNCpy macro.
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated.  Consider using one of the following alternatives. <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcopya">StringCbCopy</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcopyexa">StringCbCopyEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcopyna">StringCbCopyN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcopynexa">StringCbCopyNEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopya">StringCchCopy</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopyexa">StringCchCopyEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopyna">StringCchCopyN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcopynexa">StringCchCopyNEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * @param {Pointer<Char>} pszDst Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the copied string. This buffer must be of sufficient size to hold the copied characters. This string is not guaranteed to be null-terminated.
     * @param {Pointer<Char>} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated source string.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The number of characters to be copied, including the terminating null character.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>pszDst</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcpynw
     * @since windows5.0
     */
    static StrCpyNW(pszDst, pszSrc, cchMax) {
        pszDst := pszDst is String? StrPtr(pszDst) : pszDst
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrCpyNW", "ptr", pszDst, "ptr", pszSrc, "int", cchMax, "char*")
        return result
    }

    /**
     * Copies and appends characters from one string to the end of another. (Unicode)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcata">StringCbCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatexa">StringCbCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatna">StringCbCatN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatnexa">StringCbCatNEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcata">StringCchCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatexa">StringCchCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatna">StringCchCatN</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatnexa">StringCchCatNEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCatBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.
     * @param {Pointer<Char>} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the string to be appended to <i>pszDest</i>.
     * @param {Integer} cchDestBuffSize Type: <b>int</b>
     * 
     * The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the destination string.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcatbuffw
     * @since windows5.0
     */
    static StrCatBuffW(pszDest, pszSrc, cchDestBuffSize) {
        pszDest := pszDest is String? StrPtr(pszDest) : pszDest
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrCatBuffW", "ptr", pszDest, "ptr", pszSrc, "int", cchDestBuffSize, "char*")
        return result
    }

    /**
     * Copies and appends characters from one string to the end of another. (ANSI)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcata">StringCbCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatexa">StringCbCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatna">StringCbCatN</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatnexa">StringCbCatNEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcata">StringCchCat</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatexa">StringCchCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatna">StringCchCatN</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatnexa">StringCchCatNEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCatBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.
     * @param {Pointer<Byte>} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the string to be appended to <i>pszDest</i>.
     * @param {Integer} cchDestBuffSize Type: <b>int</b>
     * 
     * The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the destination string.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcatbuffa
     * @since windows5.0
     */
    static StrCatBuffA(pszDest, pszSrc, cchDestBuffSize) {
        pszDest := pszDest is String? StrPtr(pszDest) : pszDest
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrCatBuffA", "ptr", pszDest, "ptr", pszSrc, "int", cchDestBuffSize, "char*")
        return result
    }

    /**
     * Performs a comparison between two characters. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines ChrCmpI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} w1 Type: <b>TCHAR</b>
     * 
     * The first character to be compared.
     * @param {Integer} w2 Type: <b>TCHAR</b>
     * 
     * The second character to be compared.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns zero if the two characters are the same, or nonzero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-chrcmpia
     * @since windows5.0
     */
    static ChrCmpIA(w1, w2) {
        result := DllCall("SHLWAPI.dll\ChrCmpIA", "ushort", w1, "ushort", w2, "int")
        return result
    }

    /**
     * Performs a comparison between two characters. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines ChrCmpI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} w1 Type: <b>TCHAR</b>
     * 
     * The first character to be compared.
     * @param {Integer} w2 Type: <b>TCHAR</b>
     * 
     * The second character to be compared.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns zero if the two characters are the same, or nonzero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-chrcmpiw
     * @since windows5.0
     */
    static ChrCmpIW(w1, w2) {
        result := DllCall("SHLWAPI.dll\ChrCmpIW", "char", w1, "char", w2, "int")
        return result
    }

    /**
     * Takes a list of arguments and returns the values of the arguments as a printf-style formatted string. (ANSI)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbprintfa">StringCbPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbprintfexa">StringCbPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbvprintfa">StringCbVPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbvprintfexa">StringCbVPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchprintfa">StringCchPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchprintfexa">StringCchPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchvprintfa">StringCchVPrintf</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchvprintfexa">StringCchVPrintfEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines wvnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the output string.
     * @param {Integer} cchDest Type: <b>int</b>
     * 
     * The maximum number of characters allowed in <i>pszDest</i>.
     * @param {Pointer<Byte>} pszFmt Type: <b>PCTSTR</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
     * @param {Pointer<SByte>} arglist Type: <b>va_list</b>
     * 
     * A pointer to a list of command-line parameters used to customize the output.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-wvnsprintfa
     * @since windows5.0
     */
    static wvnsprintfA(pszDest, cchDest, pszFmt, arglist) {
        pszDest := pszDest is String? StrPtr(pszDest) : pszDest
        pszFmt := pszFmt is String? StrPtr(pszFmt) : pszFmt

        result := DllCall("SHLWAPI.dll\wvnsprintfA", "ptr", pszDest, "int", cchDest, "ptr", pszFmt, "char*", arglist, "int")
        return result
    }

    /**
     * Takes a list of arguments and returns the values of the arguments as a printf-style formatted string. (Unicode)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbprintfa">StringCbPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbprintfexa">StringCbPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbvprintfa">StringCbVPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbvprintfexa">StringCbVPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchprintfa">StringCchPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchprintfexa">StringCchPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchvprintfa">StringCchVPrintf</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchvprintfexa">StringCchVPrintfEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines wvnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the output string.
     * @param {Integer} cchDest Type: <b>int</b>
     * 
     * The maximum number of characters allowed in <i>pszDest</i>.
     * @param {Pointer<Char>} pszFmt Type: <b>PCTSTR</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
     * @param {Pointer<SByte>} arglist Type: <b>va_list</b>
     * 
     * A pointer to a list of command-line parameters used to customize the output.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-wvnsprintfw
     * @since windows5.0
     */
    static wvnsprintfW(pszDest, cchDest, pszFmt, arglist) {
        pszDest := pszDest is String? StrPtr(pszDest) : pszDest
        pszFmt := pszFmt is String? StrPtr(pszFmt) : pszFmt

        result := DllCall("SHLWAPI.dll\wvnsprintfW", "ptr", pszDest, "int", cchDest, "ptr", pszFmt, "char*", arglist, "int")
        return result
    }

    /**
     * Takes a variable-length argument list and returns the values of the arguments as a printf-style formatted string. (ANSI)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbprintfa">StringCbPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbprintfexa">StringCbPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbvprintfa">StringCbVPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbvprintfexa">StringCbVPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchprintfa">StringCchPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchprintfexa">StringCchPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchvprintfa">StringCchVPrintf</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchvprintfexa">StringCchVPrintfEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * 
     * This is a Windows version of <a href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2010/ybk95axf(v=vs.100)">sprintf</a>. It does not support floating-point or pointer types. It supports only the left alignment flag.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines wnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the output string.
     * @param {Integer} cchDest Type: <b>int</b>
     * 
     * The maximum number of characters allowed in <i>pszDest</i>.
     * @param {Pointer<Byte>} pszFmt Type: <b>PCTSTR</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-wnsprintfa
     * @since windows5.0
     */
    static wnsprintfA(pszDest, cchDest, pszFmt) {
        pszDest := pszDest is String? StrPtr(pszDest) : pszDest
        pszFmt := pszFmt is String? StrPtr(pszFmt) : pszFmt

        result := DllCall("SHLWAPI.dll\wnsprintfA", "ptr", pszDest, "int", cchDest, "ptr", pszFmt, "CDecl int")
        return result
    }

    /**
     * Takes a variable-length argument list and returns the values of the arguments as a printf-style formatted string. (Unicode)
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbprintfa">StringCbPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbprintfexa">StringCbPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbvprintfa">StringCbVPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbvprintfexa">StringCbVPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchprintfa">StringCchPrintf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchprintfexa">StringCchPrintfEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchvprintfa">StringCchVPrintf</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchvprintfexa">StringCchVPrintfEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * 
     * This is a Windows version of <a href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2010/ybk95axf(v=vs.100)">sprintf</a>. It does not support floating-point or pointer types. It supports only the left alignment flag.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines wnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the output string.
     * @param {Integer} cchDest Type: <b>int</b>
     * 
     * The maximum number of characters allowed in <i>pszDest</i>.
     * @param {Pointer<Char>} pszFmt Type: <b>PCTSTR</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-wnsprintfw
     * @since windows5.0
     */
    static wnsprintfW(pszDest, cchDest, pszFmt) {
        pszDest := pszDest is String? StrPtr(pszDest) : pszDest
        pszFmt := pszFmt is String? StrPtr(pszFmt) : pszFmt

        result := DllCall("SHLWAPI.dll\wnsprintfW", "ptr", pszDest, "int", cchDest, "ptr", pszFmt, "CDecl int")
        return result
    }

    /**
     * Takes an STRRET structure returned by IShellFolder::GetDisplayNameOf and returns a pointer to an allocated string containing the display name. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrRetToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer will no longer be valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure. This value can be <b>NULL</b>.
     * @param {Pointer<Byte>} ppsz Type: <b>LPTSTR*</b>
     * 
     * A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>. You should free the string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrettostra
     * @since windows5.0
     */
    static StrRetToStrA(pstr, pidl, ppsz) {
        result := DllCall("SHLWAPI.dll\StrRetToStrA", "ptr", pstr, "ptr", pidl, "ptr", ppsz, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Takes an STRRET structure returned by IShellFolder::GetDisplayNameOf and returns a pointer to an allocated string containing the display name. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines StrRetToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer will no longer be valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} ppsz Type: <b>LPTSTR*</b>
     * 
     * A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>. You should free the string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrettostrw
     * @since windows5.0
     */
    static StrRetToStrW(pstr, pidl, ppsz) {
        result := DllCall("SHLWAPI.dll\StrRetToStrW", "ptr", pstr, "ptr", pidl, "ptr", ppsz, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts an STRRET structure returned by IShellFolder::GetDisplayNameOf to a string, and places the result in a buffer. (ANSI)
     * @remarks
     * If the <b>uType</b> member of the structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <b>pOleStr</b> member of that structure will be freed on return.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrRetToBuf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer will no longer be valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<Byte>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrettobufa
     * @since windows5.0
     */
    static StrRetToBufA(pstr, pidl, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrRetToBufA", "ptr", pstr, "ptr", pidl, "ptr", pszBuf, "uint", cchBuf, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts an STRRET structure returned by IShellFolder::GetDisplayNameOf to a string, and places the result in a buffer. (Unicode)
     * @remarks
     * If the <b>uType</b> member of the structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <b>pOleStr</b> member of that structure will be freed on return.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrRetToBuf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer will no longer be valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<Char>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrettobufw
     * @since windows5.0
     */
    static StrRetToBufW(pstr, pidl, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrRetToBufW", "ptr", pstr, "ptr", pidl, "ptr", pszBuf, "uint", cchBuf, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Makes a copy of a string in newly allocated memory. (SHStrDupA)
     * @remarks
     * This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.
     * 
     * This function uses <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a> to allocate memory for the copied string. You must free this memory with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} psz Type: <b>LPCTSTR</b>
     * 
     * A pointer to the null-terminated string to be copied.
     * @param {Pointer<Char>} ppwsz Type: <b>LPTSTR*</b>
     * 
     * A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>. You should free the string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * 
     *                     
     * 
     * In the case of failure, this value is NULL.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or a COM error value otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shstrdupa
     * @since windows5.0
     */
    static SHStrDupA(psz, ppwsz) {
        psz := psz is String? StrPtr(psz) : psz

        result := DllCall("SHLWAPI.dll\SHStrDupA", "ptr", psz, "ptr", ppwsz, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Makes a copy of a string in newly allocated memory. (SHStrDupW)
     * @remarks
     * This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.
     * 
     * This function uses <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a> to allocate memory for the copied string. You must free this memory with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} psz Type: <b>LPCTSTR</b>
     * 
     * A pointer to the null-terminated string to be copied.
     * @param {Pointer<Char>} ppwsz Type: <b>LPTSTR*</b>
     * 
     * A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>. You should free the string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * 
     *                     
     * 
     * In the case of failure, this value is NULL.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or a COM error value otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shstrdupw
     * @since windows5.0
     */
    static SHStrDupW(psz, ppwsz) {
        psz := psz is String? StrPtr(psz) : psz

        result := DllCall("SHLWAPI.dll\SHStrDupW", "ptr", psz, "ptr", ppwsz, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Compares two Unicode strings. Digits in the strings are considered as numerical content rather than text. This test is not case-sensitive.
     * @remarks
     * This function's ordering schema differs somewhat from <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-strcmpiw">StrCmpI</a>, which also compares strings without regard to case sensitivity. Considering digits by their numerical valueas <b>StrCmpLogicalW</b> doesstrings are ordered as follows:
     * 		
     *                 
     * 
     * 
     * ```
     * 2string
     * 3string
     * 20string
     * st2ring
     * st3ring
     * st20ring
     * string2
     * string3
     * string20
     * ```
     * 
     * 
     * <b>StrCmpI</b> considers digits in the string only as text so that those same strings are ordered as follows:
     * 		    
     *                 
     * 
     * 
     * ```
     * 20string
     * 2string
     * 3string
     * st20ring
     * st2ring
     * st3ring
     * string2
     * string20
     * string3
     * ```
     * 
     * 
     * <div class="alert"><b>Note</b>Behavior of this function, and therefore the results it returns, can change from release to release. It should not be used for canonical sorting applications.</div>
     * <div></div>
     * @param {Pointer<Char>} psz1 Type: <b>PCWSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} psz2 Type: <b>PCWSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * <ul>
     * <li>Returns zero if the strings are identical.</li>
     * <li>Returns 1 if the string pointed to by <i>psz1</i> has a greater value than that pointed to by <i>psz2</i>.</li>
     * <li>Returns -1 if the string pointed to by <i>psz1</i> has a lesser value than that pointed to by <i>psz2</i>.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmplogicalw
     * @since windows5.1.2600
     */
    static StrCmpLogicalW(psz1, psz2) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpLogicalW", "ptr", psz1, "ptr", psz2, "int")
        return result
    }

    /**
     * Concatenates two Unicode strings. Used when repeated concatenations to the same buffer are required.
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatexa">StringCbCatEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcbcatnexa">StringCbCatNEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatexa">StringCchCatEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/strsafe/nf-strsafe-stringcchcatnexa">StringCchCatNEx</a>. You should review <a href="https://docs.microsoft.com/windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.
     * @param {Pointer<Char>} pszDst Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the null-terminated, Unicode string.
     * @param {Integer} cchDst Type: <b>DWORD</b>
     * 
     * The size of the destination buffer, in characters. This buffer must be of sufficient size to hold both strings as well as a terminating null character. If the buffer is too small, the final string is truncated.
     * @param {Integer} ichAt Type: <b>DWORD</b>
     * 
     * The offset into the destination buffer at which to begin the append action. If the string is not empty, set this value to -1 to have the current number of filled characters (not including the terminating null character) calculated for you.
     * @param {Pointer<Char>} pszSrc Type: <b>PCWSTR</b>
     * 
     * A pointer to the null-terminated Unicode source string.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns the offset of the null character after the last character added to <i>pszDst</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcatchainw
     * @since windows5.1.2600
     */
    static StrCatChainW(pszDst, cchDst, ichAt, pszSrc) {
        pszDst := pszDst is String? StrPtr(pszDst) : pszDst
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrCatChainW", "ptr", pszDst, "uint", cchDst, "uint", ichAt, "ptr", pszSrc, "uint")
        return result
    }

    /**
     * Accepts a STRRET structure returned by IShellFolder::GetDisplayNameOf that contains or points to a string, and returns that string as a BSTR.
     * @remarks
     * If the <i>uType</i> member of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <i>pOleStr</i> member of that structure is freed on return.
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer is longer valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> that uniquely identifies a file object or subfolder relative to the parent folder. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pbstr Type: <b><a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">BSTR</a>*</b>
     * 
     * A pointer to a variable of type <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">BSTR</a> that receives the converted string.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strrettobstr
     * @since windows5.1.2600
     */
    static StrRetToBSTR(pstr, pidl, pbstr) {
        result := DllCall("SHLWAPI.dll\StrRetToBSTR", "ptr", pstr, "ptr", pidl, "ptr", pbstr, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins with the '@' symbol).
     * @remarks
     * An indirect string can be provided in several forms, each of which has its own interpretation:
     *             
     * 			    
     * 
     * <ul>
     * <li><b>File name and resource ID</b>
     * ``` syntax
     * @filename,resource
     * ```
     * 
     * The string is extracted from the file named, using the <i>resource</i> value as a locator. If the resource value is zero or greater, the number becomes the index of the string in the binary file. If the number is negative, it becomes a resource ID. The retrieved string is copied to the output buffer and the function returns S_OK.
     * 
     * </li>
     * <li><b>File name and resource ID with a version modifier</b>
     * ``` syntax
     * @filename,resource;v2
     * ```
     * 
     * This form can be used when a resource is changed but still uses the same index or ID as the old resource. Without a version modifier, the Multilingual User Interface (MUI) cache will not recognize that the resource has changed and will not refresh. By appending the version modifier, the value is seen as a new resource and is added to the cache. Note that it is recommended that you use a new ID or index for a new resource, and use a version modifier only when that is not possible.
     * 
     * </li>
     * <li><b>PRI file path and resource ID</b>
     * ``` syntax
     * @{PRIFilepath?resource}
     * ```
     * 
     * The Package Resource Index (PRI) is a binary format introduced in Windows8 that contains indexed resources or references to resources. The .pri file is bundled as part of an app's package. For more information on .pri files, see <a href="https://docs.microsoft.com/previous-versions/hh694557(v=vs.110)">Creating and retrieving resources in Windows Store apps</a>.
     * 
     * The string is extracted from the .pri file named, using the <i>resource</i> as a locator. The retrieved string is copied to the output buffer and the function returns S_OK. The string is extracted based on the current Shell environment or <a href="https://docs.microsoft.com/uwp/api/windows.applicationmodel.resources.core.resourcecontext">ResourceContext</a>.
     * 
     * An example of this type of indirect string is shown here.
     *                         
     *                             
     * 
     * 
     * ```
     * 
     * @{C:\Program Files\WindowsApps\Microsoft.Camera_6.2.8376.0_x64__8wekyb3d8bbwe\resources.pri? ms-resource://Microsoft.Camera/resources/manifestAppDescription}
     * ```
     * 
     * 
     * 
     * 
     * </li>
     * <li><b>Package name and resource ID</b>
     * ``` syntax
     * @{PackageFullName?resource}
     * ```
     * 
     * The string is extracted from the Resources.pri file stored in the app's root directory of the package identified by <i>PackageFullName</i>, using the <i>resource</i> as a locator. The retrieved string is copied to the output buffer and the function returns S_OK. The string is extracted based on the app's environment or <a href="https://docs.microsoft.com/uwp/api/windows.applicationmodel.resources.core.resourcecontext">ResourceContext</a>.
     * 
     * <div class="alert"><b>Note</b>This string must refer to a package installed for the current user. If it does not, the call will fail.</div>
     * <div></div>
     * An example of this type of indirect string is shown here. In this example, the reference name is fully-qualified, but it contains no namespace (for example, "resources"). The deployment stack expands the name to look for it in all namespaces.
     * 
     * 
     * ```
     * 
     * @{Microsoft.Camera_6.2.8376.0_x64__8wekyb3d8bbwe? ms-resource://Microsoft.Camera/manifestAppDescription}
     * ```
     * 
     * 
     * 
     * 
     * In this next example, the fully-qualified reference name does specify a namespace to limit the lookup to.
     * 
     * 
     * ```
     * 
     * @{Microsoft.Camera_6.2.8376.0_x64__8wekyb3d8bbwe? ms-resource://Microsoft.Camera/resources/manifestAppDescription}
     * ```
     * 
     * 
     * 
     * 
     * </li>
     * </ul>
     * If the string is not an indirect string, then the string is directly copied without change to <i>pszOutBuf</i> and the function returns S_OK.
     * @param {Pointer<Char>} pszSource Type: <b>PCWSTR</b>
     * 
     * A pointer to a buffer that contains the indirect string from which the resource will be retrieved. This string should begin with the '@' symbol and use one of the forms discussed in the Remarks section. This function will successfully accept a string that does not begin with an '@' symbol, but the string will be simply passed unchanged to <i>pszOutBuf</i>.
     * @param {Pointer<Char>} pszOutBuf Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the text resource. Both <i>pszOutBuf</i> and <i>pszSource</i> can point to the same buffer, in which case the original string will be overwritten.
     * @param {Integer} cchOutBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszOutBuf</i>, in characters.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shloadindirectstring
     * @since windows5.1.2600
     */
    static SHLoadIndirectString(pszSource, pszOutBuf, cchOutBuf) {
        static ppvReserved := 0 ;Reserved parameters must always be NULL

        pszSource := pszSource is String? StrPtr(pszSource) : pszSource
        pszOutBuf := pszOutBuf is String? StrPtr(pszOutBuf) : pszOutBuf

        result := DllCall("SHLWAPI.dll\SHLoadIndirectString", "ptr", pszSource, "ptr", pszOutBuf, "uint", cchOutBuf, "ptr", ppvReserved, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines whether a character represents a space. (ANSI)
     * @remarks
     * For those versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h, <b>IsCharSpaceW</b> must be called directly from Shlwapi.dll (ordinal 29), using a WCHAR in the <i>wch</i> parameter. <b>IsCharSpaceA</b> is not available in versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines IsCharSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} wch Type: <b>TCHAR</b>
     * 
     * A single character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-ischarspacea
     * @since windows5.0
     */
    static IsCharSpaceA(wch) {
        result := DllCall("SHLWAPI.dll\IsCharSpaceA", "char", wch, "int")
        return result
    }

    /**
     * Determines whether a character represents a space. (Unicode)
     * @remarks
     * For those versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h, <b>IsCharSpaceW</b> must be called directly from Shlwapi.dll (ordinal 29), using a WCHAR in the <i>wch</i> parameter. <b>IsCharSpaceA</b> is not available in versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines IsCharSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} wch Type: <b>TCHAR</b>
     * 
     * A single character.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-ischarspacew
     * @since windows5.0
     */
    static IsCharSpaceW(wch) {
        result := DllCall("SHLWAPI.dll\IsCharSpaceW", "char", wch, "int")
        return result
    }

    /**
     * Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive. (ANSI)
     * @remarks
     * It is strongly recommended that you use the <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> function in place of this function. <b>StrCmpC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.
     * 
     * This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpC</b> determines that the first unequal character is at position four ("z" in <i>lpStr1</i> and "d" in <i>lpStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".
     * 
     * For those versions of Windows that do not include <b>StrCmpC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpCA</b> is ordinal 155 and <b>StrCmpCW</b> is ordinal 156.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Byte>} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpca
     * @since windows5.0
     */
    static StrCmpCA(pszStr1, pszStr2) {
        pszStr1 := pszStr1 is String? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpCA", "ptr", pszStr1, "ptr", pszStr2, "int")
        return result
    }

    /**
     * Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive. (Unicode)
     * @remarks
     * It is strongly recommended that you use the <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> function in place of this function. <b>StrCmpC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.
     * 
     * This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpC</b> determines that the first unequal character is at position four ("z" in <i>lpStr1</i> and "d" in <i>lpStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".
     * 
     * For those versions of Windows that do not include <b>StrCmpC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpCA</b> is ordinal 155 and <b>StrCmpCW</b> is ordinal 156.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpcw
     * @since windows5.0
     */
    static StrCmpCW(pszStr1, pszStr2) {
        pszStr1 := pszStr1 is String? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpCW", "ptr", pszStr1, "ptr", pszStr2, "int")
        return result
    }

    /**
     * Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * It is strongly recommended that you use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> in place of this function. <b>StrCmpIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with double-byte character set (DBCS) data.
     * 
     * Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the converted values.  This function returns the difference in value of the first unequal characters it encounters, or zero if they are all equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpIC</b> determines that "abczb" is greater than "abcdefg" and returns z - d.
     * 
     * For those versions of Windows that do not include <b>StrCmpIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpICA</b> is ordinal 157 and <b>StrCmpICW</b> is ordinal 158.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Byte>} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpica
     * @since windows5.0
     */
    static StrCmpICA(pszStr1, pszStr2) {
        pszStr1 := pszStr1 is String? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpICA", "ptr", pszStr1, "ptr", pszStr2, "int")
        return result
    }

    /**
     * Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * It is strongly recommended that you use <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> in place of this function. <b>StrCmpIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with double-byte character set (DBCS) data.
     * 
     * Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the converted values.  This function returns the difference in value of the first unequal characters it encounters, or zero if they are all equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpIC</b> determines that "abczb" is greater than "abcdefg" and returns z - d.
     * 
     * For those versions of Windows that do not include <b>StrCmpIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpICA</b> is ordinal 157 and <b>StrCmpICW</b> is ordinal 158.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpicw
     * @since windows5.0
     */
    static StrCmpICW(pszStr1, pszStr2) {
        pszStr1 := pszStr1 is String? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpICW", "ptr", pszStr1, "ptr", pszStr2, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive. (ANSI)
     * @remarks
     * Note that <b>StrCmpNC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.
     * 
     * This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".
     * 
     * For those versions of Windows that do not include <b>StrCmpNC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNCA</b> is ordinal 151 and <b>StrCmpNCW</b> is ordinal 152.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Byte>} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpnca
     * @since windows5.0
     */
    static StrCmpNCA(pszStr1, pszStr2, nChar) {
        pszStr1 := pszStr1 is String? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpNCA", "ptr", pszStr1, "ptr", pszStr2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive. (Unicode)
     * @remarks
     * Note that <b>StrCmpNC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.
     * 
     * This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".
     * 
     * For those versions of Windows that do not include <b>StrCmpNC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNCA</b> is ordinal 151 and <b>StrCmpNCW</b> is ordinal 152.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpncw
     * @since windows5.0
     */
    static StrCmpNCW(pszStr1, pszStr2, nChar) {
        pszStr1 := pszStr1 is String? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpNCW", "ptr", pszStr1, "ptr", pszStr2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * Note that <b>StrCmpNIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.
     * 
     * This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNIC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".
     * 
     * For those versions of Windows that do not include <b>StrCmpNIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNICA</b> is ordinal 153 and <b>StrCmpNICW</b> is ordinal 154.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpNIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Byte>} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpnica
     * @since windows5.0
     */
    static StrCmpNICA(pszStr1, pszStr2, nChar) {
        pszStr1 := pszStr1 is String? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpNICA", "ptr", pszStr1, "ptr", pszStr2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * Note that <b>StrCmpNIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.
     * 
     * This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNIC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".
     * 
     * For those versions of Windows that do not include <b>StrCmpNIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNICA</b> is ordinal 153 and <b>StrCmpNICW</b> is ordinal 154.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines StrCmpNIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {Pointer<Char>} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-strcmpnicw
     * @since windows5.0
     */
    static StrCmpNICW(pszStr1, pszStr2, nChar) {
        pszStr1 := pszStr1 is String? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpNICW", "ptr", pszStr1, "ptr", pszStr2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two localized strings. (ANSI)
     * @remarks
     * This function retrieves the thread locale and uses <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> to determine whether the first <i>nChar</i> characters are identical.
     * @param {Integer} fCaseSens Type: <b>BOOL</b>
     * 
     * A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.
     * @param {Pointer<Byte>} lpString1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string.
     * @param {Pointer<Byte>} lpString2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters to be compared, starting from the beginning of the strings.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-intlstreqworkera
     * @since windows5.0
     */
    static IntlStrEqWorkerA(fCaseSens, lpString1, lpString2, nChar) {
        lpString1 := lpString1 is String? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String? StrPtr(lpString2) : lpString2

        result := DllCall("SHLWAPI.dll\IntlStrEqWorkerA", "int", fCaseSens, "ptr", lpString1, "ptr", lpString2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two localized strings. (Unicode)
     * @remarks
     * This function retrieves the thread locale and uses <a href="https://docs.microsoft.com/windows/desktop/api/stringapiset/nf-stringapiset-comparestringw">CompareString</a> to determine whether the first <i>nChar</i> characters are identical.
     * @param {Integer} fCaseSens Type: <b>BOOL</b>
     * 
     * A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.
     * @param {Pointer<Char>} lpString1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string.
     * @param {Pointer<Char>} lpString2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters to be compared, starting from the beginning of the strings.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-intlstreqworkerw
     * @since windows5.0
     */
    static IntlStrEqWorkerW(fCaseSens, lpString1, lpString2, nChar) {
        lpString1 := lpString1 is String? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String? StrPtr(lpString2) : lpString2

        result := DllCall("SHLWAPI.dll\IntlStrEqWorkerW", "int", fCaseSens, "ptr", lpString1, "ptr", lpString2, "int", nChar, "int")
        return result
    }

    /**
     * Adds a backslash to the end of a string to create the correct syntax for a path. (PathAddBackslashA)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathAddBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @returns {Pointer<Byte>} Type: <b>LPTSTR</b>
     * 
     * A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathaddbackslasha
     * @since windows5.0
     */
    static PathAddBackslashA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathAddBackslashA", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Adds a backslash to the end of a string to create the correct syntax for a path. (PathAddBackslashW)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathAddBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @returns {Pointer<Char>} Type: <b>LPTSTR</b>
     * 
     * A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathaddbackslashw
     * @since windows5.0
     */
    static PathAddBackslashW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathAddBackslashW", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Adds a file name extension to a path string. (ANSI)
     * @remarks
     * If there is already a file name extension present, no extension will be added. If the <i>pszPath</i> points to a <b>NULL</b> string, the result will be the file name extension only. If <i>pszExtension</i> points to a <b>NULL</b> string, an ".exe" extension will be added.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Byte>} pszExt Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathaddextensiona
     * @since windows5.0
     */
    static PathAddExtensionA(pszPath, pszExt) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\PathAddExtensionA", "ptr", pszPath, "ptr", pszExt, "int")
        return result
    }

    /**
     * Adds a file name extension to a path string. (Unicode)
     * @remarks
     * If there is already a file name extension present, no extension will be added. If the <i>pszPath</i> points to a <b>NULL</b> string, the result will be the file name extension only. If <i>pszExtension</i> points to a <b>NULL</b> string, an ".exe" extension will be added.
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Char>} pszExt Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathaddextensionw
     * @since windows5.0
     */
    static PathAddExtensionW(pszPath, pszExt) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\PathAddExtensionW", "ptr", pszPath, "ptr", pszExt, "int")
        return result
    }

    /**
     * Appends one path to the end of another. (ANSI)
     * @remarks
     * This function automatically inserts a backslash between the two strings, if one is not already present.
     * 
     * The path supplied in <i>pszPath</i> cannot begin with "..\\" or ".\\" to produce a relative path string. If present, those periods are stripped from the output string. For example, appending "path3" to "..\\path1\\path2" results in an output of "\path1\path2\path3" rather than "..\path1\path2\path3".
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Byte>} pszMore Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathappenda
     * @since windows5.0
     */
    static PathAppendA(pszPath, pszMore) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszMore := pszMore is String? StrPtr(pszMore) : pszMore

        result := DllCall("SHLWAPI.dll\PathAppendA", "ptr", pszPath, "ptr", pszMore, "int")
        return result
    }

    /**
     * Appends one path to the end of another. (Unicode)
     * @remarks
     * This function automatically inserts a backslash between the two strings, if one is not already present.
     * 
     * The path supplied in <i>pszPath</i> cannot begin with "..\\" or ".\\" to produce a relative path string. If present, those periods are stripped from the output string. For example, appending "path3" to "..\\path1\\path2" results in an output of "\path1\path2\path3" rather than "..\path1\path2\path3".
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Char>} pszMore Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathappendw
     * @since windows5.0
     */
    static PathAppendW(pszPath, pszMore) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszMore := pszMore is String? StrPtr(pszMore) : pszMore

        result := DllCall("SHLWAPI.dll\PathAppendW", "ptr", pszPath, "ptr", pszMore, "int")
        return result
    }

    /**
     * Creates a root path from a given drive number. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathBuildRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszRoot Type: <b>LPTSTR</b>
     * 
     * A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.
     * @returns {Pointer<Byte>} Type: <b>LPTSTR</b>
     * 
     * Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathbuildroota
     * @since windows5.0
     */
    static PathBuildRootA(pszRoot, iDrive) {
        pszRoot := pszRoot is String? StrPtr(pszRoot) : pszRoot

        result := DllCall("SHLWAPI.dll\PathBuildRootA", "ptr", pszRoot, "int", iDrive, "char*")
        return result
    }

    /**
     * Creates a root path from a given drive number. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathBuildRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszRoot Type: <b>LPTSTR</b>
     * 
     * A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.
     * @returns {Pointer<Char>} Type: <b>LPTSTR</b>
     * 
     * Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathbuildrootw
     * @since windows5.0
     */
    static PathBuildRootW(pszRoot, iDrive) {
        pszRoot := pszRoot is String? StrPtr(pszRoot) : pszRoot

        result := DllCall("SHLWAPI.dll\PathBuildRootW", "ptr", pszRoot, "int", iDrive, "char*")
        return result
    }

    /**
     * Simplifies a path by removing navigation elements such as &quot;.&quot; and &quot;..&quot; to produce a direct, well-formed path. (ANSI)
     * @remarks
     * This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.
     * 
     * If there are more ".." sequences than there are path segments, the function returns <b>TRUE</b> and contents of the buffer pointed to by <i>lpszDst</i> contains just the root, "\".
     * @param {Pointer<Byte>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcanonicalizea
     * @since windows5.0
     */
    static PathCanonicalizeA(pszBuf, pszPath) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\PathCanonicalizeA", "ptr", pszBuf, "ptr", pszPath, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Simplifies a path by removing navigation elements such as &quot;.&quot; and &quot;..&quot; to produce a direct, well-formed path. (Unicode)
     * @remarks
     * This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.
     * 
     * If there are more ".." sequences than there are path segments, the function returns <b>TRUE</b> and contents of the buffer pointed to by <i>lpszDst</i> contains just the root, "\".
     * @param {Pointer<Char>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcanonicalizew
     * @since windows5.0
     */
    static PathCanonicalizeW(pszBuf, pszPath) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\PathCanonicalizeW", "ptr", pszBuf, "ptr", pszPath, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements. (ANSI)
     * @remarks
     * The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while <i>lpszDir</i> and <i>lpszFile</i> are both optional parameters, they cannot both be <b>NULL</b>.
     * @param {Pointer<Byte>} pszDest Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Byte>} pszDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.
     * @param {Pointer<Byte>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.
     * @returns {Pointer<Byte>} Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcombinea
     * @since windows5.0
     */
    static PathCombineA(pszDest, pszDir, pszFile) {
        pszDest := pszDest is String? StrPtr(pszDest) : pszDest
        pszDir := pszDir is String? StrPtr(pszDir) : pszDir
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\PathCombineA", "ptr", pszDest, "ptr", pszDir, "ptr", pszFile, "char*")
        return result
    }

    /**
     * Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements. (Unicode)
     * @remarks
     * The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while <i>lpszDir</i> and <i>lpszFile</i> are both optional parameters, they cannot both be <b>NULL</b>.
     * @param {Pointer<Char>} pszDest Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Char>} pszDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.
     * @returns {Pointer<Char>} Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcombinew
     * @since windows5.0
     */
    static PathCombineW(pszDest, pszDir, pszFile) {
        pszDest := pszDest is String? StrPtr(pszDest) : pszDest
        pszDir := pszDir is String? StrPtr(pszDir) : pszDir
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\PathCombineW", "ptr", pszDest, "ptr", pszDir, "ptr", pszFile, "char*")
        return result
    }

    /**
     * Truncates a file path to fit within a given pixel width by replacing path components with ellipses. (ANSI)
     * @remarks
     * This function uses the font currently selected in <i>hDC</i> to calculate the width of the text. This function will not compact the path beyond the base file name preceded by ellipses.
     * @param {Pointer<Void>} hDC Type: <b>HDC</b>
     * 
     * A handle to the device context used for font metrics. This value can be <b>NULL</b>.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.
     * @param {Integer} dx Type: <b>UINT</b>
     * 
     * The width, in pixels, in which the string must fit.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcompactpatha
     * @since windows5.0
     */
    static PathCompactPathA(hDC, pszPath, dx) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathCompactPathA", "ptr", hDC, "ptr", pszPath, "uint", dx, "int")
        return result
    }

    /**
     * Truncates a file path to fit within a given pixel width by replacing path components with ellipses. (Unicode)
     * @remarks
     * This function uses the font currently selected in <i>hDC</i> to calculate the width of the text. This function will not compact the path beyond the base file name preceded by ellipses.
     * @param {Pointer<Void>} hDC Type: <b>HDC</b>
     * 
     * A handle to the device context used for font metrics. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.
     * @param {Integer} dx Type: <b>UINT</b>
     * 
     * The width, in pixels, in which the string must fit.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcompactpathw
     * @since windows5.0
     */
    static PathCompactPathW(hDC, pszPath, dx) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathCompactPathW", "ptr", hDC, "ptr", pszPath, "uint", dx, "int")
        return result
    }

    /**
     * Truncates a path to fit within a certain number of characters by replacing path components with ellipses. (ANSI)
     * @remarks
     * The '/' separator will be used instead of '\' if the original string used it. If <i>pszSrc</i> points to a file name that is too long, instead of a path, the file name will be truncated to <i>cchMax</i> characters, including the ellipsis and the terminating <b>NULL</b> character. For example, if the input file name is "My Filename" and <i>cchMax</i> is 10, <b>PathCompactPathEx</b> will return "My Fil...".
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathCompactPathEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszOut Type: <b>LPTSTR</b>
     * 
     * The address of the string that has been altered.
     * @param {Pointer<Byte>} pszSrc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcompactpathexa
     * @since windows5.0
     */
    static PathCompactPathExA(pszOut, pszSrc, cchMax, dwFlags) {
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\PathCompactPathExA", "ptr", pszOut, "ptr", pszSrc, "uint", cchMax, "uint", dwFlags, "int")
        return result
    }

    /**
     * Truncates a path to fit within a certain number of characters by replacing path components with ellipses. (Unicode)
     * @remarks
     * The '/' separator will be used instead of '\\' if the original string used it. If <i>pszSrc</i> points to a file name that is too long, instead of a path, the file name will be truncated to <i>cchMax</i> characters, including the ellipsis and the terminating <b>NULL</b> character. For example, if the input file name is "My Filename" and <i>cchMax</i> is 10, <b>PathCompactPathEx</b> will return "My Fil...".
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathCompactPathEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszOut Type: <b>LPTSTR</b>
     * 
     * The address of the string that has been altered.
     * @param {Pointer<Char>} pszSrc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcompactpathexw
     * @since windows5.0
     */
    static PathCompactPathExW(pszOut, pszSrc, cchMax, dwFlags) {
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\PathCompactPathExW", "ptr", pszOut, "ptr", pszSrc, "uint", cchMax, "uint", dwFlags, "int")
        return result
    }

    /**
     * Compares two paths to determine if they share a common prefix. A prefix is one of these types:\_&quot;C:\\&quot;, &quot;.&quot;, &quot;..&quot;, &quot;..\\&quot;. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathCommonPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszFile1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the first path name.
     * @param {Pointer<Byte>} pszFile2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the second path name.
     * @param {Pointer<Byte>} achPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcommonprefixa
     * @since windows5.0
     */
    static PathCommonPrefixA(pszFile1, pszFile2, achPath) {
        pszFile1 := pszFile1 is String? StrPtr(pszFile1) : pszFile1
        pszFile2 := pszFile2 is String? StrPtr(pszFile2) : pszFile2
        achPath := achPath is String? StrPtr(achPath) : achPath

        result := DllCall("SHLWAPI.dll\PathCommonPrefixA", "ptr", pszFile1, "ptr", pszFile2, "ptr", achPath, "int")
        return result
    }

    /**
     * Compares two paths to determine if they share a common prefix. A prefix is one of these types:\_&quot;C:\\&quot;, &quot;.&quot;, &quot;..&quot;, &quot;..\\&quot;. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathCommonPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszFile1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the first path name.
     * @param {Pointer<Char>} pszFile2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the second path name.
     * @param {Pointer<Char>} achPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcommonprefixw
     * @since windows5.0
     */
    static PathCommonPrefixW(pszFile1, pszFile2, achPath) {
        pszFile1 := pszFile1 is String? StrPtr(pszFile1) : pszFile1
        pszFile2 := pszFile2 is String? StrPtr(pszFile2) : pszFile2
        achPath := achPath is String? StrPtr(achPath) : achPath

        result := DllCall("SHLWAPI.dll\PathCommonPrefixW", "ptr", pszFile1, "ptr", pszFile2, "ptr", achPath, "int")
        return result
    }

    /**
     * Determines whether a path to a file system object such as a file or folder is valid. (ANSI)
     * @remarks
     * This function tests the validity of the path.
     * 
     * A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \\server\share\file is permitted. A UNC path to a server or server share is not permitted; that is, \\server or \\server\share. This function returns <b>FALSE</b> if a mounted remote drive is out of service.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfileexistsa
     * @since windows5.0
     */
    static PathFileExistsA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\PathFileExistsA", "ptr", pszPath, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a path to a file system object such as a file or folder is valid. (Unicode)
     * @remarks
     * This function tests the validity of the path.
     * 
     * A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \\server\share\file is permitted. A UNC path to a server or server share is not permitted; that is, \\server or \\server\share. This function returns <b>FALSE</b> if a mounted remote drive is out of service.
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information. If the file does not exist, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <a href="https://docs.microsoft.com/windows/win32/debug/system-error-codes--0-499-">ERROR_FILE_NOT_FOUND</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfileexistsw
     * @since windows5.0
     */
    static PathFileExistsW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\PathFileExistsW", "ptr", pszPath, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches a path for an extension. (ANSI)
     * @remarks
     * Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-extensions">File Type Handlers</a>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathFindExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindextensiona
     * @since windows5.0
     */
    static PathFindExtensionA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindExtensionA", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Searches a path for an extension. (Unicode)
     * @remarks
     * Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-extensions">File Type Handlers</a>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathFindExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindextensionw
     * @since windows5.0
     */
    static PathFindExtensionW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindExtensionW", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Searches a path for a file name. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathFindFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindfilenamea
     * @since windows5.0
     */
    static PathFindFileNameA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindFileNameA", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Searches a path for a file name. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathFindFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindfilenamew
     * @since windows5.0
     */
    static PathFindFileNameW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindFileNameW", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Parses a path and returns the portion of that path that follows the first backslash. (ANSI)
     * @remarks
     * <b>PathFindNextComponent</b>  walks a path string until it encounters a backslash ("\\"), ignores everything up to that point including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2), the function simply removes the initial backslash and returns the rest (path1\path2).
     * @param {Pointer<Byte>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to a null-terminated string that contains the truncated path.
     * 
     * If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.
     * 
     * If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindnextcomponenta
     * @since windows5.0
     */
    static PathFindNextComponentA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindNextComponentA", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Parses a path and returns the portion of that path that follows the first backslash. (Unicode)
     * @remarks
     * <b>PathFindNextComponent</b>  walks a path string until it encounters a backslash ("\\"), ignores everything up to that point including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2), the function simply removes the initial backslash and returns the rest (path1\path2).
     * @param {Pointer<Char>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to a null-terminated string that contains the truncated path.
     * 
     * If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.
     * 
     * If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindnextcomponentw
     * @since windows5.0
     */
    static PathFindNextComponentW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindNextComponentW", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Searches for a file. (ANSI)
     * @remarks
     * <b>PathFindOnPath</b> searches for the file specified by <i>pszFile</i>. If no directories are specified in <i>ppszOtherDirs</i>, it attempts to find the file by searching standard directories such as System32 and the directories specified in the PATH environment variable. To expedite the process or enable <b>PathFindOnPath</b> to search a wider range of directories, use the <i>ppszOtherDirs</i> parameter to specify one or more directories to be searched first. If more than one file has the name specified by <i>pszFile</i>, <b>PathFindOnPath</b> returns the first instance it finds.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathFindOnPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.
     * @param {Pointer<SByte>} ppszOtherDirs Type: <b>LPCTSTR*</b>
     * 
     * An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindonpatha
     * @since windows5.0
     */
    static PathFindOnPathA(pszPath, ppszOtherDirs) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindOnPathA", "ptr", pszPath, "ptr", ppszOtherDirs, "int")
        return result
    }

    /**
     * Searches for a file. (Unicode)
     * @remarks
     * <b>PathFindOnPath</b> searches for the file specified by <i>pszFile</i>. If no directories are specified in <i>ppszOtherDirs</i>, it attempts to find the file by searching standard directories such as System32 and the directories specified in the PATH environment variable. To expedite the process or enable <b>PathFindOnPath</b> to search a wider range of directories, use the <i>ppszOtherDirs</i> parameter to specify one or more directories to be searched first. If more than one file has the name specified by <i>pszFile</i>, <b>PathFindOnPath</b> returns the first instance it finds.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathFindOnPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.
     * @param {Pointer<UInt16>} ppszOtherDirs Type: <b>LPCTSTR*</b>
     * 
     * An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindonpathw
     * @since windows5.0
     */
    static PathFindOnPathW(pszPath, ppszOtherDirs) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindOnPathW", "ptr", pszPath, "ptr", ppszOtherDirs, "int")
        return result
    }

    /**
     * Determines whether a given file name has one of a list of suffixes. (ANSI)
     * @remarks
     * This function uses a case-sensitive comparison. The suffix must match exactly.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathFindSuffixArray as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.
     * @param {Pointer<Byte>} apszSuffix Type: <b>const LPCTSTR*</b>
     * 
     * An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.
     * @param {Integer} iArraySize Type: <b>int</b>
     * 
     * The number of elements in the array pointed to by <i>apszSuffix</i>.
     * @returns {Pointer<Byte>} Type: <b>LPCTSTR</b>
     * 
     * Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindsuffixarraya
     * @since windows5.0
     */
    static PathFindSuffixArrayA(pszPath, apszSuffix, iArraySize) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindSuffixArrayA", "ptr", pszPath, "ptr", apszSuffix, "int", iArraySize, "char*")
        return result
    }

    /**
     * Determines whether a given file name has one of a list of suffixes. (Unicode)
     * @remarks
     * This function uses a case-sensitive comparison. The suffix must match exactly.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathFindSuffixArray as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.
     * @param {Pointer<Char>} apszSuffix Type: <b>const LPCTSTR*</b>
     * 
     * An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.
     * @param {Integer} iArraySize Type: <b>int</b>
     * 
     * The number of elements in the array pointed to by <i>apszSuffix</i>.
     * @returns {Pointer<Char>} Type: <b>LPCTSTR</b>
     * 
     * Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathfindsuffixarrayw
     * @since windows5.0
     */
    static PathFindSuffixArrayW(pszPath, apszSuffix, iArraySize) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindSuffixArrayW", "ptr", pszPath, "ptr", apszSuffix, "int", iArraySize, "char*")
        return result
    }

    /**
     * Finds the command line arguments within a given path. (ANSI)
     * @remarks
     * This function should not be used on generic command path templates (from users or the registry), but rather should be used only on templates that the application knows to be well formed.
     * @param {Pointer<Byte>} pszPath Type: <b>PTSTR</b>
     * 
     * Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful. 
     * 
     *                     
     * 
     * If there are no arguments in the path, the function returns a pointer to the end of the input string.
     * 
     * If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathgetargsa
     * @since windows5.0
     */
    static PathGetArgsA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathGetArgsA", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Finds the command line arguments within a given path. (Unicode)
     * @remarks
     * This function should not be used on generic command path templates (from users or the registry), but rather should be used only on templates that the application knows to be well formed.
     * @param {Pointer<Char>} pszPath Type: <b>PTSTR</b>
     * 
     * Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful. 
     * 
     *                     
     * 
     * If there are no arguments in the path, the function returns a pointer to the end of the input string.
     * 
     * If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathgetargsw
     * @since windows5.0
     */
    static PathGetArgsW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathGetArgsW", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Determines whether a file name is in long format. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsLFNFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszName Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathislfnfilespeca
     * @since windows5.0
     */
    static PathIsLFNFileSpecA(pszName) {
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHLWAPI.dll\PathIsLFNFileSpecA", "ptr", pszName, "int")
        return result
    }

    /**
     * Determines whether a file name is in long format. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsLFNFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszName Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathislfnfilespecw
     * @since windows5.0
     */
    static PathIsLFNFileSpecW(pszName) {
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHLWAPI.dll\PathIsLFNFileSpecW", "ptr", pszName, "int")
        return result
    }

    /**
     * Determines the type of character in relation to a path. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathGetCharType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TUCHAR</b>
     * 
     * The character for which to determine the type.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * Returns one or more of the following values that define the type of character.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_INVALID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is not valid in a path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_LFNCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is valid in a long file name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_SEPARATOR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is a path separator.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_SHORTCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is valid in a short (8.3) file name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_WILD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is a wildcard character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathgetchartypea
     * @since windows5.0
     */
    static PathGetCharTypeA(ch) {
        result := DllCall("SHLWAPI.dll\PathGetCharTypeA", "char", ch, "uint")
        return result
    }

    /**
     * Determines the type of character in relation to a path. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathGetCharType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TUCHAR</b>
     * 
     * The character for which to determine the type.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * Returns one or more of the following values that define the type of character.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_INVALID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is not valid in a path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_LFNCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is valid in a long file name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_SEPARATOR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is a path separator.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_SHORTCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is valid in a short (8.3) file name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_WILD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is a wildcard character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathgetchartypew
     * @since windows5.0
     */
    static PathGetCharTypeW(ch) {
        result := DllCall("SHLWAPI.dll\PathGetCharTypeW", "char", ch, "uint")
        return result
    }

    /**
     * Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathGetDriveNumber as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathgetdrivenumbera
     * @since windows5.0
     */
    static PathGetDriveNumberA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathGetDriveNumberA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathGetDriveNumber as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathgetdrivenumberw
     * @since windows5.0
     */
    static PathGetDriveNumberW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathGetDriveNumberW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Verifies that a path is a valid directory. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisdirectorya
     * @since windows5.0
     */
    static PathIsDirectoryA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsDirectoryA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Verifies that a path is a valid directory. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisdirectoryw
     * @since windows5.0
     */
    static PathIsDirectoryW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsDirectoryW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a specified path is an empty directory. (ANSI)
     * @remarks
     * "C:\" is considered a directory.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsDirectoryEmpty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisdirectoryemptya
     * @since windows5.0
     */
    static PathIsDirectoryEmptyA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsDirectoryEmptyA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a specified path is an empty directory. (Unicode)
     * @remarks
     * "C:\" is considered a directory.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsDirectoryEmpty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisdirectoryemptyw
     * @since windows5.0
     */
    static PathIsDirectoryEmptyW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsDirectoryEmptyW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path for any path-delimiting characters (for example, ':' or '\' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisfilespeca
     * @since windows5.0
     */
    static PathIsFileSpecA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsFileSpecA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path for any path-delimiting characters (for example, ':' or '\\' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisfilespecw
     * @since windows5.0
     */
    static PathIsFileSpecW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsFileSpecW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Examines a path to determine if it starts with a prefix value passed by pszPrefix. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPrefix Type: <b>IN LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix to match.
     * @param {Pointer<Byte>} pszPath Type: <b>IN LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be examined.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> starts with <i>pszPrefix</i>, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisprefixa
     * @since windows5.0
     */
    static PathIsPrefixA(pszPrefix, pszPath) {
        pszPrefix := pszPrefix is String? StrPtr(pszPrefix) : pszPrefix
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsPrefixA", "ptr", pszPrefix, "ptr", pszPath, "int")
        return result
    }

    /**
     * Examines a path to determine if it starts with a prefix value passed by pszPrefix. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPrefix Type: <b>IN LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix to match.
     * @param {Pointer<Char>} pszPath Type: <b>IN LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be examined.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> starts with <i>pszPrefix</i>, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisprefixw
     * @since windows5.0
     */
    static PathIsPrefixW(pszPrefix, pszPath) {
        pszPrefix := pszPrefix is String? StrPtr(pszPrefix) : pszPrefix
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsPrefixW", "ptr", pszPrefix, "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path and determines if it is relative. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsRelative as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisrelativea
     * @since windows5.0
     */
    static PathIsRelativeA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsRelativeA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path and determines if it is relative. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsRelative as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisrelativew
     * @since windows5.0
     */
    static PathIsRelativeW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsRelativeW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a path string refers to the root of a volume. (ANSI)
     * @remarks
     * Returns <b>TRUE</b> for paths such as "\", "<i>X</i>:\" or "&#92;&#92;<i>server</i>&#92;<i>share</i>". Paths such as "..\path2" or "&#92;&#92;<i>server</i>\" return <b>FALSE</b>.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisroota
     * @since windows5.0
     */
    static PathIsRootA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsRootA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a path string refers to the root of a volume. (Unicode)
     * @remarks
     * Returns <b>TRUE</b> for paths such as "\", "<i>X</i>:\" or "&#92;&#92;<i>server</i>&#92;<i>share</i>". Paths such as "..\path2" or "&#92;&#92;<i>server</i>\" return <b>FALSE</b>.
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisrootw
     * @since windows5.0
     */
    static PathIsRootW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsRootW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Compares two paths to determine if they have a common root component. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsSameRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.
     * @param {Pointer<Byte>} pszPath2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathissameroota
     * @since windows5.0
     */
    static PathIsSameRootA(pszPath1, pszPath2) {
        pszPath1 := pszPath1 is String? StrPtr(pszPath1) : pszPath1
        pszPath2 := pszPath2 is String? StrPtr(pszPath2) : pszPath2

        result := DllCall("SHLWAPI.dll\PathIsSameRootA", "ptr", pszPath1, "ptr", pszPath2, "int")
        return result
    }

    /**
     * Compares two paths to determine if they have a common root component. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsSameRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.
     * @param {Pointer<Char>} pszPath2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathissamerootw
     * @since windows5.0
     */
    static PathIsSameRootW(pszPath1, pszPath2) {
        pszPath1 := pszPath1 is String? StrPtr(pszPath1) : pszPath1
        pszPath2 := pszPath2 is String? StrPtr(pszPath2) : pszPath2

        result := DllCall("SHLWAPI.dll\PathIsSameRootW", "ptr", pszPath1, "ptr", pszPath2, "int")
        return result
    }

    /**
     * Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsUNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisunca
     * @since windows5.0
     */
    static PathIsUNCA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsUNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisuncw
     * @since windows5.0
     */
    static PathIsUNCW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a path string represents a network resource. (ANSI)
     * @remarks
     * <b>PathIsNetworkPath</b> interprets the following two types of paths as network paths.
     * 
     * <ul>
     * <li>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</li>
     * <li>Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However, <b>PathIsNetworkPath</b> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-definedosdevicew">DefineDosDevice</a> function.</li>
     * </ul>
     * <div class="alert"><b>Note</b>The function does not verify that the specified network resource exists, is currently accessible, or that the user has sufficient permissions to access it.</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsNetworkPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisnetworkpatha
     * @since windows5.0
     */
    static PathIsNetworkPathA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsNetworkPathA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a path string represents a network resource. (Unicode)
     * @remarks
     * <b>PathIsNetworkPath</b> interprets the following two types of paths as network paths.
     * 
     * <ul>
     * <li>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</li>
     * <li>Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However, <b>PathIsNetworkPath</b> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-definedosdevicew">DefineDosDevice</a> function.</li>
     * </ul>
     * <div class="alert"><b>Note</b>The function does not verify that the specified network resource exists, is currently accessible, or that the user has sufficient permissions to access it.</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsNetworkPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisnetworkpathw
     * @since windows5.0
     */
    static PathIsNetworkPathW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsNetworkPathW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a string is a valid Universal Naming Convention (UNC) for a server path only. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsUNCServer as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisuncservera
     * @since windows5.0
     */
    static PathIsUNCServerA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCServerA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a string is a valid Universal Naming Convention (UNC) for a server path only. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsUNCServer as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisuncserverw
     * @since windows5.0
     */
    static PathIsUNCServerW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCServerW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a string is a valid Universal Naming Convention (UNC) share path, \\server\share. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsUNCServerShare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is in the form &#92;&#92;<i>server</i>&#92;<i>share</i>, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisuncserversharea
     * @since windows5.0
     */
    static PathIsUNCServerShareA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCServerShareA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a string is a valid Universal Naming Convention (UNC) share path, \\server\share. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsUNCServerShare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is in the form &#92;&#92;<i>server</i>&#92;<i>share</i>, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisuncserversharew
     * @since windows5.0
     */
    static PathIsUNCServerShareW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCServerShareW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the pszContentType. The comparison is not case-sensitive. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsContentType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.
     * @param {Pointer<Byte>} pszContentType Type: <b>LPCTSTR</b>
     * 
     * The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathiscontenttypea
     * @since windows5.0
     */
    static PathIsContentTypeA(pszPath, pszContentType) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszContentType := pszContentType is String? StrPtr(pszContentType) : pszContentType

        result := DllCall("SHLWAPI.dll\PathIsContentTypeA", "ptr", pszPath, "ptr", pszContentType, "int")
        return result
    }

    /**
     * Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the pszContentType. The comparison is not case-sensitive. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsContentType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.
     * @param {Pointer<Char>} pszContentType Type: <b>LPCTSTR</b>
     * 
     * The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathiscontenttypew
     * @since windows5.0
     */
    static PathIsContentTypeW(pszPath, pszContentType) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszContentType := pszContentType is String? StrPtr(pszContentType) : pszContentType

        result := DllCall("SHLWAPI.dll\PathIsContentTypeW", "ptr", pszPath, "ptr", pszContentType, "int")
        return result
    }

    /**
     * Tests a given string to determine if it conforms to a valid URL format. (ANSI)
     * @remarks
     * This function does not verify that the path points to an existing siteonly that it has a valid URL format.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisurla
     * @since windows5.0
     */
    static PathIsURLA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsURLA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Tests a given string to determine if it conforms to a valid URL format. (Unicode)
     * @remarks
     * This function does not verify that the path points to an existing siteonly that it has a valid URL format.
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathisurlw
     * @since windows5.0
     */
    static PathIsURLW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsURLW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance. (ANSI)
     * @remarks
     * This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but c:\Windows will not be changed.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathmakeprettya
     * @since windows5.0
     */
    static PathMakePrettyA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathMakePrettyA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance. (Unicode)
     * @remarks
     * This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but c:\Windows will not be changed.
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathmakeprettyw
     * @since windows5.0
     */
    static PathMakePrettyW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathMakePrettyW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a string using a Microsoft MS-DOS wildcard match type. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathMatchSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszFile Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to be searched.
     * @param {Pointer<Byte>} pszSpec Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathmatchspeca
     * @since windows5.0
     */
    static PathMatchSpecA(pszFile, pszSpec) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile
        pszSpec := pszSpec is String? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHLWAPI.dll\PathMatchSpecA", "ptr", pszFile, "ptr", pszSpec, "int")
        return result
    }

    /**
     * Searches a string using a Microsoft MS-DOS wildcard match type. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathMatchSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszFile Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to be searched.
     * @param {Pointer<Char>} pszSpec Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathmatchspecw
     * @since windows5.0
     */
    static PathMatchSpecW(pszFile, pszSpec) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile
        pszSpec := pszSpec is String? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHLWAPI.dll\PathMatchSpecW", "ptr", pszFile, "ptr", pszSpec, "int")
        return result
    }

    /**
     * Matches a file name from a path against one or more file name patterns. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathMatchSpecEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.
     * @param {Pointer<Byte>} pszSpec Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Modifies the search condition. The following are valid flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathmatchspecexa
     * @since windows6.0.6000
     */
    static PathMatchSpecExA(pszFile, pszSpec, dwFlags) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile
        pszSpec := pszSpec is String? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHLWAPI.dll\PathMatchSpecExA", "ptr", pszFile, "ptr", pszSpec, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Matches a file name from a path against one or more file name patterns. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathMatchSpecEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.
     * @param {Pointer<Char>} pszSpec Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Modifies the search condition. The following are valid flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathmatchspecexw
     * @since windows6.0.6000
     */
    static PathMatchSpecExW(pszFile, pszSpec, dwFlags) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile
        pszSpec := pszSpec is String? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHLWAPI.dll\PathMatchSpecExW", "ptr", pszFile, "ptr", pszSpec, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Parses a file location string that contains a file location and icon index, and returns separate values. (ANSI)
     * @remarks
     * This function is useful for taking a DefaultIcon value retrieved from the registry by <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shgetvaluea">SHGetValue</a> and separating the icon index from the path.
     * @param {Pointer<Byte>} pszIconFile Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the valid icon index value.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathparseiconlocationa
     * @since windows5.0
     */
    static PathParseIconLocationA(pszIconFile) {
        pszIconFile := pszIconFile is String? StrPtr(pszIconFile) : pszIconFile

        result := DllCall("SHLWAPI.dll\PathParseIconLocationA", "ptr", pszIconFile, "int")
        return result
    }

    /**
     * Parses a file location string that contains a file location and icon index, and returns separate values. (Unicode)
     * @remarks
     * This function is useful for taking a DefaultIcon value retrieved from the registry by <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shgetvaluea">SHGetValue</a> and separating the icon index from the path.
     * @param {Pointer<Char>} pszIconFile Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the valid icon index value.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathparseiconlocationw
     * @since windows5.0
     */
    static PathParseIconLocationW(pszIconFile) {
        pszIconFile := pszIconFile is String? StrPtr(pszIconFile) : pszIconFile

        result := DllCall("SHLWAPI.dll\PathParseIconLocationW", "ptr", pszIconFile, "int")
        return result
    }

    /**
     * Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathQuoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpsz Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathquotespacesa
     * @since windows5.0
     */
    static PathQuoteSpacesA(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("SHLWAPI.dll\PathQuoteSpacesA", "ptr", lpsz, "int")
        return result
    }

    /**
     * Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathQuoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpsz Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathquotespacesw
     * @since windows5.0
     */
    static PathQuoteSpacesW(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("SHLWAPI.dll\PathQuoteSpacesW", "ptr", lpsz, "int")
        return result
    }

    /**
     * Creates a relative path from one file or folder to another. (ANSI)
     * @remarks
     * This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully qualified, but they must have a common prefix, or the function will fail and return <b>FALSE</b>.
     * 
     * For example, let the starting point, <i>pszFrom</i>, be "c:\FolderA\FolderB\FolderC", and the ending point, <i>pszTo</i>, be "c:\FolderA\FolderD\FolderE". <b>PathRelativePathTo</b> will return the relative path from <i>pszFrom</i> to <i>pszTo</i> as: "..\..\FolderD\FolderE". You will get the same result if you set <i>pszFrom</i> to "\FolderA\FolderB\FolderC" and <i>pszTo</i> to "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the function will fail. Note that "\\" is not considered a prefix and is ignored. If you set <i>pszFrom</i> to "\\FolderA\FolderB", and <i>pszTo</i> to "\\FolderC\FolderD", the function will fail.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.
     * @param {Pointer<Byte>} pszFrom Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.
     * @param {Integer} dwAttrFrom Type: <b>DWORD</b>
     * 
     * The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.
     * @param {Pointer<Byte>} pszTo Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.
     * @param {Integer} dwAttrTo Type: <b>DWORD</b>
     * 
     * The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathrelativepathtoa
     * @since windows5.0
     */
    static PathRelativePathToA(pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszFrom := pszFrom is String? StrPtr(pszFrom) : pszFrom
        pszTo := pszTo is String? StrPtr(pszTo) : pszTo

        result := DllCall("SHLWAPI.dll\PathRelativePathToA", "ptr", pszPath, "ptr", pszFrom, "uint", dwAttrFrom, "ptr", pszTo, "uint", dwAttrTo, "int")
        return result
    }

    /**
     * Creates a relative path from one file or folder to another. (Unicode)
     * @remarks
     * This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully qualified, but they must have a common prefix, or the function will fail and return <b>FALSE</b>.
     * 
     * For example, let the starting point, <i>pszFrom</i>, be "c:\FolderA\FolderB\FolderC", and the ending point, <i>pszTo</i>, be "c:\FolderA\FolderD\FolderE". <b>PathRelativePathTo</b> will return the relative path from <i>pszFrom</i> to <i>pszTo</i> as: "..\..\FolderD\FolderE". You will get the same result if you set <i>pszFrom</i> to "\FolderA\FolderB\FolderC" and <i>pszTo</i> to "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the function will fail. Note that "\\" is not considered a prefix and is ignored. If you set <i>pszFrom</i> to "\\FolderA\FolderB", and <i>pszTo</i> to "\\FolderC\FolderD", the function will fail.
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.
     * @param {Pointer<Char>} pszFrom Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.
     * @param {Integer} dwAttrFrom Type: <b>DWORD</b>
     * 
     * The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.
     * @param {Pointer<Char>} pszTo Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.
     * @param {Integer} dwAttrTo Type: <b>DWORD</b>
     * 
     * The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathrelativepathtow
     * @since windows5.0
     */
    static PathRelativePathToW(pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszFrom := pszFrom is String? StrPtr(pszFrom) : pszFrom
        pszTo := pszTo is String? StrPtr(pszTo) : pszTo

        result := DllCall("SHLWAPI.dll\PathRelativePathToW", "ptr", pszPath, "ptr", pszFrom, "uint", dwAttrFrom, "ptr", pszTo, "uint", dwAttrTo, "int")
        return result
    }

    /**
     * Removes any arguments from a given path. (ANSI)
     * @remarks
     * This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremoveargsa
     * @since windows5.0
     */
    static PathRemoveArgsA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveArgsA", "ptr", pszPath)
    }

    /**
     * Removes any arguments from a given path. (Unicode)
     * @remarks
     * This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremoveargsw
     * @since windows5.0
     */
    static PathRemoveArgsW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveArgsW", "ptr", pszPath)
    }

    /**
     * Removes the trailing backslash from a given path. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.
     * @returns {Pointer<Byte>} Type: <b>LPTSTR</b>
     * 
     * A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremovebackslasha
     * @since windows5.0
     */
    static PathRemoveBackslashA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathRemoveBackslashA", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Removes the trailing backslash from a given path. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.
     * @returns {Pointer<Char>} Type: <b>LPTSTR</b>
     * 
     * A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremovebackslashw
     * @since windows5.0
     */
    static PathRemoveBackslashW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathRemoveBackslashW", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Removes all leading and trailing spaces from a string. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremoveblanksa
     * @since windows5.0
     */
    static PathRemoveBlanksA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveBlanksA", "ptr", pszPath)
    }

    /**
     * Removes all leading and trailing spaces from a string. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremoveblanksw
     * @since windows5.0
     */
    static PathRemoveBlanksW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveBlanksW", "ptr", pszPath)
    }

    /**
     * Removes the file name extension from a path, if one is present. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremoveextensiona
     * @since windows5.0
     */
    static PathRemoveExtensionA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveExtensionA", "ptr", pszPath)
    }

    /**
     * Removes the file name extension from a path, if one is present. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremoveextensionw
     * @since windows5.0
     */
    static PathRemoveExtensionW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveExtensionW", "ptr", pszPath)
    }

    /**
     * Removes the trailing file name and backslash from a path, if they are present. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if something was removed, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremovefilespeca
     * @since windows5.0
     */
    static PathRemoveFileSpecA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathRemoveFileSpecA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes the trailing file name and backslash from a path, if they are present. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if something was removed, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathremovefilespecw
     * @since windows5.0
     */
    static PathRemoveFileSpecW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathRemoveFileSpecW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRenameExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.
     * @param {Pointer<Byte>} pszExt Type: <b>LPCTSTR</b>
     * 
     * Pointer to a character buffer that contains a '.' character followed by the new extension.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathrenameextensiona
     * @since windows5.0
     */
    static PathRenameExtensionA(pszPath, pszExt) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\PathRenameExtensionA", "ptr", pszPath, "ptr", pszExt, "int")
        return result
    }

    /**
     * Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathRenameExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.
     * @param {Pointer<Char>} pszExt Type: <b>LPCTSTR</b>
     * 
     * Pointer to a character buffer that contains a '.' character followed by the new extension.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathrenameextensionw
     * @since windows5.0
     */
    static PathRenameExtensionW(pszPath, pszExt) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\PathRenameExtensionW", "ptr", pszPath, "ptr", pszExt, "int")
        return result
    }

    /**
     * Determines if a given path is correctly formatted and fully qualified. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathSearchAndQualify as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @param {Pointer<Byte>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathsearchandqualifya
     * @since windows5.0
     */
    static PathSearchAndQualifyA(pszPath, pszBuf, cchBuf) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\PathSearchAndQualifyA", "ptr", pszPath, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Determines if a given path is correctly formatted and fully qualified. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathSearchAndQualify as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @param {Pointer<Char>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathsearchandqualifyw
     * @since windows5.0
     */
    static PathSearchAndQualifyW(pszPath, pszBuf, cchBuf) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\PathSearchAndQualifyW", "ptr", pszPath, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Sets the text of a child control in a window or dialog box, using PathCompactPath to ensure the path fits in the control. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box or window.
     * @param {Integer} id Type: <b>int</b>
     * 
     * The identifier of the control.
     * @param {Pointer<Byte>} pszPath Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathsetdlgitempatha
     * @since windows5.0
     */
    static PathSetDlgItemPathA(hDlg, id, pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathSetDlgItemPathA", "ptr", hDlg, "int", id, "ptr", pszPath)
    }

    /**
     * Sets the text of a child control in a window or dialog box, using PathCompactPath to ensure the path fits in the control. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box or window.
     * @param {Integer} id Type: <b>int</b>
     * 
     * The identifier of the control.
     * @param {Pointer<Char>} pszPath Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathsetdlgitempathw
     * @since windows5.0
     */
    static PathSetDlgItemPathW(hDlg, id, pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathSetDlgItemPathW", "ptr", hDlg, "int", id, "ptr", pszPath)
    }

    /**
     * Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathSkipRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.
     * @returns {Pointer<Byte>} Type: <b>PTSTR</b>
     * 
     * A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathskiproota
     * @since windows5.0
     */
    static PathSkipRootA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathSkipRootA", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathSkipRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.
     * @returns {Pointer<Char>} Type: <b>PTSTR</b>
     * 
     * A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathskiprootw
     * @since windows5.0
     */
    static PathSkipRootW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathSkipRootW", "ptr", pszPath, "char*")
        return result
    }

    /**
     * Removes the path portion of a fully qualified path and file. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathstrippatha
     * @since windows5.0
     */
    static PathStripPathA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathStripPathA", "ptr", pszPath)
    }

    /**
     * Removes the path portion of a fully qualified path and file. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathstrippathw
     * @since windows5.0
     */
    static PathStripPathW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathStripPathW", "ptr", pszPath)
    }

    /**
     * Removes all file and directory elements in a path except for the root information. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathStripToRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathstriptoroota
     * @since windows5.0
     */
    static PathStripToRootA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathStripToRootA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes all file and directory elements in a path except for the root information. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathStripToRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathstriptorootw
     * @since windows5.0
     */
    static PathStripToRootW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathStripToRootW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes quotes from the beginning and end of a path. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathUnquoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpsz Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.
     * @returns {Integer} <b>TRUE</b> if the string gets unquoted; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathunquotespacesa
     * @since windows5.0
     */
    static PathUnquoteSpacesA(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("SHLWAPI.dll\PathUnquoteSpacesA", "ptr", lpsz, "int")
        return result
    }

    /**
     * Removes quotes from the beginning and end of a path. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathUnquoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpsz Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.
     * @returns {Integer} <b>TRUE</b> if the string gets unquoted; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathunquotespacesw
     * @since windows5.0
     */
    static PathUnquoteSpacesW(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("SHLWAPI.dll\PathUnquoteSpacesW", "ptr", lpsz, "int")
        return result
    }

    /**
     * Gives an existing folder the proper attributes to become a system folder. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathMakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathmakesystemfoldera
     * @since windows5.0
     */
    static PathMakeSystemFolderA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathMakeSystemFolderA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Gives an existing folder the proper attributes to become a system folder. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathMakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathmakesystemfolderw
     * @since windows5.0
     */
    static PathMakeSystemFolderW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathMakeSystemFolderW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathUnmakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathunmakesystemfoldera
     * @since windows5.0
     */
    static PathUnmakeSystemFolderA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathUnmakeSystemFolderA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathUnmakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathunmakesystemfolderw
     * @since windows5.0
     */
    static PathUnmakeSystemFolderW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathUnmakeSystemFolderW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.
     * @param {Integer} dwAttrb Type: <b>DWORD</b>
     * 
     * The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathissystemfoldera
     * @since windows5.0
     */
    static PathIsSystemFolderA(pszPath, dwAttrb) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsSystemFolderA", "ptr", pszPath, "uint", dwAttrb, "int")
        return result
    }

    /**
     * Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathIsSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.
     * @param {Integer} dwAttrb Type: <b>DWORD</b>
     * 
     * The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathissystemfolderw
     * @since windows5.0
     */
    static PathIsSystemFolderW(pszPath, dwAttrb) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsSystemFolderW", "ptr", pszPath, "uint", dwAttrb, "int")
        return result
    }

    /**
     * Removes the decoration from a path string. (ANSI)
     * @remarks
     * A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathundecoratea
     * @since windows5.0
     */
    static PathUndecorateA(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathUndecorateA", "ptr", pszPath)
    }

    /**
     * Removes the decoration from a path string. (Unicode)
     * @remarks
     * A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathundecoratew
     * @since windows5.0
     */
    static PathUndecorateW(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathUndecorateW", "ptr", pszPath)
    }

    /**
     * Replaces certain folder names in a fully qualified path with their associated environment string. (ANSI)
     * @remarks
     * The following folder paths are replaced by their equivalent environment string.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Folder</th>
     * <th>Environment String</th>
     * </tr>
     * <tr>
     * <td>The All Users profile folder</td>
     * <td>%ALLUSERSPROFILE%</td>
     * </tr>
     * <tr>
     * <td>The current user's application data folder (WindowsVista and later only).</td>
     * <td>%APPDATA%</td>
     * </tr>
     * <tr>
     * <td>The system name</td>
     * <td>%COMPUTERNAME%</td>
     * </tr>
     * <tr>
     * <td>The Program Files folder</td>
     * <td>%ProgramFiles%</td>
     * </tr>
     * <tr>
     * <td>The system root folder</td>
     * <td>%SystemRoot%</td>
     * </tr>
     * <tr>
     * <td>The system drive letter</td>
     * <td>%SystemDrive%</td>
     * </tr>
     * <tr>
     * <td>The current user's profile folder</td>
     * <td>%USERPROFILE%</td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>%APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is being impersonated from a service. For further discussion of access control issues, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a>.</div>
     * <div></div>
     * The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set, it is not unexpanded.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathUnExpandEnvStrings as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.
     * @param {Pointer<Byte>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size, in characters, in the <i>pszBuf</i> buffer.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathunexpandenvstringsa
     * @since windows5.0
     */
    static PathUnExpandEnvStringsA(pszPath, pszBuf, cchBuf) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\PathUnExpandEnvStringsA", "ptr", pszPath, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Replaces certain folder names in a fully qualified path with their associated environment string. (Unicode)
     * @remarks
     * The following folder paths are replaced by their equivalent environment string.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Folder</th>
     * <th>Environment String</th>
     * </tr>
     * <tr>
     * <td>The All Users profile folder</td>
     * <td>%ALLUSERSPROFILE%</td>
     * </tr>
     * <tr>
     * <td>The current user's application data folder (WindowsVista and later only).</td>
     * <td>%APPDATA%</td>
     * </tr>
     * <tr>
     * <td>The system name</td>
     * <td>%COMPUTERNAME%</td>
     * </tr>
     * <tr>
     * <td>The Program Files folder</td>
     * <td>%ProgramFiles%</td>
     * </tr>
     * <tr>
     * <td>The system root folder</td>
     * <td>%SystemRoot%</td>
     * </tr>
     * <tr>
     * <td>The system drive letter</td>
     * <td>%SystemDrive%</td>
     * </tr>
     * <tr>
     * <td>The current user's profile folder</td>
     * <td>%USERPROFILE%</td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>%APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is being impersonated from a service. For further discussion of access control issues, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a>.</div>
     * <div></div>
     * The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set, it is not unexpanded.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathUnExpandEnvStrings as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.
     * @param {Pointer<Char>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size, in characters, in the <i>pszBuf</i> buffer.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathunexpandenvstringsw
     * @since windows5.0
     */
    static PathUnExpandEnvStringsW(pszPath, pszBuf, cchBuf) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\PathUnExpandEnvStringsW", "ptr", pszPath, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Makes a case-sensitive comparison of two URL strings. (ANSI)
     * @remarks
     * For best results, you should first canonicalize the URLs with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-urlcanonicalizea">UrlCanonicalize</a>. Then, compare the canonicalized URLs with <b>UrlCompare</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlCompare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} psz1 Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.
     * @param {Pointer<Byte>} psz2 Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.
     * @param {Integer} fIgnoreSlash Type: <b>BOOL</b>
     * 
     * A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '\' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlcomparea
     * @since windows5.0
     */
    static UrlCompareA(psz1, psz2, fIgnoreSlash) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\UrlCompareA", "ptr", psz1, "ptr", psz2, "int", fIgnoreSlash, "int")
        return result
    }

    /**
     * Makes a case-sensitive comparison of two URL strings. (Unicode)
     * @remarks
     * For best results, you should first canonicalize the URLs with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-urlcanonicalizea">UrlCanonicalize</a>. Then, compare the canonicalized URLs with <b>UrlCompare</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlCompare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} psz1 Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.
     * @param {Pointer<Char>} psz2 Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.
     * @param {Integer} fIgnoreSlash Type: <b>BOOL</b>
     * 
     * A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '\' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlcomparew
     * @since windows5.0
     */
    static UrlCompareW(psz1, psz2, fIgnoreSlash) {
        psz1 := psz1 is String? StrPtr(psz1) : psz1
        psz2 := psz2 is String? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\UrlCompareW", "ptr", psz1, "ptr", psz2, "int", fIgnoreSlash, "int")
        return result
    }

    /**
     * When provided with a relative URL and its base, returns a URL in canonical form. (ANSI)
     * @remarks
     * Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a slash (/) after the document name to append more items; otherwise, <b>UrlCombine</b> exchanges one document for another. For example: 		
     * 
     * 				
     * 
     * 
     * ```
     * 
     * hRetVal = UrlCombine(TEXT("http://xyz/test/abc"), 
     *                      TEXT("bar"), 
     *                      lpszCombined, 
     *                      &dwLength, 0);
     * ```
     * 
     * 
     * The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the following call to <b>UrlCombine</b>.
     * 
     * 				
     * 
     * 
     * ```
     * 
     * hRetVal = UrlCombine(TEXT("http://xyz/test/abc/"), 
     *                      TEXT("bar"), 
     *                      lpszCombined, 
     *                      &dwLength, 0);
     * ```
     * 
     * 
     * If a URL string contains '/../' or '/./', <b>UrlCombine</b> usually treats the characters as if they indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to "/hello/world". If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszBase Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.
     * @param {Pointer<Byte>} pszRelative Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.
     * @param {Pointer<Byte>} pszCombined Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.
     * @param {Pointer<UInt32>} pcchCombined Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify how the URL is converted to canonical form. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns standard COM error codes, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_POINTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlcombinea
     * @since windows5.0
     */
    static UrlCombineA(pszBase, pszRelative, pszCombined, pcchCombined, dwFlags) {
        pszBase := pszBase is String? StrPtr(pszBase) : pszBase
        pszRelative := pszRelative is String? StrPtr(pszRelative) : pszRelative
        pszCombined := pszCombined is String? StrPtr(pszCombined) : pszCombined

        result := DllCall("SHLWAPI.dll\UrlCombineA", "ptr", pszBase, "ptr", pszRelative, "ptr", pszCombined, "uint*", pcchCombined, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * When provided with a relative URL and its base, returns a URL in canonical form. (Unicode)
     * @remarks
     * Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a slash (/) after the document name to append more items; otherwise, <b>UrlCombine</b> exchanges one document for another. For example: 		
     * 
     * 				
     * 
     * 
     * ```
     * 
     * hRetVal = UrlCombine(TEXT("http://xyz/test/abc"), 
     *                      TEXT("bar"), 
     *                      lpszCombined, 
     *                      &dwLength, 0);
     * ```
     * 
     * 
     * The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the following call to <b>UrlCombine</b>.
     * 
     * 				
     * 
     * 
     * ```
     * 
     * hRetVal = UrlCombine(TEXT("http://xyz/test/abc/"), 
     *                      TEXT("bar"), 
     *                      lpszCombined, 
     *                      &dwLength, 0);
     * ```
     * 
     * 
     * If a URL string contains '/../' or '/./', <b>UrlCombine</b> usually treats the characters as if they indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to "/hello/world". If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszBase Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.
     * @param {Pointer<Char>} pszRelative Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.
     * @param {Pointer<Char>} pszCombined Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.
     * @param {Pointer<UInt32>} pcchCombined Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify how the URL is converted to canonical form. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns standard COM error codes, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_POINTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlcombinew
     * @since windows5.0
     */
    static UrlCombineW(pszBase, pszRelative, pszCombined, pcchCombined, dwFlags) {
        pszBase := pszBase is String? StrPtr(pszBase) : pszBase
        pszRelative := pszRelative is String? StrPtr(pszRelative) : pszRelative
        pszCombined := pszCombined is String? StrPtr(pszCombined) : pszCombined

        result := DllCall("SHLWAPI.dll\UrlCombineW", "ptr", pszBase, "ptr", pszRelative, "ptr", pszCombined, "uint*", pcchCombined, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a URL string into canonical form. (ANSI)
     * @remarks
     * This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like "..\...".
     * 
     * If a URL string contains "/../" or "/./", <b>UrlCanonicalize</b> treats the characters as indicating navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to "/hello/world". Exceptions to this default behavior occur in these cases:
     *                 
     *                 
     * 
     * <ul>
     * <li>If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</li>
     * <li>If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"), <b>UrlCanonicalize</b> outputs the path exactly as it was input.</li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".
     * @param {Pointer<Byte>} pszCanonicalized Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.
     * @param {Pointer<UInt32>} pcchCanonicalized Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that specify how the URL is converted to canonical form. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlcanonicalizea
     * @since windows5.0
     */
    static UrlCanonicalizeA(pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl
        pszCanonicalized := pszCanonicalized is String? StrPtr(pszCanonicalized) : pszCanonicalized

        result := DllCall("SHLWAPI.dll\UrlCanonicalizeA", "ptr", pszUrl, "ptr", pszCanonicalized, "uint*", pcchCanonicalized, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a URL string into canonical form. (Unicode)
     * @remarks
     * This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like "..\...".
     * 
     * If a URL string contains "/../" or "/./", <b>UrlCanonicalize</b> treats the characters as indicating navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to "/hello/world". Exceptions to this default behavior occur in these cases:
     *                 
     *                 
     * 
     * <ul>
     * <li>If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</li>
     * <li>If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"), <b>UrlCanonicalize</b> outputs the path exactly as it was input.</li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".
     * @param {Pointer<Char>} pszCanonicalized Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.
     * @param {Pointer<UInt32>} pcchCanonicalized Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that specify how the URL is converted to canonical form. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlcanonicalizew
     * @since windows5.0
     */
    static UrlCanonicalizeW(pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl
        pszCanonicalized := pszCanonicalized is String? StrPtr(pszCanonicalized) : pszCanonicalized

        result := DllCall("SHLWAPI.dll\UrlCanonicalizeW", "ptr", pszUrl, "ptr", pszCanonicalized, "uint*", pcchCanonicalized, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Returns whether a URL is opaque. (ANSI)
     * @remarks
     * A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, mailto:xyz@litwareinc.com is an opaque URL. Opaque URLs cannot be separated into the standard URL hierarchy. <b>UrlIsOpaque</b> is equivalent to the following:
     * 
     * 				
     * 
     * 
     * ``` syntax
     * UrlIs(pszURL, URLIS_OPAQUE)
     * ```
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlIsOpaque as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the URL is opaque, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlisopaquea
     * @since windows5.0
     */
    static UrlIsOpaqueA(pszURL) {
        pszURL := pszURL is String? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlIsOpaqueA", "ptr", pszURL, "int")
        return result
    }

    /**
     * Returns whether a URL is opaque. (Unicode)
     * @remarks
     * A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, mailto:xyz@litwareinc.com is an opaque URL. Opaque URLs cannot be separated into the standard URL hierarchy. <b>UrlIsOpaque</b> is equivalent to the following:
     * 
     * 				
     * 
     * 
     * ``` syntax
     * UrlIs(pszURL, URLIS_OPAQUE)
     * ```
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlIsOpaque as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the URL is opaque, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlisopaquew
     * @since windows5.0
     */
    static UrlIsOpaqueW(pszURL) {
        pszURL := pszURL is String? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlIsOpaqueW", "ptr", pszURL, "int")
        return result
    }

    /**
     * Returns whether a URL is a URL that browsers typically do not include in navigation history. (ANSI)
     * @remarks
     * This function is equivalent to the following:
     * 				
     *                 
     * 
     * 
     * ``` syntax
     * UrlIs(pszURL, URLIS_NOHISTORY)
     * ```
     * @param {Pointer<Byte>} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlisnohistorya
     * @since windows5.0
     */
    static UrlIsNoHistoryA(pszURL) {
        pszURL := pszURL is String? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlIsNoHistoryA", "ptr", pszURL, "int")
        return result
    }

    /**
     * Returns whether a URL is a URL that browsers typically do not include in navigation history. (Unicode)
     * @remarks
     * This function is equivalent to the following:
     * 				
     *                 
     * 
     * 
     * ``` syntax
     * UrlIs(pszURL, URLIS_NOHISTORY)
     * ```
     * @param {Pointer<Char>} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlisnohistoryw
     * @since windows5.0
     */
    static UrlIsNoHistoryW(pszURL) {
        pszURL := pszURL is String? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlIsNoHistoryW", "ptr", pszURL, "int")
        return result
    }

    /**
     * Tests whether a URL is a specified type. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines UrlIs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Integer} UrlIs Type: <b>URLIS</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not. 
     * 
     *                     
     * 
     * If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlisa
     * @since windows5.0
     */
    static UrlIsA(pszUrl, UrlIs) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlIsA", "ptr", pszUrl, "int", UrlIs, "int")
        return result
    }

    /**
     * Tests whether a URL is a specified type. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines UrlIs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Integer} UrlIs Type: <b>URLIS</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not. 
     * 
     *                     
     * 
     * If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlisw
     * @since windows5.0
     */
    static UrlIsW(pszUrl, UrlIs) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlIsW", "ptr", pszUrl, "int", UrlIs, "int")
        return result
    }

    /**
     * Retrieves the location from a URL. (ANSI)
     * @remarks
     * The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string includes the query string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlGetLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.
     * @returns {Pointer<Byte>} Type: <b>LPCTSTR</b>
     * 
     * Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlgetlocationa
     * @since windows5.0
     */
    static UrlGetLocationA(pszURL) {
        pszURL := pszURL is String? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlGetLocationA", "ptr", pszURL, "char*")
        return result
    }

    /**
     * Retrieves the location from a URL. (Unicode)
     * @remarks
     * The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string includes the query string.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlGetLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.
     * @returns {Pointer<Char>} Type: <b>LPCTSTR</b>
     * 
     * Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlgetlocationw
     * @since windows5.0
     */
    static UrlGetLocationW(pszURL) {
        pszURL := pszURL is String? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlGetLocationW", "ptr", pszURL, "char*")
        return result
    }

    /**
     * Converts escape sequences back into ordinary characters. (ANSI)
     * @remarks
     * An escape sequence has the form "%xy".
     * 
     * Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlUnescape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszUrl Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.
     * @param {Pointer<Byte>} pszUnescaped Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.
     * @param {Pointer<UInt32>} pcchUnescaped Type: <b>DWORD*</b>
     * 
     * The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code and the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that control which characters are unescaped. It can be a combination of the following flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlunescapea
     * @since windows5.0
     */
    static UrlUnescapeA(pszUrl, pszUnescaped, pcchUnescaped, dwFlags) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl
        pszUnescaped := pszUnescaped is String? StrPtr(pszUnescaped) : pszUnescaped

        result := DllCall("SHLWAPI.dll\UrlUnescapeA", "ptr", pszUrl, "ptr", pszUnescaped, "uint*", pcchUnescaped, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts escape sequences back into ordinary characters. (Unicode)
     * @remarks
     * An escape sequence has the form "%xy".
     * 
     * Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlUnescape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszUrl Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.
     * @param {Pointer<Char>} pszUnescaped Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.
     * @param {Pointer<UInt32>} pcchUnescaped Type: <b>DWORD*</b>
     * 
     * The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code and the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that control which characters are unescaped. It can be a combination of the following flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlunescapew
     * @since windows5.0
     */
    static UrlUnescapeW(pszUrl, pszUnescaped, pcchUnescaped, dwFlags) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl
        pszUnescaped := pszUnescaped is String? StrPtr(pszUnescaped) : pszUnescaped

        result := DllCall("SHLWAPI.dll\UrlUnescapeW", "ptr", pszUrl, "ptr", pszUnescaped, "uint*", pcchUnescaped, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet (&quot;unsafe&quot; characters) into their corresponding escape sequences. (ANSI)
     * @remarks
     * For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example: 
     * 
     *                 
     * 
     * 
     * ``` syntax
     * http://microsoft.com/test.asp?url=/example/abc.asp?frame=true#fragment
     * ```
     * 
     * The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.
     *                 
     *                 
     * 
     * The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this case simply "test.asp".
     * 
     * The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".
     * 
     * Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Character</th>
     * <th>Escape Sequence</th>
     * </tr>
     * <tr>
     * <td>^</td>
     * <td>%5E</td>
     * </tr>
     * <tr>
     * <td>&amp;</td>
     * <td>%26</td>
     * </tr>
     * <tr>
     * <td>`</td>
     * <td>%60</td>
     * </tr>
     * <tr>
     * <td>{</td>
     * <td>%7B</td>
     * </tr>
     * <tr>
     * <td>}</td>
     * <td>%7D</td>
     * </tr>
     * <tr>
     * <td>|</td>
     * <td>%7C</td>
     * </tr>
     * <tr>
     * <td>]</td>
     * <td>%5D</td>
     * </tr>
     * <tr>
     * <td>[</td>
     * <td>%5B</td>
     * </tr>
     * <tr>
     * <td>"</td>
     * <td>%22</td>
     * </tr>
     * <tr>
     * <td>&lt;</td>
     * <td>%3C</td>
     * </tr>
     * <tr>
     * <td>&gt;</td>
     * <td>%3E</td>
     * </tr>
     * <tr>
     * <td>\</td>
     * <td>%5C</td>
     * </tr>
     * </table>
     * 
     * 
     * Use of the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.
     * 
     * By default, <b>UrlEscape</b> ignores any text following a # or ? character. The <b>URL_ESCAPE_SEGMENT_ONLY</b> flag overrides this behavior by regarding the entire string as the segment. The <b>URL_ESCAPE_SPACES_ONLY</b> flag overrides this behavior, but only for space characters.
     * @param {Pointer<Byte>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.
     * @param {Pointer<Byte>} pszEscaped Type: <b>PTSTR</b>
     * 
     * The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.
     * @param {Pointer<UInt32>} pcchEscaped Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character. 
     *     
     *                         
     * 
     * If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlescapea
     * @since windows5.0
     */
    static UrlEscapeA(pszUrl, pszEscaped, pcchEscaped, dwFlags) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl
        pszEscaped := pszEscaped is String? StrPtr(pszEscaped) : pszEscaped

        result := DllCall("SHLWAPI.dll\UrlEscapeA", "ptr", pszUrl, "ptr", pszEscaped, "uint*", pcchEscaped, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet (&quot;unsafe&quot; characters) into their corresponding escape sequences. (Unicode)
     * @remarks
     * For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example: 
     * 
     *                 
     * 
     * 
     * ``` syntax
     * http://microsoft.com/test.asp?url=/example/abc.asp?frame=true#fragment
     * ```
     * 
     * The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.
     *                 
     *                 
     * 
     * The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this case simply "test.asp".
     * 
     * The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".
     * 
     * Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Character</th>
     * <th>Escape Sequence</th>
     * </tr>
     * <tr>
     * <td>^</td>
     * <td>%5E</td>
     * </tr>
     * <tr>
     * <td>&amp;</td>
     * <td>%26</td>
     * </tr>
     * <tr>
     * <td>`</td>
     * <td>%60</td>
     * </tr>
     * <tr>
     * <td>{</td>
     * <td>%7B</td>
     * </tr>
     * <tr>
     * <td>}</td>
     * <td>%7D</td>
     * </tr>
     * <tr>
     * <td>|</td>
     * <td>%7C</td>
     * </tr>
     * <tr>
     * <td>]</td>
     * <td>%5D</td>
     * </tr>
     * <tr>
     * <td>[</td>
     * <td>%5B</td>
     * </tr>
     * <tr>
     * <td>"</td>
     * <td>%22</td>
     * </tr>
     * <tr>
     * <td>&lt;</td>
     * <td>%3C</td>
     * </tr>
     * <tr>
     * <td>&gt;</td>
     * <td>%3E</td>
     * </tr>
     * <tr>
     * <td>\</td>
     * <td>%5C</td>
     * </tr>
     * </table>
     * 
     * 
     * Use of the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.
     * 
     * By default, <b>UrlEscape</b> ignores any text following a # or ? character. The <b>URL_ESCAPE_SEGMENT_ONLY</b> flag overrides this behavior by regarding the entire string as the segment. The <b>URL_ESCAPE_SPACES_ONLY</b> flag overrides this behavior, but only for space characters.
     * @param {Pointer<Char>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.
     * @param {Pointer<Char>} pszEscaped Type: <b>PTSTR</b>
     * 
     * The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.
     * @param {Pointer<UInt32>} pcchEscaped Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character. 
     *     
     *                         
     * 
     * If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlescapew
     * @since windows5.0
     */
    static UrlEscapeW(pszUrl, pszEscaped, pcchEscaped, dwFlags) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl
        pszEscaped := pszEscaped is String? StrPtr(pszEscaped) : pszEscaped

        result := DllCall("SHLWAPI.dll\UrlEscapeW", "ptr", pszUrl, "ptr", pszEscaped, "uint*", pcchEscaped, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a Microsoft MS-DOS path to a canonicalized URL. (ANSI)
     * @remarks
     * <div class="alert"><b>Note</b><b>UrlCreateFromPath</b> does not support extended paths. These are paths that include the extended-length path prefix "\\?\".</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.
     * @param {Pointer<Byte>} pszUrl Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the URL.
     * @param {Pointer<UInt32>} pcchUrl Type: <b>DWORD*</b>
     * 
     * The number of characters in <i>pszUrl</i>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Set this parameter to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlcreatefrompatha
     * @since windows5.0
     */
    static UrlCreateFromPathA(pszPath, pszUrl, pcchUrl, dwFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlCreateFromPathA", "ptr", pszPath, "ptr", pszUrl, "uint*", pcchUrl, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a Microsoft MS-DOS path to a canonicalized URL. (Unicode)
     * @remarks
     * <div class="alert"><b>Note</b><b>UrlCreateFromPath</b> does not support extended paths. These are paths that include the extended-length path prefix "\\?\".</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszPath Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.
     * @param {Pointer<Char>} pszUrl Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the URL.
     * @param {Pointer<UInt32>} pcchUrl Type: <b>DWORD*</b>
     * 
     * The number of characters in <i>pszUrl</i>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Set this parameter to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlcreatefrompathw
     * @since windows5.0
     */
    static UrlCreateFromPathW(pszPath, pszUrl, pcchUrl, dwFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlCreateFromPathW", "ptr", pszPath, "ptr", pszUrl, "uint*", pcchUrl, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a file URL to a Microsoft MS-DOS path. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathCreateFromUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Pointer<Byte>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<UInt32>} pcchPath Type: <b>DWORD*</b>
     * 
     * The number of characters in the <i>pszPath</i> buffer.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Set this parameter to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcreatefromurla
     * @since windows5.0
     */
    static PathCreateFromUrlA(pszUrl, pszPath, pcchPath, dwFlags) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathCreateFromUrlA", "ptr", pszUrl, "ptr", pszPath, "uint*", pcchPath, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a file URL to a Microsoft MS-DOS path. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines PathCreateFromUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Pointer<Char>} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<UInt32>} pcchPath Type: <b>DWORD*</b>
     * 
     * The number of characters in the <i>pszPath</i> buffer.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Set this parameter to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcreatefromurlw
     * @since windows5.0
     */
    static PathCreateFromUrlW(pszUrl, pszPath, pcchPath, dwFlags) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathCreateFromUrlW", "ptr", pszUrl, "ptr", pszPath, "uint*", pcchPath, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a path from a file URL.
     * @param {Pointer<Char>} pszIn Type: <b>PCWSTR</b>
     * 
     * A pointer to the URL of a file, represented as a null-terminated, Unicode string.
     * @param {Pointer<Char>} ppszOut Type: <b>PWSTR*</b>
     * 
     * The address of a pointer to a buffer of length MAX_PATH that, when this function returns successfully, receives the file path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved, must be 0.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-pathcreatefromurlalloc
     * @since windows6.0.6000
     */
    static PathCreateFromUrlAlloc(pszIn, ppszOut, dwFlags) {
        pszIn := pszIn is String? StrPtr(pszIn) : pszIn

        result := DllCall("SHLWAPI.dll\PathCreateFromUrlAlloc", "ptr", pszIn, "ptr", ppszOut, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Hashes a URL string. (ANSI)
     * @remarks
     * To hash a URL into a single byte, set <i>cbHash</i> = sizeof(BYTE) and <i>pbHash</i> = (LPBYTE)&amp;bHashedValue, where bHashedValue is a one-byte buffer. To hash a URL into a <b>DWORD</b>, set <i>cbHash</i> = sizeof(DWORD) and <i>pbHash</i> = (LPBYTE)&amp;dwHashedValue, where dwHashedValue is a <b>DWORD</b> buffer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlHash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Pointer} pbHash Type: <b>BYTE*</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the hashed array.
     * @param {Integer} cbHash Type: <b>DWORD</b>
     * 
     * The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlhasha
     * @since windows5.0
     */
    static UrlHashA(pszUrl, pbHash, cbHash) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlHashA", "ptr", pszUrl, "ptr", pbHash, "uint", cbHash, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Hashes a URL string. (Unicode)
     * @remarks
     * To hash a URL into a single byte, set <i>cbHash</i> = sizeof(BYTE) and <i>pbHash</i> = (LPBYTE)&amp;bHashedValue, where bHashedValue is a one-byte buffer. To hash a URL into a <b>DWORD</b>, set <i>cbHash</i> = sizeof(DWORD) and <i>pbHash</i> = (LPBYTE)&amp;dwHashedValue, where dwHashedValue is a <b>DWORD</b> buffer.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlHash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Pointer} pbHash Type: <b>BYTE*</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the hashed array.
     * @param {Integer} cbHash Type: <b>DWORD</b>
     * 
     * The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlhashw
     * @since windows5.0
     */
    static UrlHashW(pszUrl, pbHash, cbHash) {
        pszUrl := pszUrl is String? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlHashW", "ptr", pszUrl, "ptr", pbHash, "uint", cbHash, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Accepts a URL string and returns a specified part of that URL. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines UrlGetPart as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszIn Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Pointer<Char>} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.
     * @param {Pointer<UInt32>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwPart Type: <b>DWORD</b>
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlgetpartw
     * @since windows5.0
     */
    static UrlGetPartW(pszIn, pszOut, pcchOut, dwPart, dwFlags) {
        pszIn := pszIn is String? StrPtr(pszIn) : pszIn
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\UrlGetPartW", "ptr", pszIn, "ptr", pszOut, "uint*", pcchOut, "uint", dwPart, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Accepts a URL string and returns a specified part of that URL. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines UrlGetPart as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszIn Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Pointer<Byte>} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.
     * @param {Pointer<UInt32>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwPart Type: <b>DWORD</b>
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlgetparta
     * @since windows5.0
     */
    static UrlGetPartA(pszIn, pszOut, pcchOut, dwPart, dwFlags) {
        pszIn := pszIn is String? StrPtr(pszIn) : pszIn
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\UrlGetPartA", "ptr", pszIn, "ptr", pszOut, "uint*", pcchOut, "uint", dwPart, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines a scheme for a specified URL string, and returns a string with an appropriate prefix. (ANSI)
     * @remarks
     * If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your input string fits this description, <b>UrlApplyScheme</b> may treat it as valid and not apply a scheme. To force the function to apply a scheme to a URL, set the <b>URL_APPLY_FORCEAPPLY</b> and <b>URL_APPLY_DEFAULT</b> flags in <i>dwFlags</i>. This combination of flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlApplyScheme as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszIn Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.
     * @param {Pointer<Byte>} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.
     * @param {Pointer<UInt32>} pcchOut Type: <b>DWORD*</b>
     * 
     * The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that specify how to determine the scheme. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM return value, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There were no errors, but no prefix was prepended.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_POINTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlapplyschemea
     * @since windows5.0
     */
    static UrlApplySchemeA(pszIn, pszOut, pcchOut, dwFlags) {
        pszIn := pszIn is String? StrPtr(pszIn) : pszIn
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\UrlApplySchemeA", "ptr", pszIn, "ptr", pszOut, "uint*", pcchOut, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines a scheme for a specified URL string, and returns a string with an appropriate prefix. (Unicode)
     * @remarks
     * If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your input string fits this description, <b>UrlApplyScheme</b> may treat it as valid and not apply a scheme. To force the function to apply a scheme to a URL, set the <b>URL_APPLY_FORCEAPPLY</b> and <b>URL_APPLY_DEFAULT</b> flags in <i>dwFlags</i>. This combination of flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines UrlApplyScheme as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszIn Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.
     * @param {Pointer<Char>} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.
     * @param {Pointer<UInt32>} pcchOut Type: <b>DWORD*</b>
     * 
     * The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that specify how to determine the scheme. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM return value, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There were no errors, but no prefix was prepended.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_POINTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlapplyschemew
     * @since windows5.0
     */
    static UrlApplySchemeW(pszIn, pszOut, pcchOut, dwFlags) {
        pszIn := pszIn is String? StrPtr(pszIn) : pszIn
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\UrlApplySchemeW", "ptr", pszIn, "ptr", pszOut, "uint*", pcchOut, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Hashes an array of data.
     * @param {Pointer} pbData Type: <b>BYTE*</b>
     * 
     * A pointer to the data array.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * The number of elements in the array at <i>pbData</i>.
     * @param {Pointer} pbHash Type: <b>BYTE*</b>
     * 
     * A pointer to a value that, when this function returns successfully, receives the hashed array.
     * @param {Integer} cbHash Type: <b>DWORD</b>
     * 
     * The number of elements in <i>pbHash</i>. It should be no larger than 256.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-hashdata
     * @since windows5.0
     */
    static HashData(pbData, cbData, pbHash, cbHash) {
        result := DllCall("SHLWAPI.dll\HashData", "ptr", pbData, "uint", cbData, "ptr", pbHash, "uint", cbHash, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * UrlFixupW may be altered or unavailable.
     * @remarks
     * The UrlFixup function recognizes the schemes specified by the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-url_scheme">URL_SCHEME</a> enumeration.
     * 
     * Priority is given to the first character in the protocol identifier section so <c>htp</code> will be converted to <code>http</code> instead of <code>ftp</c>.
     * 
     * <div class="alert"><b>Note</b>Do not use this function for deterministic data transformation. The heuristics used by <b>UrlFixupW</b> can change from one release to the next. The function should only be used to correct possibly invalid user input.</div>
     * <div></div>
     * This function is available only in a Unicode version.
     * @param {Pointer<Char>} pcszUrl Type: <b>PCWSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that contains the URL to be corrected. This string must not exceed INTERNET_MAX_PATH_LENGTH characters in length, including the terminating <b>NULL</b> character.
     * @param {Pointer<Char>} pszTranslatedUrl Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the copied characters. The buffer must be large enough to contain the number of WCHAR characters specified by the <i>cchMax</i> parameter, including the terminating <b>NULL</b> character. This parameter can be equal to the <i>pcszUrl</i> parameter to correct a URL in place. If <i>pszTranslatedUrl</i> is not equal to <i>pcszUrl</i>, the buffer pointed to by <i>pszTranslatedUrl</i> must not overlap the buffer pointed to by <i>pcszUrl</i>.
     * @param {Integer} cchMax Type: <b>DWORD</b>
     * 
     * The number of <b>WCHAR</b> characters that can be contained in the buffer pointed to by <i>pszTranslatedUrl</i>. This parameter must be greater than zero.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the proposed URL was already acceptable or was successfully corrected. The <i>pszTranslatedUrl</i> buffer contains the corrected URL, or the original URL if no correction was needed. Returns S_FALSE if the proposed URL could not be recognized sufficiently to be corrected. Otherwise, returns a standard COM error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-urlfixupw
     * @since windows5.1.2600
     */
    static UrlFixupW(pcszUrl, pszTranslatedUrl, cchMax) {
        pcszUrl := pcszUrl is String? StrPtr(pcszUrl) : pcszUrl
        pszTranslatedUrl := pszTranslatedUrl is String? StrPtr(pszTranslatedUrl) : pszTranslatedUrl

        result := DllCall("SHLWAPI.dll\UrlFixupW", "ptr", pcszUrl, "ptr", pszTranslatedUrl, "uint", cchMax, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Performs rudimentary parsing of a URL. (ANSI)
     * @remarks
     * The parsing performed by <b>ParseURL</b> is fairly rudimentary. For more sophisticated URL parsing, use <a href="https://docs.microsoft.com/windows/desktop/api/wininet/nf-wininet-internetcrackurla">InternetCrackUrl</a>.
     * @param {Pointer<Byte>} pcszURL Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the URL to be parsed.
     * @param {Pointer<PARSEDURLA>} ppu Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-parsedurla">PARSEDURL</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-parsedurla">PARSEDURL</a> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-parseurla
     * @since windows6.0.6000
     */
    static ParseURLA(pcszURL, ppu) {
        pcszURL := pcszURL is String? StrPtr(pcszURL) : pcszURL

        result := DllCall("SHLWAPI.dll\ParseURLA", "ptr", pcszURL, "ptr", ppu, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Performs rudimentary parsing of a URL. (Unicode)
     * @remarks
     * The parsing performed by <b>ParseURL</b> is fairly rudimentary. For more sophisticated URL parsing, use <a href="https://docs.microsoft.com/windows/desktop/api/wininet/nf-wininet-internetcrackurla">InternetCrackUrl</a>.
     * @param {Pointer<Char>} pcszURL Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the URL to be parsed.
     * @param {Pointer<PARSEDURLW>} ppu Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-parsedurla">PARSEDURL</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-parsedurla">PARSEDURL</a> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-parseurlw
     * @since windows6.0.6000
     */
    static ParseURLW(pcszURL, ppu) {
        pcszURL := pcszURL is String? StrPtr(pcszURL) : pcszURL

        result := DllCall("SHLWAPI.dll\ParseURLW", "ptr", pcszURL, "ptr", ppu, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Deletes an empty key. (ANSI)
     * @remarks
     * <b>SHDeleteEmptyKey</b> does not delete a key if it contains any subkeys or values. Use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shdeletekeya">SHDeleteKey</a> instead.
     * 
     * Alternatively, use the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regdeletekeya">RegDeleteKey</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regdeletetreea">RegDeleteTree</a> function.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHDeleteEmptyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the key to delete.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shdeleteemptykeya
     * @since windows5.0
     */
    static SHDeleteEmptyKeyA(hkey, pszSubKey) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHDeleteEmptyKeyA", "ptr", hkey, "ptr", pszSubKey, "uint")
        return result
    }

    /**
     * Deletes an empty key. (Unicode)
     * @remarks
     * <b>SHDeleteEmptyKey</b> does not delete a key if it contains any subkeys or values. Use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shdeletekeya">SHDeleteKey</a> instead.
     * 
     * Alternatively, use the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regdeletekeya">RegDeleteKey</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regdeletetreea">RegDeleteTree</a> function.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHDeleteEmptyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {Pointer<Char>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the key to delete.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shdeleteemptykeyw
     * @since windows5.0
     */
    static SHDeleteEmptyKeyW(hkey, pszSubKey) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHDeleteEmptyKeyW", "ptr", hkey, "ptr", pszSubKey, "uint")
        return result
    }

    /**
     * Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry. (ANSI)
     * @remarks
     * Alternatively, use the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regdeletekeya">RegDeleteKey</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regdeletetreea">RegDeleteTree</a> function.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHDeleteKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the key to delete.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shdeletekeya
     * @since windows5.0
     */
    static SHDeleteKeyA(hkey, pszSubKey) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHDeleteKeyA", "ptr", hkey, "ptr", pszSubKey, "uint")
        return result
    }

    /**
     * Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry. (Unicode)
     * @remarks
     * Alternatively, use the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regdeletekeya">RegDeleteKey</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regdeletetreea">RegDeleteTree</a> function.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHDeleteKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {Pointer<Char>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the key to delete.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shdeletekeyw
     * @since windows5.0
     */
    static SHDeleteKeyW(hkey, pszSubKey) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHDeleteKeyW", "ptr", hkey, "ptr", pszSubKey, "uint")
        return result
    }

    /**
     * Duplicates a registry key's HKEY handle.
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * The HKEY handle to be duplicated.
     * @returns {Pointer<Void>} Type: <b>HKEY</b>
     * 
     * Returns a duplicate of the handle specified in <i>hkey</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregduplicatehkey
     * @since windows5.0
     */
    static SHRegDuplicateHKey(hkey) {
        result := DllCall("SHLWAPI.dll\SHRegDuplicateHKey", "ptr", hkey)
        return result
    }

    /**
     * Deletes a named value from the specified registry key. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the subkey for which to change the value.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the value to be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shdeletevaluea
     * @since windows5.0
     */
    static SHDeleteValueA(hkey, pszSubKey, pszValue) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHDeleteValueA", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint")
        return result
    }

    /**
     * Deletes a named value from the specified registry key. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Char>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the subkey for which to change the value.
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the value to be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shdeletevaluew
     * @since windows5.0
     */
    static SHDeleteValueW(hkey, pszSubKey, pszValue) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHDeleteValueW", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint")
        return result
    }

    /**
     * Retrieves a registry value. (SHGetValueA)
     * @remarks
     * If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the value.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * The type of value. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of the destination data buffer.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * The size of the destination data buffer.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shgetvaluea
     * @since windows5.0
     */
    static SHGetValueA(hkey, pszSubKey, pszValue, pdwType, pvData, pcbData) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHGetValueA", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Retrieves a registry value. (SHGetValueW)
     * @remarks
     * If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Char>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the value.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * The type of value. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of the destination data buffer.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * The size of the destination data buffer.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shgetvaluew
     * @since windows5.0
     */
    static SHGetValueW(hkey, pszSubKey, pszValue, pdwType, pvData, pcbData) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHGetValueW", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Sets the value of a registry key. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHSetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPCVOID</b>
     * 
     * Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shsetvaluea
     * @since windows5.0
     */
    static SHSetValueA(hkey, pszSubKey, pszValue, dwType, pvData, cbData) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHSetValueA", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint", dwType, "ptr", pvData, "uint", cbData, "int")
        return result
    }

    /**
     * Sets the value of a registry key. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHSetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Char>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPCVOID</b>
     * 
     * Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shsetvaluew
     * @since windows5.0
     */
    static SHSetValueW(hkey, pszSubKey, pszValue, dwType, pvData, cbData) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHSetValueW", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint", dwType, "ptr", pvData, "uint", cbData, "int")
        return result
    }

    /**
     * Retrieves a registry value. (SHRegGetValueA)
     * @remarks
     * <b>SHRegGetValue</b> provides data type checking, boot mode checking, auto-expansion of REG_EXPAND_SZ data, and guaranteed <b>null</b>-termination of REG_SZ, REG_EXPAND_SZ, and REG_MULTI_SZ data.
     * 
     * The key identified by <i>hkey</i> must have been opened with <a href="https://docs.microsoft.com/windows/desktop/shell/messages">KEY_QUERY_VALUE</a> security access. If <i>pszSubKey</i> is not <b>NULL</b> or an empty string, that key also must be able to be opened with <b>KEY_QUERY_VALUE</b> security access in the current calling context.
     * 
     * If the data's type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ, then any returned data includes or takes into account the string's <b>null</b>-termination. For example, if <i>pvData</i> is not <b>NULL</b>, the data returned in that buffer is <b>null</b>-terminated. If <i>pcbData</i> is not <b>NULL</b>, the buffer size that it points to includes the bytes required to hold the terminating <b>null</b> character.
     * 
     * Unless the SRRF_NOEXPAND flag is set, string data of type REG_EXPAND_SZ is automatically expanded before being returned. The expanded string's type is reported in <i>pdwType</i> as REG_SZ, the <i>pcbData</i> parameter points to the number of bytes written for the expanded string, and the buffer pointed to by <i>pvData</i> holds the expanded version of the string.
     * 
     * <h3><a id="Performance_Notes"></a><a id="performance_notes"></a><a id="PERFORMANCE_NOTES"></a>Performance Notes</h3>
     * If <i>pszSubKey</i> is not <b>NULL</b> or an empty string, that key is opened and closed by this function each time it is accessed. If your application must retrieve a series of values from the same subkey, you will see better performance by opening the key using <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeyexa">RegOpenKeyEx</a> before calling <b>SHRegGetValue</b>. Use the key returned in the <i>phkResult</i> parameter of <b>RegOpenKeyEx</b> as the <i>hkey</i> parameter in this function, with <i>pszSubKey</i> set to <b>NULL</b>.
     * 
     * The potential for an additional call to the registry to read or re-read the data exists when the data type is REG_EXPAND_SZ and the SRRF_NOEXPAND flag has not been set. The following conditions result in that additional call.
     *                     <ul>
     * <li><i>pvData</i> is <b>NULL</b>, <i>pcbData</i> is not <b>NULL</b>. Though the data is not retrieved, the registry must be read to get the string and that string expanded to determine the required size of the data buffer.</li>
     * <li><i>pvData</i> is not <b>NULL</b>, but is too small to hold the data. The data is re-read to get the full string, the string is expanded, and the total required size is determined.</li>
     * </ul>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the relative path from <i>hkey</i> to the subkey to retrieve the value from. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the <i>hkey</i> location.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that contains the name of the value. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the Default value.
     * @param {Integer} srrfFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a></b>
     * 
     * One or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a> flags that restricts the data to be retrieved. At least one type restriction (SRRF_RT) value must be specified.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. If the SRRF_NOEXPAND flag is not set, REG_EXPAND_SZ types are automatically expanded and returned as REG_SZ. If type information is not required, this parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * A pointer to a buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not needed. For example, if you were testing only for a value's existence, the specific value data would be superfluous.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the destination data buffer <i>pvData</i>, in bytes. This value can be <b>NULL</b> only if <i>pvData</i> is <b>NULL</b>. On exit, <i>pcbData</i> points to one of these values.
     *                     
     * 
     * <table class="clsStd">
     * <tr>
     * <th>pvData</th>
     * <th>Return Value</th>
     * <th>pcbData</th>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td>ERROR_SUCCESS</td>
     * <td>Size in bytes sufficient to hold the registry data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>NULL</b></td>
     * <td>ERROR_SUCCESS</td>
     * <td>Exact number of bytes written to <i>pvData</i>.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>NULL</b></td>
     * <td>ERROR_MORE_DATA</td>
     * <td>Size in bytes needed to hold the entire data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetvaluea
     * @since windows5.1.2600
     */
    static SHRegGetValueA(hkey, pszSubKey, pszValue, srrfFlags, pdwType, pvData, pcbData) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegGetValueA", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "int", srrfFlags, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Retrieves a registry value. (SHRegGetValueW)
     * @remarks
     * <b>SHRegGetValue</b> provides data type checking, boot mode checking, auto-expansion of REG_EXPAND_SZ data, and guaranteed <b>null</b>-termination of REG_SZ, REG_EXPAND_SZ, and REG_MULTI_SZ data.
     * 
     * The key identified by <i>hkey</i> must have been opened with <a href="https://docs.microsoft.com/windows/desktop/shell/messages">KEY_QUERY_VALUE</a> security access. If <i>pszSubKey</i> is not <b>NULL</b> or an empty string, that key also must be able to be opened with <b>KEY_QUERY_VALUE</b> security access in the current calling context.
     * 
     * If the data's type is REG_SZ, REG_EXPAND_SZ or REG_MULTI_SZ, then any returned data includes or takes into account the string's <b>null</b>-termination. For example, if <i>pvData</i> is not <b>NULL</b>, the data returned in that buffer is <b>null</b>-terminated. If <i>pcbData</i> is not <b>NULL</b>, the buffer size that it points to includes the bytes required to hold the terminating <b>null</b> character.
     * 
     * Unless the SRRF_NOEXPAND flag is set, string data of type REG_EXPAND_SZ is automatically expanded before being returned. The expanded string's type is reported in <i>pdwType</i> as REG_SZ, the <i>pcbData</i> parameter points to the number of bytes written for the expanded string, and the buffer pointed to by <i>pvData</i> holds the expanded version of the string.
     * 
     * <h3><a id="Performance_Notes"></a><a id="performance_notes"></a><a id="PERFORMANCE_NOTES"></a>Performance Notes</h3>
     * If <i>pszSubKey</i> is not <b>NULL</b> or an empty string, that key is opened and closed by this function each time it is accessed. If your application must retrieve a series of values from the same subkey, you will see better performance by opening the key using <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeyexa">RegOpenKeyEx</a> before calling <b>SHRegGetValue</b>. Use the key returned in the <i>phkResult</i> parameter of <b>RegOpenKeyEx</b> as the <i>hkey</i> parameter in this function, with <i>pszSubKey</i> set to <b>NULL</b>.
     * 
     * The potential for an additional call to the registry to read or re-read the data exists when the data type is REG_EXPAND_SZ and the SRRF_NOEXPAND flag has not been set. The following conditions result in that additional call.
     *                     <ul>
     * <li><i>pvData</i> is <b>NULL</b>, <i>pcbData</i> is not <b>NULL</b>. Though the data is not retrieved, the registry must be read to get the string and that string expanded to determine the required size of the data buffer.</li>
     * <li><i>pvData</i> is not <b>NULL</b>, but is too small to hold the data. The data is re-read to get the full string, the string is expanded, and the total required size is determined.</li>
     * </ul>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {Pointer<Char>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the relative path from <i>hkey</i> to the subkey to retrieve the value from. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the <i>hkey</i> location.
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that contains the name of the value. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the Default value.
     * @param {Integer} srrfFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a></b>
     * 
     * One or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a> flags that restricts the data to be retrieved. At least one type restriction (SRRF_RT) value must be specified.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. If the SRRF_NOEXPAND flag is not set, REG_EXPAND_SZ types are automatically expanded and returned as REG_SZ. If type information is not required, this parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * A pointer to a buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not needed. For example, if you were testing only for a value's existence, the specific value data would be superfluous.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the destination data buffer <i>pvData</i>, in bytes. This value can be <b>NULL</b> only if <i>pvData</i> is <b>NULL</b>. On exit, <i>pcbData</i> points to one of these values.
     *                     
     * 
     * <table class="clsStd">
     * <tr>
     * <th>pvData</th>
     * <th>Return Value</th>
     * <th>pcbData</th>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td>ERROR_SUCCESS</td>
     * <td>Size in bytes sufficient to hold the registry data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>NULL</b></td>
     * <td>ERROR_SUCCESS</td>
     * <td>Exact number of bytes written to <i>pvData</i>.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>NULL</b></td>
     * <td>ERROR_MORE_DATA</td>
     * <td>Size in bytes needed to hold the entire data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetvaluew
     * @since windows5.1.2600
     */
    static SHRegGetValueW(hkey, pszSubKey, pszValue, srrfFlags, pdwType, pvData, pcbData) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegGetValueW", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "int", srrfFlags, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Obtains specified information from the registry.
     * @param {Pointer<Char>} pwszKey Type: <b>PCWSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated Unicode string that specifies the path to the registry key.
     * @param {Pointer<Char>} pwszValue Type: <b>PCWSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated Unicode string that specifies the key value. This value can be <b>NULL</b>, in which case data is retrieved from the Default value.
     * @param {Integer} srrfFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a> flag constants. If more than one flag is used they can be combined using a bitwise OR. These flags are used to restrict the type of data returned. This value cannot be 0.
     * @param {Pointer<UInt32>} pdwType Type: <b>DWORD*</b>
     * 
     * When this function returns, contains a pointer to a <b>DWORD</b> which receives a code that indicates the type of data stored in the specified value.  This can be set to <b>NULL</b> if no type information is wanted. If this value is not <b>NULL</b>, and the SRRF_NOEXPAND flag has not been set, data types of REG_EXPAND_SZ will be returned as REG_SZ since they are automatically expanded in this method.
     * @param {Pointer} pvData Type: <b>LPCVOID</b>
     * 
     * A pointer to a buffer that contains the value's data. This parameter can be <b>NULL</b> if the data is not needed. This value must contain the size of the <i>pvData</i> buffer on entry.  If <i>pvData</i> is <b>NULL</b> (or if <i>pvData</i> is not <b>NULL</b>, but too small of a buffer to hold the registry data), then on exit it will contain the size required to hold the registry data.
     * @param {Pointer<UInt32>} pcbData Type: <b>DWORD*</b>
     * 
     * When this function returns, contains a pointer to the size of the data, in bytes.
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * If successful, this function returns ERROR_SUCCESS and all out parameters requested. Returns ERROR_MORE_DATA if the function fails due to insufficient space in a provided non-<b>NULL</b> pvData. In this case  only <i>pdwType</i> and <i>pcbData</i> may contain valid data, <i>pvData</i> will be undefined. Otherwise, returns a nonzero error code defined in Winerror.h . You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetvaluefromhkcuhklm
     * @since windows6.0.6000
     */
    static SHRegGetValueFromHKCUHKLM(pwszKey, pwszValue, srrfFlags, pdwType, pvData, pcbData) {
        pwszKey := pwszKey is String? StrPtr(pwszKey) : pwszKey
        pwszValue := pwszValue is String? StrPtr(pwszValue) : pwszValue

        result := DllCall("SHLWAPI.dll\SHRegGetValueFromHKCUHKLM", "ptr", pwszKey, "ptr", pwszValue, "int", srrfFlags, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Opens a registry key and queries it for a specific value. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHQueryValueEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the <b>null</b>-terminated string that contains the name of the value to be queried.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shqueryvalueexa
     * @since windows5.0
     */
    static SHQueryValueExA(hkey, pszValue, pdwType, pvData, pcbData) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHQueryValueExA", "ptr", hkey, "ptr", pszValue, "uint*", pdwReserved, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Opens a registry key and queries it for a specific value. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHQueryValueEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the <b>null</b>-terminated string that contains the name of the value to be queried.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shqueryvalueexw
     * @since windows5.0
     */
    static SHQueryValueExW(hkey, pszValue, pdwType, pvData, pcbData) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHQueryValueExW", "ptr", hkey, "ptr", pszValue, "uint*", pdwReserved, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Enumerates the subkeys of the specified open registry key. (SHEnumKeyExA)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHEnumKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {Pointer<Byte>} pszName Type: <b>LPTSTR</b>
     * 
     * The address of a character buffer that receives the enumerated key name.
     * @param {Pointer<UInt32>} pcchName Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shenumkeyexa
     * @since windows5.0
     */
    static SHEnumKeyExA(hkey, dwIndex, pszName, pcchName) {
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHLWAPI.dll\SHEnumKeyExA", "ptr", hkey, "uint", dwIndex, "ptr", pszName, "uint*", pcchName, "uint")
        return result
    }

    /**
     * Enumerates the subkeys of the specified open registry key. (SHEnumKeyExW)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHEnumKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {Pointer<Char>} pszName Type: <b>LPTSTR</b>
     * 
     * The address of a character buffer that receives the enumerated key name.
     * @param {Pointer<UInt32>} pcchName Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shenumkeyexw
     * @since windows5.0
     */
    static SHEnumKeyExW(hkey, dwIndex, pszName, pcchName) {
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHLWAPI.dll\SHEnumKeyExW", "ptr", hkey, "uint", dwIndex, "ptr", pszName, "uint*", pcchName, "uint")
        return result
    }

    /**
     * Enumerates the values of the specified open registry key. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHEnumValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {Pointer<Byte>} pszValueName Type: <b>LPTSTR</b>
     * 
     * The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.
     * @param {Pointer<UInt32>} pcchValueName Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shenumvaluea
     * @since windows5.0
     */
    static SHEnumValueA(hkey, dwIndex, pszValueName, pcchValueName, pdwType, pvData, pcbData) {
        pszValueName := pszValueName is String? StrPtr(pszValueName) : pszValueName

        result := DllCall("SHLWAPI.dll\SHEnumValueA", "ptr", hkey, "uint", dwIndex, "ptr", pszValueName, "uint*", pcchValueName, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Enumerates the values of the specified open registry key. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHEnumValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {Pointer<Char>} pszValueName Type: <b>LPTSTR</b>
     * 
     * The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.
     * @param {Pointer<UInt32>} pcchValueName Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shenumvaluew
     * @since windows5.0
     */
    static SHEnumValueW(hkey, dwIndex, pszValueName, pcchValueName, pdwType, pvData, pcbData) {
        pszValueName := pszValueName is String? StrPtr(pszValueName) : pszValueName

        result := DllCall("SHLWAPI.dll\SHEnumValueW", "ptr", hkey, "uint", dwIndex, "ptr", pszValueName, "uint*", pcchValueName, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "uint")
        return result
    }

    /**
     * Retrieves information about a specified registry key. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHQueryInfoKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<UInt32>} pcSubKeys Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.
     * @param {Pointer<UInt32>} pcchMaxSubKeyLen Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.
     * @param {Pointer<UInt32>} pcValues Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of values under the specified key.
     * @param {Pointer<UInt32>} pcchMaxValueNameLen Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shqueryinfokeya
     * @since windows5.0
     */
    static SHQueryInfoKeyA(hkey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen) {
        result := DllCall("SHLWAPI.dll\SHQueryInfoKeyA", "ptr", hkey, "uint*", pcSubKeys, "uint*", pcchMaxSubKeyLen, "uint*", pcValues, "uint*", pcchMaxValueNameLen, "uint")
        return result
    }

    /**
     * Retrieves information about a specified registry key. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHQueryInfoKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<UInt32>} pcSubKeys Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.
     * @param {Pointer<UInt32>} pcchMaxSubKeyLen Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.
     * @param {Pointer<UInt32>} pcValues Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of values under the specified key.
     * @param {Pointer<UInt32>} pcchMaxValueNameLen Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shqueryinfokeyw
     * @since windows5.0
     */
    static SHQueryInfoKeyW(hkey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen) {
        result := DllCall("SHLWAPI.dll\SHQueryInfoKeyW", "ptr", hkey, "uint*", pcSubKeys, "uint*", pcchMaxSubKeyLen, "uint*", pcValues, "uint*", pcchMaxValueNameLen, "uint")
        return result
    }

    /**
     * Recursively copies the subkeys and values of the source subkey to the destination key. SHCopyKey does not copy the security attributes of the keys. (ANSI)
     * @remarks
     * <div class="alert"><b>Important</b>This function does not duplicate the security attributes of the keys and values that it copies. Rather, all security attributes in the destination key are the default attributes.</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHCopyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkeySrc Type: <b>HKEY</b>
     * 
     * A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).
     * @param {Pointer<Byte>} pszSrcSubKey Type: <b>LPCTSTR</b>
     * 
     * The subkey whose subkeys and values are to be copied.
     * @param {Pointer<Void>} hkeyDest Type: <b>HKEY</b>
     * 
     * The destination key.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcopykeya
     * @since windows5.0
     */
    static SHCopyKeyA(hkeySrc, pszSrcSubKey, hkeyDest) {
        static fReserved := 0 ;Reserved parameters must always be NULL

        pszSrcSubKey := pszSrcSubKey is String? StrPtr(pszSrcSubKey) : pszSrcSubKey

        result := DllCall("SHLWAPI.dll\SHCopyKeyA", "ptr", hkeySrc, "ptr", pszSrcSubKey, "ptr", hkeyDest, "uint", fReserved, "uint")
        return result
    }

    /**
     * Recursively copies the subkeys and values of the source subkey to the destination key. SHCopyKey does not copy the security attributes of the keys. (Unicode)
     * @remarks
     * <div class="alert"><b>Important</b>This function does not duplicate the security attributes of the keys and values that it copies. Rather, all security attributes in the destination key are the default attributes.</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHCopyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkeySrc Type: <b>HKEY</b>
     * 
     * A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).
     * @param {Pointer<Char>} pszSrcSubKey Type: <b>LPCTSTR</b>
     * 
     * The subkey whose subkeys and values are to be copied.
     * @param {Pointer<Void>} hkeyDest Type: <b>HKEY</b>
     * 
     * The destination key.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcopykeyw
     * @since windows5.0
     */
    static SHCopyKeyW(hkeySrc, pszSrcSubKey, hkeyDest) {
        static fReserved := 0 ;Reserved parameters must always be NULL

        pszSrcSubKey := pszSrcSubKey is String? StrPtr(pszSrcSubKey) : pszSrcSubKey

        result := DllCall("SHLWAPI.dll\SHCopyKeyW", "ptr", hkeySrc, "ptr", pszSrcSubKey, "ptr", hkeyDest, "uint", fReserved, "uint")
        return result
    }

    /**
     * Retrieves a file path from the registry, expanding environment variables as needed. (ANSI)
     * @remarks
     * The data type of the specified registry value must be either <b>REG_EXPAND_SZ</b> or <b>REG_SZ</b>. If it has the <b>REG_EXPAND_SZ</b> type, any environment variables in the registry string will be expanded with <a href="https://docs.microsoft.com/windows/desktop/api/rrascfg/nn-rrascfg-ieapproviderconfig">ExpandEnvironmentStrings</a>. If it has the <b>REG_SZ</b> data type, environment variables will not be expanded and the string pointed to by <i>pszPath</i> will be identical to the string in the registry.
     * 
     * The following environment strings will be replaced by their equivalent path.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Environment string</th>
     * <th>Folder</th>
     * </tr>
     * <tr>
     * <td>%USERPROFILE%
     * 						</td>
     * <td>The current user's profile folder</td>
     * </tr>
     * <tr>
     * <td>%ALLUSERSPROFILE%
     * 						</td>
     * <td>The All Users profile folder</td>
     * </tr>
     * <tr>
     * <td>%ProgramFiles%
     * 						</td>
     * <td>The Program Files folder</td>
     * </tr>
     * <tr>
     * <td>%SystemRoot%
     * 						</td>
     * <td>The system root folder</td>
     * </tr>
     * <tr>
     * <td>%SystemDrive%
     * 						</td>
     * <td>The system drive letter</td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>%USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegGetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hKey Type: <b>HKEY</b>
     * 
     * A handle to a key that is currently open, or a registry root key.
     * @param {Pointer<Byte>} pcszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the name of the subkey.
     * @param {Pointer<Byte>} pcszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.
     * @param {Pointer<Byte>} pszPath Type: <b>LPTSTR</b>
     * 
     * A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetpatha
     * @since windows5.0
     */
    static SHRegGetPathA(hKey, pcszSubKey, pcszValue, pszPath, dwFlags) {
        pcszSubKey := pcszSubKey is String? StrPtr(pcszSubKey) : pcszSubKey
        pcszValue := pcszValue is String? StrPtr(pcszValue) : pcszValue
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\SHRegGetPathA", "ptr", hKey, "ptr", pcszSubKey, "ptr", pcszValue, "ptr", pszPath, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Retrieves a file path from the registry, expanding environment variables as needed. (Unicode)
     * @remarks
     * The data type of the specified registry value must be either <b>REG_EXPAND_SZ</b> or <b>REG_SZ</b>. If it has the <b>REG_EXPAND_SZ</b> type, any environment variables in the registry string will be expanded with <a href="https://docs.microsoft.com/windows/desktop/api/rrascfg/nn-rrascfg-ieapproviderconfig">ExpandEnvironmentStrings</a>. If it has the <b>REG_SZ</b> data type, environment variables will not be expanded and the string pointed to by <i>pszPath</i> will be identical to the string in the registry.
     * 
     * The following environment strings will be replaced by their equivalent path.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Environment string</th>
     * <th>Folder</th>
     * </tr>
     * <tr>
     * <td>%USERPROFILE%
     * 						</td>
     * <td>The current user's profile folder</td>
     * </tr>
     * <tr>
     * <td>%ALLUSERSPROFILE%
     * 						</td>
     * <td>The All Users profile folder</td>
     * </tr>
     * <tr>
     * <td>%ProgramFiles%
     * 						</td>
     * <td>The Program Files folder</td>
     * </tr>
     * <tr>
     * <td>%SystemRoot%
     * 						</td>
     * <td>The system root folder</td>
     * </tr>
     * <tr>
     * <td>%SystemDrive%
     * 						</td>
     * <td>The system drive letter</td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>%USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegGetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hKey Type: <b>HKEY</b>
     * 
     * A handle to a key that is currently open, or a registry root key.
     * @param {Pointer<Char>} pcszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the name of the subkey.
     * @param {Pointer<Char>} pcszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.
     * @param {Pointer<Char>} pszPath Type: <b>LPTSTR</b>
     * 
     * A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetpathw
     * @since windows5.0
     */
    static SHRegGetPathW(hKey, pcszSubKey, pcszValue, pszPath, dwFlags) {
        pcszSubKey := pcszSubKey is String? StrPtr(pcszSubKey) : pcszSubKey
        pcszValue := pcszValue is String? StrPtr(pcszValue) : pcszValue
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\SHRegGetPathW", "ptr", hKey, "ptr", pcszSubKey, "ptr", pcszValue, "ptr", pszPath, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry. (ANSI)
     * @remarks
     * For Windows2000, <b>SHRegSetPath</b> uses <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-pathunexpandenvstringsa">PathUnExpandEnvStrings</a> to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the <b>REG_EXPAND_SZ</b> data type. Otherwise, it will be set with the <b>REG_SZ</b> data type.
     * 
     * The following folder paths will be replaced by their equivalent environment string.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Folder</th>
     * <th>Environment string</th>
     * </tr>
     * <tr>
     * <td>The current user's profile folder</td>
     * <td>%USERPROFILE%
     * 						</td>
     * </tr>
     * <tr>
     * <td>The All Users profile folder</td>
     * <td>%ALLUSERSPROFILE%
     * 						</td>
     * </tr>
     * <tr>
     * <td>The Program Files folder</td>
     * <td>%ProgramFiles%
     * 						</td>
     * </tr>
     * <tr>
     * <td>The system root folder</td>
     * <td>%SystemRoot%
     * 						</td>
     * </tr>
     * <tr>
     * <td>The system drive letter</td>
     * <td>%SystemDrive%
     * 						</td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>%USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</div>
     * <div></div>
     * The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows95 or Windows98. The %ProgramFiles% variable is new for Windows2000, and will typically not be set on Microsoft WindowsNT4.0 systems.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegSetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hKey Type: <b>HKEY</b>
     * 
     * A handle to a key that is currently open, or a registry root key.
     * @param {Pointer<Byte>} pcszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.
     * @param {Pointer<Byte>} pcszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the value to hold the path string.
     * @param {Pointer<Byte>} pcszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with a fully qualified file path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregsetpatha
     * @since windows5.0
     */
    static SHRegSetPathA(hKey, pcszSubKey, pcszValue, pcszPath, dwFlags) {
        pcszSubKey := pcszSubKey is String? StrPtr(pcszSubKey) : pcszSubKey
        pcszValue := pcszValue is String? StrPtr(pcszValue) : pcszValue
        pcszPath := pcszPath is String? StrPtr(pcszPath) : pcszPath

        result := DllCall("SHLWAPI.dll\SHRegSetPathA", "ptr", hKey, "ptr", pcszSubKey, "ptr", pcszValue, "ptr", pcszPath, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry. (Unicode)
     * @remarks
     * For Windows2000, <b>SHRegSetPath</b> uses <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-pathunexpandenvstringsa">PathUnExpandEnvStrings</a> to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the <b>REG_EXPAND_SZ</b> data type. Otherwise, it will be set with the <b>REG_SZ</b> data type.
     * 
     * The following folder paths will be replaced by their equivalent environment string.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Folder</th>
     * <th>Environment string</th>
     * </tr>
     * <tr>
     * <td>The current user's profile folder</td>
     * <td>%USERPROFILE%
     * 						</td>
     * </tr>
     * <tr>
     * <td>The All Users profile folder</td>
     * <td>%ALLUSERSPROFILE%
     * 						</td>
     * </tr>
     * <tr>
     * <td>The Program Files folder</td>
     * <td>%ProgramFiles%
     * 						</td>
     * </tr>
     * <tr>
     * <td>The system root folder</td>
     * <td>%SystemRoot%
     * 						</td>
     * </tr>
     * <tr>
     * <td>The system drive letter</td>
     * <td>%SystemDrive%
     * 						</td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>%USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</div>
     * <div></div>
     * The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows95 or Windows98. The %ProgramFiles% variable is new for Windows2000, and will typically not be set on Microsoft WindowsNT4.0 systems.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegSetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hKey Type: <b>HKEY</b>
     * 
     * A handle to a key that is currently open, or a registry root key.
     * @param {Pointer<Char>} pcszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.
     * @param {Pointer<Char>} pcszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the value to hold the path string.
     * @param {Pointer<Char>} pcszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with a fully qualified file path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregsetpathw
     * @since windows5.0
     */
    static SHRegSetPathW(hKey, pcszSubKey, pcszValue, pcszPath, dwFlags) {
        pcszSubKey := pcszSubKey is String? StrPtr(pcszSubKey) : pcszSubKey
        pcszValue := pcszValue is String? StrPtr(pcszValue) : pcszValue
        pcszPath := pcszPath is String? StrPtr(pcszPath) : pcszPath

        result := DllCall("SHLWAPI.dll\SHRegSetPathW", "ptr", hKey, "ptr", pcszSubKey, "ptr", pcszValue, "ptr", pcszPath, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * If you want to write values to the new key, use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregwriteusvaluea">SHRegWriteUSValue</a> to write each value, passing the <b>HUSKEY</b> handle that is returned through <i>phNewUSKey</i>. When you have finished, close the user-specific registry key with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregcloseuskey">SHRegCloseUSKey</a>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegCreateUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened.
     * @param {Integer} samDesired Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a></b>
     * 
     * The desired security access. For more information on security access, see <a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a>.
     * @param {Pointer} hRelativeUSKey Type: <b>HUSKEY</b>
     * 
     * The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.
     * @param {Pointer<IntPtr>} phNewUSKey Type: <b>PHUSKEY</b>
     * 
     * A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregcreateuskeya
     * @since windows5.0
     */
    static SHRegCreateUSKeyA(pszPath, samDesired, hRelativeUSKey, phNewUSKey, dwFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\SHRegCreateUSKeyA", "ptr", pszPath, "uint", samDesired, "ptr", hRelativeUSKey, "ptr*", phNewUSKey, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * If you want to write values to the new key, use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregwriteusvaluea">SHRegWriteUSValue</a> to write each value, passing the <b>HUSKEY</b> handle that is returned through <i>phNewUSKey</i>. When you have finished, close the user-specific registry key with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregcloseuskey">SHRegCloseUSKey</a>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegCreateUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pwzPath TBD
     * @param {Integer} samDesired Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a></b>
     * 
     * The desired security access. For more information on security access, see <a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a>.
     * @param {Pointer} hRelativeUSKey Type: <b>HUSKEY</b>
     * 
     * The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.
     * @param {Pointer<IntPtr>} phNewUSKey Type: <b>PHUSKEY</b>
     * 
     * A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregcreateuskeyw
     * @since windows5.0
     */
    static SHRegCreateUSKeyW(pwzPath, samDesired, hRelativeUSKey, phNewUSKey, dwFlags) {
        pwzPath := pwzPath is String? StrPtr(pwzPath) : pwzPath

        result := DllCall("SHLWAPI.dll\SHRegCreateUSKeyW", "ptr", pwzPath, "uint", samDesired, "ptr", hRelativeUSKey, "ptr*", phNewUSKey, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegOpenUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey.
     * @param {Integer} samDesired Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a></b>
     * 
     * The desired security access. For more information on security access, see <a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a>.
     * @param {Pointer} hRelativeUSKey Type: <b>HUSKEY</b>
     * 
     * The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.
     * @param {Pointer<IntPtr>} phNewUSKey Type: <b>PHUSKEY</b>
     * 
     * A pointer to the handle of the opened key.
     * @param {Integer} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregopenuskeya
     * @since windows5.0
     */
    static SHRegOpenUSKeyA(pszPath, samDesired, hRelativeUSKey, phNewUSKey, fIgnoreHKCU) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\SHRegOpenUSKeyA", "ptr", pszPath, "uint", samDesired, "ptr", hRelativeUSKey, "ptr*", phNewUSKey, "int", fIgnoreHKCU, "uint")
        return result
    }

    /**
     * Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegOpenUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pwzPath TBD
     * @param {Integer} samDesired Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a></b>
     * 
     * The desired security access. For more information on security access, see <a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a>.
     * @param {Pointer} hRelativeUSKey Type: <b>HUSKEY</b>
     * 
     * The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.
     * @param {Pointer<IntPtr>} phNewUSKey Type: <b>PHUSKEY</b>
     * 
     * A pointer to the handle of the opened key.
     * @param {Integer} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregopenuskeyw
     * @since windows5.0
     */
    static SHRegOpenUSKeyW(pwzPath, samDesired, hRelativeUSKey, phNewUSKey, fIgnoreHKCU) {
        pwzPath := pwzPath is String? StrPtr(pwzPath) : pwzPath

        result := DllCall("SHLWAPI.dll\SHRegOpenUSKeyW", "ptr", pwzPath, "uint", samDesired, "ptr", hRelativeUSKey, "ptr*", phNewUSKey, "int", fIgnoreHKCU, "uint")
        return result
    }

    /**
     * Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegQueryUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value returns from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurs and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.
     * 
     * If you only need to read a single value, <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shreggetusvaluea">SHRegGetUSValue</a> will both open the key and return the value. To use <b>SHRegQueryUSValue</b>, you must first open the key with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a>. However, once the key is opened, you can use <b>SHRegQueryUSValue</b> as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to <b>SHRegQueryUSValue</b> is usually more efficient than <b>SHRegGetUSValue</b>, as the key is only opened once.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegQueryUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD*</b>
     * 
     * A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>LPVOID*</b>
     * 
     * A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD*</b>
     * 
     * A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.
     * @param {Integer} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer} pvDefaultData Type: <b>LPVOID*</b>
     * 
     * A pointer to the default data.
     * @param {Integer} dwDefaultDataSize Type: <b>DWORD</b>
     * 
     * The length, in bytes, of the default data.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregqueryusvaluea
     * @since windows5.0
     */
    static SHRegQueryUSValueA(hUSKey, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize) {
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegQueryUSValueA", "ptr", hUSKey, "ptr", pszValue, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "int", fIgnoreHKCU, "ptr", pvDefaultData, "uint", dwDefaultDataSize, "uint")
        return result
    }

    /**
     * Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegQueryUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value returns from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurs and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.
     * 
     * If you only need to read a single value, <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shreggetusvaluea">SHRegGetUSValue</a> will both open the key and return the value. To use <b>SHRegQueryUSValue</b>, you must first open the key with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a>. However, once the key is opened, you can use <b>SHRegQueryUSValue</b> as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to <b>SHRegQueryUSValue</b> is usually more efficient than <b>SHRegGetUSValue</b>, as the key is only opened once.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegQueryUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD*</b>
     * 
     * A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>LPVOID*</b>
     * 
     * A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD*</b>
     * 
     * A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.
     * @param {Integer} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer} pvDefaultData Type: <b>LPVOID*</b>
     * 
     * A pointer to the default data.
     * @param {Integer} dwDefaultDataSize Type: <b>DWORD</b>
     * 
     * The length, in bytes, of the default data.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregqueryusvaluew
     * @since windows5.0
     */
    static SHRegQueryUSValueW(hUSKey, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize) {
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegQueryUSValueW", "ptr", hUSKey, "ptr", pszValue, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "int", fIgnoreHKCU, "ptr", pvDefaultData, "uint", dwDefaultDataSize, "uint")
        return result
    }

    /**
     * Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * To use <b>SHRegWriteUSValue</b>, you must first open the key with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a>. Once the key is opened, you can use <b>SHRegWriteUSValue</b> as many times as necessary.
     * 
     * If you only need to write a single value, you should use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregsetusvaluea">SHRegSetUSValue</a>, which both opens the key and writes the value.
     * 
     * If you need to write more than one value on the same key, multiple calls to <b>SHRegWriteUSValue</b> are usually more efficient than <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregsetusvaluea">SHRegSetUSValue</a>, because the key is only opened once.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegWriteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey, it will be added.
     * 
     *                         
     * 
     * If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for the subkey's Default value.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.
     * @param {Pointer} pvData Type: <b>const void*</b>
     * 
     * A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\\mydir\\myfile" to store the string "C:\mydir\myfile".
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregwriteusvaluea
     * @since windows5.0
     */
    static SHRegWriteUSValueA(hUSKey, pszValue, dwType, pvData, cbData, dwFlags) {
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegWriteUSValueA", "ptr", hUSKey, "ptr", pszValue, "uint", dwType, "ptr", pvData, "uint", cbData, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * To use <b>SHRegWriteUSValue</b>, you must first open the key with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a>. Once the key is opened, you can use <b>SHRegWriteUSValue</b> as many times as necessary.
     * 
     * If you only need to write a single value, you should use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregsetusvaluea">SHRegSetUSValue</a>, which both opens the key and writes the value.
     * 
     * If you need to write more than one value on the same key, multiple calls to <b>SHRegWriteUSValue</b> are usually more efficient than <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregsetusvaluea">SHRegSetUSValue</a>, because the key is only opened once.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegWriteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Char>} pwzValue TBD
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.
     * @param {Pointer} pvData Type: <b>const void*</b>
     * 
     * A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\\mydir\\myfile" to store the string "C:\mydir\myfile".
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregwriteusvaluew
     * @since windows5.0
     */
    static SHRegWriteUSValueW(hUSKey, pwzValue, dwType, pvData, cbData, dwFlags) {
        pwzValue := pwzValue is String? StrPtr(pwzValue) : pwzValue

        result := DllCall("SHLWAPI.dll\SHRegWriteUSValueW", "ptr", hUSKey, "ptr", pwzValue, "uint", dwType, "ptr", pvData, "uint", cbData, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegDeleteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to the null-terminated string that names the value to remove.
     * @param {Integer} delRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a> that specifies from which base key the value will be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregdeleteusvaluea
     * @since windows5.0
     */
    static SHRegDeleteUSValueA(hUSKey, pszValue, delRegFlags) {
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegDeleteUSValueA", "ptr", hUSKey, "ptr", pszValue, "int", delRegFlags, "uint")
        return result
    }

    /**
     * Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegDeleteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Char>} pwzValue TBD
     * @param {Integer} delRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a> that specifies from which base key the value will be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregdeleteusvaluew
     * @since windows5.0
     */
    static SHRegDeleteUSValueW(hUSKey, pwzValue, delRegFlags) {
        pwzValue := pwzValue is String? StrPtr(pwzValue) : pwzValue

        result := DllCall("SHLWAPI.dll\SHRegDeleteUSValueW", "ptr", hUSKey, "ptr", pwzValue, "int", delRegFlags, "uint")
        return result
    }

    /**
     * Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegDeleteEmptyUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Char>} pwzSubKey TBD
     * @param {Integer} delRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a> that specifies from which base key the subkey will be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregdeleteemptyuskeyw
     * @since windows5.0
     */
    static SHRegDeleteEmptyUSKeyW(hUSKey, pwzSubKey, delRegFlags) {
        pwzSubKey := pwzSubKey is String? StrPtr(pwzSubKey) : pwzSubKey

        result := DllCall("SHLWAPI.dll\SHRegDeleteEmptyUSKeyW", "ptr", hUSKey, "ptr", pwzSubKey, "int", delRegFlags, "uint")
        return result
    }

    /**
     * Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegDeleteEmptyUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCSTR</b>
     * 
     * A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted.
     * @param {Integer} delRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a> that specifies from which base key the subkey will be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregdeleteemptyuskeya
     * @since windows5.0
     */
    static SHRegDeleteEmptyUSKeyA(hUSKey, pszSubKey, delRegFlags) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHRegDeleteEmptyUSKeyA", "ptr", hUSKey, "ptr", pszSubKey, "int", delRegFlags, "uint")
        return result
    }

    /**
     * Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegEnumUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {Pointer<Byte>} pszName Type: <b>LPTSTR</b>
     * 
     * A pointer to a character buffer that receives the enumerated key name.
     * @param {Pointer<UInt32>} pcchName Type: <b>LPDWORD</b>
     * 
     * A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the enumeration should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregenumuskeya
     * @since windows5.0
     */
    static SHRegEnumUSKeyA(hUSKey, dwIndex, pszName, pcchName, enumRegFlags) {
        pszName := pszName is String? StrPtr(pszName) : pszName

        result := DllCall("SHLWAPI.dll\SHRegEnumUSKeyA", "ptr", hUSKey, "uint", dwIndex, "ptr", pszName, "uint*", pcchName, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegEnumUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {Pointer<Char>} pwzName TBD
     * @param {Pointer<UInt32>} pcchName Type: <b>LPDWORD</b>
     * 
     * A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the enumeration should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregenumuskeyw
     * @since windows5.0
     */
    static SHRegEnumUSKeyW(hUSKey, dwIndex, pwzName, pcchName, enumRegFlags) {
        pwzName := pwzName is String? StrPtr(pwzName) : pwzName

        result := DllCall("SHLWAPI.dll\SHRegEnumUSKeyW", "ptr", hUSKey, "uint", dwIndex, "ptr", pwzName, "uint*", pcchName, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegEnumUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSkey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {Pointer<Byte>} pszValueName Type: <b>LPTSTR</b>
     * 
     * A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.
     * @param {Pointer<UInt32>} pcchValueName Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a>.
     * @param {Pointer} pvData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the enumeration should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregenumusvaluea
     * @since windows5.0
     */
    static SHRegEnumUSValueA(hUSkey, dwIndex, pszValueName, pcchValueName, pdwType, pvData, pcbData, enumRegFlags) {
        pszValueName := pszValueName is String? StrPtr(pszValueName) : pszValueName

        result := DllCall("SHLWAPI.dll\SHRegEnumUSValueA", "ptr", hUSkey, "uint", dwIndex, "ptr", pszValueName, "uint*", pcchValueName, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegEnumUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSkey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {Pointer<Char>} pszValueName Type: <b>LPTSTR</b>
     * 
     * A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.
     * @param {Pointer<UInt32>} pcchValueName Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.
     * @param {Pointer<UInt32>} pdwType Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a>.
     * @param {Pointer} pvData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<UInt32>} pcbData Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the enumeration should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregenumusvaluew
     * @since windows5.0
     */
    static SHRegEnumUSValueW(hUSkey, dwIndex, pszValueName, pcchValueName, pdwType, pvData, pcbData, enumRegFlags) {
        pszValueName := pszValueName is String? StrPtr(pszValueName) : pszValueName

        result := DllCall("SHLWAPI.dll\SHRegEnumUSValueW", "ptr", hUSkey, "uint", dwIndex, "ptr", pszValueName, "uint*", pcchValueName, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegQueryInfoUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<UInt32>} pcSubKeys Type: <b>LPDWORD</b>
     * 
     * A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.
     * @param {Pointer<UInt32>} pcchMaxSubKeyLen Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.
     * @param {Pointer<UInt32>} pcValues Type: <b>LPDWORD</b>
     * 
     * A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.
     * @param {Pointer<UInt32>} pcchMaxValueNameLen Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the query should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregqueryinfouskeya
     * @since windows5.0
     */
    static SHRegQueryInfoUSKeyA(hUSKey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen, enumRegFlags) {
        result := DllCall("SHLWAPI.dll\SHRegQueryInfoUSKeyA", "ptr", hUSKey, "uint*", pcSubKeys, "uint*", pcchMaxSubKeyLen, "uint*", pcValues, "uint*", pcchMaxValueNameLen, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegQueryInfoUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<UInt32>} pcSubKeys Type: <b>LPDWORD</b>
     * 
     * A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.
     * @param {Pointer<UInt32>} pcchMaxSubKeyLen Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.
     * @param {Pointer<UInt32>} pcValues Type: <b>LPDWORD</b>
     * 
     * A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.
     * @param {Pointer<UInt32>} pcchMaxValueNameLen Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the query should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregqueryinfouskeyw
     * @since windows5.0
     */
    static SHRegQueryInfoUSKeyW(hUSKey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen, enumRegFlags) {
        result := DllCall("SHLWAPI.dll\SHRegQueryInfoUSKeyW", "ptr", hUSKey, "uint*", pcSubKeys, "uint*", pcchMaxSubKeyLen, "uint*", pcValues, "uint*", pcchMaxValueNameLen, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Closes a handle to a user-specific registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. Use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregcloseuskey
     * @since windows5.0
     */
    static SHRegCloseUSKey(hUSKey) {
        result := DllCall("SHLWAPI.dll\SHRegCloseUSKey", "ptr", hUSKey, "uint")
        return result
    }

    /**
     * Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegGetUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegGetUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value is returned from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurred and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.
     * 
     * This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> and then use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregqueryusvaluea">SHRegQueryUSValue</a> to retrieve the data.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegGetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.
     * @param {Pointer<UInt32>} pdwType Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the value's data.
     * @param {Pointer<UInt32>} pcbData Type: <b>DWORD*</b>
     * 
     * A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.
     * @param {Integer} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer} pvDefaultData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the value's default data.
     * @param {Integer} dwDefaultDataSize Type: <b>DWORD</b>
     * 
     * The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetusvaluea
     * @since windows5.0
     */
    static SHRegGetUSValueA(pszSubKey, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegGetUSValueA", "ptr", pszSubKey, "ptr", pszValue, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "int", fIgnoreHKCU, "ptr", pvDefaultData, "uint", dwDefaultDataSize, "uint")
        return result
    }

    /**
     * Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegGetUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegGetUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value is returned from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurred and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.
     * 
     * This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> and then use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregqueryusvaluea">SHRegQueryUSValue</a> to retrieve the data.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegGetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.
     * @param {Pointer<UInt32>} pdwType Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the value's data.
     * @param {Pointer<UInt32>} pcbData Type: <b>DWORD*</b>
     * 
     * A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.
     * @param {Integer} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer} pvDefaultData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the value's default data.
     * @param {Integer} dwDefaultDataSize Type: <b>DWORD</b>
     * 
     * The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetusvaluew
     * @since windows5.0
     */
    static SHRegGetUSValueW(pszSubKey, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegGetUSValueW", "ptr", pszSubKey, "ptr", pszValue, "uint*", pdwType, "ptr", pvData, "uint*", pcbData, "int", fIgnoreHKCU, "ptr", pvDefaultData, "uint", dwDefaultDataSize, "uint")
        return result
    }

    /**
     * Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> and then use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregwriteusvaluea">SHRegWriteUSValue</a> to write the data.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegSetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the name of the value.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID*</b>
     * 
     *  Apointer to a null-terminated string that contains the value to be set for the specified key.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags indicating where the data should be written.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregsetusvaluea
     * @since windows5.0
     */
    static SHRegSetUSValueA(pszSubKey, pszValue, dwType, pvData, cbData, dwFlags) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegSetUSValueA", "ptr", pszSubKey, "ptr", pszValue, "uint", dwType, "ptr", pvData, "uint", cbData, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> and then use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregwriteusvaluea">SHRegWriteUSValue</a> to write the data.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegSetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pwzSubKey TBD
     * @param {Pointer<Char>} pwzValue TBD
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID*</b>
     * 
     *  Apointer to a null-terminated string that contains the value to be set for the specified key.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags indicating where the data should be written.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shregsetusvaluew
     * @since windows5.0
     */
    static SHRegSetUSValueW(pwzSubKey, pwzValue, dwType, pvData, cbData, dwFlags) {
        pwzSubKey := pwzSubKey is String? StrPtr(pwzSubKey) : pwzSubKey
        pwzValue := pwzValue is String? StrPtr(pwzValue) : pwzValue

        result := DllCall("SHLWAPI.dll\SHRegSetUSValueW", "ptr", pwzSubKey, "ptr", pwzValue, "uint", dwType, "ptr", pvData, "uint", cbData, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Reads a numeric string value from the registry and converts it to an integer.
     * @remarks
     * Prior to Windows2000 Service Pack3 (SP3), Windows Server2003 Service Pack1 (SP1), and WindowsXP, <b>SHRegGetIntW</b> was not exported by name. On those systems you must load it directly from Shlwapi.dll as ordinal 280.
     * 
     * This function is only available in a Unicode version. ANSI is not supported.
     * @param {Pointer<Void>} hk Type: <b>HKEY</b>
     * 
     * A handle to the registry key that specifies the value to be read.
     * @param {Pointer<Char>} pwzKey Type: <b>LPCWSTR</b>
     * 
     * A pointer to a string value that specifies the name of the value to be read. The string must be null-terminated.
     * @param {Integer} iDefault Type: <b>int</b>
     * 
     * An <b>int</b> that specifies the value returned if the registry value cannot be retrieved successfully.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the converted string as an <b>int</b>, or the default value specified by <i>nDefault</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetintw
     * @since windows5.0
     */
    static SHRegGetIntW(hk, pwzKey, iDefault) {
        pwzKey := pwzKey is String? StrPtr(pwzKey) : pwzKey

        result := DllCall("SHLWAPI.dll\SHRegGetIntW", "ptr", hk, "ptr", pwzKey, "int", iDefault, "int")
        return result
    }

    /**
     * Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegGetBoolUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.
     * @param {Integer} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * A variable that specifies which key to look under. When set to <b>TRUE</b>, <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shreggetusvaluea">SHRegGetUSValue</a> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Integer} fDefault Type: <b>BOOL</b>
     * 
     * A value that is returned if there is no registry value.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns either the value from the registry, or <i>fDefault</i> if none is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetboolusvaluea
     * @since windows5.0
     */
    static SHRegGetBoolUSValueA(pszSubKey, pszValue, fIgnoreHKCU, fDefault) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegGetBoolUSValueA", "ptr", pszSubKey, "ptr", pszValue, "int", fIgnoreHKCU, "int", fDefault, "int")
        return result
    }

    /**
     * Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE). (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHRegGetBoolUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.
     * @param {Integer} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * A variable that specifies which key to look under. When set to <b>TRUE</b>, <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shreggetusvaluea">SHRegGetUSValue</a> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Integer} fDefault Type: <b>BOOL</b>
     * 
     * A value that is returned if there is no registry value.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns either the value from the registry, or <i>fDefault</i> if none is found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreggetboolusvaluew
     * @since windows5.0
     */
    static SHRegGetBoolUSValueW(pszSubKey, pszValue, fIgnoreHKCU, fDefault) {
        pszSubKey := pszSubKey is String? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegGetBoolUSValueW", "ptr", pszSubKey, "ptr", pszValue, "int", fIgnoreHKCU, "int", fDefault, "int")
        return result
    }

    /**
     * Returns a pointer to an IQueryAssociations object.
     * @remarks
     * As of WindowsVista, <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-assoccreateforclasses">AssocCreateForClasses</a> is preferred to <b>AssocCreate</b>.
     * @param {Pointer<Guid>} clsid Type: <b>CLSID</b>
     * 
     * The CLSID of the object that exposes the interface. This parameter must be set to CLSID_QueryAssociations, which is defined in Shlguid.h.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the IID IID_IQueryAssociations, which is defined in Shlguid.h.
     * @param {Pointer<Void>} ppv Type: <b>void*</b>
     * 
     * When this method returns, contains the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface pointer requested in <i>riid</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-assoccreate
     * @since windows5.0
     */
    static AssocCreate(clsid, riid, ppv) {
        result := DllCall("SHLWAPI.dll\AssocCreate", "ptr", clsid, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Searches for and retrieves a file or protocol association-related string from the registry. (AssocQueryStringA)
     * @remarks
     * This function is a wrapper for the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface. The <b>AssocQueryString</b> function is intended to simplify the process of using <b>IQueryAssociations</b> interface.
     * 
     * Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines AssocQueryString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} str Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a> value that specifies the type of string that is to be returned.
     * @param {Pointer<Byte>} pszAssoc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.
     * @param {Pointer<Byte>} pszExtra Type: <b>LPCTSTR</b>
     * 
     * An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {Pointer<Byte>} pszOut Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
     * @param {Pointer<UInt32>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.
     * 
     * If the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-url_scheme">ASSOCF_NOTRUNCATE</a> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.
     * 
     * If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM error value, including the following:
     *     
     *                         
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>S_OK</td>
     * <td>Success.</td>
     * </tr>
     * <tr>
     * <td>E_POINTER</td>
     * <td>The <i>pszOut</i> buffer is too small to hold the entire string.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td><i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-assocquerystringa
     * @since windows5.0
     */
    static AssocQueryStringA(flags, str, pszAssoc, pszExtra, pszOut, pcchOut) {
        pszAssoc := pszAssoc is String? StrPtr(pszAssoc) : pszAssoc
        pszExtra := pszExtra is String? StrPtr(pszExtra) : pszExtra
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\AssocQueryStringA", "uint", flags, "int", str, "ptr", pszAssoc, "ptr", pszExtra, "ptr", pszOut, "uint*", pcchOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Searches for and retrieves a file or protocol association-related string from the registry. (AssocQueryStringW)
     * @remarks
     * This function is a wrapper for the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface. The <b>AssocQueryString</b> function is intended to simplify the process of using <b>IQueryAssociations</b> interface.
     * 
     * Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines AssocQueryString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} str Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a> value that specifies the type of string that is to be returned.
     * @param {Pointer<Char>} pszAssoc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.
     * @param {Pointer<Char>} pszExtra Type: <b>LPCTSTR</b>
     * 
     * An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {Pointer<Char>} pszOut Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
     * @param {Pointer<UInt32>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.
     * 
     * If the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-url_scheme">ASSOCF_NOTRUNCATE</a> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.
     * 
     * If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM error value, including the following:
     *     
     *                         
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>S_OK</td>
     * <td>Success.</td>
     * </tr>
     * <tr>
     * <td>E_POINTER</td>
     * <td>The <i>pszOut</i> buffer is too small to hold the entire string.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td><i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-assocquerystringw
     * @since windows5.0
     */
    static AssocQueryStringW(flags, str, pszAssoc, pszExtra, pszOut, pcchOut) {
        pszAssoc := pszAssoc is String? StrPtr(pszAssoc) : pszAssoc
        pszExtra := pszExtra is String? StrPtr(pszExtra) : pszExtra
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\AssocQueryStringW", "uint", flags, "int", str, "ptr", pszAssoc, "ptr", pszExtra, "ptr", pszOut, "uint*", pcchOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Searches for and retrieves a file association-related string from the registry starting from a specified key. (ANSI)
     * @remarks
     * This function is a wrapper for the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see <b>IQueryAssociations</b>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines AssocQueryStringByKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} str Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a> value that specifies the type of string that is to be returned.
     * @param {Pointer<Void>} hkAssoc Type: <b>HKEY</b>
     * 
     * The HKEY value of the key that will be used as a root key. The search looks only below this key.
     * @param {Pointer<Byte>} pszExtra Type: <b>LPCTSTR</b>
     * 
     * A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {Pointer<Byte>} pszOut Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
     * @param {Pointer<UInt32>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer. 
     * 
     *                     
     * 
     * If the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-url_scheme">ASSOCF_NOTRUNCATE</a> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.
     * 
     * If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM error value, including the following:
     * 
     *                     
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>S_OK</td>
     * <td>Success.</td>
     * </tr>
     * <tr>
     * <td>E_POINTER</td>
     * <td>The <i>pszOut</i> buffer is too small to hold the entire string.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td><i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-assocquerystringbykeya
     * @since windows5.0
     */
    static AssocQueryStringByKeyA(flags, str, hkAssoc, pszExtra, pszOut, pcchOut) {
        pszExtra := pszExtra is String? StrPtr(pszExtra) : pszExtra
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\AssocQueryStringByKeyA", "uint", flags, "int", str, "ptr", hkAssoc, "ptr", pszExtra, "ptr", pszOut, "uint*", pcchOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Searches for and retrieves a file association-related string from the registry starting from a specified key. (Unicode)
     * @remarks
     * This function is a wrapper for the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see <b>IQueryAssociations</b>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines AssocQueryStringByKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} str Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a> value that specifies the type of string that is to be returned.
     * @param {Pointer<Void>} hkAssoc Type: <b>HKEY</b>
     * 
     * The HKEY value of the key that will be used as a root key. The search looks only below this key.
     * @param {Pointer<Char>} pszExtra Type: <b>LPCTSTR</b>
     * 
     * A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {Pointer<Char>} pszOut Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
     * @param {Pointer<UInt32>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer. 
     * 
     *                     
     * 
     * If the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-url_scheme">ASSOCF_NOTRUNCATE</a> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.
     * 
     * If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM error value, including the following:
     * 
     *                     
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>S_OK</td>
     * <td>Success.</td>
     * </tr>
     * <tr>
     * <td>E_POINTER</td>
     * <td>The <i>pszOut</i> buffer is too small to hold the entire string.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td><i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-assocquerystringbykeyw
     * @since windows5.0
     */
    static AssocQueryStringByKeyW(flags, str, hkAssoc, pszExtra, pszOut, pcchOut) {
        pszExtra := pszExtra is String? StrPtr(pszExtra) : pszExtra
        pszOut := pszOut is String? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\AssocQueryStringByKeyW", "uint", flags, "int", str, "ptr", hkAssoc, "ptr", pszExtra, "ptr", pszOut, "uint*", pcchOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Searches for and retrieves a key related to a file or protocol association from the registry. (ANSI)
     * @remarks
     * This function is a wrapper for the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see <b>IQueryAssociations</b>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines AssocQueryKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} key Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assockey">ASSOCKEY</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assockey">ASSOCKEY</a> value that specifies the type of key that is to be returned.
     * @param {Pointer<Byte>} pszAssoc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.
     * @param {Pointer<Byte>} pszExtra Type: <b>LPCTSTR</b>
     * 
     * A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {Pointer<Void>} phkeyOut Type: <b>HKEY*</b>
     * 
     * A pointer to the key's HKEY value.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or a COM error value otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-assocquerykeya
     * @since windows5.0
     */
    static AssocQueryKeyA(flags, key, pszAssoc, pszExtra, phkeyOut) {
        pszAssoc := pszAssoc is String? StrPtr(pszAssoc) : pszAssoc
        pszExtra := pszExtra is String? StrPtr(pszExtra) : pszExtra

        result := DllCall("SHLWAPI.dll\AssocQueryKeyA", "uint", flags, "int", key, "ptr", pszAssoc, "ptr", pszExtra, "ptr", phkeyOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Searches for and retrieves a key related to a file or protocol association from the registry. (Unicode)
     * @remarks
     * This function is a wrapper for the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see <b>IQueryAssociations</b>.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines AssocQueryKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} key Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assockey">ASSOCKEY</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assockey">ASSOCKEY</a> value that specifies the type of key that is to be returned.
     * @param {Pointer<Char>} pszAssoc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.
     * @param {Pointer<Char>} pszExtra Type: <b>LPCTSTR</b>
     * 
     * A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {Pointer<Void>} phkeyOut Type: <b>HKEY*</b>
     * 
     * A pointer to the key's HKEY value.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or a COM error value otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-assocquerykeyw
     * @since windows5.0
     */
    static AssocQueryKeyW(flags, key, pszAssoc, pszExtra, phkeyOut) {
        pszAssoc := pszAssoc is String? StrPtr(pszAssoc) : pszAssoc
        pszExtra := pszExtra is String? StrPtr(pszExtra) : pszExtra

        result := DllCall("SHLWAPI.dll\AssocQueryKeyW", "uint", flags, "int", key, "ptr", pszAssoc, "ptr", pszExtra, "ptr", phkeyOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines whether a file type is considered a potential security risk.
     * @remarks
     * Files that are determined to be potentially dangerous, such as .exe files, should be handled with more care than other files. For example, Windows Internet Explorer version 6.01 or later uses <b>AssocIsDangerous</b> to determine whether it should issue stronger warning language in its download dialog box. <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecuteexa">ShellExecuteEx</a> uses <b>AssocIsDangerous</b> to trigger zone checking using the methods of the <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537130(v=vs.85)">IInternetSecurityManager</a> interface in conjunction with the <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537178(v=vs.85)">URLACTION_SHELL_SHELLEXECUTE</a> flag.
     * 
     * The determination of a file's potential risk is made by checking its type against several sources, including a list of known dangerous types and the presence of the FTA_AlwaysUnsafe flag in the registry. On systems running WindowsXPService Pack1 (SP1) or later or Windows Server2003, it also uses the <a href="https://docs.microsoft.com/windows/desktop/api/winsafer/nf-winsafer-saferiisexecutablefiletype">SaferiIsExecutableFileType</a> function to determine whether a file type is executable.
     * 
     * Applications that can take advantage of <b>AssocIsDangerous</b> include email programs, browsers, chat clients capable of downloading files, and any application that moves files or data from one zone of trust to another.
     * @param {Pointer<Char>} pszAssoc Type: <b>PCWSTR</b>
     * 
     * A pointer to a string that contains the type of file in question. This may be either an extension such as ".exe" or a progid such as "exefile".
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the file type is considered dangerous; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-associsdangerous
     * @since windows5.1.2600
     */
    static AssocIsDangerous(pszAssoc) {
        pszAssoc := pszAssoc is String? StrPtr(pszAssoc) : pszAssoc

        result := DllCall("SHLWAPI.dll\AssocIsDangerous", "ptr", pszAssoc, "int")
        return result
    }

    /**
     * Retrieves a file's perceived type based on its extension.
     * @remarks
     * This function first compares the extension against a hard-coded set of extensions known to Windows. If that search fails to reveal a match, the registered associations under HKEY_CLASSES_ROOT are searched for a key that matches the extension and contains a PerceivedType value. If that value is found, the extension set is again searched for a match. If again no match is found, the perceived type is determined to be PERCEIVED_TYPE_CUSTOM. If either a key that matches the extension or a PerceivedType value is not found, the perceived type is reported as PERCEIVED_TYPE_UNSPECIFIED.
     * @param {Pointer<Char>} pszExt Type: <b>PCWSTR</b>
     * 
     * A pointer to a buffer that contains the file's extension. This should include the leading period, for example ".txt".
     * @param {Pointer<Int32>} ptype Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-perceived">PERCEIVED</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-perceived">PERCEIVED</a> value that indicates the perceived type.
     * @param {Pointer<UInt32>} pflag Type: <b>PERCEIVEDFLAG*</b>
     * @param {Pointer<Char>} ppszType Type: <b>PWSTR*</b>
     * 
     * If the function returns a success code, this contains the address of a pointer to a buffer that receives the perceived type string, for instance "text" or "video". This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-assocgetperceivedtype
     * @since windows5.1.2600
     */
    static AssocGetPerceivedType(pszExt, ptype, pflag, ppszType) {
        pszExt := pszExt is String? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\AssocGetPerceivedType", "ptr", pszExt, "int*", ptype, "uint*", pflag, "ptr", ppszType, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Deprecated. (SHOpenRegStreamA)
     * @remarks
     * The calling application is responsible for calling the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> method of the returned object when that <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> object is no longer needed.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHOpenRegStream as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
     * @param {Pointer<Byte>} pszSubkey Type: <b>LPCTSTR</b>
     * 
     * Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {Pointer<IStream>} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream. 
     * 
     *                     
     * 
     * <div class="alert"><b>Note</b>In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shopenregstream2a">SHOpenRegStream2</a> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shopenregstreama
     * @since windows5.0
     */
    static SHOpenRegStreamA(hkey, pszSubkey, pszValue, grfMode) {
        pszSubkey := pszSubkey is String? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHOpenRegStreamA", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * Deprecated. (SHOpenRegStreamW)
     * @remarks
     * The calling application is responsible for calling the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> method of the returned object when that <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> object is no longer needed.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHOpenRegStream as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
     * @param {Pointer<Char>} pszSubkey Type: <b>LPCTSTR</b>
     * 
     * Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {Pointer<IStream>} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream. 
     * 
     *                     
     * 
     * <div class="alert"><b>Note</b>In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shopenregstream2a">SHOpenRegStream2</a> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shopenregstreamw
     * @since windows5.0
     */
    static SHOpenRegStreamW(hkey, pszSubkey, pszValue, grfMode) {
        pszSubkey := pszSubkey is String? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHOpenRegStreamW", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes SHOpenRegStream. (ANSI)
     * @remarks
     * The calling application is responsible for calling the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> method of the returned object when that <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> object is no longer needed.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHOpenRegStream2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
     * @param {Pointer<Byte>} pszSubkey Type: <b>LPCTSTR</b>
     * 
     * Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.
     * @param {Pointer<Byte>} pszValue Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {Pointer<IStream>} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shopenregstream2a
     * @since windows5.0
     */
    static SHOpenRegStream2A(hkey, pszSubkey, pszValue, grfMode) {
        pszSubkey := pszSubkey is String? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHOpenRegStream2A", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes SHOpenRegStream. (Unicode)
     * @remarks
     * The calling application is responsible for calling the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">Release</a> method of the returned object when that <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> object is no longer needed.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHOpenRegStream2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hkey Type: <b>HKEY</b>
     * 
     * Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
     * @param {Pointer<Char>} pszSubkey Type: <b>LPCTSTR</b>
     * 
     * Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszValue Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {Pointer<IStream>} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shopenregstream2w
     * @since windows5.0
     */
    static SHOpenRegStream2W(hkey, pszSubkey, pszValue, grfMode) {
        pszSubkey := pszSubkey is String? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHOpenRegStream2W", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * SHCreateStreamOnFile may be altered or unavailable. Instead, use SHCreateStreamOnFileEx. (ANSI)
     * @remarks
     * <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shcreatestreamonfileex">SHCreateStreamOnFileEx</a> fully supports all <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> modes and allows the caller to specify file attributes if creating a new file.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHCreateStreamOnFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the file name.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * 
     * One or more <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.
     * @param {Pointer<IStream>} ppstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>**</b>
     * 
     * Receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer for the stream associated with the file.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcreatestreamonfilea
     * @since windows5.1.2600
     */
    static SHCreateStreamOnFileA(pszFile, grfMode, ppstm) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\SHCreateStreamOnFileA", "ptr", pszFile, "uint", grfMode, "ptr", ppstm, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHCreateStreamOnFile may be altered or unavailable. Instead, use SHCreateStreamOnFileEx. (Unicode)
     * @remarks
     * <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shcreatestreamonfileex">SHCreateStreamOnFileEx</a> fully supports all <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> modes and allows the caller to specify file attributes if creating a new file.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHCreateStreamOnFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the file name.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * 
     * One or more <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.
     * @param {Pointer<IStream>} ppstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>**</b>
     * 
     * Receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer for the stream associated with the file.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcreatestreamonfilew
     * @since windows5.1.2600
     */
    static SHCreateStreamOnFileW(pszFile, grfMode, ppstm) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\SHCreateStreamOnFileW", "ptr", pszFile, "uint", grfMode, "ptr", ppstm, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Opens or creates a file and retrieves a stream to read or write to that file.
     * @remarks
     * The <b>SHCreateStreamOnFileEx</b> function extends the semantics of the <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> flags and produces the same effect as calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * 
     * The <i>grfMode</i> and <i>fCreate</i> parameters work together to specify how the function should behave with respect to existing files.
     * 
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th><i>grfMode</i></th>
     * <th><i>fCreate</i></th>
     * <th>File exists?</th>
     * <th>Behavior</th>
     * </tr>
     * <tr>
     * <td><b>STGM_CREATE</b></td>
     * <td>Ignored</td>
     * <td>Yes</td>
     * <td>The file is recreated.</td>
     * </tr>
     * <tr>
     * <td><b>STGM_CREATE</b></td>
     * <td>Ignored</td>
     * <td>No</td>
     * <td>The file is created.</td>
     * </tr>
     * <tr>
     * <td><b>STGM_FAILIFTHERE</b></td>
     * <td><b>FALSE</b></td>
     * <td>Yes</td>
     * <td>The file is opened.</td>
     * </tr>
     * <tr>
     * <td><b>STGM_FAILIFTHERE</b></td>
     * <td><b>FALSE</b></td>
     * <td>No</td>
     * <td>The call fails.</td>
     * </tr>
     * <tr>
     * <td><b>STGM_FAILIFTHERE</b></td>
     * <td><b>TRUE</b></td>
     * <td>Yes</td>
     * <td>The call fails.</td>
     * </tr>
     * <tr>
     * <td><b>STGM_FAILIFTHERE</b></td>
     * <td><b>TRUE</b></td>
     * <td>No</td>
     * <td>The file is created.</td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} pszFile Type: <b>LPCWSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the file name.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * 
     * One or more <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.
     * @param {Integer} dwAttributes Type: <b>DWORD</b>
     * 
     * One or more flag values that specify file attributes in the case that a new file is created. For a complete list of possible values, see the <i>dwFlagsAndAttributes</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} fCreate Type: <b>BOOL</b>
     * 
     * A <b>BOOL</b> value that helps specify, in conjunction with <i>grfMode</i>, how existing files should be treated when creating the stream. See Remarks for details.
     * @param {Pointer<IStream>} pstmTemplate Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Reserved.
     * @param {Pointer<IStream>} ppstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>**</b>
     * 
     * Receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer for the stream associated with the file.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcreatestreamonfileex
     * @since windows5.1.2600
     */
    static SHCreateStreamOnFileEx(pszFile, grfMode, dwAttributes, fCreate, pstmTemplate, ppstm) {
        pszFile := pszFile is String? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\SHCreateStreamOnFileEx", "ptr", pszFile, "uint", grfMode, "uint", dwAttributes, "int", fCreate, "ptr", pstmTemplate, "ptr", ppstm, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a memory stream using a similar process to CreateStreamOnHGlobal.
     * @remarks
     * Prior to WindowsVista, this function was not included in the public Shlwapi.h file, nor was it exported by name from Shlwapi.dll. To use it on earlier systems, you must call it directly from the Shlwapi.dll file as ordinal 12.
     * 
     * This function creates a memory stream. This is an implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface that stores its contents in memory. <b>SHCreateMemStream</b> differs from <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-createstreamonhglobal">CreateStreamOnHGlobal</a> in the following ways.
     * 
     *                 
     * 
     * <ul>
     * <li>Thread safety. The stream created by <b>SHCreateMemStream</b> is thread-safe as of Windows8. On earlier systems, the stream is not thread-safe. The stream created by <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-createstreamonhglobal">CreateStreamOnHGlobal</a> is thread-safe.</li>
     * <li>Initial contents. <b>SHCreateMemStream</b> accepts the initial contents in the form of a buffer. <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-createstreamonhglobal">CreateStreamOnHGlobal</a> accepts the initial contents in the form of an HGLOBAL.</li>
     * <li>Access to contents. <b>SHCreateMemStream</b> does not allow direct access to the stream contents. <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-createstreamonhglobal">CreateStreamOnHGlobal</a> permits access through <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-gethglobalfromstream">GetHGlobalFromStream</a>.</li>
     * <li>Failure information. If <b>SHCreateMemStream</b> returns <b>NULL</b>, it was unable to allocate the necessary memory. Callers should assume the cause is E_OUTOFMEMORY.</li>
     * <li>Support for <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-clone">IStream::Clone</a>. Prior to Windows8, the stream created by <b>SHCreateMemStream</b> does not support <b>IStream::Clone</b>. The stream created by <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-createstreamonhglobal">CreateStreamOnHGlobal</a> does. As of Windows8, the stream created by <b>SHCreateMemStream</b> does support <b>IStream::Clone</b>.</li>
     * <li>The stream returned by <b>SHCreateMemStream</b> returns S_FALSE from <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-isequentialstream-read">IStream::Read</a> if you attempt to read past the end of the buffer. The stream returned by <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-createstreamonhglobal">CreateStreamOnHGlobal</a> returns S_OK and sets *pcbRead to 0 if you attempt to read past the end of the buffer.</li>
     * </ul>
     * @param {Pointer} pInit Type: <b>const BYTE*</b>
     * 
     * A pointer to a buffer of size <i>cbInit</i>. The contents of this buffer are used to set the initial contents of the memory stream. If this parameter is <b>NULL</b>, the returned memory stream does not have any initial content.
     * @param {Integer} cbInit Type: <b>UINT</b>
     * 
     * The number of bytes in the buffer pointed to by <i>pInit</i>. If <i>pInit</i> is set to <b>NULL</b>, <i>cbInit</i> must be zero.
     * @returns {Pointer<IStream>} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * On success, returns a pointer to the created memory stream. Returns <b>NULL</b> if the stream object could not be allocated.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcreatememstream
     * @since windows5.0
     */
    static SHCreateMemStream(pInit, cbInit) {
        result := DllCall("SHLWAPI.dll\SHCreateMemStream", "ptr", pInit, "uint", cbInit, "ptr")
        return result
    }

    /**
     * Retrieves a string used with websites when specifying language preferences. (ANSI)
     * @remarks
     * For those versions of Windows that do not include <b>GetAcceptLanguages</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>GetAcceptLanguagesA</b> is ordinal 14 and <b>GetAcceptLanguagesW</b> is ordinal 15.
     * 
     * Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in Control Panel. <b>GetAcceptLanguages</b> retrieves a string that represents those preferences. That string is sent in an additional language header when negotiating HTTP connections.
     * 
     * <div class="alert"><b>Note</b>If your app or service passes language tags from this function to any <a href="https://docs.microsoft.com/windows/desktop/Intl/national-language-support">National Language Support</a> functions, or to Microsoft .NET, it must first convert the tags through the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a> function.</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines GetAcceptLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszLanguages Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.
     * @param {Pointer<UInt32>} pcchLanguages Type: <b>DWORD*</b>
     * 
     * A pointer to the size, in characters, of the string at <i>pszLanguages</i>. 
     *                         
     *                         
     * 
     * On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.
     * 
     * On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-getacceptlanguagesa
     * @since windows5.0
     */
    static GetAcceptLanguagesA(pszLanguages, pcchLanguages) {
        pszLanguages := pszLanguages is String? StrPtr(pszLanguages) : pszLanguages

        result := DllCall("SHLWAPI.dll\GetAcceptLanguagesA", "ptr", pszLanguages, "uint*", pcchLanguages, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves a string used with websites when specifying language preferences. (Unicode)
     * @remarks
     * For those versions of Windows that do not include <b>GetAcceptLanguages</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>GetAcceptLanguagesA</b> is ordinal 14 and <b>GetAcceptLanguagesW</b> is ordinal 15.
     * 
     * Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in Control Panel. <b>GetAcceptLanguages</b> retrieves a string that represents those preferences. That string is sent in an additional language header when negotiating HTTP connections.
     * 
     * <div class="alert"><b>Note</b>If your app or service passes language tags from this function to any <a href="https://docs.microsoft.com/windows/desktop/Intl/national-language-support">National Language Support</a> functions, or to Microsoft .NET, it must first convert the tags through the <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-resolvelocalename">ResolveLocaleName</a> function.</div>
     * <div></div>
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines GetAcceptLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszLanguages Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.
     * @param {Pointer<UInt32>} pcchLanguages Type: <b>DWORD*</b>
     * 
     * A pointer to the size, in characters, of the string at <i>pszLanguages</i>. 
     *                         
     *                         
     * 
     * On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.
     * 
     * On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-getacceptlanguagesw
     * @since windows5.0
     */
    static GetAcceptLanguagesW(pszLanguages, pcchLanguages) {
        pszLanguages := pszLanguages is String? StrPtr(pszLanguages) : pszLanguages

        result := DllCall("SHLWAPI.dll\GetAcceptLanguagesW", "ptr", pszLanguages, "uint*", pcchLanguages, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Changes the value of a Component Object Model (COM) interface pointer and releases the previous interface.
     * @remarks
     * This function mimics the behavior of a smart pointer. Conceptually, the function does the following:
     *                 
     *                 
     * 
     * <ul>
     * <li>Releases the original interface, if <i>ppunk</i> is non-<b>NULL</b></li>
     * <li>Assigns <i>punk</i> to <i>ppunk</i></li>
     * <li>Calls IUnknown::AddRef on the interface pointed to by <i>punk</i>, if <i>punk</i> is non-<b>NULL</b>.</li>
     * </ul>
     * @param {Pointer<IUnknown>} ppunk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>**</b>
     * 
     * The address of a COM interface pointer to receive the pointer assigned to <i>punk</i>. If the previous value of the pointer is non-<b>NULL</b>, the function releases that interface by calling its IUnkown::Release method.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * The interface pointer to be copied to <i>ppunk</i>. If the value is non-<b>NULL</b>, the function increments the interface's reference count.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-iunknown_set
     * @since windows5.0
     */
    static IUnknown_Set(ppunk, punk) {
        DllCall("SHLWAPI.dll\IUnknown_Set", "ptr", ppunk, "ptr", punk)
    }

    /**
     * Releases a Component Object Model (COM) pointer and sets it to NULL.
     * @remarks
     * If <i>ppunk</i> points to a <b>NULL</b> pointer, no operation is performed. Otherwise, <i>ppunk</i> is assumed to be the address of a COM interface pointer, derived from <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>. The function calls the interface's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> method then sets the interface pointer to <b>NULL</b>.
     * @param {Pointer<Void>} ppunk Type: <b>void**</b>
     * 
     * The address of a pointer to a COM interface.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-iunknown_atomicrelease
     * @since windows5.0
     */
    static IUnknown_AtomicRelease(ppunk) {
        DllCall("SHLWAPI.dll\IUnknown_AtomicRelease", "ptr", ppunk)
    }

    /**
     * Attempts to retrieve a window handle from a Component Object Model (COM) object by querying for various interfaces that have a GetWindow method.
     * @remarks
     * This function attempts to retrieve the window handle by calling <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nf-oleidl-iolewindow-getwindow">IOleWindow::GetWindow</a>, <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537095(v=vs.85)">IInternetSecurityMgrSite::GetWindow</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView::GetWindow</a>. It is possible that future versions of <b>IUnknown_GetWindow</b> may attempt additional interfaces.
     * 
     * <div class="alert"><b>Note</b>The query for <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> is theoretically unnecessary because <b>IShellView</b> derives from <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-iolewindow">IOleWindow</a>. The function explicitly queries for this interface because some objects implement <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">QueryInterface</a> incorrectly and fail to respond to a query for the base interface.</div>
     * <div></div>
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the COM object from which this function will attempt to obtain a window handle.
     * @param {Pointer<Void>} phwnd Type: <b>HWND*</b>
     * 
     * A pointer to a HWND that, when this function returns successfully, receives the window handle. If a window handle was not obtained, this parameter is set to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if a window handle was successfully returned, or a COM error code otherwise. If no suitable interface was found, the function returns E_NOINTERFACE. Otherwise, the function returns the <b>HRESULT</b> returned by the corresponding interface's <b>GetWindow</b> method.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-iunknown_getwindow
     * @since windows5.0
     */
    static IUnknown_GetWindow(punk, phwnd) {
        result := DllCall("SHLWAPI.dll\IUnknown_GetWindow", "ptr", punk, "ptr", phwnd, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Sets the specified object's site by calling its IObjectWithSite::SetSite method.
     * @remarks
     * This function calls the specified object's IUnknown::QueryInterface method to obtain a pointer to the object's <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-iobjectwithsite">IObjectWithSite</a> interface.  If successful, the function calls <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-iobjectwithsite-setsite">IObjectWithSite::SetSite</a> to set or change the site.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the IUnknown interface of the object whose site is to be changed.
     * @param {Pointer<IUnknown>} punkSite Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the IUnknown interface of the new site.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the site was successfully set, or a COM error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-iunknown_setsite
     * @since windows5.0
     */
    static IUnknown_SetSite(punk, punkSite) {
        result := DllCall("SHLWAPI.dll\IUnknown_SetSite", "ptr", punk, "ptr", punkSite, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Calls the specified object's IObjectWithSite::GetSite method.
     * @remarks
     * This function calls the specified object's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q)">QueryInterface</a> method to obtain the <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-iobjectwithsite">IObjectWithSite</a> interface.  If successful, the function calls the interface's <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-iobjectwithsite-getsite">IObjectWithSite::GetSite</a> method to obtain the site.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the COM object whose <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-iobjectwithsite-getsite">IObjectWithSite::GetSite</a> method is to be called.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * The IID of the interface pointer that should be returned in <i>ppvSite</i>.
     * @param {Pointer<Void>} ppv Type: <b>VOID**</b>
     * 
     * The address of the pointer to receive the requested interface pointer. If the function call is successful, <i>ppvSite</i> will contain the requested interface pointer. If no site is available or the requested interface is not supported, <i>ppvSite</i> is set to <b>NULL</b> and the function returns a COM error code.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> if the site was successfully retrieved or a COM error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-iunknown_getsite
     * @since windows5.0
     */
    static IUnknown_GetSite(punk, riid, ppv) {
        result := DllCall("SHLWAPI.dll\IUnknown_GetSite", "ptr", punk, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves an interface for a service from a specified object.
     * @remarks
     * If the object passed in the <i>punk</i> parameter supports the <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678965(v=vs.85)">IServiceProvider</a> interface, then its <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678966(v=vs.85)">QueryService</a> method is invoked, passing the <i>guidService</i>, <i>riid</i>, and <i>ppvOut</i> parameters and propagating the return value. Otherwise, the function returns E_FAIL.
     * 
     * For those versions of Windows that do not include <b>IUnknown_QueryService</b> in Shlwapi.h, this function must be called directly from Shlwapi.dll using ordinal 176.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> instance of the COM object that supports the service.
     * @param {Pointer<Guid>} guidService Type: <b>REFGUID</b>
     * 
     * The service's unique identifier (SID).
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * The IID of the desired service interface.
     * @param {Pointer<Void>} ppvOut Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested <i>riid</i>. If successful, the calling application is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> using this value when the service is no longer needed. In the case of failure, this value is <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> if successful. Returns <b>E_FAIL</b> if the object does not support <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678965(v=vs.85)">IServiceProvider</a>. Otherwise, the function returns the <b>HRESULT</b> returned by the object's <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678966(v=vs.85)">QueryService</a> method.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-iunknown_queryservice
     * @since windows5.0
     */
    static IUnknown_QueryService(punk, guidService, riid, ppvOut) {
        result := DllCall("SHLWAPI.dll\IUnknown_QueryService", "ptr", punk, "ptr", guidService, "ptr", riid, "ptr", ppvOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Reads bytes from a specified stream and returns a value that indicates whether all bytes were successfully read.
     * @remarks
     * This function calls the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-isequentialstream-read">ISequentialStream::Read</a> method to read data from the specified stream into the buffer. If the function fails for any reason, the contents of the output buffer and the position of the read pointer in the input stream are undefined.
     * @param {Pointer<IStream>} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface of the stream from which to read.
     * @param {Pointer} pv Type: <b>VOID*</b>
     * 
     * A pointer to a buffer to receive the stream data from <i>pstm</i>. This buffer must be at least <i>cb</i> bytes in size.
     * @param {Integer} cb Type: <b>ULONG</b>
     * 
     * The number of bytes of data that the function should attempt to read from the input stream.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> if the function successfully reads the specified number of bytes from the stream, or a COM failure code otherwise. In particular, if the read attempt was successful but fewer than <i>cb</i> bytes were read, the function returns <b>E_FAIL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_read
     * @since windows5.0
     */
    static IStream_Read(pstm, pv, cb) {
        result := DllCall("SHLWAPI.dll\IStream_Read", "ptr", pstm, "ptr", pv, "uint", cb, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Writes data of unknown format from a buffer to a specified stream.
     * @param {Pointer<IStream>} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> pointer that specifies the target stream.
     * @param {Pointer} pv Type: <b>const void*</b>
     * 
     * Pointer to a buffer that holds the data to send to the target stream. This buffer must be at least <i>cb</i> bytes in size.
     * @param {Integer} cb Type: <b>ULONG</b>
     * 
     * The number of bytes of data to write to the target stream.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the function successfully wrote the specified number of bytes to the stream, or an error value otherwise. In particular, if less than <i>cb</i> bytes was written to the target stream, even if some data was successfully written, the function returns E_FAIL.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_write
     * @since windows6.0.6000
     */
    static IStream_Write(pstm, pv, cb) {
        result := DllCall("SHLWAPI.dll\IStream_Write", "ptr", pstm, "ptr", pv, "uint", cb, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Moves the seek position in a specified stream to the beginning of the stream.
     * @remarks
     * This function calls <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-seek">IStream::Seek</a> to move the stream's seek position to the beginning of the stream.
     * @param {Pointer<IStream>} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface of the stream whose position is to be reset.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> on success or a COM failure code otherwise. See <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-seek">IStream::Seek</a> for further discussion of possible error codes.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_reset
     * @since windows5.0
     */
    static IStream_Reset(pstm) {
        result := DllCall("SHLWAPI.dll\IStream_Reset", "ptr", pstm, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the size, in bytes, of a specified stream.
     * @remarks
     * This function gets the size of the stream by calling the specified stream object's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-stat">IStream::Stat</a> method. It then copies the value of the <b>cbSize</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-statstg">STATSTG</a> structure returned by <b>IStream::Stat</b> to the <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a> structure pointed to by <i>pui</i>.  If the function fails, the contents of the <b>ULARGE_INTEGER</b> structure are undefined.
     * @param {Pointer<IStream>} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface of the stream whose size is to be determined.
     * @param {Pointer<UInt64>} pui Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a> structure to receive the size of the stream.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> on success or a COM failure code otherwise. See <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-istream-stat">IStream::Stat</a> for further discussion of possible error codes.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_size
     * @since windows5.0
     */
    static IStream_Size(pstm, pui) {
        result := DllCall("SHLWAPI.dll\IStream_Size", "ptr", pstm, "uint*", pui, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Establishes or terminates a connection between a client's sink and a connection point container.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface of the object to be connected to the connection point container. If you set <i>fConnect</i> to <b>FALSE</b> to indicate that you are disconnecting the object, this parameter is ignored and can be set to <b>NULL</b>.
     * @param {Pointer<Guid>} riidEvent Type: <b>REFIID</b>
     * 
     * The IID of the interface on the connection point container whose connection point object is being requested.
     * @param {Integer} fConnect Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if a connection is being established; <b>FALSE</b> if a connection is being broken.
     * @param {Pointer<IUnknown>} punkTarget Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the connection point container's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface.
     * @param {Pointer<UInt32>} pdwCookie Type: <b>DWORD*</b>
     * 
     * A connection token. If you set <i>fConnect</i> to <b>TRUE</b> to make a new connection, this parameter receives a token that uniquely identifies the connection. If you set <i>fConnect</i> to <b>FALSE</b> to break a connection, this parameter must point to the token that you received when you called <b>ConnectToConnectionPoint</b> to establish the connection.
     * @param {Pointer<IConnectionPoint>} ppcpOut Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-iconnectionpoint">IConnectionPoint</a>**</b>
     * 
     * A pointer to the connection point container's <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-iconnectionpoint">IConnectionPoint</a> interface, if the operation was successful. The calling application must release this pointer when it is no longer needed. If the request is unsuccessful, the pointer receives <b>NULL</b>. This parameter is optional and can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-connecttoconnectionpoint
     * @since windows5.0
     */
    static ConnectToConnectionPoint(punk, riidEvent, fConnect, punkTarget, pdwCookie, ppcpOut) {
        result := DllCall("SHLWAPI.dll\ConnectToConnectionPoint", "ptr", punk, "ptr", riidEvent, "int", fConnect, "ptr", punkTarget, "uint*", pdwCookie, "ptr", ppcpOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Reads a pointer to an item identifier list (PIDL) from an IStream object into a PIDLIST_RELATIVE object.
     * @param {Pointer<IStream>} pstm Type: <b>IStream*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> from which the PIDL is read.
     * @param {Pointer<ITEMIDLIST>} ppidlOut Type: <b>PIDLIST_RELATIVE*</b>
     * 
     * A pointer to the resulting PIDL.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_readpidl
     * @since windows6.0.6000
     */
    static IStream_ReadPidl(pstm, ppidlOut) {
        result := DllCall("SHLWAPI.dll\IStream_ReadPidl", "ptr", pstm, "ptr", ppidlOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Writes a pointer to an item identifier list (PIDL) from a PCUIDLIST_RELATIVE object into an IStream object.
     * @param {Pointer<IStream>} pstm Type: <b>IStream*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> object in which to write.
     * @param {Pointer<ITEMIDLIST>} pidlWrite Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * The source PIDL.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_writepidl
     * @since windows6.0.6000
     */
    static IStream_WritePidl(pstm, pidlWrite) {
        result := DllCall("SHLWAPI.dll\IStream_WritePidl", "ptr", pstm, "ptr", pidlWrite, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Reads from a stream and writes into a string.
     * @param {Pointer<IStream>} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the stream from which to read.
     * @param {Pointer<Char>} ppsz Type: <b>PWSTR*</b>
     * 
     * A pointer to the null-terminated, Unicode string into which the stream is written.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_readstr
     * @since windows6.0.6000
     */
    static IStream_ReadStr(pstm, ppsz) {
        result := DllCall("SHLWAPI.dll\IStream_ReadStr", "ptr", pstm, "ptr", ppsz, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Reads from a string and writes into a stream.
     * @param {Pointer<IStream>} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the stream in which to write.
     * @param {Pointer<Char>} psz Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string from which to read.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_writestr
     * @since windows6.0.6000
     */
    static IStream_WriteStr(pstm, psz) {
        psz := psz is String? StrPtr(psz) : psz

        result := DllCall("SHLWAPI.dll\IStream_WriteStr", "ptr", pstm, "ptr", psz, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Copies a stream to another stream.
     * @param {Pointer<IStream>} pstmFrom Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the source stream.
     * @param {Pointer<IStream>} pstmTo Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the destination stream.
     * @param {Integer} cb Type: <b>DWORD</b>
     * 
     * The number of bytes to copy from the source stream.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-istream_copy
     * @since windows6.0.6000
     */
    static IStream_Copy(pstmFrom, pstmTo, cb) {
        result := DllCall("SHLWAPI.dll\IStream_Copy", "ptr", pstmFrom, "ptr", pstmTo, "uint", cb, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHGetViewStatePropertyBag may be altered or unavailable.
     * @remarks
     * Critical information should not be stored in the view state property bag because the system keeps only a limited number of view states. If a folder is not visited for a long time, its view state is eventually deleted.
     * 
     * We recommend that you use the <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-iid_ppv_args">IID_PPV_ARGS</a> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error in <i>riid</i> that could lead to unexpected results.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A PIDL of the folder for which you are requesting properties. This parameter must be <b>NULL</b> if the SHGVSPB_ALLFOLDERS flag is passed.
     * @param {Pointer<Char>} pszBagName Type: <b>PCWSTR</b>
     * 
     * A pointer to a string that contains the name of the requested property bag.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * A value that specifies a combination of the following flags.
     * 
     * 
     * One value from the following set of flags is required.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns successfully, contains the interface pointer requested in <i>riid</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shgetviewstatepropertybag
     * @since windows5.1.2600
     */
    static SHGetViewStatePropertyBag(pidl, pszBagName, dwFlags, riid, ppv) {
        pszBagName := pszBagName is String? StrPtr(pszBagName) : pszBagName

        result := DllCall("SHLWAPI.dll\SHGetViewStatePropertyBag", "ptr", pidl, "ptr", pszBagName, "uint", dwFlags, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * SHFormatDateTime may be altered or unavailable. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHFormatDateTime as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<FILETIME>} pft Type: <b>const FILETIME UNALIGNED*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure whose time is to be converted to a string.
     * @param {Pointer<UInt32>} pdwFlags Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that contains bitwise flags that specify the date and time format.
     * 
     * 
     * 
     * 
     * When you call the function, you can combine zero or more of the following flags, with exceptions as noted. You can also set this parameter to <b>NULL</b>, in which case the function assumes that the FDTF_DEFAULT flag is set.
     * @param {Pointer<Byte>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that receives the formatted date and time. The buffer must be large enough to contain the number of TCHAR characters specified by the <i>cchBuf</i> parameter, including a terminating null character.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The number of TCHARs that can be contained by the buffer pointed to by <i>pszBuf</i>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of TCHARs written to the buffer, including the terminating null character. On failure, this value is 0.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shformatdatetimea
     * @since windows5.1.2600
     */
    static SHFormatDateTimeA(pft, pdwFlags, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\SHFormatDateTimeA", "ptr", pft, "uint*", pdwFlags, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * SHFormatDateTime may be altered or unavailable. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The shlwapi.h header defines SHFormatDateTime as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<FILETIME>} pft Type: <b>const FILETIME UNALIGNED*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure whose time is to be converted to a string.
     * @param {Pointer<UInt32>} pdwFlags Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that contains bitwise flags that specify the date and time format.
     * 
     * 
     * 
     * 
     * When you call the function, you can combine zero or more of the following flags, with exceptions as noted. You can also set this parameter to <b>NULL</b>, in which case the function assumes that the FDTF_DEFAULT flag is set.
     * @param {Pointer<Char>} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that receives the formatted date and time. The buffer must be large enough to contain the number of TCHAR characters specified by the <i>cchBuf</i> parameter, including a terminating null character.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The number of TCHARs that can be contained by the buffer pointed to by <i>pszBuf</i>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of TCHARs written to the buffer, including the terminating null character. On failure, this value is 0.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shformatdatetimew
     * @since windows5.1.2600
     */
    static SHFormatDateTimeW(pft, pdwFlags, pszBuf, cchBuf) {
        pszBuf := pszBuf is String? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\SHFormatDateTimeW", "ptr", pft, "uint*", pdwFlags, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Converts a string from the ANSI code page to the Unicode code page.
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. For example, if <i>pwszDst</i> buffer is not large enough to contain the number of characters specified by <i>cwchBuf</i>, a buffer overrun can occur. Buffer overruns can cause a denial of service attack against an application if an access violation occurs. In the worst case, a buffer overrun might allow an attacker to inject executable code into your process, especially if <i>pwszDst</i> is a stack-based buffer. When copying an entire string, note that sizeof returns the number of bytes, which is not the correct value to use for the <i>cwchBuf</i> parameter. Instead, use sizeof(pwszDst)/sizeof(WCHAR). Note that this technique assumes that <i>pwszDst</i> is an array, not a pointer.
     * 
     * If the <i>pwszDst</i> buffer is not large enough to contain the entire converted output string, the string is truncated to fit the buffer. There is no way to detect that the return string has been truncated.  The string is always null-terminated, even if it has been truncated. This ensures that no more than <i>cwchBuf</i> characters are copied to <i>pwszDst</i>. No attempt is made to avoid truncating the string in the middle of a Unicode surrogate pair.
     * 
     * If the <i>pszSrc</i> and <i>pwszDst</i> buffers overlap, the function's behavior is undefined.
     * 
     * <div class="alert"><b>Note</b>Do not assume that the function has not changed any of the characters in the output buffer that follow the string's terminating null character. The contents of the output buffer following the string's terminating null character are undefined, up to and including the last character in the buffer.</div>
     * <div></div>
     * <b>SHAnsiToTChar</b> is defined to be the same as <b>SHAnsiToUnicode</b>.
     * @param {Pointer<Byte>} pszSrc Type: <b>PCSTR</b>
     * 
     * A pointer to a null-terminated ANSI string to be converted to Unicode.
     * @param {Pointer<Char>} pwszDst Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the string specified by <i>pszSrc</i>, after the ANSI characters have been converted to Unicode (WCHAR). The buffer must be large enough to contain the number of Unicode characters specified by the <i>cwchBuf</i> parameter, including a terminating null character.
     * @param {Integer} cwchBuf Type: <b>int</b>
     * 
     * The number of Unicode characters that can be contained by the buffer pointed to by <i>pwszDst</i>. This parameter must be greater than zero.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of Unicode characters written to <i>pwszDst</i>, including the terminating null character. Returns 0 if unsuccessful.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shansitounicode
     * @since windows5.0
     */
    static SHAnsiToUnicode(pszSrc, pwszDst, cwchBuf) {
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc
        pwszDst := pwszDst is String? StrPtr(pwszDst) : pwszDst

        result := DllCall("SHLWAPI.dll\SHAnsiToUnicode", "ptr", pszSrc, "ptr", pwszDst, "int", cwchBuf, "int")
        return result
    }

    /**
     * Copies an ANSI string.
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. For example, if <i>pszDst</i> buffer is not large enough to contain the number of characters specified by <i>cchBuf</i>, a buffer overrun can occur. Buffer overruns can cause a denial of service attack against an application if an access violation occurs. In the worst case, a buffer overrun might allow an attacker to inject executable code into your process, especially if <i>pszDst</i> is a stack-based buffer. Note that the output string is silently truncated if the buffer is not large enough. This can result in canonicalization or other security vulnerabilities.
     * 
     * If the <i>pszDst</i> buffer is not large enough to contain the entire converted output string, the string is truncated to fit the buffer. There is no way to detect that the return string has been truncated. The string will always be null-terminated, even if it has been truncated. This function takes care to not truncate between the lead and trail bytes of a DBCS character pair. In that case, only cchBuf-1 characters are returned.
     * 
     * If the <i>pszSrc</i> and <i>pszDst</i> buffers overlap, the function's behavior is undefined.
     * 
     * <div class="alert"><b>Note</b>Do not assume that the function has not changed any of the characters in the output buffer that follow the string's terminating null character. The contents of the output buffer following the string's terminating null character are undefined, up to and including the last character in the buffer.</div>
     * <div></div>
     * @param {Pointer<Byte>} pszSrc Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated ANSI string to be converted to Unicode.
     * @param {Pointer<Byte>} pszDst Type: <b>LPWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the characters copied from <i>pszSrc</i>. The buffer must be large enough to contain the number of characters specified by the <i>cchBuf</i> parameter, including a room for a terminating null character.
     * @param {Integer} cchBuf Type: <b>int</b>
     * 
     * The number of characters that can be contained by the buffer pointed to by <i>pszDst</i>. This parameter must be greater than zero.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to <i>pszDst</i>, including the terminating null character. Returns 0 if unsuccessful.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shansitoansi
     * @since windows5.0
     */
    static SHAnsiToAnsi(pszSrc, pszDst, cchBuf) {
        pszSrc := pszSrc is String? StrPtr(pszSrc) : pszSrc
        pszDst := pszDst is String? StrPtr(pszDst) : pszDst

        result := DllCall("SHLWAPI.dll\SHAnsiToAnsi", "ptr", pszSrc, "ptr", pszDst, "int", cchBuf, "int")
        return result
    }

    /**
     * Converts a string from the Unicode code page to the ANSI code page.
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. For example, if <i>pszDst</i> buffer is not large enough to contain the number of characters specified by <i>cchBuf</i>, a buffer overrun can occur. Buffer overruns can cause a denial of service attack against an application if an access violation occurs. In the worst case, a buffer overrun might allow an attacker to inject executable code into your process, especially if <i>pszDst</i> is a stack-based buffer. In addition, the output string is silently truncated if it is too large for the buffer. This can cause canonicalization or other security vulnerabilities.
     * 
     * If the <i>pszDst</i> buffer is not large enough to contain the entire converted output string, the string is truncated to fit the buffer. There is no way to detect that the return string has been truncated. The string will always be null-terminated, even if it has been truncated. This function takes care to not truncate between the lead and trail bytes of a DBCS character pair. In that case, only cchBuf-1 characters are returned.
     * 
     * If the <i>pwszSrc</i> and <i>pszDst</i> buffers overlap, the function's behavior is undefined.
     * 
     * <div class="alert"><b>Note</b>Do not assume that the function has not changed any of the characters in the output buffer that follow the string's terminating null character. The contents of the output buffer following the string's terminating null character are undefined, up to and including the last character in the buffer.</div>
     * <div></div>
     * <b>SHTCharToAnsi</b> is defined to be the same as <b>SHUnicodeToAnsi</b>.
     * @param {Pointer<Char>} pwszSrc Type: <b>PCWSTR</b>
     * 
     * A pointer to the null-terminated Unicode string to be converted to ANSI.
     * @param {Pointer<Byte>} pszDst Type: <b>PSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted characters. The buffer must be large enough to contain the number of <b>CHAR</b> characters specified by the <i>cchBuf</i> parameter, including room for a terminating null character.
     * @param {Integer} cchBuf Type: <b>int</b>
     * 
     * The number of <b>CHAR</b> values that can be contained by the buffer pointed to by <i>pszDst</i>. The value assigned to parameter must be greater than zero.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of <b>CHAR</b> values written to the output buffer, including the terminating null character. Returns 0 if unsuccessful.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shunicodetoansi
     * @since windows5.0
     */
    static SHUnicodeToAnsi(pwszSrc, pszDst, cchBuf) {
        pwszSrc := pwszSrc is String? StrPtr(pwszSrc) : pwszSrc
        pszDst := pszDst is String? StrPtr(pszDst) : pszDst

        result := DllCall("SHLWAPI.dll\SHUnicodeToAnsi", "ptr", pwszSrc, "ptr", pszDst, "int", cchBuf, "int")
        return result
    }

    /**
     * Copies a Unicode string.
     * @remarks
     * <b>Security Warning:</b>Using this function incorrectly can compromise the security of your application. For example, if <i>pwzDst</i> buffer is not large enough to contain the number of characters specified by <i>cwchBuf</i>, a buffer overrun can occur. Buffer overruns can cause a denial of service attack against an application if an access violation occurs. In the worst case, a buffer overrun might allow an attacker to inject executable code into your process, especially if <i>pwzDst</i> is a stack-based buffer. When copying an entire string, note that sizeof returns the number of bytes, which is not the correct value to use for the <i>cwchBuf</i> parameter. Instead, use sizeof(pwzDst)/sizeof(WCHAR). Note that this technique assumes that <i>pwzDst</i> is an array, not a pointer. Note also that the function silently truncates the output string  if the buffer is not large enough. This can result in canonicalization or other security vulnerabilities.
     * 
     * If the <i>pwzDst</i> buffer is not large enough to contain the entire converted output string, the string is truncated to fit the buffer. There is no way to detect that the return string has been truncated.  The string will always be null-terminated, even if it has been truncated. This ensures that no more than <i>cwchBuf</i> characters are copied to <i>pwzDst</i>. No attempt is made to avoid truncating the string in the middle of a Unicode surrogate pair.
     * 
     * If the <i>pwzSrc</i> and <i>pwzDst</i> buffers overlap, the function's behavior is undefined.
     * 
     * <div class="alert"><b>Note</b>Do not assume that the function has not changed any of the characters in the output buffer that follow the string's terminating null character. The contents of the output buffer following the string's terminating null character are undefined, up to and including the last character in the buffer.</div>
     * <div></div>
     * <b>SHTCharToUnicode</b> is defined to be the same as <b>SHUnicodeToUnicode</b>.
     * 
     * <b>SHUnicodeToTChar</b> is defined to be the same as <b>SHUnicodeToUnicode</b>.
     * @param {Pointer<Char>} pwzSrc Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated Unicode string to be copied to the output buffer.
     * @param {Pointer<Char>} pwzDst Type: <b>PWSTR</b>
     * 
     * A pointer to an output buffer to receive the copied characters. The buffer must be large enough to contain the number of <b>WCHAR</b> characters specified by <i>cwchBuf</i>, including room for a terminating null character.
     * @param {Integer} cwchBuf Type: <b>int</b>
     * 
     * The number of <b>WCHAR</b> characters that can be contained by the buffer pointed to by <i>pwzDst</i> parameter. This parameter must be greater than zero.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of <b>WCHAR</b> characters written to the output buffer, including the terminating null character. Returns 0 if unsuccessful.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shunicodetounicode
     * @since windows5.0
     */
    static SHUnicodeToUnicode(pwzSrc, pwzDst, cwchBuf) {
        pwzSrc := pwzSrc is String? StrPtr(pwzSrc) : pwzSrc
        pwzDst := pwzDst is String? StrPtr(pwzDst) : pwzDst

        result := DllCall("SHLWAPI.dll\SHUnicodeToUnicode", "ptr", pwzSrc, "ptr", pwzDst, "int", cwchBuf, "int")
        return result
    }

    /**
     * SHMessageBoxCheck may be altered or unavailable. (ANSI)
     * @remarks
     * <b>Security Warning:</b>Do not take any dangerous actions if the function returns either 1 or <i>iDefault</i>. If an error occurs when attempting to display the message box, <b>SHMessageBoxCheck</b> returns 1 or, in some cases, <i>iDefault</i>. Such errors can be caused by insufficient memory or resources.  If you get one of these return values, you should be aware that the user did not necessarily see the dialog box and consequently did not positively agree to any action.
     * 
     * Do not confuse "Do not show this dialog box" with "Remember this answer". <b>SHMessageBoxCheck</b> does not provide "Remember this answer" functionality. If the user chooses to suppress the message box again, the function does not preserve which button they clicked. Instead, subsequent invocations of <b>SHMessageBoxCheck</b> simply return the value specified by <i>iDefault</i>. Consider the following example.
     * 			
     *             	
     * 
     * 
     * ```
     * 
     * int iResult = SHMessageBoxCheck(hwnd, 
     *                                 TEXT("Do you want to exit without saving?"),
     *                                 TEXT("Warning"), 
     *                                 MB_YESNO, 
     *                                 IDNO,
     *                                 TEXT("{d9108ba3-9a61-4398-bfbc-b02102c77e8a}");
     * ```
     * 
     * 
     * If the user selects <b>In the future, do not show me this</b> dialog box and clicks the <b>Yes</b> button, <b>SHMessageBoxCheck</b> returns IDYES. However, the next time this code is executed, <b>SHMessageBoxCheck</b> does not return IDYES, even though the user selected <b>Yes</b> originally. Instead, it returns IDNO, because that is the value specified by <i>iDefault</i>.
     * 
     * The default button displayed by the message box should agree with your <i>iDefault</i> value. The lack of support for the MB_DEFBUTTON2 flag means that <i>iDefault</i> should be set to IDOK if you have specified the MB_OK or MB_OKCANCEL flag. The <i>iDefault</i> value should be set to IDYES if you have set the MB_YESNO flag.
     * 
     * <b>SHMessageBoxCheck</b> records the message boxes that the user has chosen to suppress under the following registry key:
     *                 
     * <pre><b>HKEY_CURRENT_USER</b>
     * <b>Software</b>
     * <b>Microsoft</b>
     * <b>Windows</b>
     * <b>CurrentVersion</b>
     * <b>Explorer</b>
     * <b>DontShowMeThisDialogAgain</b></pre>
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHMessageBoxCheck as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * The window handle to the message box's owner. This value can be <b>NULL</b>.
     * @param {Pointer<Byte>} pszText Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the message to be displayed.
     * @param {Pointer<Byte>} pszCaption Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the title of the message box. If this parameter is set to <b>NULL</b>, the title is set to <b>Error!</b>.
     * @param {Integer} uType Type: <b>UINT</b>
     * 
     * The flags that specify the contents and behavior of the message box. This function supports only a subset of the flags supported by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>. If you use any flags that are not listed below, the function's behavior is undefined.
     * 
     * 
     * You must specify the buttons to be displayed by setting one and only one of the following flags.
     * @param {Integer} iDefault Type: <b>int</b>
     * 
     * The value that the function returns when the user has opted not to have the message box displayed again. If the user has not opted to suppress the message box, the message box is displayed and the function ignores <i>iDefault</i>.
     * @param {Pointer<Byte>} pszRegVal Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains a unique string value to associate with this message. To avoid collisions with values used by Microsoft, this string should include a GUID. This string must not exceed REGSTR_MAX_VALUE_LENGTH characters in length, including the terminating null character.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the user has already chosen to suppress the message box, the function immediately returns the value assigned to <i>iDefault</i>.
     * 
     * If the user clicks the <b>OK</b>, <b>Cancel</b>, <b>Yes</b>, or <b>No</b> button, the function returns IDOK, IDCANCEL, IDYES, or IDNO, respectively.
     * 
     * If the user closes the message box by clicking the <b>X</b> button in the caption, the function returns IDCANCEL. This value is returned in this case even if the MB_OKCANCEL flag has not been set.
     * 
     * If an error occurs, the return value is normally 1. However, under certain low-memory conditions, the function might return <i>iDefault</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shmessageboxchecka
     * @since windows5.1.2600
     */
    static SHMessageBoxCheckA(hwnd, pszText, pszCaption, uType, iDefault, pszRegVal) {
        pszText := pszText is String? StrPtr(pszText) : pszText
        pszCaption := pszCaption is String? StrPtr(pszCaption) : pszCaption
        pszRegVal := pszRegVal is String? StrPtr(pszRegVal) : pszRegVal

        result := DllCall("SHLWAPI.dll\SHMessageBoxCheckA", "ptr", hwnd, "ptr", pszText, "ptr", pszCaption, "uint", uType, "int", iDefault, "ptr", pszRegVal, "int")
        return result
    }

    /**
     * SHMessageBoxCheck may be altered or unavailable. (Unicode)
     * @remarks
     * <b>Security Warning:</b>Do not take any dangerous actions if the function returns either 1 or <i>iDefault</i>. If an error occurs when attempting to display the message box, <b>SHMessageBoxCheck</b> returns 1 or, in some cases, <i>iDefault</i>. Such errors can be caused by insufficient memory or resources.  If you get one of these return values, you should be aware that the user did not necessarily see the dialog box and consequently did not positively agree to any action.
     * 
     * Do not confuse "Do not show this dialog box" with "Remember this answer". <b>SHMessageBoxCheck</b> does not provide "Remember this answer" functionality. If the user chooses to suppress the message box again, the function does not preserve which button they clicked. Instead, subsequent invocations of <b>SHMessageBoxCheck</b> simply return the value specified by <i>iDefault</i>. Consider the following example.
     * 			
     *             	
     * 
     * 
     * ```
     * 
     * int iResult = SHMessageBoxCheck(hwnd, 
     *                                 TEXT("Do you want to exit without saving?"),
     *                                 TEXT("Warning"), 
     *                                 MB_YESNO, 
     *                                 IDNO,
     *                                 TEXT("{d9108ba3-9a61-4398-bfbc-b02102c77e8a}");
     * ```
     * 
     * 
     * If the user selects <b>In the future, do not show me this</b> dialog box and clicks the <b>Yes</b> button, <b>SHMessageBoxCheck</b> returns IDYES. However, the next time this code is executed, <b>SHMessageBoxCheck</b> does not return IDYES, even though the user selected <b>Yes</b> originally. Instead, it returns IDNO, because that is the value specified by <i>iDefault</i>.
     * 
     * The default button displayed by the message box should agree with your <i>iDefault</i> value. The lack of support for the MB_DEFBUTTON2 flag means that <i>iDefault</i> should be set to IDOK if you have specified the MB_OK or MB_OKCANCEL flag. The <i>iDefault</i> value should be set to IDYES if you have set the MB_YESNO flag.
     * 
     * <b>SHMessageBoxCheck</b> records the message boxes that the user has chosen to suppress under the following registry key.
     *                 
     * <pre><b>HKEY_CURRENT_USER</b>
     * <b>Software</b>
     * <b>Microsoft</b>
     * <b>Windows</b>
     * <b>CurrentVersion</b>
     * <b>Explorer</b>
     * <b>LowRegistry</b>
     * <b>DontShowMeThisDialogAgain</b></pre>
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHMessageBoxCheck as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * The window handle to the message box's owner. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszText Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the message to be displayed.
     * @param {Pointer<Char>} pszCaption Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the title of the message box. If this parameter is set to <b>NULL</b>, the title is set to <b>Error!</b>.
     * @param {Integer} uType Type: <b>UINT</b>
     * 
     * The flags that specify the contents and behavior of the message box. This function supports only a subset of the flags supported by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>. If you use any flags that are not listed below, the function's behavior is undefined.
     * 
     * 
     * You must specify the buttons to be displayed by setting one and only one of the following flags.
     * @param {Integer} iDefault Type: <b>int</b>
     * 
     * The value that the function returns when the user has opted not to have the message box displayed again. If the user has not opted to suppress the message box, the message box is displayed and the function ignores <i>iDefault</i>.
     * @param {Pointer<Char>} pszRegVal Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains a unique string value to associate with this message. To avoid collisions with values used by Microsoft, this string should include a GUID. This string must not exceed REGSTR_MAX_VALUE_LENGTH characters in length, including the terminating null character.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the user has already chosen to suppress the message box, the function immediately returns the value assigned to <i>iDefault</i>.
     * 
     * If the user clicks the <b>OK</b>, <b>Cancel</b>, <b>Yes</b>, or <b>No</b> button, the function returns IDOK, IDCANCEL, IDYES, or IDNO, respectively.
     * 
     * If the user closes the message box by clicking the <b>X</b> button in the caption, the function returns IDCANCEL. This value is returned in this case even if the MB_OKCANCEL flag has not been set.
     * 
     * If an error occurs, the return value is normally 1. However, under certain low-memory conditions, the function might return <i>iDefault</i>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shmessageboxcheckw
     * @since windows5.1.2600
     */
    static SHMessageBoxCheckW(hwnd, pszText, pszCaption, uType, iDefault, pszRegVal) {
        pszText := pszText is String? StrPtr(pszText) : pszText
        pszCaption := pszCaption is String? StrPtr(pszCaption) : pszCaption
        pszRegVal := pszRegVal is String? StrPtr(pszRegVal) : pszRegVal

        result := DllCall("SHLWAPI.dll\SHMessageBoxCheckW", "ptr", hwnd, "ptr", pszText, "ptr", pszCaption, "uint", uType, "int", iDefault, "ptr", pszRegVal, "int")
        return result
    }

    /**
     * Sends a message to all top-level windows in the system. (ANSI)
     * @remarks
     * <b>SHSendMessageBroadcast</b> is equivalent to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> with <b>HWND_BROADCAST</b>. To avoid causing the Shell to become unresponsive in the case where there could be a window in the system that is not responding to messages, use <b>SHSendMessageBroadcast</b>.
     * 
     * <b>SHSendMessageBroadcast</b> is not exported by name. <b>SHSendMessageBroadcastA</b> is exported from Shlwapi.dll as ordinal 432. <b>SHSendMessageBroadcastW</b> is exported from Shlwapi.dll as ordinal 433.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHSendMessageBroadcast as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to send.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value is not meaningful.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shsendmessagebroadcasta
     * @since windows5.1.2600
     */
    static SHSendMessageBroadcastA(uMsg, wParam, lParam) {
        result := DllCall("SHLWAPI.dll\SHSendMessageBroadcastA", "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Sends a message to all top-level windows in the system. (Unicode)
     * @remarks
     * <b>SHSendMessageBroadcast</b> is equivalent to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> with <b>HWND_BROADCAST</b>. To avoid causing the Shell to become unresponsive in the case where there could be a window in the system that is not responding to messages, use <b>SHSendMessageBroadcast</b>.
     * 
     * <b>SHSendMessageBroadcast</b> is not exported by name. <b>SHSendMessageBroadcastA</b> is exported from Shlwapi.dll as ordinal 432. <b>SHSendMessageBroadcastW</b> is exported from Shlwapi.dll as ordinal 433.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHSendMessageBroadcast as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to send.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value is not meaningful.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shsendmessagebroadcastw
     * @since windows5.1.2600
     */
    static SHSendMessageBroadcastW(uMsg, wParam, lParam) {
        result := DllCall("SHLWAPI.dll\SHSendMessageBroadcastW", "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Removes the mnemonic marker from a string. (ANSI)
     * @remarks
     * The term "mnemonic" is misspelled in the function name.
     * 
     * The function supports the following mnemonic formats.
     *         
     *                 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Input String</th>
     * <th>Output String</th>
     * <th>Mnemonic Character</th>
     * <th>Remarks</th>
     * </tr>
     * <tr>
     * <td>"Str&amp;ing"</td>
     * <td>"String"</td>
     * <td>'i'</td>
     * <td>None.</td>
     * </tr>
     * <tr>
     * <td>"String (&amp;S)"</td>
     * <td>"String"</td>
     * <td>'S'</td>
     * <td>Supported only by the Unicode version of this function. Requires WindowsXP or later.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHStripMneumonic as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pszMenu Type: <b>LPTSTR*</b>
     * 
     * A pointer to the null-terminated string that contains the mnemonic marker.
     * @returns {Integer} Type: <b>TCHAR</b>
     * 
     * Returns the mnemonic character, if one was found. Otherwise, returns 0.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shstripmneumonica
     * @since windows5.0
     */
    static SHStripMneumonicA(pszMenu) {
        pszMenu := pszMenu is String? StrPtr(pszMenu) : pszMenu

        result := DllCall("SHLWAPI.dll\SHStripMneumonicA", "ptr", pszMenu, "char")
        return result
    }

    /**
     * Removes the mnemonic marker from a string. (Unicode)
     * @remarks
     * The term "mnemonic" is misspelled in the function name.
     * 
     * The function supports the following mnemonic formats.
     *         
     *                 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Input String</th>
     * <th>Output String</th>
     * <th>Mnemonic Character</th>
     * <th>Remarks</th>
     * </tr>
     * <tr>
     * <td>"Str&amp;ing"</td>
     * <td>"String"</td>
     * <td>'i'</td>
     * <td>None.</td>
     * </tr>
     * <tr>
     * <td>"String (&amp;S)"</td>
     * <td>"String"</td>
     * <td>'S'</td>
     * <td>Supported only by the Unicode version of this function. Requires WindowsXP or later.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines SHStripMneumonic as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pszMenu Type: <b>LPTSTR*</b>
     * 
     * A pointer to the null-terminated string that contains the mnemonic marker.
     * @returns {Integer} Type: <b>TCHAR</b>
     * 
     * Returns the mnemonic character, if one was found. Otherwise, returns 0.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shstripmneumonicw
     * @since windows5.0
     */
    static SHStripMneumonicW(pszMenu) {
        pszMenu := pszMenu is String? StrPtr(pszMenu) : pszMenu

        result := DllCall("SHLWAPI.dll\SHStripMneumonicW", "ptr", pszMenu, "char")
        return result
    }

    /**
     * Checks for specified operating systems and operating system features.
     * @remarks
     * Values are not provided for WindowsVista and Windows7. To determine whether either of those operating systems are present, use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-verifyversioninfoa">VerifyVersionInfo</a>.
     * 
     * In Windows versions earlier than WindowsVista, <b>IsOS</b> was not exported by name or declared in a public header file. To use it in those cases, you must use <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> and request ordinal 437 from Shlwapi.dll to obtain a function pointer. Under WindowsVista, <b>IsOS</b> is included in Shlwapi.h and this is not necessary.
     * 
     * When referring to server products, "Windows Server" refers only to the Standard Edition server. If all server products are covered by a particular flag, it is called out explicitly in the table.
     * @param {Integer} dwOS Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the specified operating system or operating system feature is detected, otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-isos
     * @since windows5.0
     */
    static IsOS(dwOS) {
        result := DllCall("SHLWAPI.dll\IsOS", "uint", dwOS, "int")
        return result
    }

    /**
     * Gets the current value of a global counter.
     * @param {Integer} id Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a> for which to retrieve the current value.
     * @returns {Integer} Type: <b>long</b>
     * 
     * The current value of the counter.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shglobalcountergetvalue
     * @since windows6.1
     */
    static SHGlobalCounterGetValue(id) {
        result := DllCall("SHLWAPI.dll\SHGlobalCounterGetValue", "int", id, "int")
        return result
    }

    /**
     * Increments a global counter.
     * @param {Integer} id Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a> to increment.
     * @returns {Integer} Type: <b>long</b>
     * 
     * The value of the counter after the increment.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shglobalcounterincrement
     * @since windows6.1
     */
    static SHGlobalCounterIncrement(id) {
        result := DllCall("SHLWAPI.dll\SHGlobalCounterIncrement", "int", id, "int")
        return result
    }

    /**
     * Decrements a global counter.
     * @param {Integer} id Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a> to decrement.
     * @returns {Integer} Type: <b>long</b>
     * 
     * The value of the counter after the decrement.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shglobalcounterdecrement
     * @since windows6.1
     */
    static SHGlobalCounterDecrement(id) {
        result := DllCall("SHLWAPI.dll\SHGlobalCounterDecrement", "int", id, "int")
        return result
    }

    /**
     * SHAllocShared may be altered or unavailable.
     * @remarks
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shfreeshared">SHFreeShared</a> to free the handle when you are finished.
     * @param {Pointer} pvData Type: <b>const void*</b>
     * 
     * A pointer to the memory block in the calling process that is to be copied. You can set this parameter to <b>NULL</b> if you want to share a block of memory without copying any data to it.
     * @param {Integer} dwSize Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the memory block pointed to by <i>pvData</i>.
     * @param {Integer} dwProcessId Type: <b>DWORD</b>
     * 
     * The process ID of the process that will share memory block specified by <i>pvData</i>.
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * Returns a handle to the shared memory for the process specified by <i>dwDestinationProcessId</i>. Returns <b>NULL</b> if unsuccessful.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shallocshared
     * @since windows5.1.2600
     */
    static SHAllocShared(pvData, dwSize, dwProcessId) {
        result := DllCall("SHLWAPI.dll\SHAllocShared", "ptr", pvData, "uint", dwSize, "uint", dwProcessId)
        return result
    }

    /**
     * SHFreeShared may be altered or unavailable.
     * @param {Pointer<Void>} hData Type: <b>HANDLE</b>
     * 
     * A handle to the mapped memory.
     * @param {Integer} dwProcessId Type: <b>DWORD</b>
     * 
     * The process ID of the process from which the memory was allocated.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shfreeshared
     * @since windows5.1.2600
     */
    static SHFreeShared(hData, dwProcessId) {
        A_LastError := 0

        result := DllCall("SHLWAPI.dll\SHFreeShared", "ptr", hData, "uint", dwProcessId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * SHLockShared may be altered or unavailable.
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shunlockshared">SHUnlockShared</a> to unlock the memory that this function maps. Call <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shfreeshared">SHFreeShared</a> to release the memory.
     * @param {Pointer<Void>} hData Type: <b>HANDLE</b>
     * 
     * A handle to the memory you want to map into the calling process.
     * @param {Integer} dwProcessId Type: <b>DWORD</b>
     * 
     * The process ID of the process from which you want to map the block of memory.
     * @returns {Pointer<Void>} Returns a void pointer to the shared memory. Returns <b>NULL</b> if unsuccessful.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shlockshared
     * @since windows5.1.2600
     */
    static SHLockShared(hData, dwProcessId) {
        result := DllCall("SHLWAPI.dll\SHLockShared", "ptr", hData, "uint", dwProcessId)
        return result
    }

    /**
     * SHUnlockShared may be altered or unavailable.
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shfreeshared">SHFreeShared</a> to free the memory block.
     * @param {Pointer<Void>} pvData Type: <b>void*</b>
     * 
     * A pointer to the shared memory block returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shlockshared">SHLockShared</a>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is <b>TRUE</b> and all modified pages within the specified range are written to the disk with low priority. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shunlockshared
     * @since windows5.1.2600
     */
    static SHUnlockShared(pvData) {
        A_LastError := 0

        result := DllCall("SHLWAPI.dll\SHUnlockShared", "ptr", pvData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * WhichPlatform may be altered or unavailable.
     * @remarks
     * This function always returns PLATFORM_INTEGRATED because WindowsXP comes with an integrated shell.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PLATFORM_UNKNOWN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was unable to determine the Shell32.dll version.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PLATFORM_IE3</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obsolete: Use PLATFORM_BROWSERONLY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PLATFORM_BROWSERONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Shell32.dll version is browser-only, with no new shell.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PLATFORM_INTEGRATED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The platform contains an integrated shell.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-whichplatform
     * @since windows5.1.2600
     */
    static WhichPlatform() {
        result := DllCall("SHLWAPI.dll\WhichPlatform", "uint")
        return result
    }

    /**
     * A table-driven implementation of the IUnknown::QueryInterface method.
     * @remarks
     * <div class="alert"><b>Note</b>Prior to WindowsVista, <b>QISearch</b> was not exported by name or declared in a public header file. To use it in those cases, you must use <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> and request ordinal 219 from Shlwapi.dll to obtain a function pointer. Under WindowsVista, <b>QISearch</b> is included in Shlwapi.h and this is not necessary.</div>
     * <div></div>
     * If the requested interface is IUnknown, then <b>QISearch</b> uses the first entry of the specified array of <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-qitab">QITAB</a> structures. Otherwise, <b>QISearch</b> searches the table until it either finds a matching IID or reaches the end of the table.  If a matching IID is found, the function advances the associated interface pointer by the number of bytes specified by the <b>dwOffset</b> member of the interface's <b>QITAB</b> structure and reinterpreted as a COM pointer.  That pointer is assigned to the <b>QISearch</b> function's  <i>ppv</i> parameter. The method also calls IUnknown::AddRef to increment the interface's reference count.
     * 
     * If <b>QISearch</b> reaches the end of the table without finding the interface, it returns E_NOINTERFACE and sets <i>ppv</i> to <b>NULL</b>.
     * 
     * It is important to include all applicable interfaces in the table. For example, if the object implements a derived interface, you should also include the base interface in the table.
     * 
     * We recommend that you use the <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-iid_ppv_args">IID_PPV_ARGS</a> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error in <i>riid</i> that could lead to unexpected results.
     * 
     * <div class="alert"><b>Note</b>Active Template Library (ATL) provides a significantly better version of a table-driven implementation of QueryInterface.</div>
     * <div></div>
     * @param {Pointer<Void>} that Type: <b>void*</b>
     * 
     * A pointer to the base of a COM object.
     * @param {Pointer<QITAB>} pqit Type: <b>LPCQITAB</b>
     * 
     * An array of <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-qitab">QITAB</a> structures. The last structure in the array must have its <b>piid</b> member set to <b>NULL</b> and its <b>dwOffset</b> member set to 0.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>.
     * @param {Pointer<Void>} ppv Type: <b>void**</b>
     * 
     * When this method returns successfully, contains the interface pointer requested in <i>riid</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the requested interface was found in the table or if the requested interface was IUnknown. Returns E_NOINTERFACE if the requested interface was not found.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-qisearch
     * @since windows5.0
     */
    static QISearch(that, pqit, riid, ppv) {
        result := DllCall("SHLWAPI.dll\QISearch", "ptr", that, "ptr", pqit, "ptr", riid, "ptr", ppv, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Not supported. (SHIsLowMemoryMachine)
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * The type of machine being examined. The following is the only recognized value.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the machine is considered low on resources, <b>FALSE</b> otherwise.
     * 
     * <div class="alert"><b>Note</b>Always returns <b>FALSE</b> under WindowsXP.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shislowmemorymachine
     * @since windows5.1.2600
     */
    static SHIsLowMemoryMachine(dwType) {
        result := DllCall("SHLWAPI.dll\SHIsLowMemoryMachine", "uint", dwType, "int")
        return result
    }

    /**
     * GetMenuPosFromID may be altered or unavailable.
     * @remarks
     * Beginning with WindowsVista, this function is declared in Shlwapi.h.
     * 
     * <b>WindowsXP:</b>This function is declared in Shlwapi.dll.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * The handle of the menu.
     * @param {Integer} id Type: <b>UINT</b>
     * 
     * An application-defined 16-bit value that identifies the menu item.
     * @returns {Integer} Type: <b>int</b>
     * 
     * The item's zero-based position in the menu.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-getmenuposfromid
     * @since windows5.1.2600
     */
    static GetMenuPosFromID(hmenu, id) {
        result := DllCall("SHLWAPI.dll\GetMenuPosFromID", "ptr", hmenu, "uint", id, "int")
        return result
    }

    /**
     * Retrieves the inverse color table mapping for the halftone palette.
     * @remarks
     * The inverse color mapping table is a table of 32,768 bytes. It contains the indexes of colors in the halftone palette. Each index is stored at a position in the buffer that corresponds to a particular RGB value expressed in 555 format. These pairings allow you to find a color in the halftone palette which is a close approximation of the original color.
     *                 
     *                 
     * 
     * For example, the method for determining a color in the halftone palette that is a close approximation for the color #306040 is as follows:
     * 
     * <ol>
     * <li>Decompose the color into its red, green, and blue components. In this case, the red component is 0x30, the green component is 0x60 and the blue component is 0x40.</li>
     * <li>Reassemble the color into 555 format. The formula for reducing a 24-bit RGB color into 555 format is shown here.
     * 
     *                         
     * 
     * 
     * ```
     * ((red / 8) << 10) + ((blue / 8) << 5) + (green / 8)
     * ```
     * 
     * 
     * In this example, the value in 555 format is ((0x30 / 8) &lt;&lt; 10) + ((0x60 / 8) &lt;&lt; 5) + (0x40 / 8) = 6536.
     * 
     * </li>
     * <li>The index value stored in position 6536 in the inverse color map table is the index of the color in the halftone palette that is a reasonable approximation to the color #306040.</li>
     * </ol>
     * @param {Pointer} pbMap Type: <b>BYTE*</b>
     * 
     * A pointer to an array of <b>BYTE</b><b>s</b> that receives the inverse color table mapping, or a pointer to an <b>LPBYTE</b> which receives a pointer to a cached copy of the inverse color table mapping, depending on the value of the <i>cbMap</i> parameter.
     * @param {Integer} cbMap Type: <b>ULONG</b>
     * 
     * The size of the buffer pointed to by <i>pbMap</i>, which also defines its contents. Two values are recognized.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shgetinversecmap
     * @since windows5.0
     */
    static SHGetInverseCMAP(pbMap, cbMap) {
        result := DllCall("SHLWAPI.dll\SHGetInverseCMAP", "ptr", pbMap, "uint", cbMap, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Instructs system edit controls to use AutoComplete to help complete URLs or file system paths.
     * @remarks
     * <b>SHAutoComplete</b> works on any system edit control, including the edit control and controls that contain edit controls such as <a href="https://docs.microsoft.com/windows/desktop/Controls/comboboxex-control-reference">ComboBoxEx</a> controls. To retrieve a handle to an edit control embedded in a ComboBoxEx control, send the ComboBoxEx control a <a href="https://docs.microsoft.com/windows/desktop/Controls/cbem-geteditcontrol">CBEM_GETEDITCONTROL</a> message.
     * 
     * An application must have invoked either <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-coinitialize">CoInitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleinitialize">OleInitialize</a> prior to calling this function. <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize">CoUninitialize</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ole2/nf-ole2-oleuninitialize">OleUninitialize</a> cannot be called until the edit box has finished processing the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-destroy">WM_DESTROY</a> message for <i>hwndEdit</i>.
     * 
     * The maximum number of items that can be displayed in an autosuggest drop-down list box is 1000.
     * 
     * On versions of Windows prior to WindowsVista and server versions prior to Windows Server2008, <b>SHAutoComplete</b> should not be called more than once with the same <b>HWND</b>. Doing so results in a memory leak. It prevents the original resources from being released, including the previous instance of the AutoComplete object, enumerator objects that the previous AutoComplete object has referenced, and Windows Graphics Device Interface (GDI) resources. Rather than call <b>SHAutoComplete</b> again with a different set of flags to change the AutoComplete list, call <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance">CoCreateInstance</a> with CLSID_AutoComplete to obtain the AutoComplete object. Then pass the <b>HWND</b> to the object to initialize it and provide your own custom enumerator. You can use CLSID_ACLMulti if you want AutoComplete to use multiple lists.
     * @param {Pointer<Void>} hwndEdit Type: <b>HWND</b>
     * 
     * The window handle of a system edit control. Typically, this parameter is the handle of an edit control or the edit control embedded in a <a href="https://docs.microsoft.com/windows/desktop/Controls/comboboxex-control-reference">ComboBoxEx</a> control.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags to control the operation of <b>SHAutoComplete</b>. The first four flags are used to override the Internet Explorer registry settings. The user can change these settings manually by launching the <b>Internet Options</b> property sheet from the <b>Tools</b> menu and clicking the <b>Advanced</b> tab.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shautocomplete
     * @since windows5.0
     */
    static SHAutoComplete(hwndEdit, dwFlags) {
        result := DllCall("SHLWAPI.dll\SHAutoComplete", "ptr", hwndEdit, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a per-thread reference to a Component Object Model (COM) object.
     * @remarks
     * See <a href="https://docs.microsoft.com/windows/desktop/shell/managing-thread-references">Managing Thread References</a> for more details on using the Shlwapi thread APIs.
     * @param {Pointer<Int32>} pcRef Type: <b>LONG*</b>
     * 
     * A pointer to a value, usually a local variable in the thread's <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>, that is used by the interface in <i>ppunk</i> as a reference counter.
     * @param {Pointer<IUnknown>} ppunk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>**</b>
     * 
     * The address of a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface. If successful, this parameter holds the thread's <b>IUnknown</b> pointer on return. Your application is responsible for freeing the pointer when it is finished.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcreatethreadref
     * @since windows5.1.2600
     */
    static SHCreateThreadRef(pcRef, ppunk) {
        result := DllCall("SHLWAPI.dll\SHCreateThreadRef", "int*", pcRef, "ptr", ppunk, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Stores a per-thread reference to a Component Object Model (COM) object. This allows the caller to control the thread's lifetime so that it can ensure that Windows won't shut down the thread before the caller is ready.
     * @remarks
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shgetthreadref">SHGetThreadRef</a> to retrieve the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> pointer.
     * @param {Pointer<IUnknown>} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> of the object for which you want to store a reference. This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shsetthreadref
     * @since windows5.0
     */
    static SHSetThreadRef(punk) {
        result := DllCall("SHLWAPI.dll\SHSetThreadRef", "ptr", punk, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves the per-thread object reference set by SHSetThreadRef.
     * @param {Pointer<IUnknown>} ppunk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>**</b>
     * 
     * The address of a pointer that, when this function returns successfully, points to the object whose reference is stored. Your application is responsible for freeing this resource when it is no longer needed.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the object reference exists, or <b>E_NOINTERFACE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shgetthreadref
     * @since windows5.0
     */
    static SHGetThreadRef(ppunk) {
        result := DllCall("SHLWAPI.dll\SHGetThreadRef", "ptr", ppunk, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Checks a bind context to see if it is safe to bind to a particular component object.
     * @remarks
     * This function can be used to avoid infinite cycles in namespace binding. For example, a folder shortcut that refers to a folder above it in the namespace tree can produce an infinitely recursive loop.
     * @param {Pointer<IBindCtx>} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface that specifies the bind context you want to check. This value can be <b>NULL</b>.
     * @param {Pointer<Guid>} pclsid Type: <b>const CLSID*</b>
     * 
     * A pointer to a variable that specifies the <b>CLSID</b> of the object being tested to see if it must be skipped. Typically, this is the CLSID of the object that <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject">IShellFolder::BindToObject</a> is about to create.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the object specified by <i>pclsid</i> must be skipped, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shskipjunction
     * @since windows5.0
     */
    static SHSkipJunction(pbc, pclsid) {
        result := DllCall("SHLWAPI.dll\SHSkipJunction", "ptr", pbc, "ptr", pclsid, "int")
        return result
    }

    /**
     * Creates a thread.
     * @remarks
     * The function pointed to by <i>pfnThreadProc</i> and <i>pfnCallback</i> must take the following form.
     * 
     * 				
     * 
     * 
     * ```
     * DWORD WINAPI ThreadProc(LPVOID pData)
     * {
     *   ...
     * }
     * ```
     * 
     * 
     * The function name is arbitrary. The <i>pData</i> parameter points to an application-defined data structure with initialization information.
     * @param {Pointer<LPTHREAD_START_ROUTINE>} pfnThreadProc Type: <b>LPTHREAD_START_ROUTINE</b>
     * 
     * A pointer to an application-defined function of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a> type. If a new thread was successfully created, this application-defined function is called in the context of that thread. <b>SHCreateThread</b> does not wait for the function pointed to by this parameter to complete before returning to its caller.  The application-defined function's return value is the exit code of the thread.
     * @param {Pointer<Void>} pData Type: <b>void*</b>
     * 
     * A pointer to an optional application-defined data structure that contains initialization data. It is passed to the function pointed to by <i>pfnThreadProc</i> and, optionally, <i>pfnCallback</i>. This value can be <b>NULL</b>.
     * @param {Integer} flags Type: <b>SHCT_FLAGS</b>
     * 
     * The flags that control the behavior of the function. One or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/ctf">CTF</a> constants.
     * @param {Pointer<LPTHREAD_START_ROUTINE>} pfnCallback Type: <b>LPTHREAD_START_ROUTINE</b>
     * 
     * A pointer to an optional application-defined function of the 
     * 				 <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a> type. This function is called 
     * 				 in the context of the created thread before the function pointed to by 
     * 				 <i>pfnThreadProc</i> is called. It will also receive <i>pData</i> as 
     * 				 its argument. <b>SHCreateThread</b> will wait for the 
     * 				 function pointed to by <i>pfnCallback</i> to return before returning to its caller. The 
     * 				 return value of the function pointed to by <i>pfnCallback</i> is ignored.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the thread is successfully created, or <b>FALSE</b> otherwise. On failure, use <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to retrieve the specific error value as shown here.
     * 
     *                     
     * 
     * 
     * ```
     * if (!SHCreateThread(...))
     * {
     *     hr = HRESULT_FROM_WIN32( GetLastError() );
     * }
     * else
     * {
     *     ....
     * }
     * ```
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcreatethread
     * @since windows5.0
     */
    static SHCreateThread(pfnThreadProc, pData, flags, pfnCallback) {
        A_LastError := 0

        result := DllCall("SHLWAPI.dll\SHCreateThread", "ptr", pfnThreadProc, "ptr", pData, "uint", flags, "ptr", pfnCallback, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new thread and retrieves its handle.
     * @remarks
     * Prior to Windows7, this function did not have an associated header or library file. To use this function under those earlier operating systems, call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> with the DLL name (Shlwapi.dll) to obtain a module handle. Then call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> with that module handle and a function ordinal of 615 to get the address of this function.
     * 
     * The function pointed to by <i>pfnThreadProc</i> and <i>pfnCallback</i> must take the following form. 
     * 
     *                 
     * 
     * 
     * ```
     * DWORD WINAPI ThreadProc(LPVOID pData)
     * {
     *     ...
     * }
     * ```
     * 
     * 
     * The function name is arbitrary. The <i>pData</i> parameter points to an application-defined data structure with initialization information.
     * @param {Pointer<LPTHREAD_START_ROUTINE>} pfnThreadProc Type: <b>LPTHREAD_START_ROUTINE</b>
     * 
     * A pointer to an application-defined function of type <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a>. If a new thread was successfully created, this application-defined function is called in the context of that thread. <b>SHCreateThreadWithHandle</b> does not wait for the function pointed to by <i>pfnThreadProc</i> to complete before returning to its caller. The return value for the function specified by <i>pfnThreadProc</i> is the exit code of the thread.
     * @param {Pointer<Void>} pData Type: <b>void*</b>
     * 
     * A pointer to an optional application-defined data structure that contains initialization data. It is passed to the function pointed to by <i>pfnThreadProc</i> and, optionally, the function pointed to by <i>pfnCallback</i>.
     * @param {Integer} flags Type: <b>SHCT_FLAGS</b>
     * 
     * Flags that control the behavior of the function; one or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/ctf">CTF</a> constants.
     * @param {Pointer<LPTHREAD_START_ROUTINE>} pfnCallback Type: <b>LPTHREAD_START_ROUTINE</b>
     * 
     * A pointer to an optional application-defined function of type <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a>. This function is called in the context of the created thread before the function pointed to by <i>pfnThreadProc</i> is called. It will also receive <i>pData</i> as its argument. <b>SHCreateThreadWithHandle</b> waits for the function pointed to by <i>pfnCallback</i> to complete before returning to its caller. The return value for the function specified by <i>pfnCallback</i> is ignored.
     * @param {Pointer<Void>} pHandle Type: <b>HANDLE*</b>
     * 
     * A pointer to the <b>HANDLE</b> of the created thread. When it is no longer needed, this handle should be closed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function. This value can be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the thread is successfully created; otherwise, <b>FALSE</b>
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcreatethreadwithhandle
     * @since windows6.0.6000
     */
    static SHCreateThreadWithHandle(pfnThreadProc, pData, flags, pfnCallback, pHandle) {
        A_LastError := 0

        result := DllCall("SHLWAPI.dll\SHCreateThreadWithHandle", "ptr", pfnThreadProc, "ptr", pData, "uint", flags, "ptr", pfnCallback, "ptr", pHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Releases a thread reference before the thread procedure returns.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shreleasethreadref
     * @since windows5.1.2600
     */
    static SHReleaseThreadRef() {
        result := DllCall("SHLWAPI.dll\SHReleaseThreadRef", "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a halftone palette for the specified device context.
     * @remarks
     * This function behaves the same as <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createhalftonepalette">CreateHalftonePalette</a>. The palette that is returned depends on the device context in the following way:
     * 
     * 				
     * 
     * <ul>
     * <li>If <i>hdc</i> is set to <b>NULL</b>, a full palette is returned.</li>
     * <li>If the device context is indexed, a full palette is returned.</li>
     * <li>If the device context is not indexed, a default palette (VGA colors) is returned.</li>
     * </ul>
     * @param {Pointer<Void>} hdc Type: <b>HDC</b>
     * 
     * The device context.
     * @returns {Pointer<Void>} Type: <b>HPALETTE</b>
     * 
     * Returns the palette if successful; otherwise 0.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-shcreateshellpalette
     * @since windows5.0
     */
    static SHCreateShellPalette(hdc) {
        result := DllCall("SHLWAPI.dll\SHCreateShellPalette", "ptr", hdc)
        return result
    }

    /**
     * Converts colors from RGB to hue-luminance-saturation (HLS) format.
     * @param {Integer} clrRGB Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * The original RGB color.
     * @param {Pointer<UInt16>} pwHue Type: <b>WORD*</b>
     * 
     * A pointer to a value that, when this method returns successfully, receives the HLS hue value.
     * Can range from 0 to 240.
     * @param {Pointer<UInt16>} pwLuminance Type: <b>WORD*</b>
     * 
     * A pointer to a value that, when this method returns successfully, receives the HLS luminance value.
     * Can range from 0 to 240.
     * @param {Pointer<UInt16>} pwSaturation Type: <b>WORD*</b>
     * 
     * A pointer to a value that, when this method returns successfully, receives the HLS saturation value.
     * Can range from 0 to 240.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-colorrgbtohls
     * @since windows5.0
     */
    static ColorRGBToHLS(clrRGB, pwHue, pwLuminance, pwSaturation) {
        DllCall("SHLWAPI.dll\ColorRGBToHLS", "uint", clrRGB, "ushort*", pwHue, "ushort*", pwLuminance, "ushort*", pwSaturation)
    }

    /**
     * Converts colors from hue-luminance-saturation (HLS) to RGB format.
     * @param {Integer} wHue Type: <b>WORD</b>
     * 
     * The original HLS hue value.
     * Can range from 0 to 240.
     * @param {Integer} wLuminance Type: <b>WORD</b>
     * 
     * The original HLS luminance value.
     * Can range from 0 to 240.
     * @param {Integer} wSaturation Type: <b>WORD</b>
     * 
     * The original HLS saturation value.
     * Can range from 0 to 240.
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * Returns the RGB value.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-colorhlstorgb
     * @since windows5.0
     */
    static ColorHLSToRGB(wHue, wLuminance, wSaturation) {
        result := DllCall("SHLWAPI.dll\ColorHLSToRGB", "ushort", wHue, "ushort", wLuminance, "ushort", wSaturation, "uint")
        return result
    }

    /**
     * Changes the luminance of a RGB value. Hue and saturation are not affected.
     * @remarks
     * If <i>fScale</i> is set to <b>TRUE</b>, <i>n</i> can range from -1000 to +1000.
     * 
     * If <i>fScale</i> is set to <b>FALSE</b>, <i>n</i> can range from 0 to 1000. Available luminance values range from 0 to a maximum. If the requested value is negative or exceeds the maximum, the luminance will be set to either zero or the maximum value, respectively.
     * @param {Integer} clrRGB Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * The initial RGB value.
     * @param {Integer} n Type: <b>int</b>
     * 
     * The luminance in units of 0.1 percent of the total range. For example, a value of <i>n</i> = 50 corresponds to 5 percent of the maximum luminance.
     * @param {Integer} fScale Type: <b>BOOL</b>
     * 
     * If <i>fScale</i> is set to <b>TRUE</b>, <i>n</i> specifies how much to increment or decrement the current luminance. If <i>fScale</i> is set to <b>FALSE</b>, <i>n</i> specifies the absolute luminance.
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * Returns the modified RGB value.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-coloradjustluma
     * @since windows5.0
     */
    static ColorAdjustLuma(clrRGB, n, fScale) {
        result := DllCall("SHLWAPI.dll\ColorAdjustLuma", "uint", clrRGB, "int", n, "int", fScale, "uint")
        return result
    }

    /**
     * Determines whether Windows Internet Explorer is in the Enhanced Security Configuration.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if Internet Explorer is in the Enhanced Security Configuration, and <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/shlwapi/nf-shlwapi-isinternetescenabled
     * @since windows5.1.2600
     */
    static IsInternetESCEnabled() {
        result := DllCall("SHLWAPI.dll\IsInternetESCEnabled", "int")
        return result
    }

    /**
     * 
     * @param {Pointer<IMoniker>} pimkTrgt 
     * @param {Pointer<Char>} pwzLocation 
     * @param {Pointer<Char>} pwzFriendlyName 
     * @param {Pointer<IHlinkSite>} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {Pointer<IUnknown>} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @param {Pointer<Void>} ppvObj 
     * @returns {HRESULT} 
     */
    static HlinkCreateFromMoniker(pimkTrgt, pwzLocation, pwzFriendlyName, pihlsite, dwSiteData, piunkOuter, riid, ppvObj) {
        pwzLocation := pwzLocation is String? StrPtr(pwzLocation) : pwzLocation
        pwzFriendlyName := pwzFriendlyName is String? StrPtr(pwzFriendlyName) : pwzFriendlyName

        result := DllCall("hlink.dll\HlinkCreateFromMoniker", "ptr", pimkTrgt, "ptr", pwzLocation, "ptr", pwzFriendlyName, "ptr", pihlsite, "uint", dwSiteData, "ptr", piunkOuter, "ptr", riid, "ptr", ppvObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzTarget 
     * @param {Pointer<Char>} pwzLocation 
     * @param {Pointer<Char>} pwzFriendlyName 
     * @param {Pointer<IHlinkSite>} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {Pointer<IUnknown>} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @param {Pointer<Void>} ppvObj 
     * @returns {HRESULT} 
     */
    static HlinkCreateFromString(pwzTarget, pwzLocation, pwzFriendlyName, pihlsite, dwSiteData, piunkOuter, riid, ppvObj) {
        pwzTarget := pwzTarget is String? StrPtr(pwzTarget) : pwzTarget
        pwzLocation := pwzLocation is String? StrPtr(pwzLocation) : pwzLocation
        pwzFriendlyName := pwzFriendlyName is String? StrPtr(pwzFriendlyName) : pwzFriendlyName

        result := DllCall("hlink.dll\HlinkCreateFromString", "ptr", pwzTarget, "ptr", pwzLocation, "ptr", pwzFriendlyName, "ptr", pihlsite, "uint", dwSiteData, "ptr", piunkOuter, "ptr", riid, "ptr", ppvObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IDataObject>} piDataObj 
     * @param {Pointer<IHlinkSite>} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {Pointer<IUnknown>} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @param {Pointer<Void>} ppvObj 
     * @returns {HRESULT} 
     */
    static HlinkCreateFromData(piDataObj, pihlsite, dwSiteData, piunkOuter, riid, ppvObj) {
        result := DllCall("hlink.dll\HlinkCreateFromData", "ptr", piDataObj, "ptr", pihlsite, "uint", dwSiteData, "ptr", piunkOuter, "ptr", riid, "ptr", ppvObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IDataObject>} piDataObj 
     * @returns {HRESULT} 
     */
    static HlinkQueryCreateFromData(piDataObj) {
        result := DllCall("hlink.dll\HlinkQueryCreateFromData", "ptr", piDataObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IHlink>} pihl 
     * @param {Pointer<Guid>} riid 
     * @param {Pointer<IHlinkSite>} pihlsiteForClone 
     * @param {Integer} dwSiteData 
     * @param {Pointer<Void>} ppvObj 
     * @returns {HRESULT} 
     */
    static HlinkClone(pihl, riid, pihlsiteForClone, dwSiteData, ppvObj) {
        result := DllCall("hlink.dll\HlinkClone", "ptr", pihl, "ptr", riid, "ptr", pihlsiteForClone, "uint", dwSiteData, "ptr", ppvObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IUnknown>} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @param {Pointer<Void>} ppvObj 
     * @returns {HRESULT} 
     */
    static HlinkCreateBrowseContext(piunkOuter, riid, ppvObj) {
        result := DllCall("hlink.dll\HlinkCreateBrowseContext", "ptr", piunkOuter, "ptr", riid, "ptr", ppvObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzTarget 
     * @param {Pointer<Char>} pwzLocation 
     * @param {Pointer<IHlinkSite>} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {Pointer<IHlinkFrame>} pihlframe 
     * @param {Integer} grfHLNF 
     * @param {Pointer<IBindCtx>} pibc 
     * @param {Pointer<IBindStatusCallback>} pibsc 
     * @param {Pointer<IHlinkBrowseContext>} pihlbc 
     * @returns {HRESULT} 
     */
    static HlinkNavigateToStringReference(pwzTarget, pwzLocation, pihlsite, dwSiteData, pihlframe, grfHLNF, pibc, pibsc, pihlbc) {
        pwzTarget := pwzTarget is String? StrPtr(pwzTarget) : pwzTarget
        pwzLocation := pwzLocation is String? StrPtr(pwzLocation) : pwzLocation

        result := DllCall("hlink.dll\HlinkNavigateToStringReference", "ptr", pwzTarget, "ptr", pwzLocation, "ptr", pihlsite, "uint", dwSiteData, "ptr", pihlframe, "uint", grfHLNF, "ptr", pibc, "ptr", pibsc, "ptr", pihlbc, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IHlink>} pihl 
     * @param {Pointer<IHlinkFrame>} pihlframe 
     * @param {Integer} grfHLNF 
     * @param {Pointer<IBindCtx>} pbc 
     * @param {Pointer<IBindStatusCallback>} pibsc 
     * @param {Pointer<IHlinkBrowseContext>} pihlbc 
     * @returns {HRESULT} 
     */
    static HlinkNavigate(pihl, pihlframe, grfHLNF, pbc, pibsc, pihlbc) {
        result := DllCall("hlink.dll\HlinkNavigate", "ptr", pihl, "ptr", pihlframe, "uint", grfHLNF, "ptr", pbc, "ptr", pibsc, "ptr", pihlbc, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IHlinkFrame>} pihlframe 
     * @param {Pointer<IHlinkBrowseContext>} pihlbc 
     * @param {Integer} grfHLNF 
     * @param {Pointer<IMoniker>} pimkTarget 
     * @param {Pointer<Char>} pwzLocation 
     * @param {Pointer<Char>} pwzFriendlyName 
     * @param {Pointer<UInt32>} puHLID 
     * @returns {HRESULT} 
     */
    static HlinkOnNavigate(pihlframe, pihlbc, grfHLNF, pimkTarget, pwzLocation, pwzFriendlyName, puHLID) {
        pwzLocation := pwzLocation is String? StrPtr(pwzLocation) : pwzLocation
        pwzFriendlyName := pwzFriendlyName is String? StrPtr(pwzFriendlyName) : pwzFriendlyName

        result := DllCall("hlink.dll\HlinkOnNavigate", "ptr", pihlframe, "ptr", pihlbc, "uint", grfHLNF, "ptr", pimkTarget, "ptr", pwzLocation, "ptr", pwzFriendlyName, "uint*", puHLID, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IHlinkFrame>} pihlframe 
     * @param {Pointer<IHlinkBrowseContext>} pihlbc 
     * @param {Integer} uHLID 
     * @param {Pointer<IMoniker>} pimkTrgt 
     * @param {Pointer<Char>} pwzLocation 
     * @param {Pointer<Char>} pwzFriendlyName 
     * @returns {HRESULT} 
     */
    static HlinkUpdateStackItem(pihlframe, pihlbc, uHLID, pimkTrgt, pwzLocation, pwzFriendlyName) {
        pwzLocation := pwzLocation is String? StrPtr(pwzLocation) : pwzLocation
        pwzFriendlyName := pwzFriendlyName is String? StrPtr(pwzFriendlyName) : pwzFriendlyName

        result := DllCall("hlink.dll\HlinkUpdateStackItem", "ptr", pihlframe, "ptr", pihlbc, "uint", uHLID, "ptr", pimkTrgt, "ptr", pwzLocation, "ptr", pwzFriendlyName, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Integer} dwReserved 
     * @param {Pointer<IHlinkBrowseContext>} pihlbc 
     * @param {Pointer<IMoniker>} pimkOld 
     * @param {Pointer<IMoniker>} pimkNew 
     * @returns {HRESULT} 
     */
    static HlinkOnRenameDocument(dwReserved, pihlbc, pimkOld, pimkNew) {
        result := DllCall("hlink.dll\HlinkOnRenameDocument", "uint", dwReserved, "ptr", pihlbc, "ptr", pimkOld, "ptr", pimkNew, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IMoniker>} pimkReference 
     * @param {Integer} reserved 
     * @param {Pointer<IBindCtx>} pibc 
     * @param {Integer} cFmtetc 
     * @param {Pointer<FORMATETC>} rgFmtetc 
     * @param {Pointer<IBindStatusCallback>} pibsc 
     * @param {Pointer<IMoniker>} pimkBase 
     * @returns {HRESULT} 
     */
    static HlinkResolveMonikerForData(pimkReference, reserved, pibc, cFmtetc, rgFmtetc, pibsc, pimkBase) {
        result := DllCall("hlink.dll\HlinkResolveMonikerForData", "ptr", pimkReference, "uint", reserved, "ptr", pibc, "uint", cFmtetc, "ptr", rgFmtetc, "ptr", pibsc, "ptr", pimkBase, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzReference 
     * @param {Integer} reserved 
     * @param {Pointer<IBindCtx>} pibc 
     * @param {Integer} cFmtetc 
     * @param {Pointer<FORMATETC>} rgFmtetc 
     * @param {Pointer<IBindStatusCallback>} pibsc 
     * @param {Pointer<IMoniker>} pimkBase 
     * @returns {HRESULT} 
     */
    static HlinkResolveStringForData(pwzReference, reserved, pibc, cFmtetc, rgFmtetc, pibsc, pimkBase) {
        pwzReference := pwzReference is String? StrPtr(pwzReference) : pwzReference

        result := DllCall("hlink.dll\HlinkResolveStringForData", "ptr", pwzReference, "uint", reserved, "ptr", pibc, "uint", cFmtetc, "ptr", rgFmtetc, "ptr", pibsc, "ptr", pimkBase, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IBindCtx>} pibc 
     * @param {Pointer<Char>} pwzDisplayName 
     * @param {Integer} fNoForceAbs 
     * @param {Pointer<UInt32>} pcchEaten 
     * @param {Pointer<IMoniker>} ppimk 
     * @returns {HRESULT} 
     */
    static HlinkParseDisplayName(pibc, pwzDisplayName, fNoForceAbs, pcchEaten, ppimk) {
        pwzDisplayName := pwzDisplayName is String? StrPtr(pwzDisplayName) : pwzDisplayName

        result := DllCall("hlink.dll\HlinkParseDisplayName", "ptr", pibc, "ptr", pwzDisplayName, "int", fNoForceAbs, "uint*", pcchEaten, "ptr", ppimk, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzAdditionalHeaders 
     * @param {Pointer<Void>} phwnd 
     * @param {Pointer<Char>} pszUsername 
     * @param {Pointer<Char>} pszPassword 
     * @param {Pointer<IUnknown>} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @param {Pointer<Void>} ppvObj 
     * @returns {HRESULT} 
     */
    static HlinkCreateExtensionServices(pwzAdditionalHeaders, phwnd, pszUsername, pszPassword, piunkOuter, riid, ppvObj) {
        pwzAdditionalHeaders := pwzAdditionalHeaders is String? StrPtr(pwzAdditionalHeaders) : pwzAdditionalHeaders
        pszUsername := pszUsername is String? StrPtr(pszUsername) : pszUsername
        pszPassword := pszPassword is String? StrPtr(pszPassword) : pszPassword

        result := DllCall("hlink.dll\HlinkCreateExtensionServices", "ptr", pwzAdditionalHeaders, "ptr", phwnd, "ptr", pszUsername, "ptr", pszPassword, "ptr", piunkOuter, "ptr", riid, "ptr", ppvObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IBindCtx>} pibc 
     * @param {Pointer<IMoniker>} pimkIn 
     * @param {Pointer<IMoniker>} ppimkOut 
     * @returns {HRESULT} 
     */
    static HlinkPreprocessMoniker(pibc, pimkIn, ppimkOut) {
        result := DllCall("hlink.dll\HlinkPreprocessMoniker", "ptr", pibc, "ptr", pimkIn, "ptr", ppimkOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<IUnknown>} piunk 
     * @param {Pointer<IStream>} pistm 
     * @param {Integer} fClearDirty 
     * @returns {HRESULT} 
     */
    static OleSaveToStreamEx(piunk, pistm, fClearDirty) {
        result := DllCall("hlink.dll\OleSaveToStreamEx", "ptr", piunk, "ptr", pistm, "int", fClearDirty, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Integer} uReference 
     * @param {Pointer<Char>} pwzReference 
     * @returns {HRESULT} 
     */
    static HlinkSetSpecialReference(uReference, pwzReference) {
        pwzReference := pwzReference is String? StrPtr(pwzReference) : pwzReference

        result := DllCall("hlink.dll\HlinkSetSpecialReference", "uint", uReference, "ptr", pwzReference, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Integer} uReference 
     * @param {Pointer<Char>} ppwzReference 
     * @returns {HRESULT} 
     */
    static HlinkGetSpecialReference(uReference, ppwzReference) {
        result := DllCall("hlink.dll\HlinkGetSpecialReference", "uint", uReference, "ptr", ppwzReference, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Integer} grfHLSHORTCUTF 
     * @param {Pointer<IHlink>} pihl 
     * @param {Pointer<Char>} pwzDir 
     * @param {Pointer<Char>} pwzFileName 
     * @param {Pointer<Char>} ppwzShortcutFile 
     * @param {Integer} dwReserved 
     * @returns {HRESULT} 
     */
    static HlinkCreateShortcut(grfHLSHORTCUTF, pihl, pwzDir, pwzFileName, ppwzShortcutFile, dwReserved) {
        pwzDir := pwzDir is String? StrPtr(pwzDir) : pwzDir
        pwzFileName := pwzFileName is String? StrPtr(pwzFileName) : pwzFileName

        result := DllCall("hlink.dll\HlinkCreateShortcut", "uint", grfHLSHORTCUTF, "ptr", pihl, "ptr", pwzDir, "ptr", pwzFileName, "ptr", ppwzShortcutFile, "uint", dwReserved, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Integer} grfHLSHORTCUTF 
     * @param {Pointer<IMoniker>} pimkTarget 
     * @param {Pointer<Char>} pwzLocation 
     * @param {Pointer<Char>} pwzDir 
     * @param {Pointer<Char>} pwzFileName 
     * @param {Pointer<Char>} ppwzShortcutFile 
     * @param {Integer} dwReserved 
     * @returns {HRESULT} 
     */
    static HlinkCreateShortcutFromMoniker(grfHLSHORTCUTF, pimkTarget, pwzLocation, pwzDir, pwzFileName, ppwzShortcutFile, dwReserved) {
        pwzLocation := pwzLocation is String? StrPtr(pwzLocation) : pwzLocation
        pwzDir := pwzDir is String? StrPtr(pwzDir) : pwzDir
        pwzFileName := pwzFileName is String? StrPtr(pwzFileName) : pwzFileName

        result := DllCall("hlink.dll\HlinkCreateShortcutFromMoniker", "uint", grfHLSHORTCUTF, "ptr", pimkTarget, "ptr", pwzLocation, "ptr", pwzDir, "ptr", pwzFileName, "ptr", ppwzShortcutFile, "uint", dwReserved, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Integer} grfHLSHORTCUTF 
     * @param {Pointer<Char>} pwzTarget 
     * @param {Pointer<Char>} pwzLocation 
     * @param {Pointer<Char>} pwzDir 
     * @param {Pointer<Char>} pwzFileName 
     * @param {Pointer<Char>} ppwzShortcutFile 
     * @param {Integer} dwReserved 
     * @returns {HRESULT} 
     */
    static HlinkCreateShortcutFromString(grfHLSHORTCUTF, pwzTarget, pwzLocation, pwzDir, pwzFileName, ppwzShortcutFile, dwReserved) {
        pwzTarget := pwzTarget is String? StrPtr(pwzTarget) : pwzTarget
        pwzLocation := pwzLocation is String? StrPtr(pwzLocation) : pwzLocation
        pwzDir := pwzDir is String? StrPtr(pwzDir) : pwzDir
        pwzFileName := pwzFileName is String? StrPtr(pwzFileName) : pwzFileName

        result := DllCall("hlink.dll\HlinkCreateShortcutFromString", "uint", grfHLSHORTCUTF, "ptr", pwzTarget, "ptr", pwzLocation, "ptr", pwzDir, "ptr", pwzFileName, "ptr", ppwzShortcutFile, "uint", dwReserved, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzShortcutFileName 
     * @param {Pointer<IHlinkSite>} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {Pointer<IUnknown>} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @param {Pointer<Void>} ppvObj 
     * @returns {HRESULT} 
     */
    static HlinkResolveShortcut(pwzShortcutFileName, pihlsite, dwSiteData, piunkOuter, riid, ppvObj) {
        pwzShortcutFileName := pwzShortcutFileName is String? StrPtr(pwzShortcutFileName) : pwzShortcutFileName

        result := DllCall("hlink.dll\HlinkResolveShortcut", "ptr", pwzShortcutFileName, "ptr", pihlsite, "uint", dwSiteData, "ptr", piunkOuter, "ptr", riid, "ptr", ppvObj, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzShortcutFileName 
     * @param {Pointer<IMoniker>} ppimkTarget 
     * @param {Pointer<Char>} ppwzLocation 
     * @returns {HRESULT} 
     */
    static HlinkResolveShortcutToMoniker(pwzShortcutFileName, ppimkTarget, ppwzLocation) {
        pwzShortcutFileName := pwzShortcutFileName is String? StrPtr(pwzShortcutFileName) : pwzShortcutFileName

        result := DllCall("hlink.dll\HlinkResolveShortcutToMoniker", "ptr", pwzShortcutFileName, "ptr", ppimkTarget, "ptr", ppwzLocation, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzShortcutFileName 
     * @param {Pointer<Char>} ppwzTarget 
     * @param {Pointer<Char>} ppwzLocation 
     * @returns {HRESULT} 
     */
    static HlinkResolveShortcutToString(pwzShortcutFileName, ppwzTarget, ppwzLocation) {
        pwzShortcutFileName := pwzShortcutFileName is String? StrPtr(pwzShortcutFileName) : pwzShortcutFileName

        result := DllCall("hlink.dll\HlinkResolveShortcutToString", "ptr", pwzShortcutFileName, "ptr", ppwzTarget, "ptr", ppwzLocation, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzFileName 
     * @returns {HRESULT} 
     */
    static HlinkIsShortcut(pwzFileName) {
        pwzFileName := pwzFileName is String? StrPtr(pwzFileName) : pwzFileName

        result := DllCall("hlink.dll\HlinkIsShortcut", "ptr", pwzFileName, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzParams 
     * @param {Pointer<Char>} pwzName 
     * @param {Pointer<Char>} ppwzValue 
     * @returns {HRESULT} 
     */
    static HlinkGetValueFromParams(pwzParams, pwzName, ppwzValue) {
        pwzParams := pwzParams is String? StrPtr(pwzParams) : pwzParams
        pwzName := pwzName is String? StrPtr(pwzName) : pwzName

        result := DllCall("hlink.dll\HlinkGetValueFromParams", "ptr", pwzParams, "ptr", pwzName, "ptr", ppwzValue, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Char>} pwzURL 
     * @param {Integer} grfFlags 
     * @param {Pointer<Char>} ppwzTranslatedURL 
     * @returns {HRESULT} 
     */
    static HlinkTranslateURL(pwzURL, grfFlags, ppwzTranslatedURL) {
        pwzURL := pwzURL is String? StrPtr(pwzURL) : pwzURL

        result := DllCall("hlink.dll\HlinkTranslateURL", "ptr", pwzURL, "uint", grfFlags, "ptr", ppwzTranslatedURL, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.This function differs from PathIsUNC in that it also allows you to extract the name of the server from the path.
     * @param {Pointer<Char>} pszPath A pointer to the path string.
     * @param {Pointer<Char>} ppszServer A pointer to a string that, when this function returns successfully, receives the server portion of the UNC path. This value can be <b>NULL</b> if you don't need this information.
     * @returns {Integer} Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathisuncex
     * @since windows8.0
     */
    static PathIsUNCEx(pszPath, ppszServer) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathIsUNCEx", "ptr", pszPath, "ptr", ppszServer, "int")
        return result
    }

    /**
     * Determines whether a path string refers to the root of a volume.This function differs from PathIsRoot in that it accepts paths with &#0034;\\&#0034;, &#0034;\\?\&#0034; and &#0034;\\?\UNC\&#0034; prefixes.
     * @remarks
     * The following table shows the <b>PathCchIsRoot</b> return value for various paths.
     *             
     *                 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Path</th>
     * <th>PathCchIsRoot</th>
     * </tr>
     * <tr>
     * <td>"c:\"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"c:"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"c:\path1"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\path1"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"path1"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\path1\path2"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"\\path1\path2\"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\path1\path2\path3"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\path1"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"\\path1\"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"\\?\UNC\"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"\\?\UNC\path1\path2"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"\\?\UNC\path1\path2\"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\?\UNC\path1\path2\path3"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\?\UNC\path1"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"\\?\UNC\path1\"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\?\c:\"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"\\?\c:"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\?\c:\path1"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\?\Volume{guid}\"</td>
     * <td>TRUE</td>
     * </tr>
     * <tr>
     * <td>"\\?\Volume{guid}"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>"\\?\Volume{guid}\path1"</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>NULL</td>
     * <td>FALSE</td>
     * </tr>
     * <tr>
     * <td>""</td>
     * <td>FALSE</td>
     * </tr>
     * </table>
     * 
     * 
     * This function returns <b>TRUE</b> for paths such as "\", "<i>X</i>:\" or "&#92;&#92;<i>server</i>&#92;<i>share</i>". Paths such as "..\path2" or "&#92;&#92;<i>server</i>\" return <b>FALSE</b>.
     * @param {Pointer<Char>} pszPath A pointer to the path string.
     * @returns {Integer} Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchisroot
     * @since windows8.0
     */
    static PathCchIsRoot(pszPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchIsRoot", "ptr", pszPath, "int")
        return result
    }

    /**
     * Adds a backslash to the end of a string to create the correct syntax for a path. (PathCchAddBackslashEx)
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, the buffer contains the string with the appended backslash. This value should not be <b>NULL</b>.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<Char>} ppszEnd A value that, when this function returns successfully, receives the address of a pointer to the terminating null character at the end of the string.
     * @param {Pointer<UIntPtr>} pcchRemaining A pointer to a value that, when this function returns successfully, is set to the number of unused characters in the destination buffer, including the terminating null character.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the path string already ends in a backslash, or an error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchaddbackslashex
     * @since windows8.0
     */
    static PathCchAddBackslashEx(pszPath, cchPath, ppszEnd, pcchRemaining) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAddBackslashEx", "ptr", pszPath, "ptr", cchPath, "ptr", ppszEnd, "ptr*", pcchRemaining, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Adds a backslash to the end of a string to create the correct syntax for a path. (PathCchAddBackslash)
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, the buffer contains the string with the appended backslash. This value should not be <b>NULL</b>.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the path string already ends in a backslash, or an error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchaddbackslash
     * @since windows8.0
     */
    static PathCchAddBackslash(pszPath, cchPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAddBackslash", "ptr", pszPath, "ptr", cchPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes the trailing backslash from the end of a path string.This function differs from PathCchRemoveBackslash in that it can return a pointer to the new end of the string and report the number of unused characters remaining in the buffer.This function differs from PathRemoveBackslash in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @remarks
     * This function will not remove the backslash from a root path string, such as "C:\".
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, the string contains the path with any trailing backslash removed. If no trailing backslash was found, the string is unchanged.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<Char>} ppszEnd A value that, when this function returns successfully, receives the address of a pointer to end of the new string. If the string is a root path such as "C:\", the pointer points to the backslash; otherwise the pointer points to the string's terminating null character.
     * @param {Pointer<UIntPtr>} pcchRemaining A pointer to a value that, when this function returns successfully, receives the number of unused characters in the destination buffer, including the terminating null character. If the string is a root path such as "C:\", this count includes the backslash in that string.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the string was a root path or if no backslash was found, or an error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchremovebackslashex
     * @since windows8.0
     */
    static PathCchRemoveBackslashEx(pszPath, cchPath, ppszEnd, pcchRemaining) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRemoveBackslashEx", "ptr", pszPath, "ptr", cchPath, "ptr", ppszEnd, "ptr*", pcchRemaining, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes the trailing backslash from the end of a path string.This function differs from PathRemoveBackslash in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @remarks
     * This function will not remove the backslash from a root path string, such as "C:\".
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, the string contains the path with any trailing backslash removed. If no trailing backslash was found, the string is unchanged.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the string was a root path or if no backslash was found, or an error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchremovebackslash
     * @since windows8.0
     */
    static PathCchRemoveBackslash(pszPath, cchPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRemoveBackslash", "ptr", pszPath, "ptr", cchPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.This function differs from PathSkipRoot in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {Pointer<Char>} pszPath A pointer to the path string.
     * @param {Pointer<Char>} ppszRootEnd The address of a pointer that, when this function returns successfully, points to the first character in a path following the drive letter or UNC server/share path elements. If the path consists of only a root, this value will point to the string's terminating null character.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchskiproot
     * @since windows8.0
     */
    static PathCchSkipRoot(pszPath, ppszRootEnd) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchSkipRoot", "ptr", pszPath, "ptr", ppszRootEnd, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes all file and directory elements in a path except for the root information.This function differs from PathStripToRoot in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @remarks
     * Some examples of the effect of this function:
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Initial string</th>
     * <th>Final string</th>
     * </tr>
     * <tr>
     * <td>"C:\path1\path2\file"</td>
     * <td>"C:\"</td>
     * </tr>
     * <tr>
     * <td>"\\path1\path2\path3"</td>
     * <td>"\\path1\path2"</td>
     * </tr>
     * <tr>
     * <td>"\path1"</td>
     * <td>"\"</td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, this string contains only the root information taken from that path.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the path was truncated, <b>S_FALSE</b> if the path was already just a root, or an <b>HRESULT</b> failure code.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchstriptoroot
     * @since windows8.0
     */
    static PathCchStripToRoot(pszPath, cchPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchStripToRoot", "ptr", pszPath, "ptr", cchPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes the last element in a path string, whether that element is a file name or a directory name.
     * @remarks
     * The following table shows the effect of this function on a selection of path strings.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Original String</th>
     * <th>Returned String</th>
     * </tr>
     * <tr>
     * <td>"C:\path1"</td>
     * <td>"C:\"</td>
     * </tr>
     * <tr>
     * <td>"C:\path1\path2"</td>
     * <td>"C:\path1"</td>
     * </tr>
     * <tr>
     * <td>"C:\path1\"</td>
     * <td>"C:\path1"</td>
     * </tr>
     * <tr>
     * <td>"\\path1\path2\path3"</td>
     * <td>"\\path1\path2"</td>
     * </tr>
     * <tr>
     * <td>"\path1"</td>
     * <td>"\"</td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} pszPath A pointer to the fully-qualified path string. When this function returns successfully, the string will have had its last element and its leading backslash removed. This function does not affect root paths such as "C:\". In the case of a root path, the path string is returned unaltered. If a path string ends with a trailing backslash, only that backslash is removed.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if there was nothing to remove, or an error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchremovefilespec
     * @since windows8.0
     */
    static PathCchRemoveFileSpec(pszPath, cchPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRemoveFileSpec", "ptr", pszPath, "ptr", cchPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Searches a path to find its file name extension, such as &quot;.exe&quot; or &quot;.ini&quot;.
     * @param {Pointer<Char>} pszPath A pointer to the path to search.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<Char>} ppszExt The address of a pointer that, when this function returns successfully, points to the "." character that precedes the extension within <i>pszPath</i>. If no extension is found, it points to the string's terminating null character.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchfindextension
     * @since windows8.0
     */
    static PathCchFindExtension(pszPath, cchPath, ppszExt) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchFindExtension", "ptr", pszPath, "ptr", cchPath, "ptr", ppszExt, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Adds a file name extension to a path string.This function differs from PathAddExtension in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, the buffer contains the string with the appended extension. This value should not be <b>NULL</b>.
     * 
     * <div class="alert"><b>Note</b>If the original string already has a file name extension present, no new extension will be added and the original string will be unchanged.</div>
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<Char>} pszExt A pointer to the file name extension string. This string can be given either with or without a preceding period (".ext" or "ext").
     * @returns {HRESULT} This function returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function succeeded. Note that this also includes the case of an empty extension, such as a period with no characters following it. In that case, the original string is returned unaltered.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value can be caused by several things, such as the <i>pszPath</i> param being set to <b>NULL</b>, the <i>cchPath</i> being set to 0 or a value greater than <b>PATHCCH_MAX_CCH</b>, or the extension string containing illegal characters or otherwise not being a valid extension.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The original string already has an extension.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer is too small to hold the returned string.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchaddextension
     * @since windows8.0
     */
    static PathCchAddExtension(pszPath, cchPath, pszExt) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String? StrPtr(pszExt) : pszExt

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAddExtension", "ptr", pszPath, "ptr", cchPath, "ptr", pszExt, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Replaces a file name's extension at the end of a path string with a new extension.
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, this value points to the same string, but with the renamed or added extension.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<Char>} pszExt A pointer to the new extension string. The leading '.' character is optional. In the case of an empty string (""), any existing extension in the path string is removed.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchrenameextension
     * @since windows8.0
     */
    static PathCchRenameExtension(pszPath, cchPath, pszExt) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String? StrPtr(pszExt) : pszExt

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRenameExtension", "ptr", pszPath, "ptr", cchPath, "ptr", pszExt, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes the file name extension from a path, if one is present.This function differs from PathRemoveExtension in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, the string contains the path with any extension removed. If no extension was found, the string is unchanged.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if no extension was found, or an error code otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchremoveextension
     * @since windows8.0
     */
    static PathCchRemoveExtension(pszPath, cchPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRemoveExtension", "ptr", pszPath, "ptr", cchPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Simplifies a path by removing navigation elements such as &quot;.&quot; and &quot;..&quot; to produce a direct, well-formed path.This function differs from PathCchCanonicalize in that it allows for a longer final path to be constructed.This function differs from PathAllocCanonicalize in that the caller must declare the size of the returned string, which is stored on the stack.This function differs from PathCanonicalize in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @remarks
     * This function responds to the strings "." and ".." embedded in a path. The ".." string indicates to remove the immediately preceding path segment. The "." string indicates to skip over the next path segment. Note that the root segment of the path cannot be removed. If there are more ".." strings than there are path segments, the function returns <b>S_OK</b> and the buffer pointed to by <i>pszPathOut</i> contains a single backslash, "\\".
     * 
     * All trailing periods are removed from the path, except when preceded by the "*" wild card character. In that case, a single period is retained after the '*' character, but all other trailing periods are removed.
     * 
     * If the resulting path is a root drive ("x:"), a backslash is appended ("x:\\").
     * 
     * This function does not convert forward slashes (/) into back slashes (\\). With untrusted input, this function by itself, cannot be used to convert paths into a form that can be compared with other paths for sub-path or identity. Callers that need that ability should convert forward to back slashes before using this function.
     * 
     * The following examples show the effect of these strings.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Original string</th>
     * <th>Canonicalized string</th>
     * </tr>
     * <tr>
     * <td>C:\name_1\.\name_2\..\name_3</td>
     * <td>C:\name_1\name_3</td>
     * </tr>
     * <tr>
     * <td>C:\name_1\..\name_2\.\name_3</td>
     * <td>C:\name_2\name_3</td>
     * </tr>
     * <tr>
     * <td>C:\name_1\name_2\.\name_3\..\name_4</td>
     * <td>C:\name_1\name_2\name_4</td>
     * </tr>
     * <tr>
     * <td>C:\name_1\.\name_2\.\name_3\..\name_4\..</td>
     * <td>C:\name_1\name_2</td>
     * </tr>
     * <tr>
     * <td>C:\name_1\*...</td>
     * <td>C:\name_1\*.</td>
     * </tr>
     * <tr>
     * <td>C:\..</td>
     * <td>C:\</td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} pszPathOut A pointer to a buffer that, when this function returns successfully, receives the edited path string.
     * @param {Pointer} cchPathOut The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
     * @param {Pointer<Char>} pszPathIn A pointer to the original path string. If this value is <b>NULL</b>, points to an empty string, or results in an empty string once the "." and ".." elements are removed, a single backslash is copied to the buffer pointed to by <i>pszPathOut</i>.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow the building of \\?\ paths longer than <b>MAX_PATH</b>. Note that <i>cchPathOut</i> must be greater than <b>MAX_PATH</b>. If it is not, this flag is ignored.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a id="____pathcch_ensure_trailing_slash"></a><dl>
     * <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including but not limited to the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>cchPathOut</i> value is greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A path segment has more than <b>PATHCCH_MAX_CCH</b> characters, or, if the <b>PATHCCH_ALLOW_LONG_PATHS</b> flag is not set, exceeds the standard path segment length limit of 256 characters.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate a buffer of the necessary size.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchcanonicalizeex
     * @since windows8.0
     */
    static PathCchCanonicalizeEx(pszPathOut, cchPathOut, pszPathIn, dwFlags) {
        pszPathOut := pszPathOut is String? StrPtr(pszPathOut) : pszPathOut
        pszPathIn := pszPathIn is String? StrPtr(pszPathIn) : pszPathIn

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchCanonicalizeEx", "ptr", pszPathOut, "ptr", cchPathOut, "ptr", pszPathIn, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a path string into a canonical form.This function differs from PathCchCanonicalizeEx in that you are restricted to a final path of length MAX_PATH.This function differs from PathAllocCanonicalize in that the caller must declare the size of the returned string, which is stored on the stack.This function differs from PathCanonicalize in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @remarks
     * This function responds to the strings "." and ".." embedded in a path. The ".." string indicates to remove the immediately preceding path segment. The "." string indicates to skip over the next path segment. Note that the root segment of the path cannot be removed. If there are more ".." strings than there are path segments, the function returns S_OK and the buffer pointed to by <i>pszPathOut</i> contains a single backslash, "\\".
     * 
     * All trailing periods are removed from the path, except when preceded by the "*" wild card character. In that case, a single period is retained after the '*' character, but all other trailing periods are removed.
     * 
     * If the resulting path is a root drive ("x:"), a backslash is appended ("x:\\").
     * 
     * This function does not convert forward slashes (/) into back slashes (\\). With untrusted input, this function by itself, cannot be used to convert paths into a form that can be compared with other paths for sub-path or identity. Callers that need that ability should convert forward to back slashes before using this function.
     * 
     * The following examples show the effect of these strings.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Original string</th>
     * <th>Canonicalized string</th>
     * </tr>
     * <tr>
     * <td>C:\name_1\.\name_2\..\name_3</td>
     * <td>C:\name_1\name_3</td>
     * </tr>
     * <tr>
     * <td>C:\name_1\..\name_2\.\name_3</td>
     * <td>C:\name_2\name_3</td>
     * </tr>
     * <tr>
     * <td>C:\name_1\name_2\.\name_3\..\name_4</td>
     * <td>C:\name_1\name_2\name_4</td>
     * </tr>
     * <tr>
     * <td>C:\name_1\.\name_2\.\name_3\..\name_4\..</td>
     * <td>C:\name_1\name_2</td>
     * </tr>
     * <tr>
     * <td>C:\name_1\*...</td>
     * <td>C:\name_1\*.</td>
     * </tr>
     * <tr>
     * <td>C:\..</td>
     * <td>C:\</td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} pszPathOut A pointer to a buffer that, when this function returns successfully, receives the canonicalized path string.
     * @param {Pointer} cchPathOut The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
     * @param {Pointer<Char>} pszPathIn A pointer to the original path string. If this value points to an empty string, or results in an empty string once the "." and ".." elements are removed, a single backslash is copied to the buffer pointed to by <i>pszPathOut</i>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>cchPathOut</i> value is greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A path segment exceeds the standard path segment length limit of 256 characters.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate a buffer of the necessary size.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchcanonicalize
     * @since windows8.0
     */
    static PathCchCanonicalize(pszPathOut, cchPathOut, pszPathIn) {
        pszPathOut := pszPathOut is String? StrPtr(pszPathOut) : pszPathOut
        pszPathIn := pszPathIn is String? StrPtr(pszPathIn) : pszPathIn

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchCanonicalize", "ptr", pszPathOut, "ptr", cchPathOut, "ptr", pszPathIn, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Combines two path fragments into a single path. (PathCchCombineEx)
     * @remarks
     * If both <i>pszPathIn</i> and <i>pszMore</i> are <b>NULL</b> or point to empty strings, a single backslash is copied to the buffer pointed to by <i>pszPathOut</i>.
     * @param {Pointer<Char>} pszPathOut A pointer to a buffer that, when this function returns successfully, receives the combined path string. This parameter can point to the same buffer as <i>pszPathIn</i> or <i>pszMore</i>.
     * @param {Pointer} cchPathOut The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
     * @param {Pointer<Char>} pszPathIn A pointer to the first path string. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszMore A pointer to the second path string. If this path begins with a single backslash, it is combined with only the root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualified, it is copied directly to the output buffer without being combined with the other path. This value can be <b>NULL</b>.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow the construction of \\?\ paths longer than <b>MAX_PATH</b>. Note that <i>cchPathOut</i> must be greater than <b>MAX_PATH</b>. If it is not, this flag is ignored.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} This function returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function succeeded. Note that this also includes the case of an empty extension, such as a period with no characters following it. In that case, the original string is returned unaltered.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value can be caused by several things, such as the <i>pszPathOut</i> param being set to <b>NULL</b>, or the <i>cchPathOut</i> value being set to 0 or a value greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate enough memory to perform the operation.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of one or both of the original paths exceeded <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchcombineex
     * @since windows8.0
     */
    static PathCchCombineEx(pszPathOut, cchPathOut, pszPathIn, pszMore, dwFlags) {
        pszPathOut := pszPathOut is String? StrPtr(pszPathOut) : pszPathOut
        pszPathIn := pszPathIn is String? StrPtr(pszPathIn) : pszPathIn
        pszMore := pszMore is String? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchCombineEx", "ptr", pszPathOut, "ptr", cchPathOut, "ptr", pszPathIn, "ptr", pszMore, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Combines two path fragments into a single path. (PathCchCombine)
     * @remarks
     * If both <i>pszPathIn</i> and <i>pszMore</i> are <b>NULL</b> or point to empty strings, a single backslash is copied to the buffer pointed to by <i>pszPathOut</i>.
     * @param {Pointer<Char>} pszPathOut A pointer to a buffer that, when this function returns successfully, receives the combined path string. This parameter can point to the same buffer as <i>pszPathIn</i> or <i>pszMore</i>.
     * @param {Pointer} cchPathOut The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
     * @param {Pointer<Char>} pszPathIn A pointer to the first path string. This value can be <b>NULL</b>.
     * @param {Pointer<Char>} pszMore A pointer to the second path string. If this path begins with a single backslash, it is combined with only the root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualified, it is copied directly to the output buffer without being combined with the other path. This value can be <b>NULL</b>.
     * @returns {HRESULT} This function returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function succeeded. Note that this also includes the case of an empty extension, such as a period with no characters following it. In that case, the original string is returned unaltered.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value can be caused by several things, such as the <i>pszPathOut</i> param being set to <b>NULL</b>, or the <i>cchPathOut</i> value being set to 0 or a value greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate enough memory to perform the operation.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of one or both of the original paths exceeded <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchcombine
     * @since windows8.0
     */
    static PathCchCombine(pszPathOut, cchPathOut, pszPathIn, pszMore) {
        pszPathOut := pszPathOut is String? StrPtr(pszPathOut) : pszPathOut
        pszPathIn := pszPathIn is String? StrPtr(pszPathIn) : pszPathIn
        pszMore := pszMore is String? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchCombine", "ptr", pszPathOut, "ptr", cchPathOut, "ptr", pszPathIn, "ptr", pszMore, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Appends one path to the end of another.This function differs from PathCchAppend in that it allows for a longer final path to be constructed.This function differs from PathAppend in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @remarks
     * This function inserts a backslash between the two strings, if one is not already present.
     * @param {Pointer<Char>} pszPath A pointer to a buffer that, on entry, contains the original path. When this function returns successfully, the buffer contains the original path plus the appended path.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<Char>} pszMore A pointer the path to append to the end of the path pointed to by <i>pszPath</i>. UNC paths and paths that begin with the sequence \\?\ are accepted and recognized as fully-qualified paths. These paths replace the string pointed to by <i>pszPath</i> instead of being appended to it.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>. 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">Allow the building of \\?\ paths longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>. 
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the following. 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either <i>pszPath</i> or <i>pszMore</i> is <b>NULL</b>, <i>cchPath</i> is 0, or <i>cchPath</i> is greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The resulting string would exceed <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate a buffer of the necessary size.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchappendex
     * @since windows8.0
     */
    static PathCchAppendEx(pszPath, cchPath, pszMore, dwFlags) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszMore := pszMore is String? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAppendEx", "ptr", pszPath, "ptr", cchPath, "ptr", pszMore, "uint", dwFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Appends one path to the end of another.This function differs from PathCchAppendEx in that you are restricted to a final path of length MAX_PATH.This function differs from PathAppend in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @remarks
     * This function inserts a backslash between the two strings, if one is not already present.
     * @param {Pointer<Char>} pszPath A pointer to a buffer that, on entry, contains the original path. When this function returns successfully, the buffer contains the original path plus the appended path.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<Char>} pszMore A pointer to the path to append to the end of the path pointed to by <i>pszPath</i>. UNC paths and paths beginning with the "\\?\" sequence are accepted and recognized as fully-qualified paths. These paths replace the string pointed to by <i>pszPath</i> instead of being appended to it.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either <i>pszPath</i> or <i>pszMore</i> is <b>NULL</b>, <i>cchPath</i> is 0, or <i>cchPath</i> is greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The resulting string would exceed <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate a buffer of the necessary size.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchappend
     * @since windows8.0
     */
    static PathCchAppend(pszPath, cchPath, pszMore) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath
        pszMore := pszMore is String? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAppend", "ptr", pszPath, "ptr", cchPath, "ptr", pszMore, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes the &quot;\\?\&quot; prefix, if present, from a file path.
     * @param {Pointer<Char>} pszPath A pointer to the path string. When this function returns successfully, the same path string will have had the prefix removed, if the prefix was present. If no prefix was present, the string will be unchanged.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the prefix was removed, <b>S_FALSE</b> if the path did not have a prefix to remove, or an <b>HRESULT</b> failure code.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathcchstripprefix
     * @since windows8.0
     */
    static PathCchStripPrefix(pszPath, cchPath) {
        pszPath := pszPath is String? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchStripPrefix", "ptr", pszPath, "ptr", cchPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Concatenates two path fragments into a single path.
     * @remarks
     * While either <i>pszPathIn</i> or <i>pszMore</i> can <b>NULL</b>, they cannot both be <b>NULL</b>.
     * 
     * This function supports these alternate path forms:
     * 
     * <ul>
     * <li>\\?\</li>
     * <li>\\?\\UNC\</li>
     * <li>\\?\Volume{guid}\</li>
     * </ul>
     * @param {Pointer<Char>} pszPathIn A pointer to the first path string.
     * @param {Pointer<Char>} pszMore A pointer to the second path string. If this path begins with a single backslash, it is combined with only the root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualified, it is copied directly to the output buffer without being combined with the other path.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">Allow the construction of \\?\ paths longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a id="____pathcch_ensure_trailing_slash"></a><dl>
     * <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} ppszPathOut The address of a pointer to a buffer that, when this function returns successfully, receives the combined path string. It is the responsibility of the caller to free this resource, when it is no longer needed, by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function. This value cannot be <b>NULL</b>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathalloccombine
     * @since windows8.0
     */
    static PathAllocCombine(pszPathIn, pszMore, dwFlags, ppszPathOut) {
        pszPathIn := pszPathIn is String? StrPtr(pszPathIn) : pszPathIn
        pszMore := pszMore is String? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathAllocCombine", "ptr", pszPathIn, "ptr", pszMore, "uint", dwFlags, "ptr", ppszPathOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Converts a path string into a canonical form.This function differs from PathCchCanonicalize and PathCchCanonicalizeEx in that it returns the result on the heap.
     * @remarks
     * This function supports these alternate path forms:
     * 
     * <ul>
     * <li>\\?\</li>
     * <li>\\?\\UNC\</li>
     * <li>\\?\Volume{guid}\</li>
     * </ul>
     * 
     * This function does not convert forward slashes (/) into back slashes (\\). With untrusted input, this function by itself, cannot be used to convert paths into a form that can be compared with other paths for sub-path or identity. Callers that need that ability should convert forward to back slashes before using this function.
     * @param {Pointer<Char>} pszPathIn A pointer to a buffer that contains the original string. This value cannot be <b>NULL</b>.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">Allow the building of \\?\ paths longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a id="____pathcch_ensure_trailing_slash"></a><dl>
     * <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} ppszPathOut The address of a pointer to a buffer that, when this function returns successfully, receives the canonicalized path string. It is the responsibility of the caller to free this resource, when it is no longer needed, by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function. This value cannot be <b>NULL</b>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/pathcch/nf-pathcch-pathalloccanonicalize
     * @since windows8.0
     */
    static PathAllocCanonicalize(pszPathIn, dwFlags, ppszPathOut) {
        pszPathIn := pszPathIn is String? StrPtr(pszPathIn) : pszPathIn

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathAllocCanonicalize", "ptr", pszPathIn, "uint", dwFlags, "ptr", ppszPathOut, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enables an app to register a callback function through which it can be notified that its library is going into or coming out of a suspended state.
     * @param {Pointer<PAPPSTATE_CHANGE_ROUTINE>} Routine A pointer to a callback function that is called when the app enters or leaves the suspended state. See <a href="https://docs.microsoft.com/windows/desktop/api/appnotify/nc-appnotify-pappstate_change_routine">PAPPSTATE_CHANGE_ROUTINE</a> for more detail on this function.
     * @param {Pointer<Void>} Context App-specific context information that the app uses when going into or out of a suspended state. This is commonly a "this" pointer.
     * @param {Pointer<IntPtr>} Registration When this function returns successfully, this parameter receives the address of a pointer to a value that can be used to identify the registration. Store this value to use with <a href="https://docs.microsoft.com/windows/desktop/api/appnotify/nf-appnotify-unregisterappstatechangenotification">UnregisterAppStateChangeNotification</a>.
     * @returns {Integer} A standard Win32 status code.
     * @see https://learn.microsoft.com/windows/win32/api/appnotify/nf-appnotify-registerappstatechangenotification
     */
    static RegisterAppStateChangeNotification(Routine, Context, Registration) {
        result := DllCall("api-ms-win-core-psm-appnotify-l1-1-0.dll\RegisterAppStateChangeNotification", "ptr", Routine, "ptr", Context, "ptr*", Registration, "uint")
        return result
    }

    /**
     * Cancels a change notification registered through RegisterAppStateChangeNotification.
     * @param {Pointer} Registration A pointer to the registration handle retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/appnotify/nf-appnotify-registerappstatechangenotification">RegisterAppStateChangeNotification</a> through its <i>Registration</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/appnotify/nf-appnotify-unregisterappstatechangenotification
     */
    static UnregisterAppStateChangeNotification(Registration) {
        DllCall("api-ms-win-core-psm-appnotify-l1-1-0.dll\UnregisterAppStateChangeNotification", "ptr", Registration)
    }

    /**
     * 
     * @param {Pointer<PAPPCONSTRAIN_CHANGE_ROUTINE>} Routine 
     * @param {Pointer<Void>} Context 
     * @param {Pointer<IntPtr>} Registration 
     * @returns {Integer} 
     */
    static RegisterAppConstrainedChangeNotification(Routine, Context, Registration) {
        result := DllCall("api-ms-win-core-psm-appnotify-l1-1-1.dll\RegisterAppConstrainedChangeNotification", "ptr", Routine, "ptr", Context, "ptr*", Registration, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer} Registration 
     * @returns {String} Nothing - always returns an empty string
     */
    static UnregisterAppConstrainedChangeNotification(Registration) {
        DllCall("api-ms-win-core-psm-appnotify-l1-1-1.dll\UnregisterAppConstrainedChangeNotification", "ptr", Registration)
    }

;@endregion Methods
}
