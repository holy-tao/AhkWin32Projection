#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\..\Win32Handle.ahk
#Include ..\..\..\..\Guid.ahk
#Include ..\..\Foundation\Apis.ahk
#Include ..\..\System\LibraryLoader\Apis.ahk
#Include .\IShellItemArray.ahk
#Include .\IEnumAssocHandlers.ahk
#Include .\IFileOperation.ahk
#Include ..\..\System\Com\IMalloc.ahk
#Include .\IShellItem.ahk
#Include ..\..\System\Com\Apis.ahk
#Include .\IShellFolder.ahk
#Include ..\..\Foundation\HANDLE.ahk
#Include ..\..\System\Com\IUnknown.ahk
#Include ..\..\System\Com\IDataObject.ahk
#Include ..\..\System\Com\IEnumFORMATETC.ahk
#Include .\IShellView.ahk
#Include .\IContextMenu.ahk
#Include .\HPSXA.ahk
#Include ..\..\System\Com\IMoniker.ahk
#Include ..\..\Foundation\HINSTANCE.ahk
#Include ..\WindowsAndMessaging\HICON.ahk
#Include ..\..\Foundation\BSTR.ahk
#Include ..\..\System\Registry\HKEY.ahk
#Include ..\..\System\Com\IStream.ahk
#Include ..\..\Foundation\HWND.ahk
#Include ..\..\Graphics\Gdi\HPALETTE.ahk

/**
 * @namespace Windows.Win32.UI.Shell
 * @version v4.0.30319
 */
class Shell {

;@region Constants

    /**
     * @type {Integer (Int32)}
     */
    static HLINK_E_FIRST => -2147221248

    /**
     * @type {Integer (Int32)}
     */
    static HLINK_S_FIRST => 262400

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CPL_LAUNCH => 2024

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CPL_LAUNCHED => 2025

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_DYNAMIC_RES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_INIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_GETCOUNT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_INQUIRE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_SELECT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_DBLCLK => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_STOP => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_EXIT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_NEWINQUIRE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_STARTWPARMSA => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_STARTWPARMSW => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_STARTWPARMS => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CPL_SETUP => 200

    /**
     * @type {Integer (Int32)}
     */
    static HLINK_S_DONTHIDE => 262400

    /**
     * @type {Guid}
     */
    static FOLDERID_NetworkFolder => Guid("{d20beec4-5ca8-4905-ae3b-bf251ea09b53}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ComputerFolder => Guid("{0ac0837c-bbf8-452a-850d-79d08e667ca7}")

    /**
     * @type {Guid}
     */
    static FOLDERID_InternetFolder => Guid("{4d9f7874-4e0c-4904-967b-40b0d20c3e4b}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ControlPanelFolder => Guid("{82a74aeb-aeb4-465c-a014-d097ee346d63}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PrintersFolder => Guid("{76fc4e2d-d6ad-4519-a663-37bd56068185}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SyncManagerFolder => Guid("{43668bf8-c14e-49b2-97c9-747784d784b7}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SyncSetupFolder => Guid("{0f214138-b1d3-4a90-bba9-27cbc0c5389a}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ConflictFolder => Guid("{4bfefb45-347d-4006-a5be-ac0cb0567192}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SyncResultsFolder => Guid("{289a9a43-be44-4057-a41b-587a76d7e7f9}")

    /**
     * @type {Guid}
     */
    static FOLDERID_RecycleBinFolder => Guid("{b7534046-3ecb-4c18-be4e-64cd4cb7d6ac}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ConnectionsFolder => Guid("{6f0cd92b-2e97-45d1-88ff-b0d186b8dedd}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Fonts => Guid("{fd228cb7-ae11-4ae3-864c-16f3910ab8fe}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Desktop => Guid("{b4bfcc3a-db2c-424c-b029-7fe99a87c641}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Startup => Guid("{b97d20bb-f46a-4c97-ba10-5e3608430854}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Programs => Guid("{a77f5d77-2e2b-44c3-a6a2-aba601054a51}")

    /**
     * @type {Guid}
     */
    static FOLDERID_StartMenu => Guid("{625b53c3-ab48-4ec1-ba1f-a1ef4146fc19}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Recent => Guid("{ae50c081-ebd2-438a-8655-8a092e34987a}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SendTo => Guid("{8983036c-27c0-404b-8f08-102d10dcfd74}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Documents => Guid("{fdd39ad0-238f-46af-adb4-6c85480369c7}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Favorites => Guid("{1777f761-68ad-4d8a-87bd-30b759fa33dd}")

    /**
     * @type {Guid}
     */
    static FOLDERID_NetHood => Guid("{c5abbf53-e17f-4121-8900-86626fc2c973}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PrintHood => Guid("{9274bd8d-cfd1-41c3-b35e-b13f55a758f4}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Templates => Guid("{a63293e8-664e-48db-a079-df759e0509f7}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CommonStartup => Guid("{82a5ea35-d9cd-47c5-9629-e15d2f714e6e}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CommonPrograms => Guid("{0139d44e-6afe-49f2-8690-3dafcae6ffb8}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CommonStartMenu => Guid("{a4115719-d62e-491d-aa7c-e74b8be3b067}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicDesktop => Guid("{c4aa340d-f20f-4863-afef-f87ef2e6ba25}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ProgramData => Guid("{62ab5d82-fdc1-4dc3-a9dd-070d1d495d97}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CommonTemplates => Guid("{b94237e7-57ac-4347-9151-b08c6c32d1f7}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicDocuments => Guid("{ed4824af-dce4-45a8-81e2-fc7965083634}")

    /**
     * @type {Guid}
     */
    static FOLDERID_RoamingAppData => Guid("{3eb685db-65f9-4cf6-a03a-e3ef65729f3d}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalAppData => Guid("{f1b32785-6fba-4fcf-9d55-7b8e7f157091}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalAppDataLow => Guid("{a520a1a4-1780-4ff6-bd18-167343c5af16}")

    /**
     * @type {Guid}
     */
    static FOLDERID_InternetCache => Guid("{352481e8-33be-4251-ba85-6007caedcf9d}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Cookies => Guid("{2b0f765d-c0e9-4171-908e-08a611b84ff6}")

    /**
     * @type {Guid}
     */
    static FOLDERID_History => Guid("{d9dc8a3b-b784-432e-a781-5a1130a75963}")

    /**
     * @type {Guid}
     */
    static FOLDERID_System => Guid("{1ac14e77-02e7-4e5d-b744-2eb1ae5198b7}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SystemX86 => Guid("{d65231b0-b2f1-4857-a4ce-a8e7c6ea7d27}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Windows => Guid("{f38bf404-1d43-42f2-9305-67de0b28fc23}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Profile => Guid("{5e6c858f-0e22-4760-9afe-ea3317b67173}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Pictures => Guid("{33e28130-4e1e-4676-835a-98395c3bc3bb}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ProgramFilesX86 => Guid("{7c5a40ef-a0fb-4bfc-874a-c0f2e0b9fa8e}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ProgramFilesCommonX86 => Guid("{de974d24-d9c6-4d3e-bf91-f4455120b917}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ProgramFilesX64 => Guid("{6d809377-6af0-444b-8957-a3773f02200e}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ProgramFilesCommonX64 => Guid("{6365d5a7-0f0d-45e5-87f6-0da56b6a4f7d}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ProgramFiles => Guid("{905e63b6-c1bf-494e-b29c-65b732d3d21a}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ProgramFilesCommon => Guid("{f7f1ed05-9f6d-47a2-aaae-29d317c6f066}")

    /**
     * @type {Guid}
     */
    static FOLDERID_UserProgramFiles => Guid("{5cd7aee2-2219-4a67-b85d-6c9ce15660cb}")

    /**
     * @type {Guid}
     */
    static FOLDERID_UserProgramFilesCommon => Guid("{bcbd3057-ca5c-4622-b42d-bc56db0ae516}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AdminTools => Guid("{724ef170-a42d-4fef-9f26-b60e846fba4f}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CommonAdminTools => Guid("{d0384e7d-bac3-4797-8f14-cba229b392b5}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Music => Guid("{4bd8d571-6d19-48d3-be97-422220080e43}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Videos => Guid("{18989b1d-99b5-455b-841c-ab7c74e4ddfc}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Ringtones => Guid("{c870044b-f49e-4126-a9c3-b52a1ff411e8}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicPictures => Guid("{b6ebfb86-6907-413c-9af7-4fc2abf07cc5}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicMusic => Guid("{3214fab5-9757-4298-bb61-92a9deaa44ff}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicVideos => Guid("{2400183a-6185-49fb-a2d8-4a392a602ba3}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicRingtones => Guid("{e555ab60-153b-4d17-9f04-a5fe99fc15ec}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ResourceDir => Guid("{8ad10c31-2adb-4296-a8f7-e4701232c972}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalizedResourcesDir => Guid("{2a00375e-224c-49de-b8d1-440df7ef3ddc}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CommonOEMLinks => Guid("{c1bae2d0-10df-4334-bedd-7aa20b227a9d}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CDBurning => Guid("{9e52ab10-f80d-49df-acb8-4330f5687855}")

    /**
     * @type {Guid}
     */
    static FOLDERID_UserProfiles => Guid("{0762d272-c50a-4bb0-a382-697dcd729b80}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Playlists => Guid("{de92c1c7-837f-4f69-a3bb-86e631204a23}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SamplePlaylists => Guid("{15ca69b3-30ee-49c1-ace1-6b5ec372afb5}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SampleMusic => Guid("{b250c668-f57d-4ee1-a63c-290ee7d1aa1f}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SamplePictures => Guid("{c4900540-2379-4c75-844b-64e6faf8716b}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SampleVideos => Guid("{859ead94-2e85-48ad-a71a-0969cb56a6cd}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PhotoAlbums => Guid("{69d2cf90-fc33-4fb7-9a0c-ebb0f0fcb43c}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Public => Guid("{dfdf76a2-c82a-4d63-906a-5644ac457385}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ChangeRemovePrograms => Guid("{df7266ac-9274-4867-8d55-3bd661de872d}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AppUpdates => Guid("{a305ce99-f527-492b-8b1a-7e76fa98d6e4}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AddNewPrograms => Guid("{de61d971-5ebc-4f02-a3a9-6c82895e5c04}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Downloads => Guid("{374de290-123f-4565-9164-39c4925e467b}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicDownloads => Guid("{3d644c9b-1fb8-4f30-9b45-f670235f79c0}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SavedSearches => Guid("{7d1d3a04-debb-4115-95cf-2f29da2920da}")

    /**
     * @type {Guid}
     */
    static FOLDERID_QuickLaunch => Guid("{52a4f021-7b75-48a9-9f6b-4b87a210bc8f}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Contacts => Guid("{56784854-c6cb-462b-8169-88e350acb882}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SidebarParts => Guid("{a75d362e-50fc-4fb7-ac2c-a8beaa314493}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SidebarDefaultParts => Guid("{7b396e54-9ec5-4300-be0a-2482ebae1a26}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicGameTasks => Guid("{debf2536-e1a8-4c59-b6a2-414586476aea}")

    /**
     * @type {Guid}
     */
    static FOLDERID_GameTasks => Guid("{054fae61-4dd8-4787-80b6-090220c4b700}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SavedGames => Guid("{4c5c32ff-bb9d-43b0-b5b4-2d72e54eaaa4}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Games => Guid("{cac52c1a-b53d-4edc-92d7-6b2e8ac19434}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SEARCH_MAPI => Guid("{98ec0e18-2098-4d44-8644-66979315a281}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SEARCH_CSC => Guid("{ee32e446-31ca-4aba-814f-a5ebd2fd6d5e}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Links => Guid("{bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968}")

    /**
     * @type {Guid}
     */
    static FOLDERID_UsersFiles => Guid("{f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}")

    /**
     * @type {Guid}
     */
    static FOLDERID_UsersLibraries => Guid("{a302545d-deff-464b-abe8-61c8648d939b}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SearchHome => Guid("{190337d1-b8ca-4121-a639-6d472d16972a}")

    /**
     * @type {Guid}
     */
    static FOLDERID_OriginalImages => Guid("{2c36c0aa-5812-4b87-bfd0-4cd0dfb19b39}")

    /**
     * @type {Guid}
     */
    static FOLDERID_DocumentsLibrary => Guid("{7b0db17d-9cd2-4a93-9733-46cc89022e7c}")

    /**
     * @type {Guid}
     */
    static FOLDERID_MusicLibrary => Guid("{2112ab0a-c86a-4ffe-a368-0de96e47012e}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PicturesLibrary => Guid("{a990ae9f-a03b-4e80-94bc-9912d7504104}")

    /**
     * @type {Guid}
     */
    static FOLDERID_VideosLibrary => Guid("{491e922f-5643-4af4-a7eb-4e7a138d8174}")

    /**
     * @type {Guid}
     */
    static FOLDERID_RecordedTVLibrary => Guid("{1a6fdba2-f42d-4358-a798-b74d745926c5}")

    /**
     * @type {Guid}
     */
    static FOLDERID_HomeGroup => Guid("{52528a6b-b9e3-4add-b60d-588c2dba842d}")

    /**
     * @type {Guid}
     */
    static FOLDERID_HomeGroupCurrentUser => Guid("{9b74b6a3-0dfd-4f11-9e78-5f7800f2e772}")

    /**
     * @type {Guid}
     */
    static FOLDERID_DeviceMetadataStore => Guid("{5ce4a5e9-e4eb-479d-b89f-130c02886155}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Libraries => Guid("{1b3ea5dc-b587-4786-b4ef-bd1dc332aeae}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicLibraries => Guid("{48daf80b-e6cf-4f4e-b800-0e69d84ee384}")

    /**
     * @type {Guid}
     */
    static FOLDERID_UserPinned => Guid("{9e3995ab-1f9c-4f13-b827-48b24b6c7174}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ImplicitAppShortcuts => Guid("{bcb5256f-79f6-4cee-b725-dc34e402fd46}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AccountPictures => Guid("{008ca0b1-55b4-4c56-b8a8-4de4b299d3be}")

    /**
     * @type {Guid}
     */
    static FOLDERID_PublicUserTiles => Guid("{0482af6c-08f1-4c34-8c90-e17ec98b1e17}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AppsFolder => Guid("{1e87508d-89c2-42f0-8a7e-645a0f50ca58}")

    /**
     * @type {Guid}
     */
    static FOLDERID_StartMenuAllPrograms => Guid("{f26305ef-6948-40b9-b255-81453d09c785}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CommonStartMenuPlaces => Guid("{a440879f-87a0-4f7d-b700-0207b966194a}")

    /**
     * @type {Guid}
     */
    static FOLDERID_ApplicationShortcuts => Guid("{a3918781-e5f2-4890-b3d9-a7e54332328c}")

    /**
     * @type {Guid}
     */
    static FOLDERID_RoamingTiles => Guid("{00bcfc5a-ed94-4e48-96a1-3f6217f21990}")

    /**
     * @type {Guid}
     */
    static FOLDERID_RoamedTileImages => Guid("{aaa8d5a5-f1d6-4259-baa8-78e7ef60835e}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Screenshots => Guid("{b7bede81-df94-4682-a7d8-57a52620b86f}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CameraRoll => Guid("{ab5fb87b-7ce2-4f83-915d-550846c9537b}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SkyDrive => Guid("{a52bba46-e9e1-435f-b3d9-28daa648c0f6}")

    /**
     * @type {Guid}
     */
    static FOLDERID_OneDrive => Guid("{a52bba46-e9e1-435f-b3d9-28daa648c0f6}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SkyDriveDocuments => Guid("{24d89e24-2f19-4534-9dde-6a6671fbb8fe}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SkyDrivePictures => Guid("{339719b5-8c47-4894-94c2-d8f77add44a6}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SkyDriveMusic => Guid("{c3f2459e-80d6-45dc-bfef-1f769f2be730}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SkyDriveCameraRoll => Guid("{767e6811-49cb-4273-87c2-20f355e1085b}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SearchHistory => Guid("{0d4c3db6-03a3-462f-a0e6-08924c41b5d4}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SearchTemplates => Guid("{7e636bfe-dfa9-4d5e-b456-d7b39851d8a9}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CameraRollLibrary => Guid("{2b20df75-1eda-4039-8097-38798227d5b7}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SavedPictures => Guid("{3b193882-d3ad-4eab-965a-69829d1fb59f}")

    /**
     * @type {Guid}
     */
    static FOLDERID_SavedPicturesLibrary => Guid("{e25b5812-be88-4bd9-94b0-29233477b6c3}")

    /**
     * @type {Guid}
     */
    static FOLDERID_RetailDemo => Guid("{12d4c69e-24ad-4923-be19-31321c43a767}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Device => Guid("{1c2ac1dc-4358-4b6c-9733-af21156576f0}")

    /**
     * @type {Guid}
     */
    static FOLDERID_DevelopmentFiles => Guid("{dbe8e08e-3053-4bbc-b183-2a7b2b191e59}")

    /**
     * @type {Guid}
     */
    static FOLDERID_Objects3D => Guid("{31c0dd25-9439-4f12-bf41-7ff4eda38722}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AppCaptures => Guid("{edc0fe71-98d8-4f4a-b920-c8dc133cb165}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalDocuments => Guid("{f42ee2d3-909f-4907-8871-4c22fc0bf756}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalPictures => Guid("{0ddd015d-b06c-45d5-8c4c-f59713854639}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalVideos => Guid("{35286a68-3c57-41a1-bbb1-0eae73d76c95}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalMusic => Guid("{a0c69a99-21c8-4671-8703-7934162fcf1d}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalDownloads => Guid("{7d83ee9b-2244-4e70-b1f5-5393042af1e4}")

    /**
     * @type {Guid}
     */
    static FOLDERID_RecordedCalls => Guid("{2f8b40c2-83ed-48ee-b383-a1f157ec6f9a}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AllAppMods => Guid("{7ad67899-66af-43ba-9156-6aad42e6c596}")

    /**
     * @type {Guid}
     */
    static FOLDERID_CurrentAppMods => Guid("{3db40b20-2a30-4dbe-917e-771dd21dd099}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AppDataDesktop => Guid("{b2c5e279-7add-439f-b28c-c41fe1bbf672}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AppDataDocuments => Guid("{7be16610-1f7f-44ac-bff0-83e15f2ffca1}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AppDataFavorites => Guid("{7cfbefbc-de1f-45aa-b843-a542ac536cc9}")

    /**
     * @type {Guid}
     */
    static FOLDERID_AppDataProgramData => Guid("{559d40a3-a036-40fa-af61-84cb430a4d34}")

    /**
     * @type {Guid}
     */
    static FOLDERID_LocalStorage => Guid("{b3eb08d3-a1f3-496b-865a-42b536cda0ec}")

    /**
     * @type {Guid}
     */
    static CLSID_InternetShortcut => Guid("{fbf23b40-e3f0-101b-8488-00aa003e56f8}")

    /**
     * @type {Guid}
     */
    static CLSID_NetworkDomain => Guid("{46e06680-4bf0-11d1-83ee-00a0c90dc849}")

    /**
     * @type {Guid}
     */
    static CLSID_NetworkServer => Guid("{c0542a90-4bf0-11d1-83ee-00a0c90dc849}")

    /**
     * @type {Guid}
     */
    static CLSID_NetworkShare => Guid("{54a754c0-4bf0-11d1-83ee-00a0c90dc849}")

    /**
     * @type {Guid}
     */
    static CLSID_MyComputer => Guid("{20d04fe0-3aea-1069-a2d8-08002b30309d}")

    /**
     * @type {Guid}
     */
    static CLSID_Internet => Guid("{871c5380-42a0-1069-a2ea-08002b30309d}")

    /**
     * @type {Guid}
     */
    static CLSID_RecycleBin => Guid("{645ff040-5081-101b-9f08-00aa002f954e}")

    /**
     * @type {Guid}
     */
    static CLSID_ControlPanel => Guid("{21ec2020-3aea-1069-a2dd-08002b30309d}")

    /**
     * @type {Guid}
     */
    static CLSID_Printers => Guid("{2227a280-3aea-1069-a2de-08002b30309d}")

    /**
     * @type {Guid}
     */
    static CLSID_MyDocuments => Guid("{450d8fba-ad25-11d0-98a8-0800361b1103}")

    /**
     * @type {String}
     */
    static STR_MYDOCS_CLSID => "{450D8FBA-AD25-11D0-98A8-0800361B1103}"

    /**
     * @type {Guid}
     */
    static CATID_BrowsableShellExt => Guid("{00021490-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CATID_BrowseInPlace => Guid("{00021491-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CATID_DeskBand => Guid("{00021492-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CATID_InfoBand => Guid("{00021493-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CATID_CommBand => Guid("{00021494-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static FMTID_Intshcut => Guid("{000214a0-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static FMTID_InternetSite => Guid("{000214a1-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CGID_Explorer => Guid("{000214d0-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CGID_ShellDocView => Guid("{000214d1-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CGID_ShellServiceObject => Guid("{000214d2-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CGID_ExplorerBarDoc => Guid("{000214d3-0000-0000-c000-000000000046}")

    /**
     * @type {Guid}
     */
    static CLSID_FolderShortcut => Guid("{0afaced1-e828-11d1-9187-b532f1e9575d}")

    /**
     * @type {Guid}
     */
    static CLSID_CFSIconOverlayManager => Guid("{63b51f81-c868-11d0-999c-00c04fd655e1}")

    /**
     * @type {Guid}
     */
    static CLSID_ShellThumbnailDiskCache => Guid("{1ebdcf80-a200-11d0-a3a4-00c04fd706ec}")

    /**
     * @type {Guid}
     */
    static SID_DefView => Guid("{6d12fe80-7911-11cf-9534-0000c05bae0b}")

    /**
     * @type {Guid}
     */
    static CGID_DefView => Guid("{4af07f10-d231-11d0-b942-00a0c90312e1}")

    /**
     * @type {Guid}
     */
    static CLSID_MenuBand => Guid("{5b4dae26-b807-11d0-9815-00c04fd91972}")

    /**
     * @type {Guid}
     */
    static VID_LargeIcons => Guid("{0057d0e0-3573-11cf-ae69-08002b2e1262}")

    /**
     * @type {Guid}
     */
    static VID_SmallIcons => Guid("{089000c0-3573-11cf-ae69-08002b2e1262}")

    /**
     * @type {Guid}
     */
    static VID_List => Guid("{0e1fa5e0-3573-11cf-ae69-08002b2e1262}")

    /**
     * @type {Guid}
     */
    static VID_Details => Guid("{137e7700-3573-11cf-ae69-08002b2e1262}")

    /**
     * @type {Guid}
     */
    static VID_Tile => Guid("{65f125e5-7be1-4810-ba9d-d271c8432ce3}")

    /**
     * @type {Guid}
     */
    static VID_Content => Guid("{30c2c434-0889-4c8d-985d-a9f71830b0a9}")

    /**
     * @type {Guid}
     */
    static VID_Thumbnails => Guid("{8bebb290-52d0-11d0-b7f4-00c04fd706ec}")

    /**
     * @type {Guid}
     */
    static VID_ThumbStrip => Guid("{8eefa624-d1e9-445b-94b7-74fbce2ea11a}")

    /**
     * @type {Guid}
     */
    static SID_SInPlaceBrowser => Guid("{1d2ae02b-3655-46cc-b63a-285988153bca}")

    /**
     * @type {Guid}
     */
    static SID_SSearchBoxInfo => Guid("{142daa61-516b-4713-b49c-fb985ef82998}")

    /**
     * @type {Guid}
     */
    static SID_CommandsPropertyBag => Guid("{6e043250-4416-485c-b143-e62a760d9fe5}")

    /**
     * @type {Guid}
     */
    static CLSID_CURLSearchHook => Guid("{cfbfae00-17a6-11d0-99cb-00c04fd64497}")

    /**
     * @type {Guid}
     */
    static CLSID_AutoComplete => Guid("{00bb2763-6a77-11d0-a535-00c04fd7d062}")

    /**
     * @type {Guid}
     */
    static CLSID_ACLHistory => Guid("{00bb2764-6a77-11d0-a535-00c04fd7d062}")

    /**
     * @type {Guid}
     */
    static CLSID_ACListISF => Guid("{03c036f1-a186-11d0-824a-00aa005b4383}")

    /**
     * @type {Guid}
     */
    static CLSID_ACLMRU => Guid("{6756a641-de71-11d0-831b-00aa005b4383}")

    /**
     * @type {Guid}
     */
    static CLSID_ACLMulti => Guid("{00bb2765-6a77-11d0-a535-00c04fd7d062}")

    /**
     * @type {Guid}
     */
    static CLSID_ACLCustomMRU => Guid("{6935db93-21e8-4ccc-beb9-9fe3c77a297a}")

    /**
     * @type {Guid}
     */
    static CLSID_ProgressDialog => Guid("{f8383852-fcd3-11d1-a6b9-006097df5bd4}")

    /**
     * @type {Guid}
     */
    static SID_STopLevelBrowser => Guid("{4c96be40-915c-11cf-99d3-00aa004ae837}")

    /**
     * @type {Guid}
     */
    static CLSID_FileTypes => Guid("{b091e540-83e3-11cf-a713-0020afd79762}")

    /**
     * @type {Guid}
     */
    static CLSID_ActiveDesktop => Guid("{75048700-ef1f-11d0-9888-006097deacf9}")

    /**
     * @type {Guid}
     */
    static CLSID_QueryAssociations => Guid("{a07034fd-6caa-4954-ac3f-97a27216f98a}")

    /**
     * @type {Guid}
     */
    static CLSID_LinkColumnProvider => Guid("{24f14f02-7b1c-11d1-838f-0000f80461cf}")

    /**
     * @type {Guid}
     */
    static CGID_ShortCut => Guid("{93a68750-951a-11d1-946f-000000000000}")

    /**
     * @type {Guid}
     */
    static CLSID_InternetButtons => Guid("{1e796980-9cc5-11d1-a83f-00c04fc99d61}")

    /**
     * @type {Guid}
     */
    static CLSID_MSOButtons => Guid("{178f34b8-a282-11d2-86c5-00c04f8eea99}")

    /**
     * @type {Guid}
     */
    static CLSID_ToolbarExtButtons => Guid("{2ce4b5d8-a28f-11d2-86c5-00c04f8eea99}")

    /**
     * @type {Guid}
     */
    static CLSID_DarwinAppPublisher => Guid("{cfccc7a0-a282-11d1-9082-006008059382}")

    /**
     * @type {Guid}
     */
    static CLSID_DocHostUIHandler => Guid("{7057e952-bd1b-11d1-8919-00c04fc2c836}")

    /**
     * @type {Guid}
     */
    static PSGUID_SHELLDETAILS => Guid("{28636aa6-953d-11d2-b5d6-00c04fd918d0}")

    /**
     * @type {Guid}
     */
    static FMTID_ShellDetails => Guid("{28636aa6-953d-11d2-b5d6-00c04fd918d0}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_FINDDATA => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PID_NETRESOURCE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PID_DESCRIPTIONID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_WHICHFOLDER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PID_NETWORKLOCATION => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PID_COMPUTERNAME => 5

    /**
     * @type {Guid}
     */
    static FMTID_Storage => Guid("{b725f130-47ef-101a-a5f1-02608c9eebac}")

    /**
     * @type {Guid}
     */
    static PSGUID_IMAGEPROPERTIES => Guid("{14b81da1-0135-4d31-96d9-6cbfc9671a99}")

    /**
     * @type {Guid}
     */
    static FMTID_ImageProperties => Guid("{14b81da1-0135-4d31-96d9-6cbfc9671a99}")

    /**
     * @type {Guid}
     */
    static PSGUID_CUSTOMIMAGEPROPERTIES => Guid("{7ecd8b0e-c136-4a9b-9411-4ebd6673ccc3}")

    /**
     * @type {Guid}
     */
    static FMTID_CustomImageProperties => Guid("{7ecd8b0e-c136-4a9b-9411-4ebd6673ccc3}")

    /**
     * @type {Guid}
     */
    static PSGUID_LIBRARYPROPERTIES => Guid("{5d76b67f-9b3d-44bb-b6ae-25da4f638a67}")

    /**
     * @type {Guid}
     */
    static FMTID_LibraryProperties => Guid("{5d76b67f-9b3d-44bb-b6ae-25da4f638a67}")

    /**
     * @type {Guid}
     */
    static PSGUID_DISPLACED => Guid("{9b174b33-40ff-11d2-a27e-00c04fc30871}")

    /**
     * @type {Guid}
     */
    static FMTID_Displaced => Guid("{9b174b33-40ff-11d2-a27e-00c04fc30871}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_DISPLACED_FROM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_DISPLACED_DATE => 3

    /**
     * @type {Guid}
     */
    static PSGUID_BRIEFCASE => Guid("{328d8b21-7729-4bfc-954c-902b329d56b0}")

    /**
     * @type {Guid}
     */
    static FMTID_Briefcase => Guid("{328d8b21-7729-4bfc-954c-902b329d56b0}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_SYNC_COPY_IN => 2

    /**
     * @type {Guid}
     */
    static PSGUID_MISC => Guid("{9b174b34-40ff-11d2-a27e-00c04fc30871}")

    /**
     * @type {Guid}
     */
    static FMTID_Misc => Guid("{9b174b34-40ff-11d2-a27e-00c04fc30871}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_MISC_STATUS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_MISC_ACCESSCOUNT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PID_MISC_OWNER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PID_HTMLINFOTIPFILE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PID_MISC_PICS => 6

    /**
     * @type {Guid}
     */
    static PSGUID_WEBVIEW => Guid("{f2275480-f782-4291-bd94-f13693513aec}")

    /**
     * @type {Guid}
     */
    static FMTID_WebView => Guid("{f2275480-f782-4291-bd94-f13693513aec}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_DISPLAY_PROPERTIES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PID_INTROTEXT => 1

    /**
     * @type {Guid}
     */
    static PSGUID_MUSIC => Guid("{56a3372e-ce9c-11d2-9f0e-006097c686f6}")

    /**
     * @type {Guid}
     */
    static FMTID_MUSIC => Guid("{56a3372e-ce9c-11d2-9f0e-006097c686f6}")

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_ARTIST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_SONGTITLE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_ALBUM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_YEAR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_COMMENT => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_TRACK => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_GENRE => 11

    /**
     * @type {Integer (UInt32)}
     */
    static PIDSI_LYRICS => 12

    /**
     * @type {Guid}
     */
    static PSGUID_DRM => Guid("{aeac19e4-89ae-4508-b9b7-bb867abee2ed}")

    /**
     * @type {Guid}
     */
    static FMTID_DRM => Guid("{aeac19e4-89ae-4508-b9b7-bb867abee2ed}")

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_PROTECTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_DESCRIPTION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_PLAYCOUNT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_PLAYSTARTS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PIDDRSI_PLAYEXPIRES => 6

    /**
     * @type {Guid}
     */
    static PSGUID_VIDEO => Guid("{64440491-4c8b-11d1-8b70-080036b11a03}")

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_STREAM_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_FRAME_WIDTH => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_FRAME_HEIGHT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_TIMELENGTH => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_FRAME_COUNT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_FRAME_RATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_DATA_RATE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_SAMPLE_SIZE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_COMPRESSION => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PIDVSI_STREAM_NUMBER => 11

    /**
     * @type {Guid}
     */
    static PSGUID_AUDIO => Guid("{64440490-4c8b-11d1-8b70-080036b11a03}")

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_FORMAT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_TIMELENGTH => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_AVG_DATA_RATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_SAMPLE_RATE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_SAMPLE_SIZE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_CHANNEL_COUNT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_STREAM_NUMBER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_STREAM_NAME => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PIDASI_COMPRESSION => 10

    /**
     * @type {Guid}
     */
    static PSGUID_CONTROLPANEL => Guid("{305ca226-d286-468e-b848-2b2e8e697b74}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_CONTROLPANEL_CATEGORY => 2

    /**
     * @type {Guid}
     */
    static PSGUID_VOLUME => Guid("{9b174b35-40ff-11d2-a27e-00c04fc30871}")

    /**
     * @type {Guid}
     */
    static FMTID_Volume => Guid("{9b174b35-40ff-11d2-a27e-00c04fc30871}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_VOLUME_FREE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_VOLUME_CAPACITY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PID_VOLUME_FILESYSTEM => 4

    /**
     * @type {Guid}
     */
    static PSGUID_SHARE => Guid("{d8c3986f-813b-449c-845d-87b95d674ade}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_SHARE_CSC_STATUS => 2

    /**
     * @type {Guid}
     */
    static PSGUID_LINK => Guid("{b9b4b3fc-2b51-4a42-b5d8-324146afcf25}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_LINK_TARGET => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PID_LINK_TARGET_TYPE => 3

    /**
     * @type {Guid}
     */
    static PSGUID_QUERY_D => Guid("{49691c90-7e17-101a-a91c-08002b2ecda9}")

    /**
     * @type {Guid}
     */
    static FMTID_Query => Guid("{49691c90-7e17-101a-a91c-08002b2ecda9}")

    /**
     * @type {Integer (UInt32)}
     */
    static PID_QUERY_RANK => 2

    /**
     * @type {Guid}
     */
    static PSGUID_SUMMARYINFORMATION => Guid("{f29f85e0-4ff9-1068-ab91-08002b27b3d9}")

    /**
     * @type {Guid}
     */
    static PSGUID_DOCUMENTSUMMARYINFORMATION => Guid("{d5cdd502-2e9c-101b-9397-08002b2cf9ae}")

    /**
     * @type {Guid}
     */
    static PSGUID_MEDIAFILESUMMARYINFORMATION => Guid("{64440492-4c8b-11d1-8b70-080036b11a03}")

    /**
     * @type {Guid}
     */
    static PSGUID_IMAGESUMMARYINFORMATION => Guid("{6444048f-4c8b-11d1-8b70-080036b11a03}")

    /**
     * @type {Guid}
     */
    static CLSID_HWShellExecute => Guid("{ffb8655f-81b9-4fce-b89c-9a6ba76d13e7}")

    /**
     * @type {Guid}
     */
    static CLSID_DragDropHelper => Guid("{4657278a-411b-11d2-839a-00c04fd918d0}")

    /**
     * @type {Guid}
     */
    static CLSID_CAnchorBrowsePropertyPage => Guid("{3050f3bb-98b5-11cf-bb82-00aa00bdce0b}")

    /**
     * @type {Guid}
     */
    static CLSID_CImageBrowsePropertyPage => Guid("{3050f3b3-98b5-11cf-bb82-00aa00bdce0b}")

    /**
     * @type {Guid}
     */
    static CLSID_CDocBrowsePropertyPage => Guid("{3050f3b4-98b5-11cf-bb82-00aa00bdce0b}")

    /**
     * @type {Guid}
     */
    static SID_STopWindow => Guid("{49e1b500-4636-11d3-97f7-00c04f45d0b3}")

    /**
     * @type {Guid}
     */
    static SID_SGetViewFromViewDual => Guid("{889a935d-971e-4b12-b90c-24dfc9e1e5e8}")

    /**
     * @type {Guid}
     */
    static CLSID_FolderItemsMultiLevel => Guid("{53c74826-ab99-4d33-aca4-3117f51d3788}")

    /**
     * @type {Guid}
     */
    static CLSID_NewMenu => Guid("{d969a300-e7ff-11d0-a93b-00a0c90f2719}")

    /**
     * @type {Guid}
     */
    static BHID_SFObject => Guid("{3981e224-f559-11d3-8e3a-00c04f6837d5}")

    /**
     * @type {Guid}
     */
    static BHID_SFUIObject => Guid("{3981e225-f559-11d3-8e3a-00c04f6837d5}")

    /**
     * @type {Guid}
     */
    static BHID_SFViewObject => Guid("{3981e226-f559-11d3-8e3a-00c04f6837d5}")

    /**
     * @type {Guid}
     */
    static BHID_Storage => Guid("{3981e227-f559-11d3-8e3a-00c04f6837d5}")

    /**
     * @type {Guid}
     */
    static BHID_Stream => Guid("{1cebb3ab-7c10-499a-a417-92ca16c4cb83}")

    /**
     * @type {Guid}
     */
    static BHID_RandomAccessStream => Guid("{f16fc93b-77ae-4cfe-bda7-a866eea6878d}")

    /**
     * @type {Guid}
     */
    static BHID_LinkTargetItem => Guid("{3981e228-f559-11d3-8e3a-00c04f6837d5}")

    /**
     * @type {Guid}
     */
    static BHID_StorageEnum => Guid("{4621a4e3-f0d6-4773-8a9c-46e77b174840}")

    /**
     * @type {Guid}
     */
    static BHID_Transfer => Guid("{d5e346a1-f753-4932-b403-4574800e2498}")

    /**
     * @type {Guid}
     */
    static BHID_PropertyStore => Guid("{0384e1a4-1523-439c-a4c8-ab911052f586}")

    /**
     * @type {Guid}
     */
    static BHID_ThumbnailHandler => Guid("{7b2e650a-8e20-4f4a-b09e-6597afc72fb0}")

    /**
     * @type {Guid}
     */
    static BHID_EnumItems => Guid("{94f60519-2850-4924-aa5a-d15e84868039}")

    /**
     * @type {Guid}
     */
    static BHID_DataObject => Guid("{b8c0bd9f-ed24-455c-83e6-d5390c4fe8c4}")

    /**
     * @type {Guid}
     */
    static BHID_AssociationArray => Guid("{bea9ef17-82f1-4f60-9284-4f8db75c3be9}")

    /**
     * @type {Guid}
     */
    static BHID_Filter => Guid("{38d08778-f557-4690-9ebf-ba54706ad8f7}")

    /**
     * @type {Guid}
     */
    static BHID_EnumAssocHandlers => Guid("{b8ab0b9c-c2ec-4f7a-918d-314900e6280a}")

    /**
     * @type {Guid}
     */
    static BHID_StorageItem => Guid("{404e2109-77d2-4699-a5a0-4fdf10db9837}")

    /**
     * @type {Guid}
     */
    static BHID_FilePlaceholder => Guid("{8677dceb-aae0-4005-8d3d-547fa852f825}")

    /**
     * @type {Guid}
     */
    static CATID_FilePlaceholderMergeHandler => Guid("{3e9c9a51-d4aa-4870-b47c-7424b491f1cc}")

    /**
     * @type {Guid}
     */
    static SID_CtxQueryAssociations => Guid("{faadfc40-b777-4b69-aa81-77035ef0e6e8}")

    /**
     * @type {Guid}
     */
    static CLSID_QuickLinks => Guid("{0e5cbf21-d15f-11d0-8301-00aa005b4383}")

    /**
     * @type {Guid}
     */
    static CLSID_ISFBand => Guid("{d82be2b0-5764-11d0-a96e-00c04fd705a2}")

    /**
     * @type {Guid}
     */
    static CLSID_ShellFldSetExt => Guid("{6d5313c0-8c62-11d1-b2cd-006097df8c11}")

    /**
     * @type {Guid}
     */
    static SID_SMenuBandChild => Guid("{ed9cc020-08b9-11d1-9823-00c04fd91972}")

    /**
     * @type {Guid}
     */
    static SID_SMenuBandParent => Guid("{8c278eec-3eab-11d1-8cb0-00c04fd918d0}")

    /**
     * @type {Guid}
     */
    static SID_SMenuPopup => Guid("{d1e7afeb-6a2e-11d0-8c78-00c04fd918b4}")

    /**
     * @type {Guid}
     */
    static SID_SMenuBandBottomSelected => Guid("{165ebaf4-6d51-11d2-83ad-00c04fd918d0}")

    /**
     * @type {Guid}
     */
    static SID_SMenuBandBottom => Guid("{743ca664-0deb-11d1-9825-00c04fd91972}")

    /**
     * @type {Guid}
     */
    static SID_MenuShellFolder => Guid("{a6c17eb4-2d65-11d2-838f-00c04fd918d0}")

    /**
     * @type {Guid}
     */
    static SID_SMenuBandContextMenuModifier => Guid("{39545874-7162-465e-b783-2aa1874fef81}")

    /**
     * @type {Guid}
     */
    static SID_SMenuBandBKContextMenu => Guid("{164bbd86-1d0d-4de0-9a3b-d9729647c2b8}")

    /**
     * @type {Guid}
     */
    static CGID_MENUDESKBAR => Guid("{5c9f0a12-959e-11d0-a3a4-00a0c9082636}")

    /**
     * @type {Guid}
     */
    static SID_SMenuBandTop => Guid("{9493a810-ec38-11d0-bc46-00aa006ce2f5}")

    /**
     * @type {Guid}
     */
    static CLSID_MenuToolbarBase => Guid("{40b96610-b522-11d1-b3b4-00aa006efde7}")

    /**
     * @type {Guid}
     */
    static CLSID_MenuBandSite => Guid("{e13ef4e4-d2f2-11d0-9816-00c04fd91972}")

    /**
     * @type {Guid}
     */
    static SID_SCommDlgBrowser => Guid("{80f30233-b7df-11d2-a33b-006097df5bd4}")

    /**
     * @type {Guid}
     */
    static CPFG_LOGON_USERNAME => Guid("{da15bbe8-954d-4fd3-b0f4-1fb5b90b174b}")

    /**
     * @type {Guid}
     */
    static CPFG_LOGON_PASSWORD => Guid("{60624cfa-a477-47b1-8a8e-3a4a19981827}")

    /**
     * @type {Guid}
     */
    static CPFG_SMARTCARD_USERNAME => Guid("{3e1ecf69-568c-4d96-9d59-46444174e2d6}")

    /**
     * @type {Guid}
     */
    static CPFG_SMARTCARD_PIN => Guid("{4fe5263b-9181-46c1-b0a4-9dedd4db7dea}")

    /**
     * @type {Guid}
     */
    static CPFG_CREDENTIAL_PROVIDER_LOGO => Guid("{2d837775-f6cd-464e-a745-482fd0b47493}")

    /**
     * @type {Guid}
     */
    static CPFG_CREDENTIAL_PROVIDER_LABEL => Guid("{286bbff3-bad4-438f-b007-79b7267c3d48}")

    /**
     * @type {Guid}
     */
    static CPFG_STANDALONE_SUBMIT_BUTTON => Guid("{0b7b0ad8-cc36-4d59-802b-82f714fa7022}")

    /**
     * @type {Guid}
     */
    static CPFG_STYLE_LINK_AS_BUTTON => Guid("{088fa508-94a6-4430-a4cb-6fc6e3c0b9e2}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Invalid => Guid("{57807898-8c4f-4462-bb63-71042380b109}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Generic => Guid("{5c4f28b5-f869-4e84-8e60-f11db97c5cc7}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_GenericSearchResults => Guid("{7fde1a1e-8b31-49a5-93b8-6be14cfa4943}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_GenericLibrary => Guid("{5f4eab9a-6833-4f61-899d-31cf46979d49}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Documents => Guid("{7d49d726-3c21-4f05-99aa-fdc2c9474656}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Pictures => Guid("{b3690e58-e961-423b-b687-386ebfd83239}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Music => Guid("{94d6ddcc-4a68-4175-a374-bd584a510b78}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Videos => Guid("{5fa96407-7e77-483c-ac93-691d05850de8}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Downloads => Guid("{885a186e-a440-4ada-812b-db871b942259}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_UserFiles => Guid("{cd0fc69b-71e2-46e5-9690-5bcd9f57aab3}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_UsersLibraries => Guid("{c4d98f09-6124-4fe0-9942-826416082da9}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_OtherUsers => Guid("{b337fd00-9dd5-4635-a6d4-da33fd102b7a}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_PublishedItems => Guid("{7f2f5b96-ff74-41da-afd8-1c78a5f3aea2}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Communications => Guid("{91475fe5-586b-4eba-8d75-d17434b8cdf6}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Contacts => Guid("{de2b70ec-9bf7-4a93-bd3d-243f7881d492}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_StartMenu => Guid("{ef87b4cb-f2ce-4785-8658-4ca6c63e38c6}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_RecordedTV => Guid("{5557a28f-5da6-4f83-8809-c2c98a11a6fa}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_SavedGames => Guid("{d0363307-28cb-4106-9f23-2956e3e5e0e7}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_OpenSearch => Guid("{8faf9629-1980-46ff-8023-9dceab9c3ee3}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_SearchConnector => Guid("{982725ee-6f47-479e-b447-812bfa7d2e8f}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_AccountPictures => Guid("{db2a5d8f-06e6-4007-aba6-af877d526ea6}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Games => Guid("{b689b0d0-76d3-4cbb-87f7-585d0e0ce070}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_ControlPanelCategory => Guid("{de4f0660-fa10-4b8f-a494-068b20b22307}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_ControlPanelClassic => Guid("{0c3794f3-b545-43aa-a329-c37430c58d2a}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Printers => Guid("{2c7bbec6-c844-4a0a-91fa-cef6f59cfda1}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_RecycleBin => Guid("{d6d9e004-cd87-442b-9d57-5e0aeb4f6f72}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_SoftwareExplorer => Guid("{d674391b-52d9-4e07-834e-67c98610f39d}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_CompressedFolder => Guid("{80213e82-bcfd-4c4f-8817-bb27601267a9}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_NetworkExplorer => Guid("{25cc242b-9a7c-4f51-80e0-7a2928febe42}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_Searches => Guid("{0b0ba2e3-405f-415e-a6ee-cad625207853}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_SearchHome => Guid("{834d8a44-0974-4ed6-866e-f203d80b3810}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_StorageProviderGeneric => Guid("{4f01ebc5-2385-41f2-a28e-2c5c91fb56e0}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_StorageProviderDocuments => Guid("{dd61bd66-70e8-48dd-9655-65c5e1aac2d1}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_StorageProviderPictures => Guid("{71d642a9-f2b1-42cd-ad92-eb9300c7cc0a}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_StorageProviderMusic => Guid("{672ecd7e-af04-4399-875c-0290845b6247}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_StorageProviderVideos => Guid("{51294da1-d7b1-485b-9e9a-17cffe33e187}")

    /**
     * @type {Guid}
     */
    static FOLDERTYPEID_VersionControl => Guid("{69f1e26b-ec64-4280-bc83-f1eb887ec35a}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_Icon => Guid("{6dbc85c3-5d07-4c72-a777-7fec78072c06}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_EventStore => Guid("{4bef34b9-a786-4075-ba88-0c2b9d89a98f}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_ConflictStore => Guid("{d78181f4-2389-47e4-a960-60bcc2ed930b}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_BrowseContent => Guid("{57cbb584-e9b4-47ae-a120-c4df3335dee2}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_ShowSchedule => Guid("{edc6f3e3-8441-4109-adf3-6c1ca0b7de47}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_QueryBeforeActivate => Guid("{d882d80b-e7aa-49ed-86b7-e6e1f714cdfe}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_QueryBeforeDeactivate => Guid("{a0efc282-60e0-460e-9374-ea88513cfc80}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_QueryBeforeEnable => Guid("{04cbf7f0-5beb-4de1-bc90-908345c480f6}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_QueryBeforeDisable => Guid("{bb5f64aa-f004-4eb5-8e4d-26751966344c}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_QueryBeforeDelete => Guid("{f76c3397-afb3-45d7-a59f-5a49e905437e}")

    /**
     * @type {Guid}
     */
    static SYNCMGR_OBJECTID_EventLinkClick => Guid("{2203bdc1-1af1-4082-8c30-28399f41384c}")

    /**
     * @type {Guid}
     */
    static EP_NavPane => Guid("{cb316b22-25f7-42b8-8a09-540d23a43c2f}")

    /**
     * @type {Guid}
     */
    static EP_Commands => Guid("{d9745868-ca5f-4a76-91cd-f5a129fbb076}")

    /**
     * @type {Guid}
     */
    static EP_Commands_Organize => Guid("{72e81700-e3ec-4660-bf24-3c3b7b648806}")

    /**
     * @type {Guid}
     */
    static EP_Commands_View => Guid("{21f7c32d-eeaa-439b-bb51-37b96fd6a943}")

    /**
     * @type {Guid}
     */
    static EP_DetailsPane => Guid("{43abf98b-89b8-472d-b9ce-e69b8229f019}")

    /**
     * @type {Guid}
     */
    static EP_PreviewPane => Guid("{893c63d1-45c8-4d17-be19-223be71be365}")

    /**
     * @type {Guid}
     */
    static EP_QueryPane => Guid("{65bcde4f-4f07-4f27-83a7-1afca4df7ddd}")

    /**
     * @type {Guid}
     */
    static EP_AdvQueryPane => Guid("{b4e9db8b-34ba-4c39-b5cc-16a1bd2c411c}")

    /**
     * @type {Guid}
     */
    static EP_StatusBar => Guid("{65fe56ce-5cfe-4bc4-ad8a-7ae3fe7e8f7c}")

    /**
     * @type {Guid}
     */
    static EP_Ribbon => Guid("{d27524a8-c9f2-4834-a106-df8889fd4f37}")

    /**
     * @type {Guid}
     */
    static CATID_LocationFactory => Guid("{965c4d51-8b76-4e57-80b7-564d2ea4b55e}")

    /**
     * @type {Guid}
     */
    static CATID_LocationProvider => Guid("{1b3ca474-2614-414b-b813-1aceca3e3dd8}")

    /**
     * @type {Guid}
     */
    static ItemCount_Property_GUID => Guid("{abbf5c45-5ccc-47b7-bb4e-87cb87bbd162}")

    /**
     * @type {Guid}
     */
    static SelectedItemCount_Property_GUID => Guid("{8fe316d2-0e52-460a-9c1e-48f273d470a3}")

    /**
     * @type {Guid}
     */
    static ItemIndex_Property_GUID => Guid("{92a053da-2969-4021-bf27-514cfc2e4a69}")

    /**
     * @type {Guid}
     */
    static CATID_SearchableApplication => Guid("{366c292a-d9b3-4dbf-bb70-e62ec3d0bbbf}")

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_WIZEXTN_FIRST => 20480

    /**
     * @type {Integer (UInt32)}
     */
    static IDD_WIZEXTN_LAST => 20736

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_NORECOMPRESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_NONETPLACECREATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_NOFILESELECTOR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_USEMRU => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_ANYLOCATION => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SHPWHF_VALIDATEVIAWEBFOLDERS => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static ACDD_VISIBLE => 1

    /**
     * @type {String}
     */
    static PROPSTR_EXTENSIONCOMPLETIONSTATE => "ExtensionCompletionState"

    /**
     * @type {Guid}
     */
    static SID_SCommandBarState => Guid("{b99eaa5c-3850-4400-bc33-2ce534048bf8}")

    /**
     * @type {Integer (Int32)}
     */
    static NSTCDHPOS_ONTOP => -1

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_RECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_PINNED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_NEWFAILED => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_NEWFILE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static FVSIF_CANVIEWIT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_TOOLBAR => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_STATUS => 40961

    /**
     * @type {Integer (UInt32)}
     */
    static IDC_OFFLINE_HAND => 103

    /**
     * @type {Integer (UInt32)}
     */
    static IDC_PANTOOL_HAND_OPEN => 104

    /**
     * @type {Integer (UInt32)}
     */
    static IDC_PANTOOL_HAND_CLOSED => 105

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_NONE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_ZONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_OFFLINE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_PRINTER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_SSL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_NAVIGATION => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_PROGRESS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PANE_PRIVACY => 7

    /**
     * @type {Integer (UInt32)}
     */
    static DWFRF_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DWFRF_DELETECONFIGDATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DWFAF_HIDDEN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DWFAF_GROUP1 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DWFAF_GROUP2 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DWFAF_AUTOHIDE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMSTCAPFLAG_LOCKABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMSTCAPFLAG_PURGEABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_STATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_BKCOLOR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_VIEWMODE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_SHELLFOLDER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_IDLIST => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_MASK_COLORS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_DEBOSSED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_ALLOWRENAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_NOSHOWTEXT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_CHANNELBAR => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_QLINKSMODE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_FULLOPEN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_NONAMESORT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static ISFB_STATE_BTNMINSIZE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static ISFBVIEWMODE_SMALLICONS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISFBVIEWMODE_LARGEICONS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISFBVIEWMODE_LOGOS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_GS_IDEAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_GS_SIZEDOWN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_HIDE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_SHOW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBC_SHOWOBSCURE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSM_CLEAR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SSM_SET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSM_REFRESH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSM_UPDATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_DISPLAY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_EDIT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_LOCAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_GLOBAL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_REFRESH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_UPDATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_DONOTUSE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SCHEME_CREATE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static GADOF_DIRTY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHCDF_UPDATEITEM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_ADDQUOTES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_ADDARGUMENTS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_NODIRECTORIES => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_FORCEQUALIFY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PPCF_LONGESTPOSSIBLE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static OPENPROPS_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OPENPROPS_INHIBITPIF => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static GETPROPS_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SETPROPS_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLOSEPROPS_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLOSEPROPS_DISCARD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_APPEND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_PREPEND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_REPLACE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_INTERNETBAR => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_STANDARDTOOLBAR => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static TBIF_NOTOOLBAR => 196608

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_REARRANGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_ADDOBJECT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_REMOVEOBJECT => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_UPDATEOBJECT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_GETSELECTEDOBJECTS => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_SETITEMPOS => 14

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_SETCLIPBOARD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SFVM_SETPOINTS => 23

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_OPENICON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_FORSHELL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_ASYNC => 32

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_DEFAULTICON => 64

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_FORSHORTCUT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_CHECKSHIELD => 512

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_SIMULATEDOC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_PERINSTANCE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_PERCLASS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_NOTFILENAME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_DONTCACHE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_SHIELD => 512

    /**
     * @type {Integer (UInt32)}
     */
    static GIL_FORCENOSHIELD => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_OVERLAYINDEX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_ICONINDEX => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_RESERVED_SHARED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_RESERVED_LINK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_RESERVED_SLOWFILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SIOM_RESERVED_DEFAULT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static OI_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OI_ASYNC => 4294962926

    /**
     * @type {Integer (UInt32)}
     */
    static IDO_SHGIOI_SHARE => 268435455

    /**
     * @type {Integer (UInt32)}
     */
    static IDO_SHGIOI_LINK => 268435454

    /**
     * @type {Integer (UInt64)}
     */
    static IDO_SHGIOI_SLOWFILE => 4294967293

    /**
     * @type {Integer (UInt64)}
     */
    static IDO_SHGIOI_DEFAULT => 4294967292

    /**
     * @type {Integer (UInt32)}
     */
    static NT_CONSOLE_PROPS_SIG => 2684354562

    /**
     * @type {Integer (UInt32)}
     */
    static NT_FE_CONSOLE_PROPS_SIG => 2684354564

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_DARWIN_ID_SIG => 2684354566

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_SPECIAL_FOLDER_SIG => 2684354565

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_SZ_LINK_SIG => 2684354561

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_SZ_ICON_SIG => 2684354567

    /**
     * @type {Integer (UInt32)}
     */
    static EXP_PROPERTYSTORAGE_SIG => 2684354569

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_SHVIEWFIRST => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_SHVIEWLAST => 32767

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_BROWSERFIRST => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_BROWSERLAST => 48896

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_GLOBALFIRST => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_GLOBALLAST => 40959

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_FILE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_EDIT => 32832

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_VIEW => 32896

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_VIEW_SEP_OPTIONS => 32897

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_TOOLS => 32960

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_TOOLS_SEP_GOTO => 32961

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_HELP => 33024

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_FIND => 33088

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_EXPLORE => 33104

    /**
     * @type {Integer (UInt32)}
     */
    static FCIDM_MENU_FAVORITES => 33136

    /**
     * @type {Integer (UInt32)}
     */
    static OFASI_EDIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFASI_OPENDESKTOP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_DESKTOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_INTERNET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAMS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_CONTROLS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PRINTERS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PERSONAL => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FAVORITES => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_STARTUP => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_RECENT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_SENDTO => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_BITBUCKET => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_STARTMENU => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_MYDOCUMENTS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_MYMUSIC => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_MYVIDEO => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_DESKTOPDIRECTORY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_DRIVES => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_NETWORK => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_NETHOOD => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FONTS => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_TEMPLATES => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_STARTMENU => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_PROGRAMS => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_STARTUP => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_DESKTOPDIRECTORY => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_APPDATA => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PRINTHOOD => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_LOCAL_APPDATA => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_ALTSTARTUP => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_ALTSTARTUP => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_FAVORITES => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_INTERNET_CACHE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COOKIES => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_HISTORY => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_APPDATA => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_WINDOWS => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_SYSTEM => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAM_FILES => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_MYPICTURES => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROFILE => 40

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_SYSTEMX86 => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAM_FILESX86 => 42

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAM_FILES_COMMON => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_PROGRAM_FILES_COMMONX86 => 44

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_TEMPLATES => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_DOCUMENTS => 46

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_ADMINTOOLS => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_ADMINTOOLS => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_CONNECTIONS => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_MUSIC => 53

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_PICTURES => 54

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_VIDEO => 55

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_RESOURCES => 56

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_RESOURCES_LOCALIZED => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMMON_OEM_LINKS => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_CDBURN_AREA => 59

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_COMPUTERSNEARME => 61

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_CREATE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_DONT_VERIFY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_DONT_UNEXPAND => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_NO_ALIAS => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_PER_USER_INIT => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_MASK => 65280

    /**
     * @type {Integer (UInt32)}
     */
    static FCS_READ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FCS_FORCEWRITE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCS_FLAG_DRAGDROP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_VIEWID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_WEBVIEWTEMPLATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_INFOTIP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_CLSID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_ICONFILE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_LOGO => 32

    /**
     * @type {Integer (UInt32)}
     */
    static FCSM_FLAGS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_RETURNONLYFSDIRS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_DONTGOBELOWDOMAIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_STATUSTEXT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_RETURNFSANCESTORS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_EDITBOX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_VALIDATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_NEWDIALOGSTYLE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEINCLUDEURLS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_UAHINT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_NONEWFOLDERBUTTON => 512

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_NOTRANSLATETARGETS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEFORCOMPUTER => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEFORPRINTER => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEINCLUDEFILES => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_SHAREABLE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static BIF_BROWSEFILEJUNCTIONS => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_INITIALIZED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SELCHANGED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_VALIDATEFAILEDA => 3

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_VALIDATEFAILEDW => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_IUNKNOWN => 5

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSTATUSTEXTA => 1124

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_ENABLEOK => 1125

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSELECTIONA => 1126

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSELECTIONW => 1127

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSTATUSTEXTW => 1128

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETOKTEXT => 1129

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETEXPANDED => 1130

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSTATUSTEXT => 1128

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_SETSELECTION => 1127

    /**
     * @type {Integer (UInt32)}
     */
    static BFFM_VALIDATEFAILED => 4

    /**
     * @type {Integer (Int32)}
     */
    static CMDID_INTSHORTCUTCREATE => 1

    /**
     * @type {String}
     */
    static STR_PARSE_WITH_PROPERTIES => "ParseWithProperties"

    /**
     * @type {String}
     */
    static STR_PARSE_PARTIAL_IDLIST => "ParseOriginalItem"

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_MODAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_AUTOTIME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NOTIME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NOMINIMIZE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NOPROGRESSBAR => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_MARQUEEPROGRESS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PROGDLG_NOCANCEL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PDTIMER_RESET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PDTIMER_PAUSE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PDTIMER_RESUME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static COMPONENT_TOP => 1073741823

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_HTMLDOC => 0

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_PICTURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_WEBSITE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_CONTROL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_CFHTML => 4

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_TYPE_MAX => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IS_NORMAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IS_FULLSCREEN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IS_SPLIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_SAVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_HTMLGEN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_REFRESH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_FORCE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_BUFFERED_REFRESH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static AD_APPLY_DYNAMICREFRESH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static AD_GETWP_BMP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static AD_GETWP_IMAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AD_GETWP_LAST_APPLIED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_CENTER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_TILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_STRETCH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_KEEPASPECT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_CROPTOFIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_SPAN => 5

    /**
     * @type {Integer (UInt32)}
     */
    static WPSTYLE_MAX => 6

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_CHECKED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_DIRTY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_NOSCROLL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_POS_LEFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_POS_TOP => 32

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_SIZE_WIDTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_SIZE_HEIGHT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_POS_ZINDEX => 256

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_SOURCE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_FRIENDLYNAME => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_SUBSCRIBEDURL => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_ORIGINAL_CSI => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_RESTORED_CSI => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static COMP_ELEM_CURITEMSTATE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static ADDURL_SILENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COMPONENT_DEFAULT_LEFT => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static COMPONENT_DEFAULT_TOP => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_COLUMN_NAME_LEN => 80

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_COLUMN_DESC_LEN => 128

    /**
     * @type {String}
     */
    static CFSTR_SHELLIDLIST => "Shell IDList Array"

    /**
     * @type {String}
     */
    static CFSTR_SHELLIDLISTOFFSET => "Shell Object Offsets"

    /**
     * @type {String}
     */
    static CFSTR_NETRESOURCES => "Net Resource"

    /**
     * @type {String}
     */
    static CFSTR_FILEDESCRIPTORA => "FileGroupDescriptor"

    /**
     * @type {String}
     */
    static CFSTR_FILEDESCRIPTORW => "FileGroupDescriptorW"

    /**
     * @type {String}
     */
    static CFSTR_FILECONTENTS => "FileContents"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEA => "FileName"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEW => "FileNameW"

    /**
     * @type {String}
     */
    static CFSTR_PRINTERGROUP => "PrinterFriendlyName"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEMAPA => "FileNameMap"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEMAPW => "FileNameMapW"

    /**
     * @type {String}
     */
    static CFSTR_SHELLURL => "UniformResourceLocator"

    /**
     * @type {String}
     */
    static CFSTR_INETURLA => "UniformResourceLocator"

    /**
     * @type {String}
     */
    static CFSTR_INETURLW => "UniformResourceLocatorW"

    /**
     * @type {String}
     */
    static CFSTR_PREFERREDDROPEFFECT => "Preferred DropEffect"

    /**
     * @type {String}
     */
    static CFSTR_PERFORMEDDROPEFFECT => "Performed DropEffect"

    /**
     * @type {String}
     */
    static CFSTR_PASTESUCCEEDED => "Paste Succeeded"

    /**
     * @type {String}
     */
    static CFSTR_INDRAGLOOP => "InShellDragLoop"

    /**
     * @type {String}
     */
    static CFSTR_MOUNTEDVOLUME => "MountedVolume"

    /**
     * @type {String}
     */
    static CFSTR_PERSISTEDDATAOBJECT => "PersistedDataObject"

    /**
     * @type {String}
     */
    static CFSTR_TARGETCLSID => "TargetCLSID"

    /**
     * @type {String}
     */
    static CFSTR_LOGICALPERFORMEDDROPEFFECT => "Logical Performed DropEffect"

    /**
     * @type {String}
     */
    static CFSTR_AUTOPLAY_SHELLIDLISTS => "Autoplay Enumerated IDList Array"

    /**
     * @type {String}
     */
    static CFSTR_UNTRUSTEDDRAGDROP => "UntrustedDragDrop"

    /**
     * @type {String}
     */
    static CFSTR_FILE_ATTRIBUTES_ARRAY => "File Attributes Array"

    /**
     * @type {String}
     */
    static CFSTR_INVOKECOMMAND_DROPPARAM => "InvokeCommand DropParam"

    /**
     * @type {String}
     */
    static CFSTR_SHELLDROPHANDLER => "DropHandlerCLSID"

    /**
     * @type {String}
     */
    static CFSTR_DROPDESCRIPTION => "DropDescription"

    /**
     * @type {String}
     */
    static CFSTR_ZONEIDENTIFIER => "ZoneIdentifier"

    /**
     * @type {String}
     */
    static CFSTR_FILEDESCRIPTOR => "FileGroupDescriptorW"

    /**
     * @type {String}
     */
    static CFSTR_FILENAME => "FileNameW"

    /**
     * @type {String}
     */
    static CFSTR_FILENAMEMAP => "FileNameMapW"

    /**
     * @type {String}
     */
    static CFSTR_INETURL => "UniformResourceLocatorW"

    /**
     * @type {Integer (UInt32)}
     */
    static DVASPECT_SHORTNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DVASPECT_COPY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DVASPECT_LINK => 4

    /**
     * @type {Integer (Int32)}
     */
    static SHCNEE_ORDERCHANGED => 2

    /**
     * @type {Integer (Int32)}
     */
    static SHCNEE_MSI_CHANGE => 4

    /**
     * @type {Integer (Int32)}
     */
    static SHCNEE_MSI_UNINSTALL => 5

    /**
     * @type {Integer (UInt32)}
     */
    static NUM_POINTS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CABINETSTATE_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIFNAMESIZE => 30

    /**
     * @type {Integer (UInt32)}
     */
    static PIFSTARTLOCSIZE => 63

    /**
     * @type {Integer (UInt32)}
     */
    static PIFDEFPATHSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIFPARAMSSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIFSHPROGSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIFSHDATASIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIFDEFFILESIZE => 80

    /**
     * @type {Integer (UInt32)}
     */
    static PIFMAXFILEPATH => 260

    /**
     * @type {Integer (UInt32)}
     */
    static QCMINFO_PLACE_BEFORE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static QCMINFO_PLACE_AFTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SFVSOC_INVALIDATE_ALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SFVSOC_NOSCROLL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHELLSTATEVERSION_IE4 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SHELLSTATEVERSION_WIN2K => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_DIRCREATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_ASKDIRCREATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_IGNOREFILENAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_NOWRITECHECK => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SHPPFW_MEDIACHECKONLY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_DEFAULTONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_VERBSONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_EXPLORE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_NOVERBS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_CANRENAME => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_NODEFAULT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_INCLUDESTATIC => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_ITEMMENU => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_EXTENDEDVERBS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_DISABLEDVERBS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_ASYNCVERBSTATE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_OPTIMIZEFORINVOKE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_SYNCCASCADEMENU => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_DONOTPICKDEFAULT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CMF_RESERVED => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VERBA => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_HELPTEXTA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VALIDATEA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VERBW => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_HELPTEXTW => 5

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VALIDATEW => 6

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VERBICONW => 20

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_UNICODE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VERB => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_HELPTEXT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static GCS_VALIDATE => 6

    /**
     * @type {String}
     */
    static CMDSTR_NEWFOLDERA => "NewFolder"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWLISTA => "ViewList"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWDETAILSA => "ViewDetails"

    /**
     * @type {String}
     */
    static CMDSTR_NEWFOLDERW => "NewFolder"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWLISTW => "ViewList"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWDETAILSW => "ViewDetails"

    /**
     * @type {String}
     */
    static CMDSTR_NEWFOLDER => "NewFolder"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWLIST => "ViewList"

    /**
     * @type {String}
     */
    static CMDSTR_VIEWDETAILS => "ViewDetails"

    /**
     * @type {Integer (UInt32)}
     */
    static CMIC_MASK_SHIFT_DOWN => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CMIC_MASK_CONTROL_DOWN => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CMIC_MASK_PTINVOKE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_NOT_RUNNING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_RUNNING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_SUSPENDED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_PENDING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static IRTIR_TASK_FINISHED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ITSAT_DEFAULT_PRIORITY => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static ITSAT_MAX_PRIORITY => 2147483647

    /**
     * @type {Integer (UInt32)}
     */
    static ITSAT_MIN_PRIORITY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ITSSFLAG_COMPLETE_ON_DESTROY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ITSSFLAG_KILL_ON_DESTROY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ITSSFLAG_FLAGS_MASK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ITSS_THREAD_TIMEOUT_NO_CHANGE => 4294967294

    /**
     * @type {Integer (UInt32)}
     */
    static CSIDL_FLAG_PFTI_TRACKTARGET => 16384

    /**
     * @type {Integer (Int32)}
     */
    static SHCIDS_ALLFIELDS => -2147483648

    /**
     * @type {Integer (Int32)}
     */
    static SHCIDS_CANONICALONLY => 268435456

    /**
     * @type {Integer (Int32)}
     */
    static SHCIDS_BITMASK => -65536

    /**
     * @type {Integer (Int32)}
     */
    static SHCIDS_COLUMNMASK => 65535

    /**
     * @type {String}
     */
    static CONFLICT_RESOLUTION_CLSID_KEY => "ConflictResolutionCLSID"

    /**
     * @type {String}
     */
    static STR_BIND_FORCE_FOLDER_SHORTCUT_RESOLVE => "Force Folder Shortcut Resolve"

    /**
     * @type {String}
     */
    static STR_AVOID_DRIVE_RESTRICTION_POLICY => "Avoid Drive Restriction Policy"

    /**
     * @type {String}
     */
    static STR_SKIP_BINDING_CLSID => "Skip Binding CLSID"

    /**
     * @type {String}
     */
    static STR_PARSE_PREFER_FOLDER_BROWSING => "Parse Prefer Folder Browsing"

    /**
     * @type {String}
     */
    static STR_DONT_PARSE_RELATIVE => "Don't Parse Relative"

    /**
     * @type {String}
     */
    static STR_PARSE_TRANSLATE_ALIASES => "Parse Translate Aliases"

    /**
     * @type {String}
     */
    static STR_PARSE_SKIP_NET_CACHE => "Skip Net Resource Cache"

    /**
     * @type {String}
     */
    static STR_PARSE_SHELL_PROTOCOL_TO_FILE_OBJECTS => "Parse Shell Protocol To File Objects"

    /**
     * @type {String}
     */
    static STR_TRACK_CLSID => "Track the CLSID"

    /**
     * @type {String}
     */
    static STR_INTERNAL_NAVIGATE => "Internal Navigation"

    /**
     * @type {String}
     */
    static STR_PARSE_PROPERTYSTORE => "DelegateNamedProperties"

    /**
     * @type {String}
     */
    static STR_NO_VALIDATE_FILENAME_CHARS => "NoValidateFilenameChars"

    /**
     * @type {String}
     */
    static STR_BIND_DELEGATE_CREATE_OBJECT => "Delegate Object Creation"

    /**
     * @type {String}
     */
    static STR_PARSE_ALLOW_INTERNET_SHELL_FOLDERS => "Allow binding to Internet shell folder handlers and negate STR_PARSE_PREFER_WEB_BROWSING"

    /**
     * @type {String}
     */
    static STR_PARSE_PREFER_WEB_BROWSING => "Do not bind to Internet shell folder handlers"

    /**
     * @type {String}
     */
    static STR_PARSE_SHOW_NET_DIAGNOSTICS_UI => "Show network diagnostics UI"

    /**
     * @type {String}
     */
    static STR_PARSE_DONT_REQUIRE_VALIDATED_URLS => "Do not require validated URLs"

    /**
     * @type {String}
     */
    static STR_INTERNETFOLDER_PARSE_ONLY_URLMON_BINDABLE => "Validate URL"

    /**
     * @type {Integer (UInt32)}
     */
    static BIND_INTERRUPTABLE => 4294967295

    /**
     * @type {String}
     */
    static STR_BIND_FOLDERS_READ_ONLY => "Folders As Read Only"

    /**
     * @type {String}
     */
    static STR_BIND_FOLDER_ENUM_MODE => "Folder Enum Mode"

    /**
     * @type {String}
     */
    static STR_PARSE_WITH_EXPLICIT_PROGID => "ExplicitProgid"

    /**
     * @type {String}
     */
    static STR_PARSE_WITH_EXPLICIT_ASSOCAPP => "ExplicitAssociationApp"

    /**
     * @type {String}
     */
    static STR_PARSE_EXPLICIT_ASSOCIATION_SUCCESSFUL => "ExplicitAssociationSuccessful"

    /**
     * @type {String}
     */
    static STR_PARSE_AND_CREATE_ITEM => "ParseAndCreateItem"

    /**
     * @type {String}
     */
    static STR_PROPERTYBAG_PARAM => "SHBindCtxPropertyBag"

    /**
     * @type {String}
     */
    static STR_ENUM_ITEMS_FLAGS => "SHCONTF"

    /**
     * @type {String}
     */
    static STR_STORAGEITEM_CREATION_FLAGS => "SHGETSTORAGEITEM"

    /**
     * @type {String}
     */
    static STR_ITEM_CACHE_CONTEXT => "ItemCacheContext"

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_SETFOCUS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_KILLFOCUS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_SELCHANGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_RENAME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CDBOSC_STATECHANGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2N_CONTEXTMENU_DONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2N_CONTEXTMENU_START => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_SHOWALLFILES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_ISFILESAVE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_ALLOWPREVIEWPANE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_NOSELECTVERB => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_NOINCLUDEITEM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_ISFOLDERPICKER => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CDB2GVF_ADDSHIELD => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_DEFBROWSER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_SAMEBROWSER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NEWBROWSER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_DEFMODE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_OPENMODE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_EXPLOREMODE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_HELPMODE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NOTRANSFERHIST => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_ABSOLUTE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_RELATIVE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_PARENT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NAVIGATEBACK => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NAVIGATEFORWARD => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_ALLOW_AUTONAVIGATE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_KEEPSAMETEMPLATE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_KEEPWORDWHEELTEXT => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_ACTIVATE_NOFOCUS => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_CREATENOHISTORY => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_PLAYNOSOUND => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_CALLERUNTRUSTED => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_TRUSTFIRSTDOWNLOAD => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_UNTRUSTEDFORDOWNLOAD => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_NOAUTOSELECT => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_WRITENOHISTORY => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_TRUSTEDFORACTIVEX => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_FEEDNAVIGATION => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_REDIRECT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static SBSP_INITIATEDBYHLINKFRAME => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_STATUS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_TOOLBAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_TREE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_INTERNETBAR => 6

    /**
     * @type {Integer (UInt32)}
     */
    static FCW_PROGRESS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FCT_MERGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FCT_CONFIGABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FCT_ADDTOEND => 4

    /**
     * @type {String}
     */
    static STR_DONT_RESOLVE_LINK => "Don't Resolve Link"

    /**
     * @type {String}
     */
    static STR_GET_ASYNC_HANDLER => "GetAsyncHandler"

    /**
     * @type {String}
     */
    static STR_GPS_HANDLERPROPERTIESONLY => "GPS_HANDLERPROPERTIESONLY"

    /**
     * @type {String}
     */
    static STR_GPS_FASTPROPERTIESONLY => "GPS_FASTPROPERTIESONLY"

    /**
     * @type {String}
     */
    static STR_GPS_OPENSLOWITEM => "GPS_OPENSLOWITEM"

    /**
     * @type {String}
     */
    static STR_GPS_DELAYCREATION => "GPS_DELAYCREATION"

    /**
     * @type {String}
     */
    static STR_GPS_BESTEFFORT => "GPS_BESTEFFORT"

    /**
     * @type {String}
     */
    static STR_GPS_NO_OPLOCK => "GPS_NO_OPLOCK"

    /**
     * @type {String}
     */
    static DI_GETDRAGIMAGE => "ShellGetDragImage"

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUTORUNINF => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUDIOCD => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_DVDMOVIE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_BLANKCD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_BLANKDVD => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_UNKNOWNCONTENT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUTOPLAYPIX => 128

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUTOPLAYMUSIC => 256

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_AUTOPLAYVIDEO => 512

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_VCD => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_SVCD => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_DVDAUDIO => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_BLANKBD => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_BLURAY => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_CAMERASTORAGE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_CUSTOMEVENT => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_MASK => 131070

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_PRESNIFF => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_SNIFFING => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_FINAL => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static ARCONTENT_PHASE_MASK => 1879048192

    /**
     * @type {Integer (UInt32)}
     */
    static IEI_PRIORITY_MAX => 2147483647

    /**
     * @type {Integer (UInt32)}
     */
    static IEI_PRIORITY_MIN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IEIT_PRIORITY_NORMAL => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_ASYNC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_CACHE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_ASPECT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_OFFLINE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_GLEAM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_SCREEN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_ORIGSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_NOSTAMP => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_NOBORDER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_QUALITY => 512

    /**
     * @type {Integer (UInt32)}
     */
    static IEIFLAG_REFRESH => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_MINSIZE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_MAXSIZE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_INTEGRAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_ACTUAL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_TITLE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_MODEFLAGS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static DBIM_BKCOLOR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_FIXED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_FIXEDBMP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_VARIABLEHEIGHT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_UNDELETEABLE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_DEBOSSED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_BKCOLOR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_USECHEVRON => 128

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_BREAK => 256

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_ADDTOFRONT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_TOPALIGN => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_NOGRIPPER => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_ALWAYSGRIPPER => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static DBIMF_NOMARGINS => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static DBIF_VIEWMODE_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBIF_VIEWMODE_VERTICAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBIF_VIEWMODE_FLOATING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DBIF_VIEWMODE_TRANSPARENT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBPC_SELECTFIRST => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static THBN_CLICKED => 6144

    /**
     * @type {Integer (UInt32)}
     */
    static BSIM_STATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSIM_STYLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSSF_VISIBLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSSF_NOTITLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSSF_UNDELETEABLE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_AUTOGRIPPER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_NOGRIPPER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_ALWAYSGRIPPER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_LEFTALIGN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_SINGLECLICK => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_NOCONTEXTMENU => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_NODROPTARGET => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_NOCAPTION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_PREFERNOLINEBREAK => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_LOCKED => 256

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_PRESERVEORDERDURINGLAYOUT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static BSIS_FIXEDORDER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static OF_CAP_CANSWITCHTO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OF_CAP_CANCLOSE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMDM_SHELLFOLDER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMDM_HMENU => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMDM_TOOLBAR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_INITMENU => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_CREATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_EXITMENU => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETINFO => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETSFINFO => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETOBJECT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETSFOBJECT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SFEXEC => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SFSELECTITEM => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_REFRESH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_DEMOTE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_PROMOTE => 18

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_DEFAULTICON => 22

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_NEWITEM => 23

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_CHEVRONEXPAND => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_DISPLAYCHEVRONTIP => 42

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SETSFOBJECT => 45

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SHCHANGENOTIFY => 46

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_CHEVRONGETTIP => 47

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SFDDRESTRICTED => 48

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_SFEXEC_MIDDLE => 49

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETAUTOEXPANDSTATE => 65

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_AUTOEXPANDCHANGE => 66

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETCONTEXTMENUMODIFIER => 67

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_GETBKCONTEXTMENU => 68

    /**
     * @type {Integer (UInt32)}
     */
    static SMC_OPEN => 69

    /**
     * @type {Integer (UInt32)}
     */
    static SMAE_EXPANDED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMAE_CONTRACTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMAE_USER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SMAE_VALID => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_RESTRICT_DRAGDROP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_TOPLEVEL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_CACHED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_AUTOEXPAND => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_AUTOTOOLTIP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_DROPONCONTAINER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_VERTICAL => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SMINIT_HORIZONTAL => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SMSET_TOP => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SMSET_BOTTOM => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SMSET_DONTOWN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMINV_REFRESH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SMINV_ID => 8

    /**
     * @type {Integer (Int32)}
     */
    static E_PREVIEWHANDLER_DRM_FAIL => -2042494975

    /**
     * @type {Integer (Int32)}
     */
    static E_PREVIEWHANDLER_NOAUTH => -2042494974

    /**
     * @type {Integer (Int32)}
     */
    static E_PREVIEWHANDLER_NOTFOUND => -2042494973

    /**
     * @type {Integer (Int32)}
     */
    static E_PREVIEWHANDLER_CORRUPT => -2042494972

    /**
     * @type {String}
     */
    static STR_FILE_SYS_BIND_DATA => "File System Bind Data"

    /**
     * @type {String}
     */
    static STR_FILE_SYS_BIND_DATA_WIN7_FORMAT => "Win7FileSystemIdList"

    /**
     * @type {String}
     */
    static HOMEGROUP_SECURITY_GROUP_MULTI => "HUG"

    /**
     * @type {String}
     */
    static HOMEGROUP_SECURITY_GROUP => "HomeUsers"

    /**
     * @type {String}
     */
    static PROP_CONTRACT_DELEGATE => "ContractDelegate"

    /**
     * @type {Guid}
     */
    static SID_URLExecutionContext => Guid("{fb5f8ebc-bbb6-4d10-a461-777291a09030}")

    /**
     * @type {String}
     */
    static STR_TAB_REUSE_IDENTIFIER => "Tab Reuse Identifier"

    /**
     * @type {String}
     */
    static STR_REFERRER_IDENTIFIER => "Referrer Identifier"

    /**
     * @type {Guid}
     */
    static SID_LaunchSourceViewSizePreference => Guid("{80605492-67d9-414f-af89-a1cdf1242bc1}")

    /**
     * @type {Guid}
     */
    static SID_LaunchTargetViewSizePreference => Guid("{26db2472-b7b7-406b-9702-730a4e20d3bf}")

    /**
     * @type {Guid}
     */
    static SID_LaunchSourceAppUserModelId => Guid("{2ce78010-74db-48bc-9c6a-10f372495723}")

    /**
     * @type {Guid}
     */
    static SID_ShellExecuteNamedPropertyStore => Guid("{eb84ada2-00ff-4992-8324-ed5ce061cb29}")

    /**
     * @type {Integer (UInt32)}
     */
    static ISIOI_ICONFILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISIOI_ICONINDEX => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_NEW => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_REMOVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_QUERYPOS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_SETPOS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_GETSTATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_GETTASKBARPOS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_ACTIVATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_GETAUTOHIDEBAR => 7

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_SETAUTOHIDEBAR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_WINDOWPOSCHANGED => 9

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_SETSTATE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_GETAUTOHIDEBAREX => 11

    /**
     * @type {Integer (UInt32)}
     */
    static ABM_SETAUTOHIDEBAREX => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ABN_STATECHANGE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ABN_POSCHANGED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ABN_FULLSCREENAPP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABN_WINDOWARRANGE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ABS_AUTOHIDE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ABS_ALWAYSONTOP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABE_LEFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ABE_TOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ABE_RIGHT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ABE_BOTTOM => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FO_MOVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FO_COPY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FO_DELETE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FO_RENAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PO_DELETE => 19

    /**
     * @type {Integer (UInt32)}
     */
    static PO_RENAME => 20

    /**
     * @type {Integer (UInt32)}
     */
    static PO_PORTCHANGE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PO_REN_PORT => 52

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_FNF => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_PNF => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_ACCESSDENIED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_OOM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_DLLNOTFOUND => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_SHARE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_ASSOCINCOMPLETE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_DDETIMEOUT => 28

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_DDEFAIL => 29

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_DDEBUSY => 30

    /**
     * @type {Integer (UInt32)}
     */
    static SE_ERR_NOASSOC => 31

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_CLASSNAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_CLASSKEY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_IDLIST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_INVOKEIDLIST => 12

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_ICON => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_HOTKEY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NOCLOSEPROCESS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_CONNECTNETDRV => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NOASYNC => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_FLAG_DDEWAIT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_DOENVSUBST => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_FLAG_NO_UI => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_UNICODE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NO_CONSOLE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_ASYNCOK => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_HMONITOR => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NOZONECHECKS => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_NOQUERYCLASSSTORE => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_WAITFORINPUTIDLE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_FLAG_LOG_USAGE => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SEE_MASK_FLAG_HINST_IS_SITE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static SHERB_NOCONFIRMATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHERB_NOPROGRESSUI => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHERB_NOSOUND => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_SELECT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static NINF_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_BALLOONSHOW => 1026

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_BALLOONHIDE => 1027

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_BALLOONTIMEOUT => 1028

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_BALLOONUSERCLICK => 1029

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_POPUPOPEN => 1030

    /**
     * @type {Integer (UInt32)}
     */
    static NIN_POPUPCLOSE => 1031

    /**
     * @type {Integer (UInt32)}
     */
    static NOTIFYICON_VERSION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NOTIFYICON_VERSION_4 => 4

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_PIDL => 1

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_PREFIXNAME => 2

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_NOUNIQUE => 4

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_NOLNK => 8

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_NOLOCNAME => 16

    /**
     * @type {Integer (UInt64)}
     */
    static SHGNLI_USEURLEXT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_OPEN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_PROPERTIES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_NETINSTALL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_NETINSTALLLINK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_TESTPAGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_OPENNETPRN => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_DOCUMENTDEFAULTS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PRINTACTION_SERVERPROPERTIES => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PRINT_PROP_FORCE_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_STATUS_LOCAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_STATUS_REMOTE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static OFFLINE_STATUS_INCOMPLETE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_LARGE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_SMALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_EXTRALARGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_SYSSMALL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_JUMBO => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHIL_LAST => 4

    /**
     * @type {String}
     */
    static WC_NETADDRESS => "msctls_netaddress"

    /**
     * @type {Integer (UInt32)}
     */
    static NCM_GETADDRESS => 1025

    /**
     * @type {Integer (UInt32)}
     */
    static NCM_SETALLOWTYPE => 1026

    /**
     * @type {Integer (UInt32)}
     */
    static NCM_GETALLOWTYPE => 1027

    /**
     * @type {Integer (UInt32)}
     */
    static NCM_DISPLAYERRORTIP => 1028

    /**
     * @type {Integer (UInt32)}
     */
    static CREDENTIAL_PROVIDER_NO_DEFAULT => 4294967295

    /**
     * @type {Guid}
     */
    static Identity_LocalUserProvider => Guid("{a198529b-730f-4089-b646-a12557f5665e}")

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGR_ID => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGR_PROGRESSTEXT => 260

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGR_NAME => 128

    /**
     * @type {Integer (Int32)}
     */
    static STIF_DEFAULT => 0

    /**
     * @type {Integer (Int32)}
     */
    static STIF_SUPPORT_HEX => 1

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_HTMLA => "text/html"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_HTMLW => "text/html"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_CDFA => "application/x-cdf"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_CDFW => "application/x-cdf"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_HTML => "text/html"

    /**
     * @type {String}
     */
    static SZ_CONTENTTYPE_CDF => "application/x-cdf"

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_INVALID => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_LFNCHAR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_SHORTCHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_WILD => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GCT_SEPARATOR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PMSF_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PMSF_MULTIPLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PMSF_DONT_STRIP_SPACES => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_UNSAFE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static URL_PLUGGABLE_PROTOCOL => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static URL_WININET_COMPATIBILITY => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static URL_DONT_ESCAPE_EXTRA_INFO => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static URL_DONT_UNESCAPE_EXTRA_INFO => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static URL_BROWSER_MODE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_SPACES_ONLY => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static URL_DONT_SIMPLIFY => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static URL_NO_META => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE_INPLACE => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static URL_CONVERT_IF_DOSPATH => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE_HIGH_ANSI_ONLY => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static URL_INTERNAL_PATH => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static URL_FILE_USE_PATHURL => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static URL_DONT_UNESCAPE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_AS_UTF8 => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE_AS_UTF8 => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_ASCII_URI_COMPONENT => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static URL_UNESCAPE_URI_COMPONENT => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_PERCENT => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static URL_ESCAPE_SEGMENT_ONLY => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static URL_PARTFLAG_KEEPSCHEME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static URL_APPLY_DEFAULT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static URL_APPLY_GUESSSCHEME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static URL_APPLY_GUESSFILE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static URL_APPLY_FORCEAPPLY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_NONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_SZ => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_EXPAND_SZ => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_BINARY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_DWORD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_MULTI_SZ => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_REG_QWORD => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RT_ANY => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RM_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RM_NORMAL => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RM_SAFE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_RM_SAFENETWORK => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_NOEXPAND => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_ZEROONFAILURE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static SRRF_NOVIRT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static SHREGSET_HKCU => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHREGSET_FORCE_HKCU => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHREGSET_HKLM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHREGSET_FORCE_HKLM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_SHELL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_DEBUGOUT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_TEST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_BROWSER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_FLUSH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_EVENT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_MSVM => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_FORMATTEXT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_PROFILE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_DEBUGBREAK => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_MSGTRACE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_PERFTAGS => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_MEMWATCH => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_DBMON => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_MULTISTOP => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static SPMODE_EVENTTRACE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_PERUSER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_ALLUSERS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_PERFOLDER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_ALLFOLDERS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_INHERIT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_ROAM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SHGVSPB_NOAUTODEFAULTS => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_SHORTTIME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_SHORTDATE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_LONGDATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_LONGTIME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_RELATIVE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_LTRDATE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_RTLDATE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static FDTF_NOAUTOREADINGORDER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static PLATFORM_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PLATFORM_IE3 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PLATFORM_BROWSERONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PLATFORM_INTEGRATED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ILMM_IE4 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DLLVER_PLATFORM_WINDOWS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DLLVER_PLATFORM_NT => 2

    /**
     * @type {Integer (UInt64)}
     */
    static DLLVER_MAJOR_MASK => 18446462598732840960

    /**
     * @type {Integer (UInt64)}
     */
    static DLLVER_MINOR_MASK => 281470681743360

    /**
     * @type {Integer (UInt64)}
     */
    static DLLVER_BUILD_MASK => 4294901760

    /**
     * @type {Integer (UInt64)}
     */
    static DLLVER_QFE_MASK => 65535

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_FAILEDEXTRACTION => -2147175936

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_EXTRACTIONTIMEDOUT => -2147175935

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_SURROGATEUNAVAILABLE => -2147175934

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_FASTEXTRACTIONNOTSUPPORTED => -2147175933

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_DATAFILEUNAVAILABLE => -2147175932

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_EXTRACTIONPENDING => -2147175931

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_EXTRACTIONBLOCKED => -2147175930

    /**
     * @type {Integer (Int32)}
     */
    static WTS_E_NOSTORAGEPROVIDERTHUMBNAILHANDLER => -2147175929

    /**
     * @type {String}
     */
    static SHIMGKEY_QUALITY => "Compression"

    /**
     * @type {String}
     */
    static SHIMGKEY_RAWFORMAT => "RawDataFormat"

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMGDEC_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMGDEC_THUMBNAIL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHIMGDEC_LOADFULL => 2

    /**
     * @type {Integer (Int32)}
     */
    static E_NOTVALIDFORANIMATEDIMAGE => -2147221503

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_MISSINGITEMS => 262657

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_RETRYSYNC => 262658

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_CANCELITEM => 262659

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_CANCELALL => 262660

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_ITEMDELETED => 262672

    /**
     * @type {Integer (Int32)}
     */
    static S_SYNCMGR_ENUMITEMS => 262673

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRPROGRESSITEM_STATUSTEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRPROGRESSITEM_STATUSTYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRPROGRESSITEM_PROGVALUE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRPROGRESSITEM_MAXVALUE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRLOGERROR_ERRORFLAGS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRLOGERROR_ERRORID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRLOGERROR_ITEMID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRITEM_ITEMFLAGMASK => 127

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGRITEMNAME => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRHANDLERFLAG_MASK => 15

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SYNCMGRHANDLERNAME => 32

    /**
     * @type {Integer (UInt32)}
     */
    static SYNCMGRREGISTERFLAGS_MASK => 7

    /**
     * @type {Integer (Int32)}
     */
    static TLOG_BACK => -1

    /**
     * @type {Integer (UInt32)}
     */
    static TLOG_CURRENT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TLOG_FORE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TLMENUF_INCLUDECURRENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TLMENUF_BACK => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TLMENUF_FORE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_REGISTERASDROPTARGET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_THEATERMODE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_NOLOCALFILEWARNING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_UISETBYAUTOMATION => 256

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_RESIZABLE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_CANMAXIMIZE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_TOPBROWSER => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_NAVNOHISTORY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_HTMLNAVCANCELED => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_DONTSHOWNAVCANCELPAGE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_SETNAVIGATABLECODEPAGE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_DELEGATEDNAVIGATION => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_TRUSTEDFORACTIVEX => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_MERGEDMENUS => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_FEEDNAVIGATION => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_FEEDSUBSCRIBED => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_CALLERUNTRUSTED => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_TRUSTEDFORACTIVEX => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_DISABLEWINDOWRESTRICTIONS => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_TRUSTFIRSTDOWNLOAD => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_UNTRUSTEDFORDOWNLOAD => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static SHHLNF_NOAUTOSELECT => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static SHHLNF_WRITENOHISTORY => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_EXTERNALNAVIGATE => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_ALLOW_AUTONAVIGATE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static HLNF_NEWWINDOWSMANAGED => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static INTERNET_MAX_PATH_LENGTH => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static INTERNET_MAX_SCHEME_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_RESTRICTED => 112

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_CACHEHIT => 80

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_STALECACHEHIT => 69

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_USEASDEFAULT => 67

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_SHELLEXT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_CACHEMISS => 48

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_INHERIT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_SHELLEXT_ASBACKUP => 21

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_DESPERATE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static VIEW_PRIORITY_NONE => 0

    /**
     * @type {String}
     */
    static VOLUME_PREFIX => "\\?\Volume"

    /**
     * @type {Integer (UInt32)}
     */
    static PATHCCH_MAX_CCH => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static IDS_DESCRIPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ID_APP => 100

    /**
     * @type {Integer (UInt32)}
     */
    static DLG_SCRNSAVECONFIGURE => 2003

    /**
     * @type {Integer (UInt32)}
     */
    static idsIsPassword => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static idsIniFile => 1001

    /**
     * @type {Integer (UInt32)}
     */
    static idsScreenSaver => 1002

    /**
     * @type {Integer (UInt32)}
     */
    static idsPassword => 1003

    /**
     * @type {Integer (UInt32)}
     */
    static idsDifferentPW => 1004

    /**
     * @type {Integer (UInt32)}
     */
    static idsChangePW => 1005

    /**
     * @type {Integer (UInt32)}
     */
    static idsBadOldPW => 1006

    /**
     * @type {Integer (UInt32)}
     */
    static idsAppName => 1007

    /**
     * @type {Integer (UInt32)}
     */
    static idsNoHelpMemory => 1008

    /**
     * @type {Integer (UInt32)}
     */
    static idsHelpFile => 1009

    /**
     * @type {Integer (UInt32)}
     */
    static idsDefKeyword => 1010

    /**
     * @type {Integer (UInt32)}
     */
    static MAXFILELEN => 13

    /**
     * @type {Integer (UInt32)}
     */
    static TITLEBARNAMELEN => 40

    /**
     * @type {Integer (UInt32)}
     */
    static APPNAMEBUFFERLEN => 40

    /**
     * @type {Integer (UInt32)}
     */
    static BUFFLEN => 255

    /**
     * @type {Integer (UInt32)}
     */
    static SCRM_VERIFYPW => 32768

    /**
     * @type {Integer (Int32)}
     */
    static E_FLAGS => -2147217408

    /**
     * @type {Integer (Int32)}
     */
    static IS_E_EXEC_FAILED => -2147213310

    /**
     * @type {Integer (Int32)}
     */
    static URL_E_INVALID_SYNTAX => -2147217407

    /**
     * @type {Integer (Int32)}
     */
    static URL_E_UNREGISTERED_PROTOCOL => -2147217406

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_MOUSE_BUTTONS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_MOUSE_PTRMOTION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_MOUSE_WHEEL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_KEYBOARD_SPEED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CPLPAGE_DISPLAY_BACKGROUND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SELECTIONCHANGED => 200

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_FILELISTENUMDONE => 201

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_VERBINVOKED => 202

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_DEFAULTVERBINVOKED => 203

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_BEGINDRAG => 204

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_VIEWMODECHANGED => 205

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_NOITEMSTATE_CHANGED => 206

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_CONTENTSCHANGED => 207

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_FOCUSCHANGED => 208

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_CHECKSTATECHANGED => 209

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_ORDERCHANGED => 210

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_VIEWPAINTDONE => 211

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_COLUMNSCHANGED => 212

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_CTRLMOUSEWHEEL => 213

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SORTDONE => 214

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_ICONSIZECHANGED => 215

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_FOLDERCHANGED => 217

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_FILTERINVOKED => 218

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_WORDWHEELEDITED => 219

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SELECTEDITEMCHANGED => 220

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_EXPLORERWINDOWREADY => 221

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_UPDATEIMAGE => 222

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_INITIALENUMERATIONDONE => 223

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_ENTERPRISEIDCHANGED => 224

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_ENTERPRESSED => 200

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_START => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_COMPLETE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_ABORT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_UPDATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_PROGRESSTEXT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_ERROR => 6

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_SEARCHCOMMAND_RESTORE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_DIRTY => 256

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_PUBCAT => 257

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_SORT => 258

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_FORCEX86 => 259

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_SHOWPOSTSETUP => 260

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_ONDOMAIN => 261

    /**
     * @type {Integer (UInt32)}
     */
    static DISPID_IADCCTL_DEFAULTCAT => 262

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_YES => 2555905

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_NOT_HANDLED => 2555907

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_USER_RETRY => 2555908

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_USER_IGNORED => 2555909

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_MERGE => 2555910

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_DONT_PROCESS_CHILDREN => 2555912

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_ALREADY_DONE => 2555914

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_PENDING => 2555915

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_KEEP_BOTH => 2555916

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_CLOSE_PROGRAM => 2555917

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_COLLISIONRESOLVED => 2555918

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_PROGRESS_PAUSE => 2555919

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_PENDING_DELETE => 2555920

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_S_PENDING_BATCH_COPY => 2555921

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_USER_CANCELLED => -2144927744

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_CANCELLED => -2144927743

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REQUIRES_ELEVATION => -2144927742

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SAME_FILE => -2144927741

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DIFF_DIR => -2144927740

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_MANY_SRC_1_DEST => -2144927739

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_SUBTREE => -2144927735

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_SAME_TREE => -2144927734

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_FLD_IS_FILE_DEST => -2144927733

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_FILE_IS_FLD_DEST => -2144927732

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_FILE_TOO_LARGE => -2144927731

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REMOVABLE_FULL => -2144927730

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_RO_CD => -2144927729

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_RW_CD => -2144927728

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_R_CD => -2144927727

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_RO_DVD => -2144927726

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_RW_DVD => -2144927725

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DEST_IS_R_DVD => -2144927724

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_RO_CD => -2144927723

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_RW_CD => -2144927722

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_R_CD => -2144927721

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_RO_DVD => -2144927720

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_RW_DVD => -2144927719

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SRC_IS_R_DVD => -2144927718

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INVALID_FILES_SRC => -2144927717

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INVALID_FILES_DEST => -2144927716

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PATH_TOO_DEEP_SRC => -2144927715

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PATH_TOO_DEEP_DEST => -2144927714

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ROOT_DIR_SRC => -2144927713

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ROOT_DIR_DEST => -2144927712

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ACCESS_DENIED_SRC => -2144927711

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ACCESS_DENIED_DEST => -2144927710

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PATH_NOT_FOUND_SRC => -2144927709

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PATH_NOT_FOUND_DEST => -2144927708

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_NET_DISCONNECT_SRC => -2144927707

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_NET_DISCONNECT_DEST => -2144927706

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SHARING_VIOLATION_SRC => -2144927705

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SHARING_VIOLATION_DEST => -2144927704

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ALREADY_EXISTS_NORMAL => -2144927703

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ALREADY_EXISTS_READONLY => -2144927702

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ALREADY_EXISTS_SYSTEM => -2144927701

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ALREADY_EXISTS_FOLDER => -2144927700

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_STREAM_LOSS => -2144927699

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_EA_LOSS => -2144927698

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PROPERTY_LOSS => -2144927697

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_PROPERTIES_LOSS => -2144927696

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ENCRYPTION_LOSS => -2144927695

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DISK_FULL => -2144927694

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DISK_FULL_CLEAN => -2144927693

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_EA_NOT_SUPPORTED => -2144927692

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_CANT_REACH_SOURCE => -2144927691

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_UNKNOWN_ERROR => -2144927691

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_FORCE_NUKE => -2144927690

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_SIZE_TOO_BIG => -2144927689

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_PATH_TOO_LONG => -2144927688

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RECYCLE_BIN_NOT_FOUND => -2144927686

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_NEWFILE_NAME_TOO_LONG => -2144927685

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_NEWFOLDER_NAME_TOO_LONG => -2144927684

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_DIR_NOT_EMPTY => -2144927683

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_FAT_MAX_IN_ROOT => -2144927682

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_ACCESSDENIED_READONLY => -2144927681

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REDIRECTED_TO_WEBPAGE => -2144927680

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SERVER_BAD_FILE_TYPE => -2144927679

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INTERNET_ITEM_UNAVAILABLE => -2144927678

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_CANNOT_MOVE_FROM_RECYCLE_BIN => -2144927677

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_CANNOT_MOVE_SHARED_FOLDER => -2144927676

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_ERROR => -2144927675

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_PAUSED => -2144927674

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REQUIRES_EDP_CONSENT => -2144927673

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_BLOCKED_BY_EDP_POLICY => -2144927672

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE => -2144927671

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE => -2144927670

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RMS_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE => -2144927669

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_RMS_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE => -2144927668

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_WARNED_BY_DLP_POLICY => -2144927667

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_BLOCKED_BY_DLP_POLICY => -2144927666

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SILENT_FAIL_BY_DLP_POLICY => -2144927665

    /**
     * @type {Integer (Int32)}
     */
    static COPYENGINE_E_SUPPRESS_DIALOG => -2144927664

    /**
     * @type {Integer (Int32)}
     */
    static NETCACHE_E_NEGATIVE_CACHE => -2144927488

    /**
     * @type {Integer (Int32)}
     */
    static EXECUTE_E_LAUNCH_APPLICATION => -2144927487

    /**
     * @type {Integer (Int32)}
     */
    static SHELL_E_WRONG_BITDEPTH => -2144927486

    /**
     * @type {Integer (Int32)}
     */
    static LINK_E_DELETE => -2144927485

    /**
     * @type {Integer (Int32)}
     */
    static STORE_E_NEWER_VERSION_AVAILABLE => -2144927484

    /**
     * @type {Integer (Int32)}
     */
    static E_FILE_PLACEHOLDER_NOT_INITIALIZED => -2144927472

    /**
     * @type {Integer (Int32)}
     */
    static E_FILE_PLACEHOLDER_VERSION_MISMATCH => -2144927471

    /**
     * @type {Integer (Int32)}
     */
    static E_FILE_PLACEHOLDER_SERVER_TIMED_OUT => -2144927470

    /**
     * @type {Integer (Int32)}
     */
    static E_FILE_PLACEHOLDER_STORAGEPROVIDER_NOT_FOUND => -2144927469

    /**
     * @type {Integer (Int32)}
     */
    static CAMERAROLL_E_NO_DOWNSAMPLING_REQUIRED => -2144927456

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_USERCLOSE => -2144927440

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_SHELLERROR => -2144927439

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_SHELLRESTART => -2144927438

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_UNEXPECTED => -2144927437

    /**
     * @type {Integer (Int32)}
     */
    static E_ACTIVATIONDENIED_SHELLNOTREADY => -2144927436

    /**
     * @type {Integer (Int32)}
     */
    static LIBRARY_E_NO_SAVE_LOCATION => -2144927232

    /**
     * @type {Integer (Int32)}
     */
    static LIBRARY_E_NO_ACCESSIBLE_LOCATION => -2144927231

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_UNSUPPORTEDFILETYPE => -2144927216

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_CHANGEDISABLED => -2144927215

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_LARGEORDYNAMIC => -2144927214

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_VIDEOFRAMESIZE => -2144927213

    /**
     * @type {Integer (Int32)}
     */
    static E_USERTILE_FILESIZE => -2144927212

    /**
     * @type {Integer (Int32)}
     */
    static IMM_ACC_DOCKING_E_INSUFFICIENTHEIGHT => -2144927184

    /**
     * @type {Integer (Int32)}
     */
    static IMM_ACC_DOCKING_E_DOCKOCCUPIED => -2144927183

    /**
     * @type {Integer (Int32)}
     */
    static IMSC_E_SHELL_COMPONENT_STARTUP_FAILURE => -2144927181

    /**
     * @type {Integer (Int32)}
     */
    static SHC_E_SHELL_COMPONENT_STARTUP_FAILURE => -2144927180

    /**
     * @type {Integer (Int32)}
     */
    static E_TILE_NOTIFICATIONS_PLATFORM_FAILURE => -2144927159

    /**
     * @type {Integer (Int32)}
     */
    static E_SHELL_EXTENSION_BLOCKED => -2144926975

    /**
     * @type {Integer (Int32)}
     */
    static E_IMAGEFEED_CHANGEDISABLED => -2144926960

    /**
     * @type {Guid}
     */
    static CLSID_CUrlHistory => Guid("{3c374a40-bae4-11cf-bf7d-00aa006946ee}")

    /**
     * @type {Guid}
     */
    static CLSID_CUrlHistoryBoth => Guid("{6659983c-8476-4eb4-b78c-e5968f326ba0}")

    /**
     * @type {Integer (Int32)}
     */
    static ISHCUTCMDID_DOWNLOADICON => 0

    /**
     * @type {Integer (Int32)}
     */
    static ISHCUTCMDID_INTSHORTCUTCREATE => 1

    /**
     * @type {Integer (Int32)}
     */
    static ISHCUTCMDID_COMMITHISTORY => 2

    /**
     * @type {Integer (Int32)}
     */
    static ISHCUTCMDID_SETUSERAWURL => 3

    /**
     * @type {Integer (Int32)}
     */
    static SFBID_PIDLCHANGED => 0

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_EMPTY => 0

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_ONDRAG => 1

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_CLSIDOFBAR => 2

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_RESIZE => 3

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_GETBAR => 4

    /**
     * @type {Integer (Int32)}
     */
    static DBCID_UPDATESIZE => 5

    /**
     * @type {Integer (Int32)}
     */
    static BMICON_LARGE => 0

    /**
     * @type {Integer (Int32)}
     */
    static BMICON_SMALL => 1

    /**
     * @type {Integer (Int32)}
     */
    static CTF_INSIST => 1

    /**
     * @type {Integer (Int32)}
     */
    static CTF_THREAD_REF => 2

    /**
     * @type {Integer (Int32)}
     */
    static CTF_PROCESS_REF => 4

    /**
     * @type {Integer (Int32)}
     */
    static CTF_COINIT_STA => 8

    /**
     * @type {Integer (Int32)}
     */
    static CTF_COINIT => 8

    /**
     * @type {Integer (Int32)}
     */
    static CTF_FREELIBANDEXIT => 16

    /**
     * @type {Integer (Int32)}
     */
    static CTF_REF_COUNTED => 32

    /**
     * @type {Integer (Int32)}
     */
    static CTF_WAIT_ALLOWCOM => 64

    /**
     * @type {Integer (Int32)}
     */
    static CTF_UNUSED => 128

    /**
     * @type {Integer (Int32)}
     */
    static CTF_INHERITWOW64 => 256

    /**
     * @type {Integer (Int32)}
     */
    static CTF_WAIT_NO_REENTRANCY => 512

    /**
     * @type {Integer (Int32)}
     */
    static CTF_KEYBOARD_LOCALE => 1024

    /**
     * @type {Integer (Int32)}
     */
    static CTF_OLEINITIALIZE => 2048

    /**
     * @type {Integer (Int32)}
     */
    static CTF_COINIT_MTA => 4096

    /**
     * @type {Integer (Int32)}
     */
    static CTF_NOADDREFLIB => 8192
;@endregion Constants

;@region Methods
    /**
     * 
     * @param {BOOL} fRestoreCache 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/shell/fileiconinit
     */
    static FileIconInit(fRestoreCache) {
        ; This method's EntryPoint is an ordinal, so we need to load the dll manually
        hModule := LibraryLoader.LoadLibraryW("SHELL32.dll")
        procAddr := LibraryLoader.GetProcAddress(hModule, 660)

        result := DllCall(procAddr, "int", fRestoreCache, "int")

        Foundation.FreeLibrary(hModule)

        return result
    }

    /**
     * Loads the specified user's profile. The profile can be a local user profile or a roaming user profile.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * Token for the user, which is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {Pointer<PROFILEINFOA>} lpProfileInfo Type: <b>LPPROFILEINFO</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <c>sizeof(PROFILEINFO)</c> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     *                 
     *                     
     * 
     * The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-loaduserprofilea
     * @since windows5.0
     */
    static LoadUserProfileA(hToken, lpProfileInfo) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken

        A_LastError := 0

        result := DllCall("USERENV.dll\LoadUserProfileA", "ptr", hToken, "ptr", lpProfileInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Loads the specified user's profile. The profile can be a local user profile or a roaming user profile.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * Token for the user, which is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have <b>TOKEN_QUERY</b>, <b>TOKEN_IMPERSONATE</b>, and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {Pointer<PROFILEINFOW>} lpProfileInfo Type: <b>LPPROFILEINFO</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a> structure. <b>LoadUserProfile</b> fails and returns <b>ERROR_INVALID_PARAMETER</b> if the <b>dwSize</b> member of the structure is not set to <c>sizeof(PROFILEINFO)</c> or if the <b>lpUserName</b> member is <b>NULL</b>. For more information, see Remarks.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     *                 
     *                     
     * 
     * The function fails and returns ERROR_INVALID_PARAMETER if the <b>dwSize</b> member of the structure at <i>lpProfileInfo</i> is not set to <code>sizeof(PROFILEINFO)</code> or if the <b>lpUserName</b> member is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-loaduserprofilew
     * @since windows5.0
     */
    static LoadUserProfileW(hToken, lpProfileInfo) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken

        A_LastError := 0

        result := DllCall("USERENV.dll\LoadUserProfileW", "ptr", hToken, "ptr", lpProfileInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Unloads a user's profile that was loaded by the LoadUserProfile function. The caller must have administrative privileges on the computer. For more information, see the Remarks section of the LoadUserProfile function.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * Token for the user, returned from the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have <b>TOKEN_IMPERSONATE</b> and <b>TOKEN_DUPLICATE</b> access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {HANDLE} hProfile Type: <b>HANDLE</b>
     * 
     * Handle to the registry key. This value is the <b>hProfile</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/profinfo/ns-profinfo-profileinfoa">PROFILEINFO</a> structure. For more information see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/userenv/nf-userenv-loaduserprofilea">LoadUserProfile</a> and <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-unloaduserprofile
     * @since windows5.0
     */
    static UnloadUserProfile(hToken, hProfile) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        hProfile := hProfile is Win32Handle ? NumGet(hProfile, "ptr") : hProfile

        A_LastError := 0

        result := DllCall("USERENV.dll\UnloadUserProfile", "ptr", hToken, "ptr", hProfile, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to the root directory where user profiles are stored.
     * @param {PSTR} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
     * @param {Pointer<Integer>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getprofilesdirectorya
     * @since windows5.0
     */
    static GetProfilesDirectoryA(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String ? StrPtr(lpProfileDir) : lpProfileDir

        lpcchSizeMarshal := lpcchSize is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetProfilesDirectoryA", "ptr", lpProfileDir, lpcchSizeMarshal, lpcchSize, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to the root directory where user profiles are stored.
     * @param {PWSTR} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the profiles directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
     * @param {Pointer<Integer>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfilesDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfilesDir</i> is not large enough or <i>lpProfilesDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getprofilesdirectoryw
     * @since windows5.0
     */
    static GetProfilesDirectoryW(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String ? StrPtr(lpProfileDir) : lpProfileDir

        lpcchSizeMarshal := lpcchSize is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetProfilesDirectoryW", "ptr", lpProfileDir, lpcchSizeMarshal, lpcchSize, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the type of profile loaded for the current user.
     * @param {Pointer<Integer>} dwFlags Type: <b>DWORD*</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getprofiletype
     * @since windows5.0
     */
    static GetProfileType(dwFlags) {
        dwFlagsMarshal := dwFlags is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetProfileType", dwFlagsMarshal, dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile.
     * @param {PSTR} lpSidString Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the user 
     *     <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/security-identifiers">SID</a>.
     * @param {PSTR} lpProfilePath Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.
     * @param {PSTR} lpComputerName Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.
     *     
     *                         
     * 
     * <div class="alert"><b>Note</b>As of WindowsVista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</div>
     * <div></div>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-deleteprofilea
     * @since windows5.0
     */
    static DeleteProfileA(lpSidString, lpProfilePath, lpComputerName) {
        lpSidString := lpSidString is String ? StrPtr(lpSidString) : lpSidString
        lpProfilePath := lpProfilePath is String ? StrPtr(lpProfilePath) : lpProfilePath
        lpComputerName := lpComputerName is String ? StrPtr(lpComputerName) : lpComputerName

        A_LastError := 0

        result := DllCall("USERENV.dll\DeleteProfileA", "ptr", lpSidString, "ptr", lpProfilePath, "ptr", lpComputerName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deletes the user profile and all user-related settings from the specified computer. The caller must have administrative privileges to delete a user's profile.
     * @param {PWSTR} lpSidString Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the user 
     *     <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/security-identifiers">SID</a>.
     * @param {PWSTR} lpProfilePath Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the profile path. If this parameter is <b>NULL</b>, the function obtains the path from the registry.
     * @param {PWSTR} lpComputerName Type: <b>LPCTSTR</b>
     * 
     * Pointer to a string that specifies the name of the computer from which the profile is to be deleted. If this parameter is <b>NULL</b>, the local computer name is used.
     *     
     *                         
     * 
     * <div class="alert"><b>Note</b>As of WindowsVista, this parameter must be <b>NULL</b>. If it is not, this function fails with the error code ERROR_INVALID_PARAMETER.</div>
     * <div></div>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-deleteprofilew
     * @since windows5.0
     */
    static DeleteProfileW(lpSidString, lpProfilePath, lpComputerName) {
        lpSidString := lpSidString is String ? StrPtr(lpSidString) : lpSidString
        lpProfilePath := lpProfilePath is String ? StrPtr(lpProfilePath) : lpProfilePath
        lpComputerName := lpComputerName is String ? StrPtr(lpComputerName) : lpComputerName

        A_LastError := 0

        result := DllCall("USERENV.dll\DeleteProfileW", "ptr", lpSidString, "ptr", lpProfilePath, "ptr", lpComputerName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a new user profile.
     * @param {PWSTR} pszUserSid Type: <b>LPCWSTR</b>
     * 
     * Pointer to the SID of the user as a string.
     * @param {PWSTR} pszUserName Type: <b>LPCWSTR</b>
     * 
     * The user name of the new user. This name is used as the base name for the profile directory.
     * @param {PWSTR} pszProfilePath Type: <b>LPWSTR</b>
     * 
     * When this function returns, contains a pointer to the full path of the profile.
     * @param {Integer} cchProfilePath Type: <b>DWORD</b>
     * 
     * Size of the buffer pointed to by <i>pszProfilePath</i>, in characters.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have a sufficient permission level to create the profile.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A profile already exists for the specified user.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-createprofile
     * @since windows6.0.6000
     */
    static CreateProfile(pszUserSid, pszUserName, pszProfilePath, cchProfilePath) {
        pszUserSid := pszUserSid is String ? StrPtr(pszUserSid) : pszUserSid
        pszUserName := pszUserName is String ? StrPtr(pszUserName) : pszUserName
        pszProfilePath := pszProfilePath is String ? StrPtr(pszProfilePath) : pszProfilePath

        result := DllCall("USERENV.dll\CreateProfile", "ptr", pszUserSid, "ptr", pszUserName, "ptr", pszProfilePath, "uint", cchProfilePath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to the root of the default user's profile.
     * @param {PSTR} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
     * @param {Pointer<Integer>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getdefaultuserprofiledirectorya
     * @since windows5.0
     */
    static GetDefaultUserProfileDirectoryA(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String ? StrPtr(lpProfileDir) : lpProfileDir

        lpcchSizeMarshal := lpcchSize is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetDefaultUserProfileDirectoryA", "ptr", lpProfileDir, lpcchSizeMarshal, lpcchSize, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to the root of the default user's profile.
     * @param {PWSTR} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the default user's profile directory. Set this value to <b>NULL</b> to determine the required size of the buffer.
     * @param {Pointer<Integer>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getdefaultuserprofiledirectoryw
     * @since windows5.0
     */
    static GetDefaultUserProfileDirectoryW(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String ? StrPtr(lpProfileDir) : lpProfileDir

        lpcchSizeMarshal := lpcchSize is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetDefaultUserProfileDirectoryW", "ptr", lpProfileDir, lpcchSizeMarshal, lpcchSize, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to the root of the directory that contains program data shared by all users.
     * @param {PSTR} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.
     * @param {Pointer<Integer>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getallusersprofiledirectorya
     * @since windows5.0
     */
    static GetAllUsersProfileDirectoryA(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String ? StrPtr(lpProfileDir) : lpProfileDir

        lpcchSizeMarshal := lpcchSize is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetAllUsersProfileDirectoryA", "ptr", lpProfileDir, lpcchSizeMarshal, lpcchSize, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to the root of the directory that contains program data shared by all users.
     * @param {PWSTR} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path. Set this value to <b>NULL</b> to determine the required size of the buffer, including the terminating null character.
     * @param {Pointer<Integer>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * A pointer to the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getallusersprofiledirectoryw
     * @since windows5.0
     */
    static GetAllUsersProfileDirectoryW(lpProfileDir, lpcchSize) {
        lpProfileDir := lpProfileDir is String ? StrPtr(lpProfileDir) : lpProfileDir

        lpcchSizeMarshal := lpcchSize is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetAllUsersProfileDirectoryW", "ptr", lpProfileDir, lpcchSizeMarshal, lpcchSize, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to the root directory of the specified user's profile.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * A token for the user, which is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or  <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {PSTR} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.
     * @param {Pointer<Integer>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getuserprofiledirectorya
     * @since windows5.0
     */
    static GetUserProfileDirectoryA(hToken, lpProfileDir, lpcchSize) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        lpProfileDir := lpProfileDir is String ? StrPtr(lpProfileDir) : lpProfileDir

        lpcchSizeMarshal := lpcchSize is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetUserProfileDirectoryA", "ptr", hToken, "ptr", lpProfileDir, lpcchSizeMarshal, lpcchSize, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path to the root directory of the specified user's profile.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * A token for the user, which is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken">CreateRestrictedToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-duplicatetoken">DuplicateToken</a>, <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>, or  <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openthreadtoken">OpenThreadToken</a> function. The token must have TOKEN_QUERY access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>.
     * @param {PWSTR} lpProfileDir Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the path to the specified user's profile directory.
     * @param {Pointer<Integer>} lpcchSize Type: <b>LPDWORD</b>
     * 
     * Specifies the size of the <i>lpProfileDir</i> buffer, in <b>TCHARs</b>.
     *     
     *                         
     * 
     * If the buffer specified by <i>lpProfileDir</i> is not large enough or <i>lpProfileDir</i> is <b>NULL</b>, the function fails and this parameter receives the necessary buffer size, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//userenv/nf-userenv-getuserprofiledirectoryw
     * @since windows5.0
     */
    static GetUserProfileDirectoryW(hToken, lpProfileDir, lpcchSize) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        lpProfileDir := lpProfileDir is String ? StrPtr(lpProfileDir) : lpProfileDir

        lpcchSizeMarshal := lpcchSize is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("USERENV.dll\GetUserProfileDirectoryW", "ptr", hToken, "ptr", lpProfileDir, lpcchSizeMarshal, lpcchSize, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Initializes a PROPVARIANT structure based on a string stored in a STRRET structure.
     * @param {Pointer<STRRET>} pstrret Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure that contains the string.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * PIDL of the item whose details are being retrieved.
     * @param {Pointer<PROPVARIANT>} ppropvar Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a>*</b>
     * 
     * When this function returns, contains the initialized <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structure.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//propvarutil/nf-propvarutil-initpropvariantfromstrret
     * @since windows5.1.2600
     */
    static InitPropVariantFromStrRet(pstrret, pidl, ppropvar) {
        result := DllCall("PROPSYS.dll\InitPropVariantFromStrRet", "ptr", pstrret, "ptr", pidl, "ptr", ppropvar, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Extracts a string from a PROPVARIANT structure and places it into a STRRET structure.
     * @param {Pointer<PROPVARIANT>} propvar Type: <b>REFPROPVARIANT</b>
     * 
     * Reference to a source <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> structure.
     * @param {Pointer<STRRET>} pstrret Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * Points to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When this function returns, the structure has been initialized to contain a copy of the extracted string.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//propvarutil/nf-propvarutil-propvarianttostrret
     * @since windows5.1.2600
     */
    static PropVariantToStrRet(propvar, pstrret) {
        result := DllCall("PROPSYS.dll\PropVariantToStrRet", "ptr", propvar, "ptr", pstrret, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Initializes a VARIANT structure with a string stored in a STRRET structure.
     * @param {Pointer<STRRET>} pstrret Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * PIDL of the item whose details are being retrieved.
     * @param {Pointer<VARIANT>} pvar Type: <b>VARIANT*</b>
     * 
     * When this function returns, contains the initialized <a href="https://docs.microsoft.com/windows/desktop/api/oaidl/ns-oaidl-variant">VARIANT</a> structure.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//propvarutil/nf-propvarutil-initvariantfromstrret
     * @since windows5.1.2600
     */
    static InitVariantFromStrRet(pstrret, pidl, pvar) {
        result := DllCall("PROPSYS.dll\InitVariantFromStrRet", "ptr", pstrret, "ptr", pidl, "ptr", pvar, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * If the source variant is a VT_BSTR, extracts string and places it into a STRRET structure.
     * @param {Pointer<VARIANT>} varIn Type: <b>REFVARIANT</b>
     * 
     * Reference to a source variant structure.
     * @param {Pointer<STRRET>} pstrret Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * Pointer to the extracted string if one exists.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//propvarutil/nf-propvarutil-varianttostrret
     * @since windows5.1.2600
     */
    static VariantToStrRet(varIn, pstrret) {
        result := DllCall("PROPSYS.dll\VariantToStrRet", "ptr", varIn, "ptr", pstrret, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Installs or updates a window subclass callback.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * The handle of the window being subclassed.
     * @param {Pointer<SUBCLASSPROC>} pfnSubclass Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a></b>
     * 
     * A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback. For the callback function prototype, see <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a>.
     * @param {Pointer} uIdSubclass Type: <b>UINT_PTR</b>
     * 
     * The subclass ID. This ID together with the subclass procedure uniquely identify a subclass. To remove a subclass, pass the subclass procedure and this value to the <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nf-commctrl-removewindowsubclass">RemoveWindowSubclass</a> function. This value is passed to the subclass procedure in the uIdSubclass parameter.
     * @param {Pointer} dwRefData Type: <b>DWORD_PTR</b>
     * 
     * <b>DWORD_PTR</b> to reference data. The meaning of this value is determined by the calling application. This value is passed to the subclass procedure in the dwRefData parameter. A different dwRefData is associated with each combination of window handle, subclass procedure and uIdSubclass.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the subclass callback was successfully installed; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//commctrl/nf-commctrl-setwindowsubclass
     * @since windows5.1.2600
     */
    static SetWindowSubclass(hWnd, pfnSubclass, uIdSubclass, dwRefData) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        result := DllCall("COMCTL32.dll\SetWindowSubclass", "ptr", hWnd, "ptr", pfnSubclass, "ptr", uIdSubclass, "ptr", dwRefData, "int")
        return result
    }

    /**
     * Retrieves the reference data for the specified window subclass callback.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * The handle of the window being subclassed.
     * @param {Pointer<SUBCLASSPROC>} pfnSubclass Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a></b>
     * 
     * A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback.
     * @param {Pointer} uIdSubclass Type: <b>UINT_PTR</b>
     * 
     * <b>UINT_PTR</b> subclass ID. This ID and the callback pointer uniquely identify this subclass callback. Note: On 64-bit versions of Windows this is a 64-bit value.
     * @param {Pointer<Pointer>} pdwRefData Type: <b>DWORD_PTR*</b>
     * 
     * A pointer to a <b>DWORD</b> which will return the reference data. Note: On 64-bit versions of Windows, pointers are 64-bit values.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>TRUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subclass callback was successfully installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subclass callback was not installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//commctrl/nf-commctrl-getwindowsubclass
     * @since windows5.1.2600
     */
    static GetWindowSubclass(hWnd, pfnSubclass, uIdSubclass, pdwRefData) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        pdwRefDataMarshal := pdwRefData is VarRef ? "ptr*" : "ptr"

        result := DllCall("COMCTL32.dll\GetWindowSubclass", "ptr", hWnd, "ptr", pfnSubclass, "ptr", uIdSubclass, pdwRefDataMarshal, pdwRefData, "int")
        return result
    }

    /**
     * Removes a subclass callback from a window.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * The handle of the window being subclassed.
     * @param {Pointer<SUBCLASSPROC>} pfnSubclass Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a></b>
     * 
     * A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback. For the callback function prototype, see <a href="https://docs.microsoft.com/windows/desktop/api/commctrl/nc-commctrl-subclassproc">SUBCLASSPROC</a>.
     * @param {Pointer} uIdSubclass Type: <b>UINT_PTR</b>
     * 
     * The <b>UINT_PTR</b> subclass ID. This ID and the callback pointer uniquely identify this subclass callback. Note: On 64-bit versions of Windows this is a 64-bit value.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the subclass callback was successfully removed; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//commctrl/nf-commctrl-removewindowsubclass
     * @since windows5.1.2600
     */
    static RemoveWindowSubclass(hWnd, pfnSubclass, uIdSubclass) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        result := DllCall("COMCTL32.dll\RemoveWindowSubclass", "ptr", hWnd, "ptr", pfnSubclass, "ptr", uIdSubclass, "int")
        return result
    }

    /**
     * Calls the next handler in a window's subclass chain. The last handler in the subclass chain calls the original window procedure for the window.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window being subclassed.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * A value of type unsigned <b>int</b> that specifies a window message.
     * @param {WPARAM} wParam Type: <b>WPARAM</b>
     * 
     * Specifies additional message information. The contents of this parameter depend on the value of the window message.
     * @param {LPARAM} lParam Type: <b>LPARAM</b>
     * 
     * Specifies additional message information. The contents of this parameter depend on the value of the window message. Note: On 64-bit versions of Windows LPARAM is a 64-bit value.
     * @returns {LRESULT} Type: <b>LRESULT</b>
     * 
     * The returned value is specific to the message sent. This value should be ignored.
     * @see https://docs.microsoft.com/windows/win32/api//commctrl/nf-commctrl-defsubclassproc
     * @since windows5.1.2600
     */
    static DefSubclassProc(hWnd, uMsg, wParam, lParam) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        result := DllCall("COMCTL32.dll\DefSubclassProc", "ptr", hWnd, "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Associates a Help context identifier with the specified window.
     * @param {HWND} param0 
     * @param {Integer} param1 
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * 
     * To retrieve extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setwindowcontexthelpid
     * @since windows5.1.2600
     */
    static SetWindowContextHelpId(param0, param1) {
        param0 := param0 is Win32Handle ? NumGet(param0, "ptr") : param0

        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowContextHelpId", "ptr", param0, "uint", param1, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the Help context identifier, if any, associated with the specified window.
     * @param {HWND} param0 
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns the Help context identifier if the window has one, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getwindowcontexthelpid
     * @since windows5.1.2600
     */
    static GetWindowContextHelpId(param0) {
        param0 := param0 is Win32Handle ? NumGet(param0, "ptr") : param0

        result := DllCall("USER32.dll\GetWindowContextHelpId", "ptr", param0, "uint")
        return result
    }

    /**
     * Associates a Help context identifier with a menu.
     * @param {HMENU} param0 
     * @param {Integer} param1 
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * 
     * To retrieve extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-setmenucontexthelpid
     * @since windows5.1.2600
     */
    static SetMenuContextHelpId(param0, param1) {
        param0 := param0 is Win32Handle ? NumGet(param0, "ptr") : param0

        A_LastError := 0

        result := DllCall("USER32.dll\SetMenuContextHelpId", "ptr", param0, "uint", param1, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the Help context identifier associated with the specified menu.
     * @param {HMENU} param0 
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns the Help context identifier if the menu has one, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-getmenucontexthelpid
     * @since windows5.1.2600
     */
    static GetMenuContextHelpId(param0) {
        param0 := param0 is Win32Handle ? NumGet(param0, "ptr") : param0

        result := DllCall("USER32.dll\GetMenuContextHelpId", "ptr", param0, "uint")
        return result
    }

    /**
     * Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application.
     * @param {HWND} hWndMain Type: <b>HWND</b>
     * 
     * A handle to the window requesting help. The <b>WinHelp</b> function uses this handle to keep track of which applications have requested help. If the <i>uCommand</i> parameter specifies <b>HELP_CONTEXTMENU</b> or <b>HELP_WM_HELP</b>, <i>hWndMain</i> identifies the control requesting help.
     * @param {PSTR} lpszHelp Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string containing the path, if necessary, and the name of the Help file that <b>WinHelp</b> is to display.
     * 	
     *     				
     * 
     * The file name can be followed by an angle bracket (&gt;) and the name of a secondary window if the topic is to be displayed in a secondary window rather than in the primary window. You must define the name of the secondary window in the [WINDOWS] section of the Help project (.hpj) file.
     * @param {Integer} uCommand Type: <b>UINT</b>
     * 
     * The type of help requested. For a list of possible values and how they affect the value to place in the <i>dwData</i> parameter, see the Remarks section.
     * @param {Pointer} dwData Type: <b>ULONG_PTR</b>
     * 
     * Additional data. The value used depends on the value of the <i>uCommand</i> parameter. For a list of possible <i>dwData</i> values, see the Remarks section.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-winhelpa
     * @since windows5.1.2600
     */
    static WinHelpA(hWndMain, lpszHelp, uCommand, dwData) {
        hWndMain := hWndMain is Win32Handle ? NumGet(hWndMain, "ptr") : hWndMain
        lpszHelp := lpszHelp is String ? StrPtr(lpszHelp) : lpszHelp

        A_LastError := 0

        result := DllCall("USER32.dll\WinHelpA", "ptr", hWndMain, "ptr", lpszHelp, "uint", uCommand, "ptr", dwData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application.
     * @param {HWND} hWndMain Type: <b>HWND</b>
     * 
     * A handle to the window requesting help. The <b>WinHelp</b> function uses this handle to keep track of which applications have requested help. If the <i>uCommand</i> parameter specifies <b>HELP_CONTEXTMENU</b> or <b>HELP_WM_HELP</b>, <i>hWndMain</i> identifies the control requesting help.
     * @param {PWSTR} lpszHelp Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string containing the path, if necessary, and the name of the Help file that <b>WinHelp</b> is to display.
     * 	
     *     				
     * 
     * The file name can be followed by an angle bracket (&gt;) and the name of a secondary window if the topic is to be displayed in a secondary window rather than in the primary window. You must define the name of the secondary window in the [WINDOWS] section of the Help project (.hpj) file.
     * @param {Integer} uCommand Type: <b>UINT</b>
     * 
     * The type of help requested. For a list of possible values and how they affect the value to place in the <i>dwData</i> parameter, see the Remarks section.
     * @param {Pointer} dwData Type: <b>ULONG_PTR</b>
     * 
     * Additional data. The value used depends on the value of the <i>uCommand</i> parameter. For a list of possible <i>dwData</i> values, see the Remarks section.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-winhelpw
     * @since windows5.1.2600
     */
    static WinHelpW(hWndMain, lpszHelp, uCommand, dwData) {
        hWndMain := hWndMain is Win32Handle ? NumGet(hWndMain, "ptr") : hWndMain
        lpszHelp := lpszHelp is String ? StrPtr(lpszHelp) : lpszHelp

        A_LastError := 0

        result := DllCall("USER32.dll\WinHelpW", "ptr", hWndMain, "ptr", lpszHelp, "uint", uCommand, "ptr", dwData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deprecated. Returns a pointer to an ITEMIDLIST structure when passed a path.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to be converted to a PIDL.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a pointer to an <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shsimpleidlistfrompath
     * @since windows5.0
     */
    static SHSimpleIDListFromPath(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHSimpleIDListFromPath", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Creates and initializes a Shell item object from a pointer to an item identifier list (PIDL). The resulting shell item object supports the IShellItem interface.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The source PIDL.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the requested interface.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in riid.  This will typically be <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateitemfromidlist
     * @since windows6.0.6000
     */
    static SHCreateItemFromIDList(pidl, riid) {
        result := DllCall("SHELL32.dll\SHCreateItemFromIDList", "ptr", pidl, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Creates and initializes a Shell item object from a parsing name.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a display name.
     * @param {IBindCtx} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * Optional. A pointer to a bind context used to pass parameters as inputs and outputs to the parsing function. These passed parameters are often specific to the data source and are documented by the data source owners. For example, the file system data source accepts the name being parsed (as a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure), using the <a href="https://docs.microsoft.com/windows/desktop/shell/str-constants">STR_FILE_SYS_BIND_DATA</a> bind context parameter.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/shell/str-constants">STR_PARSE_PREFER_FOLDER_BROWSING</a> can be passed to indicate that URLs are parsed using the file system data source when possible. Construct a bind context object using <a href="https://docs.microsoft.com/windows/desktop/api/objbase/nf-objbase-createbindctx">CreateBindCtx</a> and populate the values using <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-ibindctx-registerobjectparam">IBindCtx::RegisterObjectParam</a>. See <b>Bind Context String Keys</b> for a complete list of these. See the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/dd940368(v=vs.85)">Parsing With Parameters Sample</a> for an example of the use of this parameter.
     * 
     * 
     * 
     * If no data is being passed to or received from the parsing function, this value can be <b>NULL</b>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>, typically <b>IID_IShellItem</b> or <b>IID_IShellItem2</b>.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns successfully, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateitemfromparsingname
     * @since windows6.0.6000
     */
    static SHCreateItemFromParsingName(pszPath, pbc, riid) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHCreateItemFromParsingName", "ptr", pszPath, "ptr", pbc, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Create a Shell item, given a parent folder and a child item ID.
     * @param {Pointer<ITEMIDLIST>} pidlParent Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The IDList of the parent folder of the item being created; the IDList of <i>psfParent</i>. This parameter can be <b>NULL</b>, if <i>psfParent</i> is specified.
     * @param {IShellFolder} psfParent Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface that specifies the shell data source of the child item specified by the <i>pidl</i>.This parameter can be <b>NULL</b>, if <i>pidlParent</i> is specified.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A child item ID relative to its parent folder specified by <i>psfParent</i> or <i>pidlParent</i>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to an interface ID.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in riid.  This will typically be <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateitemwithparent
     * @since windows6.0.6000
     */
    static SHCreateItemWithParent(pidlParent, psfParent, pidl, riid) {
        result := DllCall("SHELL32.dll\SHCreateItemWithParent", "ptr", pidlParent, "ptr", psfParent, "ptr", pidl, "ptr", riid, "ptr*", &ppvItem := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvItem
    }

    /**
     * Creates and initializes a Shell item object from a relative parsing name.
     * @param {IShellItem} psiParent Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the parent Shell item.
     * @param {PWSTR} pszName Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string that specifies a display name that is relative to the <i>psiParent</i>.
     * @param {IBindCtx} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A pointer to a bind context that controls the parsing operation. This parameter can be <b>NULL</b>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to an interface ID.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in riid.  This will usually be <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateitemfromrelativename
     * @since windows6.0.6000
     */
    static SHCreateItemFromRelativeName(psiParent, pszName, pbc, riid) {
        pszName := pszName is String ? StrPtr(pszName) : pszName

        result := DllCall("SHELL32.dll\SHCreateItemFromRelativeName", "ptr", psiParent, "ptr", pszName, "ptr", pbc, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Creates a Shell item object for a single file that exists inside a known folder.
     * @param {Pointer<Guid>} kfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A reference to the <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a>, a <b>GUID</b> that identifies the folder that contains the item.
     * @param {Integer} dwKFFlags Type: <b>DWORD</b>
     * 
     * Flags that specify special options in the object retrieval. This value can be 0; otherwise, one or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a> values.
     * @param {PWSTR} pszItem Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the file name of the new item as a Unicode string. This parameter can also be <b>NULL</b>. In this case, an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> that represents the known folder itself is created.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface that represents the item, retrieved through <i>ppv</i>. This value is typically IID_IShellItem or IID_IShellItem2.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this function returns successfully, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem2">IShellItem2</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateiteminknownfolder
     * @since windows6.0.6000
     */
    static SHCreateItemInKnownFolder(kfid, dwKFFlags, pszItem, riid) {
        pszItem := pszItem is String ? StrPtr(pszItem) : pszItem

        result := DllCall("SHELL32.dll\SHCreateItemInKnownFolder", "ptr", kfid, "uint", dwKFFlags, "ptr", pszItem, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Retrieves the pointer to an item identifier list (PIDL) of an object.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> of the object from which to get the PIDL.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * When this function returns, contains a pointer to the PIDL of the given object.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shgetidlistfromobject
     * @since windows6.0.6000
     */
    static SHGetIDListFromObject(punk) {
        result := DllCall("SHELL32.dll\SHGetIDListFromObject", "ptr", punk, "ptr*", &ppidl := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppidl
    }

    /**
     * Retrieves an IShellItem for an object.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> of the object.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired IID.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> or a related interface.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shgetitemfromobject
     * @since windows6.1
     */
    static SHGetItemFromObject(punk, riid) {
        result := DllCall("SHELL32.dll\SHGetItemFromObject", "ptr", punk, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Retrieves the display name of an item identified by its IDList.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A PIDL that identifies the item.
     * @param {Integer} sigdnName Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-sigdn">SIGDN</a></b>
     * 
     * A value from the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-sigdn">SIGDN</a> enumeration that specifies the type of display name to retrieve.
     * @returns {PWSTR} Type: <b>PWSTR*</b>
     * 
     * A value that, when this function returns successfully, receives the address of a pointer to the retrieved display name.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shgetnamefromidlist
     * @since windows6.0.6000
     */
    static SHGetNameFromIDList(pidl, sigdnName) {
        result := DllCall("SHELL32.dll\SHGetNameFromIDList", "ptr", pidl, "int", sigdnName, "ptr*", &ppszName := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppszName
    }

    /**
     * Creates an IShellItem or related object based on an item specified by an IDataObject.
     * @param {IDataObject} pdtobj Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to the source <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> instance.
     * @param {Integer} dwFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-dataobj_get_item_flags">DATAOBJ_GET_ITEM_FLAGS</a></b>
     * 
     * One or more values from the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-dataobj_get_item_flags">DATAOBJ_GET_ITEM_FLAGS</a> enumeration to specify options regarding the target object. This value can be 0.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>, typically IID_IShellItem.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shgetitemfromdataobject
     * @since windows6.1
     */
    static SHGetItemFromDataObject(pdtobj, dwFlags, riid) {
        result := DllCall("SHELL32.dll\SHGetItemFromDataObject", "ptr", pdtobj, "int", dwFlags, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Creates a Shell item array object.
     * @param {Pointer<ITEMIDLIST>} pidlParent Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The ID list of the parent folder of the items specified in <i>ppidl</i>. If <i>psf</i> is specified, this parameter can be <b>NULL</b>. If this <i>pidlParent</i> is not specified, it is computed from the <i>psf</i> parameter using <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder2">IPersistFolder2</a>.
     * @param {IShellFolder} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * The Shell data source object that is the parent of the child items specified in <i>ppidl</i>. If <i>pidlParent</i> is specified, this parameter can be <b>NULL</b>.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of elements in the array specified by <i>ppidl</i>.
     * @param {Pointer<Pointer<ITEMIDLIST>>} ppidl Type: <b>PCUITEMID_CHILD_ARRAY</b>
     * 
     * The list of child item IDs for which the array is being created. This value can be <b>NULL</b>.
     * @returns {IShellItemArray} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a>**</b>
     * 
     * When this function returns, contains the address of an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a> interface pointer.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateshellitemarray
     * @since windows6.0.6000
     */
    static SHCreateShellItemArray(pidlParent, psf, cidl, ppidl) {
        ppidlMarshal := ppidl is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\SHCreateShellItemArray", "ptr", pidlParent, "ptr", psf, "uint", cidl, ppidlMarshal, ppidl, "ptr*", &ppsiItemArray := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IShellItemArray(ppsiItemArray)
    }

    /**
     * Creates a Shell item array object from a data object.
     * @param {IDataObject} pdo Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the desired interface ID.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject
     * @since windows6.0.6000
     */
    static SHCreateShellItemArrayFromDataObject(pdo, riid) {
        result := DllCall("SHELL32.dll\SHCreateShellItemArrayFromDataObject", "ptr", pdo, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Creates a Shell item array object from a list of ITEMIDLIST structures.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of elements in the array.
     * @param {Pointer<Pointer<ITEMIDLIST>>} rgpidl Type: <b>PCIDLIST_ABSOLUTE_ARRAY</b>
     * 
     * A list of <i>cidl</i> constant pointers to <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures.
     * @returns {IShellItemArray} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a>**</b>
     * 
     * When this function returns, contains an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a> interface pointer.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromidlists
     * @since windows6.0.6000
     */
    static SHCreateShellItemArrayFromIDLists(cidl, rgpidl) {
        rgpidlMarshal := rgpidl is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\SHCreateShellItemArrayFromIDLists", "uint", cidl, rgpidlMarshal, rgpidl, "ptr*", &ppsiItemArray := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IShellItemArray(ppsiItemArray)
    }

    /**
     * Creates an array of one element from a single Shell item.
     * @param {IShellItem} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * Pointer to <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> object that represents the item.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>, typically IID_IShellItemArray.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray">IShellItemArray</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromshellitem
     * @since windows6.0.6000
     */
    static SHCreateShellItemArrayFromShellItem(psi, riid) {
        result := DllCall("SHELL32.dll\SHCreateShellItemArrayFromShellItem", "ptr", psi, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Creates an IApplicationAssociationRegistration object based on the stock implementation of the interface provided by Windows.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the requested interface.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this function returns, contains the address of a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-iapplicationassociationregistration">IApplicationAssociationRegistration</a> object.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreateassociationregistration
     * @since windows6.0.6000
     */
    static SHCreateAssociationRegistration(riid) {
        result := DllCall("SHELL32.dll\SHCreateAssociationRegistration", "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Creates a standard icon extractor, whose defaults can be further configured via the IDefaultExtractIconInit interface.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to interface ID.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * The address of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idefaultextracticoninit">IDefaultExtractIconInit</a> interface pointer.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shcreatedefaultextracticon
     * @since windows6.0.6000
     */
    static SHCreateDefaultExtractIcon(riid) {
        result := DllCall("SHELL32.dll\SHCreateDefaultExtractIcon", "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Specifies a unique application-defined Application User Model ID (AppUserModelID) that identifies the current process to the taskbar. This identifier allows an application to group its associated processes and windows under a single taskbar button.
     * @param {PWSTR} AppID Type: <b>PCWSTR</b>
     * 
     * Pointer to the AppUserModelID to assign to the current process.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-setcurrentprocessexplicitappusermodelid
     * @since windows6.1
     */
    static SetCurrentProcessExplicitAppUserModelID(AppID) {
        AppID := AppID is String ? StrPtr(AppID) : AppID

        result := DllCall("SHELL32.dll\SetCurrentProcessExplicitAppUserModelID", "ptr", AppID, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the application-defined, explicit Application User Model ID (AppUserModelID) for the current process.
     * @returns {PWSTR} Type: <b>PWSTR*</b>
     * 
     * A pointer that receives the address of the AppUserModelID assigned to the process. The caller is responsible for freeing this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-getcurrentprocessexplicitappusermodelid
     * @since windows6.1
     */
    static GetCurrentProcessExplicitAppUserModelID() {
        result := DllCall("SHELL32.dll\GetCurrentProcessExplicitAppUserModelID", "ptr*", &AppID := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return AppID
    }

    /**
     * Retrieves the temporary property for the given item. A temporary property is a read/write store that holds properties only for the lifetime of the IShellItem object, rather than being persisted back into the item.
     * @param {IShellItem} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the item for which the temporary property is to be retrieved.
     * @param {Pointer<PROPERTYKEY>} propkey Type: <b>REFPROPERTYKEY</b>
     * 
     * The property key.
     * @param {Pointer<PROPVARIANT>} ppropvar Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a>*</b>
     * 
     * A pointer to the temporary property for the item.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shgettemporarypropertyforitem
     * @since windows6.0.6000
     */
    static SHGetTemporaryPropertyForItem(psi, propkey, ppropvar) {
        result := DllCall("SHELL32.dll\SHGetTemporaryPropertyForItem", "ptr", psi, "ptr", propkey, "ptr", ppropvar, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets a temporary property for the specified item. A temporary property is kept in a read/write store that holds properties only for the lifetime of the IShellItem object, instead of writing them back into the item.
     * @param {IShellItem} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the item on which the temporary property is to be set.
     * @param {Pointer<PROPERTYKEY>} propkey Type: <b>REFPROPERTYKEY</b>
     * 
     * Reference to the <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ns-wtypes-propertykey">PROPERTYKEY</a> that identifies the temporary property that is being set.
     * @param {Pointer<PROPVARIANT>} propvar Type: <b>REFPROPVARIANT</b>
     * 
     * Reference to a <a href="https://docs.microsoft.com/windows/desktop/api/propidl/ns-propidl-propvariant">PROPVARIANT</a> that contains the value of the temporary property.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shsettemporarypropertyforitem
     * @since windows6.0.6000
     */
    static SHSetTemporaryPropertyForItem(psi, propkey, propvar) {
        result := DllCall("SHELL32.dll\SHSetTemporaryPropertyForItem", "ptr", psi, "ptr", propkey, "ptr", propvar, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Shows the library management dialog box, which enables users to manage the library folders and default save location.
     * @param {IShellItem} psiLibrary Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> object that represents the library that is to be managed.
     * @param {HWND} hwndOwner Type: <b>HWND</b>
     * 
     * The handle for the window that owns the library management dialog box. The value of this parameter can be <b>NULL</b>.
     * @param {PWSTR} pszTitle Type: <b>LPCWSTR</b>
     * 
     * A pointer to the title for the library management dialog. To display the generic title string, set the value of this parameter to <b>NULL</b>.
     * @param {PWSTR} pszInstruction Type: <b>LPCWSTR</b>
     * 
     * A pointer to a help string to display below the title string in the library management dialog box. To display the generic help string, set the value of this parameter to <b>NULL</b>.
     * @param {Integer} lmdOptions Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-librarymanagedialogoptions">LIBRARYMANAGEDIALOGOPTIONS</a></b>
     * 
     * A value from the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/ne-shobjidl_core-librarymanagedialogoptions">LIBRARYMANAGEDIALOGOPTIONS</a> enumeration that specifies the behavior of the management dialog box.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shshowmanagelibraryui
     * @since windows6.1
     */
    static SHShowManageLibraryUI(psiLibrary, hwndOwner, pszTitle, pszInstruction, lmdOptions) {
        hwndOwner := hwndOwner is Win32Handle ? NumGet(hwndOwner, "ptr") : hwndOwner
        pszTitle := pszTitle is String ? StrPtr(pszTitle) : pszTitle
        pszInstruction := pszInstruction is String ? StrPtr(pszInstruction) : pszInstruction

        result := DllCall("SHELL32.dll\SHShowManageLibraryUI", "ptr", psiLibrary, "ptr", hwndOwner, "ptr", pszTitle, "ptr", pszInstruction, "int", lmdOptions, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Resolves all locations in a library, even those locations that have been moved or renamed.
     * @param {IShellItem} psiLibrary Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> object that represents the library.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shresolvelibrary
     * @since windows6.1
     */
    static SHResolveLibrary(psiLibrary) {
        result := DllCall("SHELL32.dll\SHResolveLibrary", "ptr", psiLibrary, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns an enumeration object for a specified set of file name extension handlers.
     * @param {PWSTR} pszExtra Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains a single file type extension, for instance ".jpg". Only handlers associated with the given extension are enumerated. This parameter may not be **NULL**.
     * @param {Integer} afFilter Type: <b>ASSOC_FILTER</b>
     * @returns {IEnumAssocHandlers} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumassochandlers">IEnumAssocHandlers</a>**</b>
     * 
     * When this method returns, contains the address of a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumassochandlers">IEnumAssocHandlers</a> object.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shassocenumhandlers
     * @since windows6.0.6000
     */
    static SHAssocEnumHandlers(pszExtra, afFilter) {
        pszExtra := pszExtra is String ? StrPtr(pszExtra) : pszExtra

        result := DllCall("SHELL32.dll\SHAssocEnumHandlers", "ptr", pszExtra, "int", afFilter, "ptr*", &ppEnumHandler := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IEnumAssocHandlers(ppEnumHandler)
    }

    /**
     * Gets an enumeration interface that provides access to handlers associated with a given protocol.
     * @param {PWSTR} protocol Type: <b>PCWSTR</b>
     * 
     * Pointer to a string that specifies the protocol.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>enumHandlers</i>, typically IID_IEnumAssocHandlers.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumassochandlers">IEnumAssocHandlers</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl_core/nf-shobjidl_core-shassocenumhandlersforprotocolbyapplication
     * @since windows6.1
     */
    static SHAssocEnumHandlersForProtocolByApplication(protocol, riid) {
        protocol := protocol is String ? StrPtr(protocol) : protocol

        result := DllCall("SHELL32.dll\SHAssocEnumHandlersForProtocolByApplication", "ptr", protocol, "ptr", riid, "ptr*", &enumHandlers := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return enumHandlers
    }

    /**
     * 
     * @param {Pointer<Integer>} param0 
     * @param {Integer} param1 
     * @param {Pointer<HMONITOR>} param2 
     * @returns {Integer} 
     */
    static HMONITOR_UserSize(param0, param1, param2) {
        param0Marshal := param0 is VarRef ? "uint*" : "ptr"

        result := DllCall("OLE32.dll\HMONITOR_UserSize", param0Marshal, param0, "uint", param1, "ptr", param2, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} param0 
     * @param {Pointer<Integer>} param1 
     * @param {Pointer<HMONITOR>} param2 
     * @returns {Pointer<Integer>} 
     */
    static HMONITOR_UserMarshal(param0, param1, param2) {
        param0Marshal := param0 is VarRef ? "uint*" : "ptr"
        param1Marshal := param1 is VarRef ? "char*" : "ptr"

        result := DllCall("OLE32.dll\HMONITOR_UserMarshal", param0Marshal, param0, param1Marshal, param1, "ptr", param2, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} param0 
     * @param {Pointer<Integer>} param1 
     * @param {Pointer<HMONITOR>} param2 
     * @returns {Pointer<Integer>} 
     */
    static HMONITOR_UserUnmarshal(param0, param1, param2) {
        param0Marshal := param0 is VarRef ? "uint*" : "ptr"
        param1Marshal := param1 is VarRef ? "char*" : "ptr"

        result := DllCall("OLE32.dll\HMONITOR_UserUnmarshal", param0Marshal, param0, param1Marshal, param1, "ptr", param2, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} param0 
     * @param {Pointer<HMONITOR>} param1 
     * @returns {String} Nothing - always returns an empty string
     */
    static HMONITOR_UserFree(param0, param1) {
        param0Marshal := param0 is VarRef ? "uint*" : "ptr"

        DllCall("OLE32.dll\HMONITOR_UserFree", param0Marshal, param0, "ptr", param1)
    }

    /**
     * 
     * @param {Pointer<Integer>} param0 
     * @param {Integer} param1 
     * @param {Pointer<HMONITOR>} param2 
     * @returns {Integer} 
     */
    static HMONITOR_UserSize64(param0, param1, param2) {
        param0Marshal := param0 is VarRef ? "uint*" : "ptr"

        result := DllCall("OLE32.dll\HMONITOR_UserSize64", param0Marshal, param0, "uint", param1, "ptr", param2, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} param0 
     * @param {Pointer<Integer>} param1 
     * @param {Pointer<HMONITOR>} param2 
     * @returns {Pointer<Integer>} 
     */
    static HMONITOR_UserMarshal64(param0, param1, param2) {
        param0Marshal := param0 is VarRef ? "uint*" : "ptr"
        param1Marshal := param1 is VarRef ? "char*" : "ptr"

        result := DllCall("OLE32.dll\HMONITOR_UserMarshal64", param0Marshal, param0, param1Marshal, param1, "ptr", param2, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} param0 
     * @param {Pointer<Integer>} param1 
     * @param {Pointer<HMONITOR>} param2 
     * @returns {Pointer<Integer>} 
     */
    static HMONITOR_UserUnmarshal64(param0, param1, param2) {
        param0Marshal := param0 is VarRef ? "uint*" : "ptr"
        param1Marshal := param1 is VarRef ? "char*" : "ptr"

        result := DllCall("OLE32.dll\HMONITOR_UserUnmarshal64", param0Marshal, param0, param1Marshal, param1, "ptr", param2, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} param0 
     * @param {Pointer<HMONITOR>} param1 
     * @returns {String} Nothing - always returns an empty string
     */
    static HMONITOR_UserFree64(param0, param1) {
        param0Marshal := param0 is VarRef ? "uint*" : "ptr"

        DllCall("OLE32.dll\HMONITOR_UserFree64", param0Marshal, param0, "ptr", param1)
    }

    /**
     * Creates a file operation that sets the default properties on the Shell item that have not already been set.
     * @param {IShellItem} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the source shell item. See <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>.
     * @returns {IFileOperation} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifileoperation">IFileOperation</a>**</b>
     * 
     * The address of the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifileoperation">IFileOperation</a> interface pointer.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl/nf-shobjidl-shcreatedefaultpropertiesop
     * @since windows6.0.6000
     */
    static SHCreateDefaultPropertiesOp(psi) {
        result := DllCall("SHELL32.dll\SHCreateDefaultPropertiesOp", "ptr", psi, "ptr*", &ppFileOp := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IFileOperation(ppFileOp)
    }

    /**
     * Applies the default set of properties on a Shell item.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the item's parent window, which receives error notifications. This value can be <b>NULL</b>.
     * @param {IShellItem} psi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a> object that represents the item.
     * @param {Integer} dwFileOpFlags Type: <b>DWORD</b>
     * 
     * Flags that customize the operation. See <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ifileoperation-setoperationflags">IFileOperation::SetOperationFlags</a> for flag values.
     * @param {IFileOperationProgressSink} pfops Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifileoperationprogresssink">IFileOperationProgressSink</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ifileoperationprogresssink">IFileOperationProgressSink</a> object used to follow the progress of the operation. See <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ifileoperation-advise">IFileOperation::Advise</a> for details. This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shobjidl/nf-shobjidl-shsetdefaultproperties
     * @since windows6.0.6000
     */
    static SHSetDefaultProperties(hwnd, psi, dwFileOpFlags, pfops) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd

        result := DllCall("SHELL32.dll\SHSetDefaultProperties", "ptr", hwnd, "ptr", psi, "uint", dwFileOpFlags, "ptr", pfops, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a pointer to the Shell's IMalloc interface.
     * @returns {IMalloc} Type: <b>LPMALLOC*</b>
     * 
     * The address of a pointer that receives the Shell's <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imalloc">IMalloc</a> interface pointer.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetmalloc
     * @since windows5.1.2600
     */
    static SHGetMalloc() {
        result := DllCall("SHELL32.dll\SHGetMalloc", "ptr*", &ppMalloc := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IMalloc(ppMalloc)
    }

    /**
     * Allocates memory from the Shell's heap.
     * @param {Pointer} cb Type: <b>SIZE_T</b>
     * 
     * The number of bytes of memory to allocate.
     * @returns {Pointer<Void>} Type: <b>LPVOID</b>
     * 
     * A pointer to the allocated memory.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shalloc
     * @since windows5.0
     */
    static SHAlloc(cb) {
        result := DllCall("SHELL32.dll\SHAlloc", "ptr", cb, "ptr")
        return result
    }

    /**
     * Frees the memory allocated by SHAlloc.
     * @param {Pointer<Void>} pv Type: <b>void*</b>
     * 
     * A pointer to the memory allocated by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shalloc">SHAlloc</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shfree
     * @since windows5.0
     */
    static SHFree(pv) {
        pvMarshal := pv is VarRef ? "ptr" : "ptr"

        DllCall("SHELL32.dll\SHFree", pvMarshal, pv)
    }

    /**
     * Returns the index of the overlay icon in the system image list.
     * @param {PSTR} pszIconPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgeticonoverlayindexa
     * @since windows5.0
     */
    static SHGetIconOverlayIndexA(pszIconPath, iIconIndex) {
        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\SHGetIconOverlayIndexA", "ptr", pszIconPath, "int", iIconIndex, "int")
        return result
    }

    /**
     * Returns the index of the overlay icon in the system image list.
     * @param {PWSTR} pszIconPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length <b>MAX_PATH</b> that contains the fully qualified path of the file that contains the icon.
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The icon's index in the file pointed to by <i>pszIconPath</i>. To request a standard overlay icon, set <i>pszIconPath</i> to <b>NULL</b>, and <i>iIconIndex</i> to one of the following:
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the overlay icon in the system image list if successful, or -1 otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgeticonoverlayindexw
     * @since windows5.0
     */
    static SHGetIconOverlayIndexW(pszIconPath, iIconIndex) {
        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\SHGetIconOverlayIndexW", "ptr", pszIconPath, "int", iIconIndex, "int")
        return result
    }

    /**
     * Clones an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure to be cloned.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_RELATIVE</b>
     * 
     * Returns a pointer to a copy of the <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure pointed to by <i>pidl</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilclone
     * @since windows5.1.2600
     */
    static ILClone(pidl) {
        result := DllCall("SHELL32.dll\ILClone", "ptr", pidl, "ptr")
        return result
    }

    /**
     * Clones the first SHITEMID structure in an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that you want to clone.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PITEMID_CHILD</b>
     * 
     * A pointer to an <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that contains the first <a href="/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure from the <b>ITEMIDLIST</b> structure specified by <i>pidl</i>. Returns <b>NULL</b> on failure.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilclonefirst
     * @since windows5.1.2600
     */
    static ILCloneFirst(pidl) {
        result := DllCall("SHELL32.dll\ILCloneFirst", "ptr", pidl, "ptr")
        return result
    }

    /**
     * Combines two ITEMIDLIST structures.
     * @param {Pointer<ITEMIDLIST>} pidl1 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to the first <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<ITEMIDLIST>} pidl2 Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to the second <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure. This structure is appended to the structure pointed to by <i>pidl1</i>.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns an <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> containing the combined structures. If you set either <i>pidl1</i> or <i>pidl2</i> to <b>NULL</b>, the returned <b>ITEMIDLIST</b> structure is a clone of the non-<b>NULL</b> parameter. Returns <b>NULL</b> if <i>pidl1</i> and <i>pidl2</i> are both set to <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilcombine
     * @since windows5.1.2600
     */
    static ILCombine(pidl1, pidl2) {
        result := DllCall("SHELL32.dll\ILCombine", "ptr", pidl1, "ptr", pidl2, "ptr")
        return result
    }

    /**
     * Frees an ITEMIDLIST structure allocated by the Shell.
     * @remarks
     * 
     * <b>ILFree</b> is often used with <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures allocated by one of the other IL functions, but it can be used to free any such structure returned by the Shellfor example, the <b>ITEMIDLIST</b> structure returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shbrowseforfoldera">SHBrowseForFolder</a> or used in a call to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderlocation">SHGetFolderLocation</a>.
     * 
     * <div class="alert"><b>Note</b>When using Windows2000 or later, use <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> rather than <b>ILFree</b>. <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures are always allocated with the Component Object Model (COM) task allocator on those platforms.</div>
     * <div></div>
     * 
     * 
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure to be freed. This parameter can be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilfree
     * @since windows5.1.2600
     */
    static ILFree(pidl) {
        DllCall("SHELL32.dll\ILFree", "ptr", pidl)
    }

    /**
     * Retrieves the next SHITEMID structure in an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to a particular <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure in a larger <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PUIDLIST_RELATIVE</b>
     * 
     * Returns a pointer to the <a href="/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure that follows the one specified by <i>pidl</i>. Returns <b>NULL</b> if <i>pidl</i> points to the last <b>SHITEMID</b> structure.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilgetnext
     * @since windows5.1.2600
     */
    static ILGetNext(pidl) {
        result := DllCall("SHELL32.dll\ILGetNext", "ptr", pidl, "ptr")
        return result
    }

    /**
     * Returns the size, in bytes, of an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * The size of the <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure specified by <i>pidl</i>, in bytes.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilgetsize
     * @since windows5.1.2600
     */
    static ILGetSize(pidl) {
        result := DllCall("SHELL32.dll\ILGetSize", "ptr", pidl, "uint")
        return result
    }

    /**
     * Determines whether a specified ITEMIDLIST structure is the child of another ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidlParent Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to the parent <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<ITEMIDLIST>} pidlChild Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to the child <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PUIDLIST_RELATIVE</b>
     * 
     * Returns a pointer to the child's simple <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure if <i>pidlChild</i> is a child of <i>pidlParent</i>. The returned structure consists of <i>pidlChild</i>, minus the <a href="/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structures that make up <i>pidlParent</i>. Returns <b>NULL</b> if <i>pidlChild</i> is not a child of <i>pidlParent</i>.
     * 
     * <div class="alert"><b>Note</b>The returned pointer is a pointer into the existing parent structure. It is an alias for <i>pidlChild</i>. No new memory is allocated in association with the returned pointer. It is not the caller's responsibility to free the returned value.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilfindchild
     * @since windows5.1.2600
     */
    static ILFindChild(pidlParent, pidlChild) {
        result := DllCall("SHELL32.dll\ILFindChild", "ptr", pidlParent, "ptr", pidlChild, "ptr")
        return result
    }

    /**
     * Returns a pointer to the last SHITEMID structure in an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PUITEMID_CHILD</b>
     * 
     * A pointer to the last <a href="/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure in <i>pidl</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilfindlastid
     * @since windows5.1.2600
     */
    static ILFindLastID(pidl) {
        result := DllCall("SHELL32.dll\ILFindLastID", "ptr", pidl, "ptr")
        return result
    }

    /**
     * Removes the last SHITEMID structure from an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PUIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure to be shortened. When the function returns, this variable points to the shortened structure.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilremovelastid
     * @since windows5.1.2600
     */
    static ILRemoveLastID(pidl) {
        result := DllCall("SHELL32.dll\ILRemoveLastID", "ptr", pidl, "int")
        return result
    }

    /**
     * Tests whether two ITEMIDLIST structures are equal in a binary comparison.
     * @param {Pointer<ITEMIDLIST>} pidl1 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The first <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<ITEMIDLIST>} pidl2 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The second <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the two structures are equal, <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilisequal
     * @since windows5.1.2600
     */
    static ILIsEqual(pidl1, pidl2) {
        result := DllCall("SHELL32.dll\ILIsEqual", "ptr", pidl1, "ptr", pidl2, "int")
        return result
    }

    /**
     * Tests whether an ITEMIDLIST structure is the parent of another ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl1 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) structure that specifies the parent. This must be an absolute PIDL.
     * @param {Pointer<ITEMIDLIST>} pidl2 Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) structure that specifies the child. This must be an absolute PIDL.
     * @param {BOOL} fImmediate Type: <b>BOOL</b>
     * 
     * A Boolean value that is set to <b>TRUE</b> to test for immediate parents of <i>pidl2</i>, or <b>FALSE</b> to test for any parents of <i>pidl2</i>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pidl1</i> is a parent of <i>pidl2</i>. If <i>fImmediate</i> is set to <b>TRUE</b>, the function only returns <b>TRUE</b> if <i>pidl1</i> is the immediate parent of <i>pidl2</i>. Otherwise, the function returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilisparent
     * @since windows5.1.2600
     */
    static ILIsParent(pidl1, pidl2, fImmediate) {
        result := DllCall("SHELL32.dll\ILIsParent", "ptr", pidl1, "ptr", pidl2, "int", fImmediate, "int")
        return result
    }

    /**
     * Saves an ITEMIDLIST structure to a stream.
     * @param {IStream} pstm Type: <b>IStream *</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface where the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> is saved.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure to be saved.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or a COM error value otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilsavetostream
     * @since windows5.1.2600
     */
    static ILSaveToStream(pstm, pidl) {
        result := DllCall("SHELL32.dll\ILSaveToStream", "ptr", pstm, "ptr", pidl, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * This function may be altered or unavailable.
     * @param {IStream} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface from which the absolute 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> loads.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * When this method returns and succeeds, contains the resulting absolute 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a>. If it fails, contains 
     *       <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-illoadfromstreamex
     * @since windows6.0.6000
     */
    static ILLoadFromStreamEx(pstm) {
        result := DllCall("SHELL32.dll\ILLoadFromStreamEx", "ptr", pstm, "ptr*", &pidl := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pidl
    }

    /**
     * Returns the ITEMIDLIST structure associated with a specified file path.
     * @param {PSTR} pszPath Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a pointer to an <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that corresponds to the path.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilcreatefrompatha
     * @since windows5.1.2600
     */
    static ILCreateFromPathA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\ILCreateFromPathA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Returns the ITEMIDLIST structure associated with a specified file path.
     * @param {PWSTR} pszPath Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that contains the path. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a pointer to an <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that corresponds to the path.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilcreatefrompathw
     * @since windows5.1.2600
     */
    static ILCreateFromPathW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\ILCreateFromPathW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * SHILCreateFromPath may be altered or unavailable.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH containing the path to be converted.
     * @param {Pointer<Integer>} rgfInOut Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that, on entry, indicates any attributes of the folder named in <i>pszPath</i> that the calling application would like to retrieve along with the PIDL. On exit, this value contains those requested attributes. For a list of possible attribute flags for this parameter, see <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">IShellFolder::GetAttributesOf</a>.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * The path in <i>pszPath</i> expressed as a PIDL.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shilcreatefrompath
     * @since windows5.1.2600
     */
    static SHILCreateFromPath(pszPath, rgfInOut) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        rgfInOutMarshal := rgfInOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHELL32.dll\SHILCreateFromPath", "ptr", pszPath, "ptr*", &ppidl := 0, rgfInOutMarshal, rgfInOut, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppidl
    }

    /**
     * Appends or prepends an SHITEMID structure to an ITEMIDLIST structure.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PIDLIST_RELATIVE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure. When the function returns, the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure specified by <i>pmkid</i> is appended or prepended.
     * @param {Pointer<SHITEMID>} pmkid Type: <b>LPSHITEMID</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure to be appended or prepended to <i>pidl</i>.
     * @param {BOOL} fAppend Type: <b>BOOL</b>
     * 
     * Value that is set to <b>TRUE</b> to append <i>pmkid</i> to <i>pidl</i>. Set this value to <b>FALSE</b> to prepend <i>pmkid</i> to <i>pidl</i>.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_RELATIVE</b>
     * 
     * Returns the <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure specified by <i>pidl</i>, with <i>pmkid</i> appended or prepended. Returns <b>NULL</b> on failure.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-ilappendid
     * @since windows5.1.2600
     */
    static ILAppendID(pidl, pmkid, fAppend) {
        result := DllCall("SHELL32.dll\ILAppendID", "ptr", pidl, "ptr", pmkid, "int", fAppend, "ptr")
        return result
    }

    /**
     * Converts an item identifier list to a file system path. This function extends SHGetPathFromIDList by allowing you to set the initial size of the string buffer and declare the options below.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).
     * @param {PWSTR} pszPath Type: <b>PWSTR</b>
     * 
     * When this function is called it is passed a null-terminated, Unicode buffer to receive the file system path. This buffer is of size <i>cchPath</i>. 
     *                         
     *                         
     * 
     * When this function returns, contains the address of a null-terminated, Unicode buffer that contains the file system path. This buffer is of size <i>cchPath</i>.
     * @param {Integer} cchPath Type: <b>DWORD</b>
     * 
     * The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Integer} uOpts Type: <b>GPFIDL_FLAGS</b>
     * 
     * These flags determine the type of path returned.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetpathfromidlistex
     * @since windows6.0.6000
     */
    static SHGetPathFromIDListEx(pidl, pszPath, cchPath, uOpts) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetPathFromIDListEx", "ptr", pidl, "ptr", pszPath, "uint", cchPath, "uint", uOpts, "int")
        return result
    }

    /**
     * Converts an item identifier list to a file system path.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetpathfromidlista
     * @since windows5.1.2600
     */
    static SHGetPathFromIDListA(pidl, pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetPathFromIDListA", "ptr", pidl, "ptr", pszPath, "int")
        return result
    }

    /**
     * Converts an item identifier list to a file system path.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The address of an item identifier list that specifies a file or directory location relative to the root of the namespace (the desktop).
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * The address of a buffer to receive the file system path. This buffer must be at least MAX_PATH characters in size.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetpathfromidlistw
     * @since windows5.1.2600
     */
    static SHGetPathFromIDListW(pidl, pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetPathFromIDListW", "ptr", pidl, "ptr", pszPath, "int")
        return result
    }

    /**
     * Creates a new file system folder.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface is displayed.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that contains the fully qualified path of the directory. This string should have no more than MAX_PATH characters, including the terminating null character.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be returned, including those listed here. For values not specifically listed, see <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_PATHNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszPath</i> parameter was set to a relative path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path pointed to by <i>pszPath</i> is too long.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user canceled the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreatedirectory
     * @since windows5.1.2600
     */
    static SHCreateDirectory(hwnd, pszPath) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHCreateDirectory", "ptr", hwnd, "ptr", pszPath, "int")
        return result
    }

    /**
     * Creates a new file system folder, with optional security attributes.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface will be displayed.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string specifying the fully qualified path of the directory. This string is of maximum length of 248 characters, including the terminating null character.
     * @param {Pointer<SECURITY_ATTRIBUTES>} psa Type: <b>const <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>*</b>
     * 
     *  A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure with the directory's security attribute. Set this parameter to <b>NULL</b> if no security attributes need to be set.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be returned, including those listed here. For values not specifically listed, see <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_PATHNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszPath</i> parameter was set to a relative path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path pointed to by <i>pszPath</i> is too long.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system cannot find the path pointed to by <i>pszPath</i>. The path may contain an invalid entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user canceled the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreatedirectoryexa
     * @since windows5.0
     */
    static SHCreateDirectoryExA(hwnd, pszPath, psa) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHCreateDirectoryExA", "ptr", hwnd, "ptr", pszPath, "ptr", psa, "int")
        return result
    }

    /**
     * Creates a new file system folder, with optional security attributes.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to a parent window. This parameter can be set to <b>NULL</b> if no user interface will be displayed.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string specifying the fully qualified path of the directory. This string is of maximum length of 248 characters, including the terminating null character.
     * @param {Pointer<SECURITY_ATTRIBUTES>} psa Type: <b>const <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>*</b>
     * 
     *  A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure with the directory's security attribute. Set this parameter to <b>NULL</b> if no security attributes need to be set.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful. If the operation fails, other error codes can be returned, including those listed here. For values not specifically listed, see <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_PATHNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszPath</i> parameter was set to a relative path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILENAME_EXCED_RANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The path pointed to by <i>pszPath</i> is too long.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system cannot find the path pointed to by <i>pszPath</i>. The path may contain an invalid entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The directory exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user canceled the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreatedirectoryexw
     * @since windows5.0
     */
    static SHCreateDirectoryExW(hwnd, pszPath, psa) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHCreateDirectoryExW", "ptr", hwnd, "ptr", pszPath, "ptr", psa, "int")
        return result
    }

    /**
     * Opens a Windows Explorer window with specified items in a particular folder selected.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to a fully qualified item ID list that specifies the folder.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * A count of items in the selection array, <i>apidl</i>. If <i>cidl</i> is zero, then <i>pidlFolder</i> must point to a fully specified <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> describing a single item to select. This function opens the parent folder and selects that item.
     * @param {Pointer<Pointer<ITEMIDLIST>>} apidl Type: <b>PCUITEMID_CHILD_ARRAY</b>
     * 
     * A pointer to an array of PIDL structures, each of which is an item to select in the target folder referenced by <i>pidlFolder</i>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The optional flags. Under WindowsXP this parameter is ignored. In WindowsVista, the following flags are defined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shopenfolderandselectitems
     * @since windows5.1.2600
     */
    static SHOpenFolderAndSelectItems(pidlFolder, cidl, apidl, dwFlags) {
        apidlMarshal := apidl is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\SHOpenFolderAndSelectItems", "ptr", pidlFolder, "uint", cidl, apidlMarshal, apidl, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates an IShellItem object.
     * @param {Pointer<ITEMIDLIST>} pidlParent Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A PIDL to the parent. This value can be <b>NULL</b>.
     * @param {IShellFolder} psfParent Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to the parent <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>. This value can be <b>NULL</b>.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A PIDL to the requested item. If parent information is not included in <i>pidlParent</i> or <i>psfParent</i>, this must be an absolute PIDL.
     * @returns {IShellItem} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>**</b>
     * 
     * When this method returns, contains the interface pointer to the new <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreateshellitem
     * @since windows5.1.2600
     */
    static SHCreateShellItem(pidlParent, psfParent, pidl) {
        result := DllCall("SHELL32.dll\SHCreateShellItem", "ptr", pidlParent, "ptr", psfParent, "ptr", pidl, "ptr*", &ppsi := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IShellItem(ppsi)
    }

    /**
     * SHGetSpecialFolderLocation is not supported and may be altered or unavailable in the future. Instead, use SHGetFolderLocation.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder of interest.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * A PIDL specifying the folder's location relative to the root of the namespace (the desktop). It is the responsibility of the calling application to free the returned IDList by using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetspecialfolderlocation
     * @since windows5.0
     */
    static SHGetSpecialFolderLocation(csidl) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        result := DllCall("SHELL32.dll\SHGetSpecialFolderLocation", "ptr", hwnd, "int", csidl, "ptr*", &ppidl := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppidl
    }

    /**
     * SHCloneSpecialIDList may be altered or unavailable. Instead, use SHGetSpecialFolderLocation.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder of interest.
     * @param {BOOL} fCreate Type: <b>BOOL</b>
     * 
     * A value of type <b>BOOL</b> that indicates if the folder should be created if it does not already exist. If  <i>fCreate</i> is <b>TRUE</b>, the folder is created. If it is <b>FALSE</b>, the folder is not created.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a pointer to the <a href="/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure of a special folder specified by <i>csidl</i>. The function creates the folder if <i>fCreate</i> is <b>TRUE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shclonespecialidlist
     * @since windows5.1.2600
     */
    static SHCloneSpecialIDList(csidl, fCreate) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        result := DllCall("SHELL32.dll\SHCloneSpecialIDList", "ptr", hwnd, "int", csidl, "int", fCreate, "ptr")
        return result
    }

    /**
     * SHGetSpecialFolderPath is not supported. Instead, use ShGetFolderPath.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that receives the drive and path of the specified folder. This buffer must be at least MAX_PATH characters in size.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> that identifies the folder of interest. If a virtual folder is specified, this function will fail.
     * @param {BOOL} fCreate Type: <b>BOOL</b>
     * 
     * Indicates whether the folder should be created if it does not already exist. If this value is nonzero, the folder is created. If this value is zero, the folder is not created.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetspecialfolderpatha
     * @since windows5.0
     */
    static SHGetSpecialFolderPathA(pszPath, csidl, fCreate) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetSpecialFolderPathA", "ptr", hwnd, "ptr", pszPath, "int", csidl, "int", fCreate, "int")
        return result
    }

    /**
     * SHGetSpecialFolderPath is not supported. Instead, use ShGetFolderPath.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that receives the drive and path of the specified folder. This buffer must be at least MAX_PATH characters in size.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> that identifies the folder of interest. If a virtual folder is specified, this function will fail.
     * @param {BOOL} fCreate Type: <b>BOOL</b>
     * 
     * Indicates whether the folder should be created if it does not already exist. If this value is nonzero, the folder is created. If this value is zero, the folder is not created.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetspecialfolderpathw
     * @since windows5.0
     */
    static SHGetSpecialFolderPathW(pszPath, csidl, fCreate) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetSpecialFolderPathW", "ptr", hwnd, "ptr", pszPath, "int", csidl, "int", fCreate, "int")
        return result
    }

    /**
     * SHFlushSFCache may be altered or unavailable.
     * @remarks
     * 
     * <b>SHFlushSFCache</b> is called when the path to a special 
     *     folder is changed. This ensures that the updated path stored in the registry is used rather than the cached 
     *     value.
     * 
     * For more information on special folders, see the <i>Special Folders and CSIDLs</i> section 
     *     of <a href="https://docs.microsoft.com/windows/desktop/shell/folder-id">Getting a Folder's ID</a>.
     * 
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shflushsfcache
     * @since windows5.1.2600
     */
    static SHFlushSFCache() {
        DllCall("SHELL32.dll\SHFlushSFCache")
    }

    /**
     * Deprecated.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. 
     *     
     *                         
     * 
     * <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.
     * 
     * <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator. 
     *     
     *                         
     * 
     * The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-redirect">IKnownFolderManager::Redirect</a>, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.
     * 
     * The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.
     * 
     * For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users&#92;<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\\".
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetfolderpatha
     * @since windows5.0
     */
    static SHGetFolderPathA(csidl, hToken, dwFlags, pszPath) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFolderPathA", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deprecated.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder by combining the folder's <b>CSIDL</b> with <b>CSIDL_FLAG_CREATE</b>.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. 
     *     
     *                         
     * 
     * <b>Microsoft Windows 2000 and earlier:</b> Always set this parameter to <b>NULL</b>.
     * 
     * <b>Windows XP and later:</b> This parameter is usually set to <b>NULL</b>, but you might need to assign a non-<b>NULL</b> value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling process is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. The calling process must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This enables clients of <b>SHGetFolderPath</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as My Documents and Desktop. Any items added to the Default User folder also appear in any new user account.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify the path to be returned. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> (or <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a>) can be moved, renamed, redirected, or roamed across languages by a user or administrator. 
     *     
     *                         
     * 
     * The known folder system that underlies <b>SHGetFolderPath</b> allows users or administrators to redirect a known folder to a location that suits their needs. This is achieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-redirect">IKnownFolderManager::Redirect</a>, which sets the "current" value of the folder associated with the SHGFP_TYPE_CURRENT flag.
     * 
     * The default value of the folder, which is the location of the folder if a user or administrator had not redirected it elsewhere, is retrieved by specifying the SHGFP_TYPE_DEFAULT flag. This value can be used to implement a "restore defaults" feature for a known folder.
     * 
     * For example, the default value (SHGFP_TYPE_DEFAULT) for <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">FOLDERID_Music</a> (<a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_MYMUSIC</a>) is "C:\Users&#92;<b>user name</b>\Music". If the folder was redirected, the current value (SHGFP_TYPE_CURRENT) might be "D:\Music". If the folder has not been redirected, then SHGFP_TYPE_DEFAULT and SHGFP_TYPE_CURRENT retrieve the same path.
     * @param {PWSTR} pszPath Type: <b>LPWSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string of length MAX_PATH which will receive the path. If an error occurs or S_FALSE is returned, this string will be empty. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\\".
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetfolderpathw
     * @since windows5.0
     */
    static SHGetFolderPathW(csidl, hToken, dwFlags, pszPath) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFolderPathW", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deprecated. Retrieves the path of a folder as an ITEMIDLIST structure.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder to be located. The folders associated with the CSIDLs might not exist on a particular system.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. It is usually set to <b>NULL</b>, but it may be needed when there are multiple users for those folders that are treated as belonging to a single user. The most commonly used folder of this type is <b>My Documents</b>. The calling application is responsible for correct impersonation when <i>hToken</i> is non-<b>NULL</b>. It must have appropriate security privileges for the particular user, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     *     
     *     					
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetFolderLocation</b> to find folder locations (such as the Desktop folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>My Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * The address of a pointer to an item identifier list structure that specifies the folder's location relative to the root of the namespace (the desktop). The <i>ppidl</i> parameter is set to <b>NULL</b> on failure. The calling application is responsible for freeing this resource by calling <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetfolderlocation
     * @since windows5.0
     */
    static SHGetFolderLocation(csidl, hToken, dwFlags) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken

        result := DllCall("SHELL32.dll\SHGetFolderLocation", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr*", &ppidl := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppidl
    }

    /**
     * Deprecated. Assigns a new path to a system folder identified by its CSIDL.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.
     * 
     * Add the <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Must be set to 0.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns standard <b>HRESULT</b> codes, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The folder's path was successfully updated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Several error conditions cause the return of this value, including the following:
     * 
     * <ul>
     * <li>The <i>csidl</i> value is not valid.</li>
     * <li>The <i>csidl</i> value does not refer to a virtual folder.</li>
     * <li>The <i>csidl</i> value does not refer to a system folder.</li>
     * <li>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</li>
     * <li>The <i>dwFlags</i> value is not 0 (zero).</li>
     * <li>The <i>pszPath</i> value is <b>NULL</b>.</li>
     * <li>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</li>
     * </ul>
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shsetfolderpatha
     * @since windows5.1.2600
     */
    static SHSetFolderPathA(csidl, hToken, dwFlags, pszPath) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHSetFolderPathA", "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deprecated. Assigns a new path to a system folder identified by its CSIDL.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be set. Only physical folders are valid. If a virtual folder is specified, this function fails.
     * 
     * Add the <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> value to the CSIDL to ensure that the string is written to the registry exactly as provided. If the <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_FLAG_DONT_UNEXPAND</a> flag is not included, portions of the path may be replaced by environment strings, such as %USERPROFILE%.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that can be used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Must be set to 0.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the folder's new path. This value cannot be <b>NULL</b>, and the string cannot be of zero length.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns standard <b>HRESULT</b> codes, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The folder's path was successfully updated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Several error conditions cause the return of this value, including the following:
     * 
     * <ul>
     * <li>The <i>csidl</i> value is not valid.</li>
     * <li>The <i>csidl</i> value does not refer to a virtual folder.</li>
     * <li>The <i>csidl</i> value does not refer to a system folder.</li>
     * <li>The <i>csidl</i> value refers to a folder that cannot be renamed or moved.</li>
     * <li>The <i>dwFlags</i> value is not 0 (zero).</li>
     * <li>The <i>pszPath</i> value is <b>NULL</b>.</li>
     * <li>The string pointed to by <i>pszPath</i> value is an empty string ("") of length zero.</li>
     * </ul>
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shsetfolderpathw
     * @since windows5.1.2600
     */
    static SHSetFolderPathW(csidl, hToken, dwFlags, pszPath) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHSetFolderPathW", "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Gets the path of a folder and appends a user-provided subfolder path.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com/windows/desktop/shell/manage">My Documents</a>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.
     * @param {PSTR} pszSubDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetfolderpathandsubdira
     * @since windows5.1.2600
     */
    static SHGetFolderPathAndSubDirA(csidl, hToken, dwFlags, pszSubDir, pszPath) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        pszSubDir := pszSubDir is String ? StrPtr(pszSubDir) : pszSubDir
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFolderPathAndSubDirA", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszSubDir, "ptr", pszPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Gets the path of a folder and appends a user-provided subfolder path.
     * @param {Integer} csidl Type: <b>int</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value that identifies the folder whose path is to be retrieved. Only real folders are valid. If a virtual folder is specified, this function fails. You can force creation of a folder with <b>SHGetFolderPathAndSubDir</b> by combining the folder's <b>CSIDL</b> with CSIDL_FLAG_CREATE.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. For systems earlier than Windows2000, set this value to <b>NULL</b>. For later systems, <i>hToken</i> is usually, but not always, set to <b>NULL</b>. You might need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <a href="https://docs.microsoft.com/windows/desktop/shell/manage">My Documents</a>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Specifies whether the path to be returned is the actual path of the folder or the default path. This value is used in cases where the folder associated with a <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL</a> value may be moved or renamed by the user.
     * @param {PWSTR} pszSubDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to the subpath to be appended to the folder's path. This is a <b>null</b>-terminated string of length MAX_PATH. If you are not creating a new directory, this must be an existing subdirectory or the function returns an error. This value can be <b>NULL</b> if no subpath is to be appended.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * When this function returns, this value points to the directory path and appended subpath. This is a <b>null</b>-terminated string of length MAX_PATH. This string is empty when the function returns an error code.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetfolderpathandsubdirw
     * @since windows5.1.2600
     */
    static SHGetFolderPathAndSubDirW(csidl, hToken, dwFlags, pszSubDir, pszPath) {
        static hwnd := 0 ;Reserved parameters must always be NULL

        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        pszSubDir := pszSubDir is String ? StrPtr(pszSubDir) : pszSubDir
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFolderPathAndSubDirW", "ptr", hwnd, "int", csidl, "ptr", hToken, "uint", dwFlags, "ptr", pszSubDir, "ptr", pszPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the path of a known folder as an ITEMIDLIST structure.
     * @param {Pointer<Guid>} rfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A reference to the <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that identifies the folder. The folders associated with the known folder IDs might not exist on a particular system.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify special retrieval options. This value can be 0; otherwise, it is one or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a> values.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetKnownFolderIDList</b> to find folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * When this method returns, contains a pointer to the PIDL of the folder. This parameter is passed uninitialized. The caller is responsible for freeing the returned PIDL when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ilfree">ILFree</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetknownfolderidlist
     * @since windows6.0.6000
     */
    static SHGetKnownFolderIDList(rfid, dwFlags, hToken) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken

        result := DllCall("SHELL32.dll\SHGetKnownFolderIDList", "ptr", rfid, "uint", dwFlags, "ptr", hToken, "ptr*", &ppidl := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppidl
    }

    /**
     * Redirects a known folder to a new location.
     * @param {Pointer<Guid>} rfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A <b>GUID</b> that identifies the known folder.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Either 0 or the following value.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 			
     *             		
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-null. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHSetKnownFolderPath</b> to set folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to the folder's new path. This is a null-terminated Unicode string of length MAX_PATH. This path cannot be of zero length.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise, including the following:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Among other things, this value can indicate that the <i>rfid</i> parameter references a <a href="/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that is not present on the system. Not all <b>KNOWNFOLDERID</b> values are present on all systems. Use <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iknownfoldermanager-getfolderids">IKnownFolderManager::GetFolderIds</a> to retrieve the set of <b>KNOWNFOLDERID</b> values for the current system.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shsetknownfolderpath
     * @since windows6.0.6000
     */
    static SHSetKnownFolderPath(rfid, dwFlags, hToken, pszPath) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHSetKnownFolderPath", "ptr", rfid, "uint", dwFlags, "ptr", hToken, "ptr", pszPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the full path of a known folder identified by the folder's KNOWNFOLDERID.
     * @param {Pointer<Guid>} rfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A reference to the <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a> that identifies the folder.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify special retrieval options. This value can be 0; otherwise, one or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a> values.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> that represents a particular user. If this parameter is <b>NULL</b>, which is the most common usage, the function requests the known folder for the current user. 
     *     
     *                         
     * 
     * Request a specific user's folder by passing the <i>hToken</i> of that user. This is typically done in the context of a service that has sufficient privileges to retrieve the token of a given user. That token must be opened with <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_QUERY</a> and <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_IMPERSONATE</a> rights. In some cases, you also need to include <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-rights-for-access-token-objects">TOKEN_DUPLICATE</a>. In addition to passing the user's <i>hToken</i>, the registry hive of that specific user must be mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <b>SHGetKnownFolderPath</b> to find folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.
     * @returns {PWSTR} Type: <b>PWSTR*</b>
     * 
     * When this method returns, contains the address of a pointer to a null-terminated Unicode string that specifies the path of the known folder. The calling process is responsible for freeing this resource once it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>, whether <b>SHGetKnownFolderPath</b> succeeds or not. The returned path does not include a trailing backslash. For example, "C:\Users" is returned rather than "C:\Users\\".
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetknownfolderpath
     * @since windows6.0.6000
     */
    static SHGetKnownFolderPath(rfid, dwFlags, hToken) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken

        result := DllCall("SHELL32.dll\SHGetKnownFolderPath", "ptr", rfid, "uint", dwFlags, "ptr", hToken, "ptr*", &ppszPath := 0, "int")
        if(result != 0) {
            Com.CoTaskMemFree(ppszPath)
            throw OSError(A_LastError || result)
        }

        return ppszPath
    }

    /**
     * Retrieves an IShellItem object that represents a known folder.
     * @param {Pointer<Guid>} rfid Type: <b>REFKNOWNFOLDERID</b>
     * 
     * A reference to the <a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">KNOWNFOLDERID</a>, a <b>GUID</b> that identifies the folder that contains the item.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a></b>
     * 
     * Flags that specify special options used in the retrieval of the known folder <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitem">IShellItem</a>. This value can be <b>KF_FLAG_DEFAULT</b>; otherwise, one or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-known_folder_flag">KNOWN_FOLDER_FLAG</a> values.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-tokens">access token</a> used to represent a particular user. This parameter is usually set to <b>NULL</b>, in which case the function tries to access the current user's instance of the folder. However, you may need to assign a value to <i>hToken</i> for those folders that can have multiple users but are treated as belonging to a single user. The most commonly used folder of this type is <b>Documents</b>.
     * 
     * 
     * 
     * The calling application is responsible for correct impersonation when <i>hToken</i> is non-<b>null</b>. It must have appropriate security privileges for the particular user, including TOKEN_QUERY and TOKEN_IMPERSONATE, and the user's registry hive must be currently mounted. See <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> for further discussion of access control issues.
     * 
     * Assigning the <i>hToken</i> parameter a value of -1 indicates the Default User. This allows clients of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shsetknownfolderpath">SHSetKnownFolderPath</a> to set folder locations (such as the <b>Desktop</b> folder) for the Default User. The Default User user profile is duplicated when any new user account is created, and includes special folders such as <b>Documents</b> and <b>Desktop</b>. Any items added to the Default User folder also appear in any new user account. Note that access to the Default User folders requires administrator privileges.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface that represents the item, usually IID_IShellItem or IID_IShellItem2.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetknownfolderitem
     * @since windows6.1
     */
    static SHGetKnownFolderItem(rfid, flags, hToken, riid) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken

        result := DllCall("SHELL32.dll\SHGetKnownFolderItem", "ptr", rfid, "int", flags, "ptr", hToken, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * SHGetSetFolderCustomSettings may be altered or unavailable.
     * @param {Pointer<SHFOLDERCUSTOMSETTINGS>} pfcs Type: <b>LPSHFOLDERCUSTOMSETTINGS</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shfoldercustomsettings">SHFOLDERCUSTOMSETTINGS</a> structure that provides or receives the custom folder settings.
     * @param {PWSTR} pszPath Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that contains the path to the folder. The length of  <b>pszPath</b> must be MAX_PATH or less, including the terminating null character.
     * @param {Integer} dwReadWrite Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetsetfoldercustomsettings
     * @since windows5.1.2600
     */
    static SHGetSetFolderCustomSettings(pfcs, pszPath, dwReadWrite) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetSetFolderCustomSettings", "ptr", pfcs, "ptr", pszPath, "uint", dwReadWrite, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Displays a dialog box that enables the user to select a Shell folder.
     * @param {Pointer<BROWSEINFOA>} lpbi Type: <b>LPBROWSEINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure that contains information used to display the dialog box.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.
     *     
     *     					
     * 
     * It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shbrowseforfoldera
     * @since windows5.1.2600
     */
    static SHBrowseForFolderA(lpbi) {
        result := DllCall("SHELL32.dll\SHBrowseForFolderA", "ptr", lpbi, "ptr")
        return result
    }

    /**
     * Displays a dialog box that enables the user to select a Shell folder.
     * @param {Pointer<BROWSEINFOW>} lpbi Type: <b>LPBROWSEINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-browseinfoa">BROWSEINFO</a> structure that contains information used to display the dialog box.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_ABSOLUTE</b>
     * 
     * Returns a PIDL that specifies the location of the selected folder relative to the root of the namespace. If the user chooses the <b>Cancel</b> button in the dialog box, the return value is <b>NULL</b>.
     *     
     *     					
     * 
     * It is possible that the PIDL returned is that of a folder shortcut rather than a folder. For a full discussion of this case, see the Remarks section.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shbrowseforfolderw
     * @since windows5.1.2600
     */
    static SHBrowseForFolderW(lpbi) {
        result := DllCall("SHELL32.dll\SHBrowseForFolderW", "ptr", lpbi, "ptr")
        return result
    }

    /**
     * Creates an instance of the specified object class from within the context of the Shell's process. WindowsVista and later:\_This function has been disabled and returns E_NOTIMPL.
     * @param {Pointer<Guid>} rclsid Type: <b>REFCLSID</b>
     * 
     * The CLSID of the object class to be created.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or an error value otherwise. In WindowsVista and later versions, always returns E_NOTIMPL.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shloadinproc
     * @since windows5.1.2600
     */
    static SHLoadInProc(rclsid) {
        result := DllCall("SHELL32.dll\SHLoadInProc", "ptr", rclsid, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the IShellFolder interface for the desktop folder, which is the root of the Shell's namespace.
     * @returns {IShellFolder} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>**</b>
     * 
     * When this method returns, receives an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface pointer for the desktop folder. The calling application is responsible for eventually freeing the interface by calling its <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> method.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetdesktopfolder
     * @since windows5.1.2600
     */
    static SHGetDesktopFolder() {
        result := DllCall("SHELL32.dll\SHGetDesktopFolder", "ptr*", &ppshf := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IShellFolder(ppshf)
    }

    /**
     * Notifies the system of an event that an application has performed. An application should use this function if it performs an action that may affect the Shell.
     * @remarks
     * 
     * Applications that register new handlers of any type must call <b>SHChangeNotify</b> with the <b>SHCNE_ASSOCCHANGED</b> flag to instruct the Shell to invalidate the icon and thumbnail cache. This will also load new icon and thumbnail handlers that have been registered. Note, however, that icon overlay handlers are not reloaded.
     * 
     * The strings pointed to by <i>dwItem1</i> and <i>dwItem2</i> can be either ANSI or Unicode.
     * 
     * @param {Integer} wEventId Type: <b>LONG</b>
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @param {Pointer<Void>} dwItem1 Type: <b>LPCVOID</b>
     * 
     * Optional. First event-dependent value.
     * @param {Pointer<Void>} dwItem2 Type: <b>LPCVOID</b>
     * 
     * Optional. Second event-dependent value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shchangenotify
     * @since windows5.1.2600
     */
    static SHChangeNotify(wEventId, uFlags, dwItem1, dwItem2) {
        dwItem1Marshal := dwItem1 is VarRef ? "ptr" : "ptr"
        dwItem2Marshal := dwItem2 is VarRef ? "ptr" : "ptr"

        DllCall("SHELL32.dll\SHChangeNotify", "int", wEventId, "uint", uFlags, dwItem1Marshal, dwItem1, dwItem2Marshal, dwItem2)
    }

    /**
     * Notifies the system that an item has been accessed, for the purposes of tracking those items used most recently and most frequently. This function can also be used to clear all usage data.
     * @remarks
     * 
     * The usage statistics gathered through calls to this method are used to determine lists of items accessed most recently and most frequently. These lists are seen in the <b>Start</b> menu and, in Windows7 and later, in an application's Jump List.
     * 
     * When this method is called, it affects the following areas:
     *             
     *                 
     * 
     * <ul>
     * <li>Updates the <b>Recent</b> and <b>Frequent</b> lists for the associated application's Jump List.</li>
     * <li>Adds a shortcut to the user's <a href="https://docs.microsoft.com/windows/desktop/shell/manage">Recent</a> folder (<a href="https://docs.microsoft.com/windows/desktop/shell/knownfolderid">FOLDERID_Recent</a>, <a href="https://docs.microsoft.com/windows/desktop/shell/csidl">CSIDL_RECENT</a>). This is reflected in the <b>My Recent Documents</b> (WindowsXP) and <b>Recent Items</b> (WindowsVista and later) menu in the <b>Start</b> menu.</li>
     * <li>Adds a shortcut to the Classic <b>Start</b> menu's <b>Documents</b> submenu. (Note that the Classic <b>Start</b> menu option is not available in Windows7 and later.)</li>
     * </ul>
     * Items represented by an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishelllinka">IShellLink</a> are not added to the <b>Recent</b> folder, although they are reflected in an application's Jump List.
     * 
     * In some cases, notably when a user opens an item through Windows Explorer or uses the common file dialog to open, save, or create a file, the Shell calls <b>SHAddToRecentDocs</b> on behalf of the application. An application that has a custom UI for selecting items should call <b>SHAddToRecentDocs</b> explicitly to ensure accurate statistics. Duplicate calls are accounted for by the system so there is no risk of skewing the data by doing so.
     * 
     * Executable (.exe) files are filtered from the recently used documents list in WindowsXP and later versions. Although <b>SHAddToRecentDocs</b> will accept the path of an executable file, that file will not appear in the <b>Recent Items</b> list.
     * 
     * Folders are also accepted by <b>SHAddToRecentDocs</b>, but appear only in the Jump List for the Windows Explorer taskbar button. Folders do not appear in any other application's Jump List.
     * 
     * In certain cases, <b>SHAddToRecentDocs</b> attempts to register an application to handle a file type that it is not registered to handle. This occurs under these circumstances:
     * 
     * <ul>
     * <li>An application explicitly calls <b>SHAddToRecentDocs</b> with a file type that it is not registered to handle. This also applies to calls made to <b>SHAddToRecentDocs</b> by the common file dialog on behalf of the application, but only when the dialog is used to open a file, not when it is used to save one.</li>
     * <li>The user drops a file of a type that the application is not registered to handle on the application's taskbar button.</li>
     * </ul>
     * This registration is done per-user.
     * 
     * A set of requirements must be met for the registration to be accomplished successfully:
     * 
     * <ul>
     * <li>The application must be registered under <b>HKEY_CLASSES_ROOT</b>&#92;<b>Applications</b>.</li>
     * <li>That registration cannot include the NoOpenWith value. See <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-types">File Types</a> for more details on NoOpenWith.</li>
     * <li>That registration cannot supply data under a <b>SupportedTypes</b> subkey. See <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-types">File Types</a> for more details on the <b>SupportedTypes</b> subkey.</li>
     * <li>
     * The application's executable file cannot be listed in the KillList value found here:
     * 
     * 
     * <pre xml:space="preserve"><b>HKEY_LOCAL_MACHINE</b>
     * <b>Software</b>
     * <b>Microsoft</b>
     * <b>Windows</b>
     * <b>CurrentVersion</b>
     * <b>Explorer</b>
     * <b>FileAssociation</b>
     * <b>KillList</b></pre>
     * 
     * 
     * <div class="alert"><b>Note</b>Third party applications should not modify the KillList value. It should be regarded as read-only.</div>
     * <div></div>
     * </li>
     * <li>
     * The application's <b>HKEY_CLASSES_ROOT</b>&#92;<b>Applications</b> registration must have a set of default verbs defined under a 
     *                         
     *                             
     *                             <b>HKEY_CLASSES_ROOT</b>&#92;<b>Applications</b>&#92;<i>ExampleApp.exe</i>&#92;<b>shell</b> subkey.
     *                         
     * 
     * If <b>SHAddToRecentDocs</b> is attempting the registration as the result of a drag-and-drop onto the taskbar button, the <b>shell</b> subkey is created if it does not already exist, as long as the existing application registration does not contain a NoOpenWith value and the application's executable is not listed in the KillList value.
     * 
     * </li>
     * </ul>
     * <h3><a id="Suppressing_Calls_to_SHAddToRecentDocs"></a><a id="suppressing_calls_to_shaddtorecentdocs"></a><a id="SUPPRESSING_CALLS_TO_SHADDTORECENTDOCS"></a>Suppressing Calls to SHAddToRecentDocs</h3>
     * In versions of Windows before Windows7, a file type could set the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-filetypeattributeflags">FTA_NoRecentDocs</a> flag to prevent that file type from being added to the <b>Recent</b> folder. This mechanism is also supported under Windows7 and later. See <a href="https://docs.microsoft.com/windows/desktop/shell/fa-file-types">File Types</a> for more information.
     * 
     * <b>SHAddToRecentDocs</b> tracks document usage statistics through the verbs that are invoked to access those documents. Verbs supplied by registered <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> handlers are tracked, those items appear in <b>My Recent Documents</b> (WindowsXP) and <b>Recent Items</b> (WindowsVista). In Windows7, the parent folders of the documents appear in the Jump List for the Windows Explorer taskbar button. However, the documents accessed through those <b>IContextMenu</b> verbs do not appear in application Jump Lists. For those items to appear in an application's Jump List, an application must call <b>SHAddToRecentDocs</b> explicitly.
     * 
     * Prior to Windows7, only the <c>open</c> verb resulted in a call to <b>SHAddToRecentDocs</b>. In Windows7 and later, other verbs can also generate usage statistics. This information is used to make a Jump List's destinations more complete and accurate.
     * 
     * However, some classes of file type association registrations or individual <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> implementations are not appropriate for this sort of tracking. The point of usage tracking is to generate a list of items that the user is likely to want to access again. If a particular verb<c>delete</c>, for instanceis inherently invoked on an item that the user will not access again, or is a secondary action such as a virus scan on a file, that verb is not appropriate for tracking. File type classes should remove themselves from this tracking through the registry entry NoRecentDocs. NoRecentDocs is of type REG_SZ and has no associated data. Its presence is all that is required to prevent the call to <b>SHAddToRecentDocs</b>.
     * 
     * For example, context menu extensions and static verbs registered under <b>HKEY_CLASSES_ROOT</b> in classes such as "*", "AllFileSystemObjects", or "Folder" should not be tracked. In cases such as these, the NoRecentDocs entry is added to the root of the class key as shown here to suppress tracking of documents launched through any verb or extension registered to that class:
     * 
     * 
     * <pre xml:space="preserve"><b>HKEY_CLASSES_ROOT</b>
     * <b>AllFileSystemObjects</b>
     * <b>NoRecentDocs</b></pre>
     * 
     * 
     * The NoRecentDocs entry is assigned by default to the <b>*</b>, <b>AllFileSystemObjects</b>, <b>Folder</b>, <b>Directory</b>, and <b>DesktopBackground</b> class subkeys.
     * 
     * Individual <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> implementations can opt out of tracking by adding a NoRecentDocs subkey to its Component Object Model (COM) object's registration, in its <b>shellex</b> subkey, as shown here:
     * 
     * 
     * <pre xml:space="preserve"><b>HKEY_CLASSES_ROOT</b>
     * <b>CLSID</b>
     * <i>{093C7AAB-5E72-454f-A91D-CA1BC991FCEC}</i>
     * <b>shellex</b>
     * <b>NoRecentDocs</b></pre>
     * 
     * 
     * This subkey is not present by default on any <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> implementation.
     * 
     * 
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * A value from the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-shard">SHARD</a> enumeration that indicates the form of the information pointed to by the <i>pv</i> parameter.
     * @param {Pointer<Void>} pv Type: <b>LPCVOID</b>
     * 
     * A pointer to data that identifies the item that has been accessed. The item can be specified in this parameter in one of the following forms:
     *     
     *                         
     * 
     * 
     * <ul>
     * <li>A null-terminated string that contains the path and file name of the item.</li>
     * <li>A PIDL that identifies the item's file object.</li>
     * <li><b>Windows7 and later only</b>. A <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shardappidinfo">SHARDAPPIDINFO</a>, <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shardappidinfoidlist">SHARDAPPIDINFOIDLIST</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shardappidinfolink">SHARDAPPIDINFOLINK</a> structure that identifies the item through an AppUserModelID. See <a href="https://docs.microsoft.com/windows/desktop/shell/appids">Application User Model IDs (AppUserModelIDs)</a> for more information.</li>
     * <li><b>Windows7 and later only</b>. An <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishelllinka">IShellLink</a> object that identifies the item through a shortcut.</li>
     * </ul>
     * 
     * 
     * Set this parameter to <b>NULL</b> to clear all usage data on all items.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shaddtorecentdocs
     * @since windows5.1.2600
     */
    static SHAddToRecentDocs(uFlags, pv) {
        pvMarshal := pv is VarRef ? "ptr" : "ptr"

        DllCall("SHELL32.dll\SHAddToRecentDocs", "uint", uFlags, pvMarshal, pv)
    }

    /**
     * SHHandleUpdateImage may be altered or unavailable.
     * @param {Pointer<ITEMIDLIST>} pidlExtra Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The index in the system image list that has changed, specified in the <i>pidl2</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-ishellchangenotify-onchange">IShellChangeNotify::OnChange</a>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns -1 on failure or the index of the changed image list entry on success.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shhandleupdateimage
     * @since windows5.1.2600
     */
    static SHHandleUpdateImage(pidlExtra) {
        result := DllCall("SHELL32.dll\SHHandleUpdateImage", "ptr", pidlExtra, "int")
        return result
    }

    /**
     * Notifies the Shell that an image in the system image list has changed.
     * @remarks
     * 
     * If you do not know the index in the system image list of the icon that you want to update, use <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shgetfileinfoa">SHGetFileInfo</a> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.
     * 
     * You must use <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * 
     * @param {PSTR} pszHashItem Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>.
     * @param {Integer} iIndex Type: <b>int</b>
     * 
     * An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.
     * @param {Integer} iImageIndex Type: <b>int</b>
     * 
     * An integer that specifies the index in the system image list of the icon that is being updated.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shupdateimagea
     * @since windows5.0
     */
    static SHUpdateImageA(pszHashItem, iIndex, uFlags, iImageIndex) {
        pszHashItem := pszHashItem is String ? StrPtr(pszHashItem) : pszHashItem

        DllCall("SHELL32.dll\SHUpdateImageA", "ptr", pszHashItem, "int", iIndex, "uint", uFlags, "int", iImageIndex)
    }

    /**
     * Notifies the Shell that an image in the system image list has changed.
     * @remarks
     * 
     * If you do not know the index in the system image list of the icon that you want to update, use <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shgetfileinfoa">SHGetFileInfo</a> with the <i>uFlags</i> parameter set to <b>SHGFI_SYSICONINDEX</b>.
     * 
     * You must use <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a> with the parameters of the old icon that needs to be updated, not those of the new icon you want to replace it with.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The shlobj_core.h header defines SHUpdateImage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * 
     * @param {PWSTR} pszHashItem Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string value that specifies the fully qualified path of the file that contains the icon. Use the path that is returned in the buffer pointed to by the <i>szIconFile</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>.
     * @param {Integer} iIndex Type: <b>int</b>
     * 
     * An integer that specifies the zero-based index of the icon in the file specified by <i>pszHashItem</i>. Use the value that is pointed to by the <i>piIndex</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * An unsigned integer that specifies the flags that determine the icon attributes. Set <i>uFlags</i> to the value that is pointed to by the <i>pwFlags</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-iextracticona-geticonlocation">IExtractIcon::GetIconLocation</a>. The flags that are relevant to <b>SHUpdateImage</b> are <b>GIL_NOTFILENAME</b> and <b>GIL_SIMULATEDOC</b>.
     * @param {Integer} iImageIndex Type: <b>int</b>
     * 
     * An integer that specifies the index in the system image list of the icon that is being updated.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shupdateimagew
     * @since windows5.0
     */
    static SHUpdateImageW(pszHashItem, iIndex, uFlags, iImageIndex) {
        pszHashItem := pszHashItem is String ? StrPtr(pszHashItem) : pszHashItem

        DllCall("SHELL32.dll\SHUpdateImageW", "ptr", pszHashItem, "int", iIndex, "uint", uFlags, "int", iImageIndex)
    }

    /**
     * Registers a window to receive notifications from the file system or Shell, if the file system supports notifications.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window that receives the change or notification messages.
     * @param {Integer} fSources Type: <b>int</b>
     * @param {Integer} fEvents Type: <b>LONG</b>
     * 
     * Change notification events for which to receive notification. See the SHCNE flags listed in <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotify">SHChangeNotify</a> for possible values.
     * @param {Integer} wMsg Type: <b>UINT</b>
     * 
     * Message to be posted to the window procedure.
     * @param {Integer} cEntries Type: <b>int</b>
     * 
     * Number of entries in the <i>pshcne</i> array.
     * @param {Pointer<SHChangeNotifyEntry>} pshcne Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shchangenotifyentry">SHChangeNotifyEntry</a>*</b>
     * 
     * Array of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shchangenotifyentry">SHChangeNotifyEntry</a> structures that contain the notifications. This array should always be set to one when calling <b>SHChangeNotifyRegister</b> or <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotifyderegister">SHChangeNotifyDeregister</a> will not work properly.
     * @returns {Integer} Type: <b>ULONG</b>
     * 
     * Returns a positive integer registration ID. Returns 0 if out of memory or in response to invalid parameters.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shchangenotifyregister
     * @since windows5.0
     */
    static SHChangeNotifyRegister(hwnd, fSources, fEvents, wMsg, cEntries, pshcne) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd

        result := DllCall("SHELL32.dll\SHChangeNotifyRegister", "ptr", hwnd, "int", fSources, "int", fEvents, "uint", wMsg, "int", cEntries, "ptr", pshcne, "uint")
        return result
    }

    /**
     * Unregisters the client's window process from receiving SHChangeNotify messages.
     * @param {Integer} ulID Type: <b>ULONG</b>
     * 
     * A value of type <b>ULONG</b> that specifies the registration ID returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotifyregister">SHChangeNotifyRegister</a>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the specified client was found and removed; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shchangenotifyderegister
     * @since windows5.1.2600
     */
    static SHChangeNotifyDeregister(ulID) {
        result := DllCall("SHELL32.dll\SHChangeNotifyDeregister", "uint", ulID, "int")
        return result
    }

    /**
     * Locks the shared memory associated with a Shell change notification event.
     * @param {HANDLE} hChange Type: <b>HANDLE</b>
     * 
     * A handle to a window received as a <i>wParam</i> in the specified Shell change notification message.
     * @param {Integer} dwProcId Type: <b>DWORD</b>
     * 
     * The process ID (<i>lParam</i> in the message callback).
     * @param {Pointer<Pointer<Pointer<ITEMIDLIST>>>} pppidl Type: <b>PIDLIST_ABSOLUTE**</b>
     * 
     * The address of a pointer to a PIDLIST_ABSOLUTE that, when this function returns successfully, receives the list of affected PIDLs.
     * @param {Pointer<Integer>} plEvent Type: <b>LONG*</b>
     * 
     * A pointer to a LONG value that, when this function returns successfully, receives the Shell change notification ID of the event that took place.
     * @returns {HANDLE} Type: <b>HANDLE</b>
     * 
     * Returns a handle (HLOCK) to the locked memory. Pass this value to <a href="/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotification_unlock">SHChangeNotification_Unlock</a> when finished.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shchangenotification_lock
     * @since windows5.0
     */
    static SHChangeNotification_Lock(hChange, dwProcId, pppidl, plEvent) {
        hChange := hChange is Win32Handle ? NumGet(hChange, "ptr") : hChange

        pppidlMarshal := pppidl is VarRef ? "ptr*" : "ptr"
        plEventMarshal := plEvent is VarRef ? "int*" : "ptr"

        result := DllCall("SHELL32.dll\SHChangeNotification_Lock", "ptr", hChange, "uint", dwProcId, pppidlMarshal, pppidl, plEventMarshal, plEvent, "ptr")
        resultHandle := HANDLE({Value: result}, True)
        resultHandle.DefineProp("Free", {Call: Shell.SHChangeNotification_Unlock})
        return resultHandle
    }

    /**
     * Unlocks shared memory for a change notification.
     * @param {HANDLE} hLock Type: <b>HANDLE</b>
     * 
     * A handle to the memory lock. This is the handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shchangenotification_lock">SHChangeNotification_Lock</a> when it locked the memory.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> on success; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shchangenotification_unlock
     * @since windows5.0
     */
    static SHChangeNotification_Unlock(hLock) {
        hLock := hLock is Win32Handle ? NumGet(hLock, "ptr") : hLock

        result := DllCall("SHELL32.dll\SHChangeNotification_Unlock", "ptr", hLock, "int")
        return result
    }

    /**
     * SHGetRealIDL may be altered or unavailable.
     * @param {IShellFolder} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to an instance of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> whose simple PIDL is to be converted.
     * @param {Pointer<ITEMIDLIST>} pidlSimple Type: <b>PCUITEMID_CHILD</b>
     * 
     * The simple PIDL to be converted.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PITEMID_CHILD*</b>
     * 
     * When this method returns, contains a pointer to the full converted PIDL. If the function fails, this parameter is set to <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetrealidl
     * @since windows5.1.2600
     */
    static SHGetRealIDL(psf, pidlSimple) {
        result := DllCall("SHELL32.dll\SHGetRealIDL", "ptr", psf, "ptr", pidlSimple, "ptr*", &ppidlReal := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppidlReal
    }

    /**
     * Retrieves an interface that allows hosted Shell extensions and other components to prevent their host process from closing prematurely.
     * @returns {IUnknown} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>**</b>
     * 
     * When this function returns successfully, contains the address of the host process' <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface pointer. This is a free-threaded interface used to prevent the host process from terminating. If the function call fails, this value is set to <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetinstanceexplorer
     * @since windows5.1.2600
     */
    static SHGetInstanceExplorer() {
        result := DllCall("SHELL32.dll\SHGetInstanceExplorer", "ptr*", &ppunk := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IUnknown(ppunk)
    }

    /**
     * Retrieves extended property data from a relative identifier list.
     * @param {IShellFolder} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * The address of the parent <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface. This must be the immediate parent of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure referenced by the <i>pidl</i> parameter.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that identifies the object relative to the folder specified in <i>psf</i>.
     * @param {Integer} nFormat Type: <b>int</b>
     * @param {Pointer} pv Type: <b>void*</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.
     * 
     * If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.
     * @param {Integer} cb Type: <b>int</b>
     * 
     * Size of the buffer at <i>pv</i>, in bytes.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or E_INVALIDARG otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetdatafromidlista
     * @since windows5.1.2600
     */
    static SHGetDataFromIDListA(psf, pidl, nFormat, pv, cb) {
        result := DllCall("SHELL32.dll\SHGetDataFromIDListA", "ptr", psf, "ptr", pidl, "int", nFormat, "ptr", pv, "int", cb, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves extended property data from a relative identifier list.
     * @param {IShellFolder} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * The address of the parent <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface. This must be the immediate parent of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure referenced by the <i>pidl</i> parameter.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure that identifies the object relative to the folder specified in <i>psf</i>.
     * @param {Integer} nFormat Type: <b>int</b>
     * @param {Pointer} pv Type: <b>void*</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the requested data. The format of this buffer is determined by <i>nFormat</i>.
     * 
     * If <i>nFormat</i> is <b>SHGDFIL_NETRESOURCE</b>, there are two possible cases. If the buffer is large enough, the net resource's string information (fields for the network name, local name, provider, and comments) will be placed into the buffer. If the buffer is not large enough, only the net resource structure will be placed into the buffer and the string information pointers will be <b>NULL</b>.
     * @param {Integer} cb Type: <b>int</b>
     * 
     * Size of the buffer at <i>pv</i>, in bytes.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful, or E_INVALIDARG otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetdatafromidlistw
     * @since windows5.1.2600
     */
    static SHGetDataFromIDListW(psf, pidl, nFormat, pv, cb) {
        result := DllCall("SHELL32.dll\SHGetDataFromIDListW", "ptr", psf, "ptr", pidl, "int", nFormat, "ptr", pv, "int", cb, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Displays a dialog box that prompts the user to restart Windows. When the user clicks the button, the function calls ExitWindowsEx to attempt to restart Windows.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {PWSTR} pszPrompt Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the text that displays in the dialog box which prompts the user.
     * @param {Integer} dwReturn Type: <b>DWORD</b>
     * 
     * The flags that specify the type of shutdown.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the identifier of the button that was pressed to close the dialog box.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-restartdialog
     * @since windows5.0
     */
    static RestartDialog(hwnd, pszPrompt, dwReturn) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszPrompt := pszPrompt is String ? StrPtr(pszPrompt) : pszPrompt

        result := DllCall("SHELL32.dll\RestartDialog", "ptr", hwnd, "ptr", pszPrompt, "uint", dwReturn, "int")
        return result
    }

    /**
     * Displays a dialog box that asks the user to restart Windows. When the user clicks the button, the function calls ExitWindowsEx to attempt to restart Windows.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {PWSTR} pszPrompt Type: <b>PCWSTR</b>
     * 
     * A null-terminated string that contains the text that displays in the dialog box to prompt the user.
     * @param {Integer} dwReturn Type: <b>DWORD</b>
     * 
     * The flags that specify the type of shutdown.
     * @param {Integer} dwReasonCode Type: <b>DWORD</b>
     * 
     * <b>Windows XP:</b>Specifies the reason for initiating the shutdown. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Shutdown/system-shutdown-reason-codes">System Shutdown Reason Codes</a>.
     *     
     *     					
     * 
     * <b>Windows 2000:</b> This parameter is ignored.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the identifier of the button that was pressed to close the dialog box.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-restartdialogex
     * @since windows5.0
     */
    static RestartDialogEx(hwnd, pszPrompt, dwReturn, dwReasonCode) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszPrompt := pszPrompt is String ? StrPtr(pszPrompt) : pszPrompt

        result := DllCall("SHELL32.dll\RestartDialogEx", "ptr", hwnd, "ptr", pszPrompt, "uint", dwReturn, "uint", dwReasonCode, "int")
        return result
    }

    /**
     * SHCoCreateInstance may be altered or unavailable. Instead, use CoCreateInstance.
     * @param {PWSTR} pszCLSID Type: <b>PCWSTR</b>
     * 
     * A pointer to a string to convert to a CLSID. If <b>NULL</b>, <i>pclsid</i> is used as the CLSID.
     * @param {Pointer<Guid>} pclsid Type: <b>const CLSID*</b>
     * 
     * The CLSID to create.
     * @param {IUnknown} pUnkOuter Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to outer <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>. Used for aggregation.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this function returns successfully, receives the interface pointer requested in <i>riid</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcocreateinstance
     * @since windows5.1.2600
     */
    static SHCoCreateInstance(pszCLSID, pclsid, pUnkOuter, riid) {
        pszCLSID := pszCLSID is String ? StrPtr(pszCLSID) : pszCLSID

        result := DllCall("SHELL32.dll\SHCoCreateInstance", "ptr", pszCLSID, "ptr", pclsid, "ptr", pUnkOuter, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Creates a data object in a parent folder.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) of the parent folder that contains the data object.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of file objects or subfolders specified in the <i>apidl</i> parameter.
     * @param {Pointer<Pointer<ITEMIDLIST>>} apidl Type: <b>PCUITEMID_CHILD_ARRAY</b>
     * 
     * An array of pointers to constant <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures, each of which uniquely identifies a file object or subfolder relative to the parent folder. Each item identifier list must contain exactly one <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-shitemid">SHITEMID</a> structure followed by a terminating zero.
     * @param {IDataObject} pdtInner Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to interface <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>. This parameter can be <b>NULL</b>. Specify <i>pdtInner</i> only if the data object created needs to support additional <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a>  clipboard formats beyond the default formats it is assigned at creation.  Alternatively, provide support for populating the created data object using non-default clipboard formats by calling method <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nf-objidl-idataobject-setdata">IDataObject::SetData</a> and specifying the format in the <b>FORMATETC</b> structure passed in parameter <i>pFormatetc</i>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>. This must be IID_IDataObject.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns successfully, contains the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface pointer requested in <i>riid</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreatedataobject
     * @since windows6.0.6000
     */
    static SHCreateDataObject(pidlFolder, cidl, apidl, pdtInner, riid) {
        apidlMarshal := apidl is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\SHCreateDataObject", "ptr", pidlFolder, "uint", cidl, apidlMarshal, apidl, "ptr", pdtInner, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * CIDLData_CreateFromIDArray may be altered or unavailable.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A fully qualified IDLIST for the root of the items specified in <i>apidl</i>.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of entries in the <i>apidl</i> array.
     * @param {Pointer<Pointer<ITEMIDLIST>>} apidl Type: <b>PCUIDLIST_RELATIVE_ARRAY</b>
     * 
     * The array of item IDs relative to <i>pidlFolder</i>. Typically, <i>apidl</i> is an array of child IDs and <i>pidlFolder</i> is a full PIDL for those items. However, <i>pidlFolder</i> can be a null PIDL (desktop IDLISTs). In that case, <i>apidl</i> can contain fully qualified ID lists.
     * @returns {IDataObject} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>**</b>
     * 
     * The address to a pointer to the object that implements <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-cidldata_createfromidarray
     * @since windows5.0
     */
    static CIDLData_CreateFromIDArray(pidlFolder, cidl, apidl) {
        apidlMarshal := apidl is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\CIDLData_CreateFromIDArray", "ptr", pidlFolder, "uint", cidl, apidlMarshal, apidl, "ptr*", &ppdtobj := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IDataObject(ppdtobj)
    }

    /**
     * SHCreateStdEnumFmtEtc may be altered or unavailable.
     * @param {Integer} cfmt Type: <b>UINT</b>
     * 
     * The number of entries in the <i>afmt</i> array.
     * @param {Pointer<FORMATETC>} afmt Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a>[]</b>
     * 
     * An array of <a href="https://docs.microsoft.com/windows/desktop/api/objidl/ns-objidl-formatetc">FORMATETC</a> structures that specifies the clipboard formats of interest.
     * @returns {IEnumFORMATETC} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumformatetc">IEnumFORMATETC</a>**</b>
     * 
     * When this function returns successfully, receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ienumformatetc">IEnumFORMATETC</a> interface pointer. Receives <b>NULL</b> on failure.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreatestdenumfmtetc
     * @since windows5.1.2600
     */
    static SHCreateStdEnumFmtEtc(cfmt, afmt) {
        result := DllCall("SHELL32.dll\SHCreateStdEnumFmtEtc", "uint", cfmt, "ptr", afmt, "ptr*", &ppenumFormatEtc := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IEnumFORMATETC(ppenumFormatEtc)
    }

    /**
     * Executes a drag-and-drop operation. Supports drag source creation on demand, as well as drag images.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * The handle of the window used to obtain the drag image. This value can be <b>NULL</b>. See Remarks for more details.
     * @param {IDataObject} pdata Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface on a data object that contains the data being dragged.
     * @param {IDropSource} pdsrc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idropsource">IDropSource</a>*</b>
     * 
     * A pointer to an implementation of the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-idropsource">IDropSource</a> interface, which is used to communicate with the source during the drag operation.
     *         
     *                         
     * 
     * As of WindowsVista, if this value is <b>NULL</b>, the Shell creates a drop source object for you.
     * @param {Integer} dwEffect Type: <b>DWORD</b>
     * 
     * The effects that the source allows in the drag-and-drop operation. The most significant effect is whether the drag-and-drop operation permits a move. For a list of possible values, see <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a>.
     * @returns {Integer} Type: <b>DWORD*</b>
     * 
     * A pointer to a value that indicates how the drag-and-drop operation affected the source data. The <i>pdwEffect</i> parameter is set only if the operation is not canceled. For a list of possible values, see <a href="https://docs.microsoft.com/windows/desktop/com/dropeffect-constants">DROPEFFECT</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shdodragdrop
     * @since windows5.1.2600
     */
    static SHDoDragDrop(hwnd, pdata, pdsrc, dwEffect) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd

        result := DllCall("SHELL32.dll\SHDoDragDrop", "ptr", hwnd, "ptr", pdata, "ptr", pdsrc, "uint", dwEffect, "uint*", &pdwEffect := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pdwEffect
    }

    /**
     * Sets the drag image.
     * @param {HIMAGELIST} him Type: <b>HIMAGELIST</b>
     * 
     * A handle to an image list. This parameter uses the zero index in the ImageList.
     * @param {Pointer<POINT>} pptOffset Type: <b><a href="https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a>*</b>
     * 
     * A pointer to the coordinates used as the hot spot for dragging the image. The coordinates are relative to upper-left corner of the image.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-dad_setdragimage
     * @since windows5.0
     */
    static DAD_SetDragImage(him, pptOffset) {
        him := him is Win32Handle ? NumGet(him, "ptr") : him

        result := DllCall("SHELL32.dll\DAD_SetDragImage", "ptr", him, "ptr", pptOffset, "int")
        return result
    }

    /**
     * Locks updates to the specified window during a drag operation and displays the drag image at the specified position within the window.
     * @param {HWND} hwndTarget Type: <b>HWND</b>
     * 
     * A handle to the window that owns the drag image.
     * @param {POINT} ptStart Type: <b>const <a href="https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b>
     * 
     * The coordinates at which to begin displaying the drag image. The coordinates are relative to the upper-left corner of the window, not the client area.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-dad_dragenterex
     * @since windows5.0
     */
    static DAD_DragEnterEx(hwndTarget, ptStart) {
        hwndTarget := hwndTarget is Win32Handle ? NumGet(hwndTarget, "ptr") : hwndTarget

        result := DllCall("SHELL32.dll\DAD_DragEnterEx", "ptr", hwndTarget, "ptr", ptStart, "int")
        return result
    }

    /**
     * Locks updates to the specified window during a drag-and-drop operation and displays the drag image at the specified position within the window.
     * @param {HWND} hwndTarget Type: <b>HWND</b>
     * 
     * A handle to the window that owns the drag image.
     * @param {POINT} ptStart Type: <b>const <a href="https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b>
     * 
     * Specifies the coordinates at which to begin displaying the drag image. The coordinates are relative to the upper-left corner of the window, not the client area.
     * @param {IDataObject} pdtObject Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface on the data object. This data object contains the data being transferred in the drag-and-drop operation. If the drop occurs, this data object will be incorporated into the target. This parameter may be <b>NULL</b>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-dad_dragenterex2
     * @since windows5.0
     */
    static DAD_DragEnterEx2(hwndTarget, ptStart, pdtObject) {
        hwndTarget := hwndTarget is Win32Handle ? NumGet(hwndTarget, "ptr") : hwndTarget

        result := DllCall("SHELL32.dll\DAD_DragEnterEx2", "ptr", hwndTarget, "ptr", ptStart, "ptr", pdtObject, "int")
        return result
    }

    /**
     * Shows or hides the image being dragged.
     * @param {BOOL} fShow Type: <b>BOOL</b>
     * 
     * A value that specifies whether to show or hide the image being dragged.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-dad_showdragimage
     * @since windows5.0
     */
    static DAD_ShowDragImage(fShow) {
        result := DllCall("SHELL32.dll\DAD_ShowDragImage", "int", fShow, "int")
        return result
    }

    /**
     * Moves the image that is being dragged during a drag-and-drop operation.
     * @param {POINT} pt Type: <b><a href="https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a></b>
     * 
     * The coordinates at which to display the drag image. The coordinates are relative to the upper-left corner of the window, not the client area.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-dad_dragmove
     * @since windows5.0
     */
    static DAD_DragMove(pt) {
        result := DllCall("SHELL32.dll\DAD_DragMove", "ptr", pt, "int")
        return result
    }

    /**
     * Unlocks the window locked by the DAD_DragEnterEx function.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>SUCCEEDED</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-dad_dragleave
     * @since windows5.0
     */
    static DAD_DragLeave() {
        result := DllCall("SHELL32.dll\DAD_DragLeave", "int")
        return result
    }

    /**
     * Scrolls the window while an image is being dragged.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window being scrolled.
     * @param {Pointer<AUTO_SCROLL_DATA>} pad Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-auto_scroll_data">AUTO_SCROLL_DATA</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-auto_scroll_data">AUTO_SCROLL_DATA</a> structure.
     * @param {Pointer<POINT>} pptNow Type: <b>const <a href="https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a>*</b>
     * 
     * A pointer to the current scroll coordinates.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-dad_autoscroll
     * @since windows5.0
     */
    static DAD_AutoScroll(hwnd, pad, pptNow) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd

        result := DllCall("SHELL32.dll\DAD_AutoScroll", "ptr", hwnd, "ptr", pad, "ptr", pptNow, "int")
        return result
    }

    /**
     * ReadCabinetState may be altered or unavailable.
     * @param {Pointer} pcs Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-cabinetstate">CABINETSTATE</a>*</b>
     * 
     * When this function returns, contains a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-cabinetstate">CABINETSTATE</a> structure that contains either information pulled from the registry or default information.
     * @param {Integer} cLength Type: <b>int</b>
     * 
     * The size of the structure pointed to by <i>pcs</i>, in bytes.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the returned structure contains information from the registry. Returns <b>FALSE</b> if the structure contains default information.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-readcabinetstate
     * @since windows5.1.2600
     */
    static ReadCabinetState(pcs, cLength) {
        result := DllCall("SHELL32.dll\ReadCabinetState", "ptr", pcs, "int", cLength, "int")
        return result
    }

    /**
     * WriteCabinetState may be altered or unavailable.
     * @param {Pointer<CABINETSTATE>} pcs Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-cabinetstate">CABINETSTATE</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-cabinetstate">CABINETSTATE</a> structure that holds the values to be set.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-writecabinetstate
     * @since windows5.1.2600
     */
    static WriteCabinetState(pcs) {
        result := DllCall("SHELL32.dll\WriteCabinetState", "ptr", pcs, "int")
        return result
    }

    /**
     * Creates a unique path name from a template.
     * @param {PWSTR} pszUniqueName Type: <b>PWSTR</b>
     * 
     * A buffer that receives a null-terminated Unicode string that contains the unique path name. It should be at least MAX_PATH characters in length.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The number of characters in the buffer pointed to by <i>pszUniqueName</i>.
     * @param {PWSTR} pszTemplate Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains a template that is used to construct the unique name. This template is used for drives that require file names with the 8.3 format. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @param {PWSTR} pszLongPlate Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains a template that is used to construct the unique name. This template is used for drives that support long file names. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @param {PWSTR} pszDir Type: <b>PCWSTR</b>
     * 
     * A null-terminated string that contains the directory in which the new file resides. This string should be no more than MAX_PATH characters in length, including the terminating null character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-pathmakeuniquename
     * @since windows5.0
     */
    static PathMakeUniqueName(pszUniqueName, cchMax, pszTemplate, pszLongPlate, pszDir) {
        pszUniqueName := pszUniqueName is String ? StrPtr(pszUniqueName) : pszUniqueName
        pszTemplate := pszTemplate is String ? StrPtr(pszTemplate) : pszTemplate
        pszLongPlate := pszLongPlate is String ? StrPtr(pszLongPlate) : pszLongPlate
        pszDir := pszDir is String ? StrPtr(pszDir) : pszDir

        result := DllCall("SHELL32.dll\PathMakeUniqueName", "ptr", pszUniqueName, "uint", cchMax, "ptr", pszTemplate, "ptr", pszLongPlate, "ptr", pszDir, "int")
        return result
    }

    /**
     * PathIsExe may be altered or unavailable.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string that contains the file path, which includes the name of the file.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the file name extension is .cmd, .bat, .pif, .scf, .exe, .com, or .scr; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-pathisexe
     * @since windows5.1.2600
     */
    static PathIsExe(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\PathIsExe", "ptr", pszPath, "int")
        return result
    }

    /**
     * PathCleanupSpec may be altered or unavailable.
     * @param {PWSTR} pszDir Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the fully qualified path of the directory that will contain the file or directory named at <i>pszSpec</i>. The path must not exceed MAX_PATH characters in length, including the terminating null character. This path is not altered.
     *                         
     *                         
     * 
     * This value can be <b>NULL</b>.
     * @param {PWSTR} pszSpec Type: <b>PWSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the file or directory name to be cleaned. In the case of a file, include the file's extension. Note that because '\' is considered an invalid character and will be removed, this buffer cannot contain a path more than one directory deep.
     *                     
     *                         
     * 
     * On exit, the buffer contains a null-terminated string that includes the cleaned name.
     * 
     * This buffer should be at least MAX_PATH characters in length to avoid the possibility of a buffer overrun.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns one or more of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_REPLACEDCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Replaced one or more invalid characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_REMOVEDCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Removed one or more invalid characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_TRUNCATED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The returned path is truncated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_PATHTOOLONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed because the input path specified at <i>pszDir</i> is too long to allow the formation of a valid file name from <i>pszSpec</i>. When this flag is returned, it is always accompanied by the PCS_FATAL flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PCS_FATAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cleaned path is not a valid file name. This flag is always returned in conjunction with PCS_PATHTOOLONG.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-pathcleanupspec
     * @since windows5.1.2600
     */
    static PathCleanupSpec(pszDir, pszSpec) {
        pszDir := pszDir is String ? StrPtr(pszDir) : pszDir
        pszSpec := pszSpec is String ? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHELL32.dll\PathCleanupSpec", "ptr", pszDir, "ptr", pszSpec, "int")
        return result
    }

    /**
     * PathResolve may be altered or unavailable.
     * @param {PWSTR} pszPath Type: <b>PWSTR</b>
     * 
     * A null-terminated Unicode string that contains the path to resolve. When the function returns, the string contains the corresponding fully qualified path. This buffer should be at least MAX_PATH characters long.
     * @param {Pointer<Pointer<Integer>>} dirs Type: <b>PZPCWSTR</b>
     * 
     * A pointer to an optional null-terminated array of directories to be searched first in the case that the path cannot be resolved from <i>pszPath</i>. This value can be <b>NULL</b>.
     * @param {Integer} fFlags Type: <b>UINT</b>
     * 
     * Flags that specify how the function operates.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns <b>TRUE</b>, unless PRF_VERIFYEXISTS is set. If that flag is set, the function returns <b>TRUE</b> if the file is verified to exist and <b>FALSE</b> otherwise. It also sets an ERROR_FILE_NOT_FOUND error code that you can retrieve by calling <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-pathresolve
     * @since windows5.1.2600
     */
    static PathResolve(pszPath, dirs, fFlags) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        dirsMarshal := dirs is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("SHELL32.dll\PathResolve", "ptr", pszPath, dirsMarshal, dirs, "uint", fFlags, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates an Open dialog box so that the user can specify the drive, directory, and name of a file to open.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box. This member can be any valid window handle, or it can be <b>NULL</b> if the dialog box has no owner.
     * @param {PWSTR} pszFilePath Type: <b>PWSTR</b>
     * 
     * A null-terminated Unicode string that contains a file name used to initialize the File Name edit control. This string corresponds to the <a href="https://docs.microsoft.com/windows/win32/api/commdlg/ns-commdlg-openfilenamea">OPENFILENAME</a> structure's <b>lpstrFile</b> member and is used in exactly the same way.
     * @param {Integer} cchFilePath Type: <b>UINT</b>
     * 
     * The number of characters in <i>pszFilePath</i>, including the terminating null character.
     * @param {PWSTR} pszWorkingDir Type: <b>PCWSTR</b>
     * 
     * The fully qualified file path of the initial directory. This string corresponds to the <a href="https://docs.microsoft.com/windows/win32/api/commdlg/ns-commdlg-openfilenamea">OPENFILENAME</a> structure's <b>lpstrInitialDir</b> member and is used in exactly the same way.
     * @param {PWSTR} pszDefExt Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the default file name extension. This extension is added to <i>pszFilePath</i> if the user does not specify an extension. The string should not contain any '.' characters. If this string is <b>NULL</b> and the user fails to type an extension, no extension is appended.
     * @param {PWSTR} pszFilters Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that defines the filter. This string corresponds to the <a href="https://docs.microsoft.com/windows/win32/api/commdlg/ns-commdlg-openfilenamea">OPENFILENAME</a> structure's <b>lpstrFilter</b> member and is used in exactly the same way.
     * @param {PWSTR} pszTitle Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that is placed in the title bar of the dialog box. If this value is <b>NULL</b>, the system uses the default title.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * If the user specifies a file name and clicks <b>OK</b>, the return value is <b>TRUE</b>. The buffer that <i>pszFilePath</i> points to contains the full path and file name that the user specifies. If the user cancels or closes the <b>Open</b> dialog box or an error occurs, the return value is <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-getfilenamefrombrowse
     * @since windows5.0
     */
    static GetFileNameFromBrowse(hwnd, pszFilePath, cchFilePath, pszWorkingDir, pszDefExt, pszFilters, pszTitle) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszFilePath := pszFilePath is String ? StrPtr(pszFilePath) : pszFilePath
        pszWorkingDir := pszWorkingDir is String ? StrPtr(pszWorkingDir) : pszWorkingDir
        pszDefExt := pszDefExt is String ? StrPtr(pszDefExt) : pszDefExt
        pszFilters := pszFilters is String ? StrPtr(pszFilters) : pszFilters
        pszTitle := pszTitle is String ? StrPtr(pszTitle) : pszTitle

        result := DllCall("SHELL32.dll\GetFileNameFromBrowse", "ptr", hwnd, "ptr", pszFilePath, "uint", cchFilePath, "ptr", pszWorkingDir, "ptr", pszDefExt, "ptr", pszFilters, "ptr", pszTitle, "int")
        return result
    }

    /**
     * DriveType may be altered or unavailable.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * The number of the drive that you want to test. "A:" corresponds to 0, "B:" to 1, and so on.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_UNKNOWN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive type cannot be determined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_NO_ROOT_DIR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The root path is invalid. For example, no volume is mounted at the path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOVABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disk can be removed from the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_FIXED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disk cannot be removed from the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a remote (network) drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_CDROM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a CD-ROM drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_RAMDISK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a RAM disk.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-drivetype
     * @since windows5.1.2600
     */
    static DriveType(iDrive) {
        result := DllCall("SHELL32.dll\DriveType", "int", iDrive, "int")
        return result
    }

    /**
     * RealDriveType may be altered or unavailable.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * The number of the drive that you want to test. "A:" corresponds to 0, "B:" to 1, and so on.
     * @param {BOOL} fOKToHitNet Type: <b>BOOL</b>
     * 
     * Reserved. Must be set to 0.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_UNKNOWN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive type cannot be determined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_NO_ROOT_DIR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The root path is invalid. For example, no volume is mounted at the path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOVABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disk can be removed from the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_FIXED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disk cannot be removed from the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a remote (network) drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_CDROM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a CD-ROM drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_RAMDISK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a RAM disk.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-realdrivetype
     * @since windows5.1.2600
     */
    static RealDriveType(iDrive, fOKToHitNet) {
        result := DllCall("SHELL32.dll\RealDriveType", "int", iDrive, "int", fOKToHitNet, "int")
        return result
    }

    /**
     * Tests whether a drive is a network drive.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * An integer that indicates which drive letter you want to test. Set it to 0 for  A:, 1 for B:, and so on.
     * @returns {Integer} Type: <b>int</b>
     * 
     * This function returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is not a network drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is a network drive that is properly connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified drive is a network drive that is disconnected or in an error state.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-isnetdrive
     * @since windows5.0
     */
    static IsNetDrive(iDrive) {
        result := DllCall("SHELL32.dll\IsNetDrive", "int", iDrive, "int")
        return result
    }

    /**
     * Shell_MergeMenus may be altered or unavailable.
     * @param {HMENU} hmDst Type: <b>HMENU</b>
     * 
     * The destination menu to which <i>hmSrc</i> is added.
     * @param {HMENU} hmSrc Type: <b>HMENU</b>
     * 
     * The source menu which is added to <i>hmDst</i>.
     * @param {Integer} uInsert Type: <b>UINT</b>
     * 
     * The point in <i>hmDst</i> after which the entries in <i>hmSrc</i> are inserted.
     * @param {Integer} uIDAdjust Type: <b>UINT</b>
     * 
     * This number is added to each menu's ID to give an adjusted ID. Set to <c>0</c> for no adjustment. The value for <i>uIDAdjust</i> would typically be the number of items in <i>hmDst</i>. This number can be obtained using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmenuitemcount">GetMenuItemCount</a>.
     * @param {Integer} uIDAdjustMax Type: <b>UINT</b>
     * 
     * The maximum adjusted ID to add to the menu. Any adjusted ID greater than this value is not added. To allow all IDs, set this parameter to 0xFFFF.
     * @param {Integer} uFlags Type: <b>ULONG</b>
     * 
     * One or more of the following flags.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * Returns the next open ID at the end of the menu (the maximum adjusted ID + 1).
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shell_mergemenus
     * @since windows5.1.2600
     */
    static Shell_MergeMenus(hmDst, hmSrc, uInsert, uIDAdjust, uIDAdjustMax, uFlags) {
        hmDst := hmDst is Win32Handle ? NumGet(hmDst, "ptr") : hmDst
        hmSrc := hmSrc is Win32Handle ? NumGet(hmSrc, "ptr") : hmSrc

        result := DllCall("SHELL32.dll\Shell_MergeMenus", "ptr", hmDst, "ptr", hmSrc, "uint", uInsert, "uint", uIDAdjust, "uint", uIDAdjustMax, "uint", uFlags, "uint")
        return result
    }

    /**
     * SHObjectProperties may be altered or unavailable.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window of the dialog box. This value can be <b>NULL</b>.
     * @param {Integer} shopObjectType Type: <b>DWORD</b>
     * 
     * A flag value that specifies the type of object.
     * @param {PWSTR} pszObjectName Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the object name. The contents of the string are determined by the flag set in <i>shopObjectType</i>.
     * @param {PWSTR} pszPropertyPage Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the name of the property sheet page to be opened initially. Set this parameter to <b>NULL</b> to specify the default page.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the command is successfully invoked; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shobjectproperties
     * @since windows5.1.2600
     */
    static SHObjectProperties(hwnd, shopObjectType, pszObjectName, pszPropertyPage) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszObjectName := pszObjectName is String ? StrPtr(pszObjectName) : pszObjectName
        pszPropertyPage := pszPropertyPage is String ? StrPtr(pszPropertyPage) : pszPropertyPage

        result := DllCall("SHELL32.dll\SHObjectProperties", "ptr", hwnd, "uint", shopObjectType, "ptr", pszObjectName, "ptr", pszPropertyPage, "int")
        return result
    }

    /**
     * SHFormatDrive may be altered or unavailable.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window of the dialog box. The <b>Format</b> dialog box must have a parent window; therefore, this parameter cannot be <b>NULL</b>.
     * @param {Integer} drive Type: <b>UINT</b>
     * 
     * The drive to format. The value of this parameter represents a letter drive starting at 0 for the A: drive. For example, a value of 2 stands for the C: drive.
     * @param {Integer} fmtID Type: <b>UINT</b>
     * 
     * The ID of the physical format. Only the following flag is currently defined.
     * @param {Integer} options Type: <b>UINT</b>
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns the format ID of the last successful format or one of the following values. The LOWORD of this value can be passed on subsequent calls as the <i>fmtID</i> parameter to repeat the last format.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SHFMT_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred during the last format. This does not indicate that the drive is unformattable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SHFMT_CANCEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The last format was canceled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SHFMT_NOFORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive cannot be formatted.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shformatdrive
     * @since windows5.1.2600
     */
    static SHFormatDrive(hwnd, drive, fmtID, options) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd

        result := DllCall("SHELL32.dll\SHFormatDrive", "ptr", hwnd, "uint", drive, "uint", fmtID, "uint", options, "uint")
        return result
    }

    /**
     * Frees property sheet handlers that are pointed to an array created by SHCreatePropSheetExtArray.
     * @param {HPSXA} hpsxa Type: <b>HPSXA</b>
     * 
     * The handle of the array that contains pointers to the property sheet handlers to destroy.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shdestroypropsheetextarray
     * @since windows5.1.2600
     */
    static SHDestroyPropSheetExtArray(hpsxa) {
        hpsxa := hpsxa is Win32Handle ? NumGet(hpsxa, "ptr") : hpsxa

        DllCall("SHELL32.dll\SHDestroyPropSheetExtArray", "ptr", hpsxa)
    }

    /**
     * Adds pages to a property sheet extension array created by SHCreatePropSheetExtArray.
     * @param {HPSXA} hpsxa Type: <b>HPSXA</b>
     * 
     * The array of property sheet handlers returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlobj/nf-shlobj-shcreatepropsheetextarray">SHCreatePropSheetExtArray</a>.
     * @param {Pointer<LPFNSVADDPROPSHEETPAGE>} lpfnAddPage Type: <b>LPFNADDPROPSHEETPAGE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/prsht/nc-prsht-lpfnaddpropsheetpage">AddPropSheetPageProc</a> callback function. It is called once for each property sheet handler. The callback function then returns the information needed to add a page to the handler's property sheet.
     * @param {LPARAM} lParam Type: <b>LPARAM</b>
     * 
     * A pointer to application-defined data. This data is passed to the callback function specified by <i>lpfnAddPage</i>.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * Returns the number of pages actually added.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shaddfrompropsheetextarray
     * @since windows5.0
     */
    static SHAddFromPropSheetExtArray(hpsxa, lpfnAddPage, lParam) {
        hpsxa := hpsxa is Win32Handle ? NumGet(hpsxa, "ptr") : hpsxa

        result := DllCall("SHELL32.dll\SHAddFromPropSheetExtArray", "ptr", hpsxa, "ptr", lpfnAddPage, "ptr", lParam, "uint")
        return result
    }

    /**
     * Requests each property sheet in a property sheet extension array to replace pages. Each page is allowed up to one replacement.
     * @param {HPSXA} hpsxa Type: <b>HPSXA</b>
     * 
     * A property sheet array handle (HPSXA) returned from a call to <a href="https://docs.microsoft.com/windows/desktop/api/shlobj/nf-shlobj-shcreatepropsheetextarray">SHCreatePropSheetExtArray</a>.
     * @param {Integer} uPageID Type: <b>UINT</b>
     * 
     * The ID of the page to replace.
     * @param {Pointer<LPFNSVADDPROPSHEETPAGE>} lpfnReplaceWith Type: <b>LPFNADDPROPSHEETPAGE</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/prsht/nc-prsht-lpfnaddpropsheetpage">AddPropSheetPageProc</a> function used by the property sheet extension to add a page to a property sheet.
     * @param {LPARAM} lParam Type: <b>LPARAM</b>
     * 
     * An application-defined value.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * The number of replacements actually performed.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shreplacefrompropsheetextarray
     * @since windows5.1.2600
     */
    static SHReplaceFromPropSheetExtArray(hpsxa, uPageID, lpfnReplaceWith, lParam) {
        hpsxa := hpsxa is Win32Handle ? NumGet(hpsxa, "ptr") : hpsxa

        result := DllCall("SHELL32.dll\SHReplaceFromPropSheetExtArray", "ptr", hpsxa, "uint", uPageID, "ptr", lpfnReplaceWith, "ptr", lParam, "uint")
        return result
    }

    /**
     * OpenRegStream may be altered or unavailable. Instead, use SHOpenRegStream2 or SHOpenRegStream.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the key that is currently open.
     * @param {PWSTR} pszSubkey Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that specifies the name of the subkey.
     * @param {PWSTR} pszValue Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that specifies the value to be accessed.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {IStream} Type: <b><a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns the address of an <a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-openregstream
     * @since windows5.1.2600
     */
    static OpenRegStream(hkey, pszSubkey, pszValue, grfMode) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubkey := pszSubkey is String ? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHELL32.dll\OpenRegStream", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * SHFindFiles may be altered or unavailable.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The folder from which to start the search. This folder appears in the <b>Look in:</b> box in the <b>Search</b> window. This folder and all of its subfolders are searched unless users choose other options in the <b>Search</b> window's <b>More Advanced Options</b>. This value can be <b>NULL</b>.
     * @param {Pointer<ITEMIDLIST>} pidlSaveFile Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * This parameter is not used and must be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A saved search file (.fnd) to load. You can save search parameters to a .fnd file after the search is begun. This value can be <b>NULL</b>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful in displaying the <b>Search</b> window; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shfindfiles
     * @since windows5.1.2600
     */
    static SHFindFiles(pidlFolder, pidlSaveFile) {
        result := DllCall("SHELL32.dll\SHFindFiles", "ptr", pidlFolder, "ptr", pidlSaveFile, "int")
        return result
    }

    /**
     * PathGetShortPath may be altered or unavailable.
     * @param {PWSTR} pszLongPath Type: <b>PWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string that contains the long path. When the function returns, it contains the equivalent short path.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-pathgetshortpath
     * @since windows5.1.2600
     */
    static PathGetShortPath(pszLongPath) {
        pszLongPath := pszLongPath is String ? StrPtr(pszLongPath) : pszLongPath

        DllCall("SHELL32.dll\PathGetShortPath", "ptr", pszLongPath)
    }

    /**
     * Creates a unique filename based on an existing filename.
     * @param {PWSTR} pszUniqueName Type: <b>PWSTR</b>
     * 
     * A string buffer that receives a null-terminated Unicode string that contains the fully qualified path of the unique file name. This buffer should be at least MAX_PATH characters long to avoid causing a buffer overrun.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the fully qualified path of folder that will contain the new file. If <i>pszShort</i> is set to <b>NULL</b>, this string must contain a full destination path, ending with the long file name that the new file name will be base on.
     * @param {PWSTR} pszShort Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the short file name that the unique name will be based on. Set this value to <b>NULL</b> to create a name based on the long file name.
     * @param {PWSTR} pszFileSpec Type: <b>PCWSTR</b>
     * 
     * A null-terminated Unicode string that contains the long file name that the unique name will be based on.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a unique name was successfully created; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-pathyetanothermakeuniquename
     * @since windows5.0
     */
    static PathYetAnotherMakeUniqueName(pszUniqueName, pszPath, pszShort, pszFileSpec) {
        pszUniqueName := pszUniqueName is String ? StrPtr(pszUniqueName) : pszUniqueName
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszShort := pszShort is String ? StrPtr(pszShort) : pszShort
        pszFileSpec := pszFileSpec is String ? StrPtr(pszFileSpec) : pszFileSpec

        result := DllCall("SHELL32.dll\PathYetAnotherMakeUniqueName", "ptr", pszUniqueName, "ptr", pszPath, "ptr", pszShort, "ptr", pszFileSpec, "int")
        return result
    }

    /**
     * Win32DeleteFile may be altered or unavailable.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a buffer that contains the full name of the file to delete.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the file was successfully deleted; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-win32deletefile
     * @since windows5.1.2600
     */
    static Win32DeleteFile(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\Win32DeleteFile", "ptr", pszPath, "int")
        return result
    }

    /**
     * SHRestricted may be altered or unavailable.
     * @param {Integer} rest Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-restrictions">RESTRICTIONS</a></b>
     * 
     * Specifies one of the flags described in the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-restrictions">RESTRICTIONS</a> enumerated type.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns nonzero if the specified restriction is in effect, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shrestricted
     * @since windows5.1.2600
     */
    static SHRestricted(rest) {
        result := DllCall("SHELL32.dll\SHRestricted", "int", rest, "uint")
        return result
    }

    /**
     * SignalFileOpen may be altered or unavailable.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A PIDL that specifies the file.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-signalfileopen
     * @since windows5.1.2600
     */
    static SignalFileOpen(pidl) {
        result := DllCall("SHELL32.dll\SignalFileOpen", "ptr", pidl, "int")
        return result
    }

    /**
     * Retrieves the value for a given property key using the file association information provided by the Namespace Extensions.
     * @param {IShellFolder} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to the shell folder for which the details of the property key of the file association are being retrieved.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * The PIDL of the child item for which the file associations are being requested.
     * @param {Pointer<PROPERTYKEY>} pkey Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ns-wtypes-propertykey">PROPERTYKEY</a>*</b>
     * 
     * A pointer to the property key that is being retrieved.
     * @param {Pointer<VARIANT>} pv Type: <b>VARIANT*</b>
     * 
     * When this function returns, contains the details of the given property key.
     * @returns {BOOL} Type: <b>BOOL*</b>
     * 
     * When this function returns, contains a flag that is <b>TRUE</b> if the property key was found, otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-assocgetdetailsofpropkey
     * @since windows6.0.6000
     */
    static AssocGetDetailsOfPropKey(psf, pidl, pkey, pv) {
        result := DllCall("SHELL32.dll\AssocGetDetailsOfPropKey", "ptr", psf, "ptr", pidl, "ptr", pkey, "ptr", pv, "int*", &pfFoundPropKey := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pfFoundPropKey
    }

    /**
     * SHStartNetConnectionDialog may be altered or unavailable.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {PWSTR} pszRemoteName Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated character string that specifies the remote network name. This value can be set to <b>NULL</b>.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Always returns S_OK.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shstartnetconnectiondialogw
     * @since windows5.1.2600
     */
    static SHStartNetConnectionDialogW(hwnd, pszRemoteName, dwType) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszRemoteName := pszRemoteName is String ? StrPtr(pszRemoteName) : pszRemoteName

        result := DllCall("SHELL32.dll\SHStartNetConnectionDialogW", "ptr", hwnd, "ptr", pszRemoteName, "uint", dwType, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Provides a default handler to extract an icon from a file.
     * @param {PSTR} pszIconFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.
     * @param {Integer} iIndex Type: <b>int</b>
     * 
     * The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * A flag that controls the icon extraction.
     * @param {Pointer<HICON>} phiconLarge Type: <b>HICON*</b>
     * 
     * A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.
     * @param {Pointer<HICON>} phiconSmall Type: <b>HICON*</b>
     * 
     * A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.
     * @param {Integer} nIconSize Type: <b>UINT</b>
     * 
     * A value that contains the large icon size in its <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * This function can return one of these values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Success.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested icon is not present.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file cannot be accessed, or is being accessed through a slow link.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shdefextracticona
     * @since windows5.1.2600
     */
    static SHDefExtractIconA(pszIconFile, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize) {
        pszIconFile := pszIconFile is String ? StrPtr(pszIconFile) : pszIconFile

        result := DllCall("SHELL32.dll\SHDefExtractIconA", "ptr", pszIconFile, "int", iIndex, "uint", uFlags, "ptr", phiconLarge, "ptr", phiconSmall, "uint", nIconSize, "int")
        return result
    }

    /**
     * Provides a default handler to extract an icon from a file.
     * @param {PWSTR} pszIconFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated buffer that contains the path and name of the file from which the icon is extracted.
     * @param {Integer} iIndex Type: <b>int</b>
     * 
     * The location of the icon within the file named in <i>pszIconFile</i>. If this is a positive number, it refers to the zero-based position of the icon in the file. For instance, 0 refers to the 1st icon in the resource file and 2 refers to the 3rd. If this is a negative number, it refers to the icon's resource ID.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * A flag that controls the icon extraction.
     * @param {Pointer<HICON>} phiconLarge Type: <b>HICON*</b>
     * 
     * A pointer to an HICON that, when this function returns successfully, receives the handle of the large version of the icon specified in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> of <i>nIconSize</i>. This value can be <b>NULL</b>.
     * @param {Pointer<HICON>} phiconSmall Type: <b>HICON*</b>
     * 
     * A pointer to an HICON that, when this function returns successfully, receives the handle of the small version of the icon specified in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of <i>nIconSize</i>.
     * @param {Integer} nIconSize Type: <b>UINT</b>
     * 
     * A value that contains the large icon size in its <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> and the small icon size in its <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a>. Size is measured in pixels. Pass 0 to specify default large and small sizes.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * This function can return one of these values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Success.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested icon is not present.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file cannot be accessed, or is being accessed through a slow link.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shdefextracticonw
     * @since windows5.1.2600
     */
    static SHDefExtractIconW(pszIconFile, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize) {
        pszIconFile := pszIconFile is String ? StrPtr(pszIconFile) : pszIconFile

        result := DllCall("SHELL32.dll\SHDefExtractIconW", "ptr", pszIconFile, "int", iIndex, "uint", uFlags, "ptr", phiconLarge, "ptr", phiconSmall, "uint", nIconSize, "int")
        return result
    }

    /**
     * Displays the Open With dialog box.
     * @param {HWND} hwndParent Type: <b>HWND</b>
     * 
     * The handle of the parent window. This value can be <b>NULL</b>.
     * @param {Pointer<OPENASINFO>} poainfo Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-openasinfo">OPENASINFO</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-openasinfo">OPENASINFO</a> structure, which specifies the contents of the resulting dialog.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shopenwithdialog
     * @since windows6.0.6000
     */
    static SHOpenWithDialog(hwndParent, poainfo) {
        hwndParent := hwndParent is Win32Handle ? NumGet(hwndParent, "ptr") : hwndParent

        result := DllCall("SHELL32.dll\SHOpenWithDialog", "ptr", hwndParent, "ptr", poainfo, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves system image lists for large and small icons.
     * @param {Pointer<HIMAGELIST>} phiml Type: <b>HIMAGELIST*</b>
     * 
     * A pointer to the handle of an image list which, on success, receives the system image list for large (32 x 32) icons.
     * @param {Pointer<HIMAGELIST>} phimlSmall Type: <b>HIMAGELIST*</b>
     * 
     * A pointer to the handle of an image list which, on success, receives the system image list for small (16 x 16) icons.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> on success. On failure, returns <b>FALSE</b> and the image lists pointed to by <i>phiml</i> and <i>phimlSmall</i> are unchanged.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shell_getimagelists
     * @since windows5.1.2600
     */
    static Shell_GetImageLists(phiml, phimlSmall) {
        result := DllCall("SHELL32.dll\Shell_GetImageLists", "ptr", phiml, "ptr", phimlSmall, "int")
        return result
    }

    /**
     * Shell_GetCachedImageIndex may be altered or unavailable.
     * @param {PWSTR} pwszIconPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a buffer that contains the path to the image file.
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The index of the image within the file named at <i>pwszIconPath</i>.
     * @param {Integer} uIconFlags Type: <b>UINT</b>
     * 
     * Not used.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the image, or 1 on failure.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shell_getcachedimageindex
     * @since windows5.1.2600
     */
    static Shell_GetCachedImageIndex(pwszIconPath, iIconIndex, uIconFlags) {
        pwszIconPath := pwszIconPath is String ? StrPtr(pwszIconPath) : pwszIconPath

        result := DllCall("SHELL32.dll\Shell_GetCachedImageIndex", "ptr", pwszIconPath, "int", iIconIndex, "uint", uIconFlags, "int")
        return result
    }

    /**
     * Shell_GetCachedImageIndex may be altered or unavailable.
     * @param {PSTR} pszIconPath TBD
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The index of the image within the file named at <i>pwszIconPath</i>.
     * @param {Integer} uIconFlags Type: <b>UINT</b>
     * 
     * Not used.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the image, or 1 on failure.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shell_getcachedimageindexa
     * @since windows5.1.2600
     */
    static Shell_GetCachedImageIndexA(pszIconPath, iIconIndex, uIconFlags) {
        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\Shell_GetCachedImageIndexA", "ptr", pszIconPath, "int", iIconIndex, "uint", uIconFlags, "int")
        return result
    }

    /**
     * Shell_GetCachedImageIndex may be altered or unavailable.
     * @param {PWSTR} pszIconPath TBD
     * @param {Integer} iIconIndex Type: <b>int</b>
     * 
     * The index of the image within the file named at <i>pwszIconPath</i>.
     * @param {Integer} uIconFlags Type: <b>UINT</b>
     * 
     * Not used.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the image, or 1 on failure.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shell_getcachedimageindexw
     * @since windows5.1.2600
     */
    static Shell_GetCachedImageIndexW(pszIconPath, iIconIndex, uIconFlags) {
        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        result := DllCall("SHELL32.dll\Shell_GetCachedImageIndexW", "ptr", pszIconPath, "int", iIconIndex, "uint", uIconFlags, "int")
        return result
    }

    /**
     * SHValidateUNC may be altered or unavailable.
     * @param {HWND} hwndOwner Type: <b>HWND</b>
     * 
     * Handle of the parent window, used to display UI. If this is not needed, this value can be set to <b>NULL</b>.
     * @param {PWSTR} pszFile Type: <b>PWSTR</b>
     * 
     * A pointer to a null-terminated Unicode string that specifies the UNC path to validate. Note: This string must not be a constant string.
     * @param {Integer} fConnect Type: <b>UINT</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the UNC path exists; <b>FALSE</b> if the UNC path does not exist or if some other failure occurred.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shvalidateunc
     * @since windows5.1.2600
     */
    static SHValidateUNC(hwndOwner, pszFile, fConnect) {
        hwndOwner := hwndOwner is Win32Handle ? NumGet(hwndOwner, "ptr") : hwndOwner
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHELL32.dll\SHValidateUNC", "ptr", hwndOwner, "ptr", pszFile, "uint", fConnect, "int")
        return result
    }

    /**
     * Provides an interface that allows hosted Shell extensions and other components to prevent their host process from closing prematurely.
     * @remarks
     * 
     * Windows Explorer and Internet Explorer can use <b>SHSetInstanceExplorer</b> to allow components such as Shell extensions to extend the lifetime of the process. Other applications can also use <b>SHSetInstanceExplorer</b> to allow for the same capability. For instance, the browser message loop and the proxy desktop use <b>SHSetInstanceExplorer</b> to let other threads extend their lifetime.
     * 
     * Applications other than Windows Explorer and Internet Explorer that call this function might encounter compatibility problems because some components use <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer">SHGetInstanceExplorer</a> to detect whether they are being hosted from within Windows Explorer or Internet Explorer.
     * 
     * The interface pointer passed to <b>SHSetInstanceExplorer</b> must reference a free-threaded object.
     * 
     * Each time a component calls <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer">SHGetInstanceExplorer</a>, the system calls the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref">AddRef</a> method before returning the interface pointer to the calling component. The component then calls the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> method when processing is complete. The process that calls <b>SHSetInstanceExplorer</b> must not terminate while the reference count of the provided interface pointer is nonzero.
     * 
     * For further information on how components use the process references, see <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer">SHGetInstanceExplorer</a>.
     * 
     * 
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to a free-threaded <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>. Components can use this interface (through <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetinstanceexplorer">SHGetInstanceExplorer</a>) to prevent the host process from terminating. This value can be <b>NULL</b>, in which case the process reference is no longer made available to components.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shsetinstanceexplorer
     * @since windows5.1.2600
     */
    static SHSetInstanceExplorer(punk) {
        DllCall("SHELL32.dll\SHSetInstanceExplorer", "ptr", punk)
    }

    /**
     * IsUserAnAdmin may be altered or unavailable.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the user is a member of the Administrator's group; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-isuseranadmin
     * @since windows5.1.2600
     */
    static IsUserAnAdmin() {
        result := DllCall("SHELL32.dll\IsUserAnAdmin", "int")
        return result
    }

    /**
     * SHShellFolderView_Message may be altered or unavailable.
     * @param {HWND} hwndMain Type: <b>HWND</b>
     * 
     * A handle to the window that receives the message.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to send. The following is a list of possible messages.
     * 
     * 						
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Message</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/samples-usingimagefactory">SFVM_ADDOBJECT</a>
     * </td>
     * <td>Adds an object to the shell view.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-getselectedobjects">SFVM_GETSELECTEDOBJECTS</a>
     * </td>
     * <td>Retrieves an array of PIDLs for all selected objects.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-rearrange">SFVM_REARRANGE</a>
     * </td>
     * <td>Notifies the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> to rearrange its items.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-removeobject">SFVM_REMOVEOBJECT</a>
     * </td>
     * <td>Removes an object from the shell view.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-setclipboard">SFVM_SETCLIPBOARD</a>
     * </td>
     * <td>Notifies the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> when one of its objects is placed on the clipboard as a result of a menu command.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-setitempos">SFVM_SETITEMPOS</a>
     * </td>
     * <td>Sets the position of an item in the shell view.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-setpoints">SFVM_SETPOINTS</a>
     * </td>
     * <td>Sets the points of the currently selected objects to the data object on <b>copy</b> and <b>cut</b> commands.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/shell/sfvm-updateobject">SFVM_UPDATEOBJECT</a>
     * </td>
     * <td>Updates an object by passing a pointer to an array of two PIDLs.</td>
     * </tr>
     * </table>
     * @param {LPARAM} lParam Type: <b>LPARAM</b>
     * 
     * Contents of this value depend on the message passed in <i>uMsg</i>. See individual message topics for more information.
     * @returns {LRESULT} Type: <b>LRESULT</b>
     * 
     * The return value depends on the message passed in <i>uMsg</i>. See individual message topics for more information.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shshellfolderview_message
     * @since windows5.1.2600
     */
    static SHShellFolderView_Message(hwndMain, uMsg, lParam) {
        hwndMain := hwndMain is Win32Handle ? NumGet(hwndMain, "ptr") : hwndMain

        result := DllCall("SHELL32.dll\SHShellFolderView_Message", "ptr", hwndMain, "uint", uMsg, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Creates a new instance of the default Shell folder view object (DefView).
     * @param {Pointer<SFV_CREATE>} pcsfv Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-sfv_create">SFV_CREATE</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-sfv_create">SFV_CREATE</a> structure that describes the particulars used in creating this instance of the Shell folder view object.
     * @returns {IShellView} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a>**</b>
     * 
     * When this function returns successfully, contains an interface pointer to the new <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> object. On failure, this value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreateshellfolderview
     * @since windows5.0
     */
    static SHCreateShellFolderView(pcsfv) {
        result := DllCall("SHELL32.dll\SHCreateShellFolderView", "ptr", pcsfv, "ptr*", &ppsv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IShellView(ppsv)
    }

    /**
     * Creates a context menu for a selected group of file folder objects.
     * @param {Pointer<ITEMIDLIST>} pidlFolder Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure for the parent folder. This value can be <b>NULL</b>.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window. This value can be <b>NULL</b>.
     * @param {Integer} cidl Type: <b>UINT</b>
     * 
     * The number of <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures in the array pointed to by <i>apidl</i>.
     * @param {Pointer<Pointer<ITEMIDLIST>>} apidl Type: <b>PCUITEMID_CHILD_ARRAY*</b>
     * 
     * A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structures, one for each item that is selected.
     * @param {IShellFolder} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to the parent folder's <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface. This <b>IShellFolder</b> must support the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a> interface. If it does not, <b>CDefFolderMenu_Create2</b> fails and returns E_NOINTERFACE. This value can be <b>NULL</b>.
     * @param {Pointer<LPFNDFMCALLBACK>} pfn Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nc-shlobj_core-lpfndfmcallback">LPFNDFMCALLBACK</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nc-shlobj_core-lpfndfmcallback">LPFNDFMCALLBACK</a> callback object. This value can be <b>NULL</b> if the callback object is not needed.
     * @param {Integer} nKeys Type: <b>UINT</b>
     * 
     * The number of registry keys in the array pointed to by <i>ahkeys</i>.
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>The maximum number of registry keys is 16. Callers must enforce this limit as the API does not. Failing to do so can result in memory corruption.</div>
     * <div></div>
     * @param {Pointer<HKEY>} ahkeys Type: <b>const HKEY*</b>
     * 
     * A pointer to an array of registry keys that specify the context menu handlers used with the menu's entries. For more information on context menu handlers, see <a href="https://docs.microsoft.com/windows/desktop/shell/context-menu-handlers">Creating Context Menu Handlers</a>. This array can contain a maximum of 16 registry keys.
     * @returns {IContextMenu} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a>**</b>
     * 
     * The address of an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> interface pointer that, when this function returns successfully, points to the <b>IContextMenu</b> object that represents the context menu.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-cdeffoldermenu_create2
     * @since windows5.0
     */
    static CDefFolderMenu_Create2(pidlFolder, hwnd, cidl, apidl, psf, pfn, nKeys, ahkeys) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd

        apidlMarshal := apidl is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\CDefFolderMenu_Create2", "ptr", pidlFolder, "ptr", hwnd, "uint", cidl, apidlMarshal, apidl, "ptr", psf, "ptr", pfn, "uint", nKeys, "ptr", ahkeys, "ptr*", &ppcm := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IContextMenu(ppcm)
    }

    /**
     * Creates an object that represents the Shell's default context menu implementation.
     * @param {Pointer<DEFCONTEXTMENU>} pdcm Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-defcontextmenu">DEFCONTEXTMENU</a>*</b>
     * 
     * A pointer to a constant <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-defcontextmenu">DEFCONTEXTMENU</a> structure.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the interface ID of the interface on which to base the object. This is typically the IID of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a>, <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu2">IContextMenu2</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu3">IContextMenu3</a>.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreatedefaultcontextmenu
     * @since windows6.0.6000
     */
    static SHCreateDefaultContextMenu(pdcm, riid) {
        result := DllCall("SHELL32.dll\SHCreateDefaultContextMenu", "ptr", pdcm, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * SHFind_InitMenuPopup may be altered or unavailable.
     * @param {HMENU} hmenu Type: <b>HMENU</b>
     * 
     * The handle of the popup menu.
     * @param {HWND} hwndOwner Type: <b>HWND</b>
     * 
     * The handle of the popup menu's owner window. This value can be <b>NULL</b>.
     * @param {Integer} idCmdFirst Type: <b>UINT</b>
     * 
     * The ID of the first menu item.
     * @param {Integer} idCmdLast Type: <b>UINT</b>
     * 
     * The ID of the last menu item.
     * @returns {IContextMenu} Type: <b><a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a>*</b>
     * 
     * If successful, returns an <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu">IContextMenu</a> pointer. On failure, returns <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shfind_initmenupopup
     * @since windows5.1.2600
     */
    static SHFind_InitMenuPopup(hmenu, hwndOwner, idCmdFirst, idCmdLast) {
        hmenu := hmenu is Win32Handle ? NumGet(hmenu, "ptr") : hmenu
        hwndOwner := hwndOwner is Win32Handle ? NumGet(hwndOwner, "ptr") : hwndOwner

        result := DllCall("SHELL32.dll\SHFind_InitMenuPopup", "ptr", hmenu, "ptr", hwndOwner, "uint", idCmdFirst, "uint", idCmdLast, "ptr")
        return result
    }

    /**
     * Creates a new instance of the default Shell folder view object. It is recommended that you use SHCreateShellFolderView rather than this function.
     * @param {Pointer<CSFV>} pcsfv Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-csfv">CSFV</a>*</b>
     * 
     * Pointer to a structure that describes the details used in creating this instance of the Shell folder view object.
     * @returns {IShellView} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a>**</b>
     * 
     * The address of an <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview">IShellView</a> interface pointer that, when this function returns successfully, points to the new view object. On failure, this value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreateshellfolderviewex
     * @since windows5.0
     */
    static SHCreateShellFolderViewEx(pcsfv) {
        result := DllCall("SHELL32.dll\SHCreateShellFolderViewEx", "ptr", pcsfv, "ptr*", &ppsv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IShellView(ppsv)
    }

    /**
     * SHGetSetSettings may be altered or unavailable.
     * @param {Pointer<SHELLSTATEA>} lpss Type: <b>LPSHELLSTATE</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shellstatea">SHELLSTATE</a> structure that provides or receives the Shell state settings.
     * @param {Integer} dwMask Type: <b>DWORD</b>
     * 
     * One or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/ssf-constants">SSF</a> flags that indicate which settings should be set or retrieved.
     * @param {BOOL} bSet Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> to indicate that the contents of <i>lpss</i> should be used to set the Shell settings, <b>FALSE</b> to indicate that the Shell settings should be retrieved to <i>lpss</i>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetsetsettings
     * @since windows5.1.2600
     */
    static SHGetSetSettings(lpss, dwMask, bSet) {
        DllCall("SHELL32.dll\SHGetSetSettings", "ptr", lpss, "uint", dwMask, "int", bSet)
    }

    /**
     * Retrieves the current Shell option settings.
     * @param {Pointer<SHELLFLAGSTATE>} psfs Type: <b>LPSHELLFLAGSTATE</b>
     * 
     * The address of a <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ns-shlobj_core-shellflagstate">SHELLFLAGSTATE</a> structure that receives the Shell option settings.
     * @param {Integer} dwMask Type: <b>DWORD</b>
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetsettings
     * @since windows5.0
     */
    static SHGetSettings(psfs, dwMask) {
        DllCall("SHELL32.dll\SHGetSettings", "ptr", psfs, "uint", dwMask)
    }

    /**
     * Takes a pointer to a fully qualified item identifier list (PIDL), and returns a specified interface pointer on the parent object.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * The item's PIDL.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * The <b>REFIID</b> of one of the interfaces exposed by the item's parent object.
     * @param {Pointer<Pointer<Void>>} ppv Type: <b>VOID**</b>
     * 
     * A pointer to the interface specified by <i>riid</i>. You must release the object when you are finished.
     * @param {Pointer<Pointer<ITEMIDLIST>>} ppidlLast Type: <b>PCUITEMID_CHILD*</b>
     * 
     * The item's PIDL relative to the parent folder. This PIDL can be used with many of the methods supported by the parent folder's interfaces. If you set <i>ppidlLast</i> to <b>NULL</b>, the PIDL is not returned.
     * 
     * 
     * 
     * <div class="alert"><b>Note</b><b>SHBindToParent</b> does not allocate a new PIDL; it simply receives a pointer through this parameter. Therefore, you are not responsible for freeing this resource.</div>
     * <div></div>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shbindtoparent
     * @since windows5.0
     */
    static SHBindToParent(pidl, riid, ppv, ppidlLast) {
        ppvMarshal := ppv is VarRef ? "ptr*" : "ptr"
        ppidlLastMarshal := ppidlLast is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\SHBindToParent", "ptr", pidl, "ptr", riid, ppvMarshal, ppv, ppidlLastMarshal, ppidlLast, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Given a Shell namespace item specified in the form of a folder, and an item identifier list relative to that folder, this function binds to the parent of the namespace item and optionally returns a pointer to the final component of the item identifier list.
     * @param {IShellFolder} psfRoot Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to a Shell folder object. If <i>psfRoot</i> is <b>NULL</b>, indicates that the IDList passed is relative to the desktop.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A PIDL to bind to, relative to <i>psfRoot</i>. If <i>psfRoot</i> is <b>NULL</b>, this is an absolute IDList relative to the desktop folder.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired interface ID. This is typically IID_IShellFolder or IID_IShellFolder2, but can be anything supported by the target folder.
     * @param {Pointer<Pointer<Void>>} ppv Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder2">IShellFolder2</a>, but can be anything supported by the target folder.
     * @param {Pointer<Pointer<ITEMIDLIST>>} ppidlLast Type: <b>PCUITEMID_CHILD*</b>
     * 
     * A pointer to the last ID of the <i>pidl</i> parameter, and is a child ID relative to the parent folder returned in <i>ppv</i>. This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shbindtofolderidlistparent
     * @since windows6.0.6000
     */
    static SHBindToFolderIDListParent(psfRoot, pidl, riid, ppv, ppidlLast) {
        ppvMarshal := ppv is VarRef ? "ptr*" : "ptr"
        ppidlLastMarshal := ppidlLast is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\SHBindToFolderIDListParent", "ptr", psfRoot, "ptr", pidl, "ptr", riid, ppvMarshal, ppv, ppidlLastMarshal, ppidlLast, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Extends the SHBindToFolderIDListParent function by allowing the caller to specify a bind context.
     * @param {IShellFolder} psfRoot Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to a Shell folder object. If <i>psfRoot</i> is <b>NULL</b>, indicates that the IDList passed is relative to the desktop.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A PIDL to bind to, relative to <i>psfRoot</i>. If <i>psfRoot</i> is <b>NULL</b>, this is an absolute IDList relative to the desktop folder.
     * @param {IBindCtx} ppbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on a bind context object to be used during this operation. If this parameter is not used, set it to <b>NULL</b>, which is equivalent to calling the <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shbindtofolderidlistparent">SHBindToFolderIDListParent</a> function. Because support for <i>pbc</i> is optional for folder object implementations, some folders may not support the use of bind contexts.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired interface ID. This is typically IID_IShellFolder or IID_IShellFolder2, but can be anything supported by the target folder.
     * @param {Pointer<Pointer<Void>>} ppv Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> or <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder2">IShellFolder2</a>, but can be anything supported by the target folder.
     * @param {Pointer<Pointer<ITEMIDLIST>>} ppidlLast Type: <b>PCUITEMID_CHILD*</b>
     * 
     * A pointer to the last ID of the <i>pidl</i> parameter, and is a child ID relative to the parent folder returned in <i>ppv</i>. This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shbindtofolderidlistparentex
     * @since windows6.0.6000
     */
    static SHBindToFolderIDListParentEx(psfRoot, pidl, ppbc, riid, ppv, ppidlLast) {
        ppvMarshal := ppv is VarRef ? "ptr*" : "ptr"
        ppidlLastMarshal := ppidlLast is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\SHBindToFolderIDListParentEx", "ptr", psfRoot, "ptr", pidl, "ptr", ppbc, "ptr", riid, ppvMarshal, ppv, ppidlLastMarshal, ppidlLast, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves and binds to a specified object by using the Shell namespace IShellFolder::BindToObject method.
     * @param {IShellFolder} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>. This parameter can be <b>NULL</b>.   If <i>psf</i> is <b>NULL</b>,  this indicates 
     * parameter <i>pidl</i> is relative to the desktop. In this case, <i>pidl</i> must specify an absolute <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a>.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * A pointer to a constant <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> to bind to that is relative to <i>psf</i>. If <i>psf</i> is <b>NULL</b>, this is an absolute <b>ITEMIDLIST</b> relative to the desktop folder.
     * @param {IBindCtx} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface on a bind context object to be used during this operation. If this parameter is not used, set it to <b>NULL</b>. Because support for <i>pbc</i> is optional for folder object implementations, some folders may not support the use of bind contexts.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Identifier of the interface to return.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer as specified in <i>riid</i> to the bound object. If an error occurs, contains a <b>NULL</b> pointer.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shbindtoobject
     * @since windows6.0.6000
     */
    static SHBindToObject(psf, pidl, pbc, riid) {
        result := DllCall("SHELL32.dll\SHBindToObject", "ptr", psf, "ptr", pidl, "ptr", pbc, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Translates a Shell namespace object's display name into an item identifier list and returns the attributes of the object. This function is the preferred method to convert a string to a pointer to an item identifier list (PIDL).
     * @param {PWSTR} pszName Type: <b>LPCWSTR</b>
     * 
     * A pointer to a zero-terminated wide string that contains the display name to parse.
     * @param {IBindCtx} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A bind context that controls the parsing operation. This parameter is normally set to <b>NULL</b>.
     * @param {Pointer<Pointer<ITEMIDLIST>>} ppidl Type: <b>PIDLIST_ABSOLUTE*</b>
     * 
     * The address of a pointer to a variable of type <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> that receives the item identifier list for the object. If an error occurs, then this parameter is set to <b>NULL</b>.
     * @param {Integer} sfgaoIn Type: <b>SFGAOF</b>
     * 
     * A <b>ULONG</b> value that specifies the attributes to query. To query for one or more attributes, initialize this parameter with the flags that represent the attributes of interest. For a list of available SFGAO flags, see <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">IShellFolder::GetAttributesOf</a>.
     * @param {Pointer<Integer>} psfgaoOut Type: <b>SFGAOF*</b>
     * 
     * A pointer to a <b>ULONG</b>. On return, those attributes that are true for the object and were requested in <i>sfgaoIn</i> are set. An object's attribute flags can be zero or a combination of SFGAO flags. For a list of available SFGAO flags, see <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">IShellFolder::GetAttributesOf</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shparsedisplayname
     * @since windows5.1.2600
     */
    static SHParseDisplayName(pszName, pbc, ppidl, sfgaoIn, psfgaoOut) {
        pszName := pszName is String ? StrPtr(pszName) : pszName

        ppidlMarshal := ppidl is VarRef ? "ptr*" : "ptr"
        psfgaoOutMarshal := psfgaoOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHELL32.dll\SHParseDisplayName", "ptr", pszName, "ptr", pbc, ppidlMarshal, ppidl, "uint", sfgaoIn, psfgaoOutMarshal, psfgaoOut, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Checks to see if the path exists.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.
     * @param {IUnknown} punkEnableModless Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface that specifies the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-ioleinplaceactiveobject">IOleInPlaceActiveObject</a> object that implements the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellview-enablemodeless">EnableModeless</a> method.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shpathprepareforwritea
     * @since windows5.0
     */
    static SHPathPrepareForWriteA(hwnd, punkEnableModless, pszPath, dwFlags) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHPathPrepareForWriteA", "ptr", hwnd, "ptr", punkEnableModless, "ptr", pszPath, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Checks to see if the path exists.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to a window that specifies the parent window to be used for any user interface windows that must be created. If set to <b>NULL</b>, user interface windows are not created.
     * @param {IUnknown} punkEnableModless Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface that specifies the <a href="https://docs.microsoft.com/windows/desktop/api/oleidl/nn-oleidl-ioleinplaceactiveobject">IOleInPlaceActiveObject</a> object that implements the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellview-enablemodeless">EnableModeless</a> method.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that specifies the path to be verified as valid for writing. This can be a UNC or file drive path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the path is available, or an error code otherwise. Note that a return value of S_OK does not mean that the medium is writable; it simply means that the path is available.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shpathprepareforwritew
     * @since windows5.0
     */
    static SHPathPrepareForWriteW(hwnd, punkEnableModless, pszPath, dwFlags) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHPathPrepareForWriteW", "ptr", hwnd, "ptr", punkEnableModless, "ptr", pszPath, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * SHCreateFileExtractIcon may be altered or unavailable.
     * @param {PWSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the file system object. The buffer must not exceed MAX_PATH characters in length.
     * @param {Integer} dwFileAttributes Type: <b>DWORD</b>
     * 
     * A combination of one or more file attribute flags (FILE_ATTRIBUTE_* values as defined in Winnt.h) that specify the type of object.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired interface ID of the icon extractor interface to create. This must be either IID_IExtractIconA or IID_IExtractIconW.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this function returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nn-shlobj_core-iextracticona">IExtractIcon</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shcreatefileextracticonw
     * @since windows5.1.2600
     */
    static SHCreateFileExtractIconW(pszFile, dwFileAttributes, riid) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHELL32.dll\SHCreateFileExtractIconW", "ptr", pszFile, "uint", dwFileAttributes, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Sets limits on valid characters for an edit control.
     * @param {HWND} hwndEdit Type: <b>HWND</b>
     * 
     * The handle of the edit control.
     * @param {IShellFolder} psf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface pointer. This object must also implement <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-iitemnamelimits">IItemNameLimits</a>, which supplies a list of invalid characters and a maximum name length.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shlimitinputedit
     * @since windows5.0
     */
    static SHLimitInputEdit(hwndEdit, psf) {
        hwndEdit := hwndEdit is Win32Handle ? NumGet(hwndEdit, "ptr") : hwndEdit

        result := DllCall("SHELL32.dll\SHLimitInputEdit", "ptr", hwndEdit, "ptr", psf, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * SHGetAttributesFromDataObject may be altered or unavailable.
     * @param {IDataObject} pdo Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * The data object from which to retrieve the information.
     * @param {Integer} dwAttributeMask Type: <b>DWORD</b>
     * 
     * One or more of the <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">SFGAO</a> flags that indicate which pieces of information the calling application wants to retrieve.
     * @param {Pointer<Integer>} pdwAttributes Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that, when this function returns successfully, receives one or more <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof">SFGAO</a> flags that indicate the attributes, among those requested, that are common to all items in <i>pdo</i>. This pointer can be <b>NULL</b> if this information is not needed.
     * @param {Pointer<Integer>} pcItems Type: <b>UINT*</b>
     * 
     * A pointer to a <b>UINT</b> that, when this function returns successfully, receives the number of PIDLs in the data object pointed to by <i>pdo</i>. This pointer can be <b>NULL</b> if this information is not needed.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * This function can return one of these values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Success.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object is not a system data object. In this case, <i>pdwAttributes</i> is set to 0.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shgetattributesfromdataobject
     * @since windows5.1.2600
     */
    static SHGetAttributesFromDataObject(pdo, dwAttributeMask, pdwAttributes, pcItems) {
        pdwAttributesMarshal := pdwAttributes is VarRef ? "uint*" : "ptr"
        pcItemsMarshal := pcItems is VarRef ? "uint*" : "ptr"

        result := DllCall("SHELL32.dll\SHGetAttributesFromDataObject", "ptr", pdo, "uint", dwAttributeMask, pdwAttributesMarshal, pdwAttributes, pcItemsMarshal, pcItems, "int")
        return result
    }

    /**
     * SHMapPIDLToSystemImageListIndex may be altered or unavailable.
     * @param {IShellFolder} pshf Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a>*</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder">IShellFolder</a> interface pointer for the folder that contains the item.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {Pointer<Integer>} piIndexSel Type: <b>int*</b>
     * 
     * A pointer to an <b>int</b> that, when this function returns successfully, receives the index of the item's <b>open</b> icon in the system image list. If the item does not have a special <b>open</b> icon then the index of its normal icon is returned. If the <b>open</b> icon exists and cannot be obtained, then the value pointed to by <i>piIndex</i> is set to -1. This parameter can be <b>NULL</b> if the calling application is not interested in the <b>open</b> icon.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the item's normal icon in the system image list if successful, or -1 otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shmappidltosystemimagelistindex
     * @since windows5.1.2600
     */
    static SHMapPIDLToSystemImageListIndex(pshf, pidl, piIndexSel) {
        piIndexSelMarshal := piIndexSel is VarRef ? "int*" : "ptr"

        result := DllCall("SHELL32.dll\SHMapPIDLToSystemImageListIndex", "ptr", pshf, "ptr", pidl, piIndexSelMarshal, piIndexSel, "int")
        return result
    }

    /**
     * Takes the string form of a class identifier (CLSID) and creates the corresponding CLSID.
     * @param {PWSTR} psz Type: <b>PCWSTR</b>
     * 
     * A Unicode string that contains the CLSID in the format, <c>{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</c>.
     * @param {Pointer<Guid>} pclsid Type: <b>CLSID*</b>
     * 
     * A pointer to a CLSID value that, when this function returns successfully, receives the converted string as a CLSID.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-shclsidfromstring
     * @since windows5.0
     */
    static SHCLSIDFromString(psz, pclsid) {
        psz := psz is String ? StrPtr(psz) : psz

        result := DllCall("SHELL32.dll\SHCLSIDFromString", "ptr", psz, "ptr", pclsid, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * PickIconDlg may be altered or unavailable.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window. This value can be <b>NULL</b>.
     * @param {PWSTR} pszIconPath Type: <b>PWSTR</b>
     * 
     * A pointer to a string that contains the null-terminated, fully qualified path of the default resource that contains the icons. If the user chooses a different resource in the dialog, this buffer contains the path of that file when the function returns. This buffer should be at least MAX_PATH characters in length, or the returned path may be truncated. You should verify that the path is valid before using it.
     * @param {Integer} cchIconPath Type: <b>UINT</b>
     * 
     * The number of characters in <i>pszIconPath</i>, including the terminating <b>NULL</b> character.
     * @param {Pointer<Integer>} piIconIndex Type: <b>int*</b>
     * 
     * A pointer to an integer that on entry specifies the index of the initial selection and, when this function returns successfully, receives the index of the icon that was selected.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns 1 if successful; otherwise, 0.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-pickicondlg
     * @since windows5.1.2600
     */
    static PickIconDlg(hwnd, pszIconPath, cchIconPath, piIconIndex) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        piIconIndexMarshal := piIconIndex is VarRef ? "int*" : "ptr"

        result := DllCall("SHELL32.dll\PickIconDlg", "ptr", hwnd, "ptr", pszIconPath, "uint", cchIconPath, piIconIndexMarshal, piIconIndex, "int")
        return result
    }

    /**
     * Creates a unique name for a stream or storage object from a template.
     * @param {IStorage} pstgParent Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> object.
     * @param {PWSTR} pszFileSpec Type: <b>PCWSTR</b>
     * 
     * The format or template for the name of the stream or storage object.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * 
     * The access mode to use when opening the stream or storage object. For more information and descriptions of the possible values, see STGM Constants.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>, typically IID_IStorage or IID_IStream.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istorage">IStorage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj_core/nf-shlobj_core-stgmakeuniquename
     * @since windows6.1
     */
    static StgMakeUniqueName(pstgParent, pszFileSpec, grfMode, riid) {
        pszFileSpec := pszFileSpec is String ? StrPtr(pszFileSpec) : pszFileSpec

        result := DllCall("SHELL32.dll\StgMakeUniqueName", "ptr", pstgParent, "ptr", pszFileSpec, "uint", grfMode, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Enables asynchronous register and deregister of a thread.
     * @param {Integer} status Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-scnrt_status">SCNRT_STATUS</a></b>
     * 
     * Indicates whether the function is being used to register or deregister the thread. One of the values of <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/ne-shlobj_core-scnrt_status">SCNRT_STATUS</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-shchangenotifyregisterthread
     * @since windows6.0.6000
     */
    static SHChangeNotifyRegisterThread(status) {
        DllCall("SHELL32.dll\SHChangeNotifyRegisterThread", "int", status)
    }

    /**
     * 
     * @param {PWSTR} psz 
     * @returns {String} Nothing - always returns an empty string
     */
    static PathQualify(psz) {
        psz := psz is String ? StrPtr(psz) : psz

        DllCall("SHELL32.dll\PathQualify", "ptr", psz)
    }

    /**
     * PathIsSlow may be altered or unavailable.
     * @param {PSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the fully qualified path of the file.
     * @param {Integer} dwAttr Type: <b>DWORD</b>
     * 
     * The file attributes, if known; otherwise, pass 1 and this function gets the attributes by calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>. See <b>GetFileAttributes</b> for a list of file attributes.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the connection is high-latency; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-pathisslowa
     * @since windows5.1.2600
     */
    static PathIsSlowA(pszFile, dwAttr) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHELL32.dll\PathIsSlowA", "ptr", pszFile, "uint", dwAttr, "int")
        return result
    }

    /**
     * PathIsSlow may be altered or unavailable.
     * @param {PWSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the fully qualified path of the file.
     * @param {Integer} dwAttr Type: <b>DWORD</b>
     * 
     * The file attributes, if known; otherwise, pass 1 and this function gets the attributes by calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>. See <b>GetFileAttributes</b> for a list of file attributes.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the connection is high-latency; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-pathissloww
     * @since windows5.1.2600
     */
    static PathIsSlowW(pszFile, dwAttr) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHELL32.dll\PathIsSlowW", "ptr", pszFile, "uint", dwAttr, "int")
        return result
    }

    /**
     * SHCreatePropSheetExtArray may be altered or unavailable.
     * @param {HKEY} hKey Type: <b>HKEY</b>
     * 
     * The registry root key that contains the subkey with the property sheet extension handlers. For instance, <b>HKEY_LOCAL_MACHINE</b>.
     * @param {PWSTR} pszSubKey Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated string specifying the name of the subkey that contains <b>shellex</b>&#92;<b>PropertySheetHandlers</b>.
     * 
     * For example, if  <i>hkey</i> specifies HKEY_LOCAL_MACHINE and <i>pszSubkey</i> specifies "Software\Microsoft\Windows\CurrentVersion\Controls Folder\Display", this function returns property sheet extension handlers using the following subkey:
     * 
     * 
     * <pre xml:space="preserve"><b>HKEY_LOCAL_MACHINE</b>
     * <b>SOFTWARE</b>
     * <b>Microsoft</b>
     * <b>Windows</b>
     * <b>CurrentVersion</b>
     * <b>Controls Folder</b>
     * <b>Display</b>
     * <b>shellex</b>
     * <b>PropertySheetHandlers</b></pre>
     * @param {Integer} max_iface Type: <b>UINT</b>
     * 
     * The maximum number of property sheet handlers to be returned.
     * @returns {HPSXA} Type: <b>HPSXA</b>
     * 
     * Returns a handle to an array of property sheet handlers. Pass this value to <a href="/windows/desktop/api/shlobj_core/nf-shlobj_core-shaddfrompropsheetextarray">SHAddFromPropSheetExtArray</a>. You do not access this value directly.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-shcreatepropsheetextarray
     * @since windows5.1.2600
     */
    static SHCreatePropSheetExtArray(hKey, pszSubKey, max_iface) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHELL32.dll\SHCreatePropSheetExtArray", "ptr", hKey, "ptr", pszSubKey, "uint", max_iface, "ptr")
        resultHandle := HPSXA({Value: result}, True)
        return resultHandle
    }

    /**
     * SHOpenPropSheet may be altered or unavailable.
     * @param {PWSTR} pszCaption Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string that contains the caption for the property sheet. This value can be <b>NULL</b> if no caption is needed.
     * @param {Pointer<HKEY>} ahkeys Type: <b>HKEY[]</b>
     * 
     * An array of registry keys that represent the <b>CLSID</b>s of the individual property sheets.
     * @param {Integer} ckeys Type: <b>UINT</b>
     * 
     * <b>UINT</b> value that specifies the number of property sheets in the array specified by <i>ahkeys</i>.
     * @param {Pointer<Guid>} pclsidDefault Type: <b>const CLSID*</b>
     * 
     * A pointer to the default <b>CLSID</b>. This value can be <b>NULL</b>.
     * @param {IDataObject} pdtobj Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>, an OLE object that can be used to carry out actions on the property sheet(s).
     * @param {IShellBrowser} psb Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellbrowser">IShellBrowser</a>*</b>
     * 
     * Not used.
     * @param {PWSTR} pStartPage Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string that specifies the start page. This value can be <b>NULL</b>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the property sheet was successfully created; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-shopenpropsheetw
     * @since windows5.1.2600
     */
    static SHOpenPropSheetW(pszCaption, ahkeys, ckeys, pclsidDefault, pdtobj, psb, pStartPage) {
        pszCaption := pszCaption is String ? StrPtr(pszCaption) : pszCaption
        pStartPage := pStartPage is String ? StrPtr(pStartPage) : pStartPage

        result := DllCall("SHELL32.dll\SHOpenPropSheetW", "ptr", pszCaption, "ptr", ahkeys, "uint", ckeys, "ptr", pclsidDefault, "ptr", pdtobj, "ptr", psb, "ptr", pStartPage, "int")
        return result
    }

    /**
     * Displays a standard message box that can be used to notify a user that an application has been updated.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {PWSTR} pszDistUnit Type: <b>PCWSTR</b>
     * 
     * The string value containing the identifier for the code distribution unit. For ActiveX controls, <i>pszDistUnit</i> is typically a GUID.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Must be set to zero.
     * @param {Pointer<SOFTDISTINFO>} psdi Type: <b>LPSOFTDISTINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/urlmon/ns-urlmon-softdistinfo">SOFTDISTINFO</a> structure that, when this method returns successfully, receives the update information. The <b>cbSize</b> member must be initialized to the <c>sizeof(SOFTDISTINFO)</c>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDNO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user clicked the <b>Do Not Update</b> button on the dialog box.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDYES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user clicked the <b>Update Now</b> or <b>About Update</b> button. The application should navigate to the HTML page referred to by the <b>szHREF</b> member of the structure pointed to by <i>psdi</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDIGNORE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no pending software update.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDABORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-softwareupdatemessagebox
     * @since windows5.0
     */
    static SoftwareUpdateMessageBox(hWnd, pszDistUnit, dwFlags, psdi) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd
        pszDistUnit := pszDistUnit is String ? StrPtr(pszDistUnit) : pszDistUnit

        result := DllCall("SHDOCVW.dll\SoftwareUpdateMessageBox", "ptr", hWnd, "ptr", pszDistUnit, "uint", dwFlags, "ptr", psdi, "uint")
        return result
    }

    /**
     * Displays a merged property sheet for a set of files. Property values common to all the files are shown while those that differ display the string (multiple values).
     * @param {IDataObject} pdtobj Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-idataobject">IDataObject</a>*</b>
     * 
     * A pointer to a data object that supplies the PIDLs of all of the files for which to display the merged property sheet. The data object must use the <a href="https://docs.microsoft.com/windows/desktop/shell/clipboard">CFSTR_SHELLIDLIST</a> clipboard format. The parent folder's implementation of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof">IShellFolder::GetDisplayNameOf</a> must return a fully qualified file system path for each item in response to the <a href="https://docs.microsoft.com/windows/win32/api/shobjidl_core/ne-shobjidl_core-_shgdnf">SHGDN_FORPARSING</a> flag.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Must be set to 0.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-shmultifileproperties
     * @since windows5.0
     */
    static SHMultiFileProperties(pdtobj, dwFlags) {
        result := DllCall("SHELL32.dll\SHMultiFileProperties", "ptr", pdtobj, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deprecated. Creates a QueryCancelAutoPlay class moniker, which can then be used to register the IQueryCancelAutoPlay handler in the running object table (ROT).
     * @returns {IMoniker} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a>**</b>
     * 
     * The address of a <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-imoniker">IMoniker</a> interface pointer that, when this function returns successfully, receives the <b>QueryCancelAutoPlay</b> class moniker. If this function call fails, this value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlobj/nf-shlobj-shcreatequerycancelautoplaymoniker
     * @since windows5.1.2600
     */
    static SHCreateQueryCancelAutoPlayMoniker() {
        result := DllCall("SHELL32.dll\SHCreateQueryCancelAutoPlayMoniker", "ptr*", &ppmoniker := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IMoniker(ppmoniker)
    }

    /**
     * 
     * @param {PWSTR} pszFilename 
     * @param {Pointer<BOOL>} pfParsePrivacyPreferences 
     * @param {Pointer<BOOL>} pfParsePerSiteRules 
     * @returns {BOOL} 
     */
    static ImportPrivacySettings(pszFilename, pfParsePrivacyPreferences, pfParsePerSiteRules) {
        pszFilename := pszFilename is String ? StrPtr(pszFilename) : pszFilename

        pfParsePrivacyPreferencesMarshal := pfParsePrivacyPreferences is VarRef ? "int*" : "ptr"
        pfParsePerSiteRulesMarshal := pfParsePerSiteRules is VarRef ? "int*" : "ptr"

        result := DllCall("SHDOCVW.dll\ImportPrivacySettings", "ptr", pszFilename, pfParsePrivacyPreferencesMarshal, pfParsePrivacyPreferences, pfParsePerSiteRulesMarshal, pfParsePerSiteRules, "int")
        return result
    }

    /**
     * Gets the preferred scale factor for a display device.
     * @param {Integer} deviceType Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-display_device_type">DISPLAY_DEVICE_TYPE</a></b>
     * 
     * The value that indicates the type of the display device.
     * @returns {Integer} Type: <b><a href="/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">DEVICE_SCALE_FACTOR</a></b>
     * 
     * A value that indicates the scale factor that should be used with the specified <a href="/windows/desktop/api/shellscalingapi/ne-shellscalingapi-display_device_type">DISPLAY_DEVICE_TYPE</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SCALE_100_PERCENT</b></dt>
     * <dt>100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use a scale factor of 1x.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SCALE_140_PERCENT</b></dt>
     * <dt>140</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use a scale factor of 1.4x.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SCALE_180_PERCENT</b></dt>
     * <dt>180</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use a scale factor of 1.8x.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellscalingapi/nf-shellscalingapi-getscalefactorfordevice
     * @since windows8.0
     */
    static GetScaleFactorForDevice(deviceType) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-0.dll\GetScaleFactorForDevice", "int", deviceType, "int")
        return result
    }

    /**
     * Registers a window to receive callbacks when scaling information changes.
     * @param {Integer} displayDevice Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-display_device_type">DISPLAY_DEVICE_TYPE</a></b>
     * 
     * The enum value that indicates which display device to receive notifications about.
     * @param {HWND} hwndNotify Type: <b>HWND</b>
     * 
     * The handle of the window that will receive the notifications.
     * @param {Integer} uMsgNotify Type: <b>UINT</b>
     * 
     * An application-defined message that is passed to the window specified by <i>hwndNotify</i> when scaling information changes.  Typically, this should be set to <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-app">WM_APP</a>+<i>x</i>, where <i>x</i> is an integer value.
     * @returns {Integer} Type: <b>DWORD*</b>
     * 
     * Pointer to a value that, when this function returns successfully, receives a registration token. This token is used to revoke notifications by calling <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-revokescalechangenotifications">RevokeScaleChangeNotifications</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shellscalingapi/nf-shellscalingapi-registerscalechangenotifications
     * @since windows8.0
     */
    static RegisterScaleChangeNotifications(displayDevice, hwndNotify, uMsgNotify) {
        hwndNotify := hwndNotify is Win32Handle ? NumGet(hwndNotify, "ptr") : hwndNotify

        result := DllCall("api-ms-win-shcore-scaling-l1-1-0.dll\RegisterScaleChangeNotifications", "int", displayDevice, "ptr", hwndNotify, "uint", uMsgNotify, "uint*", &pdwCookie := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pdwCookie
    }

    /**
     * Revokes the registration of a window, preventing it from receiving callbacks when scaling information changes.
     * @param {Integer} displayDevice Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/ne-shellscalingapi-display_device_type">DISPLAY_DEVICE_TYPE</a></b>
     * 
     * The enum value that indicates which display device to receive notifications about.
     * @param {Integer} dwCookie Type: <b>DWORD</b>
     * 
     * The registration token returned by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-registerscalechangenotifications">RegisterScaleChangeNotifications</a>.
     * @returns {HRESULT} Type: <b>STDAPI</b>
     * 
     * If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellscalingapi/nf-shellscalingapi-revokescalechangenotifications
     * @since windows8.0
     */
    static RevokeScaleChangeNotifications(displayDevice, dwCookie) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-0.dll\RevokeScaleChangeNotifications", "int", displayDevice, "uint", dwCookie, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Gets the scale factor of a specific monitor. This function replaces GetScaleFactorForDevice.
     * @param {HMONITOR} hMon The monitor's handle.
     * @returns {Integer} When this function returns successfully, this value points to one of the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">DEVICE_SCALE_FACTOR</a> values that specify the scale factor of the specified monitor.
     *                         
     * 
     * If the function call fails, this value points to a valid scale factor so that apps can opt to continue on with incorrectly sized resources.
     * @see https://docs.microsoft.com/windows/win32/api//shellscalingapi/nf-shellscalingapi-getscalefactorformonitor
     * @since windows8.1
     */
    static GetScaleFactorForMonitor(hMon) {
        hMon := hMon is Win32Handle ? NumGet(hMon, "ptr") : hMon

        result := DllCall("api-ms-win-shcore-scaling-l1-1-1.dll\GetScaleFactorForMonitor", "ptr", hMon, "int*", &pScale := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pScale
    }

    /**
     * Registers for an event that is triggered when the scale has possibly changed. This function replaces RegisterScaleChangeNotifications.
     * @param {HANDLE} hEvent Handle of the event to register for scale change notifications.
     * @returns {Pointer} When this function returns successfully, this value receives the address of a pointer to a cookie that can be used later to unregister for the scale change notifications through <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-unregisterscalechangeevent">UnregisterScaleChangeEvent</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shellscalingapi/nf-shellscalingapi-registerscalechangeevent
     * @since windows8.1
     */
    static RegisterScaleChangeEvent(hEvent) {
        hEvent := hEvent is Win32Handle ? NumGet(hEvent, "ptr") : hEvent

        result := DllCall("api-ms-win-shcore-scaling-l1-1-1.dll\RegisterScaleChangeEvent", "ptr", hEvent, "ptr*", &pdwCookie := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pdwCookie
    }

    /**
     * Unregisters for the scale change event registered through RegisterScaleChangeEvent. This function replaces RevokeScaleChangeNotifications.
     * @param {Pointer} dwCookie A pointer to the cookie retrieved in the call to <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-registerscalechangeevent">RegisterScaleChangeEvent</a>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellscalingapi/nf-shellscalingapi-unregisterscalechangeevent
     * @since windows8.1
     */
    static UnregisterScaleChangeEvent(dwCookie) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-1.dll\UnregisterScaleChangeEvent", "ptr", dwCookie, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Integer} param0 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/shellscalingapi/nf-shellscalingapi-getdpiforshelluicomponent
     * @since windows8.1
     */
    static GetDpiForShellUIComponent(param0) {
        result := DllCall("api-ms-win-shcore-scaling-l1-1-2.dll\GetDpiForShellUIComponent", "int", param0, "uint")
        return result
    }

    /**
     * Parses a Unicode command line string and returns an array of pointers to the command line arguments, along with a count of such arguments, in a way that is similar to the standard C run-time argv and argc values.
     * @param {PWSTR} lpCmdLine Type: <b>LPCWSTR</b>
     * 
     * Pointer to a <b>null</b>-terminated Unicode string that contains the full command line. If this parameter is an empty string the function returns the path to the current executable file.
     * @param {Pointer<Integer>} pNumArgs Type: <b>int*</b>
     * 
     * Pointer to an <b>int</b> that receives the number of array elements returned, similar to <i>argc</i>.
     * @returns {Pointer<PWSTR>} Type: <b>LPWSTR*</b>
     * 
     * A pointer to an array of <b>LPWSTR</b> values, similar to <i>argv</i>.
     * 
     *                     
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-commandlinetoargvw
     * @since windows5.0
     */
    static CommandLineToArgvW(lpCmdLine, pNumArgs) {
        lpCmdLine := lpCmdLine is String ? StrPtr(lpCmdLine) : lpCmdLine

        pNumArgsMarshal := pNumArgs is VarRef ? "int*" : "ptr"

        A_LastError := 0

        result := DllCall("SHELL32.dll\CommandLineToArgvW", "ptr", lpCmdLine, pNumArgsMarshal, pNumArgs, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the names of dropped files that result from a successful drag-and-drop operation.
     * @param {HDROP} hDrop Type: <b>HDROP</b>
     * 
     * Identifier of the structure that contains the file names of the dropped files.
     * @param {Integer} iFile Type: <b>UINT</b>
     * 
     * Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.
     * @param {PSTR} lpszFile Type: <b>LPTSTR</b>
     * 
     * The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.
     * @param {Integer} cch Type: <b>UINT</b>
     * 
     * The size, in characters, of the <i>lpszFile</i> buffer.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * A nonzero value indicates a successful call.
     * 
     * When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.
     * 
     * If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.
     * 
     * If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-dragqueryfilea
     * @since windows5.1.2600
     */
    static DragQueryFileA(hDrop, iFile, lpszFile, cch) {
        hDrop := hDrop is Win32Handle ? NumGet(hDrop, "ptr") : hDrop
        lpszFile := lpszFile is String ? StrPtr(lpszFile) : lpszFile

        result := DllCall("SHELL32.dll\DragQueryFileA", "ptr", hDrop, "uint", iFile, "ptr", lpszFile, "uint", cch, "uint")
        return result
    }

    /**
     * Retrieves the names of dropped files that result from a successful drag-and-drop operation.
     * @param {HDROP} hDrop Type: <b>HDROP</b>
     * 
     * Identifier of the structure that contains the file names of the dropped files.
     * @param {Integer} iFile Type: <b>UINT</b>
     * 
     * Index of the file to query. If the value of this parameter is 0xFFFFFFFF, <b>DragQueryFile</b> returns a count of the files dropped. If the value of this parameter is between zero and the total number of files dropped, <b>DragQueryFile</b> copies the file name with the corresponding value to the buffer pointed to by the <i>lpszFile</i> parameter.
     * @param {PWSTR} lpszFile Type: <b>LPTSTR</b>
     * 
     * The address of a buffer that receives the file name of a dropped file when the function returns. This file name is a null-terminated string. If this parameter is <b>NULL</b>, <b>DragQueryFile</b> returns the required size, in characters, of this buffer.
     * @param {Integer} cch Type: <b>UINT</b>
     * 
     * The size, in characters, of the <i>lpszFile</i> buffer.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * A nonzero value indicates a successful call.
     * 
     * When the function copies a file name to the buffer, the return value is a count of the characters copied, not including the terminating null character.
     * 
     * If the index value is 0xFFFFFFFF, the return value is a count of the dropped files. Note that the index variable itself returns unchanged, and therefore remains 0xFFFFFFFF.
     * 
     * If the index value is between zero and the total number of dropped files, and the <i>lpszFile</i> buffer address is <b>NULL</b>, the return value is the required size, in characters, of the buffer, <i>not including</i> the terminating null character.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-dragqueryfilew
     * @since windows5.1.2600
     */
    static DragQueryFileW(hDrop, iFile, lpszFile, cch) {
        hDrop := hDrop is Win32Handle ? NumGet(hDrop, "ptr") : hDrop
        lpszFile := lpszFile is String ? StrPtr(lpszFile) : lpszFile

        result := DllCall("SHELL32.dll\DragQueryFileW", "ptr", hDrop, "uint", iFile, "ptr", lpszFile, "uint", cch, "uint")
        return result
    }

    /**
     * Retrieves the position of the mouse pointer at the time a file was dropped during a drag-and-drop operation.
     * @param {HDROP} hDrop Type: <b>HDROP</b>
     * 
     * Handle of the drop structure that describes the dropped file.
     * @param {Pointer<POINT>} ppt Type: <b><a href="https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/previous-versions/dd162805(v=vs.85)">POINT</a> structure that, when this function returns successfully, receives the coordinates of the mouse pointer at the time the file was dropped.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the drop occurred in the client area of the window; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-dragquerypoint
     * @since windows5.1.2600
     */
    static DragQueryPoint(hDrop, ppt) {
        hDrop := hDrop is Win32Handle ? NumGet(hDrop, "ptr") : hDrop

        result := DllCall("SHELL32.dll\DragQueryPoint", "ptr", hDrop, "ptr", ppt, "int")
        return result
    }

    /**
     * Releases memory that the system allocated for use in transferring file names to the application.
     * @param {HDROP} hDrop Type: <b>HDROP</b>
     * 
     * Identifier of the structure that describes dropped files. This handle is retrieved from the <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-dragfinish
     * @since windows5.1.2600
     */
    static DragFinish(hDrop) {
        hDrop := hDrop is Win32Handle ? NumGet(hDrop, "ptr") : hDrop

        DllCall("SHELL32.dll\DragFinish", "ptr", hDrop)
    }

    /**
     * Registers whether a window accepts dropped files.
     * @remarks
     * 
     * An application that calls <b>DragAcceptFiles</b> with the <i>fAccept</i> parameter set to <b>TRUE</b> has identified itself as able to process the <a href="https://docs.microsoft.com/windows/desktop/shell/wm-dropfiles">WM_DROPFILES</a> message from File Manager.
     * 
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * The identifier of the window that is registering whether it will accept dropped files.
     * @param {BOOL} fAccept Type: <b>BOOL</b>
     * 
     * A value that indicates if the window identified by the <i>hWnd</i> parameter accepts dropped files. This value is <b>TRUE</b> to accept dropped files or <b>FALSE</b> to discontinue accepting dropped files.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-dragacceptfiles
     * @since windows5.1.2600
     */
    static DragAcceptFiles(hWnd, fAccept) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        DllCall("SHELL32.dll\DragAcceptFiles", "ptr", hWnd, "int", fAccept)
    }

    /**
     * Performs an operation on a specified file.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.
     * @param {PSTR} lpOperation Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:
     * @param {PSTR} lpFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.
     * @param {PSTR} lpParameters Type: <b>LPCTSTR</b>
     * 
     * If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.
     * @param {PSTR} lpDirectory Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.
     * @param {Integer} nShowCmd Type: <b>INT</b>
     * 
     * The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function.
     * @returns {HINSTANCE} Type: <b>HINSTANCE</b>
     * 
     * If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>int</b> and compared to either 32 or the following error codes below.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system is out of memory or resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The .exe file is invalid (non-Win32 .exe or error in .exe image).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system denied access to the specified file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ASSOCINCOMPLETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file name association is incomplete or invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDEBUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction could not be completed because other DDE transactions were being processed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDEFAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDETIMEOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction could not be completed because the request timed out.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DLLNOTFOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified DLL was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_FNF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_NOASSOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_OOM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_PNF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_SHARE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A sharing violation occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shellexecutea
     * @since windows5.1.2600
     */
    static ShellExecuteA(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        lpOperation := lpOperation is String ? StrPtr(lpOperation) : lpOperation
        lpFile := lpFile is String ? StrPtr(lpFile) : lpFile
        lpParameters := lpParameters is String ? StrPtr(lpParameters) : lpParameters
        lpDirectory := lpDirectory is String ? StrPtr(lpDirectory) : lpDirectory

        result := DllCall("SHELL32.dll\ShellExecuteA", "ptr", hwnd, "ptr", lpOperation, "ptr", lpFile, "ptr", lpParameters, "ptr", lpDirectory, "int", nShowCmd, "ptr")
        resultHandle := HINSTANCE({Value: result}, False)
        return resultHandle
    }

    /**
     * Performs an operation on a specified file.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window used for displaying a UI or error messages. This value can be <b>NULL</b> if the operation is not associated with a window.
     * @param {PWSTR} lpOperation Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string, referred to in this case as a <i>verb</i>, that specifies the action to be performed. The set of available verbs depends on the particular file or folder. Generally, the actions available from an object's shortcut menu are available verbs. The following verbs are commonly used:
     * @param {PWSTR} lpFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the file or object on which to execute the specified verb. To specify a Shell namespace object, pass the fully qualified parse name. Note that not all verbs are supported on all objects. For example, not all document types support the "print" verb. If a relative path is used for the <i>lpDirectory</i> parameter do not use a relative path for <i>lpFile</i>.
     * @param {PWSTR} lpParameters Type: <b>LPCTSTR</b>
     * 
     * If <i>lpFile</i> specifies an executable file, this parameter is a pointer to a <b>null</b>-terminated string that specifies the parameters to be passed to the application. The format of this string is determined by the verb that is to be invoked. If <i>lpFile</i> specifies a document file, <i>lpParameters</i> should be <b>NULL</b>.
     * @param {PWSTR} lpDirectory Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the default (working) directory for the action. If this value is <b>NULL</b>, the current working directory is used. If a relative path is provided at <i>lpFile</i>, do not use a relative path for <i>lpDirectory</i>.
     * @param {Integer} nShowCmd Type: <b>INT</b>
     * 
     * The flags that specify how an application is to be displayed when it is opened. If <i>lpFile</i> specifies a document file, the flag is simply passed to the associated application. It is up to the application to decide how to handle it. It can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function.
     * @returns {HINSTANCE} Type: <b>HINSTANCE</b>
     * 
     * If the function succeeds, it returns a value greater than 32. If the function fails, it returns an error value that indicates the cause of the failure. The return value is cast as an HINSTANCE for backward compatibility with 16-bit Windows applications. It is not a true HINSTANCE, however. It can be cast only to an <b>int</b> and compared to either 32 or the following error codes below.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system is out of memory or resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BAD_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The .exe file is invalid (non-Win32 .exe or error in .exe image).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system denied access to the specified file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ASSOCINCOMPLETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file name association is incomplete or invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDEBUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction could not be completed because other DDE transactions were being processed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDEFAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DDETIMEOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The DDE transaction could not be completed because the request timed out.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_DLLNOTFOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified DLL was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_FNF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_NOASSOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_OOM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_PNF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_SHARE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A sharing violation occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shellexecutew
     * @since windows5.1.2600
     */
    static ShellExecuteW(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        lpOperation := lpOperation is String ? StrPtr(lpOperation) : lpOperation
        lpFile := lpFile is String ? StrPtr(lpFile) : lpFile
        lpParameters := lpParameters is String ? StrPtr(lpParameters) : lpParameters
        lpDirectory := lpDirectory is String ? StrPtr(lpDirectory) : lpDirectory

        result := DllCall("SHELL32.dll\ShellExecuteW", "ptr", hwnd, "ptr", lpOperation, "ptr", lpFile, "ptr", lpParameters, "ptr", lpDirectory, "int", nShowCmd, "ptr")
        resultHandle := HINSTANCE({Value: result}, False)
        return resultHandle
    }

    /**
     * Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.
     * @param {PSTR} lpFile Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.
     * @param {PSTR} lpDirectory Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.
     * @param {PSTR} lpResult Type: <b>LPTSTR</b>
     * 
     * The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.
     * @returns {HINSTANCE} Type: <b>HINSTANCE</b>
     * 
     * Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.
     * 					
     *                     
     * 
     * The following table lists possible error values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_FNF</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_PNF</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ACCESSDENIED</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file cannot be accessed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_OOM</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory or resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_NOASSOC</b></dt>
     * <dt>31</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no association for the specified file type with an executable file.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-findexecutablea
     * @since windows5.1.2600
     */
    static FindExecutableA(lpFile, lpDirectory, lpResult) {
        lpFile := lpFile is String ? StrPtr(lpFile) : lpFile
        lpDirectory := lpDirectory is String ? StrPtr(lpDirectory) : lpDirectory
        lpResult := lpResult is String ? StrPtr(lpResult) : lpResult

        result := DllCall("SHELL32.dll\FindExecutableA", "ptr", lpFile, "ptr", lpDirectory, "ptr", lpResult, "ptr")
        resultHandle := HINSTANCE({Value: result}, True)
        return resultHandle
    }

    /**
     * Retrieves the name of and handle to the executable (.exe) file associated with a specific document file.
     * @param {PWSTR} lpFile Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string that specifies a file name. This file should be a document.
     * @param {PWSTR} lpDirectory Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string that specifies the default directory. This value can be <b>NULL</b>.
     * @param {PWSTR} lpResult Type: <b>LPTSTR</b>
     * 
     * The address of a buffer that receives the file name of the associated executable file. This file name is a <b>null</b>-terminated string that specifies the executable file started when an "open" by association is run on the file specified in the <i>lpFile</i> parameter. Put simply, this is the application that is launched when the document file is directly double-clicked or when <b>Open</b> is chosen from the file's shortcut menu. This parameter must contain a valid non-<b>null</b> value and is assumed to be of length MAX_PATH. Responsibility for validating the value is left to the programmer.
     * @returns {HINSTANCE} Type: <b>HINSTANCE</b>
     * 
     * Returns a value greater than 32 if successful, or a value less than or equal to 32 representing an error.
     * 					
     *                     
     * 
     * The following table lists possible error values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_FNF</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_PNF</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified path is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_ACCESSDENIED</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file cannot be accessed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_OOM</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory or resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>SE_ERR_NOASSOC</b></dt>
     * <dt>31</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no association for the specified file type with an executable file.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-findexecutablew
     * @since windows5.1.2600
     */
    static FindExecutableW(lpFile, lpDirectory, lpResult) {
        lpFile := lpFile is String ? StrPtr(lpFile) : lpFile
        lpDirectory := lpDirectory is String ? StrPtr(lpDirectory) : lpDirectory
        lpResult := lpResult is String ? StrPtr(lpResult) : lpResult

        result := DllCall("SHELL32.dll\FindExecutableW", "ptr", lpFile, "ptr", lpDirectory, "ptr", lpResult, "ptr")
        resultHandle := HINSTANCE({Value: result}, True)
        return resultHandle
    }

    /**
     * Displays a ShellAbout dialog box.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * A window handle to a parent window. This parameter can be <b>NULL</b>.
     * @param {PSTR} szApp Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".
     * 
     *                     
     * 
     * <b>Windows2000, WindowsXP, Windows Server2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writeable.
     * 
     * <b>WindowsVista, Windows Server2008</b>: This string cannot exceed 200 characters in length.
     * @param {PSTR} szOtherStuff Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.
     * @param {HICON} hIcon Type: <b>HICON</b>
     * 
     * The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.
     * @returns {Integer} Type: <b>int</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shellabouta
     * @since windows5.1.2600
     */
    static ShellAboutA(hWnd, szApp, szOtherStuff, hIcon) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd
        szApp := szApp is String ? StrPtr(szApp) : szApp
        szOtherStuff := szOtherStuff is String ? StrPtr(szOtherStuff) : szOtherStuff
        hIcon := hIcon is Win32Handle ? NumGet(hIcon, "ptr") : hIcon

        result := DllCall("SHELL32.dll\ShellAboutA", "ptr", hWnd, "ptr", szApp, "ptr", szOtherStuff, "ptr", hIcon, "int")
        return result
    }

    /**
     * Displays a ShellAbout dialog box.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * A window handle to a parent window. This parameter can be <b>NULL</b>.
     * @param {PWSTR} szApp Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains text to be displayed in the title bar of the <b>ShellAbout</b> dialog box and on the first line of the dialog box after the text "Microsoft". If the text contains a separator (#) that divides it into two parts, the function displays the first part in the title bar and the second part on the first line after the text "Microsoft".
     * 
     *                     
     * 
     * <b>Windows2000, WindowsXP, Windows Server2003</b>: If the string pointed to by this parameter contains a separator (#), then the string must be writeable.
     * 
     * <b>WindowsVista, Windows Server2008</b>: This string cannot exceed 200 characters in length.
     * @param {PWSTR} szOtherStuff Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains text to be displayed in the dialog box after the version and copyright information. This parameter can be <b>NULL</b>.
     * @param {HICON} hIcon Type: <b>HICON</b>
     * 
     * The handle of an icon that the function displays in the dialog box. This parameter can be <b>NULL</b>, in which case the function displays the Windows icon.
     * @returns {Integer} Type: <b>int</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shellaboutw
     * @since windows5.1.2600
     */
    static ShellAboutW(hWnd, szApp, szOtherStuff, hIcon) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd
        szApp := szApp is String ? StrPtr(szApp) : szApp
        szOtherStuff := szOtherStuff is String ? StrPtr(szOtherStuff) : szOtherStuff
        hIcon := hIcon is Win32Handle ? NumGet(hIcon, "ptr") : hIcon

        result := DllCall("SHELL32.dll\ShellAboutW", "ptr", hWnd, "ptr", szApp, "ptr", szOtherStuff, "ptr", hIcon, "int")
        return result
    }

    /**
     * Creates a duplicate of a specified icon.
     * @param {HICON} hIcon Type: <b>HICON</b>
     * 
     * Handle to the icon to be duplicated.
     * @returns {HICON} Type: <b>HICON</b>
     * 
     * If successful, the function returns the handle to the new icon that was created; otherwise, <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-duplicateicon
     * @since windows5.1.2600
     */
    static DuplicateIcon(hIcon) {
        static hInst := 0 ;Reserved parameters must always be NULL

        hIcon := hIcon is Win32Handle ? NumGet(hIcon, "ptr") : hIcon

        result := DllCall("SHELL32.dll\DuplicateIcon", "ptr", hInst, "ptr", hIcon, "ptr")
        resultHandle := HICON({Value: result}, True)
        return resultHandle
    }

    /**
     * Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.
     * @param {PSTR} pszIconPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file. 
     * 
     *                     
     * 
     * When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.
     * @param {Pointer<Integer>} piIcon Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained. 
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.
     * @returns {HICON} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.
     * 
     * 					
     * 
     * If the function fails, the return value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-extractassociatedicona
     * @since windows5.1.2600
     */
    static ExtractAssociatedIconA(pszIconPath, piIcon) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        piIconMarshal := piIcon is VarRef ? "ushort*" : "ptr"

        result := DllCall("SHELL32.dll\ExtractAssociatedIconA", "ptr", hInst, "ptr", pszIconPath, piIconMarshal, piIcon, "ptr")
        resultHandle := HICON({Value: result}, True)
        return resultHandle
    }

    /**
     * Gets a handle to an icon stored as a resource in a file or an icon stored in a file's associated executable file.
     * @param {PWSTR} pszIconPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file. 
     * 
     *                     
     * 
     * When this function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.
     * @param {Pointer<Integer>} piIcon Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained. 
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.
     * @returns {HICON} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is an icon handle. If the icon is extracted from an associated executable file, the function stores the full path and file name of the executable file in the string pointed to by <i>lpIconPath</i>, and stores the icon's identifier in the <b>WORD</b> pointed to by <i>lpiIcon</i>.
     * 
     * 					
     * 
     * If the function fails, the return value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-extractassociatediconw
     * @since windows5.1.2600
     */
    static ExtractAssociatedIconW(pszIconPath, piIcon) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        piIconMarshal := piIcon is VarRef ? "ushort*" : "ptr"

        result := DllCall("SHELL32.dll\ExtractAssociatedIconW", "ptr", hInst, "ptr", pszIconPath, piIconMarshal, piIcon, "ptr")
        resultHandle := HICON({Value: result}, True)
        return resultHandle
    }

    /**
     * ExtractAssociatedIconEx may be altered or unavailable.
     * @param {PSTR} pszIconPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file. 
     * 
     *                     
     * 
     * When this function returns, if the icon handle was obtained from an executable file (either an executable file directly pointed to by this parameter or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.
     * @param {Pointer<Integer>} piIconIndex Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained. 
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.
     * @param {Pointer<Integer>} piIconId Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the ID of the icon whose handle is to be obtained.
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's ID within that file.
     * @returns {HICON} Type: <b>HICON</b>
     * 
     * Returns the icon's handle if successful, otherwise <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-extractassociatediconexa
     * @since windows5.1.2600
     */
    static ExtractAssociatedIconExA(pszIconPath, piIconIndex, piIconId) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        piIconIndexMarshal := piIconIndex is VarRef ? "ushort*" : "ptr"
        piIconIdMarshal := piIconId is VarRef ? "ushort*" : "ptr"

        result := DllCall("SHELL32.dll\ExtractAssociatedIconExA", "ptr", hInst, "ptr", pszIconPath, piIconIndexMarshal, piIconIndex, piIconIdMarshal, piIconId, "ptr")
        resultHandle := HICON({Value: result}, True)
        return resultHandle
    }

    /**
     * ExtractAssociatedIconEx may be altered or unavailable.
     * @param {PWSTR} pszIconPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a string that, on entry, specifies the full path and file name of the file that contains the icon. The function extracts the icon handle from that file, or from an executable file associated with that file. 
     * 
     *                     
     * 
     * When this function returns, if the icon handle was obtained from an executable file (either an executable file directly pointed to by this parameter or an associated executable file) the function stores the full path and file name of that executable in the buffer pointed to by this parameter.
     * @param {Pointer<Integer>} piIconIndex Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the index of the icon whose handle is to be obtained. 
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's index in that file.
     * @param {Pointer<Integer>} piIconId Type: <b>LPWORD</b>
     * 
     * Pointer to a <b>WORD</b> value that, on entry, specifies the ID of the icon whose handle is to be obtained.
     * 
     *                     
     * 
     * When the function returns, if the icon handle was obtained from an executable file (either an executable file pointed to by <i>lpIconPath</i> or an associated executable file), this value points to the icon's ID within that file.
     * @returns {HICON} Type: <b>HICON</b>
     * 
     * Returns the icon's handle if successful, otherwise <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-extractassociatediconexw
     * @since windows5.1.2600
     */
    static ExtractAssociatedIconExW(pszIconPath, piIconIndex, piIconId) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszIconPath := pszIconPath is String ? StrPtr(pszIconPath) : pszIconPath

        piIconIndexMarshal := piIconIndex is VarRef ? "ushort*" : "ptr"
        piIconIdMarshal := piIconId is VarRef ? "ushort*" : "ptr"

        result := DllCall("SHELL32.dll\ExtractAssociatedIconExW", "ptr", hInst, "ptr", pszIconPath, piIconIndexMarshal, piIconIndex, piIconIdMarshal, piIconId, "ptr")
        resultHandle := HICON({Value: result}, True)
        return resultHandle
    }

    /**
     * Gets a handle to an icon from the specified executable file, DLL, or icon file. To retrieve an array of handles to large or small icons, use the ExtractIconEx function.
     * @param {PSTR} pszExeFileName Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.
     * @param {Integer} nIconIndex Type: <b>UINT</b>
     * 
     * Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file. 
     *                     
     *                     
     * 
     * If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.
     * 
     * If this value is a negative number not equal to 1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use 3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-extracticonexa">ExtractIconEx</a> function.
     * @returns {HICON} Type: <b>HICON</b>
     * 
     * The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-extracticona
     * @since windows5.1.2600
     */
    static ExtractIconA(pszExeFileName, nIconIndex) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszExeFileName := pszExeFileName is String ? StrPtr(pszExeFileName) : pszExeFileName

        result := DllCall("SHELL32.dll\ExtractIconA", "ptr", hInst, "ptr", pszExeFileName, "uint", nIconIndex, "ptr")
        resultHandle := HICON({Value: result}, True)
        return resultHandle
    }

    /**
     * Gets a handle to an icon from the specified executable file, DLL, or icon file. To retrieve an array of handles to large or small icons, use the ExtractIconEx function.
     * @param {PWSTR} pszExeFileName Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file.
     * @param {Integer} nIconIndex Type: <b>UINT</b>
     * 
     * Specifies the zero-based index of the icon to retrieve. For example, if this value is 0, the function returns a handle to the first icon in the specified file. 
     *                     
     *                     
     * 
     * If this value is -1, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ICO file, the return value is 1.
     * 
     * If this value is a negative number not equal to 1, the function returns a handle to the icon in the specified file whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, you should use 3 to extract the icon whose resource identifier is 3. To extract the icon whose resource identifier is 1, use the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-extracticonexa">ExtractIconEx</a> function.
     * @returns {HICON} Type: <b>HICON</b>
     * 
     * The return value is a handle to an icon. If the file specified was not an executable file, DLL, or icon file, the return is 1. If no icons were found in the file, the return value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-extracticonw
     * @since windows5.1.2600
     */
    static ExtractIconW(pszExeFileName, nIconIndex) {
        static hInst := 0 ;Reserved parameters must always be NULL

        pszExeFileName := pszExeFileName is String ? StrPtr(pszExeFileName) : pszExeFileName

        result := DllCall("SHELL32.dll\ExtractIconW", "ptr", hInst, "ptr", pszExeFileName, "uint", nIconIndex, "ptr")
        resultHandle := HICON({Value: result}, True)
        return resultHandle
    }

    /**
     * Sends an appbar message to the system.
     * @param {Integer} dwMessage Type: <b>DWORD</b>
     * @param {Pointer<APPBARDATA>} pData Type: <b>PAPPBARDATA</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-appbardata">APPBARDATA</a> structure. The content of the structure on entry and on exit depends on the value set in the <i>dwMessage</i> parameter. See the individual message pages for specifics.
     * @returns {Pointer} Type: <b>UINT_PTR</b>
     * 
     * This function returns a message-dependent value. For more information, see the Windows SDK documentation for the specific appbar message sent. Links to those documents are given in the See Also section.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shappbarmessage
     * @since windows5.1.2600
     */
    static SHAppBarMessage(dwMessage, pData) {
        result := DllCall("SHELL32.dll\SHAppBarMessage", "uint", dwMessage, "ptr", pData, "ptr")
        return result
    }

    /**
     * Parses an input string that contains references to one or more environment variables and replaces them with their fully expanded values.
     * @param {PSTR} pszSrc Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that contains references to one or more environment variables, each in the following form. Case is ignored. 
     *     					
     *                         
     * 
     * <pre class="syntax" xml:space="preserve"><c>%VariableName%</c></pre>
     * Any character in the string that is not enclosed in '%' characters is ignored and returned unchanged. Therefore, if your string contains multiple environment variables, you can use any character other than '%' as a separator, including spaces or no separator.
     * 
     * When this function returns successfully, each %<i>VariableName</i>% is replaced with its expanded value. The replacement rules are the same as those used by the command interpreter. If the variable name is not found on the system, the %<i>variableName</i>% is left as it was submitted on entry.
     * 
     * If this function fails due to the expanded string being too large for the buffer, the contents of this buffer are left unchanged.
     * @param {Integer} cchSrc Type: <b>UINT</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>pszSrc</i>. Note that the buffer must be large enough to hold the returned string.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the expanded string fits in the buffer, <b>TRUE</b> is returned in the HIWORD and the length, in characters, of the new <i>pszSrc</i> is returned in the LOWORD. 
     *                     
     *                         
     * 
     * If the expanded string is too large for the buffer, <b>FALSE</b> is returned in the HIWORD and <i>cchSrc</i> in the LOWORD.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-doenvironmentsubsta
     * @since windows5.1.2600
     */
    static DoEnvironmentSubstA(pszSrc, cchSrc) {
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHELL32.dll\DoEnvironmentSubstA", "ptr", pszSrc, "uint", cchSrc, "uint")
        return result
    }

    /**
     * Parses an input string that contains references to one or more environment variables and replaces them with their fully expanded values.
     * @param {PWSTR} pszSrc Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that contains references to one or more environment variables, each in the following form. Case is ignored. 
     *     					
     *                         
     * 
     * <pre class="syntax" xml:space="preserve"><c>%VariableName%</c></pre>
     * Any character in the string that is not enclosed in '%' characters is ignored and returned unchanged. Therefore, if your string contains multiple environment variables, you can use any character other than '%' as a separator, including spaces or no separator.
     * 
     * When this function returns successfully, each %<i>VariableName</i>% is replaced with its expanded value. The replacement rules are the same as those used by the command interpreter. If the variable name is not found on the system, the %<i>variableName</i>% is left as it was submitted on entry.
     * 
     * If this function fails due to the expanded string being too large for the buffer, the contents of this buffer are left unchanged.
     * @param {Integer} cchSrc Type: <b>UINT</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>pszSrc</i>. Note that the buffer must be large enough to hold the returned string.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the expanded string fits in the buffer, <b>TRUE</b> is returned in the HIWORD and the length, in characters, of the new <i>pszSrc</i> is returned in the LOWORD. 
     *                     
     *                         
     * 
     * If the expanded string is too large for the buffer, <b>FALSE</b> is returned in the HIWORD and <i>cchSrc</i> in the LOWORD.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-doenvironmentsubstw
     * @since windows5.1.2600
     */
    static DoEnvironmentSubstW(pszSrc, cchSrc) {
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHELL32.dll\DoEnvironmentSubstW", "ptr", pszSrc, "uint", cchSrc, "uint")
        return result
    }

    /**
     * The ExtractIconEx function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file.
     * @param {PSTR} lpszFile Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.
     * @param {Integer} nIconIndex Type: <b>int</b>
     * 
     * Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file. 
     *     
     *                         
     * 
     * If this value is 1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.
     * 
     *  If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.
     * @param {Pointer<HICON>} phiconLarge Type: <b>HICON*</b>
     * 
     * Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.
     * @param {Pointer<HICON>} phiconSmall Type: <b>HICON*</b>
     * 
     * Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.
     * @param {Integer} nIcons Type: <b>UINT</b>
     * 
     * The number of icons to extract from the file.
     * @returns {Integer} Type: **UINT**
     * 
     * If the *nIconIndex* parameter is -1 and both the *phiconLarge* and *phiconSmall* parameters are **NULL**, then the return value is the number of icons contained in the specified file.
     * 
     * If the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**, the return value is the number of icons successfully extracted from the file.
     * 
     * > [!NOTE]
     * > If the function encounters an error, it returns **UINT_MAX**. In this case, you can call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md) to retrieve the error code. For example, this function returns **UINT_MAX** if the file specified by *lpszFile* cannot be found while the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**. In this case, **GetLastError** returns **ERROR_FILE_NOT_FOUND** (2).
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-extracticonexa
     * @since windows5.1.2600
     */
    static ExtractIconExA(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons) {
        lpszFile := lpszFile is String ? StrPtr(lpszFile) : lpszFile

        A_LastError := 0

        result := DllCall("SHELL32.dll\ExtractIconExA", "ptr", lpszFile, "int", nIconIndex, "ptr", phiconLarge, "ptr", phiconSmall, "uint", nIcons, "uint")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The ExtractIconEx function creates an array of handles to large or small icons extracted from the specified executable file, DLL, or icon file.
     * @param {PWSTR} lpszFile Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the name of an executable file, DLL, or icon file from which icons will be extracted.
     * @param {Integer} nIconIndex Type: <b>int</b>
     * 
     * Specifies the zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon in the specified file. 
     *     
     *                         
     * 
     * If this value is 1 and <i>phiconLarge</i> and <i>phiconSmall</i> are both <b>NULL</b>, the function returns the total number of icons in the specified file. If the file is an executable file or DLL, the return value is the number of RT_GROUP_ICON resources. If the file is an .ico file, the return value is 1.
     * 
     *  If this value is a negative number and either <i>phiconLarge</i> or <i>phiconSmall</i> is not <b>NULL</b>, the function begins by extracting the icon whose resource identifier is equal to the absolute value of <i>nIconIndex</i>. For example, use -3 to extract the icon whose resource identifier is 3.
     * @param {Pointer<HICON>} phiconLarge Type: <b>HICON*</b>
     * 
     * Pointer to an array of icon handles that receives handles to the large icons extracted from the file. If this parameter is <b>NULL</b>, no large icons are extracted from the file.
     * @param {Pointer<HICON>} phiconSmall Type: <b>HICON*</b>
     * 
     * Pointer to an array of icon handles that receives handles to the small icons extracted from the file. If this parameter is <b>NULL</b>, no small icons are extracted from the file.
     * @param {Integer} nIcons Type: <b>UINT</b>
     * 
     * The number of icons to extract from the file.
     * @returns {Integer} Type: **UINT**
     * 
     * If the *nIconIndex* parameter is -1 and both the *phiconLarge* and *phiconSmall* parameters are **NULL**, then the return value is the number of icons contained in the specified file.
     * 
     * If the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**, the return value is the number of icons successfully extracted from the file.
     * 
     * > [!NOTE]
     * > If the function encounters an error, it returns **UINT_MAX**. In this case, you can call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md) to retrieve the error code. For example, this function returns **UINT_MAX** if the file specified by *lpszFile* cannot be found while the *nIconIndex* parameter is any value other than -1 and either *phiconLarge* or *phiconSmall* is not **NULL**. In this case, **GetLastError** returns **ERROR_FILE_NOT_FOUND** (2).
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-extracticonexw
     * @since windows5.1.2600
     */
    static ExtractIconExW(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons) {
        lpszFile := lpszFile is String ? StrPtr(lpszFile) : lpszFile

        A_LastError := 0

        result := DllCall("SHELL32.dll\ExtractIconExW", "ptr", lpszFile, "int", nIconIndex, "ptr", phiconLarge, "ptr", phiconSmall, "uint", nIcons, "uint")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Copies, moves, renames, or deletes a file system object. This function has been replaced in WindowsVista by IFileOperation.
     * @param {Pointer<SHFILEOPSTRUCTA>} lpFileOp Type: <b>LPSHFILEOPSTRUCT</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero. 
     * 
     *                     
     * 
     * It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <a href="/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a>. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.
     * 
     * Do not use <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> with the return values of this function.
     * 
     * To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:
     * 
     * <ul>
     * <li>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</li>
     * <li>These error codes are subject to change and have historically done so.</li>
     * <li>These values are provided only as an aid in debugging. They should not be regarded as definitive.</li>
     * </ul>
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error Code</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>DE_SAMEFILE</td>
     * <td>0x71</td>
     * <td>The source and destination files are the same file.</td>
     * </tr>
     * <tr>
     * <td>DE_MANYSRC1DEST</td>
     * <td>0x72</td>
     * <td>Multiple file paths were specified in the source buffer, but only one destination file path.</td>
     * </tr>
     * <tr>
     * <td>DE_DIFFDIR</td>
     * <td>0x73</td>
     * <td>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</td>
     * </tr>
     * <tr>
     * <td>DE_ROOTDIR</td>
     * <td>0x74</td>
     * <td>The source is a root directory, which cannot be moved or renamed.</td>
     * </tr>
     * <tr>
     * <td>DE_OPCANCELLED</td>
     * <td>0x75</td>
     * <td>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</td>
     * </tr>
     * <tr>
     * <td>DE_DESTSUBTREE</td>
     * <td>0x76</td>
     * <td>The destination is a subtree of the source.</td>
     * </tr>
     * <tr>
     * <td>DE_ACCESSDENIEDSRC</td>
     * <td>0x78</td>
     * <td>Security settings denied access to the source.</td>
     * </tr>
     * <tr>
     * <td>DE_PATHTOODEEP</td>
     * <td>0x79</td>
     * <td>The source or destination path exceeded or would exceed MAX_PATH.</td>
     * </tr>
     * <tr>
     * <td>DE_MANYDEST</td>
     * <td>0x7A</td>
     * <td>The operation involved multiple destination paths, which can fail in the case of a move operation.</td>
     * </tr>
     * <tr>
     * <td>DE_INVALIDFILES</td>
     * <td>0x7C</td>
     * <td>The path in the source or destination or both was invalid.</td>
     * </tr>
     * <tr>
     * <td>DE_DESTSAMETREE</td>
     * <td>0x7D</td>
     * <td>The source and destination have the same parent folder.</td>
     * </tr>
     * <tr>
     * <td>DE_FLDDESTISFILE</td>
     * <td>0x7E</td>
     * <td>The destination path is an existing file.</td>
     * </tr>
     * <tr>
     * <td>DE_FILEDESTISFLD</td>
     * <td>0x80</td>
     * <td>The destination path is an existing folder.</td>
     * </tr>
     * <tr>
     * <td>DE_FILENAMETOOLONG</td>
     * <td>0x81</td>
     * <td>The name of the file exceeds MAX_PATH.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_CDROM</td>
     * <td>0x82</td>
     * <td>The destination is a read-only CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_DVD</td>
     * <td>0x83</td>
     * <td>The destination is a read-only DVD, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_CDRECORD</td>
     * <td>0x84</td>
     * <td>The destination is a writable CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_FILE_TOO_LARGE</td>
     * <td>0x85</td>
     * <td>The file involved in the operation is too large for the destination media or file system.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_CDROM</td>
     * <td>0x86</td>
     * <td>The source is a read-only CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_DVD</td>
     * <td>0x87</td>
     * <td>The source is a read-only DVD, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_CDRECORD</td>
     * <td>0x88</td>
     * <td>The source is a writable CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_ERROR_MAX</td>
     * <td>0xB7</td>
     * <td>MAX_PATH was exceeded during the operation.</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>0x402</td>
     * <td>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on WindowsVista and later.</td>
     * </tr>
     * <tr>
     * <td>ERRORONDEST</td>
     * <td>0x10000</td>
     * <td>An unspecified error occurred on the destination.</td>
     * </tr>
     * <tr>
     * <td>DE_ROOTDIR | ERRORONDEST</td>
     * <td>0x10074</td>
     * <td>Destination is a root directory and cannot be renamed.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shfileoperationa
     * @since windows5.1.2600
     */
    static SHFileOperationA(lpFileOp) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\SHFileOperationA", "ptr", lpFileOp, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Copies, moves, renames, or deletes a file system object. On WindowsVista and later releases, we recommend that you use IFileOperation instead of this function.
     * @param {Pointer<SHFILEOPSTRUCTW>} lpFileOp Type: <b>LPSHFILEOPSTRUCT</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a> structure that contains information this function needs to carry out the specified operation. This parameter must contain a valid value that is not <b>NULL</b>. You are responsible for validating the value. If you do not validate it, you will experience unexpected results.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero. 
     * 
     *                     
     * 
     * It is good practice to examine the value of the <b>fAnyOperationsAborted</b> member of the <a href="/windows/desktop/api/shellapi/ns-shellapi-shfileopstructa">SHFILEOPSTRUCT</a>. <b>SHFileOperation</b> can return 0 for success if the user cancels the operation. If you do not check <b>fAnyOperationsAborted</b> as well as the return value, you cannot know that the function accomplished the full task you asked of it and you might proceed under incorrect assumptions.
     * 
     * Do not use <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> with the return values of this function.
     * 
     * To examine the nonzero values for troubleshooting purposes, they largely map to those defined in Winerror.h. However, several of its possible return values are based on pre-Win32 error codes, which in some cases overlap the later Winerror.h values without matching their meaning. Those particular values are detailed here, and <i>for these specific values only</i> these meanings should be accepted over the Winerror.h codes. However, these values are provided with these warnings:
     * 
     * <ul>
     * <li>These are pre-Win32 error codes and are no longer supported or defined in any public header file. To use them, you must either define them yourself or compare against the numerical value.</li>
     * <li>These error codes are subject to change and have historically done so.</li>
     * <li>These values are provided only as an aid in debugging. They should not be regarded as definitive.</li>
     * </ul>
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error Code</th>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>DE_SAMEFILE</td>
     * <td>0x71</td>
     * <td>The source and destination files are the same file.</td>
     * </tr>
     * <tr>
     * <td>DE_MANYSRC1DEST</td>
     * <td>0x72</td>
     * <td>Multiple file paths were specified in the source buffer, but only one destination file path.</td>
     * </tr>
     * <tr>
     * <td>DE_DIFFDIR</td>
     * <td>0x73</td>
     * <td>Rename operation was specified but the destination path is a different directory. Use the move operation instead.</td>
     * </tr>
     * <tr>
     * <td>DE_ROOTDIR</td>
     * <td>0x74</td>
     * <td>The source is a root directory, which cannot be moved or renamed.</td>
     * </tr>
     * <tr>
     * <td>DE_OPCANCELLED</td>
     * <td>0x75</td>
     * <td>The operation was canceled by the user, or silently canceled if the appropriate flags were supplied to <b>SHFileOperation</b>.</td>
     * </tr>
     * <tr>
     * <td>DE_DESTSUBTREE</td>
     * <td>0x76</td>
     * <td>The destination is a subtree of the source.</td>
     * </tr>
     * <tr>
     * <td>DE_ACCESSDENIEDSRC</td>
     * <td>0x78</td>
     * <td>Security settings denied access to the source.</td>
     * </tr>
     * <tr>
     * <td>DE_PATHTOODEEP</td>
     * <td>0x79</td>
     * <td>The source or destination path exceeded or would exceed MAX_PATH.</td>
     * </tr>
     * <tr>
     * <td>DE_MANYDEST</td>
     * <td>0x7A</td>
     * <td>The operation involved multiple destination paths, which can fail in the case of a move operation.</td>
     * </tr>
     * <tr>
     * <td>DE_INVALIDFILES</td>
     * <td>0x7C</td>
     * <td>The path in the source or destination or both was invalid.</td>
     * </tr>
     * <tr>
     * <td>DE_DESTSAMETREE</td>
     * <td>0x7D</td>
     * <td>The source and destination have the same parent folder.</td>
     * </tr>
     * <tr>
     * <td>DE_FLDDESTISFILE</td>
     * <td>0x7E</td>
     * <td>The destination path is an existing file.</td>
     * </tr>
     * <tr>
     * <td>DE_FILEDESTISFLD</td>
     * <td>0x80</td>
     * <td>The destination path is an existing folder.</td>
     * </tr>
     * <tr>
     * <td>DE_FILENAMETOOLONG</td>
     * <td>0x81</td>
     * <td>The name of the file exceeds MAX_PATH.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_CDROM</td>
     * <td>0x82</td>
     * <td>The destination is a read-only CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_DVD</td>
     * <td>0x83</td>
     * <td>The destination is a read-only DVD, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_DEST_IS_CDRECORD</td>
     * <td>0x84</td>
     * <td>The destination is a writable CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_FILE_TOO_LARGE</td>
     * <td>0x85</td>
     * <td>The file involved in the operation is too large for the destination media or file system.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_CDROM</td>
     * <td>0x86</td>
     * <td>The source is a read-only CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_DVD</td>
     * <td>0x87</td>
     * <td>The source is a read-only DVD, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_SRC_IS_CDRECORD</td>
     * <td>0x88</td>
     * <td>The source is a writable CD-ROM, possibly unformatted.</td>
     * </tr>
     * <tr>
     * <td>DE_ERROR_MAX</td>
     * <td>0xB7</td>
     * <td>MAX_PATH was exceeded during the operation.</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>0x402</td>
     * <td>An unknown error occurred. This is typically due to an invalid path in the source or destination. This error does not occur on WindowsVista and later.</td>
     * </tr>
     * <tr>
     * <td>ERRORONDEST</td>
     * <td>0x10000</td>
     * <td>An unspecified error occurred on the destination.</td>
     * </tr>
     * <tr>
     * <td>DE_ROOTDIR | ERRORONDEST</td>
     * <td>0x10074</td>
     * <td>Destination is a root directory and cannot be renamed.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shfileoperationw
     * @since windows5.1.2600
     */
    static SHFileOperationW(lpFileOp) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\SHFileOperationW", "ptr", lpFileOp, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees a file name mapping object that was retrieved by the SHFileOperation function.
     * @param {HANDLE} hNameMappings Type: <b>HANDLE</b>
     * 
     * A handle to the file name mapping object to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shfreenamemappings
     * @since windows5.1.2600
     */
    static SHFreeNameMappings(hNameMappings) {
        hNameMappings := hNameMappings is Win32Handle ? NumGet(hNameMappings, "ptr") : hNameMappings

        DllCall("SHELL32.dll\SHFreeNameMappings", "ptr", hNameMappings)
    }

    /**
     * Performs an operation on a specified file.
     * @param {Pointer<SHELLEXECUTEINFOA>} pExecInfo Type: <b>SHELLEXECUTEINFO*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> structure that contains and receives information about the application being executed.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shellexecuteexa
     * @since windows5.1.2600
     */
    static ShellExecuteExA(pExecInfo) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\ShellExecuteExA", "ptr", pExecInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Performs an operation on a specified file.
     * @param {Pointer<SHELLEXECUTEINFOW>} pExecInfo Type: <b>SHELLEXECUTEINFO*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> structure that contains and receives information about the application being executed.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. Call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shellexecuteexw
     * @since windows5.1.2600
     */
    static ShellExecuteExW(pExecInfo) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\ShellExecuteExW", "ptr", pExecInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a new user-mode process and its primary thread to run a specified executable file.
     * @param {Pointer<SHCREATEPROCESSINFOW>} pscpi Type: <b>PSHCREATEPROCESSINFOW</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shcreateprocessinfow">SHCREATEPROCESSINFOW</a> structure with information on how to create the process.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> if not. To retrieve extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shcreateprocessasuserw
     * @since windows5.0
     */
    static SHCreateProcessAsUserW(pscpi) {
        A_LastError := 0

        result := DllCall("SHELL32.dll\SHCreateProcessAsUserW", "ptr", pscpi, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enforces strict validation of parameters used in a call to CreateProcess or ShellExecute.
     * @param {PWSTR} pszCmdTemplate Type: <b>PCWSTR</b>
     * 
     * A command line, which may or may not include parameters. If the parameters are substitution parameters, then <b>SHEvaluateSystemCommandTemplate</b> should be called before parameters have been replaced.
     * @param {Pointer<PWSTR>} ppszApplication Type: <b>PWSTR*</b>
     * 
     * A pointer to the verified path to the application. This value should be passed as the <i>lpApplication</i> parameter in a call to <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> or as the <i>lpFile</i> parameter in a call to <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">ShellExecute</a>. This resource is allocated using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>.
     * @param {Pointer<PWSTR>} ppszCommandLine Type: <b>PWSTR*</b>
     * 
     * A pointer to a command-line string template to be used in a call to <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>. Command-line parameters should be specified based on this template, and then passed as the <i>lpCommandLine</i> parameter to <b>CreateProcess</b>. It is guaranteed to be of a form that <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-pathgetargsa">PathGetArgs</a> can always read correctly. This resource is allocated using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>. 
     * 
     *                     
     * 
     * This parameter can be <b>NULL</b> if this function is not being used in association with a call to <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>.
     * @param {Pointer<PWSTR>} ppszParameters Type: <b>PWSTR*</b>
     * 
     * A pointer to a command-line string template to be used in a call to <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">ShellExecute</a>. Command-line parameters should be specified based on this template, and then passed as the <i>lpParameters</i> parameter to <b>ShellExecute</b>. This parameter is identical to calling <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-pathgetargsa">PathGetArgs</a>. This resource is allocated using <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>, and it is the responsibility of the caller to free the resource when it is no longer needed by calling <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a>. 
     * 
     *                     
     * 
     * This parameter can be <b>NULL</b> if this function is not being used in association with a call to <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shevaluatesystemcommandtemplate
     * @since windows6.0.6000
     */
    static SHEvaluateSystemCommandTemplate(pszCmdTemplate, ppszApplication, ppszCommandLine, ppszParameters) {
        pszCmdTemplate := pszCmdTemplate is String ? StrPtr(pszCmdTemplate) : pszCmdTemplate

        ppszApplicationMarshal := ppszApplication is VarRef ? "ptr*" : "ptr"
        ppszCommandLineMarshal := ppszCommandLine is VarRef ? "ptr*" : "ptr"
        ppszParametersMarshal := ppszParameters is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHELL32.dll\SHEvaluateSystemCommandTemplate", "ptr", pszCmdTemplate, ppszApplicationMarshal, ppszApplication, ppszCommandLineMarshal, ppszCommandLine, ppszParametersMarshal, ppszParameters, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves an object that implements an IQueryAssociations interface.
     * @param {Pointer<ASSOCIATIONELEMENT>} rgClasses Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-associationelement">ASSOCIATIONELEMENT</a>*</b>
     * 
     * A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-associationelement">ASSOCIATIONELEMENT</a> structures.
     * @param {Integer} cClasses Type: <b>ULONG</b>
     * 
     * The number of elements in the array pointed to by <i>rgClasses</i>.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the desired IID, normally IID_IQueryAssociations.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is normally <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-assoccreateforclasses
     * @since windows6.0.6000
     */
    static AssocCreateForClasses(rgClasses, cClasses, riid) {
        result := DllCall("SHELL32.dll\AssocCreateForClasses", "ptr", rgClasses, "uint", cClasses, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.
     * @param {PSTR} pszRootPath Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).
     * @param {Pointer<SHQUERYRBINFO>} pSHQueryRBInfo Type: <b>LPSHQUERYRBINFO</b>
     * 
     * The address of a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shqueryrbinfo">SHQUERYRBINFO</a> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shqueryrecyclebina
     * @since windows5.0
     */
    static SHQueryRecycleBinA(pszRootPath, pSHQueryRBInfo) {
        pszRootPath := pszRootPath is String ? StrPtr(pszRootPath) : pszRootPath

        result := DllCall("SHELL32.dll\SHQueryRecycleBinA", "ptr", pszRootPath, "ptr", pSHQueryRBInfo, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.
     * @param {PWSTR} pszRootPath Type: <b>LPCTSTR</b>
     * 
     * The address of a <b>null</b>-terminated string of maximum length MAX_PATH to contain the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names (C:\Windows\System...).
     * @param {Pointer<SHQUERYRBINFO>} pSHQueryRBInfo Type: <b>LPSHQUERYRBINFO</b>
     * 
     * The address of a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shqueryrbinfo">SHQUERYRBINFO</a> structure that receives the Recycle Bin information. The <b>cbSize</b> member of the structure must be set to the size of the structure before calling this API.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shqueryrecyclebinw
     * @since windows5.0
     */
    static SHQueryRecycleBinW(pszRootPath, pSHQueryRBInfo) {
        pszRootPath := pszRootPath is String ? StrPtr(pszRootPath) : pszRootPath

        result := DllCall("SHELL32.dll\SHQueryRecycleBinW", "ptr", pszRootPath, "ptr", pSHQueryRBInfo, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Empties the Recycle Bin on the specified drive.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.
     * @param {PSTR} pszRootPath Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system\. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shemptyrecyclebina
     * @since windows5.0
     */
    static SHEmptyRecycleBinA(hwnd, pszRootPath, dwFlags) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszRootPath := pszRootPath is String ? StrPtr(pszRootPath) : pszRootPath

        result := DllCall("SHELL32.dll\SHEmptyRecycleBinA", "ptr", hwnd, "ptr", pszRootPath, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Empties the Recycle Bin on the specified drive.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window of any dialog boxes that might be displayed during the operation. This parameter can be <b>NULL</b>.
     * @param {PWSTR} pszRootPath Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string of maximum length MAX_PATH that contains the path of the root drive on which the Recycle Bin is located. This parameter can contain the address of a string formatted with the drive, folder, and subfolder names, for example c:\windows\system\. It can also contain an empty string or <b>NULL</b>. If this value is an empty string or <b>NULL</b>, all Recycle Bins on all drives will be emptied.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shemptyrecyclebinw
     * @since windows5.0
     */
    static SHEmptyRecycleBinW(hwnd, pszRootPath, dwFlags) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszRootPath := pszRootPath is String ? StrPtr(pszRootPath) : pszRootPath

        result := DllCall("SHELL32.dll\SHEmptyRecycleBinW", "ptr", hwnd, "ptr", pszRootPath, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Checks the state of the computer for the current user to determine whether sending a notification is appropriate.
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-query_user_notification_state">QUERY_USER_NOTIFICATION_STATE</a>*</b>
     * 
     * When this function returns, contains a pointer to one of the values of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-query_user_notification_state">QUERY_USER_NOTIFICATION_STATE</a> enumeration.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shqueryusernotificationstate
     * @since windows6.0.6000
     */
    static SHQueryUserNotificationState() {
        result := DllCall("SHELL32.dll\SHQueryUserNotificationState", "int*", &pquns := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pquns
    }

    /**
     * Sends a message to the taskbar's status area.
     * @param {Integer} dwMessage Type: <b>DWORD</b>
     * @param {Pointer<NOTIFYICONDATAA>} lpData Type: <b>PNOTIFYICONDATA</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shell_notifyicona
     * @since windows5.1.2600
     */
    static Shell_NotifyIconA(dwMessage, lpData) {
        result := DllCall("SHELL32.dll\Shell_NotifyIconA", "uint", dwMessage, "ptr", lpData, "int")
        return result
    }

    /**
     * Sends a message to the taskbar's status area.
     * @param {Integer} dwMessage Type: <b>DWORD</b>
     * @param {Pointer<NOTIFYICONDATAW>} lpData Type: <b>PNOTIFYICONDATA</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyicondataa">NOTIFYICONDATA</a> structure. The content of the structure depends on the value of <i>dwMessage</i>. It can define an icon to add to the notification area, cause that icon to display a notification, or identify an icon to modify or delete.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise. If <i>dwMessage</i> is set to NIM_SETVERSION, the function returns <b>TRUE</b> if the version was successfully changed, or <b>FALSE</b> if the requested version is not supported.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shell_notifyiconw
     * @since windows5.1.2600
     */
    static Shell_NotifyIconW(dwMessage, lpData) {
        result := DllCall("SHELL32.dll\Shell_NotifyIconW", "uint", dwMessage, "ptr", lpData, "int")
        return result
    }

    /**
     * Gets the screen coordinates of the bounding rectangle of a notification icon.
     * @param {Pointer<NOTIFYICONIDENTIFIER>} identifier Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyiconidentifier">NOTIFYICONIDENTIFIER</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-notifyiconidentifier">NOTIFYICONIDENTIFIER</a> structure that identifies the icon.
     * @param {Pointer<RECT>} iconLocation Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that, when this function returns successfully, receives the coordinates of the icon.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shell_notifyicongetrect
     * @since windows6.1
     */
    static Shell_NotifyIconGetRect(identifier, iconLocation) {
        result := DllCall("SHELL32.dll\Shell_NotifyIconGetRect", "ptr", identifier, "ptr", iconLocation, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.
     *     
     *     					
     * 
     * If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.
     * 
     * If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.
     * 
     * This string can use either short (the 8.3 form) or long file names.
     * @param {Integer} dwFileAttributes Type: <b>DWORD</b>
     * 
     * A combination of one or more <a href="https://docs.microsoft.com/windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.
     * @param {Pointer} psfi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure to receive the file information.
     * @param {Integer} cbFileInfo Type: <b>UINT</b>
     * 
     * The size, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure pointed to by the <i>psfi</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>DWORD_PTR</b>
     * 
     * Returns a value whose meaning depends on the <i>uFlags</i> parameter. 
     *     
     *     					
     * 
     * If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.
     * 
     * If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonexecutable file or an error condition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = NE or PE and HIWORD = Windows version</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Windows application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = MZ and HIWORD = 0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MS-DOS .exe or .com file 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = PE and HIWORD = 0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Console application or .bat file 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetfileinfoa
     * @since windows5.1.2600
     */
    static SHGetFileInfoA(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFileInfoA", "ptr", pszPath, "uint", dwFileAttributes, "ptr", psfi, "uint", cbFileInfo, "uint", uFlags, "ptr")
        return result
    }

    /**
     * Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.
     *     
     *     					
     * 
     * If the <i>uFlags</i> parameter includes the <b>SHGFI_PIDL</b> flag, this parameter must be the address of an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed.
     * 
     * If the <i>uFlags</i> parameter includes the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the <i>dwFileAttributes</i> parameter. This allows you to obtain information about a file type by passing just the extension for <i>pszPath</i> and passing <b>FILE_ATTRIBUTE_NORMAL</b> in <i>dwFileAttributes</i>.
     * 
     * This string can use either short (the 8.3 form) or long file names.
     * @param {Integer} dwFileAttributes Type: <b>DWORD</b>
     * 
     * A combination of one or more <a href="https://docs.microsoft.com/windows/desktop/FileIO/retrieving-and-changing-file-attributes">file attribute flags</a> (FILE_ATTRIBUTE_ values as defined in Winnt.h). If <i>uFlags</i> does not include the <b>SHGFI_USEFILEATTRIBUTES</b> flag, this parameter is ignored.
     * @param {Pointer} psfi Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure to receive the file information.
     * @param {Integer} cbFileInfo Type: <b>UINT</b>
     * 
     * The size, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shfileinfoa">SHFILEINFO</a> structure pointed to by the <i>psfi</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>DWORD_PTR</b>
     * 
     * Returns a value whose meaning depends on the <i>uFlags</i> parameter. 
     *     
     *     					
     * 
     * If <i>uFlags</i> does not contain <b>SHGFI_EXETYPE</b> or <b>SHGFI_SYSICONINDEX</b>, the return value is nonzero if successful, or zero otherwise.
     * 
     * If <i>uFlags</i> contains the <b>SHGFI_EXETYPE</b> flag, the return value specifies the type of the executable file. It will be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonexecutable file or an error condition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = NE or PE and HIWORD = Windows version</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Windows application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = MZ and HIWORD = 0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MS-DOS .exe or .com file 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LOWORD = PE and HIWORD = 0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Console application or .bat file 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetfileinfow
     * @since windows5.1.2600
     */
    static SHGetFileInfoW(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHGetFileInfoW", "ptr", pszPath, "uint", dwFileAttributes, "ptr", psfi, "uint", cbFileInfo, "uint", uFlags, "ptr")
        return result
    }

    /**
     * Retrieves information about system-defined Shell icons.
     * @param {Integer} siid Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-shstockiconid">SHSTOCKICONID</a></b>
     * 
     * One of the values from the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ne-shellapi-shstockiconid">SHSTOCKICONID</a> enumeration that specifies which icon should be retrieved.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * A combination of zero or more of the following flags that specify which information is requested.
     * @param {Pointer<SHSTOCKICONINFO>} psii Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shstockiconinfo">SHSTOCKICONINFO</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/ns-shellapi-shstockiconinfo">SHSTOCKICONINFO</a> structure. When this function is called, the <b>cbSize</b> member of this structure needs to be set to the size of the <b>SHSTOCKICONINFO</b> structure. When this function returns, contains a pointer to a <b>SHSTOCKICONINFO</b> structure that contains the requested information.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetstockiconinfo
     * @since windows6.0.6000
     */
    static SHGetStockIconInfo(siid, uFlags, psii) {
        result := DllCall("SHELL32.dll\SHGetStockIconInfo", "int", siid, "uint", uFlags, "ptr", psii, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves disk space information for a disk volume.
     * @param {PSTR} pszDirectoryName Type: <b>LPCTSTR</b>
     * 
     * A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.
     * @param {Pointer<Integer>} pulFreeBytesAvailableToCaller Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.
     * @param {Pointer<Integer>} pulTotalNumberOfBytes Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the total size of the volume, in bytes.
     * @param {Pointer<Integer>} pulTotalNumberOfFreeBytes Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the number of bytes of free space on the volume.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetdiskfreespaceexa
     * @since windows5.0
     */
    static SHGetDiskFreeSpaceExA(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes) {
        pszDirectoryName := pszDirectoryName is String ? StrPtr(pszDirectoryName) : pszDirectoryName

        pulFreeBytesAvailableToCallerMarshal := pulFreeBytesAvailableToCaller is VarRef ? "uint*" : "ptr"
        pulTotalNumberOfBytesMarshal := pulTotalNumberOfBytes is VarRef ? "uint*" : "ptr"
        pulTotalNumberOfFreeBytesMarshal := pulTotalNumberOfFreeBytes is VarRef ? "uint*" : "ptr"

        result := DllCall("SHELL32.dll\SHGetDiskFreeSpaceExA", "ptr", pszDirectoryName, pulFreeBytesAvailableToCallerMarshal, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytesMarshal, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytesMarshal, pulTotalNumberOfFreeBytes, "int")
        return result
    }

    /**
     * Retrieves disk space information for a disk volume.
     * @param {PWSTR} pszDirectoryName Type: <b>LPCTSTR</b>
     * 
     * A null-terminated string that specifies the volume for which size information is retrieved. This can be a drive letter, UNC name, or the path of a folder. You cannot use <b>NULL</b> to represent the current drive.
     * @param {Pointer<Integer>} pulFreeBytesAvailableToCaller Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the number of bytes on the volume available to the calling application. If the operating system implements per-user quotas, this value may be less than the total number of free bytes on the volume.
     * @param {Pointer<Integer>} pulTotalNumberOfBytes Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the total size of the volume, in bytes.
     * @param {Pointer<Integer>} pulTotalNumberOfFreeBytes Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * Pointer to a value that receives the number of bytes of free space on the volume.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetdiskfreespaceexw
     * @since windows5.0
     */
    static SHGetDiskFreeSpaceExW(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes) {
        pszDirectoryName := pszDirectoryName is String ? StrPtr(pszDirectoryName) : pszDirectoryName

        pulFreeBytesAvailableToCallerMarshal := pulFreeBytesAvailableToCaller is VarRef ? "uint*" : "ptr"
        pulTotalNumberOfBytesMarshal := pulTotalNumberOfBytes is VarRef ? "uint*" : "ptr"
        pulTotalNumberOfFreeBytesMarshal := pulTotalNumberOfFreeBytes is VarRef ? "uint*" : "ptr"

        result := DllCall("SHELL32.dll\SHGetDiskFreeSpaceExW", "ptr", pszDirectoryName, pulFreeBytesAvailableToCallerMarshal, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytesMarshal, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytesMarshal, pulTotalNumberOfFreeBytes, "int")
        return result
    }

    /**
     * Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name.
     * @param {PSTR} pszLinkTo Type: <b>LPCTSTR</b>
     * 
     * A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.
     * @param {PSTR} pszDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.
     * @param {PSTR} pszName Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.
     * @param {Pointer<BOOL>} pfMustCopy Type: <b>BOOL*</b>
     * 
     * The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetnewlinkinfoa
     * @since windows5.0
     */
    static SHGetNewLinkInfoA(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags) {
        pszLinkTo := pszLinkTo is String ? StrPtr(pszLinkTo) : pszLinkTo
        pszDir := pszDir is String ? StrPtr(pszDir) : pszDir
        pszName := pszName is String ? StrPtr(pszName) : pszName

        pfMustCopyMarshal := pfMustCopy is VarRef ? "int*" : "ptr"

        result := DllCall("SHELL32.dll\SHGetNewLinkInfoA", "ptr", pszLinkTo, "ptr", pszDir, "ptr", pszName, pfMustCopyMarshal, pfMustCopy, "uint", uFlags, "int")
        return result
    }

    /**
     * Creates a name for a new shortcut based on the shortcut's proposed target. This function does not create the shortcut, just the name.
     * @param {PWSTR} pszLinkTo Type: <b>LPCTSTR</b>
     * 
     * A pointer to the path and file name of the shortcut's target. If <i>uFlags</i> does not contain the <b>SHGNLI_PIDL</b> value, this parameter is the address of a null-terminated string that contains the target. If <i>uFlags</i> contains the <b>SHGNLI_PIDL</b> value, this parameter is a PIDL that represents the target.
     * @param {PWSTR} pszDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path of the folder in which the shortcut would be created.
     * @param {PWSTR} pszName Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the null-terminated path and file name for the shortcut. This buffer is assumed to be at least MAX_PATH characters in size.
     * @param {Pointer<BOOL>} pfMustCopy Type: <b>BOOL*</b>
     * 
     * The address of a <b>BOOL</b> value that receives a flag indicating whether the shortcut would be copied. When a shortcut to another shortcut is created, the Shell simply copies the target shortcut and modifies that copied shortcut appropriately. This parameter receives a nonzero value if the target specified in <i>pszLinkTo</i> specifies a shortcut that will cause the target shortcut to be copied. This parameter receives zero if the target does not specify a shortcut that would be copied.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetnewlinkinfow
     * @since windows5.0
     */
    static SHGetNewLinkInfoW(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags) {
        pszLinkTo := pszLinkTo is String ? StrPtr(pszLinkTo) : pszLinkTo
        pszDir := pszDir is String ? StrPtr(pszDir) : pszDir
        pszName := pszName is String ? StrPtr(pszName) : pszName

        pfMustCopyMarshal := pfMustCopy is VarRef ? "int*" : "ptr"

        result := DllCall("SHELL32.dll\SHGetNewLinkInfoW", "ptr", pszLinkTo, "ptr", pszDir, "ptr", pszName, pfMustCopyMarshal, pfMustCopy, "uint", uFlags, "int")
        return result
    }

    /**
     * Executes a command on a printer object.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window of any windows or dialog boxes that are created during the operation.
     * @param {Integer} uAction Type: <b>UINT</b>
     * @param {PSTR} lpBuf1 Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.
     * @param {PSTR} lpBuf2 Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.
     * @param {BOOL} fModal Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shinvokeprintercommanda
     * @since windows5.0
     */
    static SHInvokePrinterCommandA(hwnd, uAction, lpBuf1, lpBuf2, fModal) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        lpBuf1 := lpBuf1 is String ? StrPtr(lpBuf1) : lpBuf1
        lpBuf2 := lpBuf2 is String ? StrPtr(lpBuf2) : lpBuf2

        result := DllCall("SHELL32.dll\SHInvokePrinterCommandA", "ptr", hwnd, "uint", uAction, "ptr", lpBuf1, "ptr", lpBuf2, "int", fModal, "int")
        return result
    }

    /**
     * Executes a command on a printer object.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * The handle of the parent window of any windows or dialog boxes that are created during the operation.
     * @param {Integer} uAction Type: <b>UINT</b>
     * @param {PWSTR} lpBuf1 Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.
     * @param {PWSTR} lpBuf2 Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that contains additional information for the printer command. The information contained in this parameter depends upon the value of <i>uAction</i>.
     * @param {BOOL} fModal Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> to specify that <b>SHInvokePrinterCommand</b> should not return until the command is completed; <b>FALSE</b> if the function should return as soon as the command is initialized.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shinvokeprintercommandw
     * @since windows5.0
     */
    static SHInvokePrinterCommandW(hwnd, uAction, lpBuf1, lpBuf2, fModal) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        lpBuf1 := lpBuf1 is String ? StrPtr(lpBuf1) : lpBuf1
        lpBuf2 := lpBuf2 is String ? StrPtr(lpBuf2) : lpBuf2

        result := DllCall("SHELL32.dll\SHInvokePrinterCommandW", "ptr", hwnd, "uint", uAction, "ptr", lpBuf1, "ptr", lpBuf2, "int", fModal, "int")
        return result
    }

    /**
     * Signals the Shell that during the next operation requiring overlay information, it should load icon overlay identifiers that either failed creation or were not present for creation at startup. Identifiers that have already been loaded are not affected.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Always returns S_OK.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shloadnonloadediconoverlayidentifiers
     * @since windows5.0
     */
    static SHLoadNonloadedIconOverlayIdentifiers() {
        result := DllCall("SHELL32.dll\SHLoadNonloadedIconOverlayIdentifiers", "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines whether a file or folder is available for offline use. This function also determines whether the file would be opened from the network, from the local Offline Files cache, or from both locations.
     * @param {PWSTR} pwszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a string value that specifies the full path to a network file or directory. This path does not need to be in UNC form. If <i>pszPath</i> is not a network path, the function returns E_INVALIDARG.
     * @returns {Integer} Type: <b>LPDWORD</b>
     * 
     * A pointer to a variable of type <b>DWORD</b> that receives one or more of the following flags if the function succeeds.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shisfileavailableoffline
     * @since windows5.0
     */
    static SHIsFileAvailableOffline(pwszPath) {
        pwszPath := pwszPath is String ? StrPtr(pwszPath) : pwszPath

        result := DllCall("SHELL32.dll\SHIsFileAvailableOffline", "ptr", pwszPath, "uint*", &pdwStatus := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pdwStatus
    }

    /**
     * Sets the localized name of a file in a Shell folder.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a string that specifies the fully qualified path of the target file.
     * @param {PWSTR} pszResModule Type: <b>PCWSTR</b>
     * 
     * A pointer to a string resource that specifies the localized version of the file name.
     * @param {Integer} idsRes Type: <b>int</b>
     * 
     * An integer ID that specifies the localized file name in the string resource.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shsetlocalizedname
     * @since windows5.1.2600
     */
    static SHSetLocalizedName(pszPath, pszResModule, idsRes) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszResModule := pszResModule is String ? StrPtr(pszResModule) : pszResModule

        result := DllCall("SHELL32.dll\SHSetLocalizedName", "ptr", pszPath, "ptr", pszResModule, "int", idsRes, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Removes the localized name of a file in a Shell folder.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string that specifies the fully qualified path of the target file.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shremovelocalizedname
     * @since windows6.0.6000
     */
    static SHRemoveLocalizedName(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\SHRemoveLocalizedName", "ptr", pszPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the localized name of a file in a Shell folder.
     * @param {PWSTR} pszPath Type: <b>PCWSTR</b>
     * 
     * A pointer to a string that specifies the fully qualified path of the file.
     * @param {PWSTR} pszResModule Type: <b>PWSTR</b>
     * 
     * When this function returns, contains a pointer to a string resource that specifies the localized version of the file name.
     * @param {Integer} cch Type: <b>UINT</b>
     * 
     * When this function returns, contains the size of the string, in <b>WCHARs</b>, at <i>pszResModule</i>.
     * @returns {Integer} Type: <b>int*</b>
     * 
     * When this function returns, contains a pointer to the ID of the localized file name in the resource file.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetlocalizedname
     * @since windows6.0.6000
     */
    static SHGetLocalizedName(pszPath, pszResModule, cch) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszResModule := pszResModule is String ? StrPtr(pszResModule) : pszResModule

        result := DllCall("SHELL32.dll\SHGetLocalizedName", "ptr", pszPath, "ptr", pszResModule, "uint", cch, "int*", &pidsRes := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pidsRes
    }

    /**
     * ShellMessageBox may be altered or unavailable.
     * @param {HINSTANCE} hAppInst Type: <b>HINSTANCE</b>
     * 
     * The handle of the module from which to load a string resource named in <i>pszTitle</i>. If <i>pszTitle</i> does not name a string resource, this parameter is ignored. This value must be valid if <i>pszMsg</i> or <i>pszTitle</i> is a resource ID.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window of the message box to be created. If this variable is not <b>NULL</b>, the title of the owner window is used as the title of the message box.
     * @param {PSTR} lpcText Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains either the message to be displayed or a resource ID specifying where the message is to be retrieved from.
     * @param {PSTR} lpcTitle Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the dialog box title or a resource ID specifying where the title is to be retrieved. If both this parameter and <i>hWnd</i> are <b>NULL</b>, no title is displayed. If this parameter points to a loadable resource formed with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro, it overrides <i>hWnd</i> as the title.
     * @param {Integer} fuStyle Type: <b>UINT</b>
     * 
     * Specifies the contents and behavior of the dialog box. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * An integer value indicating a button that was pressed in the message box. For specific values, see <a href="/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * 
     * 					
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shellmessageboxa
     * @since windows5.1.2600
     */
    static ShellMessageBoxA(hAppInst, hWnd, lpcText, lpcTitle, fuStyle) {
        hAppInst := hAppInst is Win32Handle ? NumGet(hAppInst, "ptr") : hAppInst
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd
        lpcText := lpcText is String ? StrPtr(lpcText) : lpcText
        lpcTitle := lpcTitle is String ? StrPtr(lpcTitle) : lpcTitle

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\ShellMessageBoxA", "ptr", hAppInst, "ptr", hWnd, "ptr", lpcText, "ptr", lpcTitle, "uint", fuStyle, "CDecl int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * ShellMessageBox may be altered or unavailable.
     * @param {HINSTANCE} hAppInst Type: <b>HINSTANCE</b>
     * 
     * The handle of the module from which to load a string resource named in <i>pszTitle</i>. If <i>pszTitle</i> does not name a string resource, this parameter is ignored. This value must be valid if <i>pszMsg</i> or <i>pszTitle</i> is a resource ID.
     * @param {HWND} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window of the message box to be created. If this variable is not <b>NULL</b>, the title of the owner window is used as the title of the message box.
     * @param {PWSTR} lpcText Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains either the message to be displayed or a resource ID specifying where the message is to be retrieved from.
     * @param {PWSTR} lpcTitle Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the dialog box title or a resource ID specifying where the title is to be retrieved. If both this parameter and <i>hWnd</i> are <b>NULL</b>, no title is displayed. If this parameter points to a loadable resource formed with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro, it overrides <i>hWnd</i> as the title.
     * @param {Integer} fuStyle Type: <b>UINT</b>
     * 
     * Specifies the contents and behavior of the dialog box. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * An integer value indicating a button that was pressed in the message box. For specific values, see <a href="/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * 
     * 					
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shellmessageboxw
     * @since windows5.1.2600
     */
    static ShellMessageBoxW(hAppInst, hWnd, lpcText, lpcTitle, fuStyle) {
        hAppInst := hAppInst is Win32Handle ? NumGet(hAppInst, "ptr") : hAppInst
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd
        lpcText := lpcText is String ? StrPtr(lpcText) : lpcText
        lpcTitle := lpcTitle is String ? StrPtr(lpcTitle) : lpcTitle

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\ShellMessageBoxW", "ptr", hAppInst, "ptr", hWnd, "ptr", lpcText, "ptr", lpcTitle, "uint", fuStyle, "CDecl int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {PSTR} pszPath 
     * @returns {BOOL} 
     */
    static IsLFNDriveA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\IsLFNDriveA", "ptr", pszPath, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszPath 
     * @returns {BOOL} 
     */
    static IsLFNDriveW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHELL32.dll\IsLFNDriveW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Enumerates the user accounts that have unread email.
     * @param {HKEY} hKeyUser Type: <b>HKEY</b>
     * 
     * A valid HKEY for a given user.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the user account.
     * @param {PWSTR} pszMailAddress Type: <b>LPTSTR</b>
     * 
     * A pointer to a Unicode string that specifies the email address of an account belonging to the specified user.
     * @param {Integer} cchMailAddress Type: <b>int</b>
     * 
     * The number of characters in the email address.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shenumerateunreadmailaccountsw
     * @since windows5.1.2600
     */
    static SHEnumerateUnreadMailAccountsW(hKeyUser, dwIndex, pszMailAddress, cchMailAddress) {
        hKeyUser := hKeyUser is Win32Handle ? NumGet(hKeyUser, "ptr") : hKeyUser
        pszMailAddress := pszMailAddress is String ? StrPtr(pszMailAddress) : pszMailAddress

        result := DllCall("SHELL32.dll\SHEnumerateUnreadMailAccountsW", "ptr", hKeyUser, "uint", dwIndex, "ptr", pszMailAddress, "int", cchMailAddress, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a specified user's unread message count for any or all email accounts.
     * @param {HKEY} hKeyUser Type: <b>HKEY</b>
     * 
     * A valid HKEY for a given user. This parameter should be <b>NULL</b> if the function is called in a user's environment, in which case <b>HKEY_CURRENT_USER</b> is used. This parameter should be <b>NULL</b> if the function is called from the SYSTEM context, in which case <b>HKEY_USERS</b>&#92;<i>{SID}</i> is used.
     * @param {PWSTR} pszMailAddress Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string in Unicode that specifies the email address of an account belonging to the specified user. When this parameter is <b>NULL</b>, <i>pdwCount</i> returns the total count of unread messages for all accounts owned by the designated user.
     * @param {Pointer<FILETIME>} pFileTime Type: <b>FILETIME*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure.  The use of this parameter is determined by whether <i>pszMailAddress</i> is <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, then this parameter is treated as an [in] parameter, which specifies a filter, so that only unread mail newer than the specified time appears. If <i>pszMailAddress</i> is not <b>NULL</b>, then this parameter is treated as an [out] parameter, which points to a <b>FILETIME</b> structure into which the function places the <b>timestamp</b> of the last <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shsetunreadmailcountw">SHSetUnreadMailCount</a> call for the specified user and email account.
     * @param {PWSTR} pszShellExecuteCommand Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string that returns the ShellExecute command statement passed into the last <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shsetunreadmailcountw">SHSetUnreadMailCount</a> call for the specified user and email account. This command string starts the email application that owns the account referenced by <i>pszMailAddress</i>. If the ShellExecute command is not required, this parameter can be <b>NULL</b>. If <i>pszMailAddress</i> is <b>NULL</b>, this parameter is ignored and must be <b>NULL</b>.
     * @param {Integer} cchShellExecuteCommand Type: <b>int</b>
     * 
     * The maximum size, in characters, of the ShellExecute command buffer pointed to by <i>pszShellExecuteCommand</i>. This parameter must be zero for total counts when <i>pszMailAddress</i> is <b>NULL</b>. It can also be <b>NULL</b> whenever the ShellExecute command string is not required.
     * @returns {Integer} Type: <b>DWORD*</b>
     * 
     * Pointer to a DWORD value which receives the unread message count.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetunreadmailcountw
     * @since windows5.1.2600
     */
    static SHGetUnreadMailCountW(hKeyUser, pszMailAddress, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand) {
        hKeyUser := hKeyUser is Win32Handle ? NumGet(hKeyUser, "ptr") : hKeyUser
        pszMailAddress := pszMailAddress is String ? StrPtr(pszMailAddress) : pszMailAddress
        pszShellExecuteCommand := pszShellExecuteCommand is String ? StrPtr(pszShellExecuteCommand) : pszShellExecuteCommand

        result := DllCall("SHELL32.dll\SHGetUnreadMailCountW", "ptr", hKeyUser, "ptr", pszMailAddress, "uint*", &pdwCount := 0, "ptr", pFileTime, "ptr", pszShellExecuteCommand, "int", cchShellExecuteCommand, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pdwCount
    }

    /**
     * Stores the current user's unread message count for a specified email account in the registry.
     * @param {PWSTR} pszMailAddress Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string in Unicode that contains the current user's full email address.
     * @param {Integer} dwCount Type: <b>DWORD</b>
     * 
     * The number of unread messages.
     * @param {PWSTR} pszShellExecuteCommand Type: <b>LPCTSTR</b>
     * 
     * A pointer to a string in Unicode that contains the full text of a command that can be passed to ShellExecute. This command should start the email application that owns the account referenced by <i>pszMailAddress</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * <b>HRESULT</b>, which includes the following possible values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call completed successfully.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid string argument in either the <i>pszMailAddress</i> or <i>pszShellExecuteCommand</i> parameters.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shsetunreadmailcountw
     * @since windows5.1.2600
     */
    static SHSetUnreadMailCountW(pszMailAddress, dwCount, pszShellExecuteCommand) {
        pszMailAddress := pszMailAddress is String ? StrPtr(pszMailAddress) : pszMailAddress
        pszShellExecuteCommand := pszShellExecuteCommand is String ? StrPtr(pszShellExecuteCommand) : pszShellExecuteCommand

        result := DllCall("SHELL32.dll\SHSetUnreadMailCountW", "ptr", pszMailAddress, "uint", dwCount, "ptr", pszShellExecuteCommand, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Uses CheckTokenMembership to test whether the given token is a member of the local group with the specified RID.
     * @param {HANDLE} hToken Type: <b>HANDLE</b>
     * 
     * A handle to the token. This value can be <b>NULL</b>.
     * @param {Integer} ulRID Type: <b>ULONG</b>
     * 
     * The RID of the local group for which membership is tested.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> on success, <b>FALSE</b> on failure.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shtesttokenmembership
     * @since windows5.1.2600
     */
    static SHTestTokenMembership(hToken, ulRID) {
        hToken := hToken is Win32Handle ? NumGet(hToken, "ptr") : hToken

        result := DllCall("SHELL32.dll\SHTestTokenMembership", "ptr", hToken, "uint", ulRID, "int")
        return result
    }

    /**
     * Retrieves an image list.
     * @param {Integer} iImageList Type: <b>int</b>
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the image list interface identifier, normally IID_IImageList.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested in <i>riid</i>. This is typically <a href="https://docs.microsoft.com/windows/desktop/api/commoncontrols/nn-commoncontrols-iimagelist">IImageList</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetimagelist
     * @since windows5.1.2600
     */
    static SHGetImageList(iImageList, riid) {
        result := DllCall("SHELL32.dll\SHGetImageList", "int", iImageList, "ptr", riid, "ptr*", &ppvObj := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvObj
    }

    /**
     * Initializes the network address control window class.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the initialization succeeded; or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-initnetworkaddresscontrol
     * @since windows6.0.6000
     */
    static InitNetworkAddressControl() {
        result := DllCall("SHELL32.dll\InitNetworkAddressControl", "int")
        return result
    }

    /**
     * Returns the type of media that is in the given drive.
     * @param {PWSTR} pszDrive Type: <b>PCWSTR</b>
     * 
     * The drive in which to check the media type.
     * @returns {Integer} Type: <b>DWORD*</b>
     * 
     * A pointer to the type of media in the given drive. A combination of <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl/nf-shobjidl-iquerycancelautoplay-allowautoplay">ARCONTENT</a> flags.
     * @see https://docs.microsoft.com/windows/win32/api//shellapi/nf-shellapi-shgetdrivemedia
     * @since windows6.0.6000
     */
    static SHGetDriveMedia(pszDrive) {
        pszDrive := pszDrive is String ? StrPtr(pszDrive) : pszDrive

        result := DllCall("SHELL32.dll\SHGetDriveMedia", "ptr", pszDrive, "uint*", &pdwMediaContent := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pdwMediaContent
    }

    /**
     * Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.
     * @param {PSTR} pszStart Type: <b>PTSTR</b>
     * 
     * The address of the string to be searched.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to be used for comparison.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strchra
     * @since windows5.0
     */
    static StrChrA(pszStart, wMatch) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrA", "ptr", pszStart, "ushort", wMatch, "ptr")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.
     * @param {PWSTR} pszStart Type: <b>PTSTR</b>
     * 
     * The address of the string to be searched.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to be used for comparison.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strchrw
     * @since windows5.0
     */
    static StrChrW(pszStart, wMatch) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrW", "ptr", pszStart, "char", wMatch, "ptr")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.
     * @param {PSTR} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the string to be searched.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to be used for comparison.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strchria
     * @since windows5.0
     */
    static StrChrIA(pszStart, wMatch) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrIA", "ptr", pszStart, "ushort", wMatch, "ptr")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.
     * @param {PWSTR} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the string to be searched.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to be used for comparison.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strchriw
     * @since windows5.0
     */
    static StrChrIW(pszStart, wMatch) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrIW", "ptr", pszStart, "char", wMatch, "ptr")
        return result
    }

    /**
     * Searches a string for the first occurrence of a specified character. The comparison is case-sensitive.
     * @param {PWSTR} pszStart Type: <b>PWSTR</b>
     * 
     * A pointer to the string to be searched.
     * @param {Integer} wMatch Type: <b>WCHAR</b>
     * 
     * The character to be used for comparison.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters to search.
     * @returns {PWSTR} Type: <b>PWSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strchrnw
     * @since windows5.1.2600
     */
    static StrChrNW(pszStart, wMatch, cchMax) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrNW", "ptr", pszStart, "char", wMatch, "uint", cchMax, "ptr")
        return result
    }

    /**
     * Searches a string for the first occurrence of a specified character. The comparison is not case-sensitive.
     * @param {PWSTR} pszStart Type: <b>PCWSTR</b>
     * 
     * A pointer to the string to be searched.
     * @param {Integer} wMatch Type: <b>WCHAR</b>
     * 
     * The character to be used for comparison.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters to search.
     * @returns {PWSTR} Type: <b>PWSTR</b>
     * 
     * Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strchrniw
     * @since windows6.0.6000
     */
    static StrChrNIW(pszStart, wMatch, cchMax) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart

        result := DllCall("SHLWAPI.dll\StrChrNIW", "ptr", pszStart, "char", wMatch, "uint", cchMax, "ptr")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The StrNCmp macro differs from this function in name only.
     * @param {PSTR} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpna
     * @since windows5.0
     */
    static StrCmpNA(psz1, psz2, nChar) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpNA", "ptr", psz1, "ptr", psz2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The StrNCmp macro differs from this function in name only.
     * @param {PWSTR} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpnw
     * @since windows5.0
     */
    static StrCmpNW(psz1, psz2, nChar) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpNW", "ptr", psz1, "ptr", psz2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The StrNCmpI macro differs from this function in name only.
     * @param {PSTR} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpnia
     * @since windows5.0
     */
    static StrCmpNIA(psz1, psz2, nChar) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpNIA", "ptr", psz1, "ptr", psz2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The StrNCmpI macro differs from this function in name only.
     * @param {PWSTR} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpniw
     * @since windows5.0
     */
    static StrCmpNIW(psz1, psz2, nChar) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpNIW", "ptr", psz1, "ptr", psz2, "int", nChar, "int")
        return result
    }

    /**
     * Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating NULL character is included within the search pattern match.
     * @param {PSTR} pszStr Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PSTR} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the characters to search for.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcspna
     * @since windows5.0
     */
    static StrCSpnA(pszStr, pszSet) {
        pszStr := pszStr is String ? StrPtr(pszStr) : pszStr
        pszSet := pszSet is String ? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrCSpnA", "ptr", pszStr, "ptr", pszSet, "int")
        return result
    }

    /**
     * Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating NULL character is included within the search pattern match.
     * @param {PWSTR} pszStr Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PWSTR} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the characters to search for.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcspnw
     * @since windows5.0
     */
    static StrCSpnW(pszStr, pszSet) {
        pszStr := pszStr is String ? StrPtr(pszStr) : pszStr
        pszSet := pszSet is String ? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrCSpnW", "ptr", pszStr, "ptr", pszSet, "int")
        return result
    }

    /**
     * Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating NULL character is included within the search pattern match.
     * @param {PSTR} pszStr Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PSTR} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the characters to search for.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcspnia
     * @since windows5.0
     */
    static StrCSpnIA(pszStr, pszSet) {
        pszStr := pszStr is String ? StrPtr(pszStr) : pszStr
        pszSet := pszSet is String ? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrCSpnIA", "ptr", pszStr, "ptr", pszSet, "int")
        return result
    }

    /**
     * Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating NULL character is included within the search pattern match.
     * @param {PWSTR} pszStr Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PWSTR} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the characters to search for.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcspniw
     * @since windows5.0
     */
    static StrCSpnIW(pszStr, pszSet) {
        pszStr := pszStr is String ? StrPtr(pszStr) : pszStr
        pszSet := pszSet is String ? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrCSpnIW", "ptr", pszStr, "ptr", pszSet, "int")
        return result
    }

    /**
     * Duplicates a string.
     * @param {PSTR} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to a constant <b>null</b>-terminated character string.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strdupa
     * @since windows5.0
     */
    static StrDupA(pszSrch) {
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrDupA", "ptr", pszSrch, "ptr")
        return result
    }

    /**
     * Duplicates a string.
     * @param {PWSTR} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to a constant <b>null</b>-terminated character string.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strdupw
     * @since windows5.0
     */
    static StrDupW(pszSrch) {
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrDupW", "ptr", pszSrch, "ptr")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
     * @param {Integer} ull Type: <b>ULONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-tagsfbs_flags">SFBS_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-tagsfbs_flags">SFBS_FLAGS</a> enumeration values that specifies whether to round or truncate undisplayed digits. This value cannot be NULL.
     * @param {PWSTR} pszBuf Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that receives the converted string.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszBuf</i>, in characters.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strformatbytesizeex
     * @since windows6.0.6000
     */
    static StrFormatByteSizeEx(ull, flags, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatByteSizeEx", "uint", ull, "int", flags, "ptr", pszBuf, "uint", cchBuf, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size. Differs from StrFormatByteSizeW in one parameter type.
     * @param {Integer} dw Type: <b>DWORD</b>
     * 
     * The numeric value to be converted.
     * @param {PSTR} pszBuf Type: <b>PSTR</b>
     * 
     * A pointer to a buffer that receives the converted string.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszBuf</i>, in characters.
     * @returns {PSTR} Type: <b>PSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strformatbytesizea
     * @since windows5.0
     */
    static StrFormatByteSizeA(dw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatByteSizeA", "uint", dw, "ptr", pszBuf, "uint", cchBuf, "ptr")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
     * @param {Integer} qdw Type: <b>LONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {PSTR} pszBuf Type: <b>PSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszBuf</i>, in characters.
     * @returns {PSTR} Type: <b>PSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strformatbytesize64a
     * @since windows5.0
     */
    static StrFormatByteSize64A(qdw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatByteSize64A", "int64", qdw, "ptr", pszBuf, "uint", cchBuf, "ptr")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size. Differs from StrFormatByteSizeA in one parameter type.
     * @param {Integer} qdw Type: <b>LONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {PWSTR} pszBuf Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszBuf</i>, in characters.
     * @returns {PWSTR} Type: <b>PWSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strformatbytesizew
     * @since windows5.0
     */
    static StrFormatByteSizeW(qdw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatByteSizeW", "int64", qdw, "ptr", pszBuf, "uint", cchBuf, "ptr")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.
     * @param {Integer} qdw Type: <b>LONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {PWSTR} pszBuf Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of <i>pszBuf</i>, in characters.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strformatkbsizew
     * @since windows5.0
     */
    static StrFormatKBSizeW(qdw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatKBSizeW", "int64", qdw, "ptr", pszBuf, "uint", cchBuf, "ptr")
        return result
    }

    /**
     * Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.
     * @param {Integer} qdw Type: <b>LONGLONG</b>
     * 
     * The numeric value to be converted.
     * @param {PSTR} pszBuf Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of <i>pszBuf</i>, in characters.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strformatkbsizea
     * @since windows5.0
     */
    static StrFormatKBSizeA(qdw, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrFormatKBSizeA", "int64", qdw, "ptr", pszBuf, "uint", cchBuf, "ptr")
        return result
    }

    /**
     * Converts a time interval, specified in milliseconds, to a string.
     * @param {PSTR} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.
     * @param {Integer} dwTimeMS Type: <b>DWORD</b>
     * 
     * The time interval, in milliseconds.
     * @param {Integer} digits Type: <b>int</b>
     * 
     * The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are: 
     *                 
     *                     
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>dwTimeMS</th>
     * <th>digits</th>
     * <th>pszOut</th>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>3</td>
     * <td>34 sec</td>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>2</td>
     * <td>34 sec</td>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>1</td>
     * <td>30 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>3</td>
     * <td>1 min 14 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>2</td>
     * <td>1 min 10 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>1</td>
     * <td>1 min</td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strfromtimeintervala
     * @since windows5.0
     */
    static StrFromTimeIntervalA(pszOut, cchMax, dwTimeMS, digits) {
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\StrFromTimeIntervalA", "ptr", pszOut, "uint", cchMax, "uint", dwTimeMS, "int", digits, "int")
        return result
    }

    /**
     * Converts a time interval, specified in milliseconds, to a string.
     * @param {PWSTR} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted number.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.
     * @param {Integer} dwTimeMS Type: <b>DWORD</b>
     * 
     * The time interval, in milliseconds.
     * @param {Integer} digits Type: <b>int</b>
     * 
     * The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are: 
     *                 
     *                     
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>dwTimeMS</th>
     * <th>digits</th>
     * <th>pszOut</th>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>3</td>
     * <td>34 sec</td>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>2</td>
     * <td>34 sec</td>
     * </tr>
     * <tr>
     * <td>34000</td>
     * <td>1</td>
     * <td>30 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>3</td>
     * <td>1 min 14 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>2</td>
     * <td>1 min 10 sec</td>
     * </tr>
     * <tr>
     * <td>74000</td>
     * <td>1</td>
     * <td>1 min</td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strfromtimeintervalw
     * @since windows5.0
     */
    static StrFromTimeIntervalW(pszOut, cchMax, dwTimeMS, digits) {
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        result := DllCall("SHLWAPI.dll\StrFromTimeIntervalW", "ptr", pszOut, "uint", cchMax, "uint", dwTimeMS, "int", digits, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are equal.
     * @param {BOOL} fCaseSens Type: <b>BOOL</b>
     * 
     * The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.
     * @param {PSTR} pszString1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PSTR} pszString2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strisintlequala
     * @since windows5.0
     */
    static StrIsIntlEqualA(fCaseSens, pszString1, pszString2, nChar) {
        pszString1 := pszString1 is String ? StrPtr(pszString1) : pszString1
        pszString2 := pszString2 is String ? StrPtr(pszString2) : pszString2

        result := DllCall("SHLWAPI.dll\StrIsIntlEqualA", "int", fCaseSens, "ptr", pszString1, "ptr", pszString2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings to determine if they are equal.
     * @param {BOOL} fCaseSens Type: <b>BOOL</b>
     * 
     * The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.
     * @param {PWSTR} pszString1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} pszString2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strisintlequalw
     * @since windows5.0
     */
    static StrIsIntlEqualW(fCaseSens, pszString1, pszString2, nChar) {
        pszString1 := pszString1 is String ? StrPtr(pszString1) : pszString1
        pszString2 := pszString2 is String ? StrPtr(pszString2) : pszString2

        result := DllCall("SHLWAPI.dll\StrIsIntlEqualW", "int", fCaseSens, "ptr", pszString1, "ptr", pszString2, "int", nChar, "int")
        return result
    }

    /**
     * Appends a specified number of characters from the beginning of one string to the end of another.
     * @param {PSTR} psz1 Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.
     * @param {PSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be appended.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>psz1</i>, which holds the combined string.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strncata
     * @since windows5.0
     */
    static StrNCatA(psz1, psz2, cchMax) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrNCatA", "ptr", psz1, "ptr", psz2, "int", cchMax, "ptr")
        return result
    }

    /**
     * Appends a specified number of characters from the beginning of one string to the end of another.
     * @param {PWSTR} psz1 Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.
     * @param {PWSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be appended.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>psz1</i>, which holds the combined string.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strncatw
     * @since windows5.0
     */
    static StrNCatW(psz1, psz2, cchMax) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrNCatW", "ptr", psz1, "ptr", psz2, "int", cchMax, "ptr")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character.
     * @param {PSTR} psz Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PSTR} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated character buffer that contains the characters for which to search.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strpbrka
     * @since windows5.0
     */
    static StrPBrkA(psz, pszSet) {
        psz := psz is String ? StrPtr(psz) : psz
        pszSet := pszSet is String ? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrPBrkA", "ptr", psz, "ptr", pszSet, "ptr")
        return result
    }

    /**
     * Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character.
     * @param {PWSTR} psz Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PWSTR} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated character buffer that contains the characters for which to search.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strpbrkw
     * @since windows5.0
     */
    static StrPBrkW(psz, pszSet) {
        psz := psz is String ? StrPtr(psz) : psz
        pszSet := pszSet is String ? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrPBrkW", "ptr", psz, "ptr", pszSet, "ptr")
        return result
    }

    /**
     * Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.
     * @param {PSTR} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PSTR} pszEnd Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to search for.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrchra
     * @since windows5.0
     */
    static StrRChrA(pszStart, pszEnd, wMatch) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart
        pszEnd := pszEnd is String ? StrPtr(pszEnd) : pszEnd

        result := DllCall("SHLWAPI.dll\StrRChrA", "ptr", pszStart, "ptr", pszEnd, "ushort", wMatch, "ptr")
        return result
    }

    /**
     * Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.
     * @param {PWSTR} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PWSTR} pszEnd Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to search for.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrchrw
     * @since windows5.0
     */
    static StrRChrW(pszStart, pszEnd, wMatch) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart
        pszEnd := pszEnd is String ? StrPtr(pszEnd) : pszEnd

        result := DllCall("SHLWAPI.dll\StrRChrW", "ptr", pszStart, "ptr", pszEnd, "char", wMatch, "ptr")
        return result
    }

    /**
     * Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.
     * @param {PSTR} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PSTR} pszEnd Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to search for.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrchria
     * @since windows5.0
     */
    static StrRChrIA(pszStart, pszEnd, wMatch) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart
        pszEnd := pszEnd is String ? StrPtr(pszEnd) : pszEnd

        result := DllCall("SHLWAPI.dll\StrRChrIA", "ptr", pszStart, "ptr", pszEnd, "ushort", wMatch, "ptr")
        return result
    }

    /**
     * Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.
     * @param {PWSTR} pszStart Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be searched.
     * @param {PWSTR} pszEnd Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.
     * @param {Integer} wMatch Type: <b>TCHAR</b>
     * 
     * The character to search for.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrchriw
     * @since windows5.0
     */
    static StrRChrIW(pszStart, pszEnd, wMatch) {
        pszStart := pszStart is String ? StrPtr(pszStart) : pszStart
        pszEnd := pszEnd is String ? StrPtr(pszEnd) : pszEnd

        result := DllCall("SHLWAPI.dll\StrRChrIW", "ptr", pszStart, "ptr", pszEnd, "char", wMatch, "ptr")
        return result
    }

    /**
     * Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.
     * @param {PSTR} pszSource Type: <b>PTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated source string.
     * @param {PSTR} pszLast Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.
     * @param {PSTR} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrstria
     * @since windows5.0
     */
    static StrRStrIA(pszSource, pszLast, pszSrch) {
        pszSource := pszSource is String ? StrPtr(pszSource) : pszSource
        pszLast := pszLast is String ? StrPtr(pszLast) : pszLast
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrRStrIA", "ptr", pszSource, "ptr", pszLast, "ptr", pszSrch, "ptr")
        return result
    }

    /**
     * Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.
     * @param {PWSTR} pszSource Type: <b>PTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated source string.
     * @param {PWSTR} pszLast Type: <b>PCTSTR</b>
     * 
     * A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.
     * @param {PWSTR} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrstriw
     * @since windows5.0
     */
    static StrRStrIW(pszSource, pszLast, pszSrch) {
        pszSource := pszSource is String ? StrPtr(pszSource) : pszSource
        pszLast := pszLast is String ? StrPtr(pszLast) : pszLast
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrRStrIW", "ptr", pszSource, "ptr", pszLast, "ptr", pszSrch, "ptr")
        return result
    }

    /**
     * Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.
     * @param {PSTR} psz Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string that is to be searched.
     * @param {PSTR} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated character buffer that contains the set of characters for which to search.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the length, in characters, of the matching string or zero if no match is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strspna
     * @since windows5.0
     */
    static StrSpnA(psz, pszSet) {
        psz := psz is String ? StrPtr(psz) : psz
        pszSet := pszSet is String ? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrSpnA", "ptr", psz, "ptr", pszSet, "int")
        return result
    }

    /**
     * Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.
     * @param {PWSTR} psz Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string that is to be searched.
     * @param {PWSTR} pszSet Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated character buffer that contains the set of characters for which to search.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the length, in characters, of the matching string or zero if no match is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strspnw
     * @since windows5.0
     */
    static StrSpnW(psz, pszSet) {
        psz := psz is String ? StrPtr(psz) : psz
        pszSet := pszSet is String ? StrPtr(pszSet) : pszSet

        result := DllCall("SHLWAPI.dll\StrSpnW", "ptr", psz, "ptr", pszSet, "int")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is case-sensitive.
     * @param {PSTR} pszFirst Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to search.
     * @param {PSTR} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strstra
     * @since windows5.0
     */
    static StrStrA(pszFirst, pszSrch) {
        pszFirst := pszFirst is String ? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrA", "ptr", pszFirst, "ptr", pszSrch, "ptr")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is case-sensitive.
     * @param {PWSTR} pszFirst Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to search.
     * @param {PWSTR} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strstrw
     * @since windows5.0
     */
    static StrStrW(pszFirst, pszSrch) {
        pszFirst := pszFirst is String ? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrW", "ptr", pszFirst, "ptr", pszSrch, "ptr")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.
     * @param {PSTR} pszFirst Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string being searched.
     * @param {PSTR} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strstria
     * @since windows5.0
     */
    static StrStrIA(pszFirst, pszSrch) {
        pszFirst := pszFirst is String ? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrIA", "ptr", pszFirst, "ptr", pszSrch, "ptr")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.
     * @param {PWSTR} pszFirst Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string being searched.
     * @param {PWSTR} pszSrch Type: <b>PCTSTR</b>
     * 
     * A pointer to the substring to search for.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strstriw
     * @since windows5.0
     */
    static StrStrIW(pszFirst, pszSrch) {
        pszFirst := pszFirst is String ? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrIW", "ptr", pszFirst, "ptr", pszSrch, "ptr")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is case-sensitive.
     * @param {PWSTR} pszFirst Type: <b>PWSTR</b>
     * 
     * A pointer to the null-terminated, Unicode string that is being searched.
     * @param {PWSTR} pszSrch Type: <b>PCWSTR</b>
     * 
     * A pointer to the null-terminated, Unicode substring that is being searched for.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters from the beginning of the searched string in which to search for the substring.
     * @returns {PWSTR} Type: <b>PWSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strstrnw
     * @since windows6.0.6000
     */
    static StrStrNW(pszFirst, pszSrch, cchMax) {
        pszFirst := pszFirst is String ? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrNW", "ptr", pszFirst, "ptr", pszSrch, "uint", cchMax, "ptr")
        return result
    }

    /**
     * Finds the first occurrence of a substring within a string. The comparison is case-insensitive.
     * @param {PWSTR} pszFirst Type: <b>PWSTR</b>
     * 
     * A pointer to the null-terminated, Unicode string that is being searched.
     * @param {PWSTR} pszSrch Type: <b>PCWSTR</b>
     * 
     * A pointer to the null-terminated, Unicode substring that is being searched for.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters from the beginning of the searched string in which to search for the substring.
     * @returns {PWSTR} Type: <b>PWSTR</b>
     * 
     * Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strstrniw
     * @since windows6.0.6000
     */
    static StrStrNIW(pszFirst, pszSrch, cchMax) {
        pszFirst := pszFirst is String ? StrPtr(pszFirst) : pszFirst
        pszSrch := pszSrch is String ? StrPtr(pszSrch) : pszSrch

        result := DllCall("SHLWAPI.dll\StrStrNIW", "ptr", pszFirst, "ptr", pszSrch, "uint", cchMax, "ptr")
        return result
    }

    /**
     * Converts a string that represents a decimal value to an integer. The StrToLong macro is identical to this function.
     * @param {PSTR} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.
     *                     
     *                     
     * 
     * <pre class="syntax" xml:space="preserve"><c>(optional white space)(optional sign)(one or more decimal digits)</c></pre>
     * The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strtointa
     * @since windows5.0
     */
    static StrToIntA(pszSrc) {
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrToIntA", "ptr", pszSrc, "int")
        return result
    }

    /**
     * Converts a string that represents a decimal value to an integer. The StrToLong macro is identical to this function.
     * @param {PWSTR} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.
     *                     
     *                     
     * 
     * <pre class="syntax" xml:space="preserve"><c>(optional white space)(optional sign)(one or more decimal digits)</c></pre>
     * The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strtointw
     * @since windows5.0
     */
    static StrToIntW(pszSrc) {
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrToIntW", "ptr", pszSrc, "int")
        return result
    }

    /**
     * Converts a string representing a decimal or hexadecimal number to an integer.
     * @param {PSTR} pszString Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.
     * @param {Integer} dwFlags Type: <b>STIF_FLAGS</b>
     * @param {Pointer<Integer>} piRet Type: <b>int*</b>
     * 
     * A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123. 
     *                     
     *                     
     * 
     * If this function returns <b>FALSE</b>, this value is undefined.
     * 
     * If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strtointexa
     * @since windows5.0
     */
    static StrToIntExA(pszString, dwFlags, piRet) {
        pszString := pszString is String ? StrPtr(pszString) : pszString

        piRetMarshal := piRet is VarRef ? "int*" : "ptr"

        result := DllCall("SHLWAPI.dll\StrToIntExA", "ptr", pszString, "int", dwFlags, piRetMarshal, piRet, "int")
        return result
    }

    /**
     * Converts a string representing a decimal or hexadecimal number to an integer.
     * @param {PWSTR} pszString Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.
     * @param {Integer} dwFlags Type: <b>STIF_FLAGS</b>
     * @param {Pointer<Integer>} piRet Type: <b>int*</b>
     * 
     * A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123. 
     *                     
     *                     
     * 
     * If this function returns <b>FALSE</b>, this value is undefined.
     * 
     * If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strtointexw
     * @since windows5.0
     */
    static StrToIntExW(pszString, dwFlags, piRet) {
        pszString := pszString is String ? StrPtr(pszString) : pszString

        piRetMarshal := piRet is VarRef ? "int*" : "ptr"

        result := DllCall("SHLWAPI.dll\StrToIntExW", "ptr", pszString, "int", dwFlags, piRetMarshal, piRet, "int")
        return result
    }

    /**
     * Converts a string representing a decimal or hexadecimal value to a 64-bit integer.
     * @param {PSTR} pszString Type: <b>PCTSTR</b>
     * 
     * A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.
     * @param {Integer} dwFlags Type: <b>STIF_FLAGS</b>
     * @param {Pointer<Integer>} pllRet Type: <b>LONGLONG*</b>
     * 
     * A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123. 
     * 
     *                     
     * 
     * If this function returns <b>FALSE</b>, this value is undefined.
     * 
     * If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strtoint64exa
     * @since windows5.0
     */
    static StrToInt64ExA(pszString, dwFlags, pllRet) {
        pszString := pszString is String ? StrPtr(pszString) : pszString

        pllRetMarshal := pllRet is VarRef ? "int64*" : "ptr"

        result := DllCall("SHLWAPI.dll\StrToInt64ExA", "ptr", pszString, "int", dwFlags, pllRetMarshal, pllRet, "int")
        return result
    }

    /**
     * Converts a string representing a decimal or hexadecimal value to a 64-bit integer.
     * @param {PWSTR} pszString Type: <b>PCTSTR</b>
     * 
     * A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.
     * @param {Integer} dwFlags Type: <b>STIF_FLAGS</b>
     * @param {Pointer<Integer>} pllRet Type: <b>LONGLONG*</b>
     * 
     * A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123. 
     * 
     *                     
     * 
     * If this function returns <b>FALSE</b>, this value is undefined.
     * 
     * If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strtoint64exw
     * @since windows5.0
     */
    static StrToInt64ExW(pszString, dwFlags, pllRet) {
        pszString := pszString is String ? StrPtr(pszString) : pszString

        pllRetMarshal := pllRet is VarRef ? "int64*" : "ptr"

        result := DllCall("SHLWAPI.dll\StrToInt64ExW", "ptr", pszString, "int", dwFlags, pllRetMarshal, pllRet, "int")
        return result
    }

    /**
     * Removes specified leading and trailing characters from a string.
     * @param {PSTR} psz Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.
     * @param {PSTR} pszTrimChars Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strtrima
     * @since windows5.0
     */
    static StrTrimA(psz, pszTrimChars) {
        psz := psz is String ? StrPtr(psz) : psz
        pszTrimChars := pszTrimChars is String ? StrPtr(pszTrimChars) : pszTrimChars

        result := DllCall("SHLWAPI.dll\StrTrimA", "ptr", psz, "ptr", pszTrimChars, "int")
        return result
    }

    /**
     * Removes specified leading and trailing characters from a string.
     * @param {PWSTR} psz Type: <b>PTSTR</b>
     * 
     * A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.
     * @param {PWSTR} pszTrimChars Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strtrimw
     * @since windows5.0
     */
    static StrTrimW(psz, pszTrimChars) {
        psz := psz is String ? StrPtr(psz) : psz
        pszTrimChars := pszTrimChars is String ? StrPtr(pszTrimChars) : pszTrimChars

        result := DllCall("SHLWAPI.dll\StrTrimW", "ptr", psz, "ptr", pszTrimChars, "int")
        return result
    }

    /**
     * Appends one string to another.
     * @param {PWSTR} psz1 Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>psz2</i> appended. This buffer must be large enough to hold both strings and the terminating null character.
     * @param {PWSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string to be appended to <i>psz1</i>.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>psz1</i>, which holds the combined strings.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcatw
     * @since windows5.0
     */
    static StrCatW(psz1, psz2) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCatW", "ptr", psz1, "ptr", psz2, "ptr")
        return result
    }

    /**
     * Compares two strings to determine if they are the same. The comparison is case-sensitive.
     * @param {PWSTR} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>psz1</i> is greater than that pointed to by <i>psz2</i>. Returns a negative value if the string pointed to by <i>psz1</i> is less than that pointed to by <i>psz2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpw
     * @since windows5.0
     */
    static StrCmpW(psz1, psz2) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpW", "ptr", psz1, "ptr", psz2, "int")
        return result
    }

    /**
     * Compares two strings to determine if they are the same. The comparison is not case-sensitive.
     * @param {PWSTR} psz1 Type: <b>PCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>psz1</i> is greater than that pointed to by <i>psz2</i>. Returns a negative value if the string pointed to by <i>psz1</i> is less than that pointed to by <i>psz2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpiw
     * @since windows5.0
     */
    static StrCmpIW(psz1, psz2) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpIW", "ptr", psz1, "ptr", psz2, "int")
        return result
    }

    /**
     * Copies one string to another.
     * @param {PWSTR} psz1 Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the copied string. This string is not guaranteed to be null-terminated.
     * @param {PWSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated source string.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>psz1</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcpyw
     * @since windows5.0
     */
    static StrCpyW(psz1, psz2) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCpyW", "ptr", psz1, "ptr", psz2, "ptr")
        return result
    }

    /**
     * Copies a specified number of characters from the beginning of one string to another.NoteDo not use this function or the StrNCpy macro.
     * @param {PWSTR} pszDst Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the copied string. This buffer must be of sufficient size to hold the copied characters. This string is not guaranteed to be null-terminated.
     * @param {PWSTR} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the null-terminated source string.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The number of characters to be copied, including the terminating null character.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to <i>pszDst</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcpynw
     * @since windows5.0
     */
    static StrCpyNW(pszDst, pszSrc, cchMax) {
        pszDst := pszDst is String ? StrPtr(pszDst) : pszDst
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrCpyNW", "ptr", pszDst, "ptr", pszSrc, "int", cchMax, "ptr")
        return result
    }

    /**
     * Copies and appends characters from one string to the end of another.
     * @param {PWSTR} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.
     * @param {PWSTR} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the string to be appended to <i>pszDest</i>.
     * @param {Integer} cchDestBuffSize Type: <b>int</b>
     * 
     * The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the destination string.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcatbuffw
     * @since windows5.0
     */
    static StrCatBuffW(pszDest, pszSrc, cchDestBuffSize) {
        pszDest := pszDest is String ? StrPtr(pszDest) : pszDest
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrCatBuffW", "ptr", pszDest, "ptr", pszSrc, "int", cchDestBuffSize, "ptr")
        return result
    }

    /**
     * Copies and appends characters from one string to the end of another.
     * @param {PSTR} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.
     * @param {PSTR} pszSrc Type: <b>PCTSTR</b>
     * 
     * A pointer to the string to be appended to <i>pszDest</i>.
     * @param {Integer} cchDestBuffSize Type: <b>int</b>
     * 
     * The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the destination string.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcatbuffa
     * @since windows5.0
     */
    static StrCatBuffA(pszDest, pszSrc, cchDestBuffSize) {
        pszDest := pszDest is String ? StrPtr(pszDest) : pszDest
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrCatBuffA", "ptr", pszDest, "ptr", pszSrc, "int", cchDestBuffSize, "ptr")
        return result
    }

    /**
     * Performs a comparison between two characters. The comparison is not case-sensitive.
     * @param {Integer} w1 Type: <b>TCHAR</b>
     * 
     * The first character to be compared.
     * @param {Integer} w2 Type: <b>TCHAR</b>
     * 
     * The second character to be compared.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns zero if the two characters are the same, or nonzero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-chrcmpia
     * @since windows5.0
     */
    static ChrCmpIA(w1, w2) {
        result := DllCall("SHLWAPI.dll\ChrCmpIA", "ushort", w1, "ushort", w2, "int")
        return result
    }

    /**
     * Performs a comparison between two characters. The comparison is not case-sensitive.
     * @param {Integer} w1 Type: <b>TCHAR</b>
     * 
     * The first character to be compared.
     * @param {Integer} w2 Type: <b>TCHAR</b>
     * 
     * The second character to be compared.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns zero if the two characters are the same, or nonzero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-chrcmpiw
     * @since windows5.0
     */
    static ChrCmpIW(w1, w2) {
        result := DllCall("SHLWAPI.dll\ChrCmpIW", "char", w1, "char", w2, "int")
        return result
    }

    /**
     * Takes a list of arguments and returns the values of the arguments as a printf-style formatted string.
     * @param {PSTR} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the output string.
     * @param {Integer} cchDest Type: <b>int</b>
     * 
     * The maximum number of characters allowed in <i>pszDest</i>.
     * @param {PSTR} pszFmt Type: <b>PCTSTR</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
     * @param {Pointer<Integer>} arglist Type: <b>va_list</b>
     * 
     * A pointer to a list of command-line parameters used to customize the output.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-wvnsprintfa
     * @since windows5.0
     */
    static wvnsprintfA(pszDest, cchDest, pszFmt, arglist) {
        pszDest := pszDest is String ? StrPtr(pszDest) : pszDest
        pszFmt := pszFmt is String ? StrPtr(pszFmt) : pszFmt

        arglistMarshal := arglist is VarRef ? "char*" : "ptr"

        result := DllCall("SHLWAPI.dll\wvnsprintfA", "ptr", pszDest, "int", cchDest, "ptr", pszFmt, arglistMarshal, arglist, "int")
        return result
    }

    /**
     * Takes a list of arguments and returns the values of the arguments as a printf-style formatted string.
     * @param {PWSTR} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the output string.
     * @param {Integer} cchDest Type: <b>int</b>
     * 
     * The maximum number of characters allowed in <i>pszDest</i>.
     * @param {PWSTR} pszFmt Type: <b>PCTSTR</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
     * @param {Pointer<Integer>} arglist Type: <b>va_list</b>
     * 
     * A pointer to a list of command-line parameters used to customize the output.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-wvnsprintfw
     * @since windows5.0
     */
    static wvnsprintfW(pszDest, cchDest, pszFmt, arglist) {
        pszDest := pszDest is String ? StrPtr(pszDest) : pszDest
        pszFmt := pszFmt is String ? StrPtr(pszFmt) : pszFmt

        arglistMarshal := arglist is VarRef ? "char*" : "ptr"

        result := DllCall("SHLWAPI.dll\wvnsprintfW", "ptr", pszDest, "int", cchDest, "ptr", pszFmt, arglistMarshal, arglist, "int")
        return result
    }

    /**
     * Takes a variable-length argument list and returns the values of the arguments as a printf-style formatted string.
     * @param {PSTR} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the output string.
     * @param {Integer} cchDest Type: <b>int</b>
     * 
     * The maximum number of characters allowed in <i>pszDest</i>.
     * @param {PSTR} pszFmt Type: <b>PCTSTR</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-wnsprintfa
     * @since windows5.0
     */
    static wnsprintfA(pszDest, cchDest, pszFmt) {
        pszDest := pszDest is String ? StrPtr(pszDest) : pszDest
        pszFmt := pszFmt is String ? StrPtr(pszFmt) : pszFmt

        result := DllCall("SHLWAPI.dll\wnsprintfA", "ptr", pszDest, "int", cchDest, "ptr", pszFmt, "CDecl int")
        return result
    }

    /**
     * Takes a variable-length argument list and returns the values of the arguments as a printf-style formatted string.
     * @param {PWSTR} pszDest Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the output string.
     * @param {Integer} cchDest Type: <b>int</b>
     * 
     * The maximum number of characters allowed in <i>pszDest</i>.
     * @param {PWSTR} pszFmt Type: <b>PCTSTR</b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-wnsprintfw
     * @since windows5.0
     */
    static wnsprintfW(pszDest, cchDest, pszFmt) {
        pszDest := pszDest is String ? StrPtr(pszDest) : pszDest
        pszFmt := pszFmt is String ? StrPtr(pszFmt) : pszFmt

        result := DllCall("SHLWAPI.dll\wnsprintfW", "ptr", pszDest, "int", cchDest, "ptr", pszFmt, "CDecl int")
        return result
    }

    /**
     * Takes an STRRET structure returned by IShellFolder::GetDisplayNameOf and returns a pointer to an allocated string containing the display name.
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer will no longer be valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure. This value can be <b>NULL</b>.
     * @returns {PSTR} Type: <b>LPTSTR*</b>
     * 
     * A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>. You should free the string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrettostra
     * @since windows5.0
     */
    static StrRetToStrA(pstr, pidl) {
        result := DllCall("SHLWAPI.dll\StrRetToStrA", "ptr", pstr, "ptr", pidl, "ptr*", &ppsz := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppsz
    }

    /**
     * Takes an STRRET structure returned by IShellFolder::GetDisplayNameOf and returns a pointer to an allocated string containing the display name.
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer will no longer be valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure. This value can be <b>NULL</b>.
     * @returns {PWSTR} Type: <b>LPTSTR*</b>
     * 
     * A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>. You should free the string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrettostrw
     * @since windows5.0
     */
    static StrRetToStrW(pstr, pidl) {
        result := DllCall("SHLWAPI.dll\StrRetToStrW", "ptr", pstr, "ptr", pidl, "ptr*", &ppsz := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppsz
    }

    /**
     * Converts an STRRET structure returned by IShellFolder::GetDisplayNameOf to a string, and places the result in a buffer.
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer will no longer be valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {PSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrettobufa
     * @since windows5.0
     */
    static StrRetToBufA(pstr, pidl, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrRetToBufA", "ptr", pstr, "ptr", pidl, "ptr", pszBuf, "uint", cchBuf, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts an STRRET structure returned by IShellFolder::GetDisplayNameOf to a string, and places the result in a buffer.
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer will no longer be valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to the item's <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> structure.
     * @param {PWSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrettobufw
     * @since windows5.0
     */
    static StrRetToBufW(pstr, pidl, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\StrRetToBufW", "ptr", pstr, "ptr", pidl, "ptr", pszBuf, "uint", cchBuf, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Makes a copy of a string in newly allocated memory.
     * @param {PSTR} psz Type: <b>LPCTSTR</b>
     * 
     * A pointer to the null-terminated string to be copied.
     * @returns {PWSTR} Type: <b>LPTSTR*</b>
     * 
     * A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>. You should free the string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * 
     *                     
     * 
     * In the case of failure, this value is NULL.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shstrdupa
     * @since windows5.0
     */
    static SHStrDupA(psz) {
        psz := psz is String ? StrPtr(psz) : psz

        result := DllCall("SHLWAPI.dll\SHStrDupA", "ptr", psz, "ptr*", &ppwsz := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppwsz
    }

    /**
     * Makes a copy of a string in newly allocated memory.
     * @param {PWSTR} psz Type: <b>LPCTSTR</b>
     * 
     * A pointer to the null-terminated string to be copied.
     * @returns {PWSTR} Type: <b>LPTSTR*</b>
     * 
     * A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemalloc">CoTaskMemAlloc</a>. You should free the string with <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-cotaskmemfree">CoTaskMemFree</a> when it is no longer needed.
     * 
     *                     
     * 
     * In the case of failure, this value is NULL.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shstrdupw
     * @since windows5.0
     */
    static SHStrDupW(psz) {
        psz := psz is String ? StrPtr(psz) : psz

        result := DllCall("SHLWAPI.dll\SHStrDupW", "ptr", psz, "ptr*", &ppwsz := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppwsz
    }

    /**
     * Compares two Unicode strings. Digits in the strings are considered as numerical content rather than text. This test is not case-sensitive.
     * @param {PWSTR} psz1 Type: <b>PCWSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} psz2 Type: <b>PCWSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * <ul>
     * <li>Returns zero if the strings are identical.</li>
     * <li>Returns 1 if the string pointed to by <i>psz1</i> has a greater value than that pointed to by <i>psz2</i>.</li>
     * <li>Returns -1 if the string pointed to by <i>psz1</i> has a lesser value than that pointed to by <i>psz2</i>.</li>
     * </ul>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmplogicalw
     * @since windows5.1.2600
     */
    static StrCmpLogicalW(psz1, psz2) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\StrCmpLogicalW", "ptr", psz1, "ptr", psz2, "int")
        return result
    }

    /**
     * Concatenates two Unicode strings. Used when repeated concatenations to the same buffer are required.
     * @param {PWSTR} pszDst Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the null-terminated, Unicode string.
     * @param {Integer} cchDst Type: <b>DWORD</b>
     * 
     * The size of the destination buffer, in characters. This buffer must be of sufficient size to hold both strings as well as a terminating null character. If the buffer is too small, the final string is truncated.
     * @param {Integer} ichAt Type: <b>DWORD</b>
     * 
     * The offset into the destination buffer at which to begin the append action. If the string is not empty, set this value to -1 to have the current number of filled characters (not including the terminating null character) calculated for you.
     * @param {PWSTR} pszSrc Type: <b>PCWSTR</b>
     * 
     * A pointer to the null-terminated Unicode source string.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns the offset of the null character after the last character added to <i>pszDst</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcatchainw
     * @since windows5.1.2600
     */
    static StrCatChainW(pszDst, cchDst, ichAt, pszSrc) {
        pszDst := pszDst is String ? StrPtr(pszDst) : pszDst
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\StrCatChainW", "ptr", pszDst, "uint", cchDst, "uint", ichAt, "ptr", pszSrc, "uint")
        return result
    }

    /**
     * Accepts a STRRET structure returned by IShellFolder::GetDisplayNameOf that contains or points to a string, and returns that string as a BSTR.
     * @param {Pointer<STRRET>} pstr Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-strret">STRRET</a> structure. When the function returns, this pointer is longer valid.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCUITEMID_CHILD</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ns-shtypes-itemidlist">ITEMIDLIST</a> that uniquely identifies a file object or subfolder relative to the parent folder. This value can be <b>NULL</b>.
     * @returns {BSTR} Type: <b><a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">BSTR</a>*</b>
     * 
     * A pointer to a variable of type <a href="https://docs.microsoft.com/previous-versions/windows/desktop/automat/bstr">BSTR</a> that receives the converted string.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strrettobstr
     * @since windows5.1.2600
     */
    static StrRetToBSTR(pstr, pidl) {
        pbstr := BSTR()
        result := DllCall("SHLWAPI.dll\StrRetToBSTR", "ptr", pstr, "ptr", pidl, "ptr", pbstr, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pbstr
    }

    /**
     * Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins with the '@' symbol).
     * @param {PWSTR} pszSource Type: <b>PCWSTR</b>
     * 
     * A pointer to a buffer that contains the indirect string from which the resource will be retrieved. This string should begin with the '@' symbol and use one of the forms discussed in the Remarks section. This function will successfully accept a string that does not begin with an '@' symbol, but the string will be simply passed unchanged to <i>pszOutBuf</i>.
     * @param {PWSTR} pszOutBuf Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the text resource. Both <i>pszOutBuf</i> and <i>pszSource</i> can point to the same buffer, in which case the original string will be overwritten.
     * @param {Integer} cchOutBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszOutBuf</i>, in characters.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shloadindirectstring
     * @since windows5.1.2600
     */
    static SHLoadIndirectString(pszSource, pszOutBuf, cchOutBuf) {
        static ppvReserved := 0 ;Reserved parameters must always be NULL

        pszSource := pszSource is String ? StrPtr(pszSource) : pszSource
        pszOutBuf := pszOutBuf is String ? StrPtr(pszOutBuf) : pszOutBuf

        result := DllCall("SHLWAPI.dll\SHLoadIndirectString", "ptr", pszSource, "ptr", pszOutBuf, "uint", cchOutBuf, "ptr*", ppvReserved, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines whether a character represents a space.
     * @param {CHAR} wch Type: <b>TCHAR</b>
     * 
     * A single character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-ischarspacea
     * @since windows5.0
     */
    static IsCharSpaceA(wch) {
        result := DllCall("SHLWAPI.dll\IsCharSpaceA", "char", wch, "int")
        return result
    }

    /**
     * Determines whether a character represents a space.
     * @param {Integer} wch Type: <b>TCHAR</b>
     * 
     * A single character.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-ischarspacew
     * @since windows5.0
     */
    static IsCharSpaceW(wch) {
        result := DllCall("SHLWAPI.dll\IsCharSpaceW", "char", wch, "int")
        return result
    }

    /**
     * Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.
     * @param {PSTR} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PSTR} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpca
     * @since windows5.0
     */
    static StrCmpCA(pszStr1, pszStr2) {
        pszStr1 := pszStr1 is String ? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String ? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpCA", "ptr", pszStr1, "ptr", pszStr2, "int")
        return result
    }

    /**
     * Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.
     * @param {PWSTR} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpcw
     * @since windows5.0
     */
    static StrCmpCW(pszStr1, pszStr2) {
        pszStr1 := pszStr1 is String ? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String ? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpCW", "ptr", pszStr1, "ptr", pszStr2, "int")
        return result
    }

    /**
     * Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.
     * @param {PSTR} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PSTR} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpica
     * @since windows5.0
     */
    static StrCmpICA(pszStr1, pszStr2) {
        pszStr1 := pszStr1 is String ? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String ? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpICA", "ptr", pszStr1, "ptr", pszStr2, "int")
        return result
    }

    /**
     * Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.
     * @param {PWSTR} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpicw
     * @since windows5.0
     */
    static StrCmpICW(pszStr1, pszStr2) {
        pszStr1 := pszStr1 is String ? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String ? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpICW", "ptr", pszStr1, "ptr", pszStr2, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.
     * @param {PSTR} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PSTR} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpnca
     * @since windows5.0
     */
    static StrCmpNCA(pszStr1, pszStr2, nChar) {
        pszStr1 := pszStr1 is String ? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String ? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpNCA", "ptr", pszStr1, "ptr", pszStr2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.
     * @param {PWSTR} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpncw
     * @since windows5.0
     */
    static StrCmpNCW(pszStr1, pszStr2, nChar) {
        pszStr1 := pszStr1 is String ? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String ? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpNCW", "ptr", pszStr1, "ptr", pszStr2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.
     * @param {PSTR} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PSTR} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpnica
     * @since windows5.0
     */
    static StrCmpNICA(pszStr1, pszStr2, nChar) {
        pszStr1 := pszStr1 is String ? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String ? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpNICA", "ptr", pszStr1, "ptr", pszStr2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.
     * @param {PWSTR} pszStr1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the first null-terminated string to be compared.
     * @param {PWSTR} pszStr2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to the second null-terminated string to be compared.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters from the beginning of each string to be compared.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-strcmpnicw
     * @since windows5.0
     */
    static StrCmpNICW(pszStr1, pszStr2, nChar) {
        pszStr1 := pszStr1 is String ? StrPtr(pszStr1) : pszStr1
        pszStr2 := pszStr2 is String ? StrPtr(pszStr2) : pszStr2

        result := DllCall("SHLWAPI.dll\StrCmpNICW", "ptr", pszStr1, "ptr", pszStr2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two localized strings.
     * @param {BOOL} fCaseSens Type: <b>BOOL</b>
     * 
     * A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.
     * @param {PSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string.
     * @param {PSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters to be compared, starting from the beginning of the strings.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-intlstreqworkera
     * @since windows5.0
     */
    static IntlStrEqWorkerA(fCaseSens, lpString1, lpString2, nChar) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("SHLWAPI.dll\IntlStrEqWorkerA", "int", fCaseSens, "ptr", lpString1, "ptr", lpString2, "int", nChar, "int")
        return result
    }

    /**
     * Compares a specified number of characters from the beginning of two localized strings.
     * @param {BOOL} fCaseSens Type: <b>BOOL</b>
     * 
     * A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.
     * @param {PWSTR} lpString1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string.
     * @param {PWSTR} lpString2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string.
     * @param {Integer} nChar Type: <b>int</b>
     * 
     * The number of characters to be compared, starting from the beginning of the strings.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-intlstreqworkerw
     * @since windows5.0
     */
    static IntlStrEqWorkerW(fCaseSens, lpString1, lpString2, nChar) {
        lpString1 := lpString1 is String ? StrPtr(lpString1) : lpString1
        lpString2 := lpString2 is String ? StrPtr(lpString2) : lpString2

        result := DllCall("SHLWAPI.dll\IntlStrEqWorkerW", "int", fCaseSens, "ptr", lpString1, "ptr", lpString2, "int", nChar, "int")
        return result
    }

    /**
     * Adds a backslash to the end of a string to create the correct syntax for a path.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathaddbackslasha
     * @since windows5.0
     */
    static PathAddBackslashA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathAddBackslashA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Adds a backslash to the end of a string to create the correct syntax for a path.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathaddbackslashw
     * @since windows5.0
     */
    static PathAddBackslashW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathAddBackslashW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Adds a file name extension to a path string.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {PSTR} pszExt Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathaddextensiona
     * @since windows5.0
     */
    static PathAddExtensionA(pszPath, pszExt) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String ? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\PathAddExtensionA", "ptr", pszPath, "ptr", pszExt, "int")
        return result
    }

    /**
     * Adds a file name extension to a path string.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {PWSTR} pszExt Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathaddextensionw
     * @since windows5.0
     */
    static PathAddExtensionW(pszPath, pszExt) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String ? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\PathAddExtensionW", "ptr", pszPath, "ptr", pszExt, "int")
        return result
    }

    /**
     * Appends one path to the end of another.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {PSTR} pszMore Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathappenda
     * @since windows5.0
     */
    static PathAppendA(pszPath, pszMore) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszMore := pszMore is String ? StrPtr(pszMore) : pszMore

        result := DllCall("SHLWAPI.dll\PathAppendA", "ptr", pszPath, "ptr", pszMore, "int")
        return result
    }

    /**
     * Appends one path to the end of another.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {PWSTR} pszMore Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathappendw
     * @since windows5.0
     */
    static PathAppendW(pszPath, pszMore) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszMore := pszMore is String ? StrPtr(pszMore) : pszMore

        result := DllCall("SHLWAPI.dll\PathAppendW", "ptr", pszPath, "ptr", pszMore, "int")
        return result
    }

    /**
     * Creates a root path from a given drive number.
     * @param {PSTR} pszRoot Type: <b>LPTSTR</b>
     * 
     * A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathbuildroota
     * @since windows5.0
     */
    static PathBuildRootA(pszRoot, iDrive) {
        pszRoot := pszRoot is String ? StrPtr(pszRoot) : pszRoot

        result := DllCall("SHLWAPI.dll\PathBuildRootA", "ptr", pszRoot, "int", iDrive, "ptr")
        return result
    }

    /**
     * Creates a root path from a given drive number.
     * @param {PWSTR} pszRoot Type: <b>LPTSTR</b>
     * 
     * A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.
     * @param {Integer} iDrive Type: <b>int</b>
     * 
     * A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathbuildrootw
     * @since windows5.0
     */
    static PathBuildRootW(pszRoot, iDrive) {
        pszRoot := pszRoot is String ? StrPtr(pszRoot) : pszRoot

        result := DllCall("SHLWAPI.dll\PathBuildRootW", "ptr", pszRoot, "int", iDrive, "ptr")
        return result
    }

    /**
     * Simplifies a path by removing navigation elements such as &quot;.&quot; and &quot;..&quot; to produce a direct, well-formed path.
     * @param {PSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcanonicalizea
     * @since windows5.0
     */
    static PathCanonicalizeA(pszBuf, pszPath) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\PathCanonicalizeA", "ptr", pszBuf, "ptr", pszPath, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Simplifies a path by removing navigation elements such as &quot;.&quot; and &quot;..&quot; to produce a direct, well-formed path.
     * @param {PWSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcanonicalizew
     * @since windows5.0
     */
    static PathCanonicalizeW(pszBuf, pszPath) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\PathCanonicalizeW", "ptr", pszBuf, "ptr", pszPath, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.
     * @param {PSTR} pszDest Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {PSTR} pszDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.
     * @param {PSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcombinea
     * @since windows5.0
     */
    static PathCombineA(pszDest, pszDir, pszFile) {
        pszDest := pszDest is String ? StrPtr(pszDest) : pszDest
        pszDir := pszDir is String ? StrPtr(pszDir) : pszDir
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\PathCombineA", "ptr", pszDest, "ptr", pszDir, "ptr", pszFile, "ptr")
        return result
    }

    /**
     * Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.
     * @param {PWSTR} pszDest Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {PWSTR} pszDir Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.
     * @param {PWSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcombinew
     * @since windows5.0
     */
    static PathCombineW(pszDest, pszDir, pszFile) {
        pszDest := pszDest is String ? StrPtr(pszDest) : pszDest
        pszDir := pszDir is String ? StrPtr(pszDir) : pszDir
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\PathCombineW", "ptr", pszDest, "ptr", pszDir, "ptr", pszFile, "ptr")
        return result
    }

    /**
     * Truncates a file path to fit within a given pixel width by replacing path components with ellipses.
     * @param {HDC} hDC Type: <b>HDC</b>
     * 
     * A handle to the device context used for font metrics. This value can be <b>NULL</b>.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.
     * @param {Integer} dx Type: <b>UINT</b>
     * 
     * The width, in pixels, in which the string must fit.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcompactpatha
     * @since windows5.0
     */
    static PathCompactPathA(hDC, pszPath, dx) {
        hDC := hDC is Win32Handle ? NumGet(hDC, "ptr") : hDC
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathCompactPathA", "ptr", hDC, "ptr", pszPath, "uint", dx, "int")
        return result
    }

    /**
     * Truncates a file path to fit within a given pixel width by replacing path components with ellipses.
     * @param {HDC} hDC Type: <b>HDC</b>
     * 
     * A handle to the device context used for font metrics. This value can be <b>NULL</b>.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.
     * @param {Integer} dx Type: <b>UINT</b>
     * 
     * The width, in pixels, in which the string must fit.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcompactpathw
     * @since windows5.0
     */
    static PathCompactPathW(hDC, pszPath, dx) {
        hDC := hDC is Win32Handle ? NumGet(hDC, "ptr") : hDC
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathCompactPathW", "ptr", hDC, "ptr", pszPath, "uint", dx, "int")
        return result
    }

    /**
     * Truncates a path to fit within a certain number of characters by replacing path components with ellipses.
     * @param {PSTR} pszOut Type: <b>LPTSTR</b>
     * 
     * The address of the string that has been altered.
     * @param {PSTR} pszSrc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcompactpathexa
     * @since windows5.0
     */
    static PathCompactPathExA(pszOut, pszSrc, cchMax, dwFlags) {
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\PathCompactPathExA", "ptr", pszOut, "ptr", pszSrc, "uint", cchMax, "uint", dwFlags, "int")
        return result
    }

    /**
     * Truncates a path to fit within a certain number of characters by replacing path components with ellipses.
     * @param {PWSTR} pszOut Type: <b>LPTSTR</b>
     * 
     * The address of the string that has been altered.
     * @param {PWSTR} pszSrc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.
     * @param {Integer} cchMax Type: <b>UINT</b>
     * 
     * The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcompactpathexw
     * @since windows5.0
     */
    static PathCompactPathExW(pszOut, pszSrc, cchMax, dwFlags) {
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc

        result := DllCall("SHLWAPI.dll\PathCompactPathExW", "ptr", pszOut, "ptr", pszSrc, "uint", cchMax, "uint", dwFlags, "int")
        return result
    }

    /**
     * Compares two paths to determine if they share a common prefix. A prefix is one of these types:\_&quot;C:\\&quot;, &quot;.&quot;, &quot;..&quot;, &quot;..\\&quot;.
     * @param {PSTR} pszFile1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the first path name.
     * @param {PSTR} pszFile2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the second path name.
     * @param {PSTR} achPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcommonprefixa
     * @since windows5.0
     */
    static PathCommonPrefixA(pszFile1, pszFile2, achPath) {
        pszFile1 := pszFile1 is String ? StrPtr(pszFile1) : pszFile1
        pszFile2 := pszFile2 is String ? StrPtr(pszFile2) : pszFile2
        achPath := achPath is String ? StrPtr(achPath) : achPath

        result := DllCall("SHLWAPI.dll\PathCommonPrefixA", "ptr", pszFile1, "ptr", pszFile2, "ptr", achPath, "int")
        return result
    }

    /**
     * Compares two paths to determine if they share a common prefix. A prefix is one of these types:\_&quot;C:\\&quot;, &quot;.&quot;, &quot;..&quot;, &quot;..\\&quot;.
     * @param {PWSTR} pszFile1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the first path name.
     * @param {PWSTR} pszFile2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the second path name.
     * @param {PWSTR} achPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcommonprefixw
     * @since windows5.0
     */
    static PathCommonPrefixW(pszFile1, pszFile2, achPath) {
        pszFile1 := pszFile1 is String ? StrPtr(pszFile1) : pszFile1
        pszFile2 := pszFile2 is String ? StrPtr(pszFile2) : pszFile2
        achPath := achPath is String ? StrPtr(achPath) : achPath

        result := DllCall("SHLWAPI.dll\PathCommonPrefixW", "ptr", pszFile1, "ptr", pszFile2, "ptr", achPath, "int")
        return result
    }

    /**
     * Determines whether a path to a file system object such as a file or folder is valid.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfileexistsa
     * @since windows5.0
     */
    static PathFileExistsA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\PathFileExistsA", "ptr", pszPath, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines whether a path to a file system object such as a file or folder is valid.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> for extended error information. If the file does not exist, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <a href="/windows/win32/debug/system-error-codes--0-499-">ERROR_FILE_NOT_FOUND</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfileexistsw
     * @since windows5.0
     */
    static PathFileExistsW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\PathFileExistsW", "ptr", pszPath, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Searches a path for an extension.
     * @param {PSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindextensiona
     * @since windows5.0
     */
    static PathFindExtensionA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindExtensionA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Searches a path for an extension.
     * @param {PWSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindextensionw
     * @since windows5.0
     */
    static PathFindExtensionW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindExtensionW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Searches a path for a file name.
     * @param {PSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindfilenamea
     * @since windows5.0
     */
    static PathFindFileNameA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindFileNameA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Searches a path for a file name.
     * @param {PWSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindfilenamew
     * @since windows5.0
     */
    static PathFindFileNameW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindFileNameW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Parses a path and returns the portion of that path that follows the first backslash.
     * @param {PSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to a null-terminated string that contains the truncated path.
     * 
     * If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.
     * 
     * If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindnextcomponenta
     * @since windows5.0
     */
    static PathFindNextComponentA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindNextComponentA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Parses a path and returns the portion of that path that follows the first backslash.
     * @param {PWSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to a null-terminated string that contains the truncated path.
     * 
     * If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.
     * 
     * If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindnextcomponentw
     * @since windows5.0
     */
    static PathFindNextComponentW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathFindNextComponentW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Searches for a file.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.
     * @param {Pointer<Pointer<Integer>>} ppszOtherDirs Type: <b>LPCTSTR*</b>
     * 
     * An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindonpatha
     * @since windows5.0
     */
    static PathFindOnPathA(pszPath, ppszOtherDirs) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        ppszOtherDirsMarshal := ppszOtherDirs is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\PathFindOnPathA", "ptr", pszPath, ppszOtherDirsMarshal, ppszOtherDirs, "int")
        return result
    }

    /**
     * Searches for a file.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.
     * @param {Pointer<Pointer<Integer>>} ppszOtherDirs Type: <b>LPCTSTR*</b>
     * 
     * An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindonpathw
     * @since windows5.0
     */
    static PathFindOnPathW(pszPath, ppszOtherDirs) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        ppszOtherDirsMarshal := ppszOtherDirs is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\PathFindOnPathW", "ptr", pszPath, ppszOtherDirsMarshal, ppszOtherDirs, "int")
        return result
    }

    /**
     * Determines whether a given file name has one of a list of suffixes.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.
     * @param {Pointer<PSTR>} apszSuffix Type: <b>const LPCTSTR*</b>
     * 
     * An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.
     * @param {Integer} iArraySize Type: <b>int</b>
     * 
     * The number of elements in the array pointed to by <i>apszSuffix</i>.
     * @returns {PSTR} Type: <b>LPCTSTR</b>
     * 
     * Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindsuffixarraya
     * @since windows5.0
     */
    static PathFindSuffixArrayA(pszPath, apszSuffix, iArraySize) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        apszSuffixMarshal := apszSuffix is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\PathFindSuffixArrayA", "ptr", pszPath, apszSuffixMarshal, apszSuffix, "int", iArraySize, "ptr")
        return result
    }

    /**
     * Determines whether a given file name has one of a list of suffixes.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.
     * @param {Pointer<PWSTR>} apszSuffix Type: <b>const LPCTSTR*</b>
     * 
     * An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.
     * @param {Integer} iArraySize Type: <b>int</b>
     * 
     * The number of elements in the array pointed to by <i>apszSuffix</i>.
     * @returns {PWSTR} Type: <b>LPCTSTR</b>
     * 
     * Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathfindsuffixarrayw
     * @since windows5.0
     */
    static PathFindSuffixArrayW(pszPath, apszSuffix, iArraySize) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        apszSuffixMarshal := apszSuffix is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\PathFindSuffixArrayW", "ptr", pszPath, apszSuffixMarshal, apszSuffix, "int", iArraySize, "ptr")
        return result
    }

    /**
     * Finds the command line arguments within a given path.
     * @param {PSTR} pszPath Type: <b>PTSTR</b>
     * 
     * Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful. 
     * 
     *                     
     * 
     * If there are no arguments in the path, the function returns a pointer to the end of the input string.
     * 
     * If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathgetargsa
     * @since windows5.0
     */
    static PathGetArgsA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathGetArgsA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Finds the command line arguments within a given path.
     * @param {PWSTR} pszPath Type: <b>PTSTR</b>
     * 
     * Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful. 
     * 
     *                     
     * 
     * If there are no arguments in the path, the function returns a pointer to the end of the input string.
     * 
     * If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathgetargsw
     * @since windows5.0
     */
    static PathGetArgsW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathGetArgsW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Determines whether a file name is in long format.
     * @param {PSTR} pszName Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathislfnfilespeca
     * @since windows5.0
     */
    static PathIsLFNFileSpecA(pszName) {
        pszName := pszName is String ? StrPtr(pszName) : pszName

        result := DllCall("SHLWAPI.dll\PathIsLFNFileSpecA", "ptr", pszName, "int")
        return result
    }

    /**
     * Determines whether a file name is in long format.
     * @param {PWSTR} pszName Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathislfnfilespecw
     * @since windows5.0
     */
    static PathIsLFNFileSpecW(pszName) {
        pszName := pszName is String ? StrPtr(pszName) : pszName

        result := DllCall("SHLWAPI.dll\PathIsLFNFileSpecW", "ptr", pszName, "int")
        return result
    }

    /**
     * Determines the type of character in relation to a path.
     * @param {Integer} ch Type: <b>TUCHAR</b>
     * 
     * The character for which to determine the type.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * Returns one or more of the following values that define the type of character.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_INVALID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is not valid in a path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_LFNCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is valid in a long file name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_SEPARATOR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is a path separator.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_SHORTCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is valid in a short (8.3) file name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_WILD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is a wildcard character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathgetchartypea
     * @since windows5.0
     */
    static PathGetCharTypeA(ch) {
        result := DllCall("SHLWAPI.dll\PathGetCharTypeA", "char", ch, "uint")
        return result
    }

    /**
     * Determines the type of character in relation to a path.
     * @param {Integer} ch Type: <b>TUCHAR</b>
     * 
     * The character for which to determine the type.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * Returns one or more of the following values that define the type of character.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_INVALID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is not valid in a path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_LFNCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is valid in a long file name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_SEPARATOR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is a path separator.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_SHORTCHAR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is valid in a short (8.3) file name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>GCT_WILD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character is a wildcard character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathgetchartypew
     * @since windows5.0
     */
    static PathGetCharTypeW(ch) {
        result := DllCall("SHLWAPI.dll\PathGetCharTypeW", "char", ch, "uint")
        return result
    }

    /**
     * Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathgetdrivenumbera
     * @since windows5.0
     */
    static PathGetDriveNumberA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathGetDriveNumberA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathgetdrivenumberw
     * @since windows5.0
     */
    static PathGetDriveNumberW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathGetDriveNumberW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Verifies that a path is a valid directory.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisdirectorya
     * @since windows5.0
     */
    static PathIsDirectoryA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsDirectoryA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Verifies that a path is a valid directory.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisdirectoryw
     * @since windows5.0
     */
    static PathIsDirectoryW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsDirectoryW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a specified path is an empty directory.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisdirectoryemptya
     * @since windows5.0
     */
    static PathIsDirectoryEmptyA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsDirectoryEmptyA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a specified path is an empty directory.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisdirectoryemptyw
     * @since windows5.0
     */
    static PathIsDirectoryEmptyW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsDirectoryEmptyW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path for any path-delimiting characters (for example, ':' or '\' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisfilespeca
     * @since windows5.0
     */
    static PathIsFileSpecA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsFileSpecA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path for any path-delimiting characters (for example, ':' or '\' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisfilespecw
     * @since windows5.0
     */
    static PathIsFileSpecW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsFileSpecW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path to determine if it contains a valid prefix of the type passed by pszPrefix. A prefix is one of these types:\_&quot;C:\\&quot;, &quot;.&quot;, &quot;..&quot;, &quot;..\\&quot;.
     * @param {PSTR} pszPrefix Type: <b>IN LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix for which to search.
     * @param {PSTR} pszPath Type: <b>IN LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the compared path is the full prefix for the path, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisprefixa
     * @since windows5.0
     */
    static PathIsPrefixA(pszPrefix, pszPath) {
        pszPrefix := pszPrefix is String ? StrPtr(pszPrefix) : pszPrefix
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsPrefixA", "ptr", pszPrefix, "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path to determine if it contains a valid prefix of the type passed by pszPrefix. A prefix is one of these types:\_&quot;C:\\&quot;, &quot;.&quot;, &quot;..&quot;, &quot;..\\&quot;.
     * @param {PWSTR} pszPrefix Type: <b>IN LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix for which to search.
     * @param {PWSTR} pszPath Type: <b>IN LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the compared path is the full prefix for the path, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisprefixw
     * @since windows5.0
     */
    static PathIsPrefixW(pszPrefix, pszPath) {
        pszPrefix := pszPrefix is String ? StrPtr(pszPrefix) : pszPrefix
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsPrefixW", "ptr", pszPrefix, "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path and determines if it is relative.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisrelativea
     * @since windows5.0
     */
    static PathIsRelativeA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsRelativeA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a path and determines if it is relative.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisrelativew
     * @since windows5.0
     */
    static PathIsRelativeW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsRelativeW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a path string refers to the root of a volume.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisroota
     * @since windows5.0
     */
    static PathIsRootA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsRootA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a path string refers to the root of a volume.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisrootw
     * @since windows5.0
     */
    static PathIsRootW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsRootW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Compares two paths to determine if they have a common root component.
     * @param {PSTR} pszPath1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.
     * @param {PSTR} pszPath2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathissameroota
     * @since windows5.0
     */
    static PathIsSameRootA(pszPath1, pszPath2) {
        pszPath1 := pszPath1 is String ? StrPtr(pszPath1) : pszPath1
        pszPath2 := pszPath2 is String ? StrPtr(pszPath2) : pszPath2

        result := DllCall("SHLWAPI.dll\PathIsSameRootA", "ptr", pszPath1, "ptr", pszPath2, "int")
        return result
    }

    /**
     * Compares two paths to determine if they have a common root component.
     * @param {PWSTR} pszPath1 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.
     * @param {PWSTR} pszPath2 Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathissamerootw
     * @since windows5.0
     */
    static PathIsSameRootW(pszPath1, pszPath2) {
        pszPath1 := pszPath1 is String ? StrPtr(pszPath1) : pszPath1
        pszPath2 := pszPath2 is String ? StrPtr(pszPath2) : pszPath2

        result := DllCall("SHLWAPI.dll\PathIsSameRootW", "ptr", pszPath1, "ptr", pszPath2, "int")
        return result
    }

    /**
     * Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisunca
     * @since windows5.0
     */
    static PathIsUNCA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisuncw
     * @since windows5.0
     */
    static PathIsUNCW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a path string represents a network resource.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisnetworkpatha
     * @since windows5.0
     */
    static PathIsNetworkPathA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsNetworkPathA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines whether a path string represents a network resource.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisnetworkpathw
     * @since windows5.0
     */
    static PathIsNetworkPathW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsNetworkPathW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisuncservera
     * @since windows5.0
     */
    static PathIsUNCServerA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCServerA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisuncserverw
     * @since windows5.0
     */
    static PathIsUNCServerW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCServerW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a string is a valid Universal Naming Convention (UNC) share path, \\server\share.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is in the form &#92;&#92;<i>server</i>&#92;<i>share</i>, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisuncserversharea
     * @since windows5.0
     */
    static PathIsUNCServerShareA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCServerShareA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a string is a valid Universal Naming Convention (UNC) share path, \\server\share.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string is in the form &#92;&#92;<i>server</i>&#92;<i>share</i>, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisuncserversharew
     * @since windows5.0
     */
    static PathIsUNCServerShareW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsUNCServerShareW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the pszContentType. The comparison is not case-sensitive.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.
     * @param {PSTR} pszContentType Type: <b>LPCTSTR</b>
     * 
     * The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathiscontenttypea
     * @since windows5.0
     */
    static PathIsContentTypeA(pszPath, pszContentType) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszContentType := pszContentType is String ? StrPtr(pszContentType) : pszContentType

        result := DllCall("SHLWAPI.dll\PathIsContentTypeA", "ptr", pszPath, "ptr", pszContentType, "int")
        return result
    }

    /**
     * Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the pszContentType. The comparison is not case-sensitive.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.
     * @param {PWSTR} pszContentType Type: <b>LPCTSTR</b>
     * 
     * The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathiscontenttypew
     * @since windows5.0
     */
    static PathIsContentTypeW(pszPath, pszContentType) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszContentType := pszContentType is String ? StrPtr(pszContentType) : pszContentType

        result := DllCall("SHLWAPI.dll\PathIsContentTypeW", "ptr", pszPath, "ptr", pszContentType, "int")
        return result
    }

    /**
     * Tests a given string to determine if it conforms to a valid URL format.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisurla
     * @since windows5.0
     */
    static PathIsURLA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsURLA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Tests a given string to determine if it conforms to a valid URL format.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathisurlw
     * @since windows5.0
     */
    static PathIsURLW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsURLW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathmakeprettya
     * @since windows5.0
     */
    static PathMakePrettyA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathMakePrettyA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathmakeprettyw
     * @since windows5.0
     */
    static PathMakePrettyW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathMakePrettyW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Searches a string using a Microsoft MS-DOS wildcard match type.
     * @param {PSTR} pszFile Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to be searched.
     * @param {PSTR} pszSpec Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathmatchspeca
     * @since windows5.0
     */
    static PathMatchSpecA(pszFile, pszSpec) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile
        pszSpec := pszSpec is String ? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHLWAPI.dll\PathMatchSpecA", "ptr", pszFile, "ptr", pszSpec, "int")
        return result
    }

    /**
     * Searches a string using a Microsoft MS-DOS wildcard match type.
     * @param {PWSTR} pszFile Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to be searched.
     * @param {PWSTR} pszSpec Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathmatchspecw
     * @since windows5.0
     */
    static PathMatchSpecW(pszFile, pszSpec) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile
        pszSpec := pszSpec is String ? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHLWAPI.dll\PathMatchSpecW", "ptr", pszFile, "ptr", pszSpec, "int")
        return result
    }

    /**
     * Matches a file name from a path against one or more file name patterns.
     * @param {PSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.
     * @param {PSTR} pszSpec Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Modifies the search condition. The following are valid flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathmatchspecexa
     * @since windows6.0.6000
     */
    static PathMatchSpecExA(pszFile, pszSpec, dwFlags) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile
        pszSpec := pszSpec is String ? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHLWAPI.dll\PathMatchSpecExA", "ptr", pszFile, "ptr", pszSpec, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Matches a file name from a path against one or more file name patterns.
     * @param {PWSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.
     * @param {PWSTR} pszSpec Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Modifies the search condition. The following are valid flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathmatchspecexw
     * @since windows6.0.6000
     */
    static PathMatchSpecExW(pszFile, pszSpec, dwFlags) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile
        pszSpec := pszSpec is String ? StrPtr(pszSpec) : pszSpec

        result := DllCall("SHLWAPI.dll\PathMatchSpecExW", "ptr", pszFile, "ptr", pszSpec, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Parses a file location string that contains a file location and icon index, and returns separate values.
     * @param {PSTR} pszIconFile Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the valid icon index value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathparseiconlocationa
     * @since windows5.0
     */
    static PathParseIconLocationA(pszIconFile) {
        pszIconFile := pszIconFile is String ? StrPtr(pszIconFile) : pszIconFile

        result := DllCall("SHLWAPI.dll\PathParseIconLocationA", "ptr", pszIconFile, "int")
        return result
    }

    /**
     * Parses a file location string that contains a file location and icon index, and returns separate values.
     * @param {PWSTR} pszIconFile Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the valid icon index value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathparseiconlocationw
     * @since windows5.0
     */
    static PathParseIconLocationW(pszIconFile) {
        pszIconFile := pszIconFile is String ? StrPtr(pszIconFile) : pszIconFile

        result := DllCall("SHLWAPI.dll\PathParseIconLocationW", "ptr", pszIconFile, "int")
        return result
    }

    /**
     * Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.
     * @param {PSTR} lpsz Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathquotespacesa
     * @since windows5.0
     */
    static PathQuoteSpacesA(lpsz) {
        lpsz := lpsz is String ? StrPtr(lpsz) : lpsz

        result := DllCall("SHLWAPI.dll\PathQuoteSpacesA", "ptr", lpsz, "int")
        return result
    }

    /**
     * Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.
     * @param {PWSTR} lpsz Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathquotespacesw
     * @since windows5.0
     */
    static PathQuoteSpacesW(lpsz) {
        lpsz := lpsz is String ? StrPtr(lpsz) : lpsz

        result := DllCall("SHLWAPI.dll\PathQuoteSpacesW", "ptr", lpsz, "int")
        return result
    }

    /**
     * Creates a relative path from one file or folder to another.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.
     * @param {PSTR} pszFrom Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.
     * @param {Integer} dwAttrFrom Type: <b>DWORD</b>
     * 
     * The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.
     * @param {PSTR} pszTo Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.
     * @param {Integer} dwAttrTo Type: <b>DWORD</b>
     * 
     * The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathrelativepathtoa
     * @since windows5.0
     */
    static PathRelativePathToA(pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszFrom := pszFrom is String ? StrPtr(pszFrom) : pszFrom
        pszTo := pszTo is String ? StrPtr(pszTo) : pszTo

        result := DllCall("SHLWAPI.dll\PathRelativePathToA", "ptr", pszPath, "ptr", pszFrom, "uint", dwAttrFrom, "ptr", pszTo, "uint", dwAttrTo, "int")
        return result
    }

    /**
     * Creates a relative path from one file or folder to another.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.
     * @param {PWSTR} pszFrom Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.
     * @param {Integer} dwAttrFrom Type: <b>DWORD</b>
     * 
     * The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.
     * @param {PWSTR} pszTo Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.
     * @param {Integer} dwAttrTo Type: <b>DWORD</b>
     * 
     * The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathrelativepathtow
     * @since windows5.0
     */
    static PathRelativePathToW(pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszFrom := pszFrom is String ? StrPtr(pszFrom) : pszFrom
        pszTo := pszTo is String ? StrPtr(pszTo) : pszTo

        result := DllCall("SHLWAPI.dll\PathRelativePathToW", "ptr", pszPath, "ptr", pszFrom, "uint", dwAttrFrom, "ptr", pszTo, "uint", dwAttrTo, "int")
        return result
    }

    /**
     * Removes any arguments from a given path.
     * @remarks
     * 
     * This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.
     * 
     * 
     * 
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremoveargsa
     * @since windows5.0
     */
    static PathRemoveArgsA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveArgsA", "ptr", pszPath)
    }

    /**
     * Removes any arguments from a given path.
     * @remarks
     * 
     * This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.
     * 
     * 
     * 
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremoveargsw
     * @since windows5.0
     */
    static PathRemoveArgsW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveArgsW", "ptr", pszPath)
    }

    /**
     * Removes the trailing backslash from a given path.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.
     * @returns {PSTR} Type: <b>LPTSTR</b>
     * 
     * A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremovebackslasha
     * @since windows5.0
     */
    static PathRemoveBackslashA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathRemoveBackslashA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Removes the trailing backslash from a given path.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.
     * @returns {PWSTR} Type: <b>LPTSTR</b>
     * 
     * A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremovebackslashw
     * @since windows5.0
     */
    static PathRemoveBackslashW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathRemoveBackslashW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Removes all leading and trailing spaces from a string.
     * @remarks
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * 
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremoveblanksa
     * @since windows5.0
     */
    static PathRemoveBlanksA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveBlanksA", "ptr", pszPath)
    }

    /**
     * Removes all leading and trailing spaces from a string.
     * @remarks
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * 
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremoveblanksw
     * @since windows5.0
     */
    static PathRemoveBlanksW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveBlanksW", "ptr", pszPath)
    }

    /**
     * Removes the file name extension from a path, if one is present.
     * @remarks
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremoveextensiona
     * @since windows5.0
     */
    static PathRemoveExtensionA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveExtensionA", "ptr", pszPath)
    }

    /**
     * Removes the file name extension from a path, if one is present.
     * @remarks
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremoveextensionw
     * @since windows5.0
     */
    static PathRemoveExtensionW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathRemoveExtensionW", "ptr", pszPath)
    }

    /**
     * Removes the trailing file name and backslash from a path, if they are present.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if something was removed, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremovefilespeca
     * @since windows5.0
     */
    static PathRemoveFileSpecA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathRemoveFileSpecA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes the trailing file name and backslash from a path, if they are present.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if something was removed, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathremovefilespecw
     * @since windows5.0
     */
    static PathRemoveFileSpecW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathRemoveFileSpecW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.
     * @param {PSTR} pszExt Type: <b>LPCTSTR</b>
     * 
     * Pointer to a character buffer that contains a '.' character followed by the new extension.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathrenameextensiona
     * @since windows5.0
     */
    static PathRenameExtensionA(pszPath, pszExt) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String ? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\PathRenameExtensionA", "ptr", pszPath, "ptr", pszExt, "int")
        return result
    }

    /**
     * Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.
     * @param {PWSTR} pszExt Type: <b>LPCTSTR</b>
     * 
     * Pointer to a character buffer that contains a '.' character followed by the new extension.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathrenameextensionw
     * @since windows5.0
     */
    static PathRenameExtensionW(pszPath, pszExt) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String ? StrPtr(pszExt) : pszExt

        result := DllCall("SHLWAPI.dll\PathRenameExtensionW", "ptr", pszPath, "ptr", pszExt, "int")
        return result
    }

    /**
     * Determines if a given path is correctly formatted and fully qualified.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @param {PSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathsearchandqualifya
     * @since windows5.0
     */
    static PathSearchAndQualifyA(pszPath, pszBuf, cchBuf) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\PathSearchAndQualifyA", "ptr", pszPath, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Determines if a given path is correctly formatted and fully qualified.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.
     * @param {PWSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathsearchandqualifyw
     * @since windows5.0
     */
    static PathSearchAndQualifyW(pszPath, pszBuf, cchBuf) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\PathSearchAndQualifyW", "ptr", pszPath, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Sets the text of a child control in a window or dialog box, using PathCompactPath to ensure the path fits in the control.
     * @remarks
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * @param {HWND} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box or window.
     * @param {Integer} id Type: <b>int</b>
     * 
     * The identifier of the control.
     * @param {PSTR} pszPath Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathsetdlgitempatha
     * @since windows5.0
     */
    static PathSetDlgItemPathA(hDlg, id, pszPath) {
        hDlg := hDlg is Win32Handle ? NumGet(hDlg, "ptr") : hDlg
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathSetDlgItemPathA", "ptr", hDlg, "int", id, "ptr", pszPath)
    }

    /**
     * Sets the text of a child control in a window or dialog box, using PathCompactPath to ensure the path fits in the control.
     * @remarks
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * @param {HWND} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box or window.
     * @param {Integer} id Type: <b>int</b>
     * 
     * The identifier of the control.
     * @param {PWSTR} pszPath Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathsetdlgitempathw
     * @since windows5.0
     */
    static PathSetDlgItemPathW(hDlg, id, pszPath) {
        hDlg := hDlg is Win32Handle ? NumGet(hDlg, "ptr") : hDlg
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathSetDlgItemPathW", "ptr", hDlg, "int", id, "ptr", pszPath)
    }

    /**
     * Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.
     * @param {PSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.
     * @returns {PSTR} Type: <b>PTSTR</b>
     * 
     * A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathskiproota
     * @since windows5.0
     */
    static PathSkipRootA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathSkipRootA", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.
     * @param {PWSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.
     * @returns {PWSTR} Type: <b>PTSTR</b>
     * 
     * A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathskiprootw
     * @since windows5.0
     */
    static PathSkipRootW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathSkipRootW", "ptr", pszPath, "ptr")
        return result
    }

    /**
     * Removes the path portion of a fully qualified path and file.
     * @remarks
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * 
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathstrippatha
     * @since windows5.0
     */
    static PathStripPathA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathStripPathA", "ptr", pszPath)
    }

    /**
     * Removes the path portion of a fully qualified path and file.
     * @remarks
     * 
     * > [!NOTE]
     * > The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * 
     * 
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathstrippathw
     * @since windows5.0
     */
    static PathStripPathW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathStripPathW", "ptr", pszPath)
    }

    /**
     * Removes all file and directory elements in a path except for the root information.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathstriptoroota
     * @since windows5.0
     */
    static PathStripToRootA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathStripToRootA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes all file and directory elements in a path except for the root information.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathstriptorootw
     * @since windows5.0
     */
    static PathStripToRootW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathStripToRootW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes quotes from the beginning and end of a path.
     * @param {PSTR} lpsz Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.
     * @returns {BOOL} No return value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathunquotespacesa
     * @since windows5.0
     */
    static PathUnquoteSpacesA(lpsz) {
        lpsz := lpsz is String ? StrPtr(lpsz) : lpsz

        result := DllCall("SHLWAPI.dll\PathUnquoteSpacesA", "ptr", lpsz, "int")
        return result
    }

    /**
     * Removes quotes from the beginning and end of a path.
     * @param {PWSTR} lpsz Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.
     * @returns {BOOL} No return value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathunquotespacesw
     * @since windows5.0
     */
    static PathUnquoteSpacesW(lpsz) {
        lpsz := lpsz is String ? StrPtr(lpsz) : lpsz

        result := DllCall("SHLWAPI.dll\PathUnquoteSpacesW", "ptr", lpsz, "int")
        return result
    }

    /**
     * Gives an existing folder the proper attributes to become a system folder.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathmakesystemfoldera
     * @since windows5.0
     */
    static PathMakeSystemFolderA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathMakeSystemFolderA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Gives an existing folder the proper attributes to become a system folder.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathmakesystemfolderw
     * @since windows5.0
     */
    static PathMakeSystemFolderW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathMakeSystemFolderW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathunmakesystemfoldera
     * @since windows5.0
     */
    static PathUnmakeSystemFolderA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathUnmakeSystemFolderA", "ptr", pszPath, "int")
        return result
    }

    /**
     * Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathunmakesystemfolderw
     * @since windows5.0
     */
    static PathUnmakeSystemFolderW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathUnmakeSystemFolderW", "ptr", pszPath, "int")
        return result
    }

    /**
     * Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.
     * @param {Integer} dwAttrb Type: <b>DWORD</b>
     * 
     * The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathissystemfoldera
     * @since windows5.0
     */
    static PathIsSystemFolderA(pszPath, dwAttrb) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsSystemFolderA", "ptr", pszPath, "uint", dwAttrb, "int")
        return result
    }

    /**
     * Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.
     * @param {Integer} dwAttrb Type: <b>DWORD</b>
     * 
     * The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathissystemfolderw
     * @since windows5.0
     */
    static PathIsSystemFolderW(pszPath, dwAttrb) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\PathIsSystemFolderW", "ptr", pszPath, "uint", dwAttrb, "int")
        return result
    }

    /**
     * Removes the decoration from a path string.
     * @remarks
     * 
     * A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.
     * 
     * 
     * 
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathundecoratea
     * @since windows5.0
     */
    static PathUndecorateA(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathUndecorateA", "ptr", pszPath)
    }

    /**
     * Removes the decoration from a path string.
     * @remarks
     * 
     * A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.
     * 
     * 
     * 
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathundecoratew
     * @since windows5.0
     */
    static PathUndecorateW(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        DllCall("SHLWAPI.dll\PathUndecorateW", "ptr", pszPath)
    }

    /**
     * Replaces certain folder names in a fully qualified path with their associated environment string.
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.
     * @param {PSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size, in characters, in the <i>pszBuf</i> buffer.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathunexpandenvstringsa
     * @since windows5.0
     */
    static PathUnExpandEnvStringsA(pszPath, pszBuf, cchBuf) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\PathUnExpandEnvStringsA", "ptr", pszPath, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Replaces certain folder names in a fully qualified path with their associated environment string.
     * @param {PWSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.
     * @param {PWSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The size, in characters, in the <i>pszBuf</i> buffer.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathunexpandenvstringsw
     * @since windows5.0
     */
    static PathUnExpandEnvStringsW(pszPath, pszBuf, cchBuf) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        result := DllCall("SHLWAPI.dll\PathUnExpandEnvStringsW", "ptr", pszPath, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Makes a case-sensitive comparison of two URL strings.
     * @param {PSTR} psz1 Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.
     * @param {PSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.
     * @param {BOOL} fIgnoreSlash Type: <b>BOOL</b>
     * 
     * A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '\' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlcomparea
     * @since windows5.0
     */
    static UrlCompareA(psz1, psz2, fIgnoreSlash) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\UrlCompareA", "ptr", psz1, "ptr", psz2, "int", fIgnoreSlash, "int")
        return result
    }

    /**
     * Makes a case-sensitive comparison of two URL strings.
     * @param {PWSTR} psz1 Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.
     * @param {PWSTR} psz2 Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.
     * @param {BOOL} fIgnoreSlash Type: <b>BOOL</b>
     * 
     * A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '\' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlcomparew
     * @since windows5.0
     */
    static UrlCompareW(psz1, psz2, fIgnoreSlash) {
        psz1 := psz1 is String ? StrPtr(psz1) : psz1
        psz2 := psz2 is String ? StrPtr(psz2) : psz2

        result := DllCall("SHLWAPI.dll\UrlCompareW", "ptr", psz1, "ptr", psz2, "int", fIgnoreSlash, "int")
        return result
    }

    /**
     * When provided with a relative URL and its base, returns a URL in canonical form.
     * @param {PSTR} pszBase Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.
     * @param {PSTR} pszRelative Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.
     * @param {PSTR} pszCombined Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.
     * @param {Pointer<Integer>} pcchCombined Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify how the URL is converted to canonical form. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns standard COM error codes, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_POINTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlcombinea
     * @since windows5.0
     */
    static UrlCombineA(pszBase, pszRelative, pszCombined, pcchCombined, dwFlags) {
        pszBase := pszBase is String ? StrPtr(pszBase) : pszBase
        pszRelative := pszRelative is String ? StrPtr(pszRelative) : pszRelative
        pszCombined := pszCombined is String ? StrPtr(pszCombined) : pszCombined

        pcchCombinedMarshal := pcchCombined is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlCombineA", "ptr", pszBase, "ptr", pszRelative, "ptr", pszCombined, pcchCombinedMarshal, pcchCombined, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * When provided with a relative URL and its base, returns a URL in canonical form.
     * @param {PWSTR} pszBase Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.
     * @param {PWSTR} pszRelative Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.
     * @param {PWSTR} pszCombined Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.
     * @param {Pointer<Integer>} pcchCombined Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that specify how the URL is converted to canonical form. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns standard COM error codes, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_POINTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlcombinew
     * @since windows5.0
     */
    static UrlCombineW(pszBase, pszRelative, pszCombined, pcchCombined, dwFlags) {
        pszBase := pszBase is String ? StrPtr(pszBase) : pszBase
        pszRelative := pszRelative is String ? StrPtr(pszRelative) : pszRelative
        pszCombined := pszCombined is String ? StrPtr(pszCombined) : pszCombined

        pcchCombinedMarshal := pcchCombined is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlCombineW", "ptr", pszBase, "ptr", pszRelative, "ptr", pszCombined, pcchCombinedMarshal, pcchCombined, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a URL string into canonical form.
     * @param {PSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".
     * @param {PSTR} pszCanonicalized Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.
     * @param {Pointer<Integer>} pcchCanonicalized Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that specify how the URL is converted to canonical form. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlcanonicalizea
     * @since windows5.0
     */
    static UrlCanonicalizeA(pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszCanonicalized := pszCanonicalized is String ? StrPtr(pszCanonicalized) : pszCanonicalized

        pcchCanonicalizedMarshal := pcchCanonicalized is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlCanonicalizeA", "ptr", pszUrl, "ptr", pszCanonicalized, pcchCanonicalizedMarshal, pcchCanonicalized, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a URL string into canonical form.
     * @param {PWSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".
     * @param {PWSTR} pszCanonicalized Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.
     * @param {Pointer<Integer>} pcchCanonicalized Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that specify how the URL is converted to canonical form. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlcanonicalizew
     * @since windows5.0
     */
    static UrlCanonicalizeW(pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszCanonicalized := pszCanonicalized is String ? StrPtr(pszCanonicalized) : pszCanonicalized

        pcchCanonicalizedMarshal := pcchCanonicalized is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlCanonicalizeW", "ptr", pszUrl, "ptr", pszCanonicalized, pcchCanonicalizedMarshal, pcchCanonicalized, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns whether a URL is opaque.
     * @param {PSTR} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the URL is opaque, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlisopaquea
     * @since windows5.0
     */
    static UrlIsOpaqueA(pszURL) {
        pszURL := pszURL is String ? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlIsOpaqueA", "ptr", pszURL, "int")
        return result
    }

    /**
     * Returns whether a URL is opaque.
     * @param {PWSTR} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the URL is opaque, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlisopaquew
     * @since windows5.0
     */
    static UrlIsOpaqueW(pszURL) {
        pszURL := pszURL is String ? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlIsOpaqueW", "ptr", pszURL, "int")
        return result
    }

    /**
     * Returns whether a URL is a URL that browsers typically do not include in navigation history.
     * @param {PSTR} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlisnohistorya
     * @since windows5.0
     */
    static UrlIsNoHistoryA(pszURL) {
        pszURL := pszURL is String ? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlIsNoHistoryA", "ptr", pszURL, "int")
        return result
    }

    /**
     * Returns whether a URL is a URL that browsers typically do not include in navigation history.
     * @param {PWSTR} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlisnohistoryw
     * @since windows5.0
     */
    static UrlIsNoHistoryW(pszURL) {
        pszURL := pszURL is String ? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlIsNoHistoryW", "ptr", pszURL, "int")
        return result
    }

    /**
     * Tests whether a URL is a specified type.
     * @param {PSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Integer} UrlIs Type: <b>URLIS</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not. 
     * 
     *                     
     * 
     * If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlisa
     * @since windows5.0
     */
    static UrlIsA(pszUrl, UrlIs) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlIsA", "ptr", pszUrl, "int", UrlIs, "int")
        return result
    }

    /**
     * Tests whether a URL is a specified type.
     * @param {PWSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Integer} UrlIs Type: <b>URLIS</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not. 
     * 
     *                     
     * 
     * If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlisw
     * @since windows5.0
     */
    static UrlIsW(pszUrl, UrlIs) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlIsW", "ptr", pszUrl, "int", UrlIs, "int")
        return result
    }

    /**
     * Retrieves the location from a URL.
     * @param {PSTR} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.
     * @returns {PSTR} Type: <b>LPCTSTR</b>
     * 
     * Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlgetlocationa
     * @since windows5.0
     */
    static UrlGetLocationA(pszURL) {
        pszURL := pszURL is String ? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlGetLocationA", "ptr", pszURL, "ptr")
        return result
    }

    /**
     * Retrieves the location from a URL.
     * @param {PWSTR} pszURL Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.
     * @returns {PWSTR} Type: <b>LPCTSTR</b>
     * 
     * Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlgetlocationw
     * @since windows5.0
     */
    static UrlGetLocationW(pszURL) {
        pszURL := pszURL is String ? StrPtr(pszURL) : pszURL

        result := DllCall("SHLWAPI.dll\UrlGetLocationW", "ptr", pszURL, "ptr")
        return result
    }

    /**
     * Converts escape sequences back into ordinary characters.
     * @param {PSTR} pszUrl Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.
     * @param {PSTR} pszUnescaped Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.
     * @param {Pointer<Integer>} pcchUnescaped Type: <b>DWORD*</b>
     * 
     * The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that control which characters are unescaped. It can be a combination of the following flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlunescapea
     * @since windows5.0
     */
    static UrlUnescapeA(pszUrl, pszUnescaped, pcchUnescaped, dwFlags) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszUnescaped := pszUnescaped is String ? StrPtr(pszUnescaped) : pszUnescaped

        pcchUnescapedMarshal := pcchUnescaped is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlUnescapeA", "ptr", pszUrl, "ptr", pszUnescaped, pcchUnescapedMarshal, pcchUnescaped, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts escape sequences back into ordinary characters.
     * @param {PWSTR} pszUrl Type: <b>PTSTR</b>
     * 
     * A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.
     * @param {PWSTR} pszUnescaped Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.
     * @param {Pointer<Integer>} pcchUnescaped Type: <b>DWORD*</b>
     * 
     * The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags that control which characters are unescaped. It can be a combination of the following flags.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlunescapew
     * @since windows5.0
     */
    static UrlUnescapeW(pszUrl, pszUnescaped, pcchUnescaped, dwFlags) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszUnescaped := pszUnescaped is String ? StrPtr(pszUnescaped) : pszUnescaped

        pcchUnescapedMarshal := pcchUnescaped is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlUnescapeW", "ptr", pszUrl, "ptr", pszUnescaped, pcchUnescapedMarshal, pcchUnescaped, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet (&quot;unsafe&quot; characters) into their corresponding escape sequences.
     * @param {PSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.
     * @param {PSTR} pszEscaped Type: <b>PTSTR</b>
     * 
     * The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.
     * @param {Pointer<Integer>} pcchEscaped Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character. 
     *     
     *                         
     * 
     * If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlescapea
     * @since windows5.0
     */
    static UrlEscapeA(pszUrl, pszEscaped, pcchEscaped, dwFlags) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszEscaped := pszEscaped is String ? StrPtr(pszEscaped) : pszEscaped

        pcchEscapedMarshal := pcchEscaped is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlEscapeA", "ptr", pszUrl, "ptr", pszEscaped, pcchEscapedMarshal, pcchEscaped, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet (&quot;unsafe&quot; characters) into their corresponding escape sequences.
     * @param {PWSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.
     * @param {PWSTR} pszEscaped Type: <b>PTSTR</b>
     * 
     * The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.
     * @param {Pointer<Integer>} pcchEscaped Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character. 
     *     
     *                         
     * 
     * If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlescapew
     * @since windows5.0
     */
    static UrlEscapeW(pszUrl, pszEscaped, pcchEscaped, dwFlags) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszEscaped := pszEscaped is String ? StrPtr(pszEscaped) : pszEscaped

        pcchEscapedMarshal := pcchEscaped is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlEscapeW", "ptr", pszUrl, "ptr", pszEscaped, pcchEscapedMarshal, pcchEscaped, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a Microsoft MS-DOS path to a canonicalized URL.
     * @param {PSTR} pszPath Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.
     * @param {PSTR} pszUrl Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the URL.
     * @param {Pointer<Integer>} pcchUrl Type: <b>DWORD*</b>
     * 
     * The number of characters in <i>pszUrl</i>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Set this parameter to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlcreatefrompatha
     * @since windows5.0
     */
    static UrlCreateFromPathA(pszPath, pszUrl, pcchUrl, dwFlags) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl

        pcchUrlMarshal := pcchUrl is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlCreateFromPathA", "ptr", pszPath, "ptr", pszUrl, pcchUrlMarshal, pcchUrl, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a Microsoft MS-DOS path to a canonicalized URL.
     * @param {PWSTR} pszPath Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.
     * @param {PWSTR} pszUrl Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the URL.
     * @param {Pointer<Integer>} pcchUrl Type: <b>DWORD*</b>
     * 
     * The number of characters in <i>pszUrl</i>.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Set this parameter to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlcreatefrompathw
     * @since windows5.0
     */
    static UrlCreateFromPathW(pszPath, pszUrl, pcchUrl, dwFlags) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl

        pcchUrlMarshal := pcchUrl is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlCreateFromPathW", "ptr", pszPath, "ptr", pszUrl, pcchUrlMarshal, pcchUrl, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a file URL to a Microsoft MS-DOS path.
     * @param {PSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {PSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Integer>} pcchPath Type: <b>DWORD*</b>
     * 
     * The number of characters in the <i>pszPath</i> buffer.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Set this parameter to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcreatefromurla
     * @since windows5.0
     */
    static PathCreateFromUrlA(pszUrl, pszPath, pcchPath, dwFlags) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        pcchPathMarshal := pcchPath is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\PathCreateFromUrlA", "ptr", pszUrl, "ptr", pszPath, pcchPathMarshal, pcchPath, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a file URL to a Microsoft MS-DOS path.
     * @param {PWSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {PWSTR} pszPath Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
     * @param {Pointer<Integer>} pcchPath Type: <b>DWORD*</b>
     * 
     * The number of characters in the <i>pszPath</i> buffer.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved. Set this parameter to <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcreatefromurlw
     * @since windows5.0
     */
    static PathCreateFromUrlW(pszUrl, pszPath, pcchPath, dwFlags) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        pcchPathMarshal := pcchPath is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\PathCreateFromUrlW", "ptr", pszUrl, "ptr", pszPath, pcchPathMarshal, pcchPath, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a path from a file URL.
     * @param {PWSTR} pszIn Type: <b>PCWSTR</b>
     * 
     * A pointer to the URL of a file, represented as a null-terminated, Unicode string.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved, must be 0.
     * @returns {PWSTR} Type: <b>PWSTR*</b>
     * 
     * The address of a pointer to a buffer of length MAX_PATH that, when this function returns successfully, receives the file path.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-pathcreatefromurlalloc
     * @since windows6.0.6000
     */
    static PathCreateFromUrlAlloc(pszIn, dwFlags) {
        pszIn := pszIn is String ? StrPtr(pszIn) : pszIn

        result := DllCall("SHLWAPI.dll\PathCreateFromUrlAlloc", "ptr", pszIn, "ptr*", &ppszOut := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppszOut
    }

    /**
     * Hashes a URL string.
     * @param {PSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Pointer} pbHash Type: <b>BYTE*</b>
     * 
     * A pointere to a buffer that, when this function returns successfully, receives the hashed array.
     * @param {Integer} cbHash Type: <b>DWORD</b>
     * 
     * The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlhasha
     * @since windows5.0
     */
    static UrlHashA(pszUrl, pbHash, cbHash) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlHashA", "ptr", pszUrl, "ptr", pbHash, "uint", cbHash, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Hashes a URL string.
     * @param {PWSTR} pszUrl Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {Pointer} pbHash Type: <b>BYTE*</b>
     * 
     * A pointere to a buffer that, when this function returns successfully, receives the hashed array.
     * @param {Integer} cbHash Type: <b>DWORD</b>
     * 
     * The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlhashw
     * @since windows5.0
     */
    static UrlHashW(pszUrl, pbHash, cbHash) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl

        result := DllCall("SHLWAPI.dll\UrlHashW", "ptr", pszUrl, "ptr", pbHash, "uint", cbHash, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Accepts a URL string and returns a specified part of that URL.
     * @param {PWSTR} pszIn Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {PWSTR} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.
     * @param {Pointer<Integer>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwPart Type: <b>DWORD</b>
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlgetpartw
     * @since windows5.0
     */
    static UrlGetPartW(pszIn, pszOut, pcchOut, dwPart, dwFlags) {
        pszIn := pszIn is String ? StrPtr(pszIn) : pszIn
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        pcchOutMarshal := pcchOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlGetPartW", "ptr", pszIn, "ptr", pszOut, pcchOutMarshal, pcchOut, "uint", dwPart, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Accepts a URL string and returns a specified part of that URL.
     * @param {PSTR} pszIn Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.
     * @param {PSTR} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.
     * @param {Pointer<Integer>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwPart Type: <b>DWORD</b>
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlgetparta
     * @since windows5.0
     */
    static UrlGetPartA(pszIn, pszOut, pcchOut, dwPart, dwFlags) {
        pszIn := pszIn is String ? StrPtr(pszIn) : pszIn
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        pcchOutMarshal := pcchOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlGetPartA", "ptr", pszIn, "ptr", pszOut, pcchOutMarshal, pcchOut, "uint", dwPart, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.
     * @param {PSTR} pszIn Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.
     * @param {PSTR} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.
     * @param {Pointer<Integer>} pcchOut Type: <b>DWORD*</b>
     * 
     * The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that specify how to determine the scheme. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM return value, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There were no errors, but no prefix was prepended.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_POINTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlapplyschemea
     * @since windows5.0
     */
    static UrlApplySchemeA(pszIn, pszOut, pcchOut, dwFlags) {
        pszIn := pszIn is String ? StrPtr(pszIn) : pszIn
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        pcchOutMarshal := pcchOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlApplySchemeA", "ptr", pszIn, "ptr", pszOut, pcchOutMarshal, pcchOut, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.
     * @param {PWSTR} pszIn Type: <b>PCTSTR</b>
     * 
     * A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.
     * @param {PWSTR} pszOut Type: <b>PTSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.
     * @param {Pointer<Integer>} pcchOut Type: <b>DWORD*</b>
     * 
     * The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags that specify how to determine the scheme. The following flags can be combined.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM return value, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There were no errors, but no prefix was prepended.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_POINTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlapplyschemew
     * @since windows5.0
     */
    static UrlApplySchemeW(pszIn, pszOut, pcchOut, dwFlags) {
        pszIn := pszIn is String ? StrPtr(pszIn) : pszIn
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        pcchOutMarshal := pcchOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\UrlApplySchemeW", "ptr", pszIn, "ptr", pszOut, pcchOutMarshal, pcchOut, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Hashes an array of data.
     * @param {Pointer} pbData Type: <b>BYTE*</b>
     * 
     * A pointer to the data array.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * The number of elements in the array at <i>pbData</i>.
     * @param {Pointer} pbHash Type: <b>BYTE*</b>
     * 
     * A pointer to a value that, when this function returns successfully, receives the hashed array.
     * @param {Integer} cbHash Type: <b>DWORD</b>
     * 
     * The number of elements in <i>pbHash</i>. It should be no larger than 256.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-hashdata
     * @since windows5.0
     */
    static HashData(pbData, cbData, pbHash, cbHash) {
        result := DllCall("SHLWAPI.dll\HashData", "ptr", pbData, "uint", cbData, "ptr", pbHash, "uint", cbHash, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * UrlFixupW may be altered or unavailable.
     * @param {PWSTR} pcszUrl Type: <b>PCWSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that contains the URL to be corrected. This string must not exceed INTERNET_MAX_PATH_LENGTH characters in length, including the terminating <b>NULL</b> character.
     * @param {PWSTR} pszTranslatedUrl Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the copied characters. The buffer must be large enough to contain the number of WCHAR characters specified by the <i>cchMax</i> parameter, including the terminating <b>NULL</b> character. This parameter can be equal to the <i>pcszUrl</i> parameter to correct a URL in place. If <i>pszTranslatedUrl</i> is not equal to <i>pcszUrl</i>, the buffer pointed to by <i>pszTranslatedUrl</i> must not overlap the buffer pointed to by <i>pcszUrl</i>.
     * @param {Integer} cchMax Type: <b>DWORD</b>
     * 
     * The number of <b>WCHAR</b> characters that can be contained in the buffer pointed to by <i>pszTranslatedUrl</i>. This parameter must be greater than zero.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the proposed URL was already acceptable or was successfully corrected. The <i>pszTranslatedUrl</i> buffer contains the corrected URL, or the original URL if no correction was needed. Returns S_FALSE if the proposed URL could not be recognized sufficiently to be corrected. Otherwise, returns a standard COM error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-urlfixupw
     * @since windows5.1.2600
     */
    static UrlFixupW(pcszUrl, pszTranslatedUrl, cchMax) {
        pcszUrl := pcszUrl is String ? StrPtr(pcszUrl) : pcszUrl
        pszTranslatedUrl := pszTranslatedUrl is String ? StrPtr(pszTranslatedUrl) : pszTranslatedUrl

        result := DllCall("SHLWAPI.dll\UrlFixupW", "ptr", pcszUrl, "ptr", pszTranslatedUrl, "uint", cchMax, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Performs rudimentary parsing of a URL.
     * @param {PSTR} pcszURL Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the URL to be parsed.
     * @param {Pointer<PARSEDURLA>} ppu Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-parsedurla">PARSEDURL</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-parsedurla">PARSEDURL</a> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-parseurla
     * @since windows6.0.6000
     */
    static ParseURLA(pcszURL, ppu) {
        pcszURL := pcszURL is String ? StrPtr(pcszURL) : pcszURL

        result := DllCall("SHLWAPI.dll\ParseURLA", "ptr", pcszURL, "ptr", ppu, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Performs rudimentary parsing of a URL.
     * @param {PWSTR} pcszURL Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the URL to be parsed.
     * @param {Pointer<PARSEDURLW>} ppu Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-parsedurla">PARSEDURL</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-parsedurla">PARSEDURL</a> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-parseurlw
     * @since windows6.0.6000
     */
    static ParseURLW(pcszURL, ppu) {
        pcszURL := pcszURL is String ? StrPtr(pcszURL) : pcszURL

        result := DllCall("SHLWAPI.dll\ParseURLW", "ptr", pcszURL, "ptr", ppu, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deletes an empty key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the key to delete.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shdeleteemptykeya
     * @since windows5.0
     */
    static SHDeleteEmptyKeyA(hkey, pszSubKey) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHDeleteEmptyKeyA", "ptr", hkey, "ptr", pszSubKey, "uint")
        return result
    }

    /**
     * Deletes an empty key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {PWSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the key to delete.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shdeleteemptykeyw
     * @since windows5.0
     */
    static SHDeleteEmptyKeyW(hkey, pszSubKey) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHDeleteEmptyKeyW", "ptr", hkey, "ptr", pszSubKey, "uint")
        return result
    }

    /**
     * Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the key to delete.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shdeletekeya
     * @since windows5.0
     */
    static SHDeleteKeyA(hkey, pszSubKey) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHDeleteKeyA", "ptr", hkey, "ptr", pszSubKey, "uint")
        return result
    }

    /**
     * Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {PWSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the key to delete.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shdeletekeyw
     * @since windows5.0
     */
    static SHDeleteKeyW(hkey, pszSubKey) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHDeleteKeyW", "ptr", hkey, "ptr", pszSubKey, "uint")
        return result
    }

    /**
     * Duplicates a registry key's HKEY handle.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * The HKEY handle to be duplicated.
     * @returns {HKEY} Type: <b>HKEY</b>
     * 
     * Returns a duplicate of the handle specified in <i>hkey</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregduplicatehkey
     * @since windows5.0
     */
    static SHRegDuplicateHKey(hkey) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey

        result := DllCall("SHLWAPI.dll\SHRegDuplicateHKey", "ptr", hkey, "ptr")
        resultHandle := HKEY({Value: result}, True)
        return resultHandle
    }

    /**
     * Deletes a named value from the specified registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the subkey for which to change the value.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the value to be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shdeletevaluea
     * @since windows5.0
     */
    static SHDeleteValueA(hkey, pszSubKey, pszValue) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHDeleteValueA", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint")
        return result
    }

    /**
     * Deletes a named value from the specified registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {PWSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string specifying the name of the subkey for which to change the value.
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the value to be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shdeletevaluew
     * @since windows5.0
     */
    static SHDeleteValueW(hkey, pszSubKey, pszValue) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHDeleteValueW", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint")
        return result
    }

    /**
     * Retrieves a registry value.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the value.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * The type of value. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of the destination data buffer.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * The size of the destination data buffer.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shgetvaluea
     * @since windows5.0
     */
    static SHGetValueA(hkey, pszSubKey, pszValue, pdwType, pvData, pcbData) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHGetValueA", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Retrieves a registry value.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {PWSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the value.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * The type of value. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of the destination data buffer.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * The size of the destination data buffer.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shgetvaluew
     * @since windows5.0
     */
    static SHGetValueW(hkey, pszSubKey, pszValue, pdwType, pvData, pcbData) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHGetValueW", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Sets the value of a registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPCVOID</b>
     * 
     * Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shsetvaluea
     * @since windows5.0
     */
    static SHSetValueA(hkey, pszSubKey, pszValue, dwType, pvData, cbData) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHSetValueA", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint", dwType, "ptr", pvData, "uint", cbData, "int")
        return result
    }

    /**
     * Sets the value of a registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {PWSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPCVOID</b>
     * 
     * Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shsetvaluew
     * @since windows5.0
     */
    static SHSetValueW(hkey, pszSubKey, pszValue, dwType, pvData, cbData) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHSetValueW", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "uint", dwType, "ptr", pvData, "uint", cbData, "int")
        return result
    }

    /**
     * Retrieves a registry value.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the relative path from <i>hkey</i> to the subkey to retrieve the value from. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the <i>hkey</i> location.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that contains the name of the value. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the Default value.
     * @param {Integer} srrfFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a></b>
     * 
     * One or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a> flags that restricts the data to be retrieved. At least one type restriction (SRRF_RT) value must be specified.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. If the SRRF_NOEXPAND flag is not set, REG_EXPAND_SZ types are automatically expanded and returned as REG_SZ. If type information is not required, this parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * A pointer to a buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not needed. For example, if you were testing only for a value's existence, the specific value data would be superfluous.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the destination data buffer <i>pvData</i>, in bytes. This value can be <b>NULL</b> only if <i>pvData</i> is <b>NULL</b>. On exit, <i>pcbData</i> points to one of these values.
     *                     
     * 
     * <table class="clsStd">
     * <tr>
     * <th>pvData</th>
     * <th>Return Value</th>
     * <th>pcbData</th>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td>ERROR_SUCCESS</td>
     * <td>Size in bytes sufficient to hold the registry data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>NULL</b></td>
     * <td>ERROR_SUCCESS</td>
     * <td>Exact number of bytes written to <i>pvData</i>.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>NULL</b></td>
     * <td>ERROR_MORE_DATA</td>
     * <td>Size in bytes needed to hold the entire data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetvaluea
     * @since windows5.1.2600
     */
    static SHRegGetValueA(hkey, pszSubKey, pszValue, srrfFlags, pdwType, pvData, pcbData) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegGetValueA", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "int", srrfFlags, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Retrieves a registry value.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * 
     * <a id="HKEY_CLASSES_ROOT"></a>
     * <a id="hkey_classes_root"></a>
     * @param {PWSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that specifies the relative path from <i>hkey</i> to the subkey to retrieve the value from. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the <i>hkey</i> location.
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated string that contains the name of the value. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the Default value.
     * @param {Integer} srrfFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a></b>
     * 
     * One or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a> flags that restricts the data to be retrieved. At least one type restriction (SRRF_RT) value must be specified.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. If the SRRF_NOEXPAND flag is not set, REG_EXPAND_SZ types are automatically expanded and returned as REG_SZ. If type information is not required, this parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * A pointer to a buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not needed. For example, if you were testing only for a value's existence, the specific value data would be superfluous.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the destination data buffer <i>pvData</i>, in bytes. This value can be <b>NULL</b> only if <i>pvData</i> is <b>NULL</b>. On exit, <i>pcbData</i> points to one of these values.
     *                     
     * 
     * <table class="clsStd">
     * <tr>
     * <th>pvData</th>
     * <th>Return Value</th>
     * <th>pcbData</th>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td>ERROR_SUCCESS</td>
     * <td>Size in bytes sufficient to hold the registry data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>NULL</b></td>
     * <td>ERROR_SUCCESS</td>
     * <td>Exact number of bytes written to <i>pvData</i>.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>NULL</b></td>
     * <td>ERROR_MORE_DATA</td>
     * <td>Size in bytes needed to hold the entire data. Note that this is not guaranteed to be the precise size, but only a sufficient size.</td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetvaluew
     * @since windows5.1.2600
     */
    static SHRegGetValueW(hkey, pszSubKey, pszValue, srrfFlags, pdwType, pvData, pcbData) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegGetValueW", "ptr", hkey, "ptr", pszSubKey, "ptr", pszValue, "int", srrfFlags, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Obtains specified information from the registry.
     * @param {PWSTR} pwszKey Type: <b>PCWSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated Unicode string that specifies the path to the registry key.
     * @param {PWSTR} pwszValue Type: <b>PCWSTR</b>
     * 
     * A pointer to a <b>null</b>-terminated Unicode string that specifies the key value. This value can be <b>NULL</b>, in which case data is retrieved from the Default value.
     * @param {Integer} srrfFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/shell/srrf">SRRF</a> flag constants. If more than one flag is used they can be combined using a bitwise OR. These flags are used to restrict the type of data returned. This value cannot be 0.
     * @param {Pointer<Integer>} pdwType Type: <b>DWORD*</b>
     * 
     * When this function returns, contains a pointer to a <b>DWORD</b> which receives a code that indicates the type of data stored in the specified value.  This can be set to <b>NULL</b> if no type information is wanted. If this value is not <b>NULL</b>, and the SRRF_NOEXPAND flag has not been set, data types of REG_EXPAND_SZ will be returned as REG_SZ since they are automatically expanded in this method.
     * @param {Pointer} pvData Type: <b>LPCVOID</b>
     * 
     * A pointer to a buffer that contains the value's data. This parameter can be <b>NULL</b> if the data is not needed. This value must contain the size of the <i>pvData</i> buffer on entry.  If <i>pvData</i> is <b>NULL</b> (or if <i>pvData</i> is not <b>NULL</b>, but too small of a buffer to hold the registry data), then on exit it will contain the size required to hold the registry data.
     * @param {Pointer<Integer>} pcbData Type: <b>DWORD*</b>
     * 
     * When this function returns, contains a pointer to the size of the data, in bytes.
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * If successful, this function returns ERROR_SUCCESS and all out parameters requested. Returns ERROR_MORE_DATA if the function fails due to insufficient space in a provided non-<b>NULL</b> pvData. In this case  only <i>pdwType</i> and <i>pcbData</i> may contain valid data, <i>pvData</i> will be undefined. Otherwise, returns a nonzero error code defined in Winerror.h . You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetvaluefromhkcuhklm
     * @since windows6.0.6000
     */
    static SHRegGetValueFromHKCUHKLM(pwszKey, pwszValue, srrfFlags, pdwType, pvData, pcbData) {
        pwszKey := pwszKey is String ? StrPtr(pwszKey) : pwszKey
        pwszValue := pwszValue is String ? StrPtr(pwszValue) : pwszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegGetValueFromHKCUHKLM", "ptr", pwszKey, "ptr", pwszValue, "int", srrfFlags, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Opens a registry key and queries it for a specific value.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the <b>null</b>-terminated string that contains the name of the value to be queried.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shqueryvalueexa
     * @since windows5.0
     */
    static SHQueryValueExA(hkey, pszValue, pdwType, pvData, pcbData) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHQueryValueExA", "ptr", hkey, "ptr", pszValue, "uint*", pdwReserved, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Opens a registry key and queries it for a specific value.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * The address of the <b>null</b>-terminated string that contains the name of the value to be queried.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shqueryvalueexw
     * @since windows5.0
     */
    static SHQueryValueExW(hkey, pszValue, pdwType, pvData, pcbData) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHQueryValueExW", "ptr", hkey, "ptr", pszValue, "uint*", pdwReserved, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Enumerates the subkeys of the specified open registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {PSTR} pszName Type: <b>LPTSTR</b>
     * 
     * The address of a character buffer that receives the enumerated key name.
     * @param {Pointer<Integer>} pcchName Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shenumkeyexa
     * @since windows5.0
     */
    static SHEnumKeyExA(hkey, dwIndex, pszName, pcchName) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszName := pszName is String ? StrPtr(pszName) : pszName

        pcchNameMarshal := pcchName is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHEnumKeyExA", "ptr", hkey, "uint", dwIndex, "ptr", pszName, pcchNameMarshal, pcchName, "uint")
        return result
    }

    /**
     * Enumerates the subkeys of the specified open registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {PWSTR} pszName Type: <b>LPTSTR</b>
     * 
     * The address of a character buffer that receives the enumerated key name.
     * @param {Pointer<Integer>} pcchName Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shenumkeyexw
     * @since windows5.0
     */
    static SHEnumKeyExW(hkey, dwIndex, pszName, pcchName) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszName := pszName is String ? StrPtr(pszName) : pszName

        pcchNameMarshal := pcchName is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHEnumKeyExW", "ptr", hkey, "uint", dwIndex, "ptr", pszName, pcchNameMarshal, pcchName, "uint")
        return result
    }

    /**
     * Enumerates the values of the specified open registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {PSTR} pszValueName Type: <b>LPTSTR</b>
     * 
     * The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.
     * @param {Pointer<Integer>} pcchValueName Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shenumvaluea
     * @since windows5.0
     */
    static SHEnumValueA(hkey, dwIndex, pszValueName, pcchValueName, pdwType, pvData, pcbData) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszValueName := pszValueName is String ? StrPtr(pszValueName) : pszValueName

        pcchValueNameMarshal := pcchValueName is VarRef ? "uint*" : "ptr"
        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHEnumValueA", "ptr", hkey, "uint", dwIndex, "ptr", pszValueName, pcchValueNameMarshal, pcchValueName, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Enumerates the values of the specified open registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {PWSTR} pszValueName Type: <b>LPTSTR</b>
     * 
     * The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.
     * @param {Pointer<Integer>} pcchValueName Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a>.
     * @param {Pointer} pvData Type: <b>LPVOID</b>
     * 
     * The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shenumvaluew
     * @since windows5.0
     */
    static SHEnumValueW(hkey, dwIndex, pszValueName, pcchValueName, pdwType, pvData, pcbData) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszValueName := pszValueName is String ? StrPtr(pszValueName) : pszValueName

        pcchValueNameMarshal := pcchValueName is VarRef ? "uint*" : "ptr"
        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHEnumValueW", "ptr", hkey, "uint", dwIndex, "ptr", pszValueName, pcchValueNameMarshal, pcchValueName, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "uint")
        return result
    }

    /**
     * Retrieves information about a specified registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Integer>} pcSubKeys Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.
     * @param {Pointer<Integer>} pcchMaxSubKeyLen Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.
     * @param {Pointer<Integer>} pcValues Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of values under the specified key.
     * @param {Pointer<Integer>} pcchMaxValueNameLen Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shqueryinfokeya
     * @since windows5.0
     */
    static SHQueryInfoKeyA(hkey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey

        pcSubKeysMarshal := pcSubKeys is VarRef ? "uint*" : "ptr"
        pcchMaxSubKeyLenMarshal := pcchMaxSubKeyLen is VarRef ? "uint*" : "ptr"
        pcValuesMarshal := pcValues is VarRef ? "uint*" : "ptr"
        pcchMaxValueNameLenMarshal := pcchMaxValueNameLen is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHQueryInfoKeyA", "ptr", hkey, pcSubKeysMarshal, pcSubKeys, pcchMaxSubKeyLenMarshal, pcchMaxSubKeyLen, pcValuesMarshal, pcValues, pcchMaxValueNameLenMarshal, pcchMaxValueNameLen, "uint")
        return result
    }

    /**
     * Retrieves information about a specified registry key.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * A handle to the currently open key, or any of the following predefined values.
     * @param {Pointer<Integer>} pcSubKeys Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.
     * @param {Pointer<Integer>} pcchMaxSubKeyLen Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.
     * @param {Pointer<Integer>} pcValues Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of values under the specified key.
     * @param {Pointer<Integer>} pcchMaxValueNameLen Type: <b>LPDWORD</b>
     * 
     * The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shqueryinfokeyw
     * @since windows5.0
     */
    static SHQueryInfoKeyW(hkey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey

        pcSubKeysMarshal := pcSubKeys is VarRef ? "uint*" : "ptr"
        pcchMaxSubKeyLenMarshal := pcchMaxSubKeyLen is VarRef ? "uint*" : "ptr"
        pcValuesMarshal := pcValues is VarRef ? "uint*" : "ptr"
        pcchMaxValueNameLenMarshal := pcchMaxValueNameLen is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHQueryInfoKeyW", "ptr", hkey, pcSubKeysMarshal, pcSubKeys, pcchMaxSubKeyLenMarshal, pcchMaxSubKeyLen, pcValuesMarshal, pcValues, pcchMaxValueNameLenMarshal, pcchMaxValueNameLen, "uint")
        return result
    }

    /**
     * Recursively copies the subkeys and values of the source subkey to the destination key. SHCopyKey does not copy the security attributes of the keys.
     * @param {HKEY} hkeySrc Type: <b>HKEY</b>
     * 
     * A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).
     * @param {PSTR} pszSrcSubKey Type: <b>LPCTSTR</b>
     * 
     * The subkey whose subkeys and values are to be copied.
     * @param {HKEY} hkeyDest Type: <b>HKEY</b>
     * 
     * The destination key.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcopykeya
     * @since windows5.0
     */
    static SHCopyKeyA(hkeySrc, pszSrcSubKey, hkeyDest) {
        static fReserved := 0 ;Reserved parameters must always be NULL

        hkeySrc := hkeySrc is Win32Handle ? NumGet(hkeySrc, "ptr") : hkeySrc
        pszSrcSubKey := pszSrcSubKey is String ? StrPtr(pszSrcSubKey) : pszSrcSubKey
        hkeyDest := hkeyDest is Win32Handle ? NumGet(hkeyDest, "ptr") : hkeyDest

        result := DllCall("SHLWAPI.dll\SHCopyKeyA", "ptr", hkeySrc, "ptr", pszSrcSubKey, "ptr", hkeyDest, "uint", fReserved, "uint")
        return result
    }

    /**
     * Recursively copies the subkeys and values of the source subkey to the destination key. SHCopyKey does not copy the security attributes of the keys.
     * @param {HKEY} hkeySrc Type: <b>HKEY</b>
     * 
     * A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).
     * @param {PWSTR} pszSrcSubKey Type: <b>LPCTSTR</b>
     * 
     * The subkey whose subkeys and values are to be copied.
     * @param {HKEY} hkeyDest Type: <b>HKEY</b>
     * 
     * The destination key.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcopykeyw
     * @since windows5.0
     */
    static SHCopyKeyW(hkeySrc, pszSrcSubKey, hkeyDest) {
        static fReserved := 0 ;Reserved parameters must always be NULL

        hkeySrc := hkeySrc is Win32Handle ? NumGet(hkeySrc, "ptr") : hkeySrc
        pszSrcSubKey := pszSrcSubKey is String ? StrPtr(pszSrcSubKey) : pszSrcSubKey
        hkeyDest := hkeyDest is Win32Handle ? NumGet(hkeyDest, "ptr") : hkeyDest

        result := DllCall("SHLWAPI.dll\SHCopyKeyW", "ptr", hkeySrc, "ptr", pszSrcSubKey, "ptr", hkeyDest, "uint", fReserved, "uint")
        return result
    }

    /**
     * Retrieves a file path from the registry, expanding environment variables as needed.
     * @param {HKEY} hKey Type: <b>HKEY</b>
     * 
     * A handle to a key that is currently open, or a registry root key.
     * @param {PSTR} pcszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the name of the subkey.
     * @param {PSTR} pcszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.
     * @param {PSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetpatha
     * @since windows5.0
     */
    static SHRegGetPathA(hKey, pcszSubKey, pcszValue, pszPath, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        pcszSubKey := pcszSubKey is String ? StrPtr(pcszSubKey) : pcszSubKey
        pcszValue := pcszValue is String ? StrPtr(pcszValue) : pcszValue
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\SHRegGetPathA", "ptr", hKey, "ptr", pcszSubKey, "ptr", pcszValue, "ptr", pszPath, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Retrieves a file path from the registry, expanding environment variables as needed.
     * @param {HKEY} hKey Type: <b>HKEY</b>
     * 
     * A handle to a key that is currently open, or a registry root key.
     * @param {PWSTR} pcszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the name of the subkey.
     * @param {PWSTR} pcszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.
     * @param {PWSTR} pszPath Type: <b>LPTSTR</b>
     * 
     * A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetpathw
     * @since windows5.0
     */
    static SHRegGetPathW(hKey, pcszSubKey, pcszValue, pszPath, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        pcszSubKey := pcszSubKey is String ? StrPtr(pcszSubKey) : pcszSubKey
        pcszValue := pcszValue is String ? StrPtr(pcszValue) : pcszValue
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("SHLWAPI.dll\SHRegGetPathW", "ptr", hKey, "ptr", pcszSubKey, "ptr", pcszValue, "ptr", pszPath, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.
     * @param {HKEY} hKey Type: <b>HKEY</b>
     * 
     * A handle to a key that is currently open, or a registry root key.
     * @param {PSTR} pcszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.
     * @param {PSTR} pcszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the value to hold the path string.
     * @param {PSTR} pcszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with a fully qualified file path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregsetpatha
     * @since windows5.0
     */
    static SHRegSetPathA(hKey, pcszSubKey, pcszValue, pcszPath, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        pcszSubKey := pcszSubKey is String ? StrPtr(pcszSubKey) : pcszSubKey
        pcszValue := pcszValue is String ? StrPtr(pcszValue) : pcszValue
        pcszPath := pcszPath is String ? StrPtr(pcszPath) : pcszPath

        result := DllCall("SHLWAPI.dll\SHRegSetPathA", "ptr", hKey, "ptr", pcszSubKey, "ptr", pcszValue, "ptr", pcszPath, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.
     * @param {HKEY} hKey Type: <b>HKEY</b>
     * 
     * A handle to a key that is currently open, or a registry root key.
     * @param {PWSTR} pcszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.
     * @param {PWSTR} pcszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the value to hold the path string.
     * @param {PWSTR} pcszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with a fully qualified file path.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Reserved.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregsetpathw
     * @since windows5.0
     */
    static SHRegSetPathW(hKey, pcszSubKey, pcszValue, pcszPath, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        pcszSubKey := pcszSubKey is String ? StrPtr(pcszSubKey) : pcszSubKey
        pcszValue := pcszValue is String ? StrPtr(pcszValue) : pcszValue
        pcszPath := pcszPath is String ? StrPtr(pcszPath) : pcszPath

        result := DllCall("SHLWAPI.dll\SHRegSetPathW", "ptr", hKey, "ptr", pcszSubKey, "ptr", pcszValue, "ptr", pcszPath, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened.
     * @param {Integer} samDesired Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a></b>
     * 
     * The desired security access. For more information on security access, see <a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a>.
     * @param {Pointer} hRelativeUSKey Type: <b>HUSKEY</b>
     * 
     * The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.
     * @param {Pointer<Pointer>} phNewUSKey Type: <b>PHUSKEY</b>
     * 
     * A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregcreateuskeya
     * @since windows5.0
     */
    static SHRegCreateUSKeyA(pszPath, samDesired, hRelativeUSKey, phNewUSKey, dwFlags) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        phNewUSKeyMarshal := phNewUSKey is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegCreateUSKeyA", "ptr", pszPath, "uint", samDesired, "ptr", hRelativeUSKey, phNewUSKeyMarshal, phNewUSKey, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PWSTR} pwzPath TBD
     * @param {Integer} samDesired Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a></b>
     * 
     * The desired security access. For more information on security access, see <a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a>.
     * @param {Pointer} hRelativeUSKey Type: <b>HUSKEY</b>
     * 
     * The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.
     * @param {Pointer<Pointer>} phNewUSKey Type: <b>PHUSKEY</b>
     * 
     * A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregcreateuskeyw
     * @since windows5.0
     */
    static SHRegCreateUSKeyW(pwzPath, samDesired, hRelativeUSKey, phNewUSKey, dwFlags) {
        pwzPath := pwzPath is String ? StrPtr(pwzPath) : pwzPath

        phNewUSKeyMarshal := phNewUSKey is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegCreateUSKeyW", "ptr", pwzPath, "uint", samDesired, "ptr", hRelativeUSKey, phNewUSKeyMarshal, phNewUSKey, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PSTR} pszPath Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey.
     * @param {Integer} samDesired Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a></b>
     * 
     * The desired security access. For more information on security access, see <a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a>.
     * @param {Pointer} hRelativeUSKey Type: <b>HUSKEY</b>
     * 
     * The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.
     * @param {Pointer<Pointer>} phNewUSKey Type: <b>PHUSKEY</b>
     * 
     * A pointer to the handle of the opened key.
     * @param {BOOL} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregopenuskeya
     * @since windows5.0
     */
    static SHRegOpenUSKeyA(pszPath, samDesired, hRelativeUSKey, phNewUSKey, fIgnoreHKCU) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        phNewUSKeyMarshal := phNewUSKey is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegOpenUSKeyA", "ptr", pszPath, "uint", samDesired, "ptr", hRelativeUSKey, phNewUSKeyMarshal, phNewUSKey, "int", fIgnoreHKCU, "uint")
        return result
    }

    /**
     * Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PWSTR} pwzPath TBD
     * @param {Integer} samDesired Type: <b><a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a></b>
     * 
     * The desired security access. For more information on security access, see <a href="https://docs.microsoft.com/windows/desktop/shell/messages">REGSAM</a>.
     * @param {Pointer} hRelativeUSKey Type: <b>HUSKEY</b>
     * 
     * The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.
     * @param {Pointer<Pointer>} phNewUSKey Type: <b>PHUSKEY</b>
     * 
     * A pointer to the handle of the opened key.
     * @param {BOOL} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregopenuskeyw
     * @since windows5.0
     */
    static SHRegOpenUSKeyW(pwzPath, samDesired, hRelativeUSKey, phNewUSKey, fIgnoreHKCU) {
        pwzPath := pwzPath is String ? StrPtr(pwzPath) : pwzPath

        phNewUSKeyMarshal := phNewUSKey is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegOpenUSKeyW", "ptr", pwzPath, "uint", samDesired, "ptr", hRelativeUSKey, phNewUSKeyMarshal, phNewUSKey, "int", fIgnoreHKCU, "uint")
        return result
    }

    /**
     * Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD*</b>
     * 
     * A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>LPVOID*</b>
     * 
     * A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD*</b>
     * 
     * A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.
     * @param {BOOL} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer} pvDefaultData Type: <b>LPVOID*</b>
     * 
     * A pointer to the default data.
     * @param {Integer} dwDefaultDataSize Type: <b>DWORD</b>
     * 
     * The length, in bytes, of the default data.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregqueryusvaluea
     * @since windows5.0
     */
    static SHRegQueryUSValueA(hUSKey, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize) {
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegQueryUSValueA", "ptr", hUSKey, "ptr", pszValue, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "int", fIgnoreHKCU, "ptr", pvDefaultData, "uint", dwDefaultDataSize, "uint")
        return result
    }

    /**
     * Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD*</b>
     * 
     * A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>LPVOID*</b>
     * 
     * A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD*</b>
     * 
     * A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.
     * @param {BOOL} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer} pvDefaultData Type: <b>LPVOID*</b>
     * 
     * A pointer to the default data.
     * @param {Integer} dwDefaultDataSize Type: <b>DWORD</b>
     * 
     * The length, in bytes, of the default data.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregqueryusvaluew
     * @since windows5.0
     */
    static SHRegQueryUSValueW(hUSKey, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize) {
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegQueryUSValueW", "ptr", hUSKey, "ptr", pszValue, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "int", fIgnoreHKCU, "ptr", pvDefaultData, "uint", dwDefaultDataSize, "uint")
        return result
    }

    /**
     * Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey, it will be added.
     * 
     *                         
     * 
     * If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for the subkey's Default value.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.
     * @param {Pointer} pvData Type: <b>const void*</b>
     * 
     * A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\\mydir\\myfile" to store the string "C:\mydir\myfile".
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregwriteusvaluea
     * @since windows5.0
     */
    static SHRegWriteUSValueA(hUSKey, pszValue, dwType, pvData, cbData, dwFlags) {
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegWriteUSValueA", "ptr", hUSKey, "ptr", pszValue, "uint", dwType, "ptr", pvData, "uint", cbData, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {PWSTR} pwzValue TBD
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.
     * @param {Pointer} pvData Type: <b>const void*</b>
     * 
     * A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\\mydir\\myfile" to store the string "C:\mydir\myfile".
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregwriteusvaluew
     * @since windows5.0
     */
    static SHRegWriteUSValueW(hUSKey, pwzValue, dwType, pvData, cbData, dwFlags) {
        pwzValue := pwzValue is String ? StrPtr(pwzValue) : pwzValue

        result := DllCall("SHLWAPI.dll\SHRegWriteUSValueW", "ptr", hUSKey, "ptr", pwzValue, "uint", dwType, "ptr", pvData, "uint", cbData, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to the null-terminated string that names the value to remove.
     * @param {Integer} delRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a> that specifies from which base key the value will be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregdeleteusvaluea
     * @since windows5.0
     */
    static SHRegDeleteUSValueA(hUSKey, pszValue, delRegFlags) {
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegDeleteUSValueA", "ptr", hUSKey, "ptr", pszValue, "int", delRegFlags, "uint")
        return result
    }

    /**
     * Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {PWSTR} pwzValue TBD
     * @param {Integer} delRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a> that specifies from which base key the value will be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregdeleteusvaluew
     * @since windows5.0
     */
    static SHRegDeleteUSValueW(hUSKey, pwzValue, delRegFlags) {
        pwzValue := pwzValue is String ? StrPtr(pwzValue) : pwzValue

        result := DllCall("SHLWAPI.dll\SHRegDeleteUSValueW", "ptr", hUSKey, "ptr", pwzValue, "int", delRegFlags, "uint")
        return result
    }

    /**
     * Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {PWSTR} pwzSubKey TBD
     * @param {Integer} delRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a> that specifies from which base key the subkey will be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregdeleteemptyuskeyw
     * @since windows5.0
     */
    static SHRegDeleteEmptyUSKeyW(hUSKey, pwzSubKey, delRegFlags) {
        pwzSubKey := pwzSubKey is String ? StrPtr(pwzSubKey) : pwzSubKey

        result := DllCall("SHLWAPI.dll\SHRegDeleteEmptyUSKeyW", "ptr", hUSKey, "ptr", pwzSubKey, "int", delRegFlags, "uint")
        return result
    }

    /**
     * Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {PSTR} pszSubKey Type: <b>LPCSTR</b>
     * 
     * A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted.
     * @param {Integer} delRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregdel_flags">SHREGDEL_FLAGS</a> that specifies from which base key the subkey will be deleted.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregdeleteemptyuskeya
     * @since windows5.0
     */
    static SHRegDeleteEmptyUSKeyA(hUSKey, pszSubKey, delRegFlags) {
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey

        result := DllCall("SHLWAPI.dll\SHRegDeleteEmptyUSKeyA", "ptr", hUSKey, "ptr", pszSubKey, "int", delRegFlags, "uint")
        return result
    }

    /**
     * Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {PSTR} pszName Type: <b>LPTSTR</b>
     * 
     * A pointer to a character buffer that receives the enumerated key name.
     * @param {Pointer<Integer>} pcchName Type: <b>LPDWORD</b>
     * 
     * A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the enumeration should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregenumuskeya
     * @since windows5.0
     */
    static SHRegEnumUSKeyA(hUSKey, dwIndex, pszName, pcchName, enumRegFlags) {
        pszName := pszName is String ? StrPtr(pszName) : pszName

        pcchNameMarshal := pcchName is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegEnumUSKeyA", "ptr", hUSKey, "uint", dwIndex, "ptr", pszName, pcchNameMarshal, pcchName, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {PWSTR} pwzName TBD
     * @param {Pointer<Integer>} pcchName Type: <b>LPDWORD</b>
     * 
     * A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the enumeration should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregenumuskeyw
     * @since windows5.0
     */
    static SHRegEnumUSKeyW(hUSKey, dwIndex, pwzName, pcchName, enumRegFlags) {
        pwzName := pwzName is String ? StrPtr(pwzName) : pwzName

        pcchNameMarshal := pcchName is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegEnumUSKeyW", "ptr", hUSKey, "uint", dwIndex, "ptr", pwzName, pcchNameMarshal, pcchName, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSkey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {PSTR} pszValueName Type: <b>LPTSTR</b>
     * 
     * A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.
     * @param {Pointer<Integer>} pcchValueName Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a>.
     * @param {Pointer} pvData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the enumeration should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregenumusvaluea
     * @since windows5.0
     */
    static SHRegEnumUSValueA(hUSkey, dwIndex, pszValueName, pcchValueName, pdwType, pvData, pcbData, enumRegFlags) {
        pszValueName := pszValueName is String ? StrPtr(pszValueName) : pszValueName

        pcchValueNameMarshal := pcchValueName is VarRef ? "uint*" : "ptr"
        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegEnumUSValueA", "ptr", hUSkey, "uint", dwIndex, "ptr", pszValueName, pcchValueNameMarshal, pcchValueName, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSkey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Integer} dwIndex Type: <b>DWORD</b>
     * 
     * The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.
     * @param {PWSTR} pszValueName Type: <b>LPTSTR</b>
     * 
     * A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.
     * @param {Pointer<Integer>} pcchValueName Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.
     * @param {Pointer<Integer>} pdwType Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a>.
     * @param {Pointer} pvData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.
     * @param {Pointer<Integer>} pcbData Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the enumeration should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregenumusvaluew
     * @since windows5.0
     */
    static SHRegEnumUSValueW(hUSkey, dwIndex, pszValueName, pcchValueName, pdwType, pvData, pcbData, enumRegFlags) {
        pszValueName := pszValueName is String ? StrPtr(pszValueName) : pszValueName

        pcchValueNameMarshal := pcchValueName is VarRef ? "uint*" : "ptr"
        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegEnumUSValueW", "ptr", hUSkey, "uint", dwIndex, "ptr", pszValueName, pcchValueNameMarshal, pcchValueName, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Integer>} pcSubKeys Type: <b>LPDWORD</b>
     * 
     * A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.
     * @param {Pointer<Integer>} pcchMaxSubKeyLen Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.
     * @param {Pointer<Integer>} pcValues Type: <b>LPDWORD</b>
     * 
     * A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.
     * @param {Pointer<Integer>} pcchMaxValueNameLen Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the query should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregqueryinfouskeya
     * @since windows5.0
     */
    static SHRegQueryInfoUSKeyA(hUSKey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen, enumRegFlags) {
        pcSubKeysMarshal := pcSubKeys is VarRef ? "uint*" : "ptr"
        pcchMaxSubKeyLenMarshal := pcchMaxSubKeyLen is VarRef ? "uint*" : "ptr"
        pcValuesMarshal := pcValues is VarRef ? "uint*" : "ptr"
        pcchMaxValueNameLenMarshal := pcchMaxValueNameLen is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegQueryInfoUSKeyA", "ptr", hUSKey, pcSubKeysMarshal, pcSubKeys, pcchMaxSubKeyLenMarshal, pcchMaxSubKeyLen, pcValuesMarshal, pcValues, pcchMaxValueNameLenMarshal, pcchMaxValueNameLen, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @param {Pointer<Integer>} pcSubKeys Type: <b>LPDWORD</b>
     * 
     * A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.
     * @param {Pointer<Integer>} pcchMaxSubKeyLen Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.
     * @param {Pointer<Integer>} pcValues Type: <b>LPDWORD</b>
     * 
     * A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.
     * @param {Pointer<Integer>} pcchMaxValueNameLen Type: <b>LPDWORD</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.
     * @param {Integer} enumRegFlags Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a></b>
     * 
     * One of the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shregenum_flags">SHREGENUM_FLAGS</a> that specifies the base key in which the query should take place.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregqueryinfouskeyw
     * @since windows5.0
     */
    static SHRegQueryInfoUSKeyW(hUSKey, pcSubKeys, pcchMaxSubKeyLen, pcValues, pcchMaxValueNameLen, enumRegFlags) {
        pcSubKeysMarshal := pcSubKeys is VarRef ? "uint*" : "ptr"
        pcchMaxSubKeyLenMarshal := pcchMaxSubKeyLen is VarRef ? "uint*" : "ptr"
        pcValuesMarshal := pcValues is VarRef ? "uint*" : "ptr"
        pcchMaxValueNameLenMarshal := pcchMaxValueNameLen is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegQueryInfoUSKeyW", "ptr", hUSKey, pcSubKeysMarshal, pcSubKeys, pcchMaxSubKeyLenMarshal, pcchMaxSubKeyLen, pcValuesMarshal, pcValues, pcchMaxValueNameLenMarshal, pcchMaxValueNameLen, "int", enumRegFlags, "uint")
        return result
    }

    /**
     * Closes a handle to a user-specific registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {Pointer} hUSKey Type: <b>HUSKEY</b>
     * 
     * A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.
     * 
     *                         
     * 
     * This handle can be obtained through the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shregopenuskeya">SHRegOpenUSKey</a> function.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. Use <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregcloseuskey
     * @since windows5.0
     */
    static SHRegCloseUSKey(hUSKey) {
        result := DllCall("SHLWAPI.dll\SHRegCloseUSKey", "ptr", hUSKey, "uint")
        return result
    }

    /**
     * Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.
     * @param {Pointer<Integer>} pdwType Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the value's data.
     * @param {Pointer<Integer>} pcbData Type: <b>DWORD*</b>
     * 
     * A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.
     * @param {BOOL} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer} pvDefaultData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the value's default data.
     * @param {Integer} dwDefaultDataSize Type: <b>DWORD</b>
     * 
     * The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetusvaluea
     * @since windows5.0
     */
    static SHRegGetUSValueA(pszSubKey, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize) {
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegGetUSValueA", "ptr", pszSubKey, "ptr", pszValue, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "int", fIgnoreHKCU, "ptr", pvDefaultData, "uint", dwDefaultDataSize, "uint")
        return result
    }

    /**
     * Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PWSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.
     * @param {Pointer<Integer>} pdwType Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.
     * @param {Pointer} pvData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the value's data.
     * @param {Pointer<Integer>} pcbData Type: <b>DWORD*</b>
     * 
     * A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.
     * @param {BOOL} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.
     * @param {Pointer} pvDefaultData Type: <b>void*</b>
     * 
     * A pointer to a buffer that receives the value's default data.
     * @param {Integer} dwDefaultDataSize Type: <b>DWORD</b>
     * 
     * The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetusvaluew
     * @since windows5.0
     */
    static SHRegGetUSValueW(pszSubKey, pszValue, pdwType, pvData, pcbData, fIgnoreHKCU, pvDefaultData, dwDefaultDataSize) {
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        pdwTypeMarshal := pdwType is VarRef ? "uint*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHRegGetUSValueW", "ptr", pszSubKey, "ptr", pszValue, pdwTypeMarshal, pdwType, "ptr", pvData, pcbDataMarshal, pcbData, "int", fIgnoreHKCU, "ptr", pvDefaultData, "uint", dwDefaultDataSize, "uint")
        return result
    }

    /**
     * Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the name of the value.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID*</b>
     * 
     *  Apointer to a null-terminated string that contains the value to be set for the specified key.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags indicating where the data should be written.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregsetusvaluea
     * @since windows5.0
     */
    static SHRegSetUSValueA(pszSubKey, pszValue, dwType, pvData, cbData, dwFlags) {
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegSetUSValueA", "ptr", pszSubKey, "ptr", pszValue, "uint", dwType, "ptr", pvData, "uint", cbData, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PWSTR} pwzSubKey TBD
     * @param {PWSTR} pwzValue TBD
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/shell/hkey-type">Registry Data Types</a>.
     * @param {Pointer} pvData Type: <b>LPVOID*</b>
     * 
     *  Apointer to a null-terminated string that contains the value to be set for the specified key.
     * @param {Integer} cbData Type: <b>DWORD</b>
     * 
     * Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Flags indicating where the data should be written.
     * @returns {Integer} Type: <b>LSTATUS</b>
     * 
     * Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shregsetusvaluew
     * @since windows5.0
     */
    static SHRegSetUSValueW(pwzSubKey, pwzValue, dwType, pvData, cbData, dwFlags) {
        pwzSubKey := pwzSubKey is String ? StrPtr(pwzSubKey) : pwzSubKey
        pwzValue := pwzValue is String ? StrPtr(pwzValue) : pwzValue

        result := DllCall("SHLWAPI.dll\SHRegSetUSValueW", "ptr", pwzSubKey, "ptr", pwzValue, "uint", dwType, "ptr", pvData, "uint", cbData, "uint", dwFlags, "uint")
        return result
    }

    /**
     * Reads a numeric string value from the registry and converts it to an integer.
     * @param {HKEY} hk Type: <b>HKEY</b>
     * 
     * A handle to the registry key that specifies the value to be read.
     * @param {PWSTR} pwzKey Type: <b>LPCWSTR</b>
     * 
     * A pointer to a string value that specifies the name of the value to be read. The string must be null-terminated.
     * @param {Integer} iDefault Type: <b>int</b>
     * 
     * An <b>int</b> that specifies the value returned if the registry value cannot be retrieved successfully.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the converted string as an <b>int</b>, or the default value specified by <i>nDefault</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetintw
     * @since windows5.0
     */
    static SHRegGetIntW(hk, pwzKey, iDefault) {
        hk := hk is Win32Handle ? NumGet(hk, "ptr") : hk
        pwzKey := pwzKey is String ? StrPtr(pwzKey) : pwzKey

        result := DllCall("SHLWAPI.dll\SHRegGetIntW", "ptr", hk, "ptr", pwzKey, "int", iDefault, "int")
        return result
    }

    /**
     * Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.
     * @param {BOOL} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * A variable that specifies which key to look under. When set to <b>TRUE</b>, <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shreggetusvaluea">SHRegGetUSValue</a> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
     * @param {BOOL} fDefault Type: <b>BOOL</b>
     * 
     * A value that is returned if there is no registry value.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns either the value from the registry, or <i>fDefault</i> if none is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetboolusvaluea
     * @since windows5.0
     */
    static SHRegGetBoolUSValueA(pszSubKey, pszValue, fIgnoreHKCU, fDefault) {
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegGetBoolUSValueA", "ptr", pszSubKey, "ptr", pszValue, "int", fIgnoreHKCU, "int", fDefault, "int")
        return result
    }

    /**
     * Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).
     * @param {PWSTR} pszSubKey Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.
     * @param {BOOL} fIgnoreHKCU Type: <b>BOOL</b>
     * 
     * A variable that specifies which key to look under. When set to <b>TRUE</b>, <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shreggetusvaluea">SHRegGetUSValue</a> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.
     * @param {BOOL} fDefault Type: <b>BOOL</b>
     * 
     * A value that is returned if there is no registry value.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns either the value from the registry, or <i>fDefault</i> if none is found.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreggetboolusvaluew
     * @since windows5.0
     */
    static SHRegGetBoolUSValueW(pszSubKey, pszValue, fIgnoreHKCU, fDefault) {
        pszSubKey := pszSubKey is String ? StrPtr(pszSubKey) : pszSubKey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHRegGetBoolUSValueW", "ptr", pszSubKey, "ptr", pszValue, "int", fIgnoreHKCU, "int", fDefault, "int")
        return result
    }

    /**
     * Returns a pointer to an IQueryAssociations object.
     * @param {Guid} clsid Type: <b>CLSID</b>
     * 
     * The CLSID of the object that exposes the interface. This parameter must be set to CLSID_QueryAssociations, which is defined in Shlguid.h.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * Reference to the IID IID_IQueryAssociations, which is defined in Shlguid.h.
     * @returns {Pointer<Void>} Type: <b>void*</b>
     * 
     * When this method returns, contains the <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nn-shlwapi-iqueryassociations">IQueryAssociations</a> interface pointer requested in <i>riid</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-assoccreate
     * @since windows5.0
     */
    static AssocCreate(clsid, riid) {
        result := DllCall("SHLWAPI.dll\AssocCreate", "ptr", clsid, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Searches for and retrieves a file or protocol association-related string from the registry.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} str Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a> value that specifies the type of string that is to be returned.
     * @param {PSTR} pszAssoc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.
     * @param {PSTR} pszExtra Type: <b>LPCTSTR</b>
     * 
     * An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {PSTR} pszOut Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
     * @param {Pointer<Integer>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.
     * 
     * If the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-url_scheme">ASSOCF_NOTRUNCATE</a> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.
     * 
     * If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM error value, including the following:
     *     
     *                         
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>S_OK</td>
     * <td>Success.</td>
     * </tr>
     * <tr>
     * <td>E_POINTER</td>
     * <td>The <i>pszOut</i> buffer is too small to hold the entire string.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td><i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-assocquerystringa
     * @since windows5.0
     */
    static AssocQueryStringA(flags, str, pszAssoc, pszExtra, pszOut, pcchOut) {
        pszAssoc := pszAssoc is String ? StrPtr(pszAssoc) : pszAssoc
        pszExtra := pszExtra is String ? StrPtr(pszExtra) : pszExtra
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        pcchOutMarshal := pcchOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\AssocQueryStringA", "uint", flags, "int", str, "ptr", pszAssoc, "ptr", pszExtra, "ptr", pszOut, pcchOutMarshal, pcchOut, "int")
        return result
    }

    /**
     * Searches for and retrieves a file or protocol association-related string from the registry.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} str Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a> value that specifies the type of string that is to be returned.
     * @param {PWSTR} pszAssoc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.
     * @param {PWSTR} pszExtra Type: <b>LPCTSTR</b>
     * 
     * An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {PWSTR} pszOut Type: <b>LPTSTR</b>
     * 
     * Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
     * @param {Pointer<Integer>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.
     * 
     * If the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-url_scheme">ASSOCF_NOTRUNCATE</a> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.
     * 
     * If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM error value, including the following:
     *     
     *                         
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>S_OK</td>
     * <td>Success.</td>
     * </tr>
     * <tr>
     * <td>E_POINTER</td>
     * <td>The <i>pszOut</i> buffer is too small to hold the entire string.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td><i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-assocquerystringw
     * @since windows5.0
     */
    static AssocQueryStringW(flags, str, pszAssoc, pszExtra, pszOut, pcchOut) {
        pszAssoc := pszAssoc is String ? StrPtr(pszAssoc) : pszAssoc
        pszExtra := pszExtra is String ? StrPtr(pszExtra) : pszExtra
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        pcchOutMarshal := pcchOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\AssocQueryStringW", "uint", flags, "int", str, "ptr", pszAssoc, "ptr", pszExtra, "ptr", pszOut, pcchOutMarshal, pcchOut, "int")
        return result
    }

    /**
     * Searches for and retrieves a file association-related string from the registry starting from a specified key.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} str Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a> value that specifies the type of string that is to be returned.
     * @param {HKEY} hkAssoc Type: <b>HKEY</b>
     * 
     * The HKEY value of the key that will be used as a root key. The search looks only below this key.
     * @param {PSTR} pszExtra Type: <b>LPCTSTR</b>
     * 
     * A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {PSTR} pszOut Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
     * @param {Pointer<Integer>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer. 
     * 
     *                     
     * 
     * If the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-url_scheme">ASSOCF_NOTRUNCATE</a> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.
     * 
     * If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM error value, including the following:
     * 
     *                     
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>S_OK</td>
     * <td>Success.</td>
     * </tr>
     * <tr>
     * <td>E_POINTER</td>
     * <td>The <i>pszOut</i> buffer is too small to hold the entire string.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td><i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-assocquerystringbykeya
     * @since windows5.0
     */
    static AssocQueryStringByKeyA(flags, str, hkAssoc, pszExtra, pszOut, pcchOut) {
        hkAssoc := hkAssoc is Win32Handle ? NumGet(hkAssoc, "ptr") : hkAssoc
        pszExtra := pszExtra is String ? StrPtr(pszExtra) : pszExtra
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        pcchOutMarshal := pcchOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\AssocQueryStringByKeyA", "uint", flags, "int", str, "ptr", hkAssoc, "ptr", pszExtra, "ptr", pszOut, pcchOutMarshal, pcchOut, "int")
        return result
    }

    /**
     * Searches for and retrieves a file association-related string from the registry starting from a specified key.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} str Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assocstr">ASSOCSTR</a> value that specifies the type of string that is to be returned.
     * @param {HKEY} hkAssoc Type: <b>HKEY</b>
     * 
     * The HKEY value of the key that will be used as a root key. The search looks only below this key.
     * @param {PWSTR} pszExtra Type: <b>LPCTSTR</b>
     * 
     * A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @param {PWSTR} pszOut Type: <b>LPTSTR</b>
     * 
     * A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.
     * @param {Pointer<Integer>} pcchOut Type: <b>DWORD*</b>
     * 
     * A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer. 
     * 
     *                     
     * 
     * If the <a href="https://docs.microsoft.com/windows/win32/api/shlwapi/ne-shlwapi-url_scheme">ASSOCF_NOTRUNCATE</a> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.
     * 
     * If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns a standard COM error value, including the following:
     * 
     *                     
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Error</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>S_OK</td>
     * <td>Success.</td>
     * </tr>
     * <tr>
     * <td>E_POINTER</td>
     * <td>The <i>pszOut</i> buffer is too small to hold the entire string.</td>
     * </tr>
     * <tr>
     * <td>S_FALSE</td>
     * <td><i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-assocquerystringbykeyw
     * @since windows5.0
     */
    static AssocQueryStringByKeyW(flags, str, hkAssoc, pszExtra, pszOut, pcchOut) {
        hkAssoc := hkAssoc is Win32Handle ? NumGet(hkAssoc, "ptr") : hkAssoc
        pszExtra := pszExtra is String ? StrPtr(pszExtra) : pszExtra
        pszOut := pszOut is String ? StrPtr(pszOut) : pszOut

        pcchOutMarshal := pcchOut is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\AssocQueryStringByKeyW", "uint", flags, "int", str, "ptr", hkAssoc, "ptr", pszExtra, "ptr", pszOut, pcchOutMarshal, pcchOut, "int")
        return result
    }

    /**
     * Searches for and retrieves a key related to a file or protocol association from the registry.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} key Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assockey">ASSOCKEY</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assockey">ASSOCKEY</a> value that specifies the type of key that is to be returned.
     * @param {PSTR} pszAssoc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.
     * @param {PSTR} pszExtra Type: <b>LPCTSTR</b>
     * 
     * A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @returns {HKEY} Type: <b>HKEY*</b>
     * 
     * A pointer to the key's HKEY value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-assocquerykeya
     * @since windows5.0
     */
    static AssocQueryKeyA(flags, key, pszAssoc, pszExtra) {
        pszAssoc := pszAssoc is String ? StrPtr(pszAssoc) : pszAssoc
        pszExtra := pszExtra is String ? StrPtr(pszExtra) : pszExtra

        phkeyOut := HKEY()
        result := DllCall("SHLWAPI.dll\AssocQueryKeyA", "uint", flags, "int", key, "ptr", pszAssoc, "ptr", pszExtra, "ptr", phkeyOut, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phkeyOut
    }

    /**
     * Searches for and retrieves a key related to a file or protocol association from the registry.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a></b>
     * 
     * The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com/windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.
     * @param {Integer} key Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assockey">ASSOCKEY</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-assockey">ASSOCKEY</a> value that specifies the type of key that is to be returned.
     * @param {PWSTR} pszAssoc Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.
     * @param {PWSTR} pszExtra Type: <b>LPCTSTR</b>
     * 
     * A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.
     * @returns {HKEY} Type: <b>HKEY*</b>
     * 
     * A pointer to the key's HKEY value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-assocquerykeyw
     * @since windows5.0
     */
    static AssocQueryKeyW(flags, key, pszAssoc, pszExtra) {
        pszAssoc := pszAssoc is String ? StrPtr(pszAssoc) : pszAssoc
        pszExtra := pszExtra is String ? StrPtr(pszExtra) : pszExtra

        phkeyOut := HKEY()
        result := DllCall("SHLWAPI.dll\AssocQueryKeyW", "uint", flags, "int", key, "ptr", pszAssoc, "ptr", pszExtra, "ptr", phkeyOut, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phkeyOut
    }

    /**
     * Determines whether a file type is considered a potential security risk.
     * @param {PWSTR} pszAssoc Type: <b>PCWSTR</b>
     * 
     * A pointer to a string that contains the type of file in question. This may be either an extension such as ".exe" or a progid such as "exefile".
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the file type is considered dangerous; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-associsdangerous
     * @since windows5.1.2600
     */
    static AssocIsDangerous(pszAssoc) {
        pszAssoc := pszAssoc is String ? StrPtr(pszAssoc) : pszAssoc

        result := DllCall("SHLWAPI.dll\AssocIsDangerous", "ptr", pszAssoc, "int")
        return result
    }

    /**
     * Retrieves a file's perceived type based on its extension.
     * @param {PWSTR} pszExt Type: <b>PCWSTR</b>
     * 
     * A pointer to a buffer that contains the file's extension. This should include the leading period, for example ".txt".
     * @param {Pointer<Integer>} ptype Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-perceived">PERCEIVED</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-perceived">PERCEIVED</a> value that indicates the perceived type.
     * @param {Pointer<Integer>} pflag Type: <b>PERCEIVEDFLAG*</b>
     * @param {Pointer<PWSTR>} ppszType Type: <b>PWSTR*</b>
     * 
     * If the function returns a success code, this contains the address of a pointer to a buffer that receives the perceived type string, for instance "text" or "video". This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-assocgetperceivedtype
     * @since windows5.1.2600
     */
    static AssocGetPerceivedType(pszExt, ptype, pflag, ppszType) {
        pszExt := pszExt is String ? StrPtr(pszExt) : pszExt

        ptypeMarshal := ptype is VarRef ? "int*" : "ptr"
        pflagMarshal := pflag is VarRef ? "uint*" : "ptr"
        ppszTypeMarshal := ppszType is VarRef ? "ptr*" : "ptr"

        result := DllCall("SHLWAPI.dll\AssocGetPerceivedType", "ptr", pszExt, ptypeMarshal, ptype, pflagMarshal, pflag, ppszTypeMarshal, ppszType, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deprecated.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
     * @param {PSTR} pszSubkey Type: <b>LPCTSTR</b>
     * 
     * Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {IStream} Type: <b><a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns an <a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream. 
     * 
     *                     
     * 
     * <div class="alert"><b>Note</b>In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <a href="/windows/desktop/api/shlwapi/nf-shlwapi-shopenregstream2a">SHOpenRegStream2</a> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shopenregstreama
     * @since windows5.0
     */
    static SHOpenRegStreamA(hkey, pszSubkey, pszValue, grfMode) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubkey := pszSubkey is String ? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHOpenRegStreamA", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * Deprecated.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
     * @param {PWSTR} pszSubkey Type: <b>LPCTSTR</b>
     * 
     * Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {IStream} Type: <b><a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns an <a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream. 
     * 
     *                     
     * 
     * <div class="alert"><b>Note</b>In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <a href="/windows/desktop/api/shlwapi/nf-shlwapi-shopenregstream2a">SHOpenRegStream2</a> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shopenregstreamw
     * @since windows5.0
     */
    static SHOpenRegStreamW(hkey, pszSubkey, pszValue, grfMode) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubkey := pszSubkey is String ? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHOpenRegStreamW", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes SHOpenRegStream.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
     * @param {PSTR} pszSubkey Type: <b>LPCTSTR</b>
     * 
     * Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.
     * @param {PSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {IStream} Type: <b><a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns an <a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shopenregstream2a
     * @since windows5.0
     */
    static SHOpenRegStream2A(hkey, pszSubkey, pszValue, grfMode) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubkey := pszSubkey is String ? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHOpenRegStream2A", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes SHOpenRegStream.
     * @param {HKEY} hkey Type: <b>HKEY</b>
     * 
     * Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.
     * @param {PWSTR} pszSubkey Type: <b>LPCTSTR</b>
     * 
     * Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.
     * @param {PWSTR} pszValue Type: <b>LPCTSTR</b>
     * 
     * Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * @returns {IStream} Type: <b><a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Returns an <a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shopenregstream2w
     * @since windows5.0
     */
    static SHOpenRegStream2W(hkey, pszSubkey, pszValue, grfMode) {
        hkey := hkey is Win32Handle ? NumGet(hkey, "ptr") : hkey
        pszSubkey := pszSubkey is String ? StrPtr(pszSubkey) : pszSubkey
        pszValue := pszValue is String ? StrPtr(pszValue) : pszValue

        result := DllCall("SHLWAPI.dll\SHOpenRegStream2W", "ptr", hkey, "ptr", pszSubkey, "ptr", pszValue, "uint", grfMode, "ptr")
        return result
    }

    /**
     * SHCreateStreamOnFile may be altered or unavailable. Instead, use SHCreateStreamOnFileEx.
     * @param {PSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the file name.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * 
     * One or more <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.
     * @returns {IStream} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>**</b>
     * 
     * Receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer for the stream associated with the file.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcreatestreamonfilea
     * @since windows5.1.2600
     */
    static SHCreateStreamOnFileA(pszFile, grfMode) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\SHCreateStreamOnFileA", "ptr", pszFile, "uint", grfMode, "ptr*", &ppstm := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IStream(ppstm)
    }

    /**
     * SHCreateStreamOnFile may be altered or unavailable. Instead, use SHCreateStreamOnFileEx.
     * @param {PWSTR} pszFile Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the file name.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * 
     * One or more <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.
     * @returns {IStream} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>**</b>
     * 
     * Receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer for the stream associated with the file.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcreatestreamonfilew
     * @since windows5.1.2600
     */
    static SHCreateStreamOnFileW(pszFile, grfMode) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\SHCreateStreamOnFileW", "ptr", pszFile, "uint", grfMode, "ptr*", &ppstm := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IStream(ppstm)
    }

    /**
     * Opens or creates a file and retrieves a stream to read or write to that file.
     * @param {PWSTR} pszFile Type: <b>LPCWSTR</b>
     * 
     * A pointer to a null-terminated string that specifies the file name.
     * @param {Integer} grfMode Type: <b>DWORD</b>
     * 
     * One or more <a href="https://docs.microsoft.com/windows/desktop/Stg/stgm-constants">STGM</a> values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.
     * @param {Integer} dwAttributes Type: <b>DWORD</b>
     * 
     * One or more flag values that specify file attributes in the case that a new file is created. For a complete list of possible values, see the <i>dwFlagsAndAttributes</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {BOOL} fCreate Type: <b>BOOL</b>
     * 
     * A <b>BOOL</b> value that helps specify, in conjunction with <i>grfMode</i>, how existing files should be treated when creating the stream. See Remarks for details.
     * @param {IStream} pstmTemplate Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * Reserved.
     * @returns {IStream} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>**</b>
     * 
     * Receives an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface pointer for the stream associated with the file.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcreatestreamonfileex
     * @since windows5.1.2600
     */
    static SHCreateStreamOnFileEx(pszFile, grfMode, dwAttributes, fCreate, pstmTemplate) {
        pszFile := pszFile is String ? StrPtr(pszFile) : pszFile

        result := DllCall("SHLWAPI.dll\SHCreateStreamOnFileEx", "ptr", pszFile, "uint", grfMode, "uint", dwAttributes, "int", fCreate, "ptr", pstmTemplate, "ptr*", &ppstm := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IStream(ppstm)
    }

    /**
     * Creates a memory stream using a similar process to CreateStreamOnHGlobal.
     * @param {Pointer} pInit Type: <b>const BYTE*</b>
     * 
     * A pointer to a buffer of size <i>cbInit</i>. The contents of this buffer are used to set the initial contents of the memory stream. If this parameter is <b>NULL</b>, the returned memory stream does not have any initial content.
     * @param {Integer} cbInit Type: <b>UINT</b>
     * 
     * The number of bytes in the buffer pointed to by <i>pInit</i>. If <i>pInit</i> is set to <b>NULL</b>, <i>cbInit</i> must be zero.
     * @returns {IStream} Type: <b><a href="/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * On success, returns a pointer to the created memory stream. Returns <b>NULL</b> if the stream object could not be allocated.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcreatememstream
     * @since windows5.0
     */
    static SHCreateMemStream(pInit, cbInit) {
        result := DllCall("SHLWAPI.dll\SHCreateMemStream", "ptr", pInit, "uint", cbInit, "ptr")
        return result
    }

    /**
     * Retrieves a string used with websites when specifying language preferences.
     * @param {PSTR} pszLanguages Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.
     * @param {Pointer<Integer>} pcchLanguages Type: <b>DWORD*</b>
     * 
     * A pointer to the size, in characters, of the string at <i>pszLanguages</i>. 
     *                         
     *                         
     * 
     * On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.
     * 
     * On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-getacceptlanguagesa
     * @since windows5.0
     */
    static GetAcceptLanguagesA(pszLanguages, pcchLanguages) {
        pszLanguages := pszLanguages is String ? StrPtr(pszLanguages) : pszLanguages

        pcchLanguagesMarshal := pcchLanguages is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\GetAcceptLanguagesA", "ptr", pszLanguages, pcchLanguagesMarshal, pcchLanguages, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a string used with websites when specifying language preferences.
     * @param {PWSTR} pszLanguages Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.
     * @param {Pointer<Integer>} pcchLanguages Type: <b>DWORD*</b>
     * 
     * A pointer to the size, in characters, of the string at <i>pszLanguages</i>. 
     *                         
     *                         
     * 
     * On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.
     * 
     * On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-getacceptlanguagesw
     * @since windows5.0
     */
    static GetAcceptLanguagesW(pszLanguages, pcchLanguages) {
        pszLanguages := pszLanguages is String ? StrPtr(pszLanguages) : pszLanguages

        pcchLanguagesMarshal := pcchLanguages is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\GetAcceptLanguagesW", "ptr", pszLanguages, pcchLanguagesMarshal, pcchLanguages, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Changes the value of a Component Object Model (COM) interface pointer and releases the previous interface.
     * @remarks
     * 
     * This function mimics the behavior of a smart pointer. Conceptually, the function does the following:
     *                 
     *                 
     * 
     * <ul>
     * <li>Releases the original interface, if <i>ppunk</i> is non-<b>NULL</b></li>
     * <li>Assigns <i>punk</i> to <i>ppunk</i></li>
     * <li>Calls IUnknown::AddRef on the interface pointed to by <i>punk</i>, if <i>punk</i> is non-<b>NULL</b>.</li>
     * </ul>
     * 
     * 
     * @param {Pointer<IUnknown>} ppunk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>**</b>
     * 
     * The address of a COM interface pointer to receive the pointer assigned to <i>punk</i>. If the previous value of the pointer is non-<b>NULL</b>, the function releases that interface by calling its IUnkown::Release method.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * The interface pointer to be copied to <i>ppunk</i>. If the value is non-<b>NULL</b>, the function increments the interface's reference count.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-iunknown_set
     * @since windows5.0
     */
    static IUnknown_Set(ppunk, punk) {
        DllCall("SHLWAPI.dll\IUnknown_Set", "ptr*", ppunk, "ptr", punk)
    }

    /**
     * Releases a Component Object Model (COM) pointer and sets it to NULL.
     * @remarks
     * 
     * If <i>ppunk</i> points to a <b>NULL</b> pointer, no operation is performed. Otherwise, <i>ppunk</i> is assumed to be the address of a COM interface pointer, derived from <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>. The function calls the interface's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> method then sets the interface pointer to <b>NULL</b>.
     * 
     * 
     * 
     * @param {Pointer<Pointer<Void>>} ppunk Type: <b>void**</b>
     * 
     * The address of a pointer to a COM interface.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-iunknown_atomicrelease
     * @since windows5.0
     */
    static IUnknown_AtomicRelease(ppunk) {
        ppunkMarshal := ppunk is VarRef ? "ptr*" : "ptr"

        DllCall("SHLWAPI.dll\IUnknown_AtomicRelease", ppunkMarshal, ppunk)
    }

    /**
     * Attempts to retrieve a window handle from a Component Object Model (COM) object by querying for various interfaces that have a GetWindow method.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the COM object from which this function will attempt to obtain a window handle.
     * @returns {HWND} Type: <b>HWND*</b>
     * 
     * A pointer to a HWND that, when this function returns successfully, receives the window handle. If a window handle was not obtained, this parameter is set to <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-iunknown_getwindow
     * @since windows5.0
     */
    static IUnknown_GetWindow(punk) {
        phwnd := HWND()
        result := DllCall("SHLWAPI.dll\IUnknown_GetWindow", "ptr", punk, "ptr", phwnd, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phwnd
    }

    /**
     * Sets the specified object's site by calling its IObjectWithSite::SetSite method.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the IUnknown interface of the object whose site is to be changed.
     * @param {IUnknown} punkSite Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the IUnknown interface of the new site.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the site was successfully set, or a COM error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-iunknown_setsite
     * @since windows5.0
     */
    static IUnknown_SetSite(punk, punkSite) {
        result := DllCall("SHLWAPI.dll\IUnknown_SetSite", "ptr", punk, "ptr", punkSite, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Calls the specified object's IObjectWithSite::GetSite method.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the COM object whose <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-iobjectwithsite-getsite">IObjectWithSite::GetSite</a> method is to be called.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * The IID of the interface pointer that should be returned in <i>ppvSite</i>.
     * @returns {Pointer<Void>} Type: <b>VOID**</b>
     * 
     * The address of the pointer to receive the requested interface pointer. If the function call is successful, <i>ppvSite</i> will contain the requested interface pointer. If no site is available or the requested interface is not supported, <i>ppvSite</i> is set to <b>NULL</b> and the function returns a COM error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-iunknown_getsite
     * @since windows5.0
     */
    static IUnknown_GetSite(punk, riid) {
        result := DllCall("SHLWAPI.dll\IUnknown_GetSite", "ptr", punk, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Retrieves an interface for a service from a specified object.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> instance of the COM object that supports the service.
     * @param {Pointer<Guid>} guidService Type: <b>REFGUID</b>
     * 
     * The service's unique identifier (SID).
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * The IID of the desired service interface.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns, contains the interface pointer requested <i>riid</i>. If successful, the calling application is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release">IUnknown::Release</a> using this value when the service is no longer needed. In the case of failure, this value is <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-iunknown_queryservice
     * @since windows5.0
     */
    static IUnknown_QueryService(punk, guidService, riid) {
        result := DllCall("SHLWAPI.dll\IUnknown_QueryService", "ptr", punk, "ptr", guidService, "ptr", riid, "ptr*", &ppvOut := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvOut
    }

    /**
     * Reads bytes from a specified stream and returns a value that indicates whether all bytes were successfully read.
     * @param {IStream} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface of the stream from which to read.
     * @param {Pointer} pv Type: <b>VOID*</b>
     * 
     * A pointer to a buffer to receive the stream data from <i>pstm</i>. This buffer must be at least <i>cb</i> bytes in size.
     * @param {Integer} cb Type: <b>ULONG</b>
     * 
     * The number of bytes of data that the function should attempt to read from the input stream.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> if the function successfully reads the specified number of bytes from the stream, or a COM failure code otherwise. In particular, if the read attempt was successful but fewer than <i>cb</i> bytes were read, the function returns <b>E_FAIL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_read
     * @since windows5.0
     */
    static IStream_Read(pstm, pv, cb) {
        result := DllCall("SHLWAPI.dll\IStream_Read", "ptr", pstm, "ptr", pv, "uint", cb, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Writes data of unknown format from a buffer to a specified stream.
     * @param {IStream} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> pointer that specifies the target stream.
     * @param {Pointer} pv Type: <b>const void*</b>
     * 
     * Pointer to a buffer that holds the data to send to the target stream. This buffer must be at least <i>cb</i> bytes in size.
     * @param {Integer} cb Type: <b>ULONG</b>
     * 
     * The number of bytes of data to write to the target stream.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns S_OK if the function successfully wrote the specified number of bytes to the stream, or an error value otherwise. In particular, if less than <i>cb</i> bytes was written to the target stream, even if some data was successfully written, the function returns E_FAIL.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_write
     * @since windows6.0.6000
     */
    static IStream_Write(pstm, pv, cb) {
        result := DllCall("SHLWAPI.dll\IStream_Write", "ptr", pstm, "ptr", pv, "uint", cb, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Moves the seek position in a specified stream to the beginning of the stream.
     * @param {IStream} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface of the stream whose position is to be reset.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * Returns <b>S_OK</b> on success or a COM failure code otherwise. See <a href="/windows/desktop/api/objidl/nf-objidl-istream-seek">IStream::Seek</a> for further discussion of possible error codes.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_reset
     * @since windows5.0
     */
    static IStream_Reset(pstm) {
        result := DllCall("SHLWAPI.dll\IStream_Reset", "ptr", pstm, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the size, in bytes, of a specified stream.
     * @param {IStream} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> interface of the stream whose size is to be determined.
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a> structure to receive the size of the stream.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_size
     * @since windows5.0
     */
    static IStream_Size(pstm) {
        result := DllCall("SHLWAPI.dll\IStream_Size", "ptr", pstm, "uint*", &pui := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pui
    }

    /**
     * Establishes or terminates a connection between a client's sink and a connection point container.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface of the object to be connected to the connection point container. If you set <i>fConnect</i> to <b>FALSE</b> to indicate that you are disconnecting the object, this parameter is ignored and can be set to <b>NULL</b>.
     * @param {Pointer<Guid>} riidEvent Type: <b>REFIID</b>
     * 
     * The IID of the interface on the connection point container whose connection point object is being requested.
     * @param {BOOL} fConnect Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if a connection is being established; <b>FALSE</b> if a connection is being broken.
     * @param {IUnknown} punkTarget Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the connection point container's <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface.
     * @param {Pointer<Integer>} pdwCookie Type: <b>DWORD*</b>
     * 
     * A connection token. If you set <i>fConnect</i> to <b>TRUE</b> to make a new connection, this parameter receives a token that uniquely identifies the connection. If you set <i>fConnect</i> to <b>FALSE</b> to break a connection, this parameter must point to the token that you received when you called <b>ConnectToConnectionPoint</b> to establish the connection.
     * @param {Pointer<IConnectionPoint>} ppcpOut Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-iconnectionpoint">IConnectionPoint</a>**</b>
     * 
     * A pointer to the connection point container's <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-iconnectionpoint">IConnectionPoint</a> interface, if the operation was successful. The calling application must release this pointer when it is no longer needed. If the request is unsuccessful, the pointer receives <b>NULL</b>. This parameter is optional and can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-connecttoconnectionpoint
     * @since windows5.0
     */
    static ConnectToConnectionPoint(punk, riidEvent, fConnect, punkTarget, pdwCookie, ppcpOut) {
        pdwCookieMarshal := pdwCookie is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\ConnectToConnectionPoint", "ptr", punk, "ptr", riidEvent, "int", fConnect, "ptr", punkTarget, pdwCookieMarshal, pdwCookie, "ptr*", ppcpOut, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Reads a pointer to an item identifier list (PIDL) from an IStream object into a PIDLIST_RELATIVE object.
     * @param {IStream} pstm Type: <b>IStream*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> from which the PIDL is read.
     * @returns {Pointer<ITEMIDLIST>} Type: <b>PIDLIST_RELATIVE*</b>
     * 
     * A pointer to the resulting PIDL.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_readpidl
     * @since windows6.0.6000
     */
    static IStream_ReadPidl(pstm) {
        result := DllCall("SHLWAPI.dll\IStream_ReadPidl", "ptr", pstm, "ptr*", &ppidlOut := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppidlOut
    }

    /**
     * Writes a pointer to an item identifier list (PIDL) from a PCUIDLIST_RELATIVE object into an IStream object.
     * @param {IStream} pstm Type: <b>IStream*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a> object in which to write.
     * @param {Pointer<ITEMIDLIST>} pidlWrite Type: <b>PCUIDLIST_RELATIVE</b>
     * 
     * The source PIDL.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_writepidl
     * @since windows6.0.6000
     */
    static IStream_WritePidl(pstm, pidlWrite) {
        result := DllCall("SHLWAPI.dll\IStream_WritePidl", "ptr", pstm, "ptr", pidlWrite, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Reads from a stream and writes into a string.
     * @param {IStream} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the stream from which to read.
     * @returns {PWSTR} Type: <b>PWSTR*</b>
     * 
     * A pointer to the null-terminated, Unicode string into which the stream is written.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_readstr
     * @since windows6.0.6000
     */
    static IStream_ReadStr(pstm) {
        result := DllCall("SHLWAPI.dll\IStream_ReadStr", "ptr", pstm, "ptr*", &ppsz := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppsz
    }

    /**
     * Reads from a string and writes into a stream.
     * @param {IStream} pstm Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the stream in which to write.
     * @param {PWSTR} psz Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated, Unicode string from which to read.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_writestr
     * @since windows6.0.6000
     */
    static IStream_WriteStr(pstm, psz) {
        psz := psz is String ? StrPtr(psz) : psz

        result := DllCall("SHLWAPI.dll\IStream_WriteStr", "ptr", pstm, "ptr", psz, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Copies a stream to another stream.
     * @param {IStream} pstmFrom Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the source stream.
     * @param {IStream} pstmTo Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-istream">IStream</a>*</b>
     * 
     * A pointer to the destination stream.
     * @param {Integer} cb Type: <b>DWORD</b>
     * 
     * The number of bytes to copy from the source stream.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-istream_copy
     * @since windows6.0.6000
     */
    static IStream_Copy(pstmFrom, pstmTo, cb) {
        result := DllCall("SHLWAPI.dll\IStream_Copy", "ptr", pstmFrom, "ptr", pstmTo, "uint", cb, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * SHGetViewStatePropertyBag may be altered or unavailable.
     * @param {Pointer<ITEMIDLIST>} pidl Type: <b>PCIDLIST_ABSOLUTE</b>
     * 
     * A PIDL of the folder for which you are requesting properties. This parameter must be <b>NULL</b> if the SHGVSPB_ALLFOLDERS flag is passed.
     * @param {PWSTR} pszBagName Type: <b>PCWSTR</b>
     * 
     * A pointer to a string that contains the name of the requested property bag.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * A value that specifies a combination of the following flags.
     * 
     * 
     * One value from the following set of flags is required.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns successfully, contains the interface pointer requested in <i>riid</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shgetviewstatepropertybag
     * @since windows5.1.2600
     */
    static SHGetViewStatePropertyBag(pidl, pszBagName, dwFlags, riid) {
        pszBagName := pszBagName is String ? StrPtr(pszBagName) : pszBagName

        result := DllCall("SHLWAPI.dll\SHGetViewStatePropertyBag", "ptr", pidl, "ptr", pszBagName, "uint", dwFlags, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * SHFormatDateTime may be altered or unavailable.
     * @param {Pointer<FILETIME>} pft Type: <b>const FILETIME UNALIGNED*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure whose time is to be converted to a string.
     * @param {Pointer<Integer>} pdwFlags Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that contains bitwise flags that specify the date and time format.
     * 
     * 
     * 
     * 
     * When you call the function, you can combine zero or more of the following flags, with exceptions as noted. You can also set this parameter to <b>NULL</b>, in which case the function assumes that the FDTF_DEFAULT flag is set.
     * @param {PSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that receives the formatted date and time. The buffer must be large enough to contain the number of TCHAR characters specified by the <i>cchBuf</i> parameter, including a terminating null character.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The number of TCHARs that can be contained by the buffer pointed to by <i>pszBuf</i>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of TCHARs written to the buffer, including the terminating null character. On failure, this value is 0.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shformatdatetimea
     * @since windows5.1.2600
     */
    static SHFormatDateTimeA(pft, pdwFlags, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        pdwFlagsMarshal := pdwFlags is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHFormatDateTimeA", "ptr", pft, pdwFlagsMarshal, pdwFlags, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * SHFormatDateTime may be altered or unavailable.
     * @param {Pointer<FILETIME>} pft Type: <b>const FILETIME UNALIGNED*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure whose time is to be converted to a string.
     * @param {Pointer<Integer>} pdwFlags Type: <b>DWORD*</b>
     * 
     * A pointer to a <b>DWORD</b> value that contains bitwise flags that specify the date and time format.
     * 
     * 
     * 
     * 
     * When you call the function, you can combine zero or more of the following flags, with exceptions as noted. You can also set this parameter to <b>NULL</b>, in which case the function assumes that the FDTF_DEFAULT flag is set.
     * @param {PWSTR} pszBuf Type: <b>LPTSTR</b>
     * 
     * A pointer to a buffer that receives the formatted date and time. The buffer must be large enough to contain the number of TCHAR characters specified by the <i>cchBuf</i> parameter, including a terminating null character.
     * @param {Integer} cchBuf Type: <b>UINT</b>
     * 
     * The number of TCHARs that can be contained by the buffer pointed to by <i>pszBuf</i>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of TCHARs written to the buffer, including the terminating null character. On failure, this value is 0.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shformatdatetimew
     * @since windows5.1.2600
     */
    static SHFormatDateTimeW(pft, pdwFlags, pszBuf, cchBuf) {
        pszBuf := pszBuf is String ? StrPtr(pszBuf) : pszBuf

        pdwFlagsMarshal := pdwFlags is VarRef ? "uint*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHFormatDateTimeW", "ptr", pft, pdwFlagsMarshal, pdwFlags, "ptr", pszBuf, "uint", cchBuf, "int")
        return result
    }

    /**
     * Converts a string from the ANSI code page to the Unicode code page.
     * @param {PSTR} pszSrc Type: <b>PCSTR</b>
     * 
     * A pointer to a null-terminated ANSI string to be converted to Unicode.
     * @param {PWSTR} pwszDst Type: <b>PWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the string specified by <i>pszSrc</i>, after the ANSI characters have been converted to Unicode (WCHAR). The buffer must be large enough to contain the number of Unicode characters specified by the <i>cwchBuf</i> parameter, including a terminating null character.
     * @param {Integer} cwchBuf Type: <b>int</b>
     * 
     * The number of Unicode characters that can be contained by the buffer pointed to by <i>pwszDst</i>. This parameter must be greater than zero.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of Unicode characters written to <i>pwszDst</i>, including the terminating null character. Returns 0 if unsuccessful.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shansitounicode
     * @since windows5.0
     */
    static SHAnsiToUnicode(pszSrc, pwszDst, cwchBuf) {
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc
        pwszDst := pwszDst is String ? StrPtr(pwszDst) : pwszDst

        result := DllCall("SHLWAPI.dll\SHAnsiToUnicode", "ptr", pszSrc, "ptr", pwszDst, "int", cwchBuf, "int")
        return result
    }

    /**
     * Copies an ANSI string.
     * @param {PSTR} pszSrc Type: <b>LPCSTR</b>
     * 
     * A pointer to a null-terminated ANSI string to be converted to Unicode.
     * @param {PSTR} pszDst Type: <b>LPWSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the characters copied from <i>pszSrc</i>. The buffer must be large enough to contain the number of characters specified by the <i>cchBuf</i> parameter, including a room for a terminating null character.
     * @param {Integer} cchBuf Type: <b>int</b>
     * 
     * The number of characters that can be contained by the buffer pointed to by <i>pszDst</i>. This parameter must be greater than zero.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of characters written to <i>pszDst</i>, including the terminating null character. Returns 0 if unsuccessful.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shansitoansi
     * @since windows5.0
     */
    static SHAnsiToAnsi(pszSrc, pszDst, cchBuf) {
        pszSrc := pszSrc is String ? StrPtr(pszSrc) : pszSrc
        pszDst := pszDst is String ? StrPtr(pszDst) : pszDst

        result := DllCall("SHLWAPI.dll\SHAnsiToAnsi", "ptr", pszSrc, "ptr", pszDst, "int", cchBuf, "int")
        return result
    }

    /**
     * Converts a string from the Unicode code page to the ANSI code page.
     * @param {PWSTR} pwszSrc Type: <b>PCWSTR</b>
     * 
     * A pointer to the null-terminated Unicode string to be converted to ANSI.
     * @param {PSTR} pszDst Type: <b>PSTR</b>
     * 
     * A pointer to a buffer that, when this function returns successfully, receives the converted characters. The buffer must be large enough to contain the number of <b>CHAR</b> characters specified by the <i>cchBuf</i> parameter, including room for a terminating null character.
     * @param {Integer} cchBuf Type: <b>int</b>
     * 
     * The number of <b>CHAR</b> values that can be contained by the buffer pointed to by <i>pszDst</i>. The value assigned to parameter must be greater than zero.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of <b>CHAR</b> values written to the output buffer, including the terminating null character. Returns 0 if unsuccessful.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shunicodetoansi
     * @since windows5.0
     */
    static SHUnicodeToAnsi(pwszSrc, pszDst, cchBuf) {
        pwszSrc := pwszSrc is String ? StrPtr(pwszSrc) : pwszSrc
        pszDst := pszDst is String ? StrPtr(pszDst) : pszDst

        result := DllCall("SHLWAPI.dll\SHUnicodeToAnsi", "ptr", pwszSrc, "ptr", pszDst, "int", cchBuf, "int")
        return result
    }

    /**
     * Copies a Unicode string.
     * @param {PWSTR} pwzSrc Type: <b>PCWSTR</b>
     * 
     * A pointer to a null-terminated Unicode string to be copied to the output buffer.
     * @param {PWSTR} pwzDst Type: <b>PWSTR</b>
     * 
     * A pointer to an output buffer to receive the copied characters. The buffer must be large enough to contain the number of <b>WCHAR</b> characters specified by <i>cwchBuf</i>, including room for a terminating null character.
     * @param {Integer} cwchBuf Type: <b>int</b>
     * 
     * The number of <b>WCHAR</b> characters that can be contained by the buffer pointed to by <i>pwzDst</i> parameter. This parameter must be greater than zero.
     * @returns {Integer} Type: <b>int</b>
     * 
     * Returns the number of <b>WCHAR</b> characters written to the output buffer, including the terminating null character. Returns 0 if unsuccessful.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shunicodetounicode
     * @since windows5.0
     */
    static SHUnicodeToUnicode(pwzSrc, pwzDst, cwchBuf) {
        pwzSrc := pwzSrc is String ? StrPtr(pwzSrc) : pwzSrc
        pwzDst := pwzDst is String ? StrPtr(pwzDst) : pwzDst

        result := DllCall("SHLWAPI.dll\SHUnicodeToUnicode", "ptr", pwzSrc, "ptr", pwzDst, "int", cwchBuf, "int")
        return result
    }

    /**
     * SHMessageBoxCheck may be altered or unavailable.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * The window handle to the message box's owner. This value can be <b>NULL</b>.
     * @param {PSTR} pszText Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the message to be displayed.
     * @param {PSTR} pszCaption Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the title of the message box. If this parameter is set to <b>NULL</b>, the title is set to <b>Error!</b>.
     * @param {Integer} uType Type: <b>UINT</b>
     * 
     * The flags that specify the contents and behavior of the message box. This function supports only a subset of the flags supported by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>. If you use any flags that are not listed below, the function's behavior is undefined.
     * 
     * 
     * You must specify the buttons to be displayed by setting one and only one of the following flags.
     * @param {Integer} iDefault Type: <b>int</b>
     * 
     * The value that the function returns when the user has opted not to have the message box displayed again. If the user has not opted to suppress the message box, the message box is displayed and the function ignores <i>iDefault</i>.
     * @param {PSTR} pszRegVal Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains a unique string value to associate with this message. To avoid collisions with values used by Microsoft, this string should include a GUID. This string must not exceed REGSTR_MAX_VALUE_LENGTH characters in length, including the terminating null character.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the user has already chosen to suppress the message box, the function immediately returns the value assigned to <i>iDefault</i>.
     * 
     * If the user clicks the <b>OK</b>, <b>Cancel</b>, <b>Yes</b>, or <b>No</b> button, the function returns IDOK, IDCANCEL, IDYES, or IDNO, respectively.
     * 
     * If the user closes the message box by clicking the <b>X</b> button in the caption, the function returns IDCANCEL. This value is returned in this case even if the MB_OKCANCEL flag has not been set.
     * 
     * If an error occurs, the return value is normally 1. However, under certain low-memory conditions, the function might return <i>iDefault</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shmessageboxchecka
     * @since windows5.1.2600
     */
    static SHMessageBoxCheckA(hwnd, pszText, pszCaption, uType, iDefault, pszRegVal) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszText := pszText is String ? StrPtr(pszText) : pszText
        pszCaption := pszCaption is String ? StrPtr(pszCaption) : pszCaption
        pszRegVal := pszRegVal is String ? StrPtr(pszRegVal) : pszRegVal

        result := DllCall("SHLWAPI.dll\SHMessageBoxCheckA", "ptr", hwnd, "ptr", pszText, "ptr", pszCaption, "uint", uType, "int", iDefault, "ptr", pszRegVal, "int")
        return result
    }

    /**
     * SHMessageBoxCheck may be altered or unavailable.
     * @param {HWND} hwnd Type: <b>HWND</b>
     * 
     * The window handle to the message box's owner. This value can be <b>NULL</b>.
     * @param {PWSTR} pszText Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the message to be displayed.
     * @param {PWSTR} pszCaption Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains the title of the message box. If this parameter is set to <b>NULL</b>, the title is set to <b>Error!</b>.
     * @param {Integer} uType Type: <b>UINT</b>
     * 
     * The flags that specify the contents and behavior of the message box. This function supports only a subset of the flags supported by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>. If you use any flags that are not listed below, the function's behavior is undefined.
     * 
     * 
     * You must specify the buttons to be displayed by setting one and only one of the following flags.
     * @param {Integer} iDefault Type: <b>int</b>
     * 
     * The value that the function returns when the user has opted not to have the message box displayed again. If the user has not opted to suppress the message box, the message box is displayed and the function ignores <i>iDefault</i>.
     * @param {PWSTR} pszRegVal Type: <b>LPCTSTR</b>
     * 
     * A pointer to a null-terminated string that contains a unique string value to associate with this message. To avoid collisions with values used by Microsoft, this string should include a GUID. This string must not exceed REGSTR_MAX_VALUE_LENGTH characters in length, including the terminating null character.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the user has already chosen to suppress the message box, the function immediately returns the value assigned to <i>iDefault</i>.
     * 
     * If the user clicks the <b>OK</b>, <b>Cancel</b>, <b>Yes</b>, or <b>No</b> button, the function returns IDOK, IDCANCEL, IDYES, or IDNO, respectively.
     * 
     * If the user closes the message box by clicking the <b>X</b> button in the caption, the function returns IDCANCEL. This value is returned in this case even if the MB_OKCANCEL flag has not been set.
     * 
     * If an error occurs, the return value is normally 1. However, under certain low-memory conditions, the function might return <i>iDefault</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shmessageboxcheckw
     * @since windows5.1.2600
     */
    static SHMessageBoxCheckW(hwnd, pszText, pszCaption, uType, iDefault, pszRegVal) {
        hwnd := hwnd is Win32Handle ? NumGet(hwnd, "ptr") : hwnd
        pszText := pszText is String ? StrPtr(pszText) : pszText
        pszCaption := pszCaption is String ? StrPtr(pszCaption) : pszCaption
        pszRegVal := pszRegVal is String ? StrPtr(pszRegVal) : pszRegVal

        result := DllCall("SHLWAPI.dll\SHMessageBoxCheckW", "ptr", hwnd, "ptr", pszText, "ptr", pszCaption, "uint", uType, "int", iDefault, "ptr", pszRegVal, "int")
        return result
    }

    /**
     * Sends a message to all top-level windows in the system.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to send.
     * @param {WPARAM} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {LPARAM} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {LRESULT} Type: <b>LRESULT</b>
     * 
     * The return value is not meaningful.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shsendmessagebroadcasta
     * @since windows5.1.2600
     */
    static SHSendMessageBroadcastA(uMsg, wParam, lParam) {
        result := DllCall("SHLWAPI.dll\SHSendMessageBroadcastA", "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Sends a message to all top-level windows in the system.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to send.
     * @param {WPARAM} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {LPARAM} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {LRESULT} Type: <b>LRESULT</b>
     * 
     * The return value is not meaningful.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shsendmessagebroadcastw
     * @since windows5.1.2600
     */
    static SHSendMessageBroadcastW(uMsg, wParam, lParam) {
        result := DllCall("SHLWAPI.dll\SHSendMessageBroadcastW", "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Removes the mnemonic marker from a string.
     * @param {PSTR} pszMenu Type: <b>LPTSTR*</b>
     * 
     * A pointer to the null-terminated string that contains the mnemonic marker.
     * @returns {CHAR} Type: <b>TCHAR</b>
     * 
     * Returns the mnemonic character, if one was found. Otherwise, returns 0.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shstripmneumonica
     * @since windows5.0
     */
    static SHStripMneumonicA(pszMenu) {
        pszMenu := pszMenu is String ? StrPtr(pszMenu) : pszMenu

        result := DllCall("SHLWAPI.dll\SHStripMneumonicA", "ptr", pszMenu, "char")
        return result
    }

    /**
     * Removes the mnemonic marker from a string.
     * @param {PWSTR} pszMenu Type: <b>LPTSTR*</b>
     * 
     * A pointer to the null-terminated string that contains the mnemonic marker.
     * @returns {Integer} Type: <b>TCHAR</b>
     * 
     * Returns the mnemonic character, if one was found. Otherwise, returns 0.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shstripmneumonicw
     * @since windows5.0
     */
    static SHStripMneumonicW(pszMenu) {
        pszMenu := pszMenu is String ? StrPtr(pszMenu) : pszMenu

        result := DllCall("SHLWAPI.dll\SHStripMneumonicW", "ptr", pszMenu, "char")
        return result
    }

    /**
     * Checks for specified operating systems and operating system features.
     * @param {Integer} dwOS Type: <b>DWORD</b>
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns a nonzero value if the specified operating system or operating system feature is detected, otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-isos
     * @since windows5.0
     */
    static IsOS(dwOS) {
        result := DllCall("SHLWAPI.dll\IsOS", "uint", dwOS, "int")
        return result
    }

    /**
     * Gets the current value of a global counter.
     * @param {Integer} id Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a> for which to retrieve the current value.
     * @returns {Integer} Type: <b>long</b>
     * 
     * The current value of the counter.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shglobalcountergetvalue
     * @since windows6.1
     */
    static SHGlobalCounterGetValue(id) {
        result := DllCall("SHLWAPI.dll\SHGlobalCounterGetValue", "int", id, "int")
        return result
    }

    /**
     * Increments a global counter.
     * @param {Integer} id Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a> to increment.
     * @returns {Integer} Type: <b>long</b>
     * 
     * The value of the counter after the increment.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shglobalcounterincrement
     * @since windows6.1
     */
    static SHGlobalCounterIncrement(id) {
        result := DllCall("SHLWAPI.dll\SHGlobalCounterIncrement", "int", id, "int")
        return result
    }

    /**
     * Decrements a global counter.
     * @param {Integer} id Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a></b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ne-shlwapi-shglobalcounter">SHGLOBALCOUNTER</a> to decrement.
     * @returns {Integer} Type: <b>long</b>
     * 
     * The value of the counter after the decrement.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shglobalcounterdecrement
     * @since windows6.1
     */
    static SHGlobalCounterDecrement(id) {
        result := DllCall("SHLWAPI.dll\SHGlobalCounterDecrement", "int", id, "int")
        return result
    }

    /**
     * SHAllocShared may be altered or unavailable.
     * @param {Pointer} pvData Type: <b>const void*</b>
     * 
     * A pointer to the memory block in the calling process that is to be copied. You can set this parameter to <b>NULL</b> if you want to share a block of memory without copying any data to it.
     * @param {Integer} dwSize Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the memory block pointed to by <i>pvData</i>.
     * @param {Integer} dwProcessId Type: <b>DWORD</b>
     * 
     * The process ID of the process that will share memory block specified by <i>pvData</i>.
     * @returns {HANDLE} Type: <b>HANDLE</b>
     * 
     * Returns a handle to the shared memory for the process specified by <i>dwDestinationProcessId</i>. Returns <b>NULL</b> if unsuccessful.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shallocshared
     * @since windows5.1.2600
     */
    static SHAllocShared(pvData, dwSize, dwProcessId) {
        result := DllCall("SHLWAPI.dll\SHAllocShared", "ptr", pvData, "uint", dwSize, "uint", dwProcessId, "ptr")
        resultHandle := HANDLE({Value: result}, True)
        return resultHandle
    }

    /**
     * SHFreeShared may be altered or unavailable.
     * @param {HANDLE} hData Type: <b>HANDLE</b>
     * 
     * A handle to the mapped memory.
     * @param {Integer} dwProcessId Type: <b>DWORD</b>
     * 
     * The process ID of the process from which the memory was allocated.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shfreeshared
     * @since windows5.1.2600
     */
    static SHFreeShared(hData, dwProcessId) {
        hData := hData is Win32Handle ? NumGet(hData, "ptr") : hData

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\SHFreeShared", "ptr", hData, "uint", dwProcessId, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * SHLockShared may be altered or unavailable.
     * @param {HANDLE} hData Type: <b>HANDLE</b>
     * 
     * A handle to the memory you want to map into the calling process.
     * @param {Integer} dwProcessId Type: <b>DWORD</b>
     * 
     * The process ID of the process from which you want to map the block of memory.
     * @returns {Pointer<Void>} Returns a void pointer to the shared memory. Returns <b>NULL</b> if unsuccessful.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shlockshared
     * @since windows5.1.2600
     */
    static SHLockShared(hData, dwProcessId) {
        hData := hData is Win32Handle ? NumGet(hData, "ptr") : hData

        result := DllCall("SHLWAPI.dll\SHLockShared", "ptr", hData, "uint", dwProcessId, "ptr")
        return result
    }

    /**
     * SHUnlockShared may be altered or unavailable.
     * @param {Pointer<Void>} pvData Type: <b>void*</b>
     * 
     * A pointer to the shared memory block returned by <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/nf-shlwapi-shlockshared">SHLockShared</a>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is <b>TRUE</b> and all modified pages within the specified range are written to the disk with low priority. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shunlockshared
     * @since windows5.1.2600
     */
    static SHUnlockShared(pvData) {
        pvDataMarshal := pvData is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\SHUnlockShared", pvDataMarshal, pvData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * WhichPlatform may be altered or unavailable.
     * @returns {Integer} Type: <b>UINT</b>
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PLATFORM_UNKNOWN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was unable to determine the Shell32.dll version.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PLATFORM_IE3</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obsolete: Use PLATFORM_BROWSERONLY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PLATFORM_BROWSERONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Shell32.dll version is browser-only, with no new shell.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PLATFORM_INTEGRATED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The platform contains an integrated shell.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-whichplatform
     * @since windows5.1.2600
     */
    static WhichPlatform() {
        result := DllCall("SHLWAPI.dll\WhichPlatform", "uint")
        return result
    }

    /**
     * A table-driven implementation of the IUnknown::QueryInterface method.
     * @param {Pointer<Void>} that Type: <b>void*</b>
     * 
     * A pointer to the base of a COM object.
     * @param {Pointer<QITAB>} pqit Type: <b>LPCQITAB</b>
     * 
     * An array of <a href="https://docs.microsoft.com/windows/desktop/api/shlwapi/ns-shlwapi-qitab">QITAB</a> structures. The last structure in the array must have its <b>piid</b> member set to <b>NULL</b> and its <b>dwOffset</b> member set to 0.
     * @param {Pointer<Guid>} riid Type: <b>REFIID</b>
     * 
     * A reference to the IID of the interface to retrieve through <i>ppv</i>.
     * @returns {Pointer<Void>} Type: <b>void**</b>
     * 
     * When this method returns successfully, contains the interface pointer requested in <i>riid</i>.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-qisearch
     * @since windows5.0
     */
    static QISearch(that, pqit, riid) {
        thatMarshal := that is VarRef ? "ptr" : "ptr"

        result := DllCall("SHLWAPI.dll\QISearch", thatMarshal, that, "ptr", pqit, "ptr", riid, "ptr*", &ppv := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppv
    }

    /**
     * Not supported.
     * @param {Integer} dwType Type: <b>DWORD</b>
     * 
     * The type of machine being examined. The following is the only recognized value.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the machine is considered low on resources, <b>FALSE</b> otherwise.
     * 
     * <div class="alert"><b>Note</b>Always returns <b>FALSE</b> under WindowsXP.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shislowmemorymachine
     * @since windows5.1.2600
     */
    static SHIsLowMemoryMachine(dwType) {
        result := DllCall("SHLWAPI.dll\SHIsLowMemoryMachine", "uint", dwType, "int")
        return result
    }

    /**
     * GetMenuPosFromID may be altered or unavailable.
     * @param {HMENU} hmenu Type: <b>HMENU</b>
     * 
     * The handle of the menu.
     * @param {Integer} id Type: <b>UINT</b>
     * 
     * An application-defined 16-bit value that identifies the menu item.
     * @returns {Integer} Type: <b>int</b>
     * 
     * The item's zero-based position in the menu.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-getmenuposfromid
     * @since windows5.1.2600
     */
    static GetMenuPosFromID(hmenu, id) {
        hmenu := hmenu is Win32Handle ? NumGet(hmenu, "ptr") : hmenu

        result := DllCall("SHLWAPI.dll\GetMenuPosFromID", "ptr", hmenu, "uint", id, "int")
        return result
    }

    /**
     * Retrieves the inverse color table mapping for the halftone palette.
     * @param {Pointer} pbMap Type: <b>BYTE*</b>
     * 
     * A pointer to an array of <b>BYTE</b><b>s</b> that receives the inverse color table mapping, or a pointer to an <b>LPBYTE</b> which receives a pointer to a cached copy of the inverse color table mapping, depending on the value of the <i>cbMap</i> parameter.
     * @param {Integer} cbMap Type: <b>ULONG</b>
     * 
     * The size of the buffer pointed to by <i>pbMap</i>, which also defines its contents. Two values are recognized.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shgetinversecmap
     * @since windows5.0
     */
    static SHGetInverseCMAP(pbMap, cbMap) {
        result := DllCall("SHLWAPI.dll\SHGetInverseCMAP", "ptr", pbMap, "uint", cbMap, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Instructs system edit controls to use AutoComplete to help complete URLs or file system paths.
     * @param {HWND} hwndEdit Type: <b>HWND</b>
     * 
     * The window handle of a system edit control. Typically, this parameter is the handle of an edit control or the edit control embedded in a <a href="https://docs.microsoft.com/windows/desktop/Controls/comboboxex-control-reference">ComboBoxEx</a> control.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * The flags to control the operation of <b>SHAutoComplete</b>. The first four flags are used to override the Internet Explorer registry settings. The user can change these settings manually by launching the <b>Internet Options</b> property sheet from the <b>Tools</b> menu and clicking the <b>Advanced</b> tab.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shautocomplete
     * @since windows5.0
     */
    static SHAutoComplete(hwndEdit, dwFlags) {
        hwndEdit := hwndEdit is Win32Handle ? NumGet(hwndEdit, "ptr") : hwndEdit

        result := DllCall("SHLWAPI.dll\SHAutoComplete", "ptr", hwndEdit, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a per-thread reference to a Component Object Model (COM) object.
     * @param {Pointer<Integer>} pcRef Type: <b>LONG*</b>
     * 
     * A pointer to a value, usually a local variable in the thread's <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>, that is used by the interface in <i>ppunk</i> as a reference counter.
     * @returns {IUnknown} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>**</b>
     * 
     * The address of a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> interface. If successful, this parameter holds the thread's <b>IUnknown</b> pointer on return. Your application is responsible for freeing the pointer when it is finished.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcreatethreadref
     * @since windows5.1.2600
     */
    static SHCreateThreadRef(pcRef) {
        pcRefMarshal := pcRef is VarRef ? "int*" : "ptr"

        result := DllCall("SHLWAPI.dll\SHCreateThreadRef", pcRefMarshal, pcRef, "ptr*", &ppunk := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IUnknown(ppunk)
    }

    /**
     * Stores a per-thread reference to a Component Object Model (COM) object. This allows the caller to control the thread's lifetime so that it can ensure that Windows won't shut down the thread before the caller is ready.
     * @param {IUnknown} punk Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a> of the object for which you want to store a reference. This value can be <b>NULL</b>.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shsetthreadref
     * @since windows5.0
     */
    static SHSetThreadRef(punk) {
        result := DllCall("SHLWAPI.dll\SHSetThreadRef", "ptr", punk, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the per-thread object reference set by SHSetThreadRef.
     * @returns {IUnknown} Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown">IUnknown</a>**</b>
     * 
     * The address of a pointer that, when this function returns successfully, points to the object whose reference is stored. Your application is responsible for freeing this resource when it is no longer needed.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shgetthreadref
     * @since windows5.0
     */
    static SHGetThreadRef() {
        result := DllCall("SHLWAPI.dll\SHGetThreadRef", "ptr*", &ppunk := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IUnknown(ppunk)
    }

    /**
     * Checks a bind context to see if it is safe to bind to a particular component object.
     * @param {IBindCtx} pbc Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-ibindctx">IBindCtx</a> interface that specifies the bind context you want to check. This value can be <b>NULL</b>.
     * @param {Pointer<Guid>} pclsid Type: <b>const CLSID*</b>
     * 
     * A pointer to a variable that specifies the <b>CLSID</b> of the object being tested to see if it must be skipped. Typically, this is the CLSID of the object that <a href="https://docs.microsoft.com/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject">IShellFolder::BindToObject</a> is about to create.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the object specified by <i>pclsid</i> must be skipped, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shskipjunction
     * @since windows5.0
     */
    static SHSkipJunction(pbc, pclsid) {
        result := DllCall("SHLWAPI.dll\SHSkipJunction", "ptr", pbc, "ptr", pclsid, "int")
        return result
    }

    /**
     * Creates a thread.
     * @param {Pointer<LPTHREAD_START_ROUTINE>} pfnThreadProc Type: <b>LPTHREAD_START_ROUTINE</b>
     * 
     * A pointer to an application-defined function of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a> type. If a new thread was successfully created, this application-defined function is called in the context of that thread. <b>SHCreateThread</b> does not wait for the function pointed to by this parameter to complete before returning to its caller.  The application-defined function's return value is the exit code of the thread.
     * @param {Pointer<Void>} pData Type: <b>void*</b>
     * 
     * A pointer to an optional application-defined data structure that contains initialization data. It is passed to the function pointed to by <i>pfnThreadProc</i> and, optionally, <i>pfnCallback</i>. This value can be <b>NULL</b>.
     * @param {Integer} flags Type: <b>SHCT_FLAGS</b>
     * 
     * The flags that control the behavior of the function. One or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/ctf">CTF</a> constants.
     * @param {Pointer<LPTHREAD_START_ROUTINE>} pfnCallback Type: <b>LPTHREAD_START_ROUTINE</b>
     * 
     * A pointer to an optional application-defined function of the 
     * 				 <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a> type. This function is called 
     * 				 in the context of the created thread before the function pointed to by 
     * 				 <i>pfnThreadProc</i> is called. It will also receive <i>pData</i> as 
     * 				 its argument. <b>SHCreateThread</b> will wait for the 
     * 				 function pointed to by <i>pfnCallback</i> to return before returning to its caller. The 
     * 				 return value of the function pointed to by <i>pfnCallback</i> is ignored.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if the thread is successfully created, or <b>FALSE</b> otherwise. On failure, use <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to retrieve the specific error value as shown here.
     * 
     *                     
     * 
     * 
     * ```
     * if (!SHCreateThread(...))
     * {
     *     hr = HRESULT_FROM_WIN32( GetLastError() );
     * }
     * else
     * {
     *     ....
     * }
     * ```
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcreatethread
     * @since windows5.0
     */
    static SHCreateThread(pfnThreadProc, pData, flags, pfnCallback) {
        pDataMarshal := pData is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\SHCreateThread", "ptr", pfnThreadProc, pDataMarshal, pData, "uint", flags, "ptr", pfnCallback, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a new thread and retrieves its handle.
     * @param {Pointer<LPTHREAD_START_ROUTINE>} pfnThreadProc Type: <b>LPTHREAD_START_ROUTINE</b>
     * 
     * A pointer to an application-defined function of type <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a>. If a new thread was successfully created, this application-defined function is called in the context of that thread. <b>SHCreateThreadWithHandle</b> does not wait for the function pointed to by <i>pfnThreadProc</i> to complete before returning to its caller. The return value for the function specified by <i>pfnThreadProc</i> is the exit code of the thread.
     * @param {Pointer<Void>} pData Type: <b>void*</b>
     * 
     * A pointer to an optional application-defined data structure that contains initialization data. It is passed to the function pointed to by <i>pfnThreadProc</i> and, optionally, the function pointed to by <i>pfnCallback</i>.
     * @param {Integer} flags Type: <b>SHCT_FLAGS</b>
     * 
     * Flags that control the behavior of the function; one or more of the <a href="https://docs.microsoft.com/windows/desktop/shell/ctf">CTF</a> constants.
     * @param {Pointer<LPTHREAD_START_ROUTINE>} pfnCallback Type: <b>LPTHREAD_START_ROUTINE</b>
     * 
     * A pointer to an optional application-defined function of type <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a>. This function is called in the context of the created thread before the function pointed to by <i>pfnThreadProc</i> is called. It will also receive <i>pData</i> as its argument. <b>SHCreateThreadWithHandle</b> waits for the function pointed to by <i>pfnCallback</i> to complete before returning to its caller. The return value for the function specified by <i>pfnCallback</i> is ignored.
     * @param {Pointer<HANDLE>} pHandle Type: <b>HANDLE*</b>
     * 
     * A pointer to the <b>HANDLE</b> of the created thread. When it is no longer needed, this handle should be closed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function. This value can be <b>NULL</b>.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the thread is successfully created; otherwise, <b>FALSE</b>
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcreatethreadwithhandle
     * @since windows6.0.6000
     */
    static SHCreateThreadWithHandle(pfnThreadProc, pData, flags, pfnCallback, pHandle) {
        pDataMarshal := pData is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("SHLWAPI.dll\SHCreateThreadWithHandle", "ptr", pfnThreadProc, pDataMarshal, pData, "uint", flags, "ptr", pfnCallback, "ptr", pHandle, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Releases a thread reference before the thread procedure returns.
     * @returns {HRESULT} Type: <b>HRESULT</b>
     * 
     * If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shreleasethreadref
     * @since windows5.1.2600
     */
    static SHReleaseThreadRef() {
        result := DllCall("SHLWAPI.dll\SHReleaseThreadRef", "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a halftone palette for the specified device context.
     * @param {HDC} hdc Type: <b>HDC</b>
     * 
     * The device context.
     * @returns {HPALETTE} Type: <b>HPALETTE</b>
     * 
     * Returns the palette if successful; otherwise 0.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-shcreateshellpalette
     * @since windows5.0
     */
    static SHCreateShellPalette(hdc) {
        hdc := hdc is Win32Handle ? NumGet(hdc, "ptr") : hdc

        result := DllCall("SHLWAPI.dll\SHCreateShellPalette", "ptr", hdc, "ptr")
        resultHandle := HPALETTE({Value: result}, True)
        return resultHandle
    }

    /**
     * Converts colors from RGB to hue-luminance-saturation (HLS) format.
     * @param {COLORREF} clrRGB Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * The original RGB color.
     * @param {Pointer<Integer>} pwHue Type: <b>WORD*</b>
     * 
     * A pointer to a value that, when this method returns successfully, receives the HLS hue value.
     * @param {Pointer<Integer>} pwLuminance Type: <b>WORD*</b>
     * 
     * A pointer to a value that, when this method returns successfully, receives the HLS luminance value.
     * @param {Pointer<Integer>} pwSaturation Type: <b>WORD*</b>
     * 
     * A pointer to a value that, when this method returns successfully, receives the HLS saturation value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-colorrgbtohls
     * @since windows5.0
     */
    static ColorRGBToHLS(clrRGB, pwHue, pwLuminance, pwSaturation) {
        pwHueMarshal := pwHue is VarRef ? "ushort*" : "ptr"
        pwLuminanceMarshal := pwLuminance is VarRef ? "ushort*" : "ptr"
        pwSaturationMarshal := pwSaturation is VarRef ? "ushort*" : "ptr"

        DllCall("SHLWAPI.dll\ColorRGBToHLS", "uint", clrRGB, pwHueMarshal, pwHue, pwLuminanceMarshal, pwLuminance, pwSaturationMarshal, pwSaturation)
    }

    /**
     * Converts colors from hue-luminance-saturation (HLS) to RGB format.
     * @param {Integer} wHue Type: <b>WORD</b>
     * 
     * The original HLS hue value.
     * @param {Integer} wLuminance Type: <b>WORD</b>
     * 
     * The original HLS luminance value.
     * @param {Integer} wSaturation Type: <b>WORD</b>
     * 
     * The original HLS saturation value.
     * @returns {COLORREF} Type: <b><a href="/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * Returns the RGB value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-colorhlstorgb
     * @since windows5.0
     */
    static ColorHLSToRGB(wHue, wLuminance, wSaturation) {
        result := DllCall("SHLWAPI.dll\ColorHLSToRGB", "ushort", wHue, "ushort", wLuminance, "ushort", wSaturation, "uint")
        return result
    }

    /**
     * Changes the luminance of a RGB value. Hue and saturation are not affected.
     * @param {COLORREF} clrRGB Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * The initial RGB value.
     * @param {Integer} n Type: <b>int</b>
     * 
     * The luminance in units of 0.1 percent of the total range. For example, a value of <i>n</i> = 50 corresponds to 5 percent of the maximum luminance.
     * @param {BOOL} fScale Type: <b>BOOL</b>
     * 
     * If <i>fScale</i> is set to <b>TRUE</b>, <i>n</i> specifies how much to increment or decrement the current luminance. If <i>fScale</i> is set to <b>FALSE</b>, <i>n</i> specifies the absolute luminance.
     * @returns {COLORREF} Type: <b><a href="/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * Returns the modified RGB value.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-coloradjustluma
     * @since windows5.0
     */
    static ColorAdjustLuma(clrRGB, n, fScale) {
        result := DllCall("SHLWAPI.dll\ColorAdjustLuma", "uint", clrRGB, "int", n, "int", fScale, "uint")
        return result
    }

    /**
     * Determines whether Windows Internet Explorer is in the Enhanced Security Configuration.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * Returns <b>TRUE</b> if Internet Explorer is in the Enhanced Security Configuration, and <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//shlwapi/nf-shlwapi-isinternetescenabled
     * @since windows5.1.2600
     */
    static IsInternetESCEnabled() {
        result := DllCall("SHLWAPI.dll\IsInternetESCEnabled", "int")
        return result
    }

    /**
     * 
     * @param {IMoniker} pimkTrgt 
     * @param {PWSTR} pwzLocation 
     * @param {PWSTR} pwzFriendlyName 
     * @param {IHlinkSite} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {IUnknown} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @returns {Pointer<Void>} 
     */
    static HlinkCreateFromMoniker(pimkTrgt, pwzLocation, pwzFriendlyName, pihlsite, dwSiteData, piunkOuter, riid) {
        pwzLocation := pwzLocation is String ? StrPtr(pwzLocation) : pwzLocation
        pwzFriendlyName := pwzFriendlyName is String ? StrPtr(pwzFriendlyName) : pwzFriendlyName

        result := DllCall("hlink.dll\HlinkCreateFromMoniker", "ptr", pimkTrgt, "ptr", pwzLocation, "ptr", pwzFriendlyName, "ptr", pihlsite, "uint", dwSiteData, "ptr", piunkOuter, "ptr", riid, "ptr*", &ppvObj := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvObj
    }

    /**
     * 
     * @param {PWSTR} pwzTarget 
     * @param {PWSTR} pwzLocation 
     * @param {PWSTR} pwzFriendlyName 
     * @param {IHlinkSite} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {IUnknown} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @returns {Pointer<Void>} 
     */
    static HlinkCreateFromString(pwzTarget, pwzLocation, pwzFriendlyName, pihlsite, dwSiteData, piunkOuter, riid) {
        pwzTarget := pwzTarget is String ? StrPtr(pwzTarget) : pwzTarget
        pwzLocation := pwzLocation is String ? StrPtr(pwzLocation) : pwzLocation
        pwzFriendlyName := pwzFriendlyName is String ? StrPtr(pwzFriendlyName) : pwzFriendlyName

        result := DllCall("hlink.dll\HlinkCreateFromString", "ptr", pwzTarget, "ptr", pwzLocation, "ptr", pwzFriendlyName, "ptr", pihlsite, "uint", dwSiteData, "ptr", piunkOuter, "ptr", riid, "ptr*", &ppvObj := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvObj
    }

    /**
     * 
     * @param {IDataObject} piDataObj 
     * @param {IHlinkSite} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {IUnknown} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @returns {Pointer<Void>} 
     */
    static HlinkCreateFromData(piDataObj, pihlsite, dwSiteData, piunkOuter, riid) {
        result := DllCall("hlink.dll\HlinkCreateFromData", "ptr", piDataObj, "ptr", pihlsite, "uint", dwSiteData, "ptr", piunkOuter, "ptr", riid, "ptr*", &ppvObj := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvObj
    }

    /**
     * 
     * @param {IDataObject} piDataObj 
     * @returns {HRESULT} 
     */
    static HlinkQueryCreateFromData(piDataObj) {
        result := DllCall("hlink.dll\HlinkQueryCreateFromData", "ptr", piDataObj, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {IHlink} pihl 
     * @param {Pointer<Guid>} riid 
     * @param {IHlinkSite} pihlsiteForClone 
     * @param {Integer} dwSiteData 
     * @returns {Pointer<Void>} 
     */
    static HlinkClone(pihl, riid, pihlsiteForClone, dwSiteData) {
        result := DllCall("hlink.dll\HlinkClone", "ptr", pihl, "ptr", riid, "ptr", pihlsiteForClone, "uint", dwSiteData, "ptr*", &ppvObj := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvObj
    }

    /**
     * 
     * @param {IUnknown} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @returns {Pointer<Void>} 
     */
    static HlinkCreateBrowseContext(piunkOuter, riid) {
        result := DllCall("hlink.dll\HlinkCreateBrowseContext", "ptr", piunkOuter, "ptr", riid, "ptr*", &ppvObj := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvObj
    }

    /**
     * 
     * @param {PWSTR} pwzTarget 
     * @param {PWSTR} pwzLocation 
     * @param {IHlinkSite} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {IHlinkFrame} pihlframe 
     * @param {Integer} grfHLNF 
     * @param {IBindCtx} pibc 
     * @param {IBindStatusCallback} pibsc 
     * @param {IHlinkBrowseContext} pihlbc 
     * @returns {HRESULT} 
     */
    static HlinkNavigateToStringReference(pwzTarget, pwzLocation, pihlsite, dwSiteData, pihlframe, grfHLNF, pibc, pibsc, pihlbc) {
        pwzTarget := pwzTarget is String ? StrPtr(pwzTarget) : pwzTarget
        pwzLocation := pwzLocation is String ? StrPtr(pwzLocation) : pwzLocation

        result := DllCall("hlink.dll\HlinkNavigateToStringReference", "ptr", pwzTarget, "ptr", pwzLocation, "ptr", pihlsite, "uint", dwSiteData, "ptr", pihlframe, "uint", grfHLNF, "ptr", pibc, "ptr", pibsc, "ptr", pihlbc, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {IHlink} pihl 
     * @param {IHlinkFrame} pihlframe 
     * @param {Integer} grfHLNF 
     * @param {IBindCtx} pbc 
     * @param {IBindStatusCallback} pibsc 
     * @param {IHlinkBrowseContext} pihlbc 
     * @returns {HRESULT} 
     */
    static HlinkNavigate(pihl, pihlframe, grfHLNF, pbc, pibsc, pihlbc) {
        result := DllCall("hlink.dll\HlinkNavigate", "ptr", pihl, "ptr", pihlframe, "uint", grfHLNF, "ptr", pbc, "ptr", pibsc, "ptr", pihlbc, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {IHlinkFrame} pihlframe 
     * @param {IHlinkBrowseContext} pihlbc 
     * @param {Integer} grfHLNF 
     * @param {IMoniker} pimkTarget 
     * @param {PWSTR} pwzLocation 
     * @param {PWSTR} pwzFriendlyName 
     * @param {Pointer<Integer>} puHLID 
     * @returns {HRESULT} 
     */
    static HlinkOnNavigate(pihlframe, pihlbc, grfHLNF, pimkTarget, pwzLocation, pwzFriendlyName, puHLID) {
        pwzLocation := pwzLocation is String ? StrPtr(pwzLocation) : pwzLocation
        pwzFriendlyName := pwzFriendlyName is String ? StrPtr(pwzFriendlyName) : pwzFriendlyName

        puHLIDMarshal := puHLID is VarRef ? "uint*" : "ptr"

        result := DllCall("hlink.dll\HlinkOnNavigate", "ptr", pihlframe, "ptr", pihlbc, "uint", grfHLNF, "ptr", pimkTarget, "ptr", pwzLocation, "ptr", pwzFriendlyName, puHLIDMarshal, puHLID, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {IHlinkFrame} pihlframe 
     * @param {IHlinkBrowseContext} pihlbc 
     * @param {Integer} uHLID 
     * @param {IMoniker} pimkTrgt 
     * @param {PWSTR} pwzLocation 
     * @param {PWSTR} pwzFriendlyName 
     * @returns {HRESULT} 
     */
    static HlinkUpdateStackItem(pihlframe, pihlbc, uHLID, pimkTrgt, pwzLocation, pwzFriendlyName) {
        pwzLocation := pwzLocation is String ? StrPtr(pwzLocation) : pwzLocation
        pwzFriendlyName := pwzFriendlyName is String ? StrPtr(pwzFriendlyName) : pwzFriendlyName

        result := DllCall("hlink.dll\HlinkUpdateStackItem", "ptr", pihlframe, "ptr", pihlbc, "uint", uHLID, "ptr", pimkTrgt, "ptr", pwzLocation, "ptr", pwzFriendlyName, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Integer} dwReserved 
     * @param {IHlinkBrowseContext} pihlbc 
     * @param {IMoniker} pimkOld 
     * @param {IMoniker} pimkNew 
     * @returns {HRESULT} 
     */
    static HlinkOnRenameDocument(dwReserved, pihlbc, pimkOld, pimkNew) {
        result := DllCall("hlink.dll\HlinkOnRenameDocument", "uint", dwReserved, "ptr", pihlbc, "ptr", pimkOld, "ptr", pimkNew, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {IMoniker} pimkReference 
     * @param {Integer} reserved 
     * @param {IBindCtx} pibc 
     * @param {Integer} cFmtetc 
     * @param {Pointer<FORMATETC>} rgFmtetc 
     * @param {IBindStatusCallback} pibsc 
     * @param {IMoniker} pimkBase 
     * @returns {HRESULT} 
     */
    static HlinkResolveMonikerForData(pimkReference, reserved, pibc, cFmtetc, rgFmtetc, pibsc, pimkBase) {
        result := DllCall("hlink.dll\HlinkResolveMonikerForData", "ptr", pimkReference, "uint", reserved, "ptr", pibc, "uint", cFmtetc, "ptr", rgFmtetc, "ptr", pibsc, "ptr", pimkBase, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {PWSTR} pwzReference 
     * @param {Integer} reserved 
     * @param {IBindCtx} pibc 
     * @param {Integer} cFmtetc 
     * @param {Pointer<FORMATETC>} rgFmtetc 
     * @param {IBindStatusCallback} pibsc 
     * @param {IMoniker} pimkBase 
     * @returns {HRESULT} 
     */
    static HlinkResolveStringForData(pwzReference, reserved, pibc, cFmtetc, rgFmtetc, pibsc, pimkBase) {
        pwzReference := pwzReference is String ? StrPtr(pwzReference) : pwzReference

        result := DllCall("hlink.dll\HlinkResolveStringForData", "ptr", pwzReference, "uint", reserved, "ptr", pibc, "uint", cFmtetc, "ptr", rgFmtetc, "ptr", pibsc, "ptr", pimkBase, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {IBindCtx} pibc 
     * @param {PWSTR} pwzDisplayName 
     * @param {BOOL} fNoForceAbs 
     * @param {Pointer<Integer>} pcchEaten 
     * @returns {IMoniker} 
     */
    static HlinkParseDisplayName(pibc, pwzDisplayName, fNoForceAbs, pcchEaten) {
        pwzDisplayName := pwzDisplayName is String ? StrPtr(pwzDisplayName) : pwzDisplayName

        pcchEatenMarshal := pcchEaten is VarRef ? "uint*" : "ptr"

        result := DllCall("hlink.dll\HlinkParseDisplayName", "ptr", pibc, "ptr", pwzDisplayName, "int", fNoForceAbs, pcchEatenMarshal, pcchEaten, "ptr*", &ppimk := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IMoniker(ppimk)
    }

    /**
     * 
     * @param {PWSTR} pwzAdditionalHeaders 
     * @param {HWND} phwnd 
     * @param {PWSTR} pszUsername 
     * @param {PWSTR} pszPassword 
     * @param {IUnknown} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @returns {Pointer<Void>} 
     */
    static HlinkCreateExtensionServices(pwzAdditionalHeaders, phwnd, pszUsername, pszPassword, piunkOuter, riid) {
        pwzAdditionalHeaders := pwzAdditionalHeaders is String ? StrPtr(pwzAdditionalHeaders) : pwzAdditionalHeaders
        phwnd := phwnd is Win32Handle ? NumGet(phwnd, "ptr") : phwnd
        pszUsername := pszUsername is String ? StrPtr(pszUsername) : pszUsername
        pszPassword := pszPassword is String ? StrPtr(pszPassword) : pszPassword

        result := DllCall("hlink.dll\HlinkCreateExtensionServices", "ptr", pwzAdditionalHeaders, "ptr", phwnd, "ptr", pszUsername, "ptr", pszPassword, "ptr", piunkOuter, "ptr", riid, "ptr*", &ppvObj := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvObj
    }

    /**
     * 
     * @param {IBindCtx} pibc 
     * @param {IMoniker} pimkIn 
     * @returns {IMoniker} 
     */
    static HlinkPreprocessMoniker(pibc, pimkIn) {
        result := DllCall("hlink.dll\HlinkPreprocessMoniker", "ptr", pibc, "ptr", pimkIn, "ptr*", &ppimkOut := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return IMoniker(ppimkOut)
    }

    /**
     * 
     * @param {IUnknown} piunk 
     * @param {IStream} pistm 
     * @param {BOOL} fClearDirty 
     * @returns {HRESULT} 
     */
    static OleSaveToStreamEx(piunk, pistm, fClearDirty) {
        result := DllCall("hlink.dll\OleSaveToStreamEx", "ptr", piunk, "ptr", pistm, "int", fClearDirty, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Integer} uReference 
     * @param {PWSTR} pwzReference 
     * @returns {HRESULT} 
     */
    static HlinkSetSpecialReference(uReference, pwzReference) {
        pwzReference := pwzReference is String ? StrPtr(pwzReference) : pwzReference

        result := DllCall("hlink.dll\HlinkSetSpecialReference", "uint", uReference, "ptr", pwzReference, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Integer} uReference 
     * @returns {PWSTR} 
     */
    static HlinkGetSpecialReference(uReference) {
        result := DllCall("hlink.dll\HlinkGetSpecialReference", "uint", uReference, "ptr*", &ppwzReference := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppwzReference
    }

    /**
     * 
     * @param {Integer} grfHLSHORTCUTF 
     * @param {IHlink} pihl 
     * @param {PWSTR} pwzDir 
     * @param {PWSTR} pwzFileName 
     * @param {Integer} dwReserved 
     * @returns {PWSTR} 
     */
    static HlinkCreateShortcut(grfHLSHORTCUTF, pihl, pwzDir, pwzFileName, dwReserved) {
        pwzDir := pwzDir is String ? StrPtr(pwzDir) : pwzDir
        pwzFileName := pwzFileName is String ? StrPtr(pwzFileName) : pwzFileName

        result := DllCall("hlink.dll\HlinkCreateShortcut", "uint", grfHLSHORTCUTF, "ptr", pihl, "ptr", pwzDir, "ptr", pwzFileName, "ptr*", &ppwzShortcutFile := 0, "uint", dwReserved, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppwzShortcutFile
    }

    /**
     * 
     * @param {Integer} grfHLSHORTCUTF 
     * @param {IMoniker} pimkTarget 
     * @param {PWSTR} pwzLocation 
     * @param {PWSTR} pwzDir 
     * @param {PWSTR} pwzFileName 
     * @param {Integer} dwReserved 
     * @returns {PWSTR} 
     */
    static HlinkCreateShortcutFromMoniker(grfHLSHORTCUTF, pimkTarget, pwzLocation, pwzDir, pwzFileName, dwReserved) {
        pwzLocation := pwzLocation is String ? StrPtr(pwzLocation) : pwzLocation
        pwzDir := pwzDir is String ? StrPtr(pwzDir) : pwzDir
        pwzFileName := pwzFileName is String ? StrPtr(pwzFileName) : pwzFileName

        result := DllCall("hlink.dll\HlinkCreateShortcutFromMoniker", "uint", grfHLSHORTCUTF, "ptr", pimkTarget, "ptr", pwzLocation, "ptr", pwzDir, "ptr", pwzFileName, "ptr*", &ppwzShortcutFile := 0, "uint", dwReserved, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppwzShortcutFile
    }

    /**
     * 
     * @param {Integer} grfHLSHORTCUTF 
     * @param {PWSTR} pwzTarget 
     * @param {PWSTR} pwzLocation 
     * @param {PWSTR} pwzDir 
     * @param {PWSTR} pwzFileName 
     * @param {Integer} dwReserved 
     * @returns {PWSTR} 
     */
    static HlinkCreateShortcutFromString(grfHLSHORTCUTF, pwzTarget, pwzLocation, pwzDir, pwzFileName, dwReserved) {
        pwzTarget := pwzTarget is String ? StrPtr(pwzTarget) : pwzTarget
        pwzLocation := pwzLocation is String ? StrPtr(pwzLocation) : pwzLocation
        pwzDir := pwzDir is String ? StrPtr(pwzDir) : pwzDir
        pwzFileName := pwzFileName is String ? StrPtr(pwzFileName) : pwzFileName

        result := DllCall("hlink.dll\HlinkCreateShortcutFromString", "uint", grfHLSHORTCUTF, "ptr", pwzTarget, "ptr", pwzLocation, "ptr", pwzDir, "ptr", pwzFileName, "ptr*", &ppwzShortcutFile := 0, "uint", dwReserved, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppwzShortcutFile
    }

    /**
     * 
     * @param {PWSTR} pwzShortcutFileName 
     * @param {IHlinkSite} pihlsite 
     * @param {Integer} dwSiteData 
     * @param {IUnknown} piunkOuter 
     * @param {Pointer<Guid>} riid 
     * @param {Pointer<Pointer<Void>>} ppvObj 
     * @returns {HRESULT} 
     */
    static HlinkResolveShortcut(pwzShortcutFileName, pihlsite, dwSiteData, piunkOuter, riid, ppvObj) {
        pwzShortcutFileName := pwzShortcutFileName is String ? StrPtr(pwzShortcutFileName) : pwzShortcutFileName

        ppvObjMarshal := ppvObj is VarRef ? "ptr*" : "ptr"

        result := DllCall("hlink.dll\HlinkResolveShortcut", "ptr", pwzShortcutFileName, "ptr", pihlsite, "uint", dwSiteData, "ptr", piunkOuter, "ptr", riid, ppvObjMarshal, ppvObj, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {PWSTR} pwzShortcutFileName 
     * @param {Pointer<IMoniker>} ppimkTarget 
     * @param {Pointer<PWSTR>} ppwzLocation 
     * @returns {HRESULT} 
     */
    static HlinkResolveShortcutToMoniker(pwzShortcutFileName, ppimkTarget, ppwzLocation) {
        pwzShortcutFileName := pwzShortcutFileName is String ? StrPtr(pwzShortcutFileName) : pwzShortcutFileName

        ppwzLocationMarshal := ppwzLocation is VarRef ? "ptr*" : "ptr"

        result := DllCall("hlink.dll\HlinkResolveShortcutToMoniker", "ptr", pwzShortcutFileName, "ptr*", ppimkTarget, ppwzLocationMarshal, ppwzLocation, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {PWSTR} pwzShortcutFileName 
     * @param {Pointer<PWSTR>} ppwzTarget 
     * @param {Pointer<PWSTR>} ppwzLocation 
     * @returns {HRESULT} 
     */
    static HlinkResolveShortcutToString(pwzShortcutFileName, ppwzTarget, ppwzLocation) {
        pwzShortcutFileName := pwzShortcutFileName is String ? StrPtr(pwzShortcutFileName) : pwzShortcutFileName

        ppwzTargetMarshal := ppwzTarget is VarRef ? "ptr*" : "ptr"
        ppwzLocationMarshal := ppwzLocation is VarRef ? "ptr*" : "ptr"

        result := DllCall("hlink.dll\HlinkResolveShortcutToString", "ptr", pwzShortcutFileName, ppwzTargetMarshal, ppwzTarget, ppwzLocationMarshal, ppwzLocation, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {PWSTR} pwzFileName 
     * @returns {HRESULT} 
     */
    static HlinkIsShortcut(pwzFileName) {
        pwzFileName := pwzFileName is String ? StrPtr(pwzFileName) : pwzFileName

        result := DllCall("hlink.dll\HlinkIsShortcut", "ptr", pwzFileName, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {PWSTR} pwzParams 
     * @param {PWSTR} pwzName 
     * @returns {PWSTR} 
     */
    static HlinkGetValueFromParams(pwzParams, pwzName) {
        pwzParams := pwzParams is String ? StrPtr(pwzParams) : pwzParams
        pwzName := pwzName is String ? StrPtr(pwzName) : pwzName

        result := DllCall("hlink.dll\HlinkGetValueFromParams", "ptr", pwzParams, "ptr", pwzName, "ptr*", &ppwzValue := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppwzValue
    }

    /**
     * 
     * @param {PWSTR} pwzURL 
     * @param {Integer} grfFlags 
     * @returns {PWSTR} 
     */
    static HlinkTranslateURL(pwzURL, grfFlags) {
        pwzURL := pwzURL is String ? StrPtr(pwzURL) : pwzURL

        result := DllCall("hlink.dll\HlinkTranslateURL", "ptr", pwzURL, "uint", grfFlags, "ptr*", &ppwzTranslatedURL := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppwzTranslatedURL
    }

    /**
     * Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.This function differs from PathIsUNC in that it also allows you to extract the name of the server from the path.
     * @param {PWSTR} pszPath A pointer to the path string.
     * @param {Pointer<PWSTR>} ppszServer A pointer to a string that, when this function returns successfully, receives the server portion of the UNC path. This value can be <b>NULL</b> if you don't need this information.
     * @returns {BOOL} Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathisuncex
     * @since windows8.0
     */
    static PathIsUNCEx(pszPath, ppszServer) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        ppszServerMarshal := ppszServer is VarRef ? "ptr*" : "ptr"

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathIsUNCEx", "ptr", pszPath, ppszServerMarshal, ppszServer, "int")
        return result
    }

    /**
     * Determines whether a path string refers to the root of a volume.This function differs from PathIsRoot in that it accepts paths with &#0034;\\&#0034;, &#0034;\\?\&#0034; and &#0034;\\?\UNC\&#0034; prefixes.
     * @param {PWSTR} pszPath A pointer to the path string.
     * @returns {BOOL} Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchisroot
     * @since windows8.0
     */
    static PathCchIsRoot(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchIsRoot", "ptr", pszPath, "int")
        return result
    }

    /**
     * Adds a backslash to the end of a string to create the correct syntax for a path.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, the buffer contains the string with the appended backslash. This value should not be <b>NULL</b>.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<PWSTR>} ppszEnd A value that, when this function returns successfully, receives the address of a pointer to the terminating null character at the end of the string.
     * @param {Pointer<Pointer>} pcchRemaining A pointer to a value that, when this function returns successfully, is set to the number of unused characters in the destination buffer, including the terminating null character.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the path string already ends in a backslash, or an error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchaddbackslashex
     * @since windows8.0
     */
    static PathCchAddBackslashEx(pszPath, cchPath, ppszEnd, pcchRemaining) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        ppszEndMarshal := ppszEnd is VarRef ? "ptr*" : "ptr"
        pcchRemainingMarshal := pcchRemaining is VarRef ? "ptr*" : "ptr"

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAddBackslashEx", "ptr", pszPath, "ptr", cchPath, ppszEndMarshal, ppszEnd, pcchRemainingMarshal, pcchRemaining, "int")
        return result
    }

    /**
     * Adds a backslash to the end of a string to create the correct syntax for a path.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, the buffer contains the string with the appended backslash. This value should not be <b>NULL</b>.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the path string already ends in a backslash, or an error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchaddbackslash
     * @since windows8.0
     */
    static PathCchAddBackslash(pszPath, cchPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAddBackslash", "ptr", pszPath, "ptr", cchPath, "int")
        return result
    }

    /**
     * Removes the trailing backslash from the end of a path string.This function differs from PathCchRemoveBackslash in that it can return a pointer to the new end of the string and report the number of unused characters remaining in the buffer.This function differs from PathRemoveBackslash in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, the string contains the path with any trailing backslash removed. If no trailing backslash was found, the string is unchanged.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {Pointer<PWSTR>} ppszEnd A value that, when this function returns successfully, receives the address of a pointer to end of the new string. If the string is a root path such as "C:\", the pointer points to the backslash; otherwise the pointer points to the string's terminating null character.
     * @param {Pointer<Pointer>} pcchRemaining A pointer to a value that, when this function returns successfully, receives the number of unused characters in the destination buffer, including the terminating null character. If the string is a root path such as "C:\", this count includes the backslash in that string.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the string was a root path or if no backslash was found, or an error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchremovebackslashex
     * @since windows8.0
     */
    static PathCchRemoveBackslashEx(pszPath, cchPath, ppszEnd, pcchRemaining) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        ppszEndMarshal := ppszEnd is VarRef ? "ptr*" : "ptr"
        pcchRemainingMarshal := pcchRemaining is VarRef ? "ptr*" : "ptr"

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRemoveBackslashEx", "ptr", pszPath, "ptr", cchPath, ppszEndMarshal, ppszEnd, pcchRemainingMarshal, pcchRemaining, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Removes the trailing backslash from the end of a path string.This function differs from PathRemoveBackslash in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, the string contains the path with any trailing backslash removed. If no trailing backslash was found, the string is unchanged.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if the string was a root path or if no backslash was found, or an error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchremovebackslash
     * @since windows8.0
     */
    static PathCchRemoveBackslash(pszPath, cchPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRemoveBackslash", "ptr", pszPath, "ptr", cchPath, "int")
        return result
    }

    /**
     * Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.This function differs from PathSkipRoot in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPath A pointer to the path string.
     * @returns {PWSTR} The address of a pointer that, when this function returns successfully, points to the first character in a path following the drive letter or UNC server/share path elements. If the path consists of only a root, this value will point to the string's terminating null character.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchskiproot
     * @since windows8.0
     */
    static PathCchSkipRoot(pszPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchSkipRoot", "ptr", pszPath, "ptr*", &ppszRootEnd := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppszRootEnd
    }

    /**
     * Removes all file and directory elements in a path except for the root information.This function differs from PathStripToRoot in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, this string contains only the root information taken from that path.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the path was truncated, <b>S_FALSE</b> if the path was already just a root, or an <b>HRESULT</b> failure code.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchstriptoroot
     * @since windows8.0
     */
    static PathCchStripToRoot(pszPath, cchPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchStripToRoot", "ptr", pszPath, "ptr", cchPath, "int")
        return result
    }

    /**
     * Removes the last element in a path string, whether that element is a file name or a directory name.
     * @param {PWSTR} pszPath A pointer to the fully-qualified path string. When this function returns successfully, the string will have had its last element and its leading backslash removed. This function does not affect root paths such as "C:\". In the case of a root path, the path string is returned unaltered. If a path string ends with a trailing backslash, only that backslash is removed.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if there was nothing to remove, or an error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchremovefilespec
     * @since windows8.0
     */
    static PathCchRemoveFileSpec(pszPath, cchPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRemoveFileSpec", "ptr", pszPath, "ptr", cchPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Searches a path to find its file name extension, such as &quot;.exe&quot; or &quot;.ini&quot;.
     * @param {PWSTR} pszPath A pointer to the path to search.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {PWSTR} The address of a pointer that, when this function returns successfully, points to the "." character that precedes the extension within <i>pszPath</i>. If no extension is found, it points to the string's terminating null character.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchfindextension
     * @since windows8.0
     */
    static PathCchFindExtension(pszPath, cchPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchFindExtension", "ptr", pszPath, "ptr", cchPath, "ptr*", &ppszExt := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppszExt
    }

    /**
     * Adds a file name extension to a path string.This function differs from PathAddExtension in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, the buffer contains the string with the appended extension. This value should not be <b>NULL</b>.
     * 
     * <div class="alert"><b>Note</b>If the original string already has a file name extension present, no new extension will be added and the original string will be unchanged.</div>
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {PWSTR} pszExt A pointer to the file name extension string. This string can be given either with or without a preceding period (".ext" or "ext").
     * @returns {HRESULT} This function returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function succeeded. Note that this also includes the case of an empty extension, such as a period with no characters following it. In that case, the original string is returned unaltered.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value can be caused by several things, such as the <i>pszPath</i> param being set to <b>NULL</b>, the <i>cchPath</i> being set to 0 or a value greater than <b>PATHCCH_MAX_CCH</b>, or the extension string containing illegal characters or otherwise not being a valid extension.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The original string already has an extension.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer is too small to hold the returned string.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchaddextension
     * @since windows8.0
     */
    static PathCchAddExtension(pszPath, cchPath, pszExt) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String ? StrPtr(pszExt) : pszExt

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAddExtension", "ptr", pszPath, "ptr", cchPath, "ptr", pszExt, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Replaces a file name's extension at the end of a path string with a new extension.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, this value points to the same string, but with the renamed or added extension.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {PWSTR} pszExt A pointer to the new extension string. The leading '.' character is optional. In the case of an empty string (""), any existing extension in the path string is removed.
     * @returns {HRESULT} If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchrenameextension
     * @since windows8.0
     */
    static PathCchRenameExtension(pszPath, cchPath, pszExt) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszExt := pszExt is String ? StrPtr(pszExt) : pszExt

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRenameExtension", "ptr", pszPath, "ptr", cchPath, "ptr", pszExt, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Removes the file name extension from a path, if one is present.This function differs from PathRemoveExtension in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, the string contains the path with any extension removed. If no extension was found, the string is unchanged.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the function was successful, <b>S_FALSE</b> if no extension was found, or an error code otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchremoveextension
     * @since windows8.0
     */
    static PathCchRemoveExtension(pszPath, cchPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchRemoveExtension", "ptr", pszPath, "ptr", cchPath, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Simplifies a path by removing navigation elements such as &quot;.&quot; and &quot;..&quot; to produce a direct, well-formed path.This function differs from PathCchCanonicalize in that it allows for a longer final path to be constructed.This function differs from PathAllocCanonicalize in that the caller must declare the size of the returned string, which is stored on the stack.This function differs from PathCanonicalize in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPathOut A pointer to a buffer that, when this function returns successfully, receives the edited path string.
     * @param {Pointer} cchPathOut The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
     * @param {PWSTR} pszPathIn A pointer to the original path string. If this value is <b>NULL</b>, points to an empty string, or results in an empty string once the "." and ".." elements are removed, a single backslash is copied to the buffer pointed to by <i>pszPathOut</i>.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow the building of \\?\ paths longer than <b>MAX_PATH</b>. Note that <i>cchPathOut</i> must be greater than <b>MAX_PATH</b>. If it is not, this flag is ignored.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a id="____pathcch_ensure_trailing_slash"></a><dl>
     * <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including but not limited to the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>cchPathOut</i> value is greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A path segment has more than <b>PATHCCH_MAX_CCH</b> characters, or, if the <b>PATHCCH_ALLOW_LONG_PATHS</b> flag is not set, exceeds the standard path segment length limit of 256 characters.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate a buffer of the neccessary size.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchcanonicalizeex
     * @since windows8.0
     */
    static PathCchCanonicalizeEx(pszPathOut, cchPathOut, pszPathIn, dwFlags) {
        pszPathOut := pszPathOut is String ? StrPtr(pszPathOut) : pszPathOut
        pszPathIn := pszPathIn is String ? StrPtr(pszPathIn) : pszPathIn

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchCanonicalizeEx", "ptr", pszPathOut, "ptr", cchPathOut, "ptr", pszPathIn, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a path string into a canonical form.This function differs from PathCchCanonicalizeEx in that you are restricted to a final path of length MAX_PATH.This function differs from PathAllocCanonicalize in that the caller must declare the size of the returned string, which is stored on the stack.This function differs from PathCanonicalize in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPathOut A pointer to a buffer that, when this function returns successfully, receives the canonicalized path string.
     * @param {Pointer} cchPathOut The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
     * @param {PWSTR} pszPathIn A pointer to the original path string. If this value points to an empty string, or results in an empty string once the "." and ".." elements are removed, a single backslash is copied to the buffer pointed to by <i>pszPathOut</i>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>cchPathOut</i> value is greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A path segment exceeds the standard path segment length limit of 256 characters.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate a buffer of the neccessary size.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchcanonicalize
     * @since windows8.0
     */
    static PathCchCanonicalize(pszPathOut, cchPathOut, pszPathIn) {
        pszPathOut := pszPathOut is String ? StrPtr(pszPathOut) : pszPathOut
        pszPathIn := pszPathIn is String ? StrPtr(pszPathIn) : pszPathIn

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchCanonicalize", "ptr", pszPathOut, "ptr", cchPathOut, "ptr", pszPathIn, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Combines two path fragments into a single path.
     * @param {PWSTR} pszPathOut A pointer to a buffer that, when this function returns successfully, receives the combined path string. This parameter can point to the same buffer as <i>pszPathIn</i> or <i>pszMore</i>.
     * @param {Pointer} cchPathOut The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
     * @param {PWSTR} pszPathIn A pointer to the first path string. This value can be <b>NULL</b>.
     * @param {PWSTR} pszMore A pointer to the second path string. If this path begins with a single backslash, it is combined with only the root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualfied, it is copied directly to the output buffer without being combined with the other path. This value can be <b>NULL</b>.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow the construction of \\?\ paths longer than <b>MAX_PATH</b>. Note that <i>cchPathOut</i> must be greater than <b>MAX_PATH</b>. Note that <i>cchPathOut</i> must be greater than <b>MAX_PATH</b>. If it is not, this flag is ignored.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} This function returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function succeeded. Note that this also includes the case of an empty extension, such as a period with no characters following it. In that case, the original string is returned unaltered.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value can be caused by several things, such as the <i>pszPathOut</i> param being set to <b>NULL</b>, or the <i>cchPathOut</i> value being set to 0 or a value greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate enough memory to perform the operation.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of one or both of the original paths exceeded <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchcombineex
     * @since windows8.0
     */
    static PathCchCombineEx(pszPathOut, cchPathOut, pszPathIn, pszMore, dwFlags) {
        pszPathOut := pszPathOut is String ? StrPtr(pszPathOut) : pszPathOut
        pszPathIn := pszPathIn is String ? StrPtr(pszPathIn) : pszPathIn
        pszMore := pszMore is String ? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchCombineEx", "ptr", pszPathOut, "ptr", cchPathOut, "ptr", pszPathIn, "ptr", pszMore, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Combines two path fragments into a single path.
     * @param {PWSTR} pszPathOut A pointer to a buffer that, when this function returns successfully, receives the combined path string. This parameter can point to the same buffer as <i>pszPathIn</i> or <i>pszMore</i>.
     * @param {Pointer} cchPathOut The size of the buffer pointed to by <i>pszPathOut</i>, in characters.
     * @param {PWSTR} pszPathIn A pointer to the first path string. This value can be <b>NULL</b>.
     * @param {PWSTR} pszMore A pointer to the second path string. If this path begins with a single backslash, it is combined with only the root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualfied, it is copied directly to the output buffer without being combined with the other path. This value can be <b>NULL</b>.
     * @returns {HRESULT} This function returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function succeeded. Note that this also includes the case of an empty extension, such as a period with no characters following it. In that case, the original string is returned unaltered.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value can be caused by several things, such as the <i>pszPathOut</i> param being set to <b>NULL</b>, or the <i>cchPathOut</i> value being set to 0 or a value greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate enough memory to perform the operation.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of one or both of the original paths exceeded <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchcombine
     * @since windows8.0
     */
    static PathCchCombine(pszPathOut, cchPathOut, pszPathIn, pszMore) {
        pszPathOut := pszPathOut is String ? StrPtr(pszPathOut) : pszPathOut
        pszPathIn := pszPathIn is String ? StrPtr(pszPathIn) : pszPathIn
        pszMore := pszMore is String ? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchCombine", "ptr", pszPathOut, "ptr", cchPathOut, "ptr", pszPathIn, "ptr", pszMore, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Appends one path to the end of another.This function differs from PathCchAppend in that it allows for a longer final path to be constructed.This function differs from PathAppend in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPath A pointer to a buffer that, on entry, contains the original path. When this function returns successfully, the buffer contains the original path plus the appended path.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {PWSTR} pszMore A pointer the path to append to the end of the path pointed to by <i>pszPath</i>. UNC paths and paths that begin with the sequence \\?\ are accepted and recognized as fully-qualified paths. These paths replace the string pointed to by <i>pszPath</i> instead of being appended to it.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>. 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">Allow the building of \\?\ paths longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>. 
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the following. 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either <i>pszPath</i> or <i>pszMore</i> is <b>NULL</b>, <i>cchPath</i> is 0, or <i>cchPath</i> is greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The resulting string would exceed <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate a buffer of the neccessary size.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchappendex
     * @since windows8.0
     */
    static PathCchAppendEx(pszPath, cchPath, pszMore, dwFlags) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszMore := pszMore is String ? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAppendEx", "ptr", pszPath, "ptr", cchPath, "ptr", pszMore, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Appends one path to the end of another.This function differs from PathCchAppendEx in that you are restricted to a final path of length MAX_PATH.This function differs from PathAppend in that it accepts paths with &quot;\\&quot;, &quot;\\?\&quot; and &quot;\\?\UNC\&quot; prefixes.
     * @param {PWSTR} pszPath A pointer to a buffer that, on entry, contains the original path. When this function returns successfully, the buffer contains the original path plus the appended path.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @param {PWSTR} pszMore A pointer to the path to append to the end of the path pointed to by <i>pszPath</i>. UNC paths and paths beginning with the "\\?\" sequence are accepted and recognized as fully-qualified paths. These paths replace the string pointed to by <i>pszPath</i> instead of being appended to it.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> code, including the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either <i>pszPath</i> or <i>pszMore</i> is <b>NULL</b>, <i>cchPath</i> is 0, or <i>cchPath</i> is greater than <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>PATHCCH_E_FILENAME_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The resulting string would exceed <b>PATHCCH_MAX_CCH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function could not allocate a buffer of the neccessary size.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchappend
     * @since windows8.0
     */
    static PathCchAppend(pszPath, cchPath, pszMore) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath
        pszMore := pszMore is String ? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchAppend", "ptr", pszPath, "ptr", cchPath, "ptr", pszMore, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Removes the &quot;\\?\&quot; prefix, if present, from a file path.
     * @param {PWSTR} pszPath A pointer to the path string. When this function returns successfully, the same path string will have had the prefix removed, if the prefix was present. If no prefix was present, the string will be unchanged.
     * @param {Pointer} cchPath The size of the buffer pointed to by <i>pszPath</i>, in characters.
     * @returns {HRESULT} This function returns <b>S_OK</b> if the prefix was removed, <b>S_FALSE</b> if the path did not have a prefix to remove, or an <b>HRESULT</b> failure code.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathcchstripprefix
     * @since windows8.0
     */
    static PathCchStripPrefix(pszPath, cchPath) {
        pszPath := pszPath is String ? StrPtr(pszPath) : pszPath

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathCchStripPrefix", "ptr", pszPath, "ptr", cchPath, "int")
        return result
    }

    /**
     * Concatenates two path fragments into a single path.
     * @param {PWSTR} pszPathIn A pointer to the first path string.
     * @param {PWSTR} pszMore A pointer to the second path string. If this path begins with a single backslash, it is combined with only the root of the path pointed to by <i>pszPathIn</i>. If this path is fully qualified, it is copied directly to the output buffer without being combined with the other path.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">Allow the construction of \\?\ paths longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a id="____pathcch_ensure_trailing_slash"></a><dl>
     * <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @returns {PWSTR} The address of a pointer to a buffer that, when this function returns successfully, receives the combined path string. It is the responsibility of the caller to free this resource, when it is no longer needed, by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function. This value cannot be <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathalloccombine
     * @since windows8.0
     */
    static PathAllocCombine(pszPathIn, pszMore, dwFlags) {
        pszPathIn := pszPathIn is String ? StrPtr(pszPathIn) : pszPathIn
        pszMore := pszMore is String ? StrPtr(pszMore) : pszMore

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathAllocCombine", "ptr", pszPathIn, "ptr", pszMore, "uint", dwFlags, "ptr*", &ppszPathOut := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppszPathOut
    }

    /**
     * Converts a path string into a canonical form.This function differs from PathCchCanonicalize and PathCchCanonicalizeEx in that it returns the result on the heap.
     * @param {PWSTR} pszPathIn A pointer to a buffer that contains the original string. This value cannot be <b>NULL</b>.
     * @param {Integer} dwFlags One or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_NONE"></a><a id="____pathcch_none"></a><dl>
     * <dt><b>PATHCCH_NONE</b></dt>
     * <dt>0x0000000</dt>
     * </dl>
     * </td>
     * <td width="60%">Do not allow for the construction of \\?\ paths (ie, long paths) longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PATHCCH_ALLOW_LONG_PATHS"></a><a id="pathcch_allow_long_paths"></a><dl>
     * <dt><b>PATHCCH_ALLOW_LONG_PATHS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">Allow the building of \\?\ paths longer than <b>MAX_PATH</b>.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_enable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path enabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS"></a><a id="____pathcch_force_disable_long_name_process"></a><dl>
     * <dt><b>PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">Forces the API to treat the caller as long path disabled, independent of the process's long name enabled state. This option can be used only when <b>PATHCCH_ALLOW_LONG_PATHS</b> is specified, and cannot be used with <b>PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_DO_NOT_NORMALIZE_SEGMENTS"></a><a id="____pathcch_do_not_normalize_segments"></a><dl>
     * <dt><b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">Disables the normalization of path segments that includes removing trailing dots and spaces. This enables access to paths that win32 path normalization will block.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="________PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH"></a><a id="________pathcch_ensure_is_extended_length_path"></a><dl>
     * <dt><b>PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">Converts the input path into the extended length DOS device path form (with the \\?\ prefix) if not already in that form. This enables access to paths that are otherwise not addressable due to Win32 normalization rules (that can strip trailing dots and spaces) and path length limitations. This option implies the same behavior of <b>PATHCCH_DO_NOT_NORMALIZE_SEGMENTS</b>.
     * 
     * <b>Note</b>This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="____PATHCCH_ENSURE_TRAILING_SLASH"></a><a id="____pathcch_ensure_trailing_slash"></a><dl>
     * <dt><b>PATHCCH_ENSURE_TRAILING_SLASH</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">When combining or normalizing a path, ensure there is a trailing backslash.
     * 
     * <b>Note</b> This value is available starting in Windows10, version 1703.
     * </td>
     * </tr>
     * </table>
     * @returns {PWSTR} The address of a pointer to a buffer that, when this function returns successfully, receives the canonicalized path string. It is the responsibility of the caller to free this resource, when it is no longer needed, by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function. This value cannot be <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//pathcch/nf-pathcch-pathalloccanonicalize
     * @since windows8.0
     */
    static PathAllocCanonicalize(pszPathIn, dwFlags) {
        pszPathIn := pszPathIn is String ? StrPtr(pszPathIn) : pszPathIn

        result := DllCall("api-ms-win-core-path-l1-1-0.dll\PathAllocCanonicalize", "ptr", pszPathIn, "uint", dwFlags, "ptr*", &ppszPathOut := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppszPathOut
    }

    /**
     * Enables an app to register a callback function through which it can be notified that its library is going into or coming out of a suspended state.
     * @param {Pointer<PAPPSTATE_CHANGE_ROUTINE>} Routine A pointer to a callback function that is called when the app enters or leaves the suspended state. See <a href="https://docs.microsoft.com/windows/desktop/api/appnotify/nc-appnotify-pappstate_change_routine">PAPPSTATE_CHANGE_ROUTINE</a> for more detail on this function.
     * @param {Pointer<Void>} Context App-specific context information that the app uses when going into or out of a suspended state. This is commonly a "this" pointer.
     * @param {Pointer<PAPPSTATE_REGISTRATION>} Registration When this function returns successfully, this parameter receives the address of a pointer to a value that can be used to identify the registration. Store this value to use with <a href="https://docs.microsoft.com/windows/desktop/api/appnotify/nf-appnotify-unregisterappstatechangenotification">UnregisterAppStateChangeNotification</a>.
     * @returns {Integer} A standard Win32 status code.
     * @see https://docs.microsoft.com/windows/win32/api//appnotify/nf-appnotify-registerappstatechangenotification
     */
    static RegisterAppStateChangeNotification(Routine, Context, Registration) {
        ContextMarshal := Context is VarRef ? "ptr" : "ptr"
        RegistrationMarshal := Registration is VarRef ? "ptr*" : "ptr"

        result := DllCall("api-ms-win-core-psm-appnotify-l1-1-0.dll\RegisterAppStateChangeNotification", "ptr", Routine, ContextMarshal, Context, RegistrationMarshal, Registration, "uint")
        return result
    }

    /**
     * Cancels a change notification registered through RegisterAppStateChangeNotification.
     * @param {PAPPSTATE_REGISTRATION} Registration A pointer to the registration handle retrieved by <a href="https://docs.microsoft.com/windows/desktop/api/appnotify/nf-appnotify-registerappstatechangenotification">RegisterAppStateChangeNotification</a> through its <i>Registration</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//appnotify/nf-appnotify-unregisterappstatechangenotification
     */
    static UnregisterAppStateChangeNotification(Registration) {
        DllCall("api-ms-win-core-psm-appnotify-l1-1-0.dll\UnregisterAppStateChangeNotification", "ptr", Registration)
    }

    /**
     * 
     * @param {Pointer<PAPPCONSTRAIN_CHANGE_ROUTINE>} Routine 
     * @param {Pointer<Void>} Context 
     * @param {Pointer<PAPPCONSTRAIN_REGISTRATION>} Registration 
     * @returns {Integer} 
     */
    static RegisterAppConstrainedChangeNotification(Routine, Context, Registration) {
        ContextMarshal := Context is VarRef ? "ptr" : "ptr"
        RegistrationMarshal := Registration is VarRef ? "ptr*" : "ptr"

        result := DllCall("api-ms-win-core-psm-appnotify-l1-1-1.dll\RegisterAppConstrainedChangeNotification", "ptr", Routine, ContextMarshal, Context, RegistrationMarshal, Registration, "uint")
        return result
    }

    /**
     * 
     * @param {PAPPCONSTRAIN_REGISTRATION} Registration 
     * @returns {String} Nothing - always returns an empty string
     */
    static UnregisterAppConstrainedChangeNotification(Registration) {
        DllCall("api-ms-win-core-psm-appnotify-l1-1-1.dll\UnregisterAppConstrainedChangeNotification", "ptr", Registration)
    }

;@endregion Methods
}
